[
  {
    "task_id": "Java/1",
    "prompt": {
      "en": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "es": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calcular el saldo promedio de la cuenta basado en los saldos de cierre de los últimos doce meses.\n         *\n         * @param closingBalances Una lista de saldos de cierre de los últimos doce meses.\n         * @return El saldo promedio de la cuenta.\n         *\n         * Ejemplo:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Salida: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "arb": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * حساب متوسط رصيد الحساب بناءً على الأرصدة الختامية من الأشهر الاثني عشر الماضية.\n         *\n         * @param closingBalances قائمة بالأرصدة الختامية من الأشهر الاثني عشر الماضية.\n         * @return متوسط رصيد الحساب.\n         *\n         * مثال:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * الناتج: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "sw": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Hesabu wastani wa salio la akaunti kulingana na salio la kufunga kutoka miezi kumi na miwili iliyopita.\n         *\n         * @param closingBalances Orodha ya masalio ya kufunga kutoka miezi kumi na miwili iliyopita.\n         * @return Wastani wa salio la akaunti.\n         *\n         * Mfano:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "tr": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Geçmiş on iki aydaki kapanış bakiyelerine dayanarak ortalama hesap bakiyesini hesaplayın.\n         *\n         * @param closingBalances Geçmiş on iki aydaki kapanış bakiyelerinin bir listesi.\n         * @return Ortalama hesap bakiyesi.\n         *\n         * Örnek:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Çıktı: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "vi": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Tính toán số dư tài khoản trung bình dựa trên số dư cuối kỳ từ mười hai tháng qua.\n         *\n         * @param closingBalances Một danh sách các số dư cuối kỳ từ mười hai tháng qua.\n         * @return Số dư tài khoản trung bình.\n         *\n         * Ví dụ:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Ra: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)"
    },
    "prompt_bertscore": {
      "es": "0.9964468997440479",
      "arb": "0.9841927956468626",
      "sw": "0.9841927956468626",
      "tr": "0.9897355764296412",
      "vi": "1"
    },
    "canonical_solution": "    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }",
    "instruction": {
      "en": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة جافا باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8929344506449556",
      "sw": "0.9149216420432316",
      "tr": "0.8873082451021423",
      "vi": "0.9391058840861344"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "calculateAverageBalance",
    "signature": "public static double calculateAverageBalance(List<Double> closingBalances)",
    "docstring": {
      "en": "Calculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "es": "Calcular el saldo promedio de la cuenta basado en los saldos de cierre de los últimos doce meses.\n\n@param closingBalances Una lista de saldos de cierre de los últimos doce meses.\n@return El saldo promedio de la cuenta.\n\nEjemplo:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nSalida: 1581.42",
      "arb": "احسب متوسط رصيد الحساب بناءً على الأرصدة الختامية من الأشهر الاثني عشر الماضية.\n\n@param closingBalances قائمة بالأرصدة الختامية من الأشهر الاثني عشر الماضية.\n@return متوسط رصيد الحساب.\n\nمثال:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nالناتج: 1581.42",
      "sw": "Hesabu wastani wa salio la akaunti kulingana na salio la kufunga kutoka miezi kumi na miwili iliyopita.\n\n@param closingBalances Orodha ya salio la kufunga kutoka miezi kumi na miwili iliyopita.\n@return Wastani wa salio la akaunti.\n\nMfano:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nMatokeo: 1581.42",
      "tr": "Geçmiş on iki aydaki kapanış bakiyelerine göre ortalama hesap bakiyesini hesaplayın.\n\n@param closingBalances Geçmiş on iki aydaki kapanış bakiyelerinin bir listesi.\n@return Ortalama hesap bakiyesi.\n\nÖrnek:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nÇıktı: 1581.42",
      "vi": "Tính toán số dư tài khoản trung bình dựa trên số dư cuối kỳ từ mười hai tháng qua.\n\n@param closingBalances Một danh sách các số dư cuối kỳ từ mười hai tháng qua.\n@return Số dư tài khoản trung bình.\n\nVí dụ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nĐầu ra: 1581.42"
    },
    "docstring_bertscore": {
      "es": "0.993845437643634",
      "arb": "0.999999801369619",
      "sw": "0.9752901819688788",
      "tr": "0.9849781801734745",
      "vi": "0.999999801369619"
    }
  },
  {
    "task_id": "Java/2",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "es": "class Solution {\n    /**\n     * Dado un entero positivo Y que indica el año de inicio, y un entero positivo N,\n     * esta función encuentra el N-ésimo año bisiesto después del año de inicio Y.\n     *\n     * @param Y El año de inicio.\n     * @param N La posición del año bisiesto a encontrar.\n     * @return El N-ésimo año bisiesto después del año de inicio Y.\n     *\n     * Ejemplo:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى عدد صحيح موجب Y يشير إلى سنة البداية، وعدد صحيح موجب N،\n     * هذه الدالة تجد السنة الكبيسة رقم N بعد سنة البداية Y.\n     *\n     * @param Y سنة البداية.\n     * @param N موضع السنة الكبيسة المطلوب إيجادها.\n     * @return السنة الكبيسة رقم N بعد سنة البداية Y.\n     *\n     * مثال:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa nambari nzima chanya Y inayoashiria mwaka wa kuanza, na nambari nzima chanya N,\n     * kazi hii inapata mwaka wa N wa kuruka baada ya mwaka wa kuanza Y.\n     *\n     * @param Y Mwaka wa kuanza.\n     * @param N Nafasi ya mwaka wa kuruka wa kupata.\n     * @return Mwaka wa N wa kuruka baada ya mwaka wa kuanza Y.\n     *\n     * Mfano:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "tr": "class Solution {\n    /**\n     * Başlangıç yılı olarak Y pozitif tam sayısı ve N pozitif tam sayısı verildiğinde,\n     * bu fonksiyon başlangıç yılı Y'den sonraki N'inci artık yılı bulur.\n     *\n     * @param Y Başlangıç yılı.\n     * @param N Bulunacak artık yılın sırası.\n     * @return Başlangıç yılı Y'den sonraki N'inci artık yıl.\n     *\n     * Örnek:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "vi": "class Solution {\n    /**\n     * Cho một số nguyên dương Y chỉ năm bắt đầu, và một số nguyên dương N,\n     * hàm này tìm năm nhuận thứ N sau năm bắt đầu Y.\n     *\n     * @param Y Năm bắt đầu.\n     * @param N Vị trí của năm nhuận cần tìm.\n     * @return Năm nhuận thứ N sau năm bắt đầu Y.\n     *\n     * Ví dụ:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) "
    },
    "prompt_bertscore": {
      "es": "0.9844309534737234",
      "arb": "0.9837564046997289",
      "sw": "0.976737204294718",
      "tr": "0.9725043908748646",
      "vi": "0.976737204294718"
    },
    "canonical_solution": "    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }",
    "instruction": {
      "en": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9240008381299553",
      "sw": "0.9426256144380726",
      "tr": "0.8494602191478496",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "findNthLeapYear",
    "signature": "public static int findNthLeapYear(int Y, int N)",
    "docstring": {
      "en": "Given a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "es": "Dado un entero positivo Y que indica el año de inicio, y un entero positivo N, esta función encuentra el N-ésimo año bisiesto después del año de inicio Y.\n\n@param Y El año de inicio.\n@param N La posición del año bisiesto a encontrar.\n@return El N-ésimo año bisiesto después del año de inicio Y.\n\nEjemplo:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "arb": "تُعطى عدد صحيح موجب Y يشير إلى سنة البدء، وعدد صحيح موجب N، \nتقوم هذه الدالة بإيجاد السنة الكبيسة رقم N بعد سنة البدء Y.\n\n@param Y سنة البدء.\n@param N موقع السنة الكبيسة المراد إيجادها.\n@return السنة الكبيسة رقم N بعد سنة البدء Y.\n\nمثال:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "sw": "Kwa kuzingatia nambari chanya Y inayoashiria mwaka wa kuanza, na nambari chanya N, \nkazi hii inapata mwaka wa N wa kuruka baada ya mwaka wa kuanza Y.\n\n@param Y Mwaka wa kuanza.\n@param N Nafasi ya mwaka wa kuruka wa kupata.\n@return Mwaka wa N wa kuruka baada ya mwaka wa kuanza Y.\n\nMfano:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "tr": "Verilen bir pozitif tamsayı Y başlangıç yılını ve pozitif bir tamsayı N'yi belirtirken, bu fonksiyon başlangıç yılı Y'den sonraki N'inci artık yılı bulur.\n\n@param Y Başlangıç yılı.\n@param N Bulunacak artık yılın sırası.\n@return Başlangıç yılı Y'den sonraki N'inci artık yıl.\n\nÖrnek:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "vi": "Cho một số nguyên dương Y biểu thị năm bắt đầu, và một số nguyên dương N, hàm này tìm năm nhuận thứ N sau năm bắt đầu Y.\n\n@param Y Năm bắt đầu.\n@param N Vị trí của năm nhuận cần tìm.\n@return Năm nhuận thứ N sau năm bắt đầu Y.\n\nVí dụ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032"
    },
    "docstring_bertscore": {
      "es": "0.9865396135987897",
      "arb": "0.9759377170110526",
      "sw": "0.9553977465689969",
      "tr": "0.9701118879352993",
      "vi": "0.9673477475528178"
    }
  },
  {
    "task_id": "Java/3",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Calculate the time needed to obtain the reverse seating order.\n     * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n     * \n     * @param N the number of people\n     * @return the time needed in minutes\n     * \n     * Example:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "es": "class Solution {\n    /**\n     * Calcular el tiempo necesario para obtener el orden de asientos inverso.\n     * Para cada persona, la persona que originalmente estaba a su izquierda estará a su derecha, y la persona que originalmente estaba a su derecha estará a su izquierda.\n     * \n     * @param N el número de personas\n     * @return el tiempo necesario en minutos\n     * \n     * Ejemplo:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "arb": "class Solution {\n    /**\n     * حساب الوقت اللازم للحصول على ترتيب الجلوس العكسي.\n     * لكل شخص، الشخص الذي كان في الأصل على يساره سيكون على يمينه، والشخص الذي كان في الأصل على يمينه سيكون على يساره.\n     * \n     * @param N عدد الأشخاص\n     * @return الوقت اللازم بالدقائق\n     * \n     * مثال:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "sw": "class Solution {\n    /**\n     * Hesabu muda unaohitajika kupata mpangilio wa viti ulio kinyume.\n     * Kwa kila mtu, mtu ambaye awali alikuwa upande wao wa kushoto atakuwa upande wao wa kulia, na mtu ambaye awali alikuwa upande wao wa kulia atakuwa upande wao wa kushoto.\n     * \n     * @param N idadi ya watu\n     * @return muda unaohitajika kwa dakika\n     * \n     * Mfano:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "tr": "class Solution {\n    /**\n     * Ters oturma düzenini elde etmek için gereken zamanı hesaplayın.\n     * Her kişi için, başlangıçta solunda olan kişi sağında olacak ve başlangıçta sağında olan kişi solunda olacak.\n     * \n     * @param N kişi sayısı\n     * @return gereken zaman dakika cinsinden\n     * \n     * Örnek:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "vi": "class Solution {\n    /**\n     * Tính thời gian cần thiết để có được thứ tự chỗ ngồi ngược lại.\n     * Đối với mỗi người, người ban đầu ở bên trái của họ sẽ ở bên phải, và người ban đầu ở bên phải của họ sẽ ở bên trái.\n     * \n     * @param N số người\n     * @return thời gian cần thiết tính bằng phút\n     * \n     * Ví dụ:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9777023493161665",
      "sw": "0.9685377421655978",
      "tr": "0.9591093538690149",
      "vi": "0.9704720048161156"
    },
    "canonical_solution": "    {\n        return N / 2;\n    }",
    "instruction": {
      "en": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9134398594007113",
      "sw": "0.9426256144380726",
      "tr": "0.8655566293357738",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert calculateTimeNeeded(7) == 3;\n        assert calculateTimeNeeded(8) == 4;\n        assert calculateTimeNeeded(9) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "calculateTimeNeeded",
    "signature": "public static int calculateTimeNeeded(int N)",
    "docstring": {
      "en": "Calculate the time needed to obtain the reverse seating order.\nFor each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n\n@param N the number of people\n@return the time needed in minutes\n\nExample:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "es": "Calcular el tiempo necesario para obtener el orden de asientos inverso.  \nPara cada persona, la persona que estaba originalmente a su izquierda estará a su derecha, y la persona que estaba originalmente a su derecha estará a su izquierda.\n\n@param N el número de personas  \n@return el tiempo necesario en minutos\n\nEjemplo:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "arb": "احسب الوقت اللازم للحصول على ترتيب الجلوس العكسي.  \nلكل شخص، الشخص الذي كان في الأصل على يساره سيكون على يمينه، والشخص الذي كان في الأصل على يمينه سيكون على يساره.\n\n@param N عدد الأشخاص  \n@return الوقت اللازم بالدقائق\n\nمثال:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6  ",
      "sw": "Hesabu muda unaohitajika kupata mpangilio wa viti ulio kinyume. Kwa kila mtu, mtu ambaye awali alikuwa upande wao wa kushoto atakuwa upande wao wa kulia, na mtu ambaye awali alikuwa upande wao wa kulia atakuwa upande wao wa kushoto.\n\n@param N idadi ya watu\n@return muda unaohitajika kwa dakika\n\nMfano:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "tr": "Ters oturma düzenini elde etmek için gereken zamanı hesaplayın.\nHer kişi için, başlangıçta solunda olan kişi sağında olacak ve başlangıçta sağında olan kişi solunda olacak.\n\n@param N kişi sayısı\n@return gereken süre, dakika cinsinden\n\nÖrnek:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "vi": "Tính toán thời gian cần thiết để có được thứ tự chỗ ngồi ngược lại.  \nĐối với mỗi người, người ban đầu ở bên trái của họ sẽ ở bên phải, và người ban đầu ở bên phải của họ sẽ ở bên trái.\n\n@param N số lượng người  \n@return thời gian cần thiết tính bằng phút\n\nVí dụ:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6"
    },
    "docstring_bertscore": {
      "es": "0.9955725288067323",
      "arb": "0.9800702220884835",
      "sw": "0.9762056693950687",
      "tr": "0.9729493229283828",
      "vi": "0.96857846139371"
    }
  },
  {
    "task_id": "Java/4",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "es": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Dado un array de enteros distintos, devuelve todas las permutaciones posibles del array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "arb": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * بالنظر إلى مصفوفة من الأعداد الصحيحة المميزة، أعد جميع التباديل الممكنة للمصفوفة.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "sw": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Ukipewa safu ya nambari tofauti, rudisha mipangilio yote inayowezekana ya safu hiyo.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "tr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Ayrı tamsayılardan oluşan bir dizi verildiğinde, dizinin tüm olası permütasyonlarını döndür.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "vi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Cho một mảng các số nguyên khác nhau, trả về tất cả các hoán vị có thể có của mảng.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) "
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9999996027392379",
      "sw": "0.9941167667441276",
      "tr": "0.9999996027392379",
      "vi": "0.9999996027392379"
    },
    "canonical_solution": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }",
    "instruction": {
      "en": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nJava kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9011037209561585",
      "sw": "0.9149216420432316",
      "tr": "0.8721595004621356",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "permute",
    "signature": "public List<List<Integer>> permute(int[] nums)",
    "docstring": {
      "en": "Given an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "es": "Dado un arreglo de enteros distintos, devuelve todas las permutaciones posibles del arreglo.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "arb": "بالنظر إلى مصفوفة من الأعداد الصحيحة المميزة، قم بإرجاع جميع التباديل الممكنة للمصفوفة.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "sw": "Kwa kupewa safu ya nambari za kipekee, rudisha mchanganyiko wote unaowezekana wa safu hiyo.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "tr": "Verilen farklı tamsayılardan oluşan bir dizi için, dizinin tüm olası permütasyonlarını döndürün.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "vi": "Cho một mảng các số nguyên khác nhau, trả về tất cả các hoán vị có thể của mảng.  \n>>> permute(new int[]{1,2,3})  \n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n>>> permute(new int[]{0,1})  \n[[0,1],[1,0]]  \n>>> permute(new int[]{1})  \n[[1]]"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9876420122135334",
      "tr": "0.979424474719739",
      "vi": "0.999999801369619"
    }
  },
  {
    "task_id": "Java/5",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dado un número de cadenas sensibles a mayúsculas y minúsculas, encuentra la cadena más grande X, tal que X, o su inversa, pueda encontrarse como una subcadena de cualquiera de las cadenas dadas.\n     * \n     * Ejemplo:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى عدد من السلاسل النصية التي تفرق بين الأحرف الكبيرة والصغيرة، يجد أكبر سلسلة X، بحيث يمكن العثور على X أو معكوسها كجزء من أي من السلاسل النصية المعطاة.\n     * \n     * مثال:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa idadi ya mistari yenye herufi kubwa na ndogo, inapata mstari mkubwa zaidi X, kiasi kwamba X, au kinyume chake kinaweza kupatikana kama sehemu ya mstari wowote kati ya mistari iliyotolewa.\n     * \n     * Mfano:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Belirli sayıda büyük/küçük harfe duyarlı string verildiğinde, bu stringlerden herhangi birinin alt dizisi olarak bulunabilen en büyük X stringini veya tersini bulur.\n     * \n     * Örnek:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho một số chuỗi phân biệt chữ hoa chữ thường, tìm chuỗi lớn nhất X, sao cho hoặc X, hoặc nghịch đảo của nó có thể được tìm thấy như một chuỗi con của bất kỳ chuỗi nào đã cho.\n     * \n     * Ví dụ:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) "
    },
    "prompt_bertscore": {
      "es": "0.9866383328981642",
      "arb": "0.9664876780029368",
      "sw": "0.9267248551754677",
      "tr": "0.9544961632694795",
      "vi": "0.9928602309537009"
    },
    "canonical_solution": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }",
    "instruction": {
      "en": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية بلغة Java باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9240008381299553",
      "sw": "0.9426256144380726",
      "tr": "0.8837954668135404",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "findLargestSubstring",
    "signature": "public int findLargestSubstring(List<String> strings)",
    "docstring": {
      "en": "Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "es": "Dado un número de cadenas sensibles a mayúsculas y minúsculas, encuentra la cadena más grande X, tal que X, o su inverso, se pueda encontrar como una subcadena de cualquiera de las cadenas dadas.\n\nEjemplo:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "arb": "إعطاء عدد من السلاسل النصية التي تميز بين الأحرف الكبيرة والصغيرة، يجد أكبر سلسلة X، بحيث يمكن العثور على X، أو عكسها كجزء من أي من السلاسل النصية المعطاة.\n\nمثال:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "sw": "Kwa kupewa idadi ya mistari yenye herufi kubwa na ndogo, tafuta mstari mkubwa zaidi X, kiasi kwamba X, au kinyume chake kinaweza kupatikana kama sehemu ndogo ya mistari yoyote iliyotolewa.\n\nMfano:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "tr": "Verilen bir dizi büyük/küçük harfe duyarlı string içinde, X veya tersinin verilen stringlerden herhangi birinin alt stringi olarak bulunabileceği en büyük stringi bulur.\n\nÖrnek:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "vi": "Cho một số chuỗi phân biệt chữ hoa chữ thường, tìm chuỗi lớn nhất X, sao cho X hoặc nghịch đảo của nó có thể được tìm thấy như một chuỗi con của bất kỳ chuỗi nào đã cho.\n\nVí dụ:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2"
    },
    "docstring_bertscore": {
      "es": "0.9811013123964356",
      "arb": "0.9682715774550111",
      "sw": "0.9212307388360427",
      "tr": "0.9230170218526894",
      "vi": "0.9829306982057668"
    }
  },
  {
    "task_id": "Java/6",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "es": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Dado un mapa que representa un terreno dividido en parcelas cuadradas, determina el número de depósitos de petróleo distintos.\n     * \n     * Parámetros:\n     *     grid (char[][]): El mapa que representa el terreno. Cada carácter es '*' para ausencia de petróleo o '@' para un bolsillo de petróleo.\n     * \n     * Devuelve:\n     *     int: El número de depósitos de petróleo distintos en el mapa.\n     * \n     * Ejemplo:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "arb": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * بالنظر إلى شبكة تمثل أرضًا مقسمة إلى قطع مربعة، حدد عدد رواسب النفط المميزة.\n     * \n     * المعلمات:\n     *     grid (char[][]): الشبكة التي تمثل الأرض. كل حرف إما '*' لغياب النفط أو '@' لوجود جيب نفطي.\n     * \n     * يعيد:\n     *     int: عدد رواسب النفط المميزة في الشبكة.\n     * \n     * مثال:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "sw": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Ukipewa gridi inayowakilisha ardhi iliyogawanywa katika viwanja vya mraba, bainisha idadi ya akiba tofauti za mafuta.\n     * \n     * Vigezo:\n     *     grid (char[][]): Gridi inayowakilisha ardhi. Kila herufi ni ama '*' kwa kutokuwepo kwa mafuta au '@' kwa mfuko wa mafuta.\n     * \n     * Inarejesha:\n     *     int: Idadi ya akiba tofauti za mafuta katika gridi.\n     * \n     * Mfano:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "tr": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Kare parsellerine bölünmüş bir araziyi temsil eden bir ızgara verildiğinde, farklı petrol yataklarının sayısını belirleyin.\n     * \n     * Parametreler:\n     *     grid (char[][]): Araziyi temsil eden ızgara. Her karakter ya petrol yokluğunu belirtmek için '*' ya da bir petrol cebi için '@' olabilir.\n     * \n     * Döndürür:\n     *     int: Izgaradaki farklı petrol yataklarının sayısı.\n     * \n     * Örnek:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "vi": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Cho một lưới đại diện cho một vùng đất được chia thành các ô vuông, xác định số lượng mỏ dầu riêng biệt.\n     * \n     * Tham số:\n     *     grid (char[][]): Lưới đại diện cho vùng đất. Mỗi ký tự là '*' cho sự vắng mặt của dầu hoặc '@' cho một túi dầu.\n     * \n     * Trả về:\n     *     int: Số lượng mỏ dầu riêng biệt trong lưới.\n     * \n     * Ví dụ:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) "
    },
    "prompt_bertscore": {
      "es": "0.985476146538729",
      "arb": "0.9904113169859218",
      "sw": "0.9910250848633196",
      "tr": "0.9884718899454972",
      "vi": "0.9759053402589439"
    },
    "canonical_solution": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }",
    "instruction": {
      "en": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9426256144380726",
      "tr": "0.8710694169310161",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countOilDeposits",
    "signature": "public static int countOilDeposits(char[][] grid)",
    "docstring": {
      "en": "Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "es": "Dado un cuadrícula que representa un terreno dividido en parcelas cuadradas, determine el número de depósitos de petróleo distintos.\n\nParámetros:\ngrid (char[][]): La cuadrícula que representa el terreno. Cada carácter es '*' para ausencia de petróleo o '@' para un bolsillo de petróleo.\n\nDevuelve:\nint: El número de depósitos de petróleo distintos en la cuadrícula.\n\nEjemplo:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "arb": "معطى شبكة تمثل أرضًا مقسمة إلى قطع مربعة، حدد عدد رواسب النفط المميزة.\n\nالمعطيات:\ngrid (char[][]): الشبكة التي تمثل الأرض. كل حرف إما '*' لعدم وجود النفط أو '@' لجيب نفطي.\n\nالقيم المعادة:\nint: عدد رواسب النفط المميزة في الشبكة.\n\nمثال:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "sw": "Ukipewa gridi inayowakilisha ardhi iliyogawanywa katika viwanja vya mraba, bainisha idadi ya akiba tofauti za mafuta.\n\nVigezo:\ngrid (char[][]): Gridi inayowakilisha ardhi. Kila herufi ni ama '*' kwa kutokuwepo kwa mafuta au '@' kwa mfuko wa mafuta.\n\nInarejesha:\nint: Idadi ya akiba tofauti za mafuta kwenye gridi.\n\nMfano:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "tr": "Verilen bir ızgarada kare parsellerine bölünmüş bir araziyi temsil eden, farklı petrol yataklarının sayısını belirleyin.\n\nParametreler:\ngrid (char[][]): Araziyi temsil eden ızgara. Her karakter ya petrol yokluğunu belirtmek için '*' ya da bir petrol cebi için '@' karakteridir.\n\nDöndürür:\nint: Izgaradaki farklı petrol yataklarının sayısı.\n\nÖrnek:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "vi": "Cho một lưới đại diện cho một vùng đất được chia thành các ô vuông, xác định số lượng mỏ dầu riêng biệt.\n\nTham số:\ngrid (char[][]): Lưới đại diện cho vùng đất. Mỗi ký tự là '*' cho sự vắng mặt của dầu hoặc '@' cho một túi dầu.\n\nTrả về:\nint: Số lượng mỏ dầu riêng biệt trong lưới.\n\nVí dụ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2"
    },
    "docstring_bertscore": {
      "es": "0.9894920555824923",
      "arb": "0.9899401657221071",
      "sw": "0.9916605034522502",
      "tr": "0.9759021621728474",
      "vi": "0.989319247150992"
    }
  },
  {
    "task_id": "Java/7",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n     *\n     * Example:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N the number of triangles\n     * @return the maximum number of regions\n     */\n    public static int maxRegions(int N) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dado el número de triángulos N, determina el número máximo de regiones en las que se puede dividir el plano.\n     *\n     * Ejemplo:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N el número de triángulos\n     * @return el número máximo de regiones\n     */\n    public static int maxRegions(int N) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى عدد المثلثات N، حدد الحد الأقصى لعدد المناطق التي يمكن تقسيم المستوى إليها.\n     *\n     * مثال:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N عدد المثلثات\n     * @return الحد الأقصى لعدد المناطق\n     */\n    public static int maxRegions(int N) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa idadi ya pembetatu N, amua idadi kubwa zaidi ya maeneo ambayo ndege inaweza kugawanywa.\n     *\n     * Mfano:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N idadi ya pembetatu\n     * @return idadi kubwa zaidi ya maeneo\n     */\n    public static int maxRegions(int N) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Verilen üçgen sayısı N olduğunda, düzlemin bölünebileceği maksimum bölge sayısını belirleyin.\n     *\n     * Örnek:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N üçgen sayısı\n     * @return maksimum bölge sayısı\n     */\n    public static int maxRegions(int N) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho số lượng tam giác N, xác định số lượng vùng tối đa mà mặt phẳng có thể được chia thành.\n     *\n     * Ví dụ:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N số lượng tam giác\n     * @return số lượng vùng tối đa\n     */\n    public static int maxRegions(int N) "
    },
    "prompt_bertscore": {
      "es": "0.9923012850614688",
      "arb": "0.9796366119666843",
      "sw": "0.9794087829196373",
      "tr": "0.9554446233389211",
      "vi": "0.9999996027392379"
    },
    "canonical_solution": "    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }",
    "instruction": {
      "en": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9306920997758775",
      "sw": "0.9149216420432316",
      "tr": "0.8799948731028189",
      "vi": "0.9363463122024166"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert maxRegions(3) == 13;\n        assert maxRegions(4) == 21;\n        assert maxRegions(5) == 31;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "maxRegions",
    "signature": "public static int maxRegions(int N)",
    "docstring": {
      "en": "Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n\nExample:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N the number of triangles\n@return the maximum number of regions",
      "es": "Dado el número de triángulos N, determina el número máximo de regiones en las que se puede dividir el plano.\n\nEjemplo:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N el número de triángulos\n@return el número máximo de regiones",
      "arb": "بالنظر إلى عدد المثلثات N، حدد الحد الأقصى لعدد المناطق التي يمكن تقسيم المستوى إليها.\n\nمثال:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N عدد المثلثات\n@return الحد الأقصى لعدد المناطق",
      "sw": "Ukizingatia idadi ya pembetatu N, bainisha idadi ya juu zaidi ya maeneo ambayo ndege inaweza kugawanywa.\n\nMfano:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N idadi ya pembetatu\n@return idadi ya juu zaidi ya maeneo",
      "tr": "Üçgen sayısı N verildiğinde, düzlemin bölünebileceği maksimum bölge sayısını belirleyin.\n\nÖrnek:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N üçgen sayısı\n@return maksimum bölge sayısı",
      "vi": "Cho số lượng tam giác N, xác định số lượng vùng tối đa mà mặt phẳng có thể được chia thành.\n\nVí dụ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N số lượng tam giác\n@return số lượng vùng tối đa"
    },
    "docstring_bertscore": {
      "es": "0.9889134452825377",
      "arb": "0.95711808429914",
      "sw": "0.9623970839359043",
      "tr": "0.9606898558109094",
      "vi": "0.9840366721673691"
    }
  },
  {
    "task_id": "Java/8",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "es": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Cuenta el número de palabras en la lista de palabras dada que tienen el prefijo dado.\n     * \n     * @param wordList: una lista de palabras\n     * @param prefix: la cadena de prefijo\n     * @return el número de palabras con el prefijo dado\n     * \n     * Ejemplo:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "arb": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * عد عدد الكلمات في قائمة الكلمات المعطاة التي تحتوي على البادئة المعطاة.\n     * \n     * @param wordList: قائمة من الكلمات\n     * @param prefix: سلسلة البادئة\n     * @return عدد الكلمات التي تحتوي على البادئة المعطاة\n     * \n     * مثال:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "sw": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Hesabu idadi ya maneno katika orodha ya maneno yaliyopewa ambayo yana kiambishi awali kilichopewa.\n     * \n     * @param wordList: orodha ya maneno\n     * @param prefix: mnyororo wa kiambishi awali\n     * @return idadi ya maneno yenye kiambishi awali kilichopewa\n     * \n     * Mfano:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "tr": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Verilen kelime listesindeki verilen ön ek ile başlayan kelimelerin sayısını sayar.\n     * \n     * @param wordList: bir kelime listesi\n     * @param prefix: ön ek dizesi\n     * @return verilen ön ek ile başlayan kelimelerin sayısı\n     * \n     * Örnek:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "vi": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Đếm số lượng từ trong danh sách từ đã cho có tiền tố đã cho.\n     * \n     * @param wordList: một danh sách các từ\n     * @param prefix: chuỗi tiền tố\n     * @return số lượng từ có tiền tố đã cho\n     * \n     * Ví dụ:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) "
    },
    "prompt_bertscore": {
      "es": "0.9944053766877713",
      "arb": "0.9831092669183172",
      "sw": "0.9862692776502013",
      "tr": "0.9843290560882525",
      "vi": "0.9900271658290003"
    },
    "canonical_solution": "    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }",
    "instruction": {
      "en": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.8494602191478496",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countPrefixWords",
    "signature": "public static int countPrefixWords(List<String> wordList, String prefix)",
    "docstring": {
      "en": "Count the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "es": "Contar el número de palabras en la lista de palabras dada que tienen el prefijo dado.\n\n@param wordList: una lista de palabras\n@param prefix: la cadena de prefijo\n@return el número de palabras con el prefijo dado\n\nEjemplo:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "arb": "احسب عدد الكلمات في قائمة الكلمات المعطاة التي تحتوي على البادئة المعطاة.\n\n@param wordList: قائمة من الكلمات\n@param prefix: سلسلة البادئة\n@return عدد الكلمات التي تحتوي على البادئة المعطاة\n\nمثال:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "sw": "Hesabu idadi ya maneno katika orodha ya maneno yaliyotolewa ambayo yana kiambishi awali kilichotolewa.\n\n@param wordList: orodha ya maneno\n@param prefix: kamba ya kiambishi awali\n@return idadi ya maneno yenye kiambishi awali kilichotolewa\n\nMfano:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "tr": "Verilen kelime listesinde, verilen önek ile başlayan kelimelerin sayısını sayın.\n\n@param wordList: kelimelerin bir listesi\n@param prefix: önek dizesi\n@return verilen önek ile başlayan kelimelerin sayısı\n\nÖrnek:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "vi": "Đếm số lượng từ trong danh sách từ đã cho có tiền tố đã cho.\n\n@param wordList: một danh sách các từ\n@param prefix: chuỗi tiền tố\n@return số lượng từ có tiền tố đã cho\n\nVí dụ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1"
    },
    "docstring_bertscore": {
      "es": "0.9933375397593278",
      "arb": "0.9691312497441301",
      "sw": "0.9797778381676001",
      "tr": "0.9626497417805807",
      "vi": "0.9882684924353174"
    }
  },
  {
    "task_id": "Java/9",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n   /**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "es": "import java.util.*;\n\nclass Solution {\n   /**\n     * Dada una lista de números, determina cuántos elementos en la lista son el doble de algún otro elemento en la misma lista.\n     * \n     * Ejemplo:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "arb": "import java.util.*;\n\nclass Solution {\n   /**\n     * بالنظر إلى قائمة من الأرقام، حدد عدد العناصر في القائمة التي هي ضعف عنصر آخر في نفس القائمة.\n     * \n     * مثال:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "sw": "import java.util.*;\n\nclass Solution {\n   /**\n     * Ukipewa orodha ya namba, bainisha ni vitu vingapi katika orodha hiyo ni mara mbili ya kitu kingine katika orodha hiyo hiyo.\n     * \n     * Mfano:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "tr": "import java.util.*;\n\nclass Solution {\n   /**\n     * Bir sayı listesini göz önünde bulundurarak, listedeki kaç öğenin aynı listedeki başka bir öğenin iki katı olduğunu belirleyin.\n     * \n     * Örnek:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "vi": "import java.util.*;\n\nclass Solution {\n   /**\n     * Cho một danh sách các số, xác định có bao nhiêu mục trong danh sách là gấp đôi một số khác trong cùng danh sách.\n     * \n     * Ví dụ:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) "
    },
    "prompt_bertscore": {
      "es": "0.9906083583239084",
      "arb": "0.9817941351654853",
      "sw": "0.9888208835249754",
      "tr": "0.9884492460820592",
      "vi": "0.9897453093183118"
    },
    "canonical_solution": "    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }",
    "instruction": {
      "en": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nJava kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8720578017070457",
      "vi": "0.9052995891251394"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countDoubles",
    "signature": "public static int countDoubles(int[] numbers)",
    "docstring": {
      "en": "Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "es": "Dada una lista de números, determina cuántos elementos en la lista son el doble de algún otro elemento en la misma lista.\n\nEjemplo:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "arb": "معطى قائمة من الأرقام، حدد عدد العناصر في القائمة التي تكون ضعف بعض العناصر الأخرى في نفس القائمة.\n\nمثال:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "sw": "Ukipewa orodha ya nambari, bainisha ni vitu vingapi katika orodha hiyo ni mara mbili ya kitu kingine katika orodha hiyo hiyo.\n\nMfano:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "tr": "Verilen bir sayı listesinden, listedeki diğer bazı öğelerin iki katı olan kaç öğe olduğunu belirleyin.\n\nÖrnek:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "vi": "Cho một danh sách các số, xác định có bao nhiêu mục trong danh sách là gấp đôi một số mục khác trong cùng danh sách.\n\nVí dụ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0"
    },
    "docstring_bertscore": {
      "es": "0.9888727260544256",
      "arb": "0.973600234687034",
      "sw": "0.9876974300898421",
      "tr": "0.9496787806382404",
      "vi": "0.9938984719553703"
    }
  },
  {
    "task_id": "Java/10",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dado el tamaño del espacio n-teresante, las coordenadas de inicio y fin de la n-tersección, y los caminos entre n-tersecciones adyacentes, determine si es posible viajar desde la n-tersección de inicio hasta la n-tersección de fin.\n     * \n     * Parámetros:\n     * - n: el tamaño del espacio n-teresante\n     * - start: las coordenadas de inicio de la n-tersección\n     * - end: las coordenadas de fin de la n-tersección\n     * - paths: caminos entre n-tersecciones adyacentes en el espacio n-teresante\n     * \n     * Salida:\n     * - Si el viaje es posible, devolver \"can be travelled\"\n     * - Si el viaje no es posible, devolver \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى حجم الفضاء n-teresting، إحداثيات البداية والنهاية للنقطة n-tersection، والمسارات بين النقاط n-tersections المجاورة، حدد ما إذا كان من الممكن السفر من النقطة n-tersection البداية إلى النقطة n-tersection النهاية.\n     * \n     * المعلمات:\n     * - n: حجم الفضاء n-teresting\n     * - start: إحداثيات النقطة n-tersection البداية\n     * - end: إحداثيات النقطة n-tersection النهاية\n     * - paths: المسارات بين النقاط n-tersections المجاورة في الفضاء n-teresting\n     * \n     * المخرجات:\n     * - إذا كان السفر ممكنًا، أعد \"can be travelled\"\n     * - إذا كان السفر غير ممكن، أعد \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa ukubwa wa nafasi ya n-teresting, viwianishi vya kuanzia na kumalizia vya n-tersection, na njia kati ya n-tersections zilizo karibu, amua kama inawezekana kusafiri kutoka n-tersection ya kuanzia hadi n-tersection ya kumalizia.\n     * \n     * Vigezo:\n     * - n: ukubwa wa nafasi ya n-teresting\n     * - start: viwianishi vya kuanzia vya n-tersection\n     * - end: viwianishi vya kumalizia vya n-tersection\n     * - paths: njia kati ya n-tersections zilizo karibu katika nafasi ya n-teresting\n     * \n     * Matokeo:\n     * - Ikiwa kusafiri kunawezekana, rudisha \"can be travelled\"\n     * - Ikiwa kusafiri hakuwezekani, rudisha \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * n-teresan alanın boyutu, başlangıç ve bitiş n-terseksiyon koordinatları ve bitişik n-terseksiyonlar arasındaki yollar verildiğinde, başlangıç n-terseksiyonundan bitiş n-terseksiyonuna seyahat etmenin mümkün olup olmadığını belirleyin.\n     * \n     * Parametreler:\n     * - n: n-teresan alanın boyutu\n     * - start: başlangıç n-terseksiyon koordinatları\n     * - end: bitiş n-terseksiyon koordinatları\n     * - paths: n-teresan alandaki bitişik n-terseksiyonlar arasındaki yollar\n     * \n     * Çıktı:\n     * - Seyahat mümkünse, \"can be travelled\" döndür\n     * - Seyahat mümkün değilse, \"cannot be travelled\" döndür\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho kích thước của không gian n-teresting, tọa độ bắt đầu và kết thúc của n-tersection, và các đường đi giữa các n-tersection liền kề, xác định xem có thể di chuyển từ n-tersection bắt đầu đến n-tersection kết thúc hay không.\n     * \n     * Tham số:\n     * - n: kích thước của không gian n-teresting\n     * - start: tọa độ bắt đầu của n-tersection\n     * - end: tọa độ kết thúc của n-tersection\n     * - paths: các đường đi giữa các n-tersection liền kề trong không gian n-teresting\n     * \n     * Đầu ra:\n     * - Nếu có thể di chuyển, trả về \"can be travelled\"\n     * - Nếu không thể di chuyển, trả về \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) "
    },
    "prompt_bertscore": {
      "es": "0.9697948738471677",
      "arb": "0.9553659657080313",
      "sw": "0.9729491242980017",
      "tr": "0.9441634108480447",
      "vi": "0.9592716348903203"
    },
    "canonical_solution": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }",
    "instruction": {
      "en": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8884380547094688",
      "sw": "0.9149216420432316",
      "tr": "0.8921927648021714",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "canTravelMaze",
    "signature": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)",
    "docstring": {
      "en": "Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"",
      "es": "Dado el tamaño del espacio n-teresante, las coordenadas de inicio y fin de la n-tersección, y los caminos entre n-tersecciones adyacentes, determina si es posible viajar desde la n-tersección de inicio hasta la n-tersección de fin.\n\nParámetros:\n- n: el tamaño del espacio n-teresante\n- start: las coordenadas de inicio de la n-tersección\n- end: las coordenadas de fin de la n-tersección\n- paths: caminos entre n-tersecciones adyacentes en el espacio n-teresante\n\nSalida:\n- Si es posible viajar, devuelve \"can be travelled\"\n- Si no es posible viajar, devuelve \"cannot be travelled\"",
      "arb": "بالنظر إلى حجم الفضاء n-teresting، وإحداثيات n-tersection البداية والنهاية، والمسارات بين n-tersections المتجاورة، حدد ما إذا كان من الممكن السفر من n-tersection البداية إلى n-tersection النهاية.\n\nالمعلمات:\n- n: حجم الفضاء n-teresting\n- start: إحداثيات n-tersection البداية\n- end: إحداثيات n-tersection النهاية\n- paths: المسارات بين n-tersections المتجاورة في الفضاء n-teresting\n\nالناتج:\n- إذا كان السفر ممكنًا، أعد \"can be travelled\"\n- إذا لم يكن السفر ممكنًا، أعد \"cannot be travelled\"",
      "sw": "Kwa kuzingatia ukubwa wa nafasi ya n-teresting, viwianishi vya kuanzia na kumalizia vya n-tersection, na njia kati ya n-tersections zilizo karibu, amua ikiwa inawezekana kusafiri kutoka n-tersection ya kuanzia hadi n-tersection ya kumalizia.\n\nVigezo:\n- n: ukubwa wa nafasi ya n-teresting\n- start: viwianishi vya kuanzia vya n-tersection\n- end: viwianishi vya kumalizia vya n-tersection\n- paths: njia kati ya n-tersections zilizo karibu katika nafasi ya n-teresting\n\nMatokeo:\n- Ikiwa kusafiri kunawezekana, rudisha \"inaweza kusafiriwa\"\n- Ikiwa kusafiri hakuwezekani, rudisha \"haiwezi kusafiriwa\"",
      "tr": "Verilen n-teresan alanın boyutu, başlangıç ve bitiş n-terseksiyon koordinatları ve bitişik n-terseksiyonlar arasındaki yollar göz önüne alındığında, başlangıç n-terseksiyonundan bitiş n-terseksiyonuna seyahat etmenin mümkün olup olmadığını belirleyin.\n\nParametreler:\n- n: n-teresan alanın boyutu\n- start: başlangıç n-terseksiyon koordinatları\n- end: bitiş n-terseksiyon koordinatları\n- paths: n-teresan alandaki bitişik n-terseksiyonlar arasındaki yollar\n\nÇıktı:\n- Seyahat mümkünse, \"seyahat edilebilir\" döndür\n- Seyahat mümkün değilse, \"seyahat edilemez\" döndür",
      "vi": "Xét kích thước của không gian n-teresting, tọa độ n-tersection bắt đầu và kết thúc, và các đường đi giữa các n-tersection liền kề, xác định xem có thể di chuyển từ n-tersection bắt đầu đến n-tersection kết thúc hay không.\n\nTham số:\n- n: kích thước của không gian n-teresting\n- start: tọa độ n-tersection bắt đầu\n- end: tọa độ n-tersection kết thúc\n- paths: các đường đi giữa các n-tersection liền kề trong không gian n-teresting\n\nĐầu ra:\n- Nếu có thể di chuyển, trả về \"có thể di chuyển\"\n- Nếu không thể di chuyển, trả về \"không thể di chuyển\""
    },
    "docstring_bertscore": {
      "es": "0.958227633607601",
      "arb": "0.9476912850456053",
      "sw": "0.9566093918933097",
      "tr": "0.9163857465818397",
      "vi": "0.9347856732986255"
    }
  },
  {
    "task_id": "Java/11",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * El valor aproximado se calcula contando el número de letras comunes\n     * y dividiéndolo por la suma de las longitudes de las dos palabras.\n     *\n     * @param word1 La primera palabra.\n     * @param word2 La segunda palabra.\n     * @return El valor aproximado como una fracción reducida.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * يتم حساب القيمة التقريبية عن طريق عد عدد الأحرف المشتركة\n     * وتقسيمه على مجموع أطوال الكلمتين.\n     *\n     * @param word1 الكلمة الأولى.\n     * @param word2 الكلمة الثانية.\n     * @return القيمة التقريبية ككسر مبسط.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Thamani ya takriban inakokotolewa kwa kuhesabu idadi ya herufi za kawaida\n     * na kuigawanya kwa jumla ya urefu wa maneno mawili.\n     *\n     * @param word1 Neno la kwanza.\n     * @param word2 Neno la pili.\n     * @return Thamani ya takriban kama sehemu iliyopunguzwa.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Yaklaşık değer, ortak harflerin sayısının hesaplanması\n     * ve iki kelimenin uzunluklarının toplamına bölünmesiyle hesaplanır.\n     *\n     * @param word1 Birinci kelime.\n     * @param word2 İkinci kelime.\n     * @return Yaklaşık değer, sadeleştirilmiş kesir olarak.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Giá trị xấp xỉ được tính bằng cách đếm số lượng chữ cái chung\n     * và chia nó cho tổng độ dài của hai từ.\n     *\n     * @param word1 Từ thứ nhất.\n     * @param word2 Từ thứ hai.\n     * @return Giá trị xấp xỉ dưới dạng phân số tối giản.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9952070489056282",
      "sw": "0.9780791511489897",
      "tr": "0.9846262071382806",
      "vi": "0.9832226848658882"
    },
    "canonical_solution": "    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }",
    "instruction": {
      "en": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة Java باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9033051414691682",
      "sw": "0.9149216420432316",
      "tr": "0.8873082451021423",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0/10\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "appx",
    "signature": "public static String appx(String word1, String word2)",
    "docstring": {
      "en": "The approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "es": "El valor aproximado se calcula contando el número de letras comunes y dividiéndolo por la suma de las longitudes de las dos palabras.\n\n@param word1 La primera palabra.\n@param word2 La segunda palabra.\n@return El valor aproximado como una fracción reducida.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "arb": "يتم حساب القيمة التقريبية عن طريق عد عدد الأحرف المشتركة وقسمتها على مجموع أطوال الكلمتين.\n\n@param word1 الكلمة الأولى.\n@param word2 الكلمة الثانية.\n@return القيمة التقريبية ككسر مبسط.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "sw": "Thamani ya takriban inakokotolewa kwa kuhesabu idadi ya herufi zinazofanana na kugawanya kwa jumla ya urefu wa maneno mawili.\n\n@param word1 Neno la kwanza.\n@param word2 Neno la pili.\n@return Thamani ya takriban kama sehemu iliyopunguzwa.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "tr": "Yaklaşık değer, ortak harflerin sayısını sayarak ve bunu iki kelimenin uzunluklarının toplamına bölerek hesaplanır.\n\n@param word1 İlk kelime.\n@param word2 İkinci kelime.\n@return Yaklaşık değeri sadeleştirilmiş bir kesir olarak döndürür.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "vi": "Giá trị xấp xỉ được tính bằng cách đếm số lượng chữ cái chung và chia nó cho tổng độ dài của hai từ.\n\n@param word1 Từ thứ nhất.\n@param word2 Từ thứ hai.\n@return Giá trị xấp xỉ dưới dạng phân số rút gọn.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\""
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9943289039910729",
      "sw": "0.9770256156079807",
      "tr": "0.9844390973193459",
      "vi": "0.9776296505967078"
    }
  },
  {
    "task_id": "Java/12",
    "prompt": {
      "en": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "es": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Dada una fecha en el formato \"MM dd yyyy\", devuelve el día de la semana de la fecha.\n     * \n     * Ejemplo:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "arb": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * بالنظر إلى تاريخ بالصيغة \"MM dd yyyy\"، قم بإرجاع يوم الأسبوع للتاريخ.\n     * \n     * مثال:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "sw": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Ukipewa tarehe katika muundo \"MM dd yyyy\", rudisha siku ya wiki ya tarehe hiyo.\n     * \n     * Mfano:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "tr": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * \"MM dd yyyy\" formatında bir tarih verildiğinde, tarihin haftanın hangi günü olduğunu döndürür.\n     * \n     * Örnek:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "vi": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Cho một ngày theo định dạng \"MM dd yyyy\", trả về ngày trong tuần của ngày đó.\n     * \n     * Ví dụ:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) "
    },
    "prompt_bertscore": {
      "es": "0.9824462387064228",
      "arb": "0.9821886151022206",
      "sw": "0.9809465793296094",
      "tr": "0.9625341388988183",
      "vi": "0.9809465793296094"
    },
    "canonical_solution": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }",
    "instruction": {
      "en": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Java باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nJava kodunun Türkçe açıklamasını (docstring) en fazla 500 karakter kullanarak sağlayın.",
      "vi": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9150914710190163",
      "sw": "0.9149216420432316",
      "tr": "0.8705992588191066",
      "vi": "0.9196422916789067"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "convertDatesToWeekdays",
    "signature": "public static String convertDatesToWeekdays(String date)",
    "docstring": {
      "en": "Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "es": "Dada una fecha en el formato \"MM dd yyyy\", devuelve el día de la semana de la fecha.\n\nEjemplo:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "arb": "إعطاء تاريخ بالتنسيق \"MM dd yyyy\"، إرجاع يوم الأسبوع للتاريخ.\n\nمثال:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "sw": "Kwa kupewa tarehe katika muundo \"MM dd yyyy\", rudisha siku ya juma ya tarehe hiyo.\n\nMfano:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 ni Jumamosi\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 ni Jumamosi\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 ni Jumamosi\"",
      "tr": "Verilen bir tarihi \"MM dd yyyy\" formatında alarak, tarihin haftanın hangi günü olduğunu döndürün.\n\nÖrnek:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "vi": "Cho một ngày theo định dạng \"MM dd yyyy\", trả về ngày trong tuần của ngày đó.\n\nVí dụ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 là một Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 là một Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 là một Saturday\""
    },
    "docstring_bertscore": {
      "es": "0.974840681416597",
      "arb": "0.9706096556701728",
      "sw": "0.9677175973223048",
      "tr": "0.9637173800786432",
      "vi": "0.972893905052074"
    }
  },
  {
    "task_id": "Java/13",
    "prompt": {
      "en": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "es": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Dado un array de enteros nums y un entero target,\n     * encuentra dos números tales que sumen target y devuelve sus índices.\n     * Puedes asumir que cada entrada tendrá exactamente una solución,\n     * y no puedes usar el mismo elemento dos veces.\n     * Puedes devolver la respuesta en cualquier orden.\n     *\n     * Ejemplo 1:\n     * Entrada: nums = [2,7,11,15], target = 9\n     * Salida: [0,1]\n     * Explicación: Porque nums[0] + nums[1] == 9, devolvemos [0, 1].\n     *\n     * Ejemplo 2:\n     * Entrada: nums = [3,2,4], target = 6\n     * Salida: [1,2]\n     *\n     * Ejemplo 3:\n     * Entrada: nums = [3,3], target = 6\n     * Salida: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "arb": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * معطى مصفوفة من الأعداد الصحيحة nums وعدد صحيح target،\n     * ابحث عن رقمين بحيث يكون مجموعهما يساوي target وأعد مؤشراتهما.\n     * يمكنك افتراض أن كل إدخال سيكون له حل واحد بالضبط،\n     * ولا يمكنك استخدام نفس العنصر مرتين.\n     * يمكنك إعادة الإجابة بأي ترتيب.\n     *\n     * المثال 1:\n     * المدخلات: nums = [2,7,11,15], target = 9\n     * الناتج: [0,1]\n     * التفسير: لأن nums[0] + nums[1] == 9، نعيد [0, 1].\n     *\n     * المثال 2:\n     * المدخلات: nums = [3,2,4], target = 6\n     * الناتج: [1,2]\n     *\n     * المثال 3:\n     * المدخلات: nums = [3,3], target = 6\n     * الناتج: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "sw": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Ukipewa safu ya nambari za mzima nums na nambari ya mzima target,\n     * pata nambari mbili ambazo jumla yao ni target na rudisha faharasa zao.\n     * Unaweza kudhani kwamba kila ingizo litakuwa na suluhisho moja tu,\n     * na huwezi kutumia kipengele sawa mara mbili.\n     * Unaweza kurudisha jibu kwa mpangilio wowote.\n     *\n     * Mfano 1:\n     * Ingizo: nums = [2,7,11,15], target = 9\n     * Matokeo: [0,1]\n     * Maelezo: Kwa sababu nums[0] + nums[1] == 9, tunarudisha [0, 1].\n     *\n     * Mfano 2:\n     * Ingizo: nums = [3,2,4], target = 6\n     * Matokeo: [1,2]\n     *\n     * Mfano 3:\n     * Ingizo: nums = [3,3], target = 6\n     * Matokeo: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "tr": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Bir tamsayı dizisi nums ve bir tamsayı hedefi verildiğinde,\n     * hedefe ulaşacak şekilde toplanan iki sayıyı bulun ve dizinlerini döndürün.\n     * Her girdinin tam olarak bir çözümü olacağını varsayabilirsiniz,\n     * ve aynı elemanı iki kez kullanamazsınız.\n     * Cevabı herhangi bir sırayla döndürebilirsiniz.\n     *\n     * Örnek 1:\n     * Girdi: nums = [2,7,11,15], target = 9\n     * Çıktı: [0,1]\n     * Açıklama: Çünkü nums[0] + nums[1] == 9, [0, 1] döndürüyoruz.\n     *\n     * Örnek 2:\n     * Girdi: nums = [3,2,4], target = 6\n     * Çıktı: [1,2]\n     *\n     * Örnek 3:\n     * Girdi: nums = [3,3], target = 6\n     * Çıktı: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "vi": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Cho một mảng số nguyên nums và một số nguyên target,\n     * tìm hai số sao cho tổng của chúng bằng target và trả về chỉ số của chúng.\n     * Bạn có thể giả định rằng mỗi đầu vào sẽ có chính xác một giải pháp,\n     * và bạn không thể sử dụng cùng một phần tử hai lần.\n     * Bạn có thể trả về câu trả lời theo bất kỳ thứ tự nào.\n     *\n     * Ví dụ 1:\n     * Đầu vào: nums = [2,7,11,15], target = 9\n     * Đầu ra: [0,1]\n     * Giải thích: Vì nums[0] + nums[1] == 9, chúng tôi trả về [0, 1].\n     *\n     * Ví dụ 2:\n     * Đầu vào: nums = [3,2,4], target = 6\n     * Đầu ra: [1,2]\n     *\n     * Ví dụ 3:\n     * Đầu vào: nums = [3,3], target = 6\n     * Đầu ra: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9903914539478184",
      "sw": "1",
      "tr": "0.9953446997596853",
      "vi": "0.9903914539478184"
    },
    "canonical_solution": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }",
    "instruction": {
      "en": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Java باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9150914710190163",
      "sw": "0.9149216420432316",
      "tr": "0.8730124193182994",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "twoSum",
    "signature": "public int[] twoSum(int[] nums, int target)",
    "docstring": {
      "en": "Given an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "es": "Dado un array de enteros nums y un entero target, encuentra dos números tales que sumen target y devuelve sus índices. Puedes asumir que cada entrada tendría exactamente una solución, y no puedes usar el mismo elemento dos veces. Puedes devolver la respuesta en cualquier orden.\n\nEjemplo 1:\nEntrada: nums = [2,7,11,15], target = 9\nSalida: [0,1]\nExplicación: Porque nums[0] + nums[1] == 9, devolvemos [0, 1].\n\nEjemplo 2:\nEntrada: nums = [3,2,4], target = 6\nSalida: [1,2]\n\nEjemplo 3:\nEntrada: nums = [3,3], target = 6\nSalida: [0,1]",
      "arb": "معطى مصفوفة من الأعداد الصحيحة nums وعدد صحيح target،  \nfind two numbers such that they add up to target and return their indices.  \nيمكنك افتراض أن كل إدخال سيكون له حل واحد بالضبط،  \nولا يمكنك استخدام نفس العنصر مرتين.  \nيمكنك إرجاع الإجابة بأي ترتيب.\n\nمثال 1:  \nالمدخلات: nums = [2,7,11,15], target = 9  \nالناتج: [0,1]  \nالتفسير: Because nums[0] + nums[1] == 9, we return [0, 1].  \n\nمثال 2:  \nالمدخلات: nums = [3,2,4], target = 6  \nالناتج: [1,2]  \n\nمثال 3:  \nالمدخلات: nums = [3,3], target = 6  \nالناتج: [0,1]",
      "sw": "Ukipewa safu ya nambari za mzima nums na nambari ya mzima target, tafuta namba mbili ambazo jumla yake ni target na rudisha fahirisi zao. Unaweza kudhani kwamba kila ingizo litakuwa na suluhisho moja tu, na huwezi kutumia kipengele sawa mara mbili. Unaweza kurudisha jibu kwa mpangilio wowote.\n\nMfano 1:\nIngizo: nums = [2,7,11,15], target = 9\nMatokeo: [0,1]\nMaelezo: Kwa sababu nums[0] + nums[1] == 9, tunarudisha [0, 1].\n\nMfano 2:\nIngizo: nums = [3,2,4], target = 6\nMatokeo: [1,2]\n\nMfano 3:\nIngizo: nums = [3,3], target = 6\nMatokeo: [0,1]",
      "tr": "Verilen bir tamsayı dizisi nums ve bir tamsayı hedef ile,\nhedefe eşit olacak şekilde toplayan iki sayıyı bulun ve bunların indekslerini döndürün.\nHer girdinin tam olarak bir çözümü olacağını varsayabilirsiniz,\nve aynı öğeyi iki kez kullanamazsınız.\nCevabı herhangi bir sırayla döndürebilirsiniz.\n\nÖrnek 1:\nGirdi: nums = [2,7,11,15], hedef = 9\nÇıktı: [0,1]\nAçıklama: Çünkü nums[0] + nums[1] == 9, [0, 1] döndürüyoruz.\n\nÖrnek 2:\nGirdi: nums = [3,2,4], hedef = 6\nÇıktı: [1,2]\n\nÖrnek 3:\nGirdi: nums = [3,3], hedef = 6\nÇıktı: [0,1]",
      "vi": "Cho một mảng số nguyên `nums` và một số nguyên `target`, tìm hai số sao cho chúng cộng lại bằng `target` và trả về chỉ số của chúng. Bạn có thể giả định rằng mỗi đầu vào sẽ có chính xác một giải pháp, và bạn không thể sử dụng cùng một phần tử hai lần. Bạn có thể trả lời theo bất kỳ thứ tự nào.\n\nVí dụ 1:\nĐầu vào: nums = [2,7,11,15], target = 9\nĐầu ra: [0,1]\nGiải thích: Bởi vì nums[0] + nums[1] == 9, chúng tôi trả về [0, 1].\n\nVí dụ 2:\nĐầu vào: nums = [3,2,4], target = 6\nĐầu ra: [1,2]\n\nVí dụ 3:\nĐầu vào: nums = [3,3], target = 6\nĐầu ra: [0,1]"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9926888129348679",
      "sw": "0.9796318448375395",
      "tr": "0.9852749339627407",
      "vi": "0.96770706991211"
    }
  },
  {
    "task_id": "Java/14",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "es": "class Solution {\n    /**\n     * Buscar el valor objetivo en el array ordenado rotado.\n     * Si el valor objetivo existe, devolver su índice; de lo contrario, devolver -1.\n     * El array nums está rotado en algún pivote desconocido k, donde 0 <= k < nums.length.\n     * La complejidad temporal del algoritmo debe ser O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "arb": "class Solution {\n    /**\n     * البحث عن القيمة المستهدفة في المصفوفة الدوارة المرتبة.\n     * إذا كانت القيمة المستهدفة موجودة، قم بإرجاع فهرسها؛ وإلا، قم بإرجاع -1.\n     * يتم تدوير المصفوفة nums عند محور غير معروف k، حيث 0 <= k < nums.length.\n     * يجب أن تكون تعقيد الزمن للخوارزمية O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "sw": "class Solution {\n    /**\n     * Tafuta thamani lengwa katika safu iliyopangwa iliyozungushwa.\n     * Ikiwa thamani lengwa ipo, rudisha kiashiria chake; vinginevyo, rudisha -1.\n     * Safu nums imezungushwa katika kipengele kisichojulikana k, ambapo 0 <= k < nums.length.\n     * Ugumu wa muda wa algoriti lazima uwe O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "tr": "class Solution {\n    /**\n     * Döndürülen sıralı dizide hedef değeri arayın.\n     * Hedef değer mevcutsa, indeksini döndürün; aksi takdirde -1 döndürün.\n     * nums dizisi, bilinmeyen bir k döndürme noktasında döndürülmüştür, burada 0 <= k < nums.length.\n     * Algoritmanın zaman karmaşıklığı O(log n) olmalıdır.\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "vi": "class Solution {\n    /**\n     * Tìm kiếm giá trị mục tiêu trong mảng đã sắp xếp và xoay vòng.\n     * Nếu giá trị mục tiêu tồn tại, trả về chỉ số của nó; nếu không, trả về -1.\n     * Mảng nums được xoay vòng tại một điểm xoay không xác định k, nơi 0 <= k < nums.length.\n     * Độ phức tạp thời gian của thuật toán phải là O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9937725402937941",
      "sw": "0.9861715515027322",
      "tr": "0.9835657195339355",
      "vi": "0.9854272834649944"
    },
    "canonical_solution": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }",
    "instruction": {
      "en": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8652195535791577",
      "sw": "0.9426256144380726",
      "tr": "0.8411703801953586",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "search",
    "signature": "public int search(int[] nums, int target)",
    "docstring": {
      "en": "Search for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "es": "Buscar el valor objetivo en el array ordenado rotado.\nSi el valor objetivo existe, devuelve su índice; de lo contrario, devuelve -1.\nEl array nums está rotado en algún pivote desconocido k, donde 0 <= k < nums.length.\nLa complejidad temporal del algoritmo debe ser O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "arb": "ابحث عن القيمة المستهدفة في المصفوفة المرتبة والمدورة.  \nإذا كانت القيمة المستهدفة موجودة، قم بإرجاع مؤشرها؛ وإلا، قم بإرجاع -1.  \nالمصفوفة nums مدورة عند محور غير معروف k، حيث 0 <= k < nums.length.  \nيجب أن تكون تعقيد الزمن للخوارزمية O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "sw": "Tafuta thamani lengwa katika safu iliyopangwa iliyozungushwa.  \nIkiwa thamani lengwa ipo, rudisha kiashiria chake; vinginevyo, rudisha -1.  \nSafu ya nums imezungushwa katika kipengele kisichojulikana k, ambapo 0 <= k < nums.length.  \nUgumu wa muda wa algorithimu lazima uwe O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)  \n4  \n>>> search(new int[]{4,5,6,7,0,1,2}, 3)  \n-1  \n>>> search(new int[]{1}, 0)  \n-1  ",
      "tr": "Döndürülmüş sıralı dizide hedef değeri arayın.\nEğer hedef değer mevcutsa, indeksini döndürün; aksi takdirde -1 döndürün.\nnums dizisi, bilinmeyen bir k döndürme noktasında döndürülmüştür, burada 0 <= k < nums.length.\nAlgoritmanın zaman karmaşıklığı O(log n) olmalıdır.\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "vi": "Tìm kiếm giá trị mục tiêu trong mảng đã được sắp xếp và xoay vòng.  \nNếu giá trị mục tiêu tồn tại, trả về chỉ số của nó; nếu không, trả về -1.  \nMảng nums được xoay vòng tại một điểm xoay không xác định k, nơi 0 <= k < nums.length.  \nĐộ phức tạp thời gian của thuật toán phải là O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9908481051938175",
      "sw": "0.974955092516073",
      "tr": "0.9839248432628465",
      "vi": "0.9838066581861308"
    }
  },
  {
    "task_id": "Java/15",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "es": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Dado un array de enteros arr, calcula la media de los elementos restantes después de eliminar el 5% más pequeño y el 5% más grande de los elementos.\n     * Devuelve la media con un error dentro de 10^-5.\n     *\n     * Ejemplo 1:\n     * Entrada: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Salida: 2.00000\n     *\n     * Ejemplo 2:\n     * Entrada: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Salida: 4.00000\n     *\n     * Ejemplo 3:\n     * Entrada: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Salida: 4.77778\n     *\n     * Ejemplo 4:\n     * Entrada: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Salida: 5.27778\n     *\n     * Ejemplo 5:\n     * Entrada: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Salida: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "arb": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى مصفوفة من الأعداد الصحيحة arr، احسب المتوسط للعناصر المتبقية بعد إزالة أصغر 5% وأكبر 5% من العناصر.\n     * أعد المتوسط مع خطأ ضمن 10^-5.\n     *\n     * المثال 1:\n     * المدخلات: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * الناتج: 2.00000\n     *\n     * المثال 2:\n     * المدخلات: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * الناتج: 4.00000\n     *\n     * المثال 3:\n     * المدخلات: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * الناتج: 4.77778\n     *\n     * المثال 4:\n     * المدخلات: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * الناتج: 5.27778\n     *\n     * المثال 5:\n     * المدخلات: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * الناتج: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "sw": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa safu ya nambari nzima arr, hesabu wastani wa vipengele vilivyobaki baada ya kuondoa asilimia 5% ndogo zaidi na asilimia 5% kubwa zaidi ya vipengele.\n     * Rudisha wastani na kosa ndani ya 10^-5.\n     *\n     * Mfano 1:\n     * Ingizo: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Matokeo: 2.00000\n     *\n     * Mfano 2:\n     * Ingizo: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Matokeo: 4.00000\n     *\n     * Mfano 3:\n     * Ingizo: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Matokeo: 4.77778\n     *\n     * Mfano 4:\n     * Ingizo: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Matokeo: 5.27778\n     *\n     * Mfano 5:\n     * Ingizo: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Matokeo: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "tr": "```java\nimport java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Bir tamsayı dizisi arr verildiğinde, en küçük %5 ve en büyük %5 elemanlar çıkarıldıktan sonra kalan elemanların ortalamasını hesaplayın.\n     * Hata payı 10^-5 içinde olan ortalamayı döndürün.\n     *\n     * Örnek 1:\n     * Girdi: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Çıktı: 2.00000\n     *\n     * Örnek 2:\n     * Girdi: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Çıktı: 4.00000\n     *\n     * Örnek 3:\n     * Girdi: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Çıktı: 4.77778\n     *\n     * Örnek 4:\n     * Girdi: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Çıktı: 5.27778\n     *\n     * Örnek 5:\n     * Girdi: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Çıktı: 5.29167\n     */\n  public double trimMean(int[] arr) \n```",
      "vi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Cho một mảng số nguyên arr, tính giá trị trung bình của các phần tử còn lại sau khi loại bỏ 5% phần tử nhỏ nhất và 5% phần tử lớn nhất.\n     * Trả về giá trị trung bình với sai số trong khoảng 10^-5.\n     *\n     * Ví dụ 1:\n     * Đầu vào: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Đầu ra: 2.00000\n     *\n     * Ví dụ 2:\n     * Đầu vào: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Đầu ra: 4.00000\n     *\n     * Ví dụ 3:\n     * Đầu vào: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Đầu ra: 4.77778\n     *\n     * Ví dụ 4:\n     * Đầu vào: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Đầu ra: 5.27778\n     *\n     * Ví dụ 5:\n     * Đầu vào: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Đầu ra: 5.29167\n     */\n  public double trimMean(int[] arr) "
    },
    "prompt_bertscore": {
      "es": "0.9400666592392001",
      "arb": "0.9773984448331832",
      "sw": "0.9881824854803293",
      "tr": "0.9748424690900263",
      "vi": "0.9468624004655467"
    },
    "canonical_solution": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }",
    "instruction": {
      "en": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9240008381299553",
      "sw": "0.9149216420432316",
      "tr": "0.8412671131909225",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "trimMean",
    "signature": "public double trimMean(int[] arr)",
    "docstring": {
      "en": "Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "es": "Dado un arreglo de enteros `arr`, calcula la media de los elementos restantes después de eliminar el 5% más pequeño y el 5% más grande de los elementos. Devuelve la media con un error dentro de 10^-5.\n\nEjemplo 1:\nEntrada: `arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]`\nSalida: `2.00000`\n\nEjemplo 2:\nEntrada: `arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]`\nSalida: `4.00000`\n\nEjemplo 3:\nEntrada: `arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]`\nSalida: `4.77778`\n\nEjemplo 4:\nEntrada: `arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]`\nSalida: `5.27778`\n\nEjemplo 5:\nEntrada: `arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]`\nSalida: `5.29167`",
      "arb": "معطى مصفوفة أعداد صحيحة `arr`، احسب المتوسط للعناصر المتبقية بعد إزالة أصغر 5% وأكبر 5% من العناصر.  \nأعد المتوسط مع خطأ ضمن 10^-5.\n\nمثال 1:  \nالمدخل: `arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]`  \nالمخرج: `2.00000`\n\nمثال 2:  \nالمدخل: `arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]`  \nالمخرج: `4.00000`\n\nمثال 3:  \nالمدخل: `arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]`  \nالمخرج: `4.77778`\n\nمثال 4:  \nالمدخل: `arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]`  \nالمخرج: `5.27778`\n\nمثال 5:  \nالمدخل: `arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]`  \nالمخرج: `5.29167`",
      "sw": "Kwa kupewa safu ya nambari nzima `arr`, hesabu wastani wa vipengele vilivyobaki baada ya kuondoa asilimia 5% ndogo zaidi na asilimia 5% kubwa zaidi ya vipengele.\n\nRudisha wastani na kosa ndani ya 10^-5.\n\nMfano 1:\nIngizo: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nMatokeo: 2.00000\n\nMfano 2:\nIngizo: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nMatokeo: 4.00000\n\nMfano 3:\nIngizo: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nMatokeo: 4.77778\n\nMfano 4:\nIngizo: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nMatokeo: 5.27778\n\nMfano 5:\nIngizo: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nMatokeo: 5.29167",
      "tr": "Verilen bir tamsayı dizisi `arr` için, elemanların en küçük %5 ve en büyük %5'ini çıkardıktan sonra kalan elemanların ortalamasını hesaplayın. Ortalamayı 10^-5 hata payı ile döndürün.\n\nÖrnek 1:\nGirdi: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nÇıktı: 2.00000\n\nÖrnek 2:\nGirdi: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nÇıktı: 4.00000\n\nÖrnek 3:\nGirdi: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nÇıktı: 4.77778\n\nÖrnek 4:\nGirdi: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nÇıktı: 5.27778\n\nÖrnek 5:\nGirdi: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nÇıktı: 5.29167",
      "vi": "Cho một mảng số nguyên `arr`, tính giá trị trung bình của các phần tử còn lại sau khi loại bỏ 5% nhỏ nhất và 5% lớn nhất của các phần tử.\n\nTrả về giá trị trung bình với sai số trong khoảng 10^-5.\n\nVí dụ 1:\nĐầu vào: `arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]`\nĐầu ra: `2.00000`\n\nVí dụ 2:\nĐầu vào: `arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]`\nĐầu ra: `4.00000`\n\nVí dụ 3:\nĐầu vào: `arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]`\nĐầu ra: `4.77778`\n\nVí dụ 4:\nĐầu vào: `arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]`\nĐầu ra: `5.27778`\n\nVí dụ 5:\nĐầu vào: `arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]`\nĐầu ra: `5.29167`"
    },
    "docstring_bertscore": {
      "es": "0.9200784839956593",
      "arb": "0.9192021267545334",
      "sw": "0.9529182435225384",
      "tr": "0.9317170325420175",
      "vi": "0.9136126678322116"
    }
  },
  {
    "task_id": "Java/16",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "es": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Verificar si es posible dividir el arreglo en n/2 pares de manera que la suma de cada par sea divisible por k.\n     *\n     * @param arr el arreglo de enteros de entrada\n     * @param k el divisor\n     * @return true si es posible, false en caso contrario\n     *\n     * Ejemplo:\n     * Entrada: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Salida: true\n     * Explicación: Los pares son (1,9), (2,8), (3,7), (4,6), (5,10), y la suma de cada par es divisible por 5.\n     *\n     * Entrada: arr = [1,2,3,4,5,6], k = 7\n     * Salida: true\n     * Explicación: Los pares son (1,6), (2,5), (3,4), y la suma de cada par es divisible por 7.\n     *\n     * Entrada: arr = [1,2,3,4,5,6], k = 10\n     * Salida: false\n     * Explicación: No es posible dividir el arreglo en n/2 pares de manera que la suma de cada par sea divisible por 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "arb": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * تحقق مما إذا كان من الممكن تقسيم المصفوفة إلى n/2 أزواج بحيث يكون مجموع كل زوج قابلاً للقسمة على k.\n     *\n     * @param arr مصفوفة الأعداد الصحيحة المدخلة\n     * @param k القاسم\n     * @return true إذا كان ذلك ممكنًا، false خلاف ذلك\n     *\n     * مثال:\n     * المدخلات: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * التفسير: الأزواج هي (1,9), (2,8), (3,7), (4,6), (5,10)، ومجموع كل زوج قابل للقسمة على 5.\n     *\n     * المدخلات: arr = [1,2,3,4,5,6], k = 7\n     * الناتج: true\n     * التفسير: الأزواج هي (1,6), (2,5), (3,4)، ومجموع كل زوج قابل للقسمة على 7.\n     *\n     * المدخلات: arr = [1,2,3,4,5,6], k = 10\n     * الناتج: false\n     * التفسير: لا يمكن تقسيم المصفوفة إلى n/2 أزواج بحيث يكون مجموع كل زوج قابلاً للقسمة على 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "sw": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Angalia kama inawezekana kugawa safu kuwa jozi n/2 ambapo jumla ya kila jozi inagawanyika kwa k.\n     *\n     * @param arr safu ya namba nzima ya ingizo\n     * @param k mgawanyiko\n     * @return kweli ikiwa inawezekana, vinginevyo si kweli\n     *\n     * Mfano:\n     * Ingizo: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Matokeo: kweli\n     * Maelezo: Jozi ni (1,9), (2,8), (3,7), (4,6), (5,10), na jumla ya kila jozi inagawanyika kwa 5.\n     *\n     * Ingizo: arr = [1,2,3,4,5,6], k = 7\n     * Matokeo: kweli\n     * Maelezo: Jozi ni (1,6), (2,5), (3,4), na jumla ya kila jozi inagawanyika kwa 7.\n     *\n     * Ingizo: arr = [1,2,3,4,5,6], k = 10\n     * Matokeo: si kweli\n     * Maelezo: Haiwezekani kugawa safu kuwa jozi n/2 ambapo jumla ya kila jozi inagawanyika kwa 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "tr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Diziyi, her bir çiftin toplamı k ile bölünebilir olacak şekilde n/2 çiftine ayırmanın mümkün olup olmadığını kontrol edin.\n     *\n     * @param arr giriş tamsayı dizisi\n     * @param k bölen\n     * @return mümkünse true, aksi takdirde false\n     *\n     * Örnek:\n     * Girdi: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Çıktı: true\n     * Açıklama: Çiftler (1,9), (2,8), (3,7), (4,6), (5,10) ve her bir çiftin toplamı 5 ile bölünebilir.\n     *\n     * Girdi: arr = [1,2,3,4,5,6], k = 7\n     * Çıktı: true\n     * Açıklama: Çiftler (1,6), (2,5), (3,4) ve her bir çiftin toplamı 7 ile bölünebilir.\n     *\n     * Girdi: arr = [1,2,3,4,5,6], k = 10\n     * Çıktı: false\n     * Açıklama: Diziyi, her bir çiftin toplamı 10 ile bölünebilir olacak şekilde n/2 çiftine ayırmak mümkün değildir.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "vi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Kiểm tra xem có thể chia mảng thành n/2 cặp sao cho tổng của mỗi cặp chia hết cho k hay không.\n     *\n     * @param arr mảng số nguyên đầu vào\n     * @param k số chia\n     * @return true nếu có thể, false nếu không thể\n     *\n     * Ví dụ:\n     * Đầu vào: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Đầu ra: true\n     * Giải thích: Các cặp là (1,9), (2,8), (3,7), (4,6), (5,10), và tổng của mỗi cặp chia hết cho 5.\n     *\n     * Đầu vào: arr = [1,2,3,4,5,6], k = 7\n     * Đầu ra: true\n     * Giải thích: Các cặp là (1,6), (2,5), (3,4), và tổng của mỗi cặp chia hết cho 7.\n     *\n     * Đầu vào: arr = [1,2,3,4,5,6], k = 10\n     * Đầu ra: false\n     * Giải thích: Không thể chia mảng thành n/2 cặp sao cho tổng của mỗi cặp chia hết cho 10.\n     */\n  public boolean canArrange(int[] arr, int k) "
    },
    "prompt_bertscore": {
      "es": "0.9916485856293882",
      "arb": "0.9791148099557057",
      "sw": "0.9720016573804653",
      "tr": "0.9652235942580307",
      "vi": "0.9677761932847101"
    },
    "canonical_solution": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "instruction": {
      "en": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nJava kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yapılmalıdır.",
      "vi": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.8651462589685558",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "canArrange",
    "signature": "public boolean canArrange(int[] arr, int k)",
    "docstring": {
      "en": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.",
      "es": "Verificar si es posible dividir el arreglo en n/2 pares de manera que la suma de cada par sea divisible por k.\n\n@param arr el arreglo de enteros de entrada\n@param k el divisor\n@return true si es posible, false de lo contrario\n\nEjemplo:\nEntrada: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nSalida: true\nExplicación: Los pares son (1,9), (2,8), (3,7), (4,6), (5,10), y la suma de cada par es divisible por 5.\n\nEntrada: arr = [1,2,3,4,5,6], k = 7\nSalida: true\nExplicación: Los pares son (1,6), (2,5), (3,4), y la suma de cada par es divisible por 7.\n\nEntrada: arr = [1,2,3,4,5,6], k = 10\nSalida: false\nExplicación: No es posible dividir el arreglo en n/2 pares de manera que la suma de cada par sea divisible por 10.",
      "arb": "التحقق مما إذا كان من الممكن تقسيم المصفوفة إلى أزواج n/2 بحيث يكون مجموع كل زوج قابلاً للقسمة على k.\n\n@param arr مصفوفة الأعداد الصحيحة المدخلة\n@param k المقسوم\n@return true إذا كان ذلك ممكنًا، false خلاف ذلك\n\nمثال:\nالمدخلات: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nالناتج: true\nالتفسير: الأزواج هي (1,9)، (2,8)، (3,7)، (4,6)، (5,10)، ومجموع كل زوج قابل للقسمة على 5.\n\nالمدخلات: arr = [1,2,3,4,5,6], k = 7\nالناتج: true\nالتفسير: الأزواج هي (1,6)، (2,5)، (3,4)، ومجموع كل زوج قابل للقسمة على 7.\n\nالمدخلات: arr = [1,2,3,4,5,6], k = 10\nالناتج: false\nالتفسير: لا يمكن تقسيم المصفوفة إلى أزواج n/2 بحيث يكون مجموع كل زوج قابلاً للقسمة على 10.",
      "sw": "Angalia ikiwa inawezekana kugawanya safu katika jozi n/2 ili kwamba jumla ya kila jozi inagawanyika kwa k.\n\n@param arr safu ya nambari za kiingilio\n@param k mgawanyiko\n@return kweli ikiwa inawezekana, sivyo vinginevyo\n\nMfano:\nKiingilio: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nMatokeo: kweli\nMaelezo: Jozi ni (1,9), (2,8), (3,7), (4,6), (5,10), na jumla ya kila jozi inagawanyika kwa 5.\n\nKiingilio: arr = [1,2,3,4,5,6], k = 7\nMatokeo: kweli\nMaelezo: Jozi ni (1,6), (2,5), (3,4), na jumla ya kila jozi inagawanyika kwa 7.\n\nKiingilio: arr = [1,2,3,4,5,6], k = 10\nMatokeo: si kweli\nMaelezo: Haiwezekani kugawanya safu katika jozi n/2 ili kwamba jumla ya kila jozi inagawanyika kwa 10.",
      "tr": "Diziyi, her bir çiftin toplamı k ile bölünebilir olacak şekilde n/2 çiftine ayırmanın mümkün olup olmadığını kontrol edin.\n\n@param arr giriş tamsayı dizisi\n@param k bölen\n@return mümkünse true, aksi takdirde false\n\nÖrnek:\nGirdi: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nÇıktı: true\nAçıklama: Çiftler (1,9), (2,8), (3,7), (4,6), (5,10) ve her bir çiftin toplamı 5 ile bölünebilir.\n\nGirdi: arr = [1,2,3,4,5,6], k = 7\nÇıktı: true\nAçıklama: Çiftler (1,6), (2,5), (3,4) ve her bir çiftin toplamı 7 ile bölünebilir.\n\nGirdi: arr = [1,2,3,4,5,6], k = 10\nÇıktı: false\nAçıklama: Diziyi, her bir çiftin toplamı 10 ile bölünebilir olacak şekilde n/2 çiftine ayırmak mümkün değildir.",
      "vi": "Kiểm tra xem có thể chia mảng thành n/2 cặp sao cho tổng của mỗi cặp chia hết cho k hay không.\n\n@param arr mảng số nguyên đầu vào\n@param k số chia\n@return true nếu có thể, false nếu không\n\nVí dụ:\nĐầu vào: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nĐầu ra: true\nGiải thích: Các cặp là (1,9), (2,8), (3,7), (4,6), (5,10), và tổng của mỗi cặp chia hết cho 5.\n\nĐầu vào: arr = [1,2,3,4,5,6], k = 7\nĐầu ra: true\nGiải thích: Các cặp là (1,6), (2,5), (3,4), và tổng của mỗi cặp chia hết cho 7.\n\nĐầu vào: arr = [1,2,3,4,5,6], k = 10\nĐầu ra: false\nGiải thích: Không thể chia mảng thành n/2 cặp sao cho tổng của mỗi cặp chia hết cho 10."
    },
    "docstring_bertscore": {
      "es": "0.9919161407526421",
      "arb": "0.975023024106387",
      "sw": "0.968703797164143",
      "tr": "0.9575705643071375",
      "vi": "0.9656351564075351"
    }
  },
  {
    "task_id": "Java/17",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "es": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Dado un árbol con n nodos y aristas, y un array booleano hasApple que indica si cada nodo tiene una manzana.\n   * Comenzando desde el nodo 0, devuelve el tiempo mínimo requerido para recoger todas las manzanas y regresar al nodo 0.\n   *\n   * Ejemplo:\n   * Entrada: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Salida: 8\n   *\n   * Entrada: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Salida: 6\n   *\n   * Entrada: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Salida: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "arb": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * بالنظر إلى شجرة تحتوي على n من العقد والحواف، ومصفوفة منطقية hasApple تشير إلى ما إذا كانت كل عقدة تحتوي على تفاحة.\n   * بدءًا من العقدة 0، أعد الوقت الأدنى المطلوب لجمع جميع التفاح والعودة إلى العقدة 0.\n   *\n   * مثال:\n   * المدخلات: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * الناتج: 8\n   *\n   * المدخلات: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * الناتج: 6\n   *\n   * المدخلات: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * الناتج: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "sw": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Ukipewa mti wenye n nodes na edges, na array ya boolean hasApple inayoonyesha kama kila node ina tofaa.\n   * Kuanzia node 0, rudisha muda wa chini kabisa unaohitajika kukusanya matofaa yote na kurudi kwenye node 0.\n   *\n   * Mfano:\n   * Ingizo: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Matokeo: 8\n   *\n   * Ingizo: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Matokeo: 6\n   *\n   * Ingizo: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Matokeo: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "tr": "```java\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * n düğüm ve kenarlara sahip bir ağaç ve her düğümde elma olup olmadığını belirten bir boolean dizi verildiğinde,\n   * 0 numaralı düğümden başlayarak tüm elmaları toplamak ve 0 numaralı düğüme geri dönmek için gereken minimum süreyi döndürün.\n   *\n   * Örnek:\n   * Girdi: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Çıktı: 8\n   *\n   * Girdi: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Çıktı: 6\n   *\n   * Girdi: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Çıktı: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) \n```",
      "vi": "```java\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Cho một cây với n nút và các cạnh, và một mảng boolean hasApple cho biết nếu mỗi nút có một quả táo.\n   * Bắt đầu từ nút 0, trả về thời gian tối thiểu cần thiết để thu thập tất cả các quả táo và quay trở lại nút 0.\n   *\n   * Ví dụ:\n   * Đầu vào: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Đầu ra: 8\n   *\n   * Đầu vào: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Đầu ra: 6\n   *\n   * Đầu vào: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Đầu ra: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) \n```"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9957703646662431",
      "sw": "0.9957703646662431",
      "tr": "0.9783129391074677",
      "vi": "0.9817176624687868"
    },
    "canonical_solution": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n",
    "instruction": {
      "en": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nAşağıdaki Java kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8612562815863686",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minTime",
    "signature": "public int minTime(int n, int[][] edges, boolean[] hasApple)",
    "docstring": {
      "en": "Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "es": "Dado un árbol con n nodos y aristas, y un array booleano hasApple que indica si cada nodo tiene una manzana. Comenzando desde el nodo 0, devuelve el tiempo mínimo requerido para recoger todas las manzanas y regresar al nodo 0.\n\nEjemplo:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nSalida: 8\n\nEntrada: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nSalida: 6\n\nEntrada: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nSalida: 0",
      "arb": "معطى شجرة تحتوي على n عقد وحواف، ومصفوفة منطقية hasApple تشير إذا كان لكل عقدة تفاحة.\nبدءًا من العقدة 0، أعد الوقت الأدنى المطلوب لجمع جميع التفاح والعودة إلى العقدة 0.\n\nمثال:\nالمدخل: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nالمخرج: 8\n\nالمدخل: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nالمخرج: 6\n\nالمدخل: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nالمخرج: 0",
      "sw": "Kwa kuzingatia mti wenye n nodes na edges, na array ya boolean hasApple inayoonyesha kama kila node ina apple.\nKuanzia node 0, rudisha muda wa chini kabisa unaohitajika kukusanya maapulo yote na kurudi kwenye node 0.\n\nMfano:\nIngizo: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nMatokeo: 8\n\nIngizo: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nMatokeo: 6\n\nIngizo: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nMatokeo: 0",
      "tr": "Verilen bir ağaçta n düğüm ve kenarlar bulunmaktadır ve her düğümde bir elma olup olmadığını belirten bir boolean dizisi hasApple vardır. \nDüğüm 0'dan başlayarak, tüm elmaları toplamak ve düğüm 0'a geri dönmek için gereken minimum süreyi döndürün.\n\nÖrnek:\nGirdi: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nÇıktı: 8\n\nGirdi: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nÇıktı: 6\n\nGirdi: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nÇıktı: 0",
      "vi": "Cho một cây với n nút và các cạnh, và một mảng boolean hasApple chỉ ra nếu mỗi nút có một quả táo.\nBắt đầu từ nút 0, trả về thời gian tối thiểu cần thiết để thu thập tất cả các quả táo và trở về nút 0.\n\nVí dụ:\nĐầu vào: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nĐầu ra: 8\n\nĐầu vào: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nĐầu ra: 6\n\nĐầu vào: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nĐầu ra: 0"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9953452956508284",
      "sw": "0.9952545215666955",
      "tr": "0.9780227401207758",
      "vi": "0.9956277480526601"
    }
  },
  {
    "task_id": "Java/18",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dada una cadena s. Debes reordenar la cadena usando el siguiente algoritmo:\n     * 1. Elige el carácter más pequeño de s y añádelo al resultado.\n     * 2. Elige el carácter más pequeño de s que sea mayor que el último carácter añadido al resultado y añádelo.\n     * 3. Repite el paso 2 hasta que no puedas elegir más caracteres.\n     * 4. Elige el carácter más grande de s y añádelo al resultado.\n     * 5. Elige el carácter más grande de s que sea menor que el último carácter añadido al resultado y añádelo.\n     * 6. Repite el paso 5 hasta que no puedas elegir más caracteres.\n     * 7. Repite los pasos del 1 al 6 hasta que elijas todos los caracteres de s.\n     * En cada paso, si el carácter más pequeño o el más grande aparece más de una vez, puedes elegir cualquier ocurrencia y añadirla al resultado.\n     * Devuelve la cadena de resultado después de ordenar s con este algoritmo.\n     */\n    public String sortString(String s)",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى سلسلة نصية s. يجب عليك إعادة ترتيب السلسلة النصية باستخدام الخوارزمية التالية:\n     * 1. اختر أصغر حرف من s وألحقه بالنتيجة.\n     * 2. اختر أصغر حرف من s يكون أكبر من آخر حرف تم إلحاقه بالنتيجة وألحقه.\n     * 3. كرر الخطوة 2 حتى لا تتمكن من اختيار المزيد من الأحرف.\n     * 4. اختر أكبر حرف من s وألحقه بالنتيجة.\n     * 5. اختر أكبر حرف من s يكون أصغر من آخر حرف تم إلحاقه بالنتيجة وألحقه.\n     * 6. كرر الخطوة 5 حتى لا تتمكن من اختيار المزيد من الأحرف.\n     * 7. كرر الخطوات من 1 إلى 6 حتى تختار جميع الأحرف من s.\n     * في كل خطوة، إذا ظهر أصغر أو أكبر حرف أكثر من مرة يمكنك اختيار أي تكرار وإلحاقه بالنتيجة.\n     * أعد السلسلة النصية الناتجة بعد ترتيب s بهذه الخوارزمية.\n     */\n    public String sortString(String s)",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa kamba s. Unapaswa kupanga upya kamba kwa kutumia algoriti ifuatayo:\n     * 1. Chagua herufi ndogo zaidi kutoka s na uiongeze kwenye matokeo.\n     * 2. Chagua herufi ndogo zaidi kutoka s ambayo ni kubwa kuliko herufi iliyoongezwa mwisho kwenye matokeo na uiongeze.\n     * 3. Rudia hatua ya 2 hadi huwezi kuchagua herufi zaidi.\n     * 4. Chagua herufi kubwa zaidi kutoka s na uiongeze kwenye matokeo.\n     * 5. Chagua herufi kubwa zaidi kutoka s ambayo ni ndogo kuliko herufi iliyoongezwa mwisho kwenye matokeo na uiongeze.\n     * 6. Rudia hatua ya 5 hadi huwezi kuchagua herufi zaidi.\n     * 7. Rudia hatua kutoka 1 hadi 6 hadi uchague herufi zote kutoka s.\n     * Katika kila hatua, Ikiwa herufi ndogo zaidi au kubwa zaidi inaonekana zaidi ya mara moja unaweza kuchagua tukio lolote na uiongeze kwenye matokeo.\n     * Rejesha kamba ya matokeo baada ya kupanga s kwa algoriti hii.\n     */\n    public String sortString(String s)",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Verilen bir string s. Aşağıdaki algoritmayı kullanarak string'i yeniden sıralamalısınız:\n     * 1. s'den en küçük karakteri seçin ve sonucu ekleyin.\n     * 2. Sonuca eklenen son karakterden daha büyük olan s'den en küçük karakteri seçin ve ekleyin.\n     * 3. Daha fazla karakter seçemeyene kadar 2. adımı tekrarlayın.\n     * 4. s'den en büyük karakteri seçin ve sonucu ekleyin.\n     * 5. Sonuca eklenen son karakterden daha küçük olan s'den en büyük karakteri seçin ve ekleyin.\n     * 6. Daha fazla karakter seçemeyene kadar 5. adımı tekrarlayın.\n     * 7. s'deki tüm karakterleri seçene kadar 1'den 6'ya kadar olan adımları tekrarlayın.\n     * Her adımda, en küçük veya en büyük karakter birden fazla kez görünüyorsa herhangi birini seçip sonucu ekleyebilirsiniz.\n     * Bu algoritma ile s'yi sıraladıktan sonra sonuç stringini döndürün.\n     */\n    public String sortString(String s)",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho một chuỗi s. Bạn nên sắp xếp lại chuỗi sử dụng thuật toán sau:\n     * 1. Chọn ký tự nhỏ nhất từ s và thêm nó vào kết quả.\n     * 2. Chọn ký tự nhỏ nhất từ s lớn hơn ký tự cuối cùng đã thêm vào kết quả và thêm nó.\n     * 3. Lặp lại bước 2 cho đến khi bạn không thể chọn thêm ký tự nào nữa.\n     * 4. Chọn ký tự lớn nhất từ s và thêm nó vào kết quả.\n     * 5. Chọn ký tự lớn nhất từ s nhỏ hơn ký tự cuối cùng đã thêm vào kết quả và thêm nó.\n     * 6. Lặp lại bước 5 cho đến khi bạn không thể chọn thêm ký tự nào nữa.\n     * 7. Lặp lại các bước từ 1 đến 6 cho đến khi bạn chọn hết các ký tự từ s.\n     * Trong mỗi bước, nếu ký tự nhỏ nhất hoặc lớn nhất xuất hiện nhiều hơn một lần, bạn có thể chọn bất kỳ lần xuất hiện nào và thêm nó vào kết quả.\n     * Trả về chuỗi kết quả sau khi sắp xếp s với thuật toán này.\n     */\n    public String sortString(String s)"
    },
    "prompt_bertscore": {
      "es": "0.9518903313006828",
      "arb": "0.9613199113795521",
      "sw": "0.9819288065638269",
      "tr": "0.9594611282738276",
      "vi": "0.9574142421972631"
    },
    "canonical_solution": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }",
    "instruction": {
      "en": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Java باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nAşağıdaki Java kodunun Türkçe'de en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8813072240303164",
      "sw": "0.9426256144380726",
      "tr": "0.8649365052861829",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "sortString",
    "signature": "public String sortString(String s)",
    "docstring": {
      "en": "Given a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
      "es": "Dada una cadena s. Debes reordenar la cadena utilizando el siguiente algoritmo:\n1. Elige el carácter más pequeño de s y añádelo al resultado.\n2. Elige el carácter más pequeño de s que sea mayor que el último carácter añadido al resultado y añádelo.\n3. Repite el paso 2 hasta que no puedas elegir más caracteres.\n4. Elige el carácter más grande de s y añádelo al resultado.\n5. Elige el carácter más grande de s que sea menor que el último carácter añadido al resultado y añádelo.\n6. Repite el paso 5 hasta que no puedas elegir más caracteres.\n7. Repite los pasos del 1 al 6 hasta que elijas todos los caracteres de s.\nEn cada paso, si el carácter más pequeño o el más grande aparece más de una vez, puedes elegir cualquier ocurrencia y añadirla al resultado.\nDevuelve la cadena de resultado después de ordenar s con este algoritmo.",
      "arb": "معطى سلسلة نصية s. يجب عليك إعادة ترتيب السلسلة باستخدام الخوارزمية التالية:\n1. اختر أصغر حرف من s وألحقه بالنتيجة.\n2. اختر أصغر حرف من s يكون أكبر من آخر حرف تم إلحاقه بالنتيجة وألحقه.\n3. كرر الخطوة 2 حتى لا تتمكن من اختيار المزيد من الأحرف.\n4. اختر أكبر حرف من s وألحقه بالنتيجة.\n5. اختر أكبر حرف من s يكون أصغر من آخر حرف تم إلحاقه بالنتيجة وألحقه.\n6. كرر الخطوة 5 حتى لا تتمكن من اختيار المزيد من الأحرف.\n7. كرر الخطوات من 1 إلى 6 حتى تختار جميع الأحرف من s.\nفي كل خطوة، إذا ظهر أصغر أو أكبر حرف أكثر من مرة يمكنك اختيار أي ظهور وإلحاقه بالنتيجة.\nأعد السلسلة النصية الناتجة بعد ترتيب s بهذه الخوارزمية.",
      "sw": "Kwa kupewa kamba s. Unapaswa kupanga upya kamba kwa kutumia algoriti ifuatayo:\n1. Chagua herufi ndogo zaidi kutoka s na uiongeze kwenye matokeo.\n2. Chagua herufi ndogo zaidi kutoka s ambayo ni kubwa kuliko herufi iliyoongezwa mwisho kwenye matokeo na uiongeze.\n3. Rudia hatua ya 2 hadi huwezi kuchagua herufi zaidi.\n4. Chagua herufi kubwa zaidi kutoka s na uiongeze kwenye matokeo.\n5. Chagua herufi kubwa zaidi kutoka s ambayo ni ndogo kuliko herufi iliyoongezwa mwisho kwenye matokeo na uiongeze.\n6. Rudia hatua ya 5 hadi huwezi kuchagua herufi zaidi.\n7. Rudia hatua kutoka 1 hadi 6 hadi uchague herufi zote kutoka s.\nKatika kila hatua, Ikiwa herufi ndogo zaidi au kubwa zaidi inaonekana zaidi ya mara moja unaweza kuchagua tukio lolote na uiongeze kwenye matokeo.\nRudisha kamba ya matokeo baada ya kupanga s kwa algoriti hii.",
      "tr": "Verilen bir string s. String'i aşağıdaki algoritmayı kullanarak yeniden sıralamalısınız:\n1. s'den en küçük karakteri seçin ve sonucu ekleyin.\n2. Sonuca eklenen son karakterden daha büyük olan s'den en küçük karakteri seçin ve ekleyin.\n3. Daha fazla karakter seçemeyene kadar 2. adımı tekrarlayın.\n4. s'den en büyük karakteri seçin ve sonucu ekleyin.\n5. Sonuca eklenen son karakterden daha küçük olan s'den en büyük karakteri seçin ve ekleyin.\n6. Daha fazla karakter seçemeyene kadar 5. adımı tekrarlayın.\n7. s'deki tüm karakterleri seçene kadar 1'den 6'ya kadar olan adımları tekrarlayın.\nHer adımda, en küçük veya en büyük karakter birden fazla kez görünüyorsa, herhangi birini seçip sonucu ekleyebilirsiniz.\nBu algoritma ile s'yi sıraladıktan sonra sonuç stringini döndürün.",
      "vi": "Cho một chuỗi s. Bạn nên sắp xếp lại chuỗi theo thuật toán sau:\n1. Chọn ký tự nhỏ nhất từ s và thêm nó vào kết quả.\n2. Chọn ký tự nhỏ nhất từ s lớn hơn ký tự cuối cùng đã thêm vào kết quả và thêm nó vào.\n3. Lặp lại bước 2 cho đến khi bạn không thể chọn thêm ký tự nào nữa.\n4. Chọn ký tự lớn nhất từ s và thêm nó vào kết quả.\n5. Chọn ký tự lớn nhất từ s nhỏ hơn ký tự cuối cùng đã thêm vào kết quả và thêm nó vào.\n6. Lặp lại bước 5 cho đến khi bạn không thể chọn thêm ký tự nào nữa.\n7. Lặp lại các bước từ 1 đến 6 cho đến khi bạn chọn hết các ký tự từ s.\nTrong mỗi bước, nếu ký tự nhỏ nhất hoặc lớn nhất xuất hiện nhiều lần, bạn có thể chọn bất kỳ lần xuất hiện nào và thêm nó vào kết quả.\nTrả về chuỗi kết quả sau khi sắp xếp s theo thuật toán này."
    },
    "docstring_bertscore": {
      "es": "0.9363904081470064",
      "arb": "0.9445060482553298",
      "sw": "0.9402517827543246",
      "tr": "0.9322706154139617",
      "vi": "0.9212631155881513"
    }
  },
  {
    "task_id": "Java/19",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Verificar si es posible dividir el arreglo de enteros dado en dos arreglos no vacíos\n     * con el mismo promedio.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * تحقق مما إذا كان من الممكن تقسيم مصفوفة الأعداد الصحيحة المعطاة إلى مصفوفتين غير فارغتين\n     * بنفس المتوسط.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Angalia kama inawezekana kugawanya safu ya nambari nzima iliyotolewa katika safu mbili zisizo tupu\n     * zenye wastani sawa.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Verilen tamsayı dizisini aynı ortalamaya sahip iki boş olmayan diziye bölmenin\n     * mümkün olup olmadığını kontrol edin.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Kiểm tra xem có thể chia mảng số nguyên đã cho thành hai mảng không rỗng\n     * với cùng một giá trị trung bình hay không.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.98430939168053"
    },
    "canonical_solution": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "en": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9098984783372402",
      "sw": "0.9149216420432316",
      "tr": "0.8411703801953586",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "splitArraySameAverage",
    "signature": "public boolean splitArraySameAverage(int[] nums)",
    "docstring": {
      "en": "Check if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "es": "Verificar si es posible dividir el array de enteros dado en dos arrays no vacíos con el mismo promedio.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "arb": "تحقق مما إذا كان من الممكن تقسيم مصفوفة الأعداد الصحيحة المعطاة إلى مصفوفتين غير فارغتين\nبمتوسط متساوٍ.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "sw": "Angalia kama inawezekana kugawanya safu ya nambari nzima iliyotolewa kuwa safu mbili zisizo tupu\nzikiwa na wastani sawa.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "tr": "Verilen tamsayı dizisini aynı ortalamaya sahip iki boş olmayan diziye bölmenin mümkün olup olmadığını kontrol edin.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "vi": "Kiểm tra xem có thể tách mảng số nguyên đã cho thành hai mảng không rỗng với cùng một giá trị trung bình hay không.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse"
    },
    "docstring_bertscore": {
      "es": "0.9919816887783837",
      "arb": "0.9862416680272375",
      "sw": "0.9919816887783837",
      "tr": "1",
      "vi": "0.9905791596578963"
    }
  },
  {
    "task_id": "Java/20",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "es": "class Solution {\n    /**\n     * Dado un arreglo de enteros cost donde cost[i] es el costo del i-ésimo escalón en una escalera,\n     * devuelve el costo mínimo para llegar a la cima del piso.\n     * Puedes comenzar desde el escalón con índice 0 o el escalón con índice 1.\n     *\n     * Ejemplo:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explicación: Comenzarás en el índice 1.\n     * - Pagas 15 y subes dos escalones para llegar a la cima.\n     * El costo total es 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explicación: Comenzarás en el índice 0.\n     * - Pagas 1 y subes dos escalones para llegar al índice 2.\n     * - Pagas 1 y subes dos escalones para llegar al índice 4.\n     * - Pagas 1 y subes dos escalones para llegar al índice 6.\n     * - Pagas 1 y subes un escalón para llegar al índice 7.\n     * - Pagas 1 y subes dos escalones para llegar al índice 9.\n     * - Pagas 1 y subes un escalón para llegar a la cima.\n     * El costo total es 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى مصفوفة أعداد صحيحة cost حيث cost[i] هو تكلفة الخطوة i على الدرج،\n     * أعد التكلفة الدنيا للوصول إلى قمة الطابق.\n     * يمكنك البدء إما من الخطوة ذات الفهرس 0 أو الخطوة ذات الفهرس 1.\n     *\n     * مثال:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * التوضيح: ستبدأ عند الفهرس 1.\n     * - ادفع 15 واصعد خطوتين للوصول إلى القمة.\n     * التكلفة الإجمالية هي 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * التوضيح: ستبدأ عند الفهرس 0.\n     * - ادفع 1 واصعد خطوتين للوصول إلى الفهرس 2.\n     * - ادفع 1 واصعد خطوتين للوصول إلى الفهرس 4.\n     * - ادفع 1 واصعد خطوتين للوصول إلى الفهرس 6.\n     * - ادفع 1 واصعد خطوة واحدة للوصول إلى الفهرس 7.\n     * - ادفع 1 واصعد خطوتين للوصول إلى الفهرس 9.\n     * - ادفع 1 واصعد خطوة واحدة للوصول إلى القمة.\n     * التكلفة الإجمالية هي 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa safu ya nambari nzima `cost` ambapo `cost[i]` ni gharama ya hatua ya ith kwenye ngazi,\n     * rudisha gharama ndogo zaidi kufikia juu ya sakafu.\n     * Unaweza kuanza ama kutoka hatua yenye index 0 au hatua yenye index 1.\n     *\n     * Mfano:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Maelezo: Utaanza kwenye index 1.\n     * - Lipa 15 na panda hatua mbili kufikia juu.\n     * Gharama jumla ni 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Maelezo: Utaanza kwenye index 0.\n     * - Lipa 1 na panda hatua mbili kufikia index 2.\n     * - Lipa 1 na panda hatua mbili kufikia index 4.\n     * - Lipa 1 na panda hatua mbili kufikia index 6.\n     * - Lipa 1 na panda hatua moja kufikia index 7.\n     * - Lipa 1 na panda hatua mbili kufikia index 9.\n     * - Lipa 1 na panda hatua moja kufikia juu.\n     * Gharama jumla ni 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "tr": "class Solution {\n    /**\n     * Bir merdivendeki i. basamağın maliyeti cost[i] olan bir tamsayı dizisi verildiğinde,\n     * katın tepesine ulaşmak için minimum maliyeti döndürün.\n     * 0. indeksli basamaktan veya 1. indeksli basamaktan başlayabilirsiniz.\n     *\n     * Örnek:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Açıklama: 1. indeksten başlayacaksınız.\n     * - 15 ödeyin ve tepeye ulaşmak için iki basamak çıkın.\n     * Toplam maliyet 15'tir.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Açıklama: 0. indeksten başlayacaksınız.\n     * - 1 ödeyin ve 2. indekse ulaşmak için iki basamak çıkın.\n     * - 1 ödeyin ve 4. indekse ulaşmak için iki basamak çıkın.\n     * - 1 ödeyin ve 6. indekse ulaşmak için iki basamak çıkın.\n     * - 1 ödeyin ve 7. indekse ulaşmak için bir basamak çıkın.\n     * - 1 ödeyin ve 9. indekse ulaşmak için iki basamak çıkın.\n     * - 1 ödeyin ve tepeye ulaşmak için bir basamak çıkın.\n     * Toplam maliyet 6'dır.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "vi": "class Solution {\n    /**\n     * Cho một mảng số nguyên cost trong đó cost[i] là chi phí của bậc thang thứ i trên cầu thang,\n     * trả về chi phí tối thiểu để đạt đến đỉnh của tầng.\n     * Bạn có thể bắt đầu từ bậc có chỉ số 0 hoặc bậc có chỉ số 1.\n     *\n     * Ví dụ:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Giải thích: Bạn sẽ bắt đầu tại chỉ số 1.\n     * - Trả 15 và leo hai bậc để đến đỉnh.\n     * Tổng chi phí là 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Giải thích: Bạn sẽ bắt đầu tại chỉ số 0.\n     * - Trả 1 và leo hai bậc để đến chỉ số 2.\n     * - Trả 1 và leo hai bậc để đến chỉ số 4.\n     * - Trả 1 và leo hai bậc để đến chỉ số 6.\n     * - Trả 1 và leo một bậc để đến chỉ số 7.\n     * - Trả 1 và leo hai bậc để đến chỉ số 9.\n     * - Trả 1 và leo một bậc để đến đỉnh.\n     * Tổng chi phí là 6.\n     */\n  public int minCostClimbingStairs(int[] cost) "
    },
    "prompt_bertscore": {
      "es": "0.9816475459442815",
      "arb": "0.980927312182649",
      "sw": "0.9717911091765683",
      "tr": "0.934663316983908",
      "vi": "0.987571697058647"
    },
    "canonical_solution": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }",
    "instruction": {
      "en": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nتقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9110543085244822",
      "sw": "0.9149216420432316",
      "tr": "0.892293669035737",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "minCostClimbingStairs",
    "signature": "public int minCostClimbingStairs(int[] cost)",
    "docstring": {
      "en": "Given an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.",
      "es": "Dado un array de enteros `cost` donde `cost[i]` es el costo del i-ésimo escalón en una escalera, devuelve el costo mínimo para llegar a la cima del piso. Puedes comenzar desde el escalón con índice 0 o el escalón con índice 1.\n\nEjemplo:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplicación: Comenzarás en el índice 1.\n- Paga 15 y sube dos escalones para llegar a la cima.\nEl costo total es 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplicación: Comenzarás en el índice 0.\n- Paga 1 y sube dos escalones para llegar al índice 2.\n- Paga 1 y sube dos escalones para llegar al índice 4.\n- Paga 1 y sube dos escalones para llegar al índice 6.\n- Paga 1 y sube un escalón para llegar al índice 7.\n- Paga 1 y sube dos escalones para llegar al índice 9.\n- Paga 1 y sube un escalón para llegar a la cima.\nEl costo total es 6.",
      "arb": "معطى مصفوفة أعداد صحيحة cost حيث cost[i] هو تكلفة الخطوة i على الدرج، أعد التكلفة الدنيا للوصول إلى قمة الطابق. يمكنك البدء إما من الخطوة ذات الفهرس 0 أو الخطوة ذات الفهرس 1.\n\nمثال:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nتوضيح: ستبدأ عند الفهرس 1.\n- ادفع 15 واصعد خطوتين للوصول إلى القمة.\nالتكلفة الإجمالية هي 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nتوضيح: ستبدأ عند الفهرس 0.\n- ادفع 1 واصعد خطوتين للوصول إلى الفهرس 2.\n- ادفع 1 واصعد خطوتين للوصول إلى الفهرس 4.\n- ادفع 1 واصعد خطوتين للوصول إلى الفهرس 6.\n- ادفع 1 واصعد خطوة واحدة للوصول إلى الفهرس 7.\n- ادفع 1 واصعد خطوتين للوصول إلى الفهرس 9.\n- ادفع 1 واصعد خطوة واحدة للوصول إلى القمة.\nالتكلفة الإجمالية هي 6.",
      "sw": "Ukipiwa safu ya nambari nzima `cost` ambapo `cost[i]` ni gharama ya hatua ya ith kwenye ngazi, rudisha gharama ndogo zaidi kufikia juu ya sakafu. Unaweza kuanza ama kutoka kwenye hatua yenye faharasa 0 au hatua yenye faharasa 1.\n\nMfano:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nMaelezo: Utaanza kwenye faharasa 1.\n- Lipa 15 na panda hatua mbili kufikia juu.\nGharama jumla ni 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nMaelezo: Utaanza kwenye faharasa 0.\n- Lipa 1 na panda hatua mbili kufikia faharasa 2.\n- Lipa 1 na panda hatua mbili kufikia faharasa 4.\n- Lipa 1 na panda hatua mbili kufikia faharasa 6.\n- Lipa 1 na panda hatua moja kufikia faharasa 7.\n- Lipa 1 na panda hatua mbili kufikia faharasa 9.\n- Lipa 1 na panda hatua moja kufikia juu.\nGharama jumla ni 6.",
      "tr": "Verilen bir tamsayı dizisi olan cost'ta, cost[i] bir merdivenin i'inci basamağının maliyetidir, katın tepesine ulaşmak için minimum maliyeti döndürün. 0. indeksli basamaktan veya 1. indeksli basamaktan başlayabilirsiniz.\n\nÖrnek:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nAçıklama: 1. indeksten başlayacaksınız.\n- 15 ödeyin ve tepeye ulaşmak için iki basamak çıkın.\nToplam maliyet 15'tir.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nAçıklama: 0. indeksten başlayacaksınız.\n- 1 ödeyin ve 2. indekse ulaşmak için iki basamak çıkın.\n- 1 ödeyin ve 4. indekse ulaşmak için iki basamak çıkın.\n- 1 ödeyin ve 6. indekse ulaşmak için iki basamak çıkın.\n- 1 ödeyin ve 7. indekse ulaşmak için bir basamak çıkın.\n- 1 ödeyin ve 9. indekse ulaşmak için iki basamak çıkın.\n- 1 ödeyin ve tepeye ulaşmak için bir basamak çıkın.\nToplam maliyet 6'dır.",
      "vi": "Cho một mảng số nguyên `cost` trong đó `cost[i]` là chi phí của bậc thang thứ i trên cầu thang, trả về chi phí tối thiểu để đạt đến đỉnh của tầng. Bạn có thể bắt đầu từ bậc thang với chỉ số 0 hoặc bậc thang với chỉ số 1.\n\nVí dụ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nGiải thích: Bạn sẽ bắt đầu ở chỉ số 1.\n- Trả 15 và leo hai bậc để đến đỉnh.\nTổng chi phí là 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nGiải thích: Bạn sẽ bắt đầu ở chỉ số 0.\n- Trả 1 và leo hai bậc để đến chỉ số 2.\n- Trả 1 và leo hai bậc để đến chỉ số 4.\n- Trả 1 và leo hai bậc để đến chỉ số 6.\n- Trả 1 và leo một bậc để đến chỉ số 7.\n- Trả 1 và leo hai bậc để đến chỉ số 9.\n- Trả 1 và leo một bậc để đến đỉnh.\nTổng chi phí là 6."
    },
    "docstring_bertscore": {
      "es": "0.961262705829814",
      "arb": "0.9662231023353983",
      "sw": "0.9670825759941363",
      "tr": "0.941791565468107",
      "vi": "0.961262705829814"
    }
  },
  {
    "task_id": "Java/21",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dado un array de cadenas de texto words donde cada palabra puede ser escrita como una concatenación del código Morse de cada letra,\n     * devuelve el número de transformaciones diferentes entre todas las palabras.\n     *\n     * Ejemplo:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى مصفوفة من السلاسل words حيث يمكن كتابة كل كلمة كدمج لشيفرة مورس لكل حرف،\n     * أعد عدد التحويلات المختلفة بين جميع الكلمات.\n     *\n     * مثال:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa safu ya maneno words ambapo kila neno linaweza kuandikwa kama muunganiko wa msimbo wa Morse wa kila herufi,\n     * rudisha idadi ya mabadiliko tofauti kati ya maneno yote.\n     *\n     * Mfano:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Her kelimenin her harfinin Mors kodu olarak birleştirilmesiyle yazılabileceği bir dizi kelime verildiğinde,\n     * tüm kelimeler arasında farklı dönüşümlerin sayısını döndürün.\n     *\n     * Örnek:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho một mảng các chuỗi words trong đó mỗi từ có thể được viết dưới dạng nối tiếp mã Morse của từng chữ cái,\n     * trả về số lượng các biến đổi khác nhau trong tất cả các từ.\n     *\n     * Ví dụ:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) "
    },
    "prompt_bertscore": {
      "es": "0.9962137076767129",
      "arb": "0.9928934022273338",
      "sw": "0.9696020037471828",
      "tr": "0.9884989036773179",
      "vi": "0.9919536818946577"
    },
    "canonical_solution": "    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }",
    "instruction": {
      "en": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.857837256837615",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "uniqueMorseRepresentations",
    "signature": "public int uniqueMorseRepresentations(String[] words)",
    "docstring": {
      "en": "Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "es": "Dado un array de cadenas de texto words donde cada palabra puede escribirse como una concatenación del código Morse de cada letra, devuelve el número de transformaciones diferentes entre todas las palabras.\n\nEjemplo:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "arb": "نظرًا لمصفوفة من السلاسل النصية words حيث يمكن كتابة كل كلمة كدمج لرموز مورس لكل حرف، قم بإرجاع عدد التحويلات المختلفة بين جميع الكلمات.\n\nمثال:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "sw": "Ukipatiwa safu ya maneno `words` ambapo kila neno linaweza kuandikwa kama muunganiko wa msimbo wa Morse wa kila herufi, rudisha idadi ya mabadiliko tofauti kati ya maneno yote.\n\nMfano:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "tr": "Verilen bir kelimeler dizisinde, her kelime her harfin Mors kodunun birleştirilmesi olarak yazılabiliyorsa, tüm kelimeler arasında farklı dönüşümlerin sayısını döndür.\n\nÖrnek:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "vi": "Cho một mảng các chuỗi words, trong đó mỗi từ có thể được viết dưới dạng một sự nối tiếp của mã Morse của từng chữ cái, trả về số lượng biến đổi khác nhau trong tất cả các từ.\n\nVí dụ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1"
    },
    "docstring_bertscore": {
      "es": "0.9855919480508724",
      "arb": "0.9804531814631188",
      "sw": "0.9710547863540719",
      "tr": "0.9618053640308013",
      "vi": "0.9873524091179845"
    }
  },
  {
    "task_id": "Java/22",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dado un string binario s y un entero k, devuelve true si cada string binario de longitud k es una subcadena de s, o false en caso contrario.\n     *\n     * Ejemplo 1:\n     * Entrada: s = \"00110110\", k = 2\n     * Salida: true\n     * Explicación: Todos los strings binarios de longitud 2 (\"00\", \"01\", \"10\", y \"11\") son subcadenas de s.\n     *\n     * Ejemplo 2:\n     * Entrada: s = \"0110\", k = 1\n     * Salida: true\n     * Explicación: Todos los strings binarios de longitud 1 (\"0\" y \"1\") son subcadenas de s.\n     *\n     * Ejemplo 3:\n     * Entrada: s = \"0110\", k = 2\n     * Salida: false\n     * Explicación: El string binario \"00\" no es una subcadena de s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى سلسلة ثنائية s وعدد صحيح k، أعد true إذا كانت كل سلسلة ثنائية بطول k هي جزء من السلسلة s، أو false خلاف ذلك.\n     *\n     * المثال 1:\n     * المدخل: s = \"00110110\", k = 2\n     * المخرج: true\n     * التوضيح: جميع السلاسل الثنائية بطول 2 (\"00\"، \"01\"، \"10\"، و\"11\") هي أجزاء من السلسلة s.\n     *\n     * المثال 2:\n     * المدخل: s = \"0110\", k = 1\n     * المخرج: true\n     * التوضيح: جميع السلاسل الثنائية بطول 1 (\"0\" و\"1\") هي أجزاء من السلسلة s.\n     *\n     * المثال 3:\n     * المدخل: s = \"0110\", k = 2\n     * المخرج: false\n     * التوضيح: السلسلة الثنائية \"00\" ليست جزءًا من السلسلة s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa kamba ya binary s na nambari k, rudisha kweli ikiwa kila kamba ya binary ya urefu k ni sehemu ndogo ya s, au uongo vinginevyo.\n     *\n     * Mfano 1:\n     * Ingizo: s = \"00110110\", k = 2\n     * Matokeo: kweli\n     * Maelezo: Kamba zote za binary za urefu 2 (\"00\", \"01\", \"10\", na \"11\") ni sehemu ndogo za s.\n     *\n     * Mfano 2:\n     * Ingizo: s = \"0110\", k = 1\n     * Matokeo: kweli\n     * Maelezo: Kamba zote za binary za urefu 1 (\"0\" na \"1\") ni sehemu ndogo za s.\n     *\n     * Mfano 3:\n     * Ingizo: s = \"0110\", k = 2\n     * Matokeo: uongo\n     * Maelezo: Kamba ya binary \"00\" si sehemu ndogo ya s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * İkili bir string s ve bir tamsayı k verildiğinde, uzunluğu k olan her ikili string s'nin bir alt dizesi ise true, aksi takdirde false döndürün.\n     *\n     * Örnek 1:\n     * Girdi: s = \"00110110\", k = 2\n     * Çıktı: true\n     * Açıklama: Uzunluğu 2 olan tüm ikili stringler (\"00\", \"01\", \"10\" ve \"11\") s'nin alt dizeleridir.\n     *\n     * Örnek 2:\n     * Girdi: s = \"0110\", k = 1\n     * Çıktı: true\n     * Açıklama: Uzunluğu 1 olan tüm ikili stringler (\"0\" ve \"1\") s'nin alt dizeleridir.\n     *\n     * Örnek 3:\n     * Girdi: s = \"0110\", k = 2\n     * Çıktı: false\n     * Açıklama: \"00\" ikili stringi s'nin bir alt dizisi değildir.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho một chuỗi nhị phân s và một số nguyên k, trả về true nếu mọi chuỗi nhị phân có độ dài k là một chuỗi con của s, hoặc false nếu không.\n     *\n     * Ví dụ 1:\n     * Đầu vào: s = \"00110110\", k = 2\n     * Đầu ra: true\n     * Giải thích: Tất cả các chuỗi nhị phân có độ dài 2 (\"00\", \"01\", \"10\", và \"11\") đều là chuỗi con của s.\n     *\n     * Ví dụ 2:\n     * Đầu vào: s = \"0110\", k = 1\n     * Đầu ra: true\n     * Giải thích: Tất cả các chuỗi nhị phân có độ dài 1 (\"0\" và \"1\") đều là chuỗi con của s.\n     *\n     * Ví dụ 3:\n     * Đầu vào: s = \"0110\", k = 2\n     * Đầu ra: false\n     * Giải thích: Chuỗi nhị phân \"00\" không phải là chuỗi con của s.\n     */\n  public boolean hasAllCodes(String s, int k) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9882750472378916",
      "sw": "0.9882750472378916",
      "tr": "0.9954364669957234",
      "vi": "1"
    },
    "canonical_solution": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "instruction": {
      "en": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8828771985620161",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "hasAllCodes",
    "signature": "public boolean hasAllCodes(String s, int k)",
    "docstring": {
      "en": "Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.",
      "es": "Dado un string binario s y un entero k, devuelve true si cada string binario de longitud k es una subcadena de s, o false en caso contrario.\n\nEjemplo 1:\nEntrada: s = \"00110110\", k = 2\nSalida: true\nExplicación: Todos los strings binarios de longitud 2 (\"00\", \"01\", \"10\", y \"11\") son subcadenas de s.\n\nEjemplo 2:\nEntrada: s = \"0110\", k = 1\nSalida: true\nExplicación: Todos los strings binarios de longitud 1 (\"0\" y \"1\") son subcadenas de s.\n\nEjemplo 3:\nEntrada: s = \"0110\", k = 2\nSalida: false\nExplicación: El string binario \"00\" no es una subcadena de s.",
      "arb": "بالنظر إلى سلسلة ثنائية s وعدد صحيح k، أعد true إذا كانت كل سلسلة ثنائية بطول k هي جزء من السلسلة s، أو false خلاف ذلك.\n\nمثال 1:\nالمدخلات: s = \"00110110\", k = 2\nالناتج: true\nالتفسير: جميع السلاسل الثنائية بطول 2 (\"00\"، \"01\"، \"10\"، و \"11\") هي سلاسل فرعية من s.\n\nمثال 2:\nالمدخلات: s = \"0110\", k = 1\nالناتج: true\nالتفسير: جميع السلاسل الثنائية بطول 1 (\"0\" و \"1\") هي سلاسل فرعية من s.\n\nمثال 3:\nالمدخلات: s = \"0110\", k = 2\nالناتج: false\nالتفسير: السلسلة الثنائية \"00\" ليست سلسلة فرعية من s.",
      "sw": "Ukipewa kamba ya binary s na nambari k, rudisha kweli ikiwa kila kamba ya binary ya urefu k ni sehemu ndogo ya s, au uongo vinginevyo.\n\nMfano 1:\nIngizo: s = \"00110110\", k = 2\nMatokeo: true\nUfafanuzi: Kamba zote za binary za urefu wa 2 (\"00\", \"01\", \"10\", na \"11\") ni sehemu ndogo za s.\n\nMfano 2:\nIngizo: s = \"0110\", k = 1\nMatokeo: true\nUfafanuzi: Kamba zote za binary za urefu wa 1 (\"0\" na \"1\") ni sehemu ndogo za s.\n\nMfano 3:\nIngizo: s = \"0110\", k = 2\nMatokeo: false\nUfafanuzi: Kamba ya binary \"00\" si sehemu ndogo ya s.",
      "tr": "Verilen bir ikili string s ve bir tamsayı k için, uzunluğu k olan her ikili string s'nin bir alt dizisi ise true, aksi takdirde false döndürün.\n\nÖrnek 1:\nGirdi: s = \"00110110\", k = 2\nÇıktı: true\nAçıklama: Uzunluğu 2 olan tüm ikili stringler (\"00\", \"01\", \"10\" ve \"11\") s'nin alt dizileridir.\n\nÖrnek 2:\nGirdi: s = \"0110\", k = 1\nÇıktı: true\nAçıklama: Uzunluğu 1 olan tüm ikili stringler (\"0\" ve \"1\") s'nin alt dizileridir.\n\nÖrnek 3:\nGirdi: s = \"0110\", k = 2\nÇıktı: false\nAçıklama: İkili string \"00\" s'nin bir alt dizisi değildir.",
      "vi": "Cho một chuỗi nhị phân s và một số nguyên k, trả về true nếu mọi chuỗi nhị phân có độ dài k là một chuỗi con của s, hoặc false nếu không.\n\nVí dụ 1:\nĐầu vào: s = \"00110110\", k = 2\nĐầu ra: true\nGiải thích: Tất cả các chuỗi nhị phân có độ dài 2 (\"00\", \"01\", \"10\", và \"11\") đều là các chuỗi con của s.\n\nVí dụ 2:\nĐầu vào: s = \"0110\", k = 1\nĐầu ra: true\nGiải thích: Tất cả các chuỗi nhị phân có độ dài 1 (\"0\" và \"1\") đều là các chuỗi con của s.\n\nVí dụ 3:\nĐầu vào: s = \"0110\", k = 2\nĐầu ra: false\nGiải thích: Chuỗi nhị phân \"00\" không phải là một chuỗi con của s."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.994283814894578",
      "vi": "1"
    }
  },
  {
    "task_id": "Java/23",
    "prompt": {
      "en": "class Solution {\n    /**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "es": "class Solution {\n    /**\n    * Verifica si searchWord es un prefijo de alguna palabra en la oración.\n    * Si searchWord es un prefijo de múltiples palabras, devuelve el índice de la primera palabra coincidente.\n    * Si searchWord no es un prefijo de ninguna palabra, devuelve -1.\n    * \n    * Ejemplo:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "arb": "class Solution {\n    /**\n    * تحقق مما إذا كانت searchWord هي بادئة لأي كلمة في الجملة.\n    * إذا كانت searchWord بادئة لعدة كلمات، قم بإرجاع فهرس الكلمة المطابقة الأولى.\n    * إذا لم تكن searchWord بادئة لأي كلمة، قم بإرجاع -1.\n    * \n    * مثال:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "sw": "class Solution {\n    /**\n    * Angalia kama searchWord ni kiambishi awali cha neno lolote katika sentensi.\n    * Kama searchWord ni kiambishi awali cha maneno kadhaa, rudisha faharasa ya neno la kwanza linalolingana.\n    * Kama searchWord si kiambishi awali cha neno lolote, rudisha -1.\n    * \n    * Mfano:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "tr": "class Solution {\n    /**\n    * searchWord'un cümledeki herhangi bir kelimenin ön eki olup olmadığını kontrol edin.\n    * Eğer searchWord birden fazla kelimenin ön eki ise, ilk eşleşen kelimenin indeksini döndürün.\n    * Eğer searchWord hiçbir kelimenin ön eki değilse, -1 döndürün.\n    * \n    * Örnek:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "vi": "class Solution {\n    /**\n    * Kiểm tra xem searchWord có phải là tiền tố của bất kỳ từ nào trong câu hay không.\n    * Nếu searchWord là tiền tố của nhiều từ, trả về chỉ số của từ khớp đầu tiên.\n    * Nếu searchWord không phải là tiền tố của bất kỳ từ nào, trả về -1.\n    * \n    * Ví dụ:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) "
    },
    "prompt_bertscore": {
      "es": "0.9916100513354673",
      "arb": "0.9951998982119109",
      "sw": "0.9937910129192304",
      "tr": "0.990765474955307",
      "vi": "0.9951998982119109"
    },
    "canonical_solution": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }",
    "instruction": {
      "en": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nAşağıdaki Java kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.8612562815863686",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isPrefixOfWord",
    "signature": "public int isPrefixOfWord(String sentence, String searchWord)",
    "docstring": {
      "en": "Check if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "es": "Verifica si searchWord es un prefijo de alguna palabra en la oración.  \nSi searchWord es un prefijo de múltiples palabras, devuelve el índice de la primera palabra coincidente.  \nSi searchWord no es un prefijo de ninguna palabra, devuelve -1.  \n\nEjemplo:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  ",
      "arb": "تحقق مما إذا كانت searchWord هي بادئة لأي كلمة في الجملة.  \nإذا كانت searchWord بادئة لعدة كلمات، أعد فهرس الكلمة المطابقة الأولى.  \nإذا لم تكن searchWord بادئة لأي كلمة، أعد -1.\n\nمثال:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  ",
      "sw": "Angalia kama searchWord ni kiambishi awali cha neno lolote katika sentensi. \nKama searchWord ni kiambishi awali cha maneno mengi, rudisha faharasa ya neno la kwanza linalolingana. \nKama searchWord si kiambishi awali cha neno lolote, rudisha -1.\n\nMfano:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "tr": "Verilen cümlede searchWord'un herhangi bir kelimenin ön eki olup olmadığını kontrol edin.\nEğer searchWord birden fazla kelimenin ön eki ise, eşleşen ilk kelimenin indeksini döndürün.\nEğer searchWord hiçbir kelimenin ön eki değilse, -1 döndürün.\n\nÖrnek:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "vi": "Kiểm tra xem searchWord có phải là tiền tố của bất kỳ từ nào trong câu hay không.  \nNếu searchWord là tiền tố của nhiều từ, trả về chỉ số của từ khớp đầu tiên.  \nNếu searchWord không phải là tiền tố của bất kỳ từ nào, trả về -1.  \n\nVí dụ:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  "
    },
    "docstring_bertscore": {
      "es": "0.9940166570320861",
      "arb": "0.9899610219121158",
      "sw": "0.9940166570320861",
      "tr": "0.9807243119332314",
      "vi": "0.9940166570320861"
    }
  },
  {
    "task_id": "Java/24",
    "prompt": {
      "en": "class Solution {\n    /**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    */\n public int minInsertions(String s) ",
      "es": "class Solution {\n    /**\n    * Dada una cadena s compuesta de '(' y ')', los paréntesis izquierdos y derechos en s pueden estar desequilibrados. Cada operación puede insertar un '(' o ')', y calcular el número mínimo de operaciones de inserción requeridas. Hacer que los paréntesis izquierdos y derechos en s estén equilibrados.\n    *\n    * Ejemplo 1:\n    * Entrada: s = \"(()))\"\n    * Salida: 1\n    * Explicación: Necesitamos agregar un '(' al inicio de la cadena para que esté equilibrada: \"((()))\".\n    * Ejemplo 2:\n    * Entrada: s = \"((()))\"\n    * Salida: 0\n    *\n    * - s consiste solo de '(' y ')'.\n    */\n public int minInsertions(String s) ",
      "arb": "class Solution {\n    /**\n    * بالنظر إلى سلسلة s مكونة من '(' و ')', قد تكون الأقواس اليسرى واليمنى في s غير متوازنة. يمكن لكل عملية إدراج '(' أو ')', وحساب الحد الأدنى لعدد عمليات الإدراج المطلوبة. اجعل الأقواس اليسرى واليمنى في s متوازنة.\n    *\n    * المثال 1:\n    * المدخلات: s = \"(()))\"\n    * الناتج: 1\n    * الشرح: نحتاج إلى إضافة '(' واحدة في بداية السلسلة لجعلها متوازنة: \"((()))\".\n    * المثال 2:\n    * المدخلات: s = \"((()))\"\n    * الناتج: 0\n    *\n    * - s يتكون فقط من '(' و ')'.\n    */\n public int minInsertions(String s) ",
      "sw": "class Solution {\n    /**\n    * Ukipewa kamba s inayojumuisha '(' na ')', mabano ya kushoto na kulia katika s yanaweza kuwa hayalingani. Kila operesheni inaweza kuingiza '(' au ')', na kuhesabu idadi ndogo ya operesheni za kuingiza zinazohitajika. Fanya mabano ya kushoto na kulia katika s yawe yamelingana.\n    *\n    * Mfano 1:\n    * Ingizo: s = \"(()))\"\n    * Matokeo: 1\n    * Maelezo: Tunahitaji kuongeza moja '(' mwanzoni mwa kamba ili kuifanya iwe imelingana: \"((()))\".\n    * Mfano 2:\n    * Ingizo: s = \"((()))\"\n    * Matokeo: 0\n    *\n    * - s inajumuisha '(' na ')' pekee.\n    */\n public int minInsertions(String s) ",
      "tr": "class Solution {\n    /**\n    * Verilen bir s dizesi '(' ve ')' karakterlerinden oluşur, s içindeki sol ve sağ parantezler dengesiz olabilir. Her işlem bir '(' veya ')' ekleyebilir ve gerekli minimum ekleme işlemi sayısını hesaplayabilir. s içindeki sol ve sağ parantezleri dengeli hale getirin.\n    *\n    * Örnek 1:\n    * Girdi: s = \"(()))\"\n    * Çıktı: 1\n    * Açıklama: Dizeyi dengeli hale getirmek için başına bir '(' eklememiz gerekiyor: \"((()))\".\n    * Örnek 2:\n    * Girdi: s = \"((()))\"\n    * Çıktı: 0\n    *\n    * - s yalnızca '(' ve ')' karakterlerinden oluşur.\n    */\n public int minInsertions(String s) ",
      "vi": "class Solution {\n    /**\n    * Cho một chuỗi s bao gồm '(' và ')', các dấu ngoặc trái và phải trong s có thể không cân bằng. Mỗi thao tác có thể chèn một '(' hoặc ')', và tính toán số lượng thao tác chèn tối thiểu cần thiết. Làm cho các dấu ngoặc trái và phải trong s cân bằng.\n    *\n    * Ví dụ 1:\n    * Đầu vào: s = \"(()))\"\n    * Đầu ra: 1\n    * Giải thích: Chúng ta cần thêm một '(' ở đầu chuỗi để làm cho nó cân bằng: \"((()))\".\n    * Ví dụ 2:\n    * Đầu vào: s = \"((()))\"\n    * Đầu ra: 0\n    *\n    * - s chỉ bao gồm '(' và ')'.\n    */\n public int minInsertions(String s) "
    },
    "prompt_bertscore": {
      "es": "0.9801304070939371",
      "arb": "0.971385505938495",
      "sw": "0.9634110920310874",
      "tr": "0.947717901516664",
      "vi": "0.9792447142249024"
    },
    "canonical_solution": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }",
    "instruction": {
      "en": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9134398594007113",
      "sw": "0.9149216420432316",
      "tr": "0.8837954668135404",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "minInsertions",
    "signature": "public int minInsertions(String s)",
    "docstring": {
      "en": "Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.",
      "es": "Dada una cadena s compuesta de '(' y ')', los paréntesis izquierdos y derechos en s pueden estar desbalanceados. Cada operación puede insertar un '(' o ')', y calcular el número mínimo de operaciones de inserción requeridas. Hacer que los paréntesis izquierdos y derechos en s estén balanceados.\n\nEjemplo 1:\nEntrada: s = \"(()))\"\nSalida: 1\nExplicación: Necesitamos agregar un '(' al inicio de la cadena para que esté balanceada: \"((()))\".\nEjemplo 2:\nEntrada: s = \"((()))\"\nSalida: 0\n\n- s consiste solo de '(' y ')'.",
      "arb": "نظرًا لسلسلة s مكونة من '(' و ')', قد تكون الأقواس اليسرى واليمنى في s غير متوازنة. كل عملية يمكنها إدراج '(' أو ')', وحساب الحد الأدنى لعدد عمليات الإدراج المطلوبة. اجعل الأقواس اليسرى واليمنى في s متوازنة.\n\nمثال 1:\nالمدخلات: s = \"(()))\"\nالناتج: 1\nالتفسير: نحتاج إلى إضافة '(' واحدة في بداية السلسلة لجعلها متوازنة: \"((()))\".\nمثال 2:\nالمدخلات: s = \"((()))\"\nالناتج: 0\n\n- s تتكون من '(' و ')' فقط.",
      "sw": "Ukipewa kamba s inayojumuisha '(' na ')', mabano ya kushoto na kulia katika s yanaweza kuwa hayalingani. Kila operesheni inaweza kuingiza '(' au ')', na kuhesabu idadi ndogo ya operesheni za kuingiza zinazohitajika. Fanya mabano ya kushoto na kulia katika s yawe yamelingana.\n\nMfano 1:\nIngizo: s = \"(()))\"\nMatokeo: 1\nMaelezo: Tunahitaji kuongeza moja '(' mwanzoni mwa kamba ili kuifanya iwe sawa: \"((()))\".\n\nMfano 2:\nIngizo: s = \"((()))\"\nMatokeo: 0\n\n- s inajumuisha '(' na ')' pekee.",
      "tr": "Verilen bir s dizesi '(' ve ')' karakterlerinden oluşur, s içindeki sol ve sağ parantezler dengesiz olabilir. Her işlem bir '(' veya ')' ekleyebilir ve gerekli minimum ekleme işlemi sayısını hesaplar. s içindeki sol ve sağ parantezleri dengeli hale getirin.\n\nÖrnek 1:\nGirdi: s = \"(()))\"\nÇıktı: 1\nAçıklama: Dizeyi dengeli hale getirmek için dizenin başına bir '(' eklememiz gerekiyor: \"((()))\".\nÖrnek 2:\nGirdi: s = \"((()))\"\nÇıktı: 0\n\n- s yalnızca '(' ve ')' karakterlerinden oluşur.",
      "vi": "Cho một chuỗi s bao gồm '(' và ')', các dấu ngoặc trái và phải trong s có thể không cân bằng. Mỗi thao tác có thể chèn một '(' hoặc ')', và tính toán số lượng tối thiểu các thao tác chèn cần thiết. Làm cho các dấu ngoặc trái và phải trong s cân bằng.\n\nVí dụ 1:\nĐầu vào: s = \"(()))\"\nĐầu ra: 1\nGiải thích: Chúng ta cần thêm một '(' ở đầu chuỗi để làm cho nó cân bằng: \"((()))\".\nVí dụ 2:\nĐầu vào: s = \"((()))\"\nĐầu ra: 0\n\n- s chỉ bao gồm '(' và ')'."
    },
    "docstring_bertscore": {
      "es": "0.9781500621950192",
      "arb": "0.9788941316023759",
      "sw": "0.9967502083358882",
      "tr": "0.9446774662741629",
      "vi": "0.9737259677182292"
    }
  },
  {
    "task_id": "Java/25",
    "prompt": {
      "en": "class Solution {\n  /**\n  * Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\n  * The array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\n  * In one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\n  * The goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n  *\n  * Example 1:\n  * Input: n = 3\n  * Output: 2\n  * Explanation: arr = [1, 3, 5]\n  * First operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Second operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Example 2:\n  * Input: n = 6\n  * Output: 9\n  */\n  public int minOperations(int n) ",
      "es": "class Solution {\n  /**\n  * Dado un entero n, devuelve el número mínimo de operaciones requeridas para hacer que todos los elementos en el arreglo arr sean iguales.\n  * El arreglo arr tiene una longitud de n, y arr[i] = (2 * i) + 1 para 0 <= i < n.\n  * En una operación, puedes seleccionar dos índices x e y (0 <= x, y < n) y restar 1 de arr[x] y sumar 1 a arr[y] (es decir, arr[x] -= 1 y arr[y] += 1).\n  * El objetivo es hacer que todos los elementos en arr sean iguales. Los casos de prueba asegurarán que después de realizar algunas operaciones, todos los elementos en arr puedan ser iguales.\n  *\n  * Ejemplo 1:\n  * Entrada: n = 3\n  * Salida: 2\n  * Explicación: arr = [1, 3, 5]\n  * Primera operación: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Segunda operación: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Ejemplo 2:\n  * Entrada: n = 6\n  * Salida: 9\n  */\n  public int minOperations(int n) ",
      "arb": "class Solution {\n  /**\n  * بالنظر إلى عدد صحيح n، أعد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع العناصر في المصفوفة arr متساوية.\n  * المصفوفة arr لها طول n، و arr[i] = (2 * i) + 1 لـ 0 <= i < n.\n  * في عملية واحدة، يمكنك اختيار مؤشرين x و y (0 <= x, y < n) وطرح 1 من arr[x] وإضافة 1 إلى arr[y] (أي، arr[x] -= 1 و arr[y] += 1).\n  * الهدف هو جعل جميع العناصر في arr متساوية. ستضمن حالات الاختبار أنه بعد إجراء بعض العمليات، يمكن جعل جميع العناصر في arr متساوية.\n  *\n  * المثال 1:\n  * المدخلات: n = 3\n  * المخرجات: 2\n  * التفسير: arr = [1, 3, 5]\n  * العملية الأولى: x = 2, y = 0 -> arr = [2, 3, 4]\n  * العملية الثانية: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * المثال 2:\n  * المدخلات: n = 6\n  * المخرجات: 9\n  */\n  public int minOperations(int n) ",
      "sw": "class Solution {\n  /**\n  * Ukipewa nambari n, rudisha idadi ndogo ya operesheni zinazohitajika kufanya vipengele vyote katika safu arr kuwa sawa.\n  * Safu arr ina urefu wa n, na arr[i] = (2 * i) + 1 kwa 0 <= i < n.\n  * Katika operesheni moja, unaweza kuchagua faharasa mbili x na y (0 <= x, y < n) na kutoa 1 kutoka arr[x] na kuongeza 1 kwa arr[y] (yaani, arr[x] -= 1 na arr[y] += 1).\n  * Lengo ni kufanya vipengele vyote katika arr kuwa sawa. Vipimo vya kesi vitahakikisha kuwa baada ya kufanya operesheni fulani, vipengele vyote katika arr vinaweza kufanywa sawa.\n  *\n  * Mfano 1:\n  * Ingizo: n = 3\n  * Matokeo: 2\n  * Maelezo: arr = [1, 3, 5]\n  * Operesheni ya kwanza: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Operesheni ya pili: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Mfano 2:\n  * Ingizo: n = 6\n  * Matokeo: 9\n  */\n  public int minOperations(int n) ",
      "tr": "class Solution {\n  /**\n  * Verilen bir tamsayı n için, dizideki tüm elemanları eşit yapmak için gereken minimum işlem sayısını döndürün.\n  * Dizi arr, n uzunluğuna sahiptir ve arr[i] = (2 * i) + 1, 0 <= i < n için geçerlidir.\n  * Bir işlemde, iki indeks x ve y (0 <= x, y < n) seçebilir ve arr[x]'ten 1 çıkarıp arr[y]'ye 1 ekleyebilirsiniz (yani, arr[x] -= 1 ve arr[y] += 1).\n  * Amaç, arr'deki tüm elemanları eşit yapmaktır. Test durumları, bazı işlemler gerçekleştirdikten sonra arr'deki tüm elemanların eşit yapılabileceğini garanti edecektir.\n  *\n  * Örnek 1:\n  * Girdi: n = 3\n  * Çıktı: 2\n  * Açıklama: arr = [1, 3, 5]\n  * İlk işlem: x = 2, y = 0 -> arr = [2, 3, 4]\n  * İkinci işlem: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Örnek 2:\n  * Girdi: n = 6\n  * Çıktı: 9\n  */\n  public int minOperations(int n) ",
      "vi": "class Solution {\n  /**\n  * Cho một số nguyên n, trả về số lượng tối thiểu các phép toán cần thiết để làm cho tất cả các phần tử trong mảng arr bằng nhau.\n  * Mảng arr có độ dài n, và arr[i] = (2 * i) + 1 cho 0 <= i < n.\n  * Trong một phép toán, bạn có thể chọn hai chỉ số x và y (0 <= x, y < n) và trừ 1 từ arr[x] và cộng 1 vào arr[y] (tức là, arr[x] -= 1 và arr[y] += 1).\n  * Mục tiêu là làm cho tất cả các phần tử trong arr bằng nhau. Các trường hợp kiểm tra sẽ đảm bảo rằng sau khi thực hiện một số phép toán, tất cả các phần tử trong arr có thể được làm cho bằng nhau.\n  *\n  * Ví dụ 1:\n  * Đầu vào: n = 3\n  * Đầu ra: 2\n  * Giải thích: arr = [1, 3, 5]\n  * Phép toán đầu tiên: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Phép toán thứ hai: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Ví dụ 2:\n  * Đầu vào: n = 6\n  * Đầu ra: 9\n  */\n  public int minOperations(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9981334703094151",
      "arb": "0.9991822387212793",
      "sw": "0.9956631042604842",
      "tr": "0.9782485828640125",
      "vi": "0.9947186167986634"
    },
    "canonical_solution": "  {\n\n      return n * n / 4;\n  }",
    "instruction": {
      "en": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9426256144380726",
      "tr": "0.8744300443477454",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.minOperations(4) == 4;\n      assert solution.minOperations(5) == 6;\n      assert solution.minOperations(7) == 12;\n      System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minOperations",
    "signature": "public int minOperations(int n)",
    "docstring": {
      "en": "Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\nThe array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\nIn one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\nThe goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:\nInput: n = 6\nOutput: 9",
      "es": "Dado un entero n, devuelve el número mínimo de operaciones requeridas para hacer que todos los elementos en el arreglo arr sean iguales.  \nEl arreglo arr tiene una longitud de n, y arr[i] = (2 * i) + 1 para 0 <= i < n.  \nEn una operación, puedes seleccionar dos índices x e y (0 <= x, y < n) y restar 1 de arr[x] y sumar 1 a arr[y] (es decir, arr[x] -= 1 y arr[y] += 1).  \nEl objetivo es hacer que todos los elementos en arr sean iguales. Los casos de prueba asegurarán que después de realizar algunas operaciones, todos los elementos en arr puedan hacerse iguales.\n\nEjemplo 1:  \nEntrada: n = 3  \nSalida: 2  \nExplicación: arr = [1, 3, 5]  \nPrimera operación: x = 2, y = 0 -> arr = [2, 3, 4]  \nSegunda operación: x = 2, y = 0 -> arr = [3, 3, 3]\n\nEjemplo 2:  \nEntrada: n = 6  \nSalida: 9",
      "arb": "معطى عدد صحيح n، أعد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع العناصر في المصفوفة arr متساوية. \nالمصفوفة arr لها طول n، و arr[i] = (2 * i) + 1 حيث 0 <= i < n. \nفي عملية واحدة، يمكنك اختيار مؤشرين x و y (0 <= x, y < n) وطرح 1 من arr[x] وإضافة 1 إلى arr[y] (أي، arr[x] -= 1 و arr[y] += 1). \nالهدف هو جعل جميع العناصر في arr متساوية. ستضمن حالات الاختبار أنه بعد تنفيذ بعض العمليات، يمكن جعل جميع العناصر في arr متساوية.\n\nمثال 1:\nالمدخلات: n = 3\nالناتج: 2\nالتفسير: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nمثال 2:\nالمدخلات: n = 6\nالناتج: 9",
      "sw": "Kwa kupewa nambari nzima n, rudisha idadi ndogo zaidi ya operesheni zinazohitajika ili kufanya vipengele vyote katika safu arr viwe sawa.\nSafu arr ina urefu wa n, na arr[i] = (2 * i) + 1 kwa 0 <= i < n.\nKatika operesheni moja, unaweza kuchagua fahirisi mbili x na y (0 <= x, y < n) na kutoa 1 kutoka arr[x] na kuongeza 1 kwa arr[y] (yaani, arr[x] -= 1 na arr[y] += 1).\nLengo ni kufanya vipengele vyote katika arr viwe sawa. Kesi za majaribio zitahakikisha kwamba baada ya kufanya baadhi ya operesheni, vipengele vyote katika arr vinaweza kufanywa sawa.\n\nMfano 1:\nIngizo: n = 3\nMatokeo: 2\nUfafanuzi: arr = [1, 3, 5]\nOperesheni ya kwanza: x = 2, y = 0 -> arr = [2, 3, 4]\nOperesheni ya pili: x = 2, y = 0 -> arr = [3, 3, 3]\n\nMfano 2:\nIngizo: n = 6\nMatokeo: 9",
      "tr": "Verilen bir tamsayı n için, dizideki tüm elemanları eşit yapmak için gereken minimum işlem sayısını döndürün.\nDizi arr uzunluğu n olan ve arr[i] = (2 * i) + 1 olan bir dizidir, burada 0 <= i < n.\nBir işlemde, iki indeks x ve y (0 <= x, y < n) seçebilir ve arr[x]'den 1 çıkarıp arr[y]'ye 1 ekleyebilirsiniz (yani, arr[x] -= 1 ve arr[y] += 1).\nAmaç, arr'deki tüm elemanları eşit yapmaktır. Test durumları, bazı işlemler yapıldıktan sonra arr'deki tüm elemanların eşit hale getirilebileceğini garanti edecektir.\n\nÖrnek 1:\nGirdi: n = 3\nÇıktı: 2\nAçıklama: arr = [1, 3, 5]\nİlk işlem: x = 2, y = 0 -> arr = [2, 3, 4]\nİkinci işlem: x = 2, y = 0 -> arr = [3, 3, 3]\n\nÖrnek 2:\nGirdi: n = 6\nÇıktı: 9",
      "vi": "Cho một số nguyên n, trả về số lượng tối thiểu các thao tác cần thiết để làm cho tất cả các phần tử trong mảng arr bằng nhau. Mảng arr có độ dài n, và arr[i] = (2 * i) + 1 với 0 <= i < n. Trong một thao tác, bạn có thể chọn hai chỉ số x và y (0 <= x, y < n) và trừ 1 từ arr[x] và cộng 1 vào arr[y] (tức là, arr[x] -= 1 và arr[y] += 1). Mục tiêu là làm cho tất cả các phần tử trong arr bằng nhau. Các trường hợp kiểm tra sẽ đảm bảo rằng sau khi thực hiện một số thao tác, tất cả các phần tử trong arr có thể được làm bằng nhau.\n\nVí dụ 1:\nĐầu vào: n = 3\nĐầu ra: 2\nGiải thích: arr = [1, 3, 5]\nThao tác đầu tiên: x = 2, y = 0 -> arr = [2, 3, 4]\nThao tác thứ hai: x = 2, y = 0 -> arr = [3, 3, 3]\n\nVí dụ 2:\nĐầu vào: n = 6\nĐầu ra: 9"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9960297759438747",
      "sw": "0.9990855057257154",
      "tr": "0.9711366220710583",
      "vi": "0.989854953288643"
    }
  },
  {
    "task_id": "Java/26",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ",
      "es": "class Solution {\n    /**\n     * Dado un array de enteros `gain` que representa la ganancia neta en altitud entre puntos consecutivos, devuelve la altitud más alta alcanzada.\n     *\n     * Ejemplo:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explicación: Las altitudes son [0,-5,-4,1,1,-6]. La altitud más alta alcanzada es 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explicación: Las altitudes son [0,-4,-7,-9,-10,-6,-3,-1]. La altitud más alta alcanzada es 0.\n     *\n     * Restricciones:\n     * - La longitud del array `gain` está entre 1 y 100, inclusive.\n     * - Cada elemento en el array `gain` está entre -100 y 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى مصفوفة الأعداد الصحيحة `gain` التي تمثل الزيادة الصافية في الارتفاع بين النقاط المتتالية، أعد الارتفاع الأعلى الذي تم الوصول إليه.\n     *\n     * مثال:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * التوضيح: الارتفاعات هي [0,-5,-4,1,1,-6]. الارتفاع الأعلى الذي تم الوصول إليه هو 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * التوضيح: الارتفاعات هي [0,-4,-7,-9,-10,-6,-3,-1]. الارتفاع الأعلى الذي تم الوصول إليه هو 0.\n     *\n     * القيود:\n     * - طول مصفوفة `gain` يتراوح بين 1 و 100، شامل.\n     * - كل عنصر في مصفوفة `gain` يتراوح بين -100 و 100، شامل.\n     */\n    public int highestAltitude(int[] gain) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa safu ya nambari `gain` inayowakilisha ongezeko la wima kati ya pointi mfululizo, rudisha kimo cha juu zaidi kilichofikiwa.\n     *\n     * Mfano:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Maelezo: Vimo ni [0,-5,-4,1,1,-6]. Kimo cha juu zaidi kilichofikiwa ni 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Maelezo: Vimo ni [0,-4,-7,-9,-10,-6,-3,-1]. Kimo cha juu zaidi kilichofikiwa ni 0.\n     *\n     * Vikwazo:\n     * - Urefu wa safu ya `gain` ni kati ya 1 na 100, pamoja.\n     * - Kila kipengele katika safu ya `gain` ni kati ya -100 na 100, pamoja.\n     */\n    public int highestAltitude(int[] gain) ",
      "tr": "class Solution {\n    /**\n     * Ardışık noktalar arasındaki yükseklik kazancını temsil eden `gain` tamsayı dizisi verildiğinde, ulaşılan en yüksek irtifayı döndürün.\n     *\n     * Örnek:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Açıklama: İrtifalar [0,-5,-4,1,1,-6] şeklindedir. Ulaşılan en yüksek irtifa 1'dir.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Açıklama: İrtifalar [0,-4,-7,-9,-10,-6,-3,-1] şeklindedir. Ulaşılan en yüksek irtifa 0'dır.\n     *\n     * Kısıtlamalar:\n     * - `gain` dizisinin uzunluğu 1 ile 100 arasında, dahil.\n     * - `gain` dizisindeki her bir eleman -100 ile 100 arasında, dahil.\n     */\n    public int highestAltitude(int[] gain) ",
      "vi": "class Solution {\n    /**\n     * Cho một mảng số nguyên `gain` đại diện cho sự tăng độ cao ròng giữa các điểm liên tiếp, trả về độ cao lớn nhất đạt được.\n     *\n     * Ví dụ:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Giải thích: Các độ cao là [0,-5,-4,1,1,-6]. Độ cao lớn nhất đạt được là 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Giải thích: Các độ cao là [0,-4,-7,-9,-10,-6,-3,-1]. Độ cao lớn nhất đạt được là 0.\n     *\n     * Ràng buộc:\n     * - Độ dài của mảng `gain` nằm trong khoảng từ 1 đến 100, bao gồm cả hai đầu.\n     * - Mỗi phần tử trong mảng `gain` nằm trong khoảng từ -100 đến 100, bao gồm cả hai đầu.\n     */\n    public int highestAltitude(int[] gain) "
    },
    "prompt_bertscore": {
      "es": "0.9916056814670846",
      "arb": "0.9951180624949245",
      "sw": "0.9871470253039945",
      "tr": "0.9893665211816783",
      "vi": "0.9927223814692627"
    },
    "canonical_solution": "    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }",
    "instruction": {
      "en": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية بلغة Java باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nAşağıdaki Java kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9128546942981824",
      "sw": "0.9426256144380726",
      "tr": "0.849080636489692",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "highestAltitude",
    "signature": "public int highestAltitude(int[] gain)",
    "docstring": {
      "en": "Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.",
      "es": "Dado un array de enteros `gain` que representa la ganancia neta en altitud entre puntos consecutivos, devuelve la altitud más alta alcanzada.\n\nEjemplo:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplicación: Las altitudes son [0,-5,-4,1,1,-6]. La altitud más alta alcanzada es 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplicación: Las altitudes son [0,-4,-7,-9,-10,-6,-3,-1]. La altitud más alta alcanzada es 0.\n\nRestricciones:\n- La longitud del array `gain` está entre 1 y 100, inclusive.\n- Cada elemento en el array `gain` está entre -100 y 100, inclusive.",
      "arb": "معطى مصفوفة أعداد صحيحة `gain` تمثل صافي الزيادة في الارتفاع بين النقاط المتتالية، أعد الارتفاع الأعلى الذي تم الوصول إليه.\n\nمثال:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nتوضيح: الارتفاعات هي [0,-5,-4,1,1,-6]. الارتفاع الأعلى الذي تم الوصول إليه هو 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nتوضيح: الارتفاعات هي [0,-4,-7,-9,-10,-6,-3,-1]. الارتفاع الأعلى الذي تم الوصول إليه هو 0.\n\nالقيود:\n- طول مصفوفة `gain` يتراوح بين 1 و 100، شامل.\n- كل عنصر في مصفوفة `gain` يتراوح بين -100 و 100، شامل.",
      "sw": "Kwa kupewa safu ya nambari nzima `gain` inayowakilisha faida halisi katika kimo kati ya pointi zinazofuatana, rudisha kimo cha juu zaidi kilichofikiwa.\n\nMfano:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nMaelezo: Vimo ni [0,-5,-4,1,1,-6]. Kimo cha juu zaidi kilichofikiwa ni 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nMaelezo: Vimo ni [0,-4,-7,-9,-10,-6,-3,-1]. Kimo cha juu zaidi kilichofikiwa ni 0.\n\nVikwazo:\n- Urefu wa safu ya `gain` ni kati ya 1 na 100, pamoja.\n- Kila kipengele katika safu ya `gain` ni kati ya -100 na 100, pamoja.",
      "tr": "Verilen bir tamsayı dizisi `gain`, ardışık noktalar arasındaki yükseklik kazancını temsil eder. En yüksek ulaşılan irtifayı döndürün.\n\nÖrnek:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nAçıklama: İrtifalar [0,-5,-4,1,1,-6] şeklindedir. Ulaşılan en yüksek irtifa 1'dir.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nAçıklama: İrtifalar [0,-4,-7,-9,-10,-6,-3,-1] şeklindedir. Ulaşılan en yüksek irtifa 0'dır.\n\nKısıtlamalar:\n- `gain` dizisinin uzunluğu 1 ile 100 arasındadır (her iki uç dahil).\n- `gain` dizisindeki her bir eleman -100 ile 100 arasındadır (her iki uç dahil).",
      "vi": "Cho một mảng số nguyên `gain` đại diện cho sự tăng độ cao ròng giữa các điểm liên tiếp, trả về độ cao cao nhất đạt được.\n\nVí dụ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nGiải thích: Các độ cao là [0,-5,-4,1,1,-6]. Độ cao cao nhất đạt được là 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nGiải thích: Các độ cao là [0,-4,-7,-9,-10,-6,-3,-1]. Độ cao cao nhất đạt được là 0.\n\nRàng buộc:\n- Độ dài của mảng `gain` nằm trong khoảng từ 1 đến 100, bao gồm cả hai đầu.\n- Mỗi phần tử trong mảng `gain` nằm trong khoảng từ -100 đến 100, bao gồm cả hai đầu."
    },
    "docstring_bertscore": {
      "es": "0.9832560547699021",
      "arb": "0.9818626626469423",
      "sw": "0.9934001083293538",
      "tr": "0.9687055848375723",
      "vi": "0.9916052842063225"
    }
  },
  {
    "task_id": "Java/27",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "es": "class Solution {\n    /**\n     * Dado un array de enteros nums, devuelve la suma absoluta máxima de cualquier subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى مصفوفة أعداد صحيحة nums، قم بإرجاع القيمة المطلقة القصوى لمجموع أي جزء من المصفوفة.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa safu ya nambari nzima nums, rudisha jumla kubwa kabisa ya sehemu yoyote ya safu.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "tr": "class Solution {\n    /**\n     * Bir tamsayı dizisi olan nums verildiğinde, herhangi bir alt dizinin maksimum mutlak toplamını döndürün.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "vi": "class Solution {\n    /**\n     * Cho một mảng số nguyên nums, trả về tổng tuyệt đối lớn nhất của bất kỳ mảng con nào.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) "
    },
    "prompt_bertscore": {
      "es": "0.9900144534846141",
      "arb": "0.9682231116420386",
      "sw": "0.9900144534846141",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }",
    "instruction": {
      "en": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nAşağıdaki Java kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak ve en fazla 500 karakter kullanarak sağlayın.",
      "vi": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8554443566372877",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "maxAbsoluteSum",
    "signature": "public int maxAbsoluteSum(int[] nums)",
    "docstring": {
      "en": "Given an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "es": "Dado un array de enteros nums, devuelve la suma absoluta máxima de cualquier subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "arb": "نظرًا لمصفوفة أعداد صحيحة `nums`، أعد القيمة المطلقة القصوى لمجموع أي مجموعة فرعية.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "sw": "Kwa kupewa safu ya nambari nzima `nums`, rudisha jumla kubwa kabisa ya thamani yoyote ya sehemu ndogo ya safu.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "tr": "Verilen bir tamsayı dizisi nums için, herhangi bir alt dizinin maksimum mutlak toplamını döndürün.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "vi": "Cho một mảng số nguyên `nums`, trả về tổng giá trị tuyệt đối lớn nhất của bất kỳ dãy con nào.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8"
    },
    "docstring_bertscore": {
      "es": "0.9859518663013075",
      "arb": "0.9404625295886027",
      "sw": "0.956035747352881",
      "tr": "0.9862571611969582",
      "vi": "0.956035747352881"
    }
  },
  {
    "task_id": "Java/28",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Dado un entero k, devuelve el número mínimo de números de Fibonacci cuya suma es igual a k.\n     * Los números de Fibonacci se definen de la siguiente manera:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, para n > 2.\n     * Se garantiza que hay al menos una solución válida para el k dado.\n     *\n     * Ejemplo 1:\n     * Entrada: k = 7\n     * Salida: 2\n     * Explicación: Los números de Fibonacci son: 1, 1, 2, 3, 5, 8, 13, ...\n     * Para k = 7, podemos obtener 2 + 5 = 7.\n     *\n     * Ejemplo 2:\n     * Entrada: k = 10\n     * Salida: 2\n     * Explicación: Para k = 10, podemos obtener 2 + 8 = 10.\n     *\n     * Ejemplo 3:\n     * Entrada: k = 19\n     * Salida: 3\n     * Explicación: Para k = 19, podemos obtener 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * بالنظر إلى عدد صحيح k، أعد العدد الأدنى من أرقام فيبوناتشي التي يكون مجموعها مساوياً لـ k.\n     * يتم تعريف أرقام فيبوناتشي كما يلي:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2، لـ n > 2.\n     * يتم ضمان وجود حل صالح واحد على الأقل للعدد k المعطى.\n     *\n     * المثال 1:\n     * المدخل: k = 7\n     * المخرج: 2\n     * التوضيح: أرقام فيبوناتشي هي: 1، 1، 2، 3، 5، 8، 13، ...\n     * بالنسبة لـ k = 7، يمكننا الحصول على 2 + 5 = 7.\n     *\n     * المثال 2:\n     * المدخل: k = 10\n     * المخرج: 2\n     * التوضيح: بالنسبة لـ k = 10، يمكننا الحصول على 2 + 8 = 10.\n     *\n     * المثال 3:\n     * المدخل: k = 19\n     * المخرج: 3\n     * التوضيح: بالنسبة لـ k = 19، يمكننا الحصول على 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ukipewa nambari nzima k, rudisha idadi ndogo zaidi ya nambari za Fibonacci ambazo jumla yake ni sawa na k.\n     * Nambari za Fibonacci zinafafanuliwa kama ifuatavyo:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, kwa n > 2.\n     * Inahakikishwa kwamba kuna angalau suluhisho moja sahihi kwa k iliyopewa.\n     *\n     * Mfano 1:\n     * Ingizo: k = 7\n     * Matokeo: 2\n     * Maelezo: Nambari za Fibonacci ni: 1, 1, 2, 3, 5, 8, 13, ...\n     * Kwa k = 7, tunaweza kupata 2 + 5 = 7.\n     *\n     * Mfano 2:\n     * Ingizo: k = 10\n     * Matokeo: 2\n     * Maelezo: Kwa k = 10, tunaweza kupata 2 + 8 = 10.\n     *\n     * Mfano 3:\n     * Ingizo: k = 19\n     * Matokeo: 3\n     * Maelezo: Kwa k = 19, tunaweza kupata 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Verilen bir tam sayı k için, toplamı k'ye eşit olan en az sayıda Fibonacci sayısının sayısını döndürün.\n     * Fibonacci sayıları aşağıdaki gibi tanımlanır:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, n > 2 için.\n     * Verilen k için en az bir geçerli çözüm olduğu garanti edilmektedir.\n     *\n     * Örnek 1:\n     * Girdi: k = 7\n     * Çıktı: 2\n     * Açıklama: Fibonacci sayıları: 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7 için, 2 + 5 = 7 elde edebiliriz.\n     *\n     * Örnek 2:\n     * Girdi: k = 10\n     * Çıktı: 2\n     * Açıklama: k = 10 için, 2 + 8 = 10 elde edebiliriz.\n     *\n     * Örnek 3:\n     * Girdi: k = 19\n     * Çıktı: 3\n     * Açıklama: k = 19 için, 1 + 5 + 13 = 19 elde edebiliriz.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Cho một số nguyên k, trả về số lượng tối thiểu các số Fibonacci có tổng bằng k.\n     * Các số Fibonacci được định nghĩa như sau:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, với n > 2.\n     * Đảm bảo rằng có ít nhất một giải pháp hợp lệ cho k đã cho.\n     *\n     * Ví dụ 1:\n     * Đầu vào: k = 7\n     * Đầu ra: 2\n     * Giải thích: Các số Fibonacci là: 1, 1, 2, 3, 5, 8, 13, ...\n     * Với k = 7, chúng ta có thể lấy 2 + 5 = 7.\n     *\n     * Ví dụ 2:\n     * Đầu vào: k = 10\n     * Đầu ra: 2\n     * Giải thích: Với k = 10, chúng ta có thể lấy 2 + 8 = 10.\n     *\n     * Ví dụ 3:\n     * Đầu vào: k = 19\n     * Đầu ra: 3\n     * Giải thích: Với k = 19, chúng ta có thể lấy 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) "
    },
    "prompt_bertscore": {
      "es": "0.990560289771698",
      "arb": "0.9971009895887958",
      "sw": "0.9887581163245684",
      "tr": "0.9926333950585591",
      "vi": "0.9794135500487822"
    },
    "canonical_solution": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }",
    "instruction": {
      "en": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nAşağıdaki Java kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9174426588393263",
      "sw": "0.9149216420432316",
      "tr": "0.8881111091022854",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "findMinFibonacciNumbers",
    "signature": "public int findMinFibonacciNumbers(int k)",
    "docstring": {
      "en": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.",
      "es": "Dado un entero k, devuelve el número mínimo de números de Fibonacci cuya suma es igual a k. Los números de Fibonacci se definen de la siguiente manera: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, para n > 2. Se garantiza que hay al menos una solución válida para el k dado.\n\nEjemplo 1: Entrada: k = 7 Salida: 2 Explicación: Los números de Fibonacci son: 1, 1, 2, 3, 5, 8, 13, ... Para k = 7, podemos obtener 2 + 5 = 7.\n\nEjemplo 2: Entrada: k = 10 Salida: 2 Explicación: Para k = 10, podemos obtener 2 + 8 = 10.\n\nEjemplo 3: Entrada: k = 19 Salida: 3 Explicación: Para k = 19, podemos obtener 1 + 5 + 13 = 19.",
      "arb": "معطى عدد صحيح k، أرجع الحد الأدنى من أعداد فيبوناتشي التي يكون مجموعها مساويًا لـ k. \nيتم تعريف أعداد فيبوناتشي كما يلي:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2، حيث n > 2.\nيتم ضمان وجود حل صالح واحد على الأقل للعدد k المعطى.\n\nمثال 1:\nالمدخل: k = 7\nالمخرج: 2\nالتوضيح: أعداد فيبوناتشي هي: 1، 1، 2، 3، 5، 8، 13، ...\nبالنسبة لـ k = 7، يمكننا الحصول على 2 + 5 = 7.\n\nمثال 2:\nالمدخل: k = 10\nالمخرج: 2\nالتوضيح: بالنسبة لـ k = 10، يمكننا الحصول على 2 + 8 = 10.\n\nمثال 3:\nالمدخل: k = 19\nالمخرج: 3\nالتوضيح: بالنسبة لـ k = 19، يمكننا الحصول على 1 + 5 + 13 = 19.",
      "sw": "Ukipewa nambari nzima k, rudisha idadi ndogo zaidi ya nambari za Fibonacci ambazo jumla yake ni sawa na k.  \nNambari za Fibonacci zinafafanuliwa kama ifuatavyo:  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2, kwa n > 2.  \nInahakikishwa kwamba kuna angalau suluhisho moja sahihi kwa k iliyotolewa.  \n\nMfano 1:  \nIngizo: k = 7  \nMatokeo: 2  \nUfafanuzi: Nambari za Fibonacci ni: 1, 1, 2, 3, 5, 8, 13, ...  \nKwa k = 7, tunaweza kupata 2 + 5 = 7.  \n\nMfano 2:  \nIngizo: k = 10  \nMatokeo: 2  \nUfafanuzi: Kwa k = 10, tunaweza kupata 2 + 8 = 10.  \n\nMfano 3:  \nIngizo: k = 19  \nMatokeo: 3  \nUfafanuzi: Kwa k = 19, tunaweza kupata 1 + 5 + 13 = 19.  ",
      "tr": "Verilen bir tamsayı k için, toplamı k'ye eşit olan en az sayıda Fibonacci sayısını döndürün.\nFibonacci sayıları aşağıdaki gibi tanımlanır:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, n > 2 için.\nVerilen k için en az bir geçerli çözüm olduğu garanti edilmektedir.\n\nÖrnek 1:\nGirdi: k = 7\nÇıktı: 2\nAçıklama: Fibonacci sayıları: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 için, 2 + 5 = 7 elde edebiliriz.\n\nÖrnek 2:\nGirdi: k = 10\nÇıktı: 2\nAçıklama: k = 10 için, 2 + 8 = 10 elde edebiliriz.\n\nÖrnek 3:\nGirdi: k = 19\nÇıktı: 3\nAçıklama: k = 19 için, 1 + 5 + 13 = 19 elde edebiliriz.",
      "vi": "Cho một số nguyên k, trả về số lượng tối thiểu các số Fibonacci có tổng bằng k. \nCác số Fibonacci được định nghĩa như sau: \nF1 = 1 \nF2 = 1 \nFn = Fn-1 + Fn-2, với n > 2. \nĐảm bảo rằng có ít nhất một giải pháp hợp lệ cho k đã cho.\n\nVí dụ 1:\nĐầu vào: k = 7\nĐầu ra: 2\nGiải thích: Các số Fibonacci là: 1, 1, 2, 3, 5, 8, 13, ...\nVới k = 7, ta có thể lấy 2 + 5 = 7.\n\nVí dụ 2:\nĐầu vào: k = 10\nĐầu ra: 2\nGiải thích: Với k = 10, ta có thể lấy 2 + 8 = 10.\n\nVí dụ 3:\nĐầu vào: k = 19\nĐầu ra: 3\nGiải thích: Với k = 19, ta có thể lấy 1 + 5 + 13 = 19."
    },
    "docstring_bertscore": {
      "es": "0.9875665326687402",
      "arb": "0.9899004396459",
      "sw": "0.9949446581722811",
      "tr": "0.9938843691983168",
      "vi": "0.9648160047161471"
    }
  },
  {
    "task_id": "Java/29",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     */\n    public int kthFactor(int n, int k) ",
      "es": "class Solution {\n    /**\n     * Dados dos enteros positivos n y k, encuentra el k-ésimo factor de n.\n     * Un factor de n es un entero positivo que divide a n de manera exacta.\n     * Devuelve el k-ésimo factor en orden ascendente. Si n tiene menos de k factores, devuelve -1.\n     *\n     * Ejemplo 1:\n     * Entrada: n = 12, k = 3\n     * Salida: 3\n     * Explicación: Los factores de 12 son [1, 2, 3, 4, 6, 12]. El 3er factor es 3.\n     *\n     * Ejemplo 2:\n     * Entrada: n = 7, k = 2\n     * Salida: 7\n     * Explicación: Los factores de 7 son [1, 7]. El 2do factor es 7.\n     *\n     * Ejemplo 3:\n     * Entrada: n = 4, k = 4\n     * Salida: -1\n     * Explicación: Los factores de 4 son [1, 2, 4]. No hay un 4to factor, por lo que devolvemos -1.\n     */\n    public int kthFactor(int n, int k) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن العامل k من n.\n     * العامل لـ n هو عدد صحيح موجب يقسم n بالتساوي.\n     * قم بإرجاع العامل k بترتيب تصاعدي. إذا كان لـ n أقل من k من العوامل، قم بإرجاع -1.\n     *\n     * المثال 1:\n     * المدخلات: n = 12, k = 3\n     * المخرجات: 3\n     * التوضيح: العوامل لـ 12 هي [1, 2, 3, 4, 6, 12]. العامل الثالث هو 3.\n     *\n     * المثال 2:\n     * المدخلات: n = 7, k = 2\n     * المخرجات: 7\n     * التوضيح: العوامل لـ 7 هي [1, 7]. العامل الثاني هو 7.\n     *\n     * المثال 3:\n     * المدخلات: n = 4, k = 4\n     * المخرجات: -1\n     * التوضيح: العوامل لـ 4 هي [1, 2, 4]. لا يوجد عامل رابع، لذا نرجع -1.\n     */\n    public int kthFactor(int n, int k) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa nambari mbili chanya n na k, tafuta kigezo cha k cha n.\n     * Kigezo cha n ni nambari chanya inayogawanya n sawasawa.\n     * Rudisha kigezo cha k kwa mpangilio wa kupanda. Ikiwa n ina vigezo vichache kuliko k, rudisha -1.\n     *\n     * Mfano 1:\n     * Ingizo: n = 12, k = 3\n     * Matokeo: 3\n     * Maelezo: Vigezo vya 12 ni [1, 2, 3, 4, 6, 12]. Kigezo cha 3 ni 3.\n     *\n     * Mfano 2:\n     * Ingizo: n = 7, k = 2\n     * Matokeo: 7\n     * Maelezo: Vigezo vya 7 ni [1, 7]. Kigezo cha 2 ni 7.\n     *\n     * Mfano 3:\n     * Ingizo: n = 4, k = 4\n     * Matokeo: -1\n     * Maelezo: Vigezo vya 4 ni [1, 2, 4]. Hakuna kigezo cha 4, kwa hivyo tunarudisha -1.\n     */\n    public int kthFactor(int n, int k) ",
      "tr": "class Solution {\n    /**\n     * İki pozitif tamsayı n ve k verildiğinde, n'in k. faktörünü bulun.\n     * n'in bir faktörü, n'i tam bölen pozitif bir tamsayıdır.\n     * k. faktörü artan sırayla döndürün. Eğer n'in k'dan az faktörü varsa, -1 döndürün.\n     *\n     * Örnek 1:\n     * Girdi: n = 12, k = 3\n     * Çıktı: 3\n     * Açıklama: 12'nin faktörleri [1, 2, 3, 4, 6, 12]'dir. 3. faktör 3'tür.\n     *\n     * Örnek 2:\n     * Girdi: n = 7, k = 2\n     * Çıktı: 7\n     * Açıklama: 7'nin faktörleri [1, 7]'dir. 2. faktör 7'dir.\n     *\n     * Örnek 3:\n     * Girdi: n = 4, k = 4\n     * Çıktı: -1\n     * Açıklama: 4'ün faktörleri [1, 2, 4]'tür. 4. faktör yoktur, bu yüzden -1 döndürürüz.\n     */\n    public int kthFactor(int n, int k) ",
      "vi": "class Solution {\n    /**\n     * Cho hai số nguyên dương n và k, tìm ước thứ k của n.\n     * Một ước của n là một số nguyên dương chia hết n.\n     * Trả về ước thứ k theo thứ tự tăng dần. Nếu n có ít hơn k ước, trả về -1.\n     *\n     * Ví dụ 1:\n     * Đầu vào: n = 12, k = 3\n     * Đầu ra: 3\n     * Giải thích: Các ước của 12 là [1, 2, 3, 4, 6, 12]. Ước thứ 3 là 3.\n     *\n     * Ví dụ 2:\n     * Đầu vào: n = 7, k = 2\n     * Đầu ra: 7\n     * Giải thích: Các ước của 7 là [1, 7]. Ước thứ 2 là 7.\n     *\n     * Ví dụ 3:\n     * Đầu vào: n = 4, k = 4\n     * Đầu ra: -1\n     * Giải thích: Các ước của 4 là [1, 2, 4]. Không có ước thứ 4, vì vậy chúng ta trả về -1.\n     */\n    public int kthFactor(int n, int k) "
    },
    "prompt_bertscore": {
      "es": "0.985499187662929",
      "arb": "0.9864673121400931",
      "sw": "0.9846722893866808",
      "tr": "0.9864075243954016",
      "vi": "0.9864075243954016"
    },
    "canonical_solution": "    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "instruction": {
      "en": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nتقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nJava kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9083841203122303",
      "sw": "0.9426256144380726",
      "tr": "0.8849673860616463",
      "vi": "0.9052995891251394"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "kthFactor",
    "signature": "public int kthFactor(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.",
      "es": "Dado dos enteros positivos n y k, encuentra el k-ésimo factor de n.  \nUn factor de n es un entero positivo que divide n de manera exacta.  \nDevuelve el k-ésimo factor en orden ascendente. Si n tiene menos de k factores, devuelve -1.\n\nEjemplo 1:  \nEntrada: n = 12, k = 3  \nSalida: 3  \nExplicación: Los factores de 12 son [1, 2, 3, 4, 6, 12]. El 3er factor es 3.\n\nEjemplo 2:  \nEntrada: n = 7, k = 2  \nSalida: 7  \nExplicación: Los factores de 7 son [1, 7]. El 2do factor es 7.\n\nEjemplo 3:  \nEntrada: n = 4, k = 4  \nSalida: -1  \nExplicación: Los factores de 4 son [1, 2, 4]. No hay un 4to factor, por lo que devolvemos -1.",
      "arb": "إعطاء عددين صحيحين موجبين n و k، العثور على العامل k من n.  \nالعامل لـ n هو عدد صحيح موجب يقسم n بالتساوي.  \nإرجاع العامل k بترتيب تصاعدي. إذا كان لـ n أقل من k من العوامل، إرجاع -1.\n\nالمثال 1:  \nالمدخلات: n = 12, k = 3  \nالمخرجات: 3  \nالتفسير: العوامل لـ 12 هي [1, 2, 3, 4, 6, 12]. العامل الثالث هو 3.\n\nالمثال 2:  \nالمدخلات: n = 7, k = 2  \nالمخرجات: 7  \nالتفسير: العوامل لـ 7 هي [1, 7]. العامل الثاني هو 7.\n\nالمثال 3:  \nالمدخلات: n = 4, k = 4  \nالمخرجات: -1  \nالتفسير: العوامل لـ 4 هي [1, 2, 4]. لا يوجد عامل رابع، لذا نرجع -1.",
      "sw": "Ukipewa nambari mbili chanya n na k, tafuta kigezo cha k cha n.  \nKipengele cha n ni nambari nzima chanya inayogawanya n sawasawa.  \nReturn the kth factor in ascending order. If n has less than k factors, return -1.  \n\nMfano 1:  \nIngizo: n = 12, k = 3  \nMatokeo: 3  \nUfafanuzi: Vipengele vya 12 ni [1, 2, 3, 4, 6, 12]. Kipengele cha 3 ni 3.  \n\nMfano 2:  \nIngizo: n = 7, k = 2  \nMatokeo: 7  \nUfafanuzi: Vipengele vya 7 ni [1, 7]. Kipengele cha 2 ni 7.  \n\nMfano 3:  \nIngizo: n = 4, k = 4  \nMatokeo: -1  \nUfafanuzi: Vipengele vya 4 ni [1, 2, 4]. Hakuna kipengele cha 4, kwa hivyo tunarudisha -1.  ",
      "tr": "Verilen iki pozitif tam sayı n ve k için, n'in k'ıncı bölenini bulun.  \nn'in bir böleni, n'i tam bölen pozitif bir tam sayıdır.  \nBölenleri artan sırayla döndürün. Eğer n'in k'tan az böleni varsa, -1 döndürün.\n\nÖrnek 1:  \nGirdi: n = 12, k = 3  \nÇıktı: 3  \nAçıklama: 12'nin bölenleri [1, 2, 3, 4, 6, 12]'dir. 3. bölen 3'tür.\n\nÖrnek 2:  \nGirdi: n = 7, k = 2  \nÇıktı: 7  \nAçıklama: 7'nin bölenleri [1, 7]'dir. 2. bölen 7'dir.\n\nÖrnek 3:  \nGirdi: n = 4, k = 4  \nÇıktı: -1  \nAçıklama: 4'ün bölenleri [1, 2, 4]'tür. 4. bölen yoktur, bu yüzden -1 döndürürüz.",
      "vi": "Cho hai số nguyên dương n và k, tìm ước thứ k của n.  \nMột ước của n là một số nguyên dương chia n mà không dư.  \nTrả về ước thứ k theo thứ tự tăng dần. Nếu n có ít hơn k ước, trả về -1.\n\nVí dụ 1:  \nĐầu vào: n = 12, k = 3  \nĐầu ra: 3  \nGiải thích: Các ước của 12 là [1, 2, 3, 4, 6, 12]. Ước thứ 3 là 3.\n\nVí dụ 2:  \nĐầu vào: n = 7, k = 2  \nĐầu ra: 7  \nGiải thích: Các ước của 7 là [1, 7]. Ước thứ 2 là 7.\n\nVí dụ 3:  \nĐầu vào: n = 4, k = 4  \nĐầu ra: -1  \nGiải thích: Các ước của 4 là [1, 2, 4]. Không có ước thứ 4, vì vậy chúng ta trả về -1."
    },
    "docstring_bertscore": {
      "es": "0.9844057274153319",
      "arb": "0.986762675516692",
      "sw": "1",
      "tr": "0.9068244745603443",
      "vi": "0.9016112215797026"
    }
  },
  {
    "task_id": "Java/30",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     */\n  public String makeGood(String s) ",
      "es": "class Solution {\n    /**\n     * Dada una cadena s que consiste en letras inglesas minúsculas y mayúsculas,\n     * necesitas hacer que la cadena sea \"buena\".\n     * Una cadena se considera \"buena\" si no hay caracteres adyacentes tales que\n     * uno sea una letra minúscula y el otro sea la letra mayúscula correspondiente.\n     * Puedes elegir cualquier par de caracteres adyacentes en la cadena y eliminarlos hasta que la cadena sea \"buena\".\n     * Devuelve la cadena \"buena\" final.\n     *\n     * Ejemplo 1:\n     * Entrada: s = \"leEeetcode\"\n     * Salida: \"leetcode\"\n     * Explicación: Puedes eliminar \"Ee\" para hacer \"leetcode\".\n     *\n     * Ejemplo 2:\n     * Entrada: s = \"abBAcC\"\n     * Salida: \"\"\n     * Explicación: Hay múltiples soluciones posibles, tales como:\n     * - Eliminar \"bB\" para hacer \"aAcC\", luego eliminar \"cC\" para hacer \"aA\", luego eliminar \"aA\" para hacer \"\".\n     * - Eliminar \"aA\" para hacer \"abBAcC\", luego eliminar \"bB\" para hacer \"aAcC\", luego eliminar \"cC\" para hacer \"aA\",\n     *   luego eliminar \"aA\" para hacer \"\".\n     * No importa las elecciones, el resultado es una cadena vacía.\n     *\n     * Ejemplo 3:\n     * Entrada: s = \"s\"\n     * Salida: \"s\"\n     * Explicación: La cadena ya es \"buena\".\n     */\n  public String makeGood(String s) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى سلسلة s تتكون من حروف إنجليزية صغيرة وكبيرة،\n     * تحتاج إلى جعل السلسلة \"جيدة\".\n     * تعتبر السلسلة \"جيدة\" إذا لم يكن هناك حروف متجاورة بحيث\n     * يكون أحدها حرف صغير والآخر هو الحرف الكبير المقابل له.\n     * يمكنك اختيار أي حروف متجاورة في السلسلة وإزالتها حتى تصبح السلسلة \"جيدة\".\n     * أعد السلسلة \"الجيدة\" النهائية.\n     *\n     * المثال 1:\n     * المدخلات: s = \"leEeetcode\"\n     * الناتج: \"leetcode\"\n     * التوضيح: يمكنك إزالة \"Ee\" لجعل السلسلة \"leetcode\".\n     *\n     * المثال 2:\n     * المدخلات: s = \"abBAcC\"\n     * الناتج: \"\"\n     * التوضيح: هناك حلول متعددة ممكنة، مثل:\n     * - إزالة \"bB\" لجعل السلسلة \"aAcC\"، ثم إزالة \"cC\" لجعل السلسلة \"aA\"، ثم إزالة \"aA\" لجعل السلسلة \"\".\n     * - إزالة \"aA\" لجعل السلسلة \"abBAcC\"، ثم إزالة \"bB\" لجعل السلسلة \"aAcC\"، ثم إزالة \"cC\" لجعل السلسلة \"aA\"،\n     *   ثم إزالة \"aA\" لجعل السلسلة \"\".\n     * بغض النظر عن الاختيارات، النتيجة هي سلسلة فارغة.\n     *\n     * المثال 3:\n     * المدخلات: s = \"s\"\n     * الناتج: \"s\"\n     * التوضيح: السلسلة بالفعل \"جيدة\".\n     */\n  public String makeGood(String s) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa kamba s inayojumuisha herufi ndogo na kubwa za Kiingereza,\n     * unahitaji kufanya kamba hiyo kuwa \"nzuri\".\n     * Kamba inachukuliwa kuwa \"nzuri\" ikiwa hakuna herufi zilizo karibu ambapo\n     * moja ni herufi ndogo na nyingine ni herufi kubwa inayolingana.\n     * Unaweza kuchagua herufi zozote zilizo karibu kwenye kamba na kuziondoa hadi kamba iwe \"nzuri\".\n     * Rudisha kamba ya mwisho \"nzuri\".\n     *\n     * Mfano 1:\n     * Ingizo: s = \"leEeetcode\"\n     * Matokeo: \"leetcode\"\n     * Maelezo: Unaweza kuondoa \"Ee\" kufanya \"leetcode\".\n     *\n     * Mfano 2:\n     * Ingizo: s = \"abBAcC\"\n     * Matokeo: \"\"\n     * Maelezo: Kuna suluhisho nyingi zinazowezekana, kama vile:\n     * - Ondoa \"bB\" kufanya \"aAcC\", kisha ondoa \"cC\" kufanya \"aA\", kisha ondoa \"aA\" kufanya \"\".\n     * - Ondoa \"aA\" kufanya \"abBAcC\", kisha ondoa \"bB\" kufanya \"aAcC\", kisha ondoa \"cC\" kufanya \"aA\",\n     *   kisha ondoa \"aA\" kufanya \"\".\n     * Haijalishi chaguo, matokeo ni kamba tupu.\n     *\n     * Mfano 3:\n     * Ingizo: s = \"s\"\n     * Matokeo: \"s\"\n     * Maelezo: Kamba tayari ni \"nzuri\".\n     */\n  public String makeGood(String s) ",
      "tr": "class Solution {\n    /**\n     * Küçük ve büyük İngiliz harflerinden oluşan bir s dizesi verildiğinde,\n     * dizeyi \"iyi\" hale getirmeniz gerekiyor.\n     * Bir dize, bitişik karakterler arasında\n     * biri küçük harf ve diğeri karşılık gelen büyük harf olacak şekilde\n     * karakterler bulunmadığında \"iyi\" olarak kabul edilir.\n     * Dizideki herhangi bir bitişik karakteri seçip kaldırarak dizeyi \"iyi\" yapabilirsiniz.\n     * Son \"iyi\" dizeyi döndürün.\n     *\n     * Örnek 1:\n     * Girdi: s = \"leEeetcode\"\n     * Çıktı: \"leetcode\"\n     * Açıklama: \"Ee\" kaldırarak \"leetcode\" yapabilirsiniz.\n     *\n     * Örnek 2:\n     * Girdi: s = \"abBAcC\"\n     * Çıktı: \"\"\n     * Açıklama: Birden fazla olası çözüm vardır, örneğin:\n     * - \"bB\" kaldırarak \"aAcC\" yapın, ardından \"cC\" kaldırarak \"aA\" yapın, ardından \"aA\" kaldırarak \"\" yapın.\n     * - \"aA\" kaldırarak \"abBAcC\" yapın, ardından \"bB\" kaldırarak \"aAcC\" yapın, ardından \"cC\" kaldırarak \"aA\" yapın,\n     *   ardından \"aA\" kaldırarak \"\" yapın.\n     * Seçimler ne olursa olsun, sonuç boş bir dizedir.\n     *\n     * Örnek 3:\n     * Girdi: s = \"s\"\n     * Çıktı: \"s\"\n     * Açıklama: Dize zaten \"iyi\".\n     */\n  public String makeGood(String s) ",
      "vi": "class Solution {\n    /**\n     * Cho một chuỗi s bao gồm các chữ cái tiếng Anh viết thường và viết hoa,\n     * bạn cần làm cho chuỗi trở nên \"tốt\".\n     * Một chuỗi được coi là \"tốt\" nếu không có các ký tự liền kề nào mà\n     * một là chữ cái viết thường và cái kia là chữ cái viết hoa tương ứng.\n     * Bạn có thể chọn bất kỳ ký tự liền kề nào trong chuỗi và loại bỏ chúng cho đến khi chuỗi trở nên \"tốt\".\n     * Trả về chuỗi \"tốt\" cuối cùng.\n     *\n     * Ví dụ 1:\n     * Đầu vào: s = \"leEeetcode\"\n     * Đầu ra: \"leetcode\"\n     * Giải thích: Bạn có thể loại bỏ \"Ee\" để làm cho \"leetcode\".\n     *\n     * Ví dụ 2:\n     * Đầu vào: s = \"abBAcC\"\n     * Đầu ra: \"\"\n     * Giải thích: Có nhiều giải pháp khả thi, chẳng hạn như:\n     * - Loại bỏ \"bB\" để làm cho \"aAcC\", sau đó loại bỏ \"cC\" để làm cho \"aA\", sau đó loại bỏ \"aA\" để làm cho \"\".\n     * - Loại bỏ \"aA\" để làm cho \"abBAcC\", sau đó loại bỏ \"bB\" để làm cho \"aAcC\", sau đó loại bỏ \"cC\" để làm cho \"aA\",\n     *   sau đó loại bỏ \"aA\" để làm cho \"\".\n     * Dù lựa chọn thế nào, kết quả là một chuỗi rỗng.\n     *\n     * Ví dụ 3:\n     * Đầu vào: s = \"s\"\n     * Đầu ra: \"s\"\n     * Giải thích: Chuỗi đã \"tốt\" sẵn rồi.\n     */\n  public String makeGood(String s) "
    },
    "prompt_bertscore": {
      "es": "0.9944653630628438",
      "arb": "0.9727753227145961",
      "sw": "0.9914682292434085",
      "tr": "0.9788710904781759",
      "vi": "0.9935540468746558"
    },
    "canonical_solution": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }",
    "instruction": {
      "en": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nJava kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9306920997758775",
      "sw": "0.9426256144380726",
      "tr": "0.8707023479868636",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "makeGood",
    "signature": "public String makeGood(String s)",
    "docstring": {
      "en": "Given a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".",
      "es": "Dada una cadena s que consiste en letras inglesas en minúsculas y mayúsculas, necesitas hacer que la cadena sea \"buena\". Una cadena se considera \"buena\" si no hay caracteres adyacentes tales que uno sea una letra minúscula y el otro sea la letra mayúscula correspondiente. Puedes elegir cualquier par de caracteres adyacentes en la cadena y eliminarlos hasta que la cadena sea \"buena\". Devuelve la cadena \"buena\" final.\n\nEjemplo 1:\nEntrada: s = \"leEeetcode\"\nSalida: \"leetcode\"\nExplicación: Puedes eliminar \"Ee\" para hacer \"leetcode\".\n\nEjemplo 2:\nEntrada: s = \"abBAcC\"\nSalida: \"\"\nExplicación: Hay múltiples soluciones posibles, tales como:\n- Eliminar \"bB\" para hacer \"aAcC\", luego eliminar \"cC\" para hacer \"aA\", luego eliminar \"aA\" para hacer \"\".\n- Eliminar \"aA\" para hacer \"abBAcC\", luego eliminar \"bB\" para hacer \"aAcC\", luego eliminar \"cC\" para hacer \"aA\", luego eliminar \"aA\" para hacer \"\".\nNo importa las elecciones, el resultado es una cadena vacía.\n\nEjemplo 3:\nEntrada: s = \"s\"\nSalida: \"s\"\nExplicación: La cadena ya es \"buena\".",
      "arb": "بالنظر إلى سلسلة s تتكون من حروف إنجليزية صغيرة وكبيرة،\n     * تحتاج إلى جعل السلسلة \"جيدة\".\n     * تعتبر السلسلة \"جيدة\" إذا لم يكن هناك حروف متجاورة بحيث\n     * يكون أحدها حرف صغير والآخر هو الحرف الكبير المقابل له.\n     * يمكنك اختيار أي حروف متجاورة في السلسلة وإزالتها حتى تصبح السلسلة \"جيدة\".\n     * أعد السلسلة \"الجيدة\" النهائية.\n     *\n     * المثال 1:\n     * المدخلات: s = \"leEeetcode\"\n     * الناتج: \"leetcode\"\n     * التوضيح: يمكنك إزالة \"Ee\" لجعل السلسلة \"leetcode\".\n     *\n     * المثال 2:\n     * المدخلات: s = \"abBAcC\"\n     * الناتج: \"\"\n     * التوضيح: هناك حلول متعددة ممكنة، مثل:\n     * - إزالة \"bB\" لجعل السلسلة \"aAcC\"، ثم إزالة \"cC\" لجعل السلسلة \"aA\"، ثم إزالة \"aA\" لجعل السلسلة \"\".\n     * - إزالة \"aA\" لجعل السلسلة \"abBAcC\"، ثم إزالة \"bB\" لجعل السلسلة \"aAcC\"، ثم إزالة \"cC\" لجعل السلسلة \"aA\"،\n     *   ثم إزالة \"aA\" لجعل السلسلة \"\".\n     * بغض النظر عن الاختيارات، النتيجة هي سلسلة فارغة.\n     *\n     * المثال 3:\n     * المدخلات: s = \"s\"\n     * الناتج: \"s\"\n     * التوضيح: السلسلة بالفعل \"جيدة\".\n     */\n  public String makeGood(String s)  ",
      "sw": "Kwa kupewa kamba s inayojumuisha herufi ndogo na kubwa za Kiingereza,\nunahitaji kufanya kamba hiyo iwe \"nzuri\".\nKamba inachukuliwa kuwa \"nzuri\" ikiwa hakuna herufi zinazofuatana ambapo\nmoja ni herufi ndogo na nyingine ni herufi kubwa inayolingana.\nUnaweza kuchagua herufi zozote zinazofuatana katika kamba na kuziondoa hadi kamba iwe \"nzuri\".\nRudisha kamba ya mwisho \"nzuri\".\n\nMfano 1:\nIngizo: s = \"leEeetcode\"\nPato: \"leetcode\"\nMaelezo: Unaweza kuondoa \"Ee\" ili kufanya \"leetcode\".\n\nMfano 2:\nIngizo: s = \"abBAcC\"\nPato: \"\"\nMaelezo: Kuna suluhisho nyingi zinazowezekana, kama vile:\n- Ondoa \"bB\" ili kufanya \"aAcC\", kisha ondoa \"cC\" ili kufanya \"aA\", kisha ondoa \"aA\" ili kufanya \"\".\n- Ondoa \"aA\" ili kufanya \"abBAcC\", kisha ondoa \"bB\" ili kufanya \"aAcC\", kisha ondoa \"cC\" ili kufanya \"aA\",\nkisha ondoa \"aA\" ili kufanya \"\".\nHaijalishi ni chaguo gani, matokeo ni kamba tupu.\n\nMfano 3:\nIngizo: s = \"s\"\nPato: \"s\"\nMaelezo: Kamba tayari ni \"nzuri\".",
      "tr": "Verilen bir s dizesi, küçük ve büyük İngilizce harflerinden oluşmaktadır, bu dizeyi \"iyi\" hale getirmeniz gerekmektedir. Bir dize, bitişik karakterler arasında biri küçük harf ve diğeri karşılık gelen büyük harf olacak şekilde karakterler yoksa \"iyi\" olarak kabul edilir. Dizideki herhangi bir bitişik karakteri seçip bunları dize \"iyi\" olana kadar kaldırabilirsiniz. Son \"iyi\" dizeyi döndürün.\n\nÖrnek 1:\nGirdi: s = \"leEeetcode\"\nÇıktı: \"leetcode\"\nAçıklama: \"Ee\"yi kaldırarak \"leetcode\" yapabilirsiniz.\n\nÖrnek 2:\nGirdi: s = \"abBAcC\"\nÇıktı: \"\"\nAçıklama: Birden fazla olası çözüm vardır, örneğin:\n- \"bB\"yi kaldırarak \"aAcC\" yapın, ardından \"cC\"yi kaldırarak \"aA\" yapın, ardından \"aA\"yı kaldırarak \"\" yapın.\n- \"aA\"yı kaldırarak \"abBAcC\" yapın, ardından \"bB\"yi kaldırarak \"aAcC\" yapın, ardından \"cC\"yi kaldırarak \"aA\" yapın,\nardından \"aA\"yı kaldırarak \"\" yapın.\nSeçimler ne olursa olsun, sonuç boş bir dizedir.\n\nÖrnek 3:\nGirdi: s = \"s\"\nÇıktı: \"s\"\nAçıklama: Dize zaten \"iyi\".",
      "vi": "Cho một chuỗi s bao gồm các chữ cái tiếng Anh viết thường và viết hoa, bạn cần làm cho chuỗi trở nên \"tốt\". Một chuỗi được coi là \"tốt\" nếu không có các ký tự liền kề sao cho một là chữ cái viết thường và chữ kia là chữ cái viết hoa tương ứng. Bạn có thể chọn bất kỳ ký tự liền kề nào trong chuỗi và loại bỏ chúng cho đến khi chuỗi trở nên \"tốt\". Trả về chuỗi \"tốt\" cuối cùng.\n\nVí dụ 1:\nĐầu vào: s = \"leEeetcode\"\nĐầu ra: \"leetcode\"\nGiải thích: Bạn có thể loại bỏ \"Ee\" để làm cho \"leetcode\".\n\nVí dụ 2:\nĐầu vào: s = \"abBAcC\"\nĐầu ra: \"\"\nGiải thích: Có nhiều giải pháp khả thi, chẳng hạn như:\n- Loại bỏ \"bB\" để làm cho \"aAcC\", sau đó loại bỏ \"cC\" để làm cho \"aA\", sau đó loại bỏ \"aA\" để làm cho \"\".\n- Loại bỏ \"aA\" để làm cho \"abBAcC\", sau đó loại bỏ \"bB\" để làm cho \"aAcC\", sau đó loại bỏ \"cC\" để làm cho \"aA\", sau đó loại bỏ \"aA\" để làm cho \"\".\nDù lựa chọn thế nào, kết quả là một chuỗi rỗng.\n\nVí dụ 3:\nĐầu vào: s = \"s\"\nĐầu ra: \"s\"\nGiải thích: Chuỗi đã \"tốt\" sẵn."
    },
    "docstring_bertscore": {
      "es": "0.9941157735922225",
      "arb": "0.999999801369619",
      "sw": "0.9881074031962981",
      "tr": "0.9851271529592507",
      "vi": "0.9979467577512423"
    }
  },
  {
    "task_id": "Java/31",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   */\n  public int maxUniqueSplit(String s) ",
      "es": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Dada una cadena s, divide la cadena y devuelve el número máximo de subcadenas únicas.\n   * Las subcadenas divididas deben poder reconstruir la cadena original, y cada subcadena debe ser única.\n   *\n   * Ejemplo:\n   * Entrada: s = \"ababccc\"\n   * Salida: 5\n   * Explicación: Una forma posible de dividir la cadena es ['a', 'b', 'ab', 'c', 'cc'].\n   *              Dividir la cadena como ['a', 'b', 'a', 'b', 'c', 'cc'] no es válido, porque tanto 'a' como 'b' aparecen más de una vez.\n   *\n   * Nota:\n   * - La longitud de s está entre 1 y 16.\n   * - s solo contiene letras minúsculas del alfabeto inglés.\n   */\n  public int maxUniqueSplit(String s) ",
      "arb": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * بالنظر إلى سلسلة نصية s، قم بتقسيم السلسلة النصية وأعد العدد الأقصى من السلاسل الفرعية الفريدة.\n   * يجب أن تكون السلاسل الفرعية المقسمة قادرة على إعادة بناء السلسلة النصية الأصلية، ويجب أن تكون كل سلسلة فرعية فريدة.\n   *\n   * مثال:\n   * المدخلات: s = \"ababccc\"\n   * الناتج: 5\n   * الشرح: إحدى الطرق الممكنة لتقسيم السلسلة النصية هي ['a', 'b', 'ab', 'c', 'cc'].\n   *        تقسيم السلسلة النصية كـ ['a', 'b', 'a', 'b', 'c', 'cc'] غير صالح، لأن 'a' و 'b' يظهران أكثر من مرة.\n   *\n   * ملاحظة:\n   * - طول s يتراوح بين 1 و 16.\n   * - s يحتوي فقط على حروف إنجليزية صغيرة.\n   */\n  public int maxUniqueSplit(String s) ",
      "sw": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Ukipewa kamba s, gawanya kamba hiyo na rudisha idadi kubwa zaidi ya vipande vidogo vya kipekee.\n   * Vipande vidogo vilivyogawanywa vinapaswa kuweza kuunda upya kamba asili, na kila kipande kidogo lazima kiwe cha kipekee.\n   *\n   * Mfano:\n   * Ingizo: s = \"ababccc\"\n   * Matokeo: 5\n   * Maelezo: Njia moja inayowezekana ya kugawanya kamba ni ['a', 'b', 'ab', 'c', 'cc'].\n   *              Kugawanya kamba kama ['a', 'b', 'a', 'b', 'c', 'cc'] si sahihi, kwa sababu 'a' na 'b' zote zinaonekana zaidi ya mara moja.\n   *\n   * Kumbuka:\n   * - Urefu wa s ni kati ya 1 na 16.\n   * - s ina herufi ndogo za Kiingereza pekee.\n   */\n  public int maxUniqueSplit(String s) ",
      "tr": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Verilen bir string s için, stringi böl ve maksimum sayıda benzersiz alt dizeyi döndür.\n   * Bölünmüş alt dizeler orijinal stringi yeniden oluşturabilmeli ve her alt dize benzersiz olmalıdır.\n   *\n   * Örnek:\n   * Girdi: s = \"ababccc\"\n   * Çıktı: 5\n   * Açıklama: Stringi bölmenin olası bir yolu ['a', 'b', 'ab', 'c', 'cc'] şeklindedir.\n   *           Stringi ['a', 'b', 'a', 'b', 'c', 'cc'] olarak bölmek geçerli değildir, çünkü hem 'a' hem de 'b' birden fazla kez görünmektedir.\n   *\n   * Not:\n   * - s'nin uzunluğu 1 ile 16 arasındadır.\n   * - s sadece küçük İngilizce harfler içerir.\n   */\n  public int maxUniqueSplit(String s) ",
      "vi": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Cho một chuỗi s, tách chuỗi và trả về số lượng tối đa các chuỗi con duy nhất.\n   * Các chuỗi con được tách ra phải có thể tái tạo lại chuỗi gốc, và mỗi chuỗi con phải là duy nhất.\n   *\n   * Ví dụ:\n   * Đầu vào: s = \"ababccc\"\n   * Đầu ra: 5\n   * Giải thích: Một cách có thể để tách chuỗi là ['a', 'b', 'ab', 'c', 'cc'].\n   *              Tách chuỗi thành ['a', 'b', 'a', 'b', 'c', 'cc'] là không hợp lệ, vì cả 'a' và 'b' xuất hiện nhiều hơn một lần.\n   *\n   * Lưu ý:\n   * - Độ dài của s nằm trong khoảng từ 1 đến 16.\n   * - s chỉ chứa các chữ cái tiếng Anh viết thường.\n   */\n  public int maxUniqueSplit(String s) "
    },
    "prompt_bertscore": {
      "es": "0.9921471478857857",
      "arb": "0.9909225915867056",
      "sw": "0.9899892274262226",
      "tr": "0.9942460751221813",
      "vi": "0.9877752931992078"
    },
    "canonical_solution": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n",
    "instruction": {
      "en": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español usando un máximo de 500 caracteres.",
      "arb": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة جافا باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9240008381299553",
      "sw": "0.9149216420432316",
      "tr": "0.892293669035737",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "maxUniqueSplit",
    "signature": "public int maxUniqueSplit(String s)",
    "docstring": {
      "en": "Given a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.",
      "es": "Dada una cadena s, divide la cadena y devuelve el número máximo de subcadenas únicas.\nLas subcadenas divididas deben poder reconstruir la cadena original, y cada subcadena debe ser única.\n\nEjemplo:\nEntrada: s = \"ababccc\"\nSalida: 5\nExplicación: Una forma posible de dividir la cadena es ['a', 'b', 'ab', 'c', 'cc'].\nDividir la cadena como ['a', 'b', 'a', 'b', 'c', 'cc'] no es válido, porque tanto 'a' como 'b' aparecen más de una vez.\n\nNota:\n- La longitud de s está entre 1 y 16.\n- s solo contiene letras minúsculas del alfabeto inglés.",
      "arb": "معطى سلسلة s، قم بتقسيم السلسلة وأعد العدد الأقصى من السلاسل الفرعية الفريدة. يجب أن تكون السلاسل الفرعية المقسمة قادرة على إعادة بناء السلسلة الأصلية، ويجب أن تكون كل سلسلة فرعية فريدة.\n\nمثال:\nالمدخل: s = \"ababccc\"\nالمخرج: 5\nالتفسير: إحدى الطرق الممكنة لتقسيم السلسلة هي ['a', 'b', 'ab', 'c', 'cc'].\nتقسيم السلسلة كـ ['a', 'b', 'a', 'b', 'c', 'cc'] غير صالح، لأن كل من 'a' و 'b' يظهران أكثر من مرة.\n\nملاحظة:\n- طول s يتراوح بين 1 و 16.\n- s يحتوي فقط على حروف إنجليزية صغيرة.",
      "sw": "Kwa kupewa kamba s, gawanya kamba na rudisha idadi kubwa zaidi ya vipande vidogo vya kipekee.\nVipande vilivyogawanywa vinapaswa kuweza kujenga upya kamba asili, na kila kipande lazima kiwe cha kipekee.\n\nMfano:\nIngizo: s = \"ababccc\"\nMatokeo: 5\nMaelezo: Njia mojawapo ya kugawanya kamba ni ['a', 'b', 'ab', 'c', 'cc'].\nKugawanya kamba kama ['a', 'b', 'a', 'b', 'c', 'cc'] si sahihi, kwa sababu 'a' na 'b' zote zinaonekana zaidi ya mara moja.\n\nKumbuka:\n- Urefu wa s ni kati ya 1 na 16.\n- s inajumuisha tu herufi ndogo za Kiingereza.",
      "tr": "Verilen bir string s için, stringi bölün ve maksimum sayıda benzersiz alt dize döndürün. Bölünmüş alt dizeler orijinal stringi yeniden oluşturabilmeli ve her alt dize benzersiz olmalıdır.\n\nÖrnek:\nGirdi: s = \"ababccc\"\nÇıktı: 5\nAçıklama: Stringi bölmenin olası bir yolu ['a', 'b', 'ab', 'c', 'cc'] şeklindedir.\nStringi ['a', 'b', 'a', 'b', 'c', 'cc'] olarak bölmek geçerli değildir, çünkü hem 'a' hem de 'b' birden fazla kez görünmektedir.\n\nNot:\n- s'nin uzunluğu 1 ile 16 arasındadır.\n- s yalnızca küçük harfli İngilizce harfler içerir.",
      "vi": "Cho một chuỗi s, tách chuỗi và trả về số lượng tối đa các chuỗi con duy nhất. Các chuỗi con được tách ra phải có thể tái tạo lại chuỗi gốc, và mỗi chuỗi con phải là duy nhất.\n\nVí dụ:\nĐầu vào: s = \"ababccc\"\nĐầu ra: 5\nGiải thích: Một cách có thể để tách chuỗi là ['a', 'b', 'ab', 'c', 'cc'].\nTách chuỗi như ['a', 'b', 'a', 'b', 'c', 'cc'] không hợp lệ, vì cả 'a' và 'b' xuất hiện nhiều hơn một lần.\n\nLưu ý:\n- Độ dài của s nằm trong khoảng từ 1 đến 16.\n- s chỉ chứa các chữ cái tiếng Anh viết thường."
    },
    "docstring_bertscore": {
      "es": "0.9910761328712456",
      "arb": "0.9945358768481113",
      "sw": "0.9827072390271027",
      "tr": "0.9930062242837616",
      "vi": "0.9910481259875197"
    }
  },
  {
    "task_id": "Java/32",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explanation: Perform the \"../\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "es": "class Solution {\n    /**\n     * Dada una lista de registros que representan operaciones de carpetas,\n     * devuelve el número mínimo de pasos necesarios para volver a la carpeta principal.\n     *\n     * Ejemplo:\n     * Entrada: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Salida: 2\n     * Explicación: Realiza la operación \"../\" dos veces para volver a la carpeta principal.\n     *\n     * Entrada: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Salida: 3\n     *\n     * Entrada: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Salida: 0\n     */\n  public int minOperations(String[] logs) ",
      "arb": "class Solution {\n    /**\n     * بالنظر إلى قائمة من السجلات التي تمثل عمليات المجلدات،\n     * أعد الحد الأدنى لعدد الخطوات المطلوبة للعودة إلى المجلد الرئيسي.\n     *\n     * مثال:\n     * المدخلات: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * الناتج: 2\n     * التفسير: قم بتنفيذ عملية \"../\" مرتين للعودة إلى المجلد الرئيسي.\n     *\n     * المدخلات: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * الناتج: 3\n     *\n     * المدخلات: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * الناتج: 0\n     */\n  public int minOperations(String[] logs) ",
      "sw": "class Solution {\n    /**\n     * Ukipewa orodha ya kumbukumbu zinazowakilisha operesheni za folda,\n     * rudisha idadi ndogo ya hatua zinazohitajika kurudi kwenye folda kuu.\n     *\n     * Mfano:\n     * Ingizo: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Matokeo: 2\n     * Maelezo: Fanya operesheni ya \"../\" mara mbili ili kurudi kwenye folda kuu.\n     *\n     * Ingizo: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Matokeo: 3\n     *\n     * Ingizo: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Matokeo: 0\n     */\n  public int minOperations(String[] logs) ",
      "tr": "class Solution {\n    /**\n     * Klasör işlemlerini temsil eden bir günlük listesi verildiğinde,\n     * ana klasöre dönmek için gereken minimum adım sayısını döndürün.\n     *\n     * Örnek:\n     * Girdi: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Çıktı: 2\n     * Açıklama: Ana klasöre dönmek için \"../\" işlemini iki kez gerçekleştirin.\n     *\n     * Girdi: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Çıktı: 3\n     *\n     * Girdi: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Çıktı: 0\n     */\n  public int minOperations(String[] logs) ",
      "vi": "class Solution {\n    /**\n     * Cho một danh sách các nhật ký đại diện cho các thao tác thư mục,\n     * trả về số bước tối thiểu cần thiết để quay trở lại thư mục chính.\n     *\n     * Ví dụ:\n     * Đầu vào: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Đầu ra: 2\n     * Giải thích: Thực hiện thao tác \"../\" hai lần để quay trở lại thư mục chính.\n     *\n     * Đầu vào: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Đầu ra: 3\n     *\n     * Đầu vào: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Đầu ra: 0\n     */\n  public int minOperations(String[] logs) "
    },
    "prompt_bertscore": {
      "es": "0.9961072417924782",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.9876612793604937"
    },
    "canonical_solution": "  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }",
    "instruction": {
      "en": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9306920997758775",
      "sw": "0.9149216420432316",
      "tr": "0.8475368811682888",
      "vi": "0.9391058840861344"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"../\", \"d21/\", \"./\", \"../\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\", \"../\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"../\", \"../\", \"../\", \"d2/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minOperations",
    "signature": "public int minOperations(String[] logs)",
    "docstring": {
      "en": "Given a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "es": "Dada una lista de registros que representan operaciones de carpetas, devuelve el número mínimo de pasos necesarios para volver a la carpeta principal.\n\nEjemplo:\nEntrada: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nSalida: 2\nExplicación: Realiza la operación \"../\" dos veces para volver a la carpeta principal.\n\nEntrada: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nSalida: 3\n\nEntrada: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nSalida: 0",
      "arb": "بالنظر إلى قائمة من السجلات التي تمثل عمليات المجلدات، \nإرجاع الحد الأدنى لعدد الخطوات المطلوبة للعودة إلى المجلد الرئيسي.\n\nمثال:\nالمدخل: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nالمخرج: 2\nالتوضيح: قم بتنفيذ عملية \"../\" مرتين للعودة إلى المجلد الرئيسي.\n\nالمدخل: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nالمخرج: 3\n\nالمدخل: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nالمخرج: 0",
      "sw": "Ukipatiwa orodha ya kumbukumbu zinazowakilisha operesheni za folda, rudisha idadi ndogo ya hatua zinazohitajika kurudi kwenye folda kuu.\n\nMfano:\nIngizo: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nPato: 2\nUfafanuzi: Fanya operesheni ya \"../\" mara mbili kurudi kwenye folda kuu.\n\nIngizo: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nPato: 3\n\nIngizo: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nPato: 0",
      "tr": "Verilen klasör işlemlerini temsil eden bir günlük listesi göz önüne alındığında, ana klasöre dönmek için gereken minimum adım sayısını döndürün.\n\nÖrnek:\nGirdi: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nÇıktı: 2\nAçıklama: Ana klasöre dönmek için \"../\" işlemini iki kez gerçekleştirin.\n\nGirdi: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nÇıktı: 3\n\nGirdi: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nÇıktı: 0",
      "vi": "Given a list of logs representing folder operations, return the minimum number of steps required to return to the main folder.\n\nVí dụ:\nĐầu vào: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nĐầu ra: 2\nGiải thích: Thực hiện thao tác \"../\" hai lần để trở về thư mục chính.\n\nĐầu vào: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nĐầu ra: 3\n\nĐầu vào: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nĐầu ra: 0"
    },
    "docstring_bertscore": {
      "es": "0.9919399763983663",
      "arb": "0.9947603291786807",
      "sw": "1",
      "tr": "1",
      "vi": "0.9970759621607854"
    }
  },
  {
    "task_id": "Java/33",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "es": "import java.util.*;\n\nclass Solution {\n    /**\n     * Devuelve la cadena lexicográficamente más pequeña de longitud n y valor k.\n     * El valor de una cadena es la suma de las posiciones de sus caracteres en el alfabeto (comenzando desde 1).\n     * Ejemplo:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "arb": "import java.util.*;\n\nclass Solution {\n    /**\n     * إرجاع أصغر سلسلة مرتبة ترتيبًا معجميًا بطول n وقيمة k.\n     * قيمة السلسلة هي مجموع مواقع حروفها في الأبجدية (بدءًا من 1).\n     * مثال:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "sw": "import java.util.*;\n\nclass Solution {\n    /**\n     * Rudisha kamba ndogo zaidi kwa mpangilio wa alfabeti yenye urefu n na thamani k.\n     * Thamani ya kamba ni jumla ya nafasi za herufi zake katika alfabeti (kuanzia 1).\n     * Mfano:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "tr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Uzunluğu n ve değeri k olan sözlük sırasına göre en küçük dizgiyi döndür.\n     * Bir dizginin değeri, karakterlerinin alfabedeki pozisyonlarının toplamıdır (1'den başlayarak).\n     * Örnek:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "vi": "import java.util.*;\n\nclass Solution {\n    /**\n     * Trả về chuỗi có thứ tự từ điển nhỏ nhất với độ dài n và giá trị k.\n     * Giá trị của một chuỗi là tổng vị trí của các ký tự trong bảng chữ cái (bắt đầu từ 1).\n     * Ví dụ:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) "
    },
    "prompt_bertscore": {
      "es": "0.9988590670913357",
      "arb": "0.9843695766859836",
      "sw": "0.9631709479004162",
      "tr": "0.9821858342768861",
      "vi": "0.9966699616619501"
    },
    "canonical_solution": "    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }",
    "instruction": {
      "en": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español usando como máximo 500 caracteres.",
      "arb": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nJava kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, kısa ve öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9426256144380726",
      "tr": "0.8720578017070457",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "getSmallestString",
    "signature": "public String getSmallestString(int n, int k)",
    "docstring": {
      "en": "Return the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "es": "Devuelve la cadena lexicográficamente más pequeña de longitud n y valor k.  \nEl valor de una cadena es la suma de las posiciones de sus caracteres en el alfabeto (comenzando desde 1).  \nEjemplo:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "arb": "إرجاع أصغر سلسلة مرتبة ترتيبًا معجميًا بطول n وقيمة k.  \nقيمة السلسلة هي مجموع مواقع حروفها في الأبجدية (تبدأ من 1).  \nمثال:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"  ",
      "sw": "Rudisha kamba ndogo zaidi kwa mpangilio wa alfabeti yenye urefu n na thamani k. Thamani ya kamba ni jumla ya nafasi za herufi zake katika alfabeti (kuanzia 1).\n\nMfano:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "tr": "n uzunluğunda ve k değerinde sözlük sırasına göre en küçük dizgeyi döndürün.\nBir dizgenin değeri, karakterlerinin alfabedeki pozisyonlarının toplamıdır (1'den başlayarak).\nÖrnek:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "vi": "Trả về chuỗi nhỏ nhất theo thứ tự từ điển có độ dài n và giá trị k.  \nGiá trị của một chuỗi là tổng của các vị trí của các ký tự trong bảng chữ cái (bắt đầu từ 1).  \nVí dụ:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"  "
    },
    "docstring_bertscore": {
      "es": "0.9999060478297706",
      "arb": "0.9830733148193499",
      "sw": "0.9523322838984855",
      "tr": "0.9315340939610844",
      "vi": "0.9874551010249796"
    }
  },
  {
    "task_id": "Java/34",
    "prompt": {
      "en": "public class Solution {\n\n  // Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  // @param n The number of passengers.\n  // @return The probability that the last passenger will sit in their own seat.\n\n  // Example 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Example 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Example 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Example 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Example 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Example 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Function to calculate the probability that the last passenger will sit in their own seat\n  public static double calculateProbability(int n) ",
      "es": "public class Solution {\n\n  // Dado el número de pasajeros n, calcula la probabilidad de que el último pasajero se siente en su propio asiento.\n  // @param n El número de pasajeros.\n  // @return La probabilidad de que el último pasajero se siente en su propio asiento.\n\n  // Ejemplo 1:\n  // Entrada: n = 1\n  // Salida: 1.00000\n\n  // Ejemplo 2:\n  // Entrada: n = 2\n  // Salida: 0.50000\n\n  // Ejemplo 3:\n  // Entrada: n = 3\n  // Salida: 0.50000\n\n  // Ejemplo 4:\n  // Entrada: n = 4\n  // Salida: 0.50000\n\n  // Ejemplo 5:\n  // Entrada: n = 5\n  // Salida: 0.50000\n\n  // Ejemplo 6:\n  // Entrada: n = 100000\n  // Salida: 0.50000\n\n  // Función para calcular la probabilidad de que el último pasajero se siente en su propio asiento\n  public static double calculateProbability(int n) ",
      "arb": "public class Solution {\n\n  // بالنظر إلى عدد الركاب n، احسب احتمال أن يجلس الراكب الأخير في مقعده الخاص.\n  // @param n عدد الركاب.\n  // @return احتمال أن يجلس الراكب الأخير في مقعده الخاص.\n\n  // المثال 1:\n  // المدخلات: n = 1\n  // الناتج: 1.00000\n\n  // المثال 2:\n  // المدخلات: n = 2\n  // الناتج: 0.50000\n\n  // المثال 3:\n  // المدخلات: n = 3\n  // الناتج: 0.50000\n\n  // المثال 4:\n  // المدخلات: n = 4\n  // الناتج: 0.50000\n\n  // المثال 5:\n  // المدخلات: n = 5\n  // الناتج: 0.50000\n\n  // المثال 6:\n  // المدخلات: n = 100000\n  // الناتج: 0.50000\n\n  // دالة لحساب احتمال أن يجلس الراكب الأخير في مقعده الخاص\n  public static double calculateProbability(int n) ",
      "sw": "public class Solution {\n\n  // Ukipewa idadi ya abiria n, hesabu uwezekano kwamba abiria wa mwisho atakaa kwenye kiti chake mwenyewe.\n  // @param n Idadi ya abiria.\n  // @return Uwezekano kwamba abiria wa mwisho atakaa kwenye kiti chake mwenyewe.\n\n  // Mfano 1:\n  // Ingizo: n = 1\n  // Matokeo: 1.00000\n\n  // Mfano 2:\n  // Ingizo: n = 2\n  // Matokeo: 0.50000\n\n  // Mfano 3:\n  // Ingizo: n = 3\n  // Matokeo: 0.50000\n\n  // Mfano 4:\n  // Ingizo: n = 4\n  // Matokeo: 0.50000\n\n  // Mfano 5:\n  // Ingizo: n = 5\n  // Matokeo: 0.50000\n\n  // Mfano 6:\n  // Ingizo: n = 100000\n  // Matokeo: 0.50000\n\n  // Kazi ya kuhesabu uwezekano kwamba abiria wa mwisho atakaa kwenye kiti chake mwenyewe\n  public static double calculateProbability(int n) ",
      "tr": "public class Solution {\n\n  // Yolcu sayısı n verildiğinde, son yolcunun kendi koltuğuna oturma olasılığını hesaplayın.\n  // @param n Yolcu sayısı.\n  // @return Son yolcunun kendi koltuğuna oturma olasılığı.\n\n  // Örnek 1:\n  // Girdi: n = 1\n  // Çıktı: 1.00000\n\n  // Örnek 2:\n  // Girdi: n = 2\n  // Çıktı: 0.50000\n\n  // Örnek 3:\n  // Girdi: n = 3\n  // Çıktı: 0.50000\n\n  // Örnek 4:\n  // Girdi: n = 4\n  // Çıktı: 0.50000\n\n  // Örnek 5:\n  // Girdi: n = 5\n  // Çıktı: 0.50000\n\n  // Örnek 6:\n  // Girdi: n = 100000\n  // Çıktı: 0.50000\n\n  // Son yolcunun kendi koltuğuna oturma olasılığını hesaplayan fonksiyon\n  public static double calculateProbability(int n) ",
      "vi": "public class Solution {\n\n  // Cho số hành khách n, tính xác suất rằng hành khách cuối cùng sẽ ngồi vào ghế của mình.\n  // @param n Số lượng hành khách.\n  // @return Xác suất rằng hành khách cuối cùng sẽ ngồi vào ghế của mình.\n\n  // Ví dụ 1:\n  // Đầu vào: n = 1\n  // Đầu ra: 1.00000\n\n  // Ví dụ 2:\n  // Đầu vào: n = 2\n  // Đầu ra: 0.50000\n\n  // Ví dụ 3:\n  // Đầu vào: n = 3\n  // Đầu ra: 0.50000\n\n  // Ví dụ 4:\n  // Đầu vào: n = 4\n  // Đầu ra: 0.50000\n\n  // Ví dụ 5:\n  // Đầu vào: n = 5\n  // Đầu ra: 0.50000\n\n  // Ví dụ 6:\n  // Đầu vào: n = 100000\n  // Đầu ra: 0.50000\n\n  // Hàm để tính xác suất rằng hành khách cuối cùng sẽ ngồi vào ghế của mình\n  public static double calculateProbability(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9885426023611456",
      "arb": "0.9769030606628821",
      "sw": "0.9894102198655059",
      "tr": "0.9687925849444656",
      "vi": "0.9894102198655059"
    },
    "canonical_solution": "  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }",
    "instruction": {
      "en": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.8412671131909225",
      "vi": "0.9052995891251394"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n    assert Math.abs(calculateProbability(6) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(10) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(50) - 0.50000) < 0.00001;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateProbability",
    "signature": "public static double calculateProbability(int n)",
    "docstring": {
      "en": "Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  @param n The number of passengers.\n  @return The probability that the last passenger will sit in their own seat.\n\n  Example 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Example 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Example 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Example 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Example 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Example 6:\n  Input: n = 100000\n  Output: 0.50000",
      "es": "Dado el número de pasajeros n, calcula la probabilidad de que el último pasajero se siente en su propio asiento.\n  @param n El número de pasajeros.\n  @return La probabilidad de que el último pasajero se siente en su propio asiento.\n\n  Ejemplo 1:\n  Entrada: n = 1\n  Salida: 1.00000\n\n  Ejemplo 2:\n  Entrada: n = 2\n  Salida: 0.50000\n\n  Ejemplo 3:\n  Entrada: n = 3\n  Salida: 0.50000\n\n  Ejemplo 4:\n  Entrada: n = 4\n  Salida: 0.50000\n\n  Ejemplo 5:\n  Entrada: n = 5\n  Salida: 0.50000\n\n  Ejemplo 6:\n  Entrada: n = 100000\n  Salida: 0.50000",
      "arb": "بالنظر إلى عدد الركاب n، احسب احتمال أن يجلس الراكب الأخير في مقعده الخاص.\n@param n عدد الركاب.\n@return احتمال أن يجلس الراكب الأخير في مقعده الخاص.\n\nمثال 1:\nالمدخلات: n = 1\nالناتج: 1.00000\n\nمثال 2:\nالمدخلات: n = 2\nالناتج: 0.50000\n\nمثال 3:\nالمدخلات: n = 3\nالناتج: 0.50000\n\nمثال 4:\nالمدخلات: n = 4\nالناتج: 0.50000\n\nمثال 5:\nالمدخلات: n = 5\nالناتج: 0.50000\n\nمثال 6:\nالمدخلات: n = 100000\nالناتج: 0.50000",
      "sw": "Ukipewa idadi ya abiria n, hesabu uwezekano kwamba abiria wa mwisho atakaa kwenye kiti chake mwenyewe.  \n@param n Idadi ya abiria.  \n@return Uwezekano kwamba abiria wa mwisho atakaa kwenye kiti chake mwenyewe.\n\nMfano 1:  \nIngizo: n = 1  \nMatokeo: 1.00000\n\nMfano 2:  \nIngizo: n = 2  \nMatokeo: 0.50000\n\nMfano 3:  \nIngizo: n = 3  \nMatokeo: 0.50000\n\nMfano 4:  \nIngizo: n = 4  \nMatokeo: 0.50000\n\nMfano 5:  \nIngizo: n = 5  \nMatokeo: 0.50000\n\nMfano 6:  \nIngizo: n = 100000  \nMatokeo: 0.50000",
      "tr": "Verilen yolcu sayısı n olduğunda, son yolcunun kendi koltuğuna oturma olasılığını hesaplayın.\n  @param n Yolcu sayısı.\n  @return Son yolcunun kendi koltuğuna oturma olasılığı.\n\n  Örnek 1:\n  Girdi: n = 1\n  Çıktı: 1.00000\n\n  Örnek 2:\n  Girdi: n = 2\n  Çıktı: 0.50000\n\n  Örnek 3:\n  Girdi: n = 3\n  Çıktı: 0.50000\n\n  Örnek 4:\n  Girdi: n = 4\n  Çıktı: 0.50000\n\n  Örnek 5:\n  Girdi: n = 5\n  Çıktı: 0.50000\n\n  Örnek 6:\n  Girdi: n = 100000\n  Çıktı: 0.50000",
      "vi": "Cho số lượng hành khách n, tính xác suất rằng hành khách cuối cùng sẽ ngồi vào đúng chỗ của mình.\n  @param n Số lượng hành khách.\n  @return Xác suất rằng hành khách cuối cùng sẽ ngồi vào đúng chỗ của mình.\n\n  Ví dụ 1:\n  Đầu vào: n = 1\n  Đầu ra: 1.00000\n\n  Ví dụ 2:\n  Đầu vào: n = 2\n  Đầu ra: 0.50000\n\n  Ví dụ 3:\n  Đầu vào: n = 3\n  Đầu ra: 0.50000\n\n  Ví dụ 4:\n  Đầu vào: n = 4\n  Đầu ra: 0.50000\n\n  Ví dụ 5:\n  Đầu vào: n = 5\n  Đầu ra: 0.50000\n\n  Ví dụ 6:\n  Đầu vào: n = 100000\n  Đầu ra: 0.50000"
    },
    "docstring_bertscore": {
      "es": "0.9862017433206495",
      "arb": "0.973907118625733",
      "sw": "0.9866178739689175",
      "tr": "0.9708706559908526",
      "vi": "0.9745592221666705"
    }
  },
  {
    "task_id": "Java/35",
    "prompt": {
      "en": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "es": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Dado un array de enteros nums donde cada elemento aparece tres veces excepto uno, que aparece solo una vez. Encuentra y devuelve el elemento que aparece solo una vez.\n   *\n   * @param nums Un array de enteros donde cada elemento aparece tres veces excepto uno.\n   * @return El elemento que aparece solo una vez.\n   *\n   * Ejemplo:\n   * singleNumber(new int[]{2,2,3,2})\n   * Salida: 3\n   *\n   * Ejemplo:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Salida: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "arb": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * معطى مصفوفة أعداد صحيحة حيث يظهر كل عنصر ثلاث مرات باستثناء عنصر واحد، الذي يظهر مرة واحدة فقط. ابحث وأعد العنصر الذي يظهر مرة واحدة فقط.\n   *\n   * @param nums مصفوفة أعداد صحيحة حيث يظهر كل عنصر ثلاث مرات باستثناء عنصر واحد.\n   * @return العنصر الذي يظهر مرة واحدة فقط.\n   *\n   * مثال:\n   * singleNumber(new int[]{2,2,3,2})\n   * الناتج: 3\n   *\n   * مثال:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * الناتج: 99\n   */\n  public static int singleNumber(int[] nums)",
      "sw": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Ukipewa safu ya nambari nzima nums ambapo kila kipengele huonekana mara tatu isipokuwa kimoja, ambacho huonekana mara moja tu. Tafuta na rudisha kipengele kinachoonekana mara moja tu.\n   *\n   * @param nums Safu ya nambari nzima ambapo kila kipengele huonekana mara tatu isipokuwa kimoja.\n   * @return Kipengele kinachoonekana mara moja tu.\n   *\n   * Mfano:\n   * singleNumber(new int[]{2,2,3,2})\n   * Matokeo: 3\n   *\n   * Mfano:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Matokeo: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "tr": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Her elemanın üç kez göründüğü, bir tanesinin ise yalnızca bir kez göründüğü bir tamsayı dizisi verildiğinde, yalnızca bir kez görünen elementi bulun ve döndürün.\n   *\n   * @param nums Her elemanın üç kez göründüğü, bir tanesinin ise yalnızca bir kez göründüğü bir tamsayı dizisi.\n   * @return Yalnızca bir kez görünen eleman.\n   *\n   * Örnek:\n   * singleNumber(new int[]{2,2,3,2})\n   * Çıktı: 3\n   *\n   * Örnek:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Çıktı: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "vi": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Cho một mảng số nguyên nums trong đó mọi phần tử xuất hiện ba lần ngoại trừ một phần tử xuất hiện chỉ một lần. Tìm và trả về phần tử xuất hiện chỉ một lần.\n   *\n   * @param nums Một mảng số nguyên trong đó mọi phần tử xuất hiện ba lần ngoại trừ một phần tử.\n   * @return Phần tử xuất hiện chỉ một lần.\n   *\n   * Ví dụ:\n   * singleNumber(new int[]{2,2,3,2})\n   * Đầu ra: 3\n   *\n   * Ví dụ:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Đầu ra: 99\n   */\n  public static int singleNumber(int[] nums) "
    },
    "prompt_bertscore": {
      "es": "0.9882742527163675",
      "arb": "0.9871092855315978",
      "sw": "0.978057301807076",
      "tr": "0.975205366796177",
      "vi": "0.9951544118546539"
    },
    "canonical_solution": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }",
    "instruction": {
      "en": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9058416514349836",
      "sw": "0.9426256144380726",
      "tr": "0.8412671131909225",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "singleNumber",
    "signature": "public static int singleNumber(int[] nums)",
    "docstring": {
      "en": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99",
      "es": "Dado un array de enteros nums donde cada elemento aparece tres veces excepto uno, que aparece solo una vez. Encuentra y devuelve el elemento que aparece solo una vez.\n\n @param nums Un array de enteros donde cada elemento aparece tres veces excepto uno.\n @return El elemento que aparece solo una vez.\n\n Ejemplo:\n singleNumber(new int[]{2,2,3,2})\n Salida: 3\n\n Ejemplo:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Salida: 99",
      "arb": "نظرًا لمصفوفة أعداد صحيحة تسمى nums حيث يظهر كل عنصر ثلاث مرات باستثناء عنصر واحد يظهر مرة واحدة فقط. ابحث وأعد العنصر الذي يظهر مرة واحدة فقط.\n\n@param nums مصفوفة أعداد صحيحة حيث يظهر كل عنصر ثلاث مرات باستثناء عنصر واحد.\n@return العنصر الذي يظهر مرة واحدة فقط.\n\nمثال:\nsingleNumber(new int[]{2,2,3,2})\nالناتج: 3\n\nمثال:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nالناتج: 99",
      "sw": "Ukipwa safu ya nambari nzima `nums` ambapo kila kipengele kinaonekana mara tatu isipokuwa kimoja, ambacho kinaonekana mara moja tu. Tafuta na urudishe kipengele ambacho kinaonekana mara moja tu.\n\n@param nums Safu ya nambari nzima ambapo kila kipengele kinaonekana mara tatu isipokuwa kimoja.\n@return Kipengele ambacho kinaonekana mara moja tu.\n\nMfano:\nsingleNumber(new int[]{2,2,3,2})\nMatokeo: 3\n\nMfano:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nMatokeo: 99",
      "tr": "Verilen bir tamsayı dizisi `nums`, her elemanın üç kez göründüğü ve yalnızca birinin bir kez göründüğü bir dizidir. Sadece bir kez görünen elementi bulun ve döndürün.\n\n @param nums Her elemanın üç kez göründüğü ve yalnızca birinin bir kez göründüğü bir tamsayı dizisi.\n @return Sadece bir kez görünen eleman.\n\n Örnek:\n singleNumber(new int[]{2,2,3,2})\n Çıktı: 3\n\n Örnek:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Çıktı: 99",
      "vi": "Cho một mảng số nguyên `nums` trong đó mọi phần tử xuất hiện ba lần ngoại trừ một phần tử, xuất hiện chỉ một lần. Tìm và trả về phần tử xuất hiện chỉ một lần.\n\n @param nums Một mảng số nguyên trong đó mọi phần tử xuất hiện ba lần ngoại trừ một phần tử.\n @return Phần tử xuất hiện chỉ một lần.\n\n Ví dụ:\n singleNumber(new int[]{2,2,3,2})\n Đầu ra: 3\n\n Ví dụ:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Đầu ra: 99"
    },
    "docstring_bertscore": {
      "es": "0.9792828512580611",
      "arb": "0.9638292089831658",
      "sw": "0.9637287020103622",
      "tr": "0.9362597093562854",
      "vi": "0.9566640152480943"
    }
  },
  {
    "task_id": "Java/36",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "es": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Encuentra todos los números escalonados en el rango [low, high] donde un número escalonado se define como un número donde cada dígito es uno más o uno menos que el dígito adyacente.\n   *\n   * @param low El límite inferior del rango.\n   * @param high El límite superior del rango.\n   * @return Una lista de números escalonados dentro del rango [low, high] ordenados en orden ascendente.\n   *\n   * Ejemplo:\n   * findSteppingNumbers(0, 21)\n   * Salida: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "arb": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * العثور على جميع الأرقام المتدرجة في النطاق [low, high] حيث يتم تعريف الرقم المتدرج على أنه رقم يكون فيه كل رقم إما واحد أكثر أو واحد أقل من الرقم المجاور.\n   *\n   * @param low الحد الأدنى للنطاق.\n   * @param high الحد الأقصى للنطاق.\n   * @return قائمة بالأرقام المتدرجة ضمن النطاق [low, high] مرتبة تصاعدياً.\n   *\n   * مثال:\n   * findSteppingNumbers(0, 21)\n   * الناتج: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "sw": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Tafuta namba zote za kuruka katika safu [low, high] ambapo namba ya kuruka inafafanuliwa kama namba ambapo kila tarakimu ni moja zaidi au moja pungufu ya tarakimu iliyo karibu nayo.\n   *\n   * @param low Kikomo cha chini cha safu.\n   * @param high Kikomo cha juu cha safu.\n   * @return Orodha ya namba za kuruka ndani ya safu [low, high] zilizopangwa kwa mpangilio wa kupanda.\n   *\n   * Mfano:\n   * findSteppingNumbers(0, 21)\n   * Matokeo: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "tr": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * [low, high] aralığındaki tüm stepping sayılarını bulun, burada bir stepping sayısı, her basamağın bitişik basamaktan bir fazla veya bir az olduğu bir sayı olarak tanımlanır.\n   *\n   * @param low Aralığın alt sınırı.\n   * @param high Aralığın üst sınırı.\n   * @return [low, high] aralığındaki stepping sayıların artan sırayla sıralanmış bir listesi.\n   *\n   * Örnek:\n   * findSteppingNumbers(0, 21)\n   * Çıktı: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "vi": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Tìm tất cả các số bước trong khoảng [low, high] nơi một số bước được định nghĩa là một số mà mỗi chữ số là lớn hơn một hoặc nhỏ hơn một so với chữ số liền kề.\n   *\n   * @param low Giới hạn dưới của khoảng.\n   * @param high Giới hạn trên của khoảng.\n   * @return Một danh sách các số bước trong khoảng [low, high] được sắp xếp theo thứ tự tăng dần.\n   *\n   * Ví dụ:\n   * findSteppingNumbers(0, 21)\n   * Đầu ra: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) "
    },
    "prompt_bertscore": {
      "es": "0.995860741489614",
      "arb": "0.9837581923731582",
      "sw": "0.9793625020408562",
      "tr": "0.9897284257359239",
      "vi": "0.9859469005417817"
    },
    "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "instruction": {
      "en": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8714799859286153",
      "sw": "0.9426256144380726",
      "tr": "0.8881111091022854",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "findSteppingNumbers",
    "signature": "public static List<Integer> findSteppingNumbers(int low, int high)",
    "docstring": {
      "en": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "es": "Encuentra todos los números escalonados en el rango [low, high] donde un número escalonado se define como un número donde cada dígito es uno más o uno menos que el dígito adyacente.\n\n@param low El límite inferior del rango.\n@param high El límite superior del rango.\n@return Una lista de números escalonados dentro del rango [low, high] ordenados en orden ascendente.\n\nEjemplo:\nfindSteppingNumbers(0, 21)\nSalida: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "arb": "ابحث عن جميع الأرقام المتدرجة في النطاق [low, high] حيث يتم تعريف الرقم المتدرج على أنه رقم يكون فيه كل رقم إما أكبر بواحد أو أقل بواحد من الرقم المجاور.\n\n@param low الحد الأدنى للنطاق.\n@param high الحد الأعلى للنطاق.\n@return قائمة بالأرقام المتدرجة داخل النطاق [low, high] مرتبة بترتيب تصاعدي.\n\nمثال:\nfindSteppingNumbers(0, 21)\nالناتج: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "sw": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low Kiwango cha chini cha safu.\n@param high Kiwango cha juu cha safu.\n@return Orodha ya namba za kuruka ndani ya safu [low, high] zilizopangwa kwa mpangilio wa kupanda.\n\nMfano:\nfindSteppingNumbers(0, 21)\nMatokeo: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "tr": "Belirtilen aralıkta [low, high] tüm adım sayıları bulun, burada bir adım sayısı, her bir basamağın bitişik basamaktan bir fazla veya bir az olduğu bir sayı olarak tanımlanır.\n\n@param low Aralığın alt sınırı.\n@param high Aralığın üst sınırı.\n@return [low, high] aralığında artan sırayla sıralanmış adım sayılarının bir listesi.\n\nÖrnek:\nfindSteppingNumbers(0, 21)\nÇıktı: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "vi": "Tìm tất cả các số bước trong phạm vi [low, high] nơi một số bước được định nghĩa là một số mà mỗi chữ số là một hơn hoặc một ít hơn chữ số liền kề.\n\n@param low Giới hạn dưới của phạm vi.\n@param high Giới hạn trên của phạm vi.\n@return Một danh sách các số bước trong phạm vi [low, high] được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\nfindSteppingNumbers(0, 21)\nĐầu ra: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]"
    },
    "docstring_bertscore": {
      "es": "0.9941648352963381",
      "arb": "0.9999996027392379",
      "sw": "0.9924538331941035",
      "tr": "0.9778596645779462",
      "vi": "0.9764762039740382"
    }
  },
  {
    "task_id": "Java/37",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "es": "public class Solution {\n\n  /**\n   * Calcular el número de veces que el dígito 1 aparece en todos los enteros no negativos menores o iguales a n.\n   *\n   * @param n Un entero que representa el límite superior.\n   * @return El número de veces que aparece el dígito 1.\n   *\n   * Ejemplo:\n   * countDigitOne(13)\n   * Salida: 6\n   *\n   * Ejemplo:\n   * countDigitOne(0)\n   * Salida: 0\n   */\n  public static int countDigitOne(int n) ",
      "arb": "public class Solution {\n\n  /**\n   * حساب عدد المرات التي يظهر فيها الرقم 1 في جميع الأعداد الصحيحة غير السالبة الأقل من أو تساوي n.\n   *\n   * @param n عدد صحيح يمثل الحد الأعلى.\n   * @return عدد المرات التي يظهر فيها الرقم 1.\n   *\n   * مثال:\n   * countDigitOne(13)\n   * الناتج: 6\n   *\n   * مثال:\n   * countDigitOne(0)\n   * الناتج: 0\n   */\n  public static int countDigitOne(int n) ",
      "sw": "public class Solution {\n\n  /**\n   * Hesabu idadi ya mara ambazo tarakimu 1 inaonekana katika nambari zote zisizo na alama hasi chini au sawa na n.\n   *\n   * @param n Nambari nzima inayowakilisha kikomo cha juu.\n   * @return Idadi ya mara ambazo tarakimu 1 inaonekana.\n   *\n   * Mfano:\n   * countDigitOne(13)\n   * Matokeo: 6\n   *\n   * Mfano:\n   * countDigitOne(0)\n   * Matokeo: 0\n   */\n  public static int countDigitOne(int n) ",
      "tr": "public class Solution {\n\n  /**\n   * Rakam 1'in, n'e eşit veya daha küçük olan tüm negatif olmayan tamsayılarda kaç kez göründüğünü hesaplayın.\n   *\n   * @param n Üst sınırı temsil eden bir tamsayı.\n   * @return Rakam 1'in kaç kez göründüğü.\n   *\n   * Örnek:\n   * countDigitOne(13)\n   * Çıktı: 6\n   *\n   * Örnek:\n   * countDigitOne(0)\n   * Çıktı: 0\n   */\n  public static int countDigitOne(int n) ",
      "vi": "public class Solution {\n\n  /**\n   * Tính số lần chữ số 1 xuất hiện trong tất cả các số nguyên không âm nhỏ hơn hoặc bằng n.\n   *\n   * @param n Một số nguyên đại diện cho giới hạn trên.\n   * @return Số lần chữ số 1 xuất hiện.\n   *\n   * Ví dụ:\n   * countDigitOne(13)\n   * Đầu ra: 6\n   *\n   * Ví dụ:\n   * countDigitOne(0)\n   * Đầu ra: 0\n   */\n  public static int countDigitOne(int n) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.994170198316626",
      "tr": "0.9860005307446611",
      "vi": "1"
    },
    "canonical_solution": "  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }",
    "instruction": {
      "en": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8680172624960341",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "countDigitOne",
    "signature": "public static int countDigitOne(int n)",
    "docstring": {
      "en": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0",
      "es": "Calcular el número de veces que el dígito 1 aparece en todos los enteros no negativos menores o iguales a n.\n   \n    @param n Un entero que representa el límite superior.\n    @return El número de veces que aparece el dígito 1.\n   \n    Ejemplo:\n    countDigitOne(13)\n    Salida: 6\n   \n    Ejemplo:\n    countDigitOne(0)\n    Salida: 0",
      "arb": "احسب عدد المرات التي يظهر فيها الرقم 1 في جميع الأعداد الصحيحة غير السالبة الأقل من أو تساوي n.\n\n    @param n عدد صحيح يمثل الحد الأعلى.\n    @return عدد المرات التي يظهر فيها الرقم 1.\n\n    مثال:\n    countDigitOne(13)\n    الناتج: 6\n\n    مثال:\n    countDigitOne(0)\n    الناتج: 0",
      "sw": "Hesabu idadi ya mara ambazo tarakimu 1 inaonekana katika nambari zote zisizo na alama hasi ambazo ni ndogo au sawa na n.\n\n    @param n Nambari nzima inayowakilisha kikomo cha juu.\n    @return Idadi ya mara ambazo tarakimu 1 inaonekana.\n\n    Mfano:\n    countDigitOne(13)\n    Matokeo: 6\n\n    Mfano:\n    countDigitOne(0)\n    Matokeo: 0",
      "tr": "Tüm negatif olmayan ve n'ye eşit veya daha küçük olan tamsayılar içinde rakam olarak 1'in kaç kez göründüğünü hesaplayın.\n   \n    @param n Üst sınırı temsil eden bir tamsayı.\n    @return Rakam olarak 1'in kaç kez göründüğü.\n   \n    Örnek:\n    countDigitOne(13)\n    Çıktı: 6\n   \n    Örnek:\n    countDigitOne(0)\n    Çıktı: 0",
      "vi": "Tính số lần chữ số 1 xuất hiện trong tất cả các số nguyên không âm nhỏ hơn hoặc bằng n.\n   \n    @param n Một số nguyên đại diện cho giới hạn trên.\n    @return Số lần chữ số 1 xuất hiện.\n   \n    Ví dụ:\n    countDigitOne(13)\n    Đầu ra: 6\n   \n    Ví dụ:\n    countDigitOne(0)\n    Đầu ra: 0"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9705800597433986",
      "tr": "0.951464269133363",
      "vi": "0.9871740390358152"
    }
  },
  {
    "task_id": "Java/38",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "es": "public class Solution {\n\n  /**\n   * Dado un entero n, determina si es una potencia de dos.\n   * Si lo es, devuelve true; de lo contrario, devuelve false.\n   * Un número n es una potencia de dos si existe un entero x tal que n == 2^x.\n   *\n   * @param n El entero a verificar.\n   * @return True si n es una potencia de dos, false de lo contrario.\n   *\n   * Ejemplo:\n   * isPowerOfTwo(1)\n   * Salida: true\n   *\n   * Ejemplo:\n   * isPowerOfTwo(16)\n   * Salida: true\n   *\n   * Ejemplo:\n   * isPowerOfTwo(3)\n   * Salida: false\n   *\n   * Ejemplo:\n   * isPowerOfTwo(4)\n   * Salida: true\n   *\n   * Ejemplo:\n   * isPowerOfTwo(5)\n   * Salida: false\n   */\n  public static boolean isPowerOfTwo(int n)",
      "arb": "public class Solution {\n\n  /**\n   * بالنظر إلى عدد صحيح n، حدد ما إذا كان قوة للعدد اثنين.\n   * إذا كان كذلك، أعد true؛ وإلا، أعد false.\n   * يكون العدد n قوة للعدد اثنين إذا كان هناك عدد صحيح x بحيث n == 2^x.\n   *\n   * @param n العدد الصحيح الذي سيتم التحقق منه.\n   * @return True إذا كان n قوة للعدد اثنين، false خلاف ذلك.\n   *\n   * مثال:\n   * isPowerOfTwo(1)\n   * الناتج: true\n   *\n   * مثال:\n   * isPowerOfTwo(16)\n   * الناتج: true\n   *\n   * مثال:\n   * isPowerOfTwo(3)\n   * الناتج: false\n   *\n   * مثال:\n   * isPowerOfTwo(4)\n   * الناتج: true\n   *\n   * مثال:\n   * isPowerOfTwo(5)\n   * الناتج: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "sw": "public class Solution {\n\n  /**\n   * Ukipewa nambari nzima n, amua kama ni nguvu ya mbili.\n   * Ikiwa ni, rudisha kweli; vinginevyo, rudisha uongo.\n   * Nambari n ni nguvu ya mbili ikiwa kuna nambari nzima x kama n == 2^x.\n   *\n   * @param n Nambari nzima itakayochunguzwa.\n   * @return Kweli ikiwa n ni nguvu ya mbili, uongo vinginevyo.\n   *\n   * Mfano:\n   * isPowerOfTwo(1)\n   * Matokeo: true\n   *\n   * Mfano:\n   * isPowerOfTwo(16)\n   * Matokeo: true\n   *\n   * Mfano:\n   * isPowerOfTwo(3)\n   * Matokeo: false\n   *\n   * Mfano:\n   * isPowerOfTwo(4)\n   * Matokeo: true\n   *\n   * Mfano:\n   * isPowerOfTwo(5)\n   * Matokeo: false\n   */\n  public static boolean isPowerOfTwo(int n)",
      "tr": "public class Solution {\n\n  /**\n   * Verilen bir tamsayı n için, bunun iki'nin kuvveti olup olmadığını belirleyin.\n   * Eğer öyleyse, true döndürün; aksi takdirde, false döndürün.\n   * Bir sayı n, eğer n == 2^x olacak şekilde bir tamsayı x varsa, iki'nin kuvvetidir.\n   *\n   * @param n Kontrol edilecek tamsayı.\n   * @return n iki'nin kuvveti ise true, aksi takdirde false.\n   *\n   * Örnek:\n   * isPowerOfTwo(1)\n   * Çıktı: true\n   *\n   * Örnek:\n   * isPowerOfTwo(16)\n   * Çıktı: true\n   *\n   * Örnek:\n   * isPowerOfTwo(3)\n   * Çıktı: false\n   *\n   * Örnek:\n   * isPowerOfTwo(4)\n   * Çıktı: true\n   *\n   * Örnek:\n   * isPowerOfTwo(5)\n   * Çıktı: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "vi": "public class Solution {\n\n  /**\n   * Cho trước một số nguyên n, xác định xem nó có phải là lũy thừa của hai hay không.\n   * Nếu đúng, trả về true; ngược lại, trả về false.\n   * Một số n là lũy thừa của hai nếu tồn tại một số nguyên x sao cho n == 2^x.\n   *\n   * @param n Số nguyên cần kiểm tra.\n   * @return True nếu n là lũy thừa của hai, false nếu không.\n   *\n   * Ví dụ:\n   * isPowerOfTwo(1)\n   * Đầu ra: true\n   *\n   * Ví dụ:\n   * isPowerOfTwo(16)\n   * Đầu ra: true\n   *\n   * Ví dụ:\n   * isPowerOfTwo(3)\n   * Đầu ra: false\n   *\n   * Ví dụ:\n   * isPowerOfTwo(4)\n   * Đầu ra: true\n   *\n   * Ví dụ:\n   * isPowerOfTwo(5)\n   * Đầu ra: false\n   */\n  public static boolean isPowerOfTwo(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9931345395099102",
      "arb": "0.9967112767812053",
      "sw": "0.9981984224440136",
      "tr": "0.9791759881130644",
      "vi": "0.9893623499436766"
    },
    "canonical_solution": "  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }",
    "instruction": {
      "en": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nJava kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.8707023479868636",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert isPowerOfTwo(1024) == true; // 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; // 65536 is 2^16\n    assert isPowerOfTwo(14) == false; // 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isPowerOfTwo",
    "signature": "public static boolean isPowerOfTwo(int n)",
    "docstring": {
      "en": "Given an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false",
      "es": "Dado un entero n, determina si es una potencia de dos.  \n    Si lo es, devuelve true; de lo contrario, devuelve false.  \n    Un número n es una potencia de dos si existe un entero x tal que n == 2^x.\n   \n    @param n El entero a verificar.\n    @return True si n es una potencia de dos, false de lo contrario.\n   \n    Ejemplo:\n    isPowerOfTwo(1)\n    Salida: true\n   \n    Ejemplo:\n    isPowerOfTwo(16)\n    Salida: true\n   \n    Ejemplo:\n    isPowerOfTwo(3)\n    Salida: false\n   \n    Ejemplo:\n    isPowerOfTwo(4)\n    Salida: true\n   \n    Ejemplo:\n    isPowerOfTwo(5)\n    Salida: false",
      "arb": "معطى عدد صحيح n، حدد ما إذا كان قوة للعدد اثنين.\n    إذا كان كذلك، أعد true؛ وإلا، أعد false.\n    يكون العدد n قوة للعدد اثنين إذا وجد عدد صحيح x بحيث n == 2^x.\n   \n    @param n العدد الصحيح الذي سيتم التحقق منه.\n    @return True إذا كان n قوة للعدد اثنين، false خلاف ذلك.\n   \n    مثال:\n    isPowerOfTwo(1)\n    الناتج: true\n   \n    مثال:\n    isPowerOfTwo(16)\n    الناتج: true\n   \n    مثال:\n    isPowerOfTwo(3)\n    الناتج: false\n   \n    مثال:\n    isPowerOfTwo(4)\n    الناتج: true\n   \n    مثال:\n    isPowerOfTwo(5)\n    الناتج: false",
      "sw": "Ukipewa nambari nzima n, amua kama ni nguvu ya mbili.  \n    Ikiwa ni, rudisha kweli; vinginevyo, rudisha si kweli.  \n    Nambari n ni nguvu ya mbili ikiwa kuna nambari x kama hiyo kwamba n == 2^x.  \n   \n    @param n Nambari nzima inayopaswa kukaguliwa.  \n    @return Kweli ikiwa n ni nguvu ya mbili, si kweli vinginevyo.  \n   \n    Mfano:  \n    isPowerOfTwo(1)  \n    Matokeo: true  \n   \n    Mfano:  \n    isPowerOfTwo(16)  \n    Matokeo: true  \n   \n    Mfano:  \n    isPowerOfTwo(3)  \n    Matokeo: false  \n   \n    Mfano:  \n    isPowerOfTwo(4)  \n    Matokeo: true  \n   \n    Mfano:  \n    isPowerOfTwo(5)  \n    Matokeo: false  ",
      "tr": "Verilen bir tamsayı n için, bunun iki'nin kuvveti olup olmadığını belirleyin.\n    Eğer öyleyse, true döndürün; aksi takdirde, false döndürün.\n    Bir sayı n, eğer n == 2^x olacak şekilde bir tamsayı x varsa, iki'nin kuvvetidir.\n   \n    @param n Kontrol edilecek tamsayı.\n    @return n iki'nin kuvveti ise True, aksi takdirde false.\n   \n    Örnek:\n    isPowerOfTwo(1)\n    Çıktı: true\n   \n    Örnek:\n    isPowerOfTwo(16)\n    Çıktı: true\n   \n    Örnek:\n    isPowerOfTwo(3)\n    Çıktı: false\n   \n    Örnek:\n    isPowerOfTwo(4)\n    Çıktı: true\n   \n    Örnek:\n    isPowerOfTwo(5)\n    Çıktı: false",
      "vi": "Cho trước một số nguyên n, xác định xem nó có phải là lũy thừa của hai hay không.  \nNếu đúng, trả về true; nếu không, trả về false. \nMột số n là lũy thừa của hai nếu tồn tại một số nguyên x sao cho n == 2^x.  \n@param n Số nguyên cần kiểm tra. \n@return True nếu n là lũy thừa của hai, false nếu không. \nVí dụ:  \nisPowerOfTwo(1)  \nKết quả: true  \nVí dụ:  \nisPowerOfTwo(16)  \nKết quả: true   \nVí dụ:  \nisPowerOfTwo(3)  \nKết quả: false  \nVí dụ:  \nisPowerOfTwo(4)  \nKết quả: true  \nVí dụ:  \nisPowerOfTwo(5) \nKết quả: false  "
    },
    "docstring_bertscore": {
      "es": "0.9959245018419262",
      "arb": "0.9915037840816137",
      "sw": "0.9924715112980157",
      "tr": "0.988237307465495",
      "vi": "1"
    }
  },
  {
    "task_id": "Java/39",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "es": "public class Solution {\n\n  /**\n   * Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado sea un solo dígito. Devuelve el resultado.\n   *\n   * @param num El número entero no negativo sobre el cual realizar la operación.\n   * @return El resultado de un solo dígito después de sumar repetidamente todos los dígitos.\n   *\n   * Ejemplo:\n   * addDigits(38)\n   * Salida: 2\n   */\n  public static int addDigits(int num) ",
      "arb": "public class Solution {\n\n  /**\n   * بالنظر إلى عدد صحيح غير سالب، قم بإضافة جميع أرقامه بشكل متكرر حتى يصبح الناتج رقمًا فرديًا. أعد النتيجة.\n   *\n   * @param num العدد الصحيح غير السالب الذي سيتم تنفيذ العملية عليه.\n   * @return النتيجة كرقم فردي بعد إضافة جميع الأرقام بشكل متكرر.\n   *\n   * مثال:\n   * addDigits(38)\n   * الناتج: 2\n   */\n  public static int addDigits(int num) ",
      "sw": "public class Solution {\n\n  /**\n   * Ukipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe tarakimu moja. Rudisha matokeo.\n   *\n   * @param num Nambari isiyo hasi ya kufanya operesheni.\n   * @return Matokeo ya tarakimu moja baada ya kuongeza mara kwa mara tarakimu zote.\n   *\n   * Mfano:\n   * addDigits(38)\n   * Matokeo: 2\n   */\n  public static int addDigits(int num) ",
      "tr": "public class Solution {\n\n  /**\n   * Negatif olmayan bir tamsayı verildiğinde, sonucu tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın. Sonucu döndürün.\n   *\n   * @param num Üzerinde işlem yapılacak negatif olmayan tamsayı.\n   * @return Tüm basamaklar tekrar tekrar toplandıktan sonra elde edilen tek basamaklı sonuç.\n   *\n   * Örnek:\n   * addDigits(38)\n   * Çıktı: 2\n   */\n  public static int addDigits(int num) ",
      "vi": "public class Solution {\n\n  /**\n   * Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả là một chữ số duy nhất. Trả về kết quả.\n   *\n   * @param num Số nguyên không âm để thực hiện phép toán.\n   * @return Kết quả là một chữ số sau khi liên tục cộng tất cả các chữ số.\n   *\n   * Ví dụ:\n   * addDigits(38)\n   * Đầu ra: 2\n   */\n  public static int addDigits(int num) "
    },
    "prompt_bertscore": {
      "es": "0.9666819385155889",
      "arb": "0.9675362477844199",
      "sw": "0.9667693358832442",
      "tr": "0.9471003596620265",
      "vi": "0.9735853374084564"
    },
    "canonical_solution": "  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }",
    "instruction": {
      "en": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Java باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nJava kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9306920997758775",
      "sw": "0.9149216420432316",
      "tr": "0.8720578017070457",
      "vi": "0.9193288529376337"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "addDigits",
    "signature": "public static int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2",
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado sea un solo dígito. Devuelve el resultado.\n\n@param num El número entero no negativo sobre el cual realizar la operación.\n@return El resultado de un solo dígito después de sumar repetidamente todos los dígitos.\n\nEjemplo:\naddDigits(38)\nSalida: 2",
      "arb": "إعطاء عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يصبح الناتج رقمًا واحدًا. أعد النتيجة.\n\n@param num العدد الصحيح غير السالب الذي سيتم تنفيذ العملية عليه.\n@return النتيجة ذات الرقم الواحد بعد إضافة جميع الأرقام بشكل متكرر.\n\nمثال:\naddDigits(38)\nالناتج: 2",
      "sw": "Kwa kupewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe tarakimu moja. Rudisha matokeo.\n\n@param num Nambari isiyo hasi ya kutekeleza operesheni.\n@return Matokeo ya tarakimu moja baada ya kuongeza mara kwa mara tarakimu zote.\n\nMfano:\naddDigits(38)\nMatokeo: 2",
      "tr": "Verilen negatif olmayan bir tamsayı num için, sonucu tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın. Sonucu döndürün.\n\n@param num İşlemin gerçekleştirileceği negatif olmayan tamsayı.\n@return Tüm basamakları tekrar tekrar topladıktan sonra elde edilen tek basamaklı sonuç.\n\nÖrnek:\naddDigits(38)\nÇıktı: 2",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả là một chữ số duy nhất. Trả về kết quả.\n\n@param num Số nguyên không âm để thực hiện phép toán.\n@return Kết quả là một chữ số sau khi liên tục cộng tất cả các chữ số.\n\nVí dụ:\naddDigits(38)\nĐầu ra: 2"
    },
    "docstring_bertscore": {
      "es": "0.9583452227931736",
      "arb": "0.990185076981923",
      "sw": "0.9566922207622013",
      "tr": "0.9540746696009235",
      "vi": "0.9609925685116066"
    }
  },
  {
    "task_id": "Java/40",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "es": "public class Solution {\n\n  /**\n   * Dado un matriz binaria mat de tamaño m x n, devuelve la longitud de la línea continua más larga de 1s en la matriz.\n   * La línea podría ser horizontal, vertical, diagonal o anti-diagonal.\n   *\n   * @param mat La matriz binaria.\n   * @return La longitud de la línea continua más larga de 1s.\n   *\n   * Ejemplo:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Salida: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "arb": "public class Solution {\n\n  /**\n   * بالنظر إلى مصفوفة ثنائية mat بحجم m x n، أعد طول أطول خط متصل من الأرقام 1 في المصفوفة.\n   * يمكن أن يكون الخط أفقيًا، عموديًا، قطريًا، أو مضادًا للقطري.\n   *\n   * @param mat المصفوفة الثنائية.\n   * @return طول أطول خط متصل من الأرقام 1.\n   *\n   * مثال:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * الناتج: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "sw": "public class Solution {\n\n  /**\n   * Ukipewa matrix ya binary mat ya ukubwa m x n, rudisha urefu wa mstari mrefu zaidi wa 1s unaoendelea kwenye matrix.\n   * Mstari unaweza kuwa wa mlalo, wima, diagonal, au anti-diagonal.\n   *\n   * @param mat Matrix ya binary.\n   * @return Urefu wa mstari mrefu zaidi wa 1s unaoendelea.\n   *\n   * Mfano:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Matokeo: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "tr": "public class Solution {\n\n  /**\n   * m x n boyutunda bir ikili matris olan mat verildiğinde, matristeki en uzun kesintisiz 1'ler çizgisinin uzunluğunu döndürün.\n   * Çizgi yatay, dikey, çapraz veya ters çapraz olabilir.\n   *\n   * @param mat İkili matris.\n   * @return En uzun kesintisiz 1'ler çizgisinin uzunluğu.\n   *\n   * Örnek:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Çıktı: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "vi": "public class Solution {\n\n  /**\n   * Cho một ma trận nhị phân mat kích thước m x n, trả về độ dài của dòng liên tục dài nhất của các số 1 trong ma trận.\n   * Dòng có thể là ngang, dọc, chéo, hoặc chéo ngược.\n   *\n   * @param mat Ma trận nhị phân.\n   * @return Độ dài của dòng liên tục dài nhất của các số 1.\n   *\n   * Ví dụ:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Đầu ra: 3\n   */\n  public static int longestLine(int[][] mat) "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9837661375883996",
      "sw": "0.9712776496415931",
      "tr": "0.9862025378421736",
      "vi": "0.9851704543823163"
    },
    "canonical_solution": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }",
    "instruction": {
      "en": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yapılmalıdır.",
      "vi": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8939142943146007",
      "sw": "0.9149216420432316",
      "tr": "0.8655566293357738",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "longestLine",
    "signature": "public static int longestLine(int[][] mat)",
    "docstring": {
      "en": "Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "es": "Dada una matriz binaria mat de tamaño m x n, devuelve la longitud de la línea continua más larga de 1s en la matriz.\n    La línea podría ser horizontal, vertical, diagonal o anti-diagonal.\n   \n    @param mat La matriz binaria.\n    @return La longitud de la línea continua más larga de 1s.\n   \n    Ejemplo:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Salida: 3",
      "arb": "بالنظر إلى مصفوفة ثنائية mat بحجم m x n، أعد طول أطول خط متواصل من الأرقام 1 في المصفوفة. \n    يمكن أن يكون الخط أفقيًا، عموديًا، قطريًا، أو قطريًا عكسيًا.\n   \n    @param mat المصفوفة الثنائية.\n    @return طول أطول خط متواصل من الأرقام 1.\n   \n    مثال:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    الناتج: 3",
      "sw": "Kutolewa matrixi ya binary `mat` ya ukubwa m x n, rudisha urefu wa mstari mrefu zaidi wa 1s unaoendelea katika matrixi.\n    Mstari unaweza kuwa wa mlalo, wima, diagonal, au anti-diagonal.\n   \n    @param mat Matrixi ya binary.\n    @return Urefu wa mstari mrefu zaidi wa 1s unaoendelea.\n   \n    Mfano:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Matokeo: 3",
      "tr": "Verilen m x n boyutunda bir ikili matris olan mat için, matris içindeki en uzun sürekli 1'ler çizgisinin uzunluğunu döndürün. Çizgi yatay, dikey, çapraz veya ters çapraz olabilir.\n\n@param mat İkili matris.\n@return En uzun sürekli 1'ler çizgisinin uzunluğu.\n\nÖrnek:\nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\nÇıktı: 3",
      "vi": "Cho một ma trận nhị phân `mat` kích thước m x n, trả về độ dài của dòng liên tục dài nhất của các số 1 trong ma trận. \nDòng này có thể là ngang, dọc, chéo, hoặc chéo ngược.\n\n@param mat Ma trận nhị phân.\n@return Độ dài của dòng liên tục dài nhất của các số 1.\n\nVí dụ:\nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\nĐầu ra: 3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.998843971182377",
      "sw": "0.9666730001484424",
      "tr": "0.9622107686384935",
      "vi": "0.9730462545543277"
    }
  },
  {
    "task_id": "Java/41",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "es": "public class Solution {\n\n  /**\n   * Dado un entero n, añade un punto ('.') como separador de miles cada tres dígitos y devuelve el resultado como una cadena.\n   *\n   * @param n El entero al que se le añadirán separadores de miles.\n   * @return La cadena con separadores de miles añadidos.\n   *\n   * Ejemplo:\n   * addThousandSeparator(987)\n   * Salida: \"987\"\n   *\n   * Ejemplo:\n   * addThousandSeparator(1234)\n   * Salida: \"1.234\"\n   *\n   * Ejemplo:\n   * addThousandSeparator(123456789)\n   * Salida: \"123.456.789\"\n   *\n   * Ejemplo:\n   * addThousandSeparator(0)\n   * Salida: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "arb": "public class Solution {\n\n  /**\n   * بالنظر إلى عدد صحيح n، أضف نقطة ('.') كمحدد للآلاف كل ثلاثة أرقام وأعد النتيجة كسلسلة نصية.\n   *\n   * @param n العدد الصحيح الذي سيتم إضافة محددات الآلاف إليه.\n   * @return السلسلة النصية مع إضافة محددات الآلاف.\n   *\n   * مثال:\n   * addThousandSeparator(987)\n   * الناتج: \"987\"\n   *\n   * مثال:\n   * addThousandSeparator(1234)\n   * الناتج: \"1.234\"\n   *\n   * مثال:\n   * addThousandSeparator(123456789)\n   * الناتج: \"123.456.789\"\n   *\n   * مثال:\n   * addThousandSeparator(0)\n   * الناتج: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "sw": "public class Solution {\n\n  /**\n   * Ukipewa nambari nzima n, ongeza nukta ('.') kama kizuizi cha maelfu kila tarakimu tatu na urejeshe matokeo kama kamba.\n   *\n   * @param n Nambari nzima ya kuongeza vizuizi vya maelfu.\n   * @return Kamba yenye vizuizi vya maelfu vilivyoongezwa.\n   *\n   * Mfano:\n   * addThousandSeparator(987)\n   * Matokeo: \"987\"\n   *\n   * Mfano:\n   * addThousandSeparator(1234)\n   * Matokeo: \"1.234\"\n   *\n   * Mfano:\n   * addThousandSeparator(123456789)\n   * Matokeo: \"123.456.789\"\n   *\n   * Mfano:\n   * addThousandSeparator(0)\n   * Matokeo: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "tr": "public class Solution {\n\n  /**\n   * Verilen bir tamsayı n için, her üç basamakta bir nokta ('.') ekleyerek sonucu bir string olarak döndür.\n   *\n   * @param n Binlik ayırıcılar eklemek için tamsayı.\n   * @return Binlik ayırıcılar eklenmiş string.\n   *\n   * Örnek:\n   * addThousandSeparator(987)\n   * Çıktı: \"987\"\n   *\n   * Örnek:\n   * addThousandSeparator(1234)\n   * Çıktı: \"1.234\"\n   *\n   * Örnek:\n   * addThousandSeparator(123456789)\n   * Çıktı: \"123.456.789\"\n   *\n   * Örnek:\n   * addThousandSeparator(0)\n   * Çıktı: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "vi": "public class Solution {\n\n  /**\n   * Cho một số nguyên n, thêm một dấu chấm ('.') như là dấu phân cách hàng nghìn mỗi ba chữ số và trả về kết quả dưới dạng chuỗi.\n   *\n   * @param n Số nguyên cần thêm dấu phân cách hàng nghìn.\n   * @return Chuỗi với dấu phân cách hàng nghìn đã được thêm vào.\n   *\n   * Ví dụ:\n   * addThousandSeparator(987)\n   * Đầu ra: \"987\"\n   *\n   * Ví dụ:\n   * addThousandSeparator(1234)\n   * Đầu ra: \"1.234\"\n   *\n   * Ví dụ:\n   * addThousandSeparator(123456789)\n   * Đầu ra: \"123.456.789\"\n   *\n   * Ví dụ:\n   * addThousandSeparator(0)\n   * Đầu ra: \"0\"\n   */\n  public static String addThousandSeparator(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9842241792470661",
      "arb": "0.9842241792470661",
      "sw": "0.9981831279046739",
      "tr": "0.9585762299263172",
      "vi": "0.9735615017627323"
    },
    "canonical_solution": "  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }",
    "instruction": {
      "en": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8652195535791577",
      "sw": "0.9426256144380726",
      "tr": "0.8475368811682888",
      "vi": "0.9196422916789067"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "addThousandSeparator",
    "signature": "public static String addThousandSeparator(int n)",
    "docstring": {
      "en": "Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "es": "Dado un entero n, agrega un punto ('.') como separador de miles cada tres dígitos y devuelve el resultado como una cadena.\n\n    @param n El entero al que se le agregarán separadores de miles.\n    @return La cadena con los separadores de miles añadidos.\n   \n    Ejemplo:\n    addThousandSeparator(987)\n    Salida: \"987\"\n   \n    Ejemplo:\n    addThousandSeparator(1234)\n    Salida: \"1.234\"\n   \n    Ejemplo:\n    addThousandSeparator(123456789)\n    Salida: \"123.456.789\"\n   \n    Ejemplo:\n    addThousandSeparator(0)\n    Salida: \"0\"",
      "arb": "بالنظر إلى عدد صحيح n، أضف نقطة ('.') كمحدد للآلاف كل ثلاثة أرقام وأعد النتيجة كسلسلة نصية.\n\n    @param n العدد الصحيح لإضافة فواصل الآلاف إليه.\n    @return السلسلة النصية مع إضافة فواصل الآلاف.\n   \n    مثال:\n    addThousandSeparator(987)\n    الناتج: \"987\"\n   \n    مثال:\n    addThousandSeparator(1234)\n    الناتج: \"1.234\"\n   \n    مثال:\n    addThousandSeparator(123456789)\n    الناتج: \"123.456.789\"\n   \n    مثال:\n    addThousandSeparator(0)\n    الناتج: \"0\"",
      "sw": "Ukipewa nambari nzima n, ongeza nukta ('.') kama kitenganishi cha maelfu kila tarakimu tatu na urudishe matokeo kama kamba.\n\n    @param n Nambari nzima ya kuongeza vitenganishi vya maelfu.\n    @return Kamba yenye vitenganishi vya maelfu vilivyoongezwa.\n   \n    Mfano:\n    addThousandSeparator(987)\n    Matokeo: \"987\"\n   \n    Mfano:\n    addThousandSeparator(1234)\n    Matokeo: \"1.234\"\n   \n    Mfano:\n    addThousandSeparator(123456789)\n    Matokeo: \"123.456.789\"\n   \n    Mfano:\n    addThousandSeparator(0)\n    Matokeo: \"0\"",
      "tr": "Verilen bir tamsayı n için, her üç basamakta bir binlik ayırıcı olarak bir nokta ('.') ekleyin ve sonucu bir string olarak döndürün.\n\n    @param n Binlik ayırıcılar eklenecek tamsayı.\n    @return Binlik ayırıcılar eklenmiş string.\n\n    Örnek:\n    addThousandSeparator(987)\n    Çıktı: \"987\"\n\n    Örnek:\n    addThousandSeparator(1234)\n    Çıktı: \"1.234\"\n\n    Örnek:\n    addThousandSeparator(123456789)\n    Çıktı: \"123.456.789\"\n\n    Örnek:\n    addThousandSeparator(0)\n    Çıktı: \"0\"",
      "vi": "Cho một số nguyên n, thêm một dấu chấm ('.') làm dấu phân cách hàng nghìn mỗi ba chữ số và trả về kết quả dưới dạng chuỗi.\n\n    @param n Số nguyên cần thêm dấu phân cách hàng nghìn.\n    @return Chuỗi với dấu phân cách hàng nghìn đã được thêm vào.\n\n    Ví dụ:\n    addThousandSeparator(987)\n    Đầu ra: \"987\"\n\n    Ví dụ:\n    addThousandSeparator(1234)\n    Đầu ra: \"1.234\"\n\n    Ví dụ:\n    addThousandSeparator(123456789)\n    Đầu ra: \"123.456.789\"\n\n    Ví dụ:\n    addThousandSeparator(0)\n    Đầu ra: \"0\""
    },
    "docstring_bertscore": {
      "es": "0.9767574645935836",
      "arb": "1",
      "sw": "0.9759252032970475",
      "tr": "0.9770083347648306",
      "vi": "0.996999290833706"
    }
  },
  {
    "task_id": "Java/42",
    "prompt": {
      "en": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "es": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Dado un array de enteros no negativos A, si la suma de cada par de elementos adyacentes en el array es un cuadrado perfecto, entonces el array se considera un array cuadrado.\n   * Devuelve el número de permutaciones cuadradas de A. Dos permutaciones A1 y A2 se consideran diferentes si existe un índice i tal que A1[i] != A2[i].\n   *\n   * @param A El array de enteros no negativos de entrada.\n   * @return El número de permutaciones cuadradas de A.\n   *\n   * Ejemplo:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Ejemplo:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "arb": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * بالنظر إلى مصفوفة أعداد صحيحة غير سالبة A، إذا كان مجموع كل زوج من العناصر المتجاورة في المصفوفة مربعًا كاملاً، فإن المصفوفة تعتبر مصفوفة مربعة.\n   * قم بإرجاع عدد التباديل المربعة لـ A. يعتبر التباديلان A1 و A2 مختلفين إذا كان هناك فهرس i بحيث A1[i] != A2[i].\n   *\n   * @param A مصفوفة الأعداد الصحيحة غير السالبة المدخلة.\n   * @return عدد التباديل المربعة لـ A.\n   *\n   * مثال:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * مثال:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "sw": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Ukipewa safu ya nambari zisizo hasi A, ikiwa jumla ya kila jozi ya vipengele vya karibu katika safu ni mraba kamili, basi safu inachukuliwa kuwa safu ya mraba.\n   * Rudisha idadi ya upangaji wa mraba wa A. Upangaji mbili A1 na A2 zinachukuliwa kuwa tofauti ikiwa kuna faharasa i kama hiyo kwamba A1[i] != A2[i].\n   *\n   * @param A Safu ya ingizo ya nambari zisizo hasi.\n   * @return Idadi ya upangaji wa mraba wa A.\n   *\n   * Mfano:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Mfano:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "tr": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Verilen negatif olmayan bir tamsayı dizisi A için, dizideki bitişik elemanların her çiftinin toplamı mükemmel bir kare ise, dizi kare dizi olarak kabul edilir.\n   * A'nın kare permütasyonlarının sayısını döndürün. İki permütasyon A1 ve A2, eğer A1[i] != A2[i] olacak şekilde bir i indeksi varsa farklı kabul edilir.\n   *\n   * @param A Girdi negatif olmayan tamsayı dizisi.\n   * @return A'nın kare permütasyonlarının sayısı.\n   *\n   * Örnek:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Çıktı: 2\n   *\n   * Örnek:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Çıktı: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "vi": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Cho một mảng số nguyên không âm A, nếu tổng của mỗi cặp phần tử liền kề trong mảng là một số chính phương, thì mảng được coi là một mảng chính phương.\n   * Trả về số lượng hoán vị chính phương của A. Hai hoán vị A1 và A2 được coi là khác nhau nếu tồn tại chỉ số i sao cho A1[i] != A2[i].\n   *\n   * @param A Mảng số nguyên không âm đầu vào.\n   * @return Số lượng hoán vị chính phương của A.\n   *\n   * Ví dụ:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Ví dụ:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) "
    },
    "prompt_bertscore": {
      "es": "0.9888419383453652",
      "arb": "0.9930672038107393",
      "sw": "0.9805093938609516",
      "tr": "0.9867364563063954",
      "vi": "0.9851231803516299"
    },
    "canonical_solution": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }",
    "instruction": {
      "en": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9426256144380726",
      "tr": "0.8412671131909225",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "squarePermutations",
    "signature": "public static int squarePermutations(int[] A)",
    "docstring": {
      "en": "Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "es": "Dada una matriz de enteros no negativos A, si la suma de cada par de elementos adyacentes en la matriz es un cuadrado perfecto, entonces la matriz se considera una matriz cuadrada. Devuelve el número de permutaciones cuadradas de A. Dos permutaciones A1 y A2 se consideran diferentes si existe un índice i tal que A1[i] != A2[i].\n\n@param A La matriz de enteros no negativos de entrada.\n@return El número de permutaciones cuadradas de A.\n\nEjemplo:\nsquarePermutations(new int[]{1, 17, 8})\nSalida: 2\n\nEjemplo:\nsquarePermutations(new int[]{2, 2, 2})\nSalida: 1",
      "arb": "بالنظر إلى مصفوفة أعداد صحيحة غير سالبة A، إذا كان مجموع كل زوج من العناصر المتجاورة في المصفوفة مربعًا كاملاً، فإن المصفوفة تعتبر مصفوفة مربعة. \n    قم بإرجاع عدد التباديل المربعة لـ A. يعتبر التباديلان A1 و A2 مختلفين إذا وجد مؤشر i بحيث A1[i] != A2[i].\n\n    @param A مصفوفة الأعداد الصحيحة غير السالبة المدخلة.\n    @return عدد التباديل المربعة لـ A.\n   \n    مثال:\n    squarePermutations(new int[]{1, 17, 8})\n    الناتج: 2\n   \n    مثال:\n    squarePermutations(new int[]{2, 2, 2})\n    الناتج: 1",
      "sw": "Ukipewa safu ya nambari zisizo hasi A, ikiwa jumla ya kila jozi ya vipengele vya karibu katika safu ni mraba kamili, basi safu inachukuliwa kuwa safu ya mraba. \n    Rudisha idadi ya mpangilio wa mraba wa A. Mipangilio miwili A1 na A2 inachukuliwa kuwa tofauti ikiwa kuna kiashiria i ambapo A1[i] != A2[i].\n   \n    @param A Kundi la nambari zisizo hasi za pembejeo.\n    @return Idadi ya mipangilio ya mraba ya A.\n   \n    Mfano:\n    squarePermutations(new int[]{1, 17, 8})\n    Matokeo: 2\n   \n    Mfano:\n    squarePermutations(new int[]{2, 2, 2})\n    Matokeo: 1",
      "tr": "Verilen negatif olmayan bir tamsayı dizisi A için, dizideki bitişik eleman çiftlerinin toplamı mükemmel kare ise, dizi kare dizi olarak kabul edilir.\n    A'nın kare permütasyonlarının sayısını döndürün. İki permütasyon A1 ve A2, A1[i] != A2[i] olacak şekilde bir i indeksi varsa farklı kabul edilir.\n   \n    @param A Girdi negatif olmayan tamsayı dizisi.\n    @return A'nın kare permütasyonlarının sayısı.\n   \n    Örnek:\n    squarePermutations(new int[]{1, 17, 8})\n    Çıktı: 2\n   \n    Örnek:\n    squarePermutations(new int[]{2, 2, 2})\n    Çıktı: 1",
      "vi": "Cho một mảng số nguyên không âm A, nếu tổng của mỗi cặp phần tử liền kề trong mảng là một số chính phương, thì mảng được coi là một mảng chính phương\nTrả về số lượng hoán vị vuông của A. Hai hoán vị A1 và A2 được coi là khác nhau nếu tồn tại chỉ số i sao cho A1[i] != A2[i].  \n@param A Mảng số nguyên không âm đầu vào.  \n@return Số lượng hoán vị vuông của A.   \nVí dụ:  \nsquarePermutations(new int[]{1, 17, 8})  \nKết quả: 2  \nVí dụ:  \nsquarePermutations(new int[]{2, 2, 2})  \nKết quả: 1  "
    },
    "docstring_bertscore": {
      "es": "0.9854858794273997",
      "arb": "0.9719365066154858",
      "sw": "0.9836525210104476",
      "tr": "0.9755917028872898",
      "vi": "0.999999801369619"
    }
  },
  {
    "task_id": "Java/43",
    "prompt": {
      "en": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "es": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Dados n enteros no negativos que representan las alturas de las barras en un gráfico de barras.\n   * Cada barra tiene un ancho de 1 unidad. Calcular el área del rectángulo más grande que se puede formar en el gráfico de barras.\n   *\n   * @param heights Un arreglo de enteros que representa las alturas de las barras.\n   * @return El área máxima del rectángulo que se puede formar.\n   *\n   * Ejemplo:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Salida: 10\n   *\n   * Ejemplo:\n   * largestRectangleArea(new int[]{2,4})\n   * Salida: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "arb": "import java.util.*;\npublic class Solution {\n\n  /**\n   * معطى n عدد صحيح غير سالب يمثل ارتفاع الأعمدة في مخطط الأعمدة.\n   * كل عمود له عرض وحدة واحدة. احسب أكبر مساحة مستطيل يمكن تشكيلها في مخطط الأعمدة.\n   *\n   * @param heights مصفوفة من الأعداد الصحيحة تمثل ارتفاعات الأعمدة.\n   * @return أقصى مساحة للمستطيل التي يمكن تشكيلها.\n   *\n   * مثال:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * الناتج: 10\n   *\n   * مثال:\n   * largestRectangleArea(new int[]{2,4})\n   * الناتج: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "sw": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Ukipewa n nambari zisizo hasi zinazowakilisha urefu wa mipira kwenye chati ya mipira.\n   * Kila mpira una upana wa kitengo 1. Hesabu eneo kubwa zaidi la mstatili ambalo linaweza kuundwa kwenye chati ya mipira.\n   *\n   * @param heights Mfululizo wa nambari zinazowakilisha urefu wa mipira.\n   * @return Eneo la juu zaidi la mstatili ambalo linaweza kuundwa.\n   *\n   * Mfano:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Matokeo: 10\n   *\n   * Mfano:\n   * largestRectangleArea(new int[]{2,4})\n   * Matokeo: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "tr": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Bir çubuk grafikteki çubukların yüksekliklerini temsil eden n tane negatif olmayan tamsayı verildiğinde.\n   * Her çubuk 1 birim genişliğe sahiptir. Çubuk grafikte oluşturulabilecek en büyük dikdörtgen alanını hesaplayın.\n   *\n   * @param heights Çubukların yüksekliklerini temsil eden bir tamsayı dizisi.\n   * @return Oluşturulabilecek dikdörtgenin maksimum alanı.\n   *\n   * Örnek:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Çıktı: 10\n   *\n   * Örnek:\n   * largestRectangleArea(new int[]{2,4})\n   * Çıktı: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "vi": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Cho n số nguyên không âm đại diện cho chiều cao của các thanh trong biểu đồ thanh.\n   * Mỗi thanh có chiều rộng là 1 đơn vị. Tính diện tích hình chữ nhật lớn nhất có thể được tạo ra trong biểu đồ thanh.\n   *\n   * @param heights Một mảng số nguyên đại diện cho chiều cao của các thanh.\n   * @return Diện tích lớn nhất của hình chữ nhật có thể được tạo ra.\n   *\n   * Ví dụ:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Đầu ra: 10\n   *\n   * Ví dụ:\n   * largestRectangleArea(new int[]{2,4})\n   * Đầu ra: 4\n   */\n  public static int largestRectangleArea(int[] heights) "
    },
    "prompt_bertscore": {
      "es": "0.9744525576520547",
      "arb": "0.9581817499895818",
      "sw": "0.976440847766214",
      "tr": "0.9935163071022591",
      "vi": "0.9802736195986632"
    },
    "canonical_solution": "  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }",
    "instruction": {
      "en": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9192750241043731",
      "sw": "0.9149216420432316",
      "tr": "0.8848885298003754",
      "vi": "0.9001481101929997"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "largestRectangleArea",
    "signature": "public static int largestRectangleArea(int[] heights)",
    "docstring": {
      "en": "Given n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "es": "Dado n enteros no negativos que representan las alturas de las barras en un gráfico de barras.\n    Cada barra tiene un ancho de 1 unidad. Calcular el área del rectángulo más grande que se puede formar en el gráfico de barras.\n   \n    @param heights Un arreglo de enteros que representa las alturas de las barras.\n    @return El área máxima del rectángulo que se puede formar.\n   \n    Ejemplo:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Salida: 10\n   \n    Ejemplo:\n    largestRectangleArea(new int[]{2,4})\n    Salida: 4",
      "arb": "معطى n عدد صحيح غير سالب يمثل ارتفاع الأعمدة في مخطط الأعمدة.  \n    كل شريط له عرض وحدة واحدة. احسب أكبر مساحة مستطيل يمكن تشكيلها في مخطط الأعمدة.\n   \n    @param heights مصفوفة من الأعداد الصحيحة تمثل ارتفاعات الأعمدة.\n    @return أكبر مساحة للمستطيل التي يمكن تشكيلها.\n   \n    مثال:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    الناتج: 10\n   \n    مثال:\n    largestRectangleArea(new int[]{2,4})\n    الناتج: 4",
      "sw": "Ukipewa n nambari zisizo hasi zinazowakilisha urefu wa mipira kwenye chati ya mipira.\n    Kila baa ina upana wa kitengo 1. Hesabu eneo kubwa zaidi la mstatili ambalo linaweza kuundwa kwenye chati ya baa.\n   \n    @param heights Safu ya nambari zisizo na alama zinazoonyesha urefu wa baa.\n    @return Eneo la juu zaidi la mstatili ambalo linaweza kuundwa.\n   \n    Mfano:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Matokeo: 10\n   \n    Mfano:\n    largestRectangleArea(new int[]{2,4})\n    Matokeo: 4",
      "tr": "Verilen n adet negatif olmayan tamsayı, bir çubuk grafikteki çubukların yüksekliklerini temsil eder. Her çubuğun genişliği 1 birimdir. Çubuk grafikte oluşturulabilecek en büyük dikdörtgen alanını hesaplayın.\n\n@param heights Çubukların yüksekliklerini temsil eden bir tamsayı dizisi.\n@return Çubuk grafikte oluşturulabilecek maksimum dikdörtgen alanı.\n\nÖrnek:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\nÇıktı: 10\n\nÖrnek:\nlargestRectangleArea(new int[]{2,4})\nÇıktı: 4",
      "vi": "Cho n số nguyên không âm đại diện cho chiều cao của các thanh trong biểu đồ thanh. Mỗi thanh có chiều rộng là 1 đơn vị. Tính diện tích hình chữ nhật lớn nhất có thể được tạo thành trong biểu đồ thanh.\n\n@param heights Một mảng các số nguyên đại diện cho chiều cao của các thanh.\n@return Diện tích lớn nhất của hình chữ nhật có thể được tạo thành.\n\nVí dụ:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\nĐầu ra: 10\n\nVí dụ:\nlargestRectangleArea(new int[]{2,4})\nĐầu ra: 4"
    },
    "docstring_bertscore": {
      "es": "0.9798547081250606",
      "arb": "0.9858799621033729",
      "sw": "0.9607619586392251",
      "tr": "0.9758568744459714",
      "vi": "0.9696411339322466"
    }
  },
  {
    "task_id": "Java/44",
    "prompt": {
      "en": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "es": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Devuelve todos los elementos en la matriz en orden diagonal.\n   *\n   * @param mat La matriz de entrada.\n   * @return Un arreglo que contiene todos los elementos en orden diagonal.\n   *\n   * Ejemplo:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Salida: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "arb": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * إرجاع جميع العناصر في المصفوفة بترتيب قطري.\n   *\n   * @param mat المصفوفة المدخلة.\n   * @return مصفوفة تحتوي على جميع العناصر بترتيب قطري.\n   *\n   * مثال:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * الناتج: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "sw": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Rudisha vipengele vyote kwenye matrix kwa mpangilio wa diagonal.\n   *\n   * @param mat Matrix ya ingizo.\n   * @return Array inayojumuisha vipengele vyote kwa mpangilio wa diagonal.\n   *\n   * Mfano:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Matokeo: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "tr": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Matristeki tüm elemanları çapraz sırayla döndür.\n   *\n   * @param mat Girdi matrisi.\n   * @return Tüm elemanları çapraz sırayla içeren bir dizi.\n   *\n   * Örnek:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Çıktı: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "vi": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Trả về tất cả các phần tử trong ma trận theo thứ tự đường chéo.\n   *\n   * @param mat Ma trận đầu vào.\n   * @return Một mảng chứa tất cả các phần tử theo thứ tự đường chéo.\n   *\n   * Ví dụ:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Đầu ra: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) "
    },
    "prompt_bertscore": {
      "es": "0.9986602380799197",
      "arb": "0.9999996027392379",
      "sw": "0.981838628370837",
      "tr": "0.9931299710111463",
      "vi": "0.9922444767724928"
    },
    "canonical_solution": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }",
    "instruction": {
      "en": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Java باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nJava kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yapılmalıdır.",
      "vi": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9281114938654722",
      "sw": "0.9149216420432316",
      "tr": "0.8891004870302202",
      "vi": "0.9052995891251394"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "diagonalOrder",
    "signature": "public static int[] diagonalOrder(int[][] mat)",
    "docstring": {
      "en": "Return all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "es": "Devolver todos los elementos en la matriz en orden diagonal.\n\n@param mat La matriz de entrada.\n@return Un arreglo que contiene todos los elementos en orden diagonal.\n\nEjemplo:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nSalida: [1,2,4,7,5,3,6,8,9]",
      "arb": "إرجاع جميع العناصر في المصفوفة بترتيب قطري.\n\n@param mat المصفوفة المدخلة.\n@return مصفوفة تحتوي على جميع العناصر بترتيب قطري.\n\nمثال:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nالناتج: [1,2,4,7,5,3,6,8,9]",
      "sw": "Rudisha vipengele vyote kwenye matrix kwa mpangilio wa diagonal.\n\n@param mat Matrix ya ingizo.\n@return Array inayojumuisha vipengele vyote kwa mpangilio wa diagonal.\n\nMfano:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nMatokeo: [1,2,4,7,5,3,6,8,9]",
      "tr": "Matristeki tüm elemanları çapraz sırayla döndür.\n\n@param mat Girdi matrisi.\n@return Tüm elemanları çapraz sırayla içeren bir dizi.\n\nÖrnek:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nÇıktı: [1,2,4,7,5,3,6,8,9]",
      "vi": "Trả về tất cả các phần tử trong ma trận theo thứ tự đường chéo.\n\n@param mat Ma trận đầu vào.\n@return Một mảng chứa tất cả các phần tử theo thứ tự đường chéo.\n\nVí dụ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nĐầu ra: [1,2,4,7,5,3,6,8,9]"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9755052986715397",
      "tr": "0.9773473968252572",
      "vi": "0.9903602689779959"
    }
  },
  {
    "task_id": "Java/45",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "es": "public class Solution {\n\n  /**\n   * Encuentra el entero más pequeño que se puede formar reorganizando los dígitos del entero positivo dado n, que sea mayor que n.\n   *\n   * @param n El entero positivo de entrada.\n   * @return El entero reorganizado más pequeño mayor que n, o -1 si no es posible.\n   *\n   * Ejemplo:\n   * findSmallestInteger(12)\n   * Salida: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "arb": "public class Solution {\n\n  /**\n   * إيجاد أصغر عدد صحيح يمكن تكوينه عن طريق إعادة ترتيب أرقام العدد الصحيح الموجب المعطى n، والذي يكون أكبر من n.\n   *\n   * @param n العدد الصحيح الموجب المدخل.\n   * @return أصغر عدد معاد ترتيبه أكبر من n، أو -1 إذا لم يكن ذلك ممكنًا.\n   *\n   * مثال:\n   * findSmallestInteger(12)\n   * الناتج: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "sw": "public class Solution {\n\n  /**\n   * Pata nambari ndogo zaidi inayoweza kuundwa kwa kupanga upya tarakimu za nambari nzima chanya iliyotolewa n, ambayo ni kubwa kuliko n.\n   *\n   * @param n Nambari nzima chanya ya pembejeo.\n   * @return Nambari ndogo zaidi iliyopangwa upya ambayo ni kubwa kuliko n, au -1 ikiwa haiwezekani.\n   *\n   * Mfano:\n   * findSmallestInteger(12)\n   * Matokeo: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "tr": "public class Solution {\n\n  /**\n   * Verilen pozitif tamsayının basamaklarını yeniden düzenleyerek n'den büyük olan en küçük tamsayıyı bulun.\n   *\n   * @param n Girdi pozitif tamsayı.\n   * @return n'den büyük en küçük yeniden düzenlenmiş tamsayı veya mümkün değilse -1.\n   *\n   * Örnek:\n   * findSmallestInteger(12)\n   * Çıktı: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "vi": "public class Solution {\n\n  /**\n   * Tìm số nguyên nhỏ nhất có thể được tạo bằng cách sắp xếp lại các chữ số của số nguyên dương n đã cho, lớn hơn n.\n   *\n   * @param n Số nguyên dương đầu vào.\n   * @return Số nguyên sắp xếp lại nhỏ nhất lớn hơn n, hoặc -1 nếu không thể.\n   *\n   * Ví dụ:\n   * findSmallestInteger(12)\n   * Đầu ra: 21\n   */\n  public static int findSmallestInteger(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9952169804246799",
      "arb": "0.996179543251175",
      "sw": "0.9723009933646849",
      "tr": "0.9457806594104307",
      "vi": "0.974254920422925"
    },
    "canonical_solution": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n",
    "instruction": {
      "en": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nAşağıdaki Java kodunun işlevini açıklayan en fazla 500 karakterlik Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8570200914500374",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "findSmallestInteger",
    "signature": "public static int findSmallestInteger(int n)",
    "docstring": {
      "en": "Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21",
      "es": "Encuentra el entero más pequeño que se puede formar reorganizando los dígitos del entero positivo dado n, que sea mayor que n.\n\n@param n El entero positivo de entrada.\n@return El entero reorganizado más pequeño mayor que n, o -1 si no es posible.\n\nEjemplo:\nfindSmallestInteger(12)\nSalida: 21",
      "arb": "ابحث عن أصغر عدد صحيح يمكن تكوينه عن طريق إعادة ترتيب أرقام العدد الصحيح الموجب المعطى n، والذي يكون أكبر من n.\n\n@param n العدد الصحيح الموجب المدخل.\n@return أصغر عدد معاد ترتيبه أكبر من n، أو -1 إذا لم يكن ذلك ممكنًا.\n\nمثال:\nfindSmallestInteger(12)\nالناتج: 21",
      "sw": "Pata nambari ndogo zaidi inayoweza kuundwa kwa kupanga upya tarakimu za nambari chanya iliyotolewa n, ambayo ni kubwa kuliko n.\n\n@param n Nambari chanya ya pembejeo.\n@return Nambari ndogo zaidi iliyopangwa upya ambayo ni kubwa kuliko n, au -1 ikiwa haiwezekani.\n\nMfano:\nfindSmallestInteger(12)\nMatokeo: 21",
      "tr": "Verilen pozitif tamsayının rakamlarını yeniden düzenleyerek n'den büyük olan en küçük tamsayıyı bulun.\n\n@param n Girdi pozitif tamsayı.\n@return n'den büyük en küçük yeniden düzenlenmiş tamsayı veya mümkün değilse -1.\n\nÖrnek:\nfindSmallestInteger(12)\nÇıktı: 21",
      "vi": "Tìm số nguyên nhỏ nhất có thể được tạo bằng cách sắp xếp lại các chữ số của số nguyên dương n đã cho, lớn hơn n.\n\n@param n Số nguyên dương đầu vào.\n@return Số nguyên nhỏ nhất sau khi sắp xếp lại lớn hơn n, hoặc -1 nếu không thể.\n\nVí dụ:\nfindSmallestInteger(12)\nĐầu ra: 21"
    },
    "docstring_bertscore": {
      "es": "0.9923282987932895",
      "arb": "1",
      "sw": "0.9391205827343309",
      "tr": "0.9199001139134899",
      "vi": "0.9471621337105284"
    }
  },
  {
    "task_id": "Java/46",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "es": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Dado un entero n, devuelve todos los números simétricos centrales de longitud n.\n   *\n   * @param n La longitud de los números simétricos centrales.\n   * @return Una lista de números simétricos centrales.\n   *\n   * Ejemplo:\n   * centerSymmetricNumbers(2)\n   * Salida: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Salida: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "arb": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * بالنظر إلى عدد صحيح n، أعد جميع الأرقام المتماثلة المركزية بطول n.\n   *\n   * @param n طول الأرقام المتماثلة المركزية.\n   * @return قائمة بالأرقام المتماثلة المركزية.\n   *\n   * مثال:\n   * centerSymmetricNumbers(2)\n   * الناتج: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * الناتج: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "sw": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Ukipewa nambari nzima n, rudisha nambari zote za ulinganifu wa katikati zenye urefu n.\n   *\n   * @param n Urefu wa nambari za ulinganifu wa katikati.\n   * @return Orodha ya nambari za ulinganifu wa katikati.\n   *\n   * Mfano:\n   * centerSymmetricNumbers(2)\n   * Matokeo: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Matokeo: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n)",
      "tr": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Bir tamsayı n verildiğinde, n uzunluğundaki tüm merkez simetrik sayıları döndür.\n   *\n   * @param n Merkez simetrik sayıların uzunluğu.\n   * @return Merkez simetrik sayıların bir listesi.\n   *\n   * Örnek:\n   * centerSymmetricNumbers(2)\n   * Çıktı: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Çıktı: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "vi": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Cho một số nguyên n, trả về tất cả các số đối xứng tâm có độ dài n.\n   *\n   * @param n Độ dài của các số đối xứng tâm.\n   * @return Một danh sách các số đối xứng tâm.\n   *\n   * Ví dụ:\n   * centerSymmetricNumbers(2)\n   * Đầu ra: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Đầu ra: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9972966405141152",
      "arb": "0.9678745153233224",
      "sw": "0.9837444868768668",
      "tr": "0.9972966405141152",
      "vi": "0.9972966405141152"
    },
    "canonical_solution": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }",
    "instruction": {
      "en": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nJava kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9128546942981824",
      "sw": "0.9149216420432316",
      "tr": "0.8406160028018902",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "centerSymmetricNumbers",
    "signature": "public static List<String> centerSymmetricNumbers(int n)",
    "docstring": {
      "en": "Given an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "es": "Dado un entero n, devuelve todos los números simétricos centrales de longitud n.\n\n@param n La longitud de los números simétricos centrales.\n@return Una lista de números simétricos centrales.\n\nEjemplo:\ncenterSymmetricNumbers(2)\nSalida: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nSalida: [\"0\",\"1\",\"8\"]",
      "arb": "بالنظر إلى عدد صحيح n، قم بإرجاع جميع الأرقام المتماثلة حول المركز بطول n.\n\n@param n طول الأرقام المتماثلة حول المركز.\n@return قائمة بالأرقام المتماثلة حول المركز.\n\nمثال:\ncenterSymmetricNumbers(2)\nالناتج: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nالناتج: [\"0\",\"1\",\"8\"]",
      "sw": "Kwa kuzingatia nambari nzima n, rudisha nambari zote za ulinganifu wa katikati zenye urefu n.\n\n@param n Urefu wa nambari za ulinganifu wa katikati.\n@return Orodha ya nambari za ulinganifu wa katikati.\n\nMfano:\ncenterSymmetricNumbers(2)\nMatokeo: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nMatokeo: [\"0\",\"1\",\"8\"]",
      "tr": "Verilen bir tamsayı n için, uzunluğu n olan tüm merkez simetrik sayıları döndürün.\n\n@param n Merkez simetrik sayıların uzunluğu.\n@return Merkez simetrik sayıların bir listesi.\n\nÖrnek:\ncenterSymmetricNumbers(2)\nÇıktı: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nÇıktı: [\"0\",\"1\",\"8\"]",
      "vi": "Cho một số nguyên n, trả về tất cả các số đối xứng tâm có độ dài n.\n\n@param n Độ dài của các số đối xứng tâm.\n@return Một danh sách các số đối xứng tâm.\n\nVí dụ:\ncenterSymmetricNumbers(2)\nĐầu ra: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nĐầu ra: [\"0\",\"1\",\"8\"]"
    },
    "docstring_bertscore": {
      "es": "0.982133793117055",
      "arb": "0.9621156246859779",
      "sw": "0.9644374152098947",
      "tr": "0.9859951677243731",
      "vi": "0.9621156246859779"
    }
  },
  {
    "task_id": "Java/47",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "es": "public class Solution {\n\n  /**\n   * Determinar si los puntos dados forman un boomerang en el plano X-Y.\n   *\n   * @param points Un arreglo de puntos donde points[i] = [xi, yi].\n   * @return True si los puntos forman un boomerang, false en caso contrario.\n   *\n   * Ejemplo:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Salida: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "arb": "public class Solution {\n\n  /**\n   * تحديد ما إذا كانت النقاط المعطاة تشكل بوميرانج على المستوى X-Y.\n   *\n   * @param points مصفوفة من النقاط حيث points[i] = [xi, yi].\n   * @return صحيح إذا كانت النقاط تشكل بوميرانج، خطأ خلاف ذلك.\n   *\n   * مثال:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * الناتج: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "sw": "public class Solution {\n\n  /**\n   * Tambua kama pointi zilizotolewa zinaunda boomerang kwenye ndege ya X-Y.\n   *\n   * @param points Mfululizo wa pointi ambapo points[i] = [xi, yi].\n   * @return Kweli ikiwa pointi zinaunda boomerang, sivyo basi uongo.\n   *\n   * Mfano:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Matokeo: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "tr": "public class Solution {\n\n  /**\n   * Verilen noktaların X-Y düzleminde bir bumerang oluşturup oluşturmadığını belirleyin.\n   *\n   * @param points points[i] = [xi, yi] olan bir nokta dizisi.\n   * @return Noktalar bir bumerang oluşturuyorsa true, aksi takdirde false.\n   *\n   * Örnek:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Çıktı: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "vi": "public class Solution {\n\n  /**\n   * Xác định xem các điểm đã cho có tạo thành một boomerang trên mặt phẳng X-Y hay không.\n   *\n   * @param points Một mảng các điểm, trong đó points[i] = [xi, yi].\n   * @return True nếu các điểm tạo thành một boomerang, false nếu không.\n   *\n   * Ví dụ:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Đầu ra: true\n   */\n  public static boolean isBoomerang(int[][] points) "
    },
    "prompt_bertscore": {
      "es": "0.9986512997127731",
      "arb": "0.9990966290270533",
      "sw": "0.9977493191524937",
      "tr": "0.9964196873818462",
      "vi": "0.9962073515045199"
    },
    "canonical_solution": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }",
    "instruction": {
      "en": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة جافا باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nAşağıdaki Java kodunun işlevini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9306920997758775",
      "sw": "0.9149216420432316",
      "tr": "0.8612562815863686",
      "vi": "0.9361222571326093"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isBoomerang",
    "signature": "public static boolean isBoomerang(int[][] points)",
    "docstring": {
      "en": "Determine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "es": "Determinar si los puntos dados forman un boomerang en el plano X-Y.\n\n@param points Un arreglo de puntos donde points[i] = [xi, yi].\n@return True si los puntos forman un boomerang, false en caso contrario.\n\nEjemplo:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nSalida: true",
      "arb": "تحديد ما إذا كانت النقاط المعطاة تشكل بوميرانغ على مستوى X-Y.\n\n@param points مصفوفة من النقاط حيث points[i] = [xi, yi].\n@return صحيح إذا كانت النقاط تشكل بوميرانغ، خطأ خلاف ذلك.\n\nمثال:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nالناتج: true",
      "sw": "Amua ikiwa pointi zilizotolewa zinaunda boomerang kwenye ndege ya X-Y.\n\n@param points Mfululizo wa pointi ambapo points[i] = [xi, yi].\n@return Kweli ikiwa pointi zinaunda boomerang, sivyo vinginevyo.\n\nMfano:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nMatokeo: true",
      "tr": "Verilen noktaların X-Y düzleminde bir bumerang oluşturup oluşturmadığını belirleyin.\n\n@param points points[i] = [xi, yi] olan noktaların bir dizisi.\n@return Noktalar bir bumerang oluşturuyorsa True, aksi takdirde false.\n\nÖrnek:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nÇıktı: true",
      "vi": "Xác định liệu các điểm đã cho có tạo thành một boomerang trên mặt phẳng X-Y hay không.\n\n@param points Một mảng các điểm, trong đó points[i] = [xi, yi].\n@return True nếu các điểm tạo thành một boomerang, ngược lại là false.\n\nVí dụ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nĐầu ra: true"
    },
    "docstring_bertscore": {
      "es": "0.9980651414583391",
      "arb": "1",
      "sw": "0.9919878463201958",
      "tr": "0.994175759967295",
      "vi": "0.9924536345637225"
    }
  },
  {
    "task_id": "Java/48",
    "prompt": {
      "en": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "es": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Encuentra y devuelve el enésimo número feo.\n   *\n   * @param n El índice del número feo a encontrar.\n   * @return El enésimo número feo.\n   *\n   * Ejemplo:\n   * findNthUglyNumber(10)\n   * Salida: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "arb": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * إيجاد وإرجاع العدد القبيح رقم n.\n   *\n   * @param n مؤشر العدد القبيح الذي يجب إيجاده.\n   * @return العدد القبيح رقم n.\n   *\n   * مثال:\n   * findNthUglyNumber(10)\n   * الناتج: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "sw": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Pata na urudishe nambari mbaya ya nth.\n   *\n   * @param n Kiashiria cha nambari mbaya inayotafutwa.\n   * @return Nambari mbaya ya nth.\n   *\n   * Mfano:\n   * findNthUglyNumber(10)\n   * Matokeo: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "tr": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * n. çirkin sayıyı bulun ve döndürün.\n   *\n   * @param n Bulunacak çirkin sayının indeksi.\n   * @return n. çirkin sayı.\n   *\n   * Örnek:\n   * findNthUglyNumber(10)\n   * Çıktı: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "vi": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Tìm và trả về số xấu xí thứ n.\n   *\n   * @param n Chỉ số của số xấu xí cần tìm.\n   * @return Số xấu xí thứ n.\n   *\n   * Ví dụ:\n   * findNthUglyNumber(10)\n   * Đầu ra: 12\n   */\n  public static int findNthUglyNumber(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9934594988132832",
      "arb": "0.9945420343899234",
      "sw": "0.9749564829287403",
      "tr": "0.974733222380457",
      "vi": "1"
    },
    "canonical_solution": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n",
    "instruction": {
      "en": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nAşağıdaki Java kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8652195535791577",
      "sw": "0.9426256144380726",
      "tr": "0.8881111091022854",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "findNthUglyNumber",
    "signature": "public static int findNthUglyNumber(int n)",
    "docstring": {
      "en": "Find and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12",
      "es": "Encuentra y devuelve el enésimo número feo.\n   \n    @param n El índice del número feo a encontrar.\n    @return El enésimo número feo.\n   \n    Ejemplo:\n    findNthUglyNumber(10)\n    Salida: 12",
      "arb": "ابحث وأعد العدد القبيح رقم n.\n\n    @param n الفهرس للعدد القبيح الذي يجب العثور عليه.\n    @return العدد القبيح رقم n.\n\n    مثال:\n    findNthUglyNumber(10)\n    الناتج: 12",
      "sw": "Tafuta na rudisha nambari mbaya ya nth.\n\n    @param n Kiashiria cha nambari mbaya ya kutafuta.\n    @return Nambari mbaya ya nth.\n   \n    Mfano:\n    findNthUglyNumber(10)\n    Matokeo: 12",
      "tr": "Find ve döndür n'inci çirkin sayıyı.\n   \n    @param n Bulunacak çirkin sayının indeksi.\n    @return n'inci çirkin sayı.\n   \n    Örnek:\n    findNthUglyNumber(10)\n    Çıktı: 12",
      "vi": "Tìm và trả về số xấu xí thứ n.\n\n    @param n Chỉ số của số xấu xí cần tìm.\n    @return Số xấu xí thứ n.\n\n    Ví dụ:\n    findNthUglyNumber(10)\n    Đầu ra: 12"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9823930057643054",
      "tr": "0.9908719408395417",
      "vi": "0.9823930057643054"
    }
  },
  {
    "task_id": "Java/49",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "es": "public class Solution {\n\n  /**\n   * Calcular la energía de la cadena, que se define como la longitud de la subcadena no vacía más larga que contiene solo un carácter.\n   *\n   * @param s La cadena de entrada.\n   * @return La energía de la cadena.\n   *\n   * Ejemplo:\n   * calculateEnergy(\"aabbccdd\")\n   * Salida: 2\n   */\n  public static int calculateEnergy(String s) ",
      "arb": "public class Solution {\n\n  /**\n   * حساب طاقة السلسلة، والتي تُعرّف على أنها طول أطول سلسلة فرعية غير فارغة تحتوي على حرف واحد فقط.\n   *\n   * @param s السلسلة المدخلة.\n   * @return طاقة السلسلة.\n   *\n   * مثال:\n   * calculateEnergy(\"aabbccdd\")\n   * الناتج: 2\n   */\n  public static int calculateEnergy(String s) ",
      "sw": "public class Solution {\n\n  /**\n   * Hesabu nishati ya kamba, ambayo inafafanuliwa kama urefu wa sehemu ndogo ndefu isiyo tupu inayojumuisha herufi moja tu.\n   *\n   * @param s Kamba ya ingizo.\n   * @return Nishati ya kamba.\n   *\n   * Mfano:\n   * calculateEnergy(\"aabbccdd\")\n   * Matokeo: 2\n   */\n  public static int calculateEnergy(String s) ",
      "tr": "public class Solution {\n\n  /**\n   * Yalnızca bir karakter içeren en uzun boş olmayan alt dizenin uzunluğu olarak tanımlanan dizenin enerjisini hesaplayın.\n   *\n   * @param s Girdi dizesi.\n   * @return Dizenin enerjisi.\n   *\n   * Örnek:\n   * calculateEnergy(\"aabbccdd\")\n   * Çıktı: 2\n   */\n  public static int calculateEnergy(String s) ",
      "vi": "public class Solution {\n\n  /**\n   * Tính toán năng lượng của chuỗi, được định nghĩa là độ dài của chuỗi con dài nhất không rỗng chỉ chứa một ký tự.\n   *\n   * @param s Chuỗi đầu vào.\n   * @return Năng lượng của chuỗi.\n   *\n   * Ví dụ:\n   * calculateEnergy(\"aabbccdd\")\n   * Đầu ra: 2\n   */\n  public static int calculateEnergy(String s) "
    },
    "prompt_bertscore": {
      "es": "0.9955246588849029",
      "arb": "1",
      "sw": "0.9776044245383163",
      "tr": "0.9734907893470838",
      "vi": "0.9676709191827616"
    },
    "canonical_solution": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }",
    "instruction": {
      "en": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Java باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9051313491924029",
      "sw": "0.9426256144380726",
      "tr": "0.8799948731028189",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; // Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; // All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; // Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateEnergy",
    "signature": "public static int calculateEnergy(String s)",
    "docstring": {
      "en": "Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "es": "Calcular la energía de la cadena, que se define como la longitud de la subcadena no vacía más larga que contiene solo un carácter.\n\n    @param s La cadena de entrada.\n    @return La energía de la cadena.\n\n    Ejemplo:\n    calculateEnergy(\"aabbccdd\")\n    Salida: 2",
      "arb": "احسب طاقة السلسلة، والتي تُعرّف على أنها طول أطول سلسلة فرعية غير فارغة تحتوي على حرف واحد فقط.\n\n    @param s السلسلة المدخلة.\n    @return طاقة السلسلة.\n\n    مثال:\n    calculateEnergy(\"aabbccdd\")\n    الناتج: 2",
      "sw": "Hesabu nishati ya kamba, ambayo inafafanuliwa kama urefu wa sehemu ndogo ndefu isiyo tupu yenye herufi moja tu.\n\n    @param s Kamba ya ingizo.\n    @return Nishati ya kamba.\n   \n    Mfano:\n    calculateEnergy(\"aabbccdd\")\n    Matokeo: 2",
      "tr": "Yalnızca bir karakter içeren en uzun boş olmayan alt dizenin uzunluğu olarak tanımlanan dizenin enerjisini hesaplayın.\n   \n    @param s Girdi dizgesi.\n    @return Dizgenin enerjisi.\n   \n    Örnek:\n    calculateEnergy(\"aabbccdd\")\n    Çıktı: 2",
      "vi": "Tính toán năng lượng của chuỗi, được định nghĩa là độ dài của chuỗi con dài nhất không rỗng chỉ chứa một ký tự.\n\n    @param s Chuỗi đầu vào.\n    @return Năng lượng của chuỗi.\n\n    Ví dụ:\n    calculateEnergy(\"aabbccdd\")\n    Đầu ra: 2"
    },
    "docstring_bertscore": {
      "es": "0.9911047356461146",
      "arb": "1",
      "sw": "0.9630702422972315",
      "tr": "0.9707840531447214",
      "vi": "0.959195956715146"
    }
  },
  {
    "task_id": "Java/50",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "es": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Devuelve todos los enteros en el rango [1, n] en orden lexicográfico.\n   *\n   * @param n El límite superior del rango.\n   * @return Lista de enteros en orden lexicográfico.\n   *\n   * Ejemplo:\n   * lexicalOrder(13)\n   * Salida: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "arb": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * إرجاع جميع الأعداد الصحيحة في النطاق [1, n] بترتيب معجمي.\n   *\n   * @param n الحد الأعلى للنطاق.\n   * @return قائمة الأعداد الصحيحة بترتيب معجمي.\n   *\n   * مثال:\n   * lexicalOrder(13)\n   * الناتج: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "sw": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Rudisha nambari zote katika safu [1, n] kwa mpangilio wa herufi.\n   *\n   * @param n Kikomo cha juu cha safu.\n   * @return Orodha ya nambari kwa mpangilio wa herufi.\n   *\n   * Mfano:\n   * lexicalOrder(13)\n   * Matokeo: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "tr": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * [1, n] aralığındaki tüm tam sayıları sözlük sırasına göre döndür.\n   *\n   * @param n Aralığın üst sınırı.\n   * @return Sözlük sırasına göre tam sayıların listesi.\n   *\n   * Örnek:\n   * lexicalOrder(13)\n   * Çıktı: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "vi": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Trả về tất cả các số nguyên trong phạm vi [1, n] theo thứ tự từ điển.\n   *\n   * @param n Giới hạn trên của phạm vi.\n   * @return Danh sách các số nguyên theo thứ tự từ điển.\n   *\n   * Ví dụ:\n   * lexicalOrder(13)\n   * Đầu ra: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) "
    },
    "prompt_bertscore": {
      "es": "0.998866813676196",
      "arb": "0.9936924922502371",
      "sw": "0.9767703755683509",
      "tr": "0.9921328464983512",
      "vi": "0.99139751682776"
    },
    "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }",
    "instruction": {
      "en": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nJava kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9128546942981824",
      "sw": "0.9426256144380726",
      "tr": "0.8412671131909225",
      "vi": "0.9054553153438708"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "lexicalOrder",
    "signature": "public static List<Integer> lexicalOrder(int n)",
    "docstring": {
      "en": "Return all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "es": "Devolver todos los enteros en el rango [1, n] en orden lexicográfico.\n   \n    @param n El límite superior del rango.\n    @return Lista de enteros en orden lexicográfico.\n   \n    Ejemplo:\n    lexicalOrder(13)\n    Salida: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "arb": "إرجاع جميع الأعداد الصحيحة في النطاق [1، n] بترتيب معجمي.\n\n    @param n الحد الأعلى للنطاق.\n    @return قائمة الأعداد الصحيحة بترتيب معجمي.\n\n    مثال:\n    lexicalOrder(13)\n    الناتج: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "sw": "Rudisha nambari zote za mzima katika safu [1, n] kwa mpangilio wa herufi.\n\n    @param n Kikomo cha juu cha safu.\n    @return Orodha ya nambari katika mpangilio wa herufi.\n\n    Mfano:\n    lexicalOrder(13)\n    Matokeo: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "tr": "Tüm tamsayıları [1, n] aralığında sözlük sırasına göre döndür.\n\n    @param n Aralığın üst sınırı.\n    @return Sözlük sırasına göre tamsayıların listesi.\n\n    Örnek:\n    lexicalOrder(13)\n    Çıktı: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "vi": "Trả về tất cả các số nguyên trong phạm vi [1, n] theo thứ tự từ điển.\n\n    @param n Giới hạn trên của phạm vi.\n    @return Danh sách các số nguyên theo thứ tự từ điển.\n   \n    Ví dụ:\n    lexicalOrder(13)\n    Đầu ra: [1,10,11,12,13,2,3,4,5,6,7,8,9]"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9921105998956753",
      "sw": "0.9307749286447691",
      "tr": "0.9921105998956753",
      "vi": "0.9890316303592535"
    }
  },
  {
    "task_id": "Java/51",
    "prompt": {
      "en": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "es": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calcular la suma de elementos únicos en el arreglo de enteros dado.\n   *\n   * @param nums Un arreglo de enteros.\n   * @return La suma de elementos únicos.\n   *\n   * Ejemplo:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Salida: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "arb": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * حساب مجموع العناصر الفريدة في مصفوفة الأعداد الصحيحة المعطاة.\n   *\n   * @param nums مصفوفة من الأعداد الصحيحة.\n   * @return مجموع العناصر الفريدة.\n   *\n   * مثال:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * الناتج: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "sw": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Hesabu jumla ya vipengele vya kipekee katika safu iliyotolewa ya nambari za mzima.\n   *\n   * @param nums Safu ya nambari za mzima.\n   * @return Jumla ya vipengele vya kipekee.\n   *\n   * Mfano:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Matokeo: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "tr": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Verilen tamsayı dizisindeki benzersiz elemanların toplamını hesaplayın.\n   *\n   * @param nums Bir tamsayı dizisi.\n   * @return Benzersiz elemanların toplamı.\n   *\n   * Örnek:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Çıktı: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "vi": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Tính tổng của các phần tử duy nhất trong mảng số nguyên đã cho.\n   *\n   * @param nums Một mảng các số nguyên.\n   * @return Tổng của các phần tử duy nhất.\n   *\n   * Ví dụ:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Đầu ra: 4\n   */\n  public static int calculateUniqueSum(int[] nums) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9936855401869009",
      "sw": "0.9797097079469052",
      "tr": "0.9919431544844629",
      "vi": "1"
    },
    "canonical_solution": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }",
    "instruction": {
      "en": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة Java باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nJava kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8714799859286153",
      "sw": "0.9149216420432316",
      "tr": "0.8720578017070457",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; // Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; // Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; // Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateUniqueSum",
    "signature": "public static int calculateUniqueSum(int[] nums)",
    "docstring": {
      "en": "Calculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "es": "Calcular la suma de elementos únicos en el arreglo de enteros dado.\n\n   @param nums Un arreglo de enteros.\n   @return La suma de elementos únicos.\n\n   Ejemplo:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Salida: 4",
      "arb": "احسب مجموع العناصر الفريدة في المصفوفة الصحيحة المعطاة.\n\n   @param nums مصفوفة من الأعداد الصحيحة.\n   @return مجموع العناصر الفريدة.\n\n   مثال:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   الناتج: 4",
      "sw": "Hesabu jumla ya vipengele vya kipekee katika safu ya nambari nzima iliyotolewa.\n\n   @param nums Safu ya nambari nzima.\n   @return Jumla ya vipengele vya kipekee.\n\n   Mfano:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Matokeo: 4",
      "tr": "Benzersiz elemanların toplamını verilen tamsayı dizisinde hesaplayın.\n\n   @param nums Bir tamsayı dizisi.\n   @return Benzersiz elemanların toplamı.\n\n   Örnek:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Çıktı: 4",
      "vi": "Tính tổng của các phần tử duy nhất trong mảng số nguyên đã cho.\n\n   @param nums Một mảng các số nguyên.\n   @return Tổng của các phần tử duy nhất.\n\n   Ví dụ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Đầu ra: 4"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.928764590558315",
      "tr": "0.9898162203643412",
      "vi": "1"
    }
  },
  {
    "task_id": "Java/52",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "es": "public class Solution {\n\n  /**\n   * Dado un entero n, devuelve el número mínimo de números cuadrados perfectos que suman n.\n   *\n   * @param n El entero objetivo.\n   * @return El número mínimo de números cuadrados perfectos.\n   *\n   * Ejemplo:\n   * minPerfectSquareSum(12)\n   * Salida: 3\n   *\n   * Ejemplo:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "arb": "public class Solution {\n\n  /**\n   * بالنظر إلى عدد صحيح n، أعد العدد الأدنى من الأعداد المربعة الكاملة التي مجموعها يساوي n.\n   *\n   * @param n العدد الصحيح المستهدف.\n   * @return العدد الأدنى من الأعداد المربعة الكاملة.\n   *\n   * مثال:\n   * minPerfectSquareSum(12)\n   * الناتج: 3\n   *\n   * مثال:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "sw": "public class Solution {\n\n  /**\n   * Ukipewa nambari nzima n, rudisha idadi ndogo zaidi ya nambari za mraba kamili zinazojumlisha hadi n.\n   *\n   * @param n Nambari lengwa.\n   * @return Idadi ndogo zaidi ya nambari za mraba kamili.\n   *\n   * Mfano:\n   * minPerfectSquareSum(12)\n   * Matokeo: 3\n   *\n   * Mfano:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "tr": "public class Solution {\n\n  /**\n   * Verilen bir tamsayı n için, n'yi toplam olarak veren en az mükemmel kare sayısını döndürün.\n   *\n   * @param n Hedef tamsayı.\n   * @return En az mükemmel kare sayısı.\n   *\n   * Örnek:\n   * minPerfectSquareSum(12)\n   * Çıktı: 3\n   *\n   * Örnek:\n   * minPerfectSquareSum(13)\n   * Çıktı: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "vi": "public class Solution {\n\n  /**\n   * Cho một số nguyên n, trả về số lượng tối thiểu các số chính phương hoàn hảo mà tổng bằng n.\n   *\n   * @param n Số nguyên mục tiêu.\n   * @return Số lượng tối thiểu các số chính phương hoàn hảo.\n   *\n   * Ví dụ:\n   * minPerfectSquareSum(12)\n   * Đầu ra: 3\n   *\n   * Ví dụ:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) "
    },
    "prompt_bertscore": {
      "es": "0.9961501459547818",
      "arb": "0.9961501459547818",
      "sw": "0.9623710633559888",
      "tr": "0.9400183920566086",
      "vi": "0.975353346430048"
    },
    "canonical_solution": "  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }",
    "instruction": {
      "en": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando como máximo 500 caracteres.",
      "arb": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة جافا باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nJava kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.8764570673862064",
      "sw": "0.9149216420432316",
      "tr": "0.8848885298003754",
      "vi": "0.9257926827972709"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minPerfectSquareSum",
    "signature": "public static int minPerfectSquareSum(int n)",
    "docstring": {
      "en": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2",
      "es": "Dado un entero n, devuelve el número mínimo de números cuadrados perfectos que suman n.\n   \n    @param n El entero objetivo.\n    @return El número mínimo de números cuadrados perfectos.\n   \n    Ejemplo:\n    minPerfectSquareSum(12)\n    Salida: 3\n   \n    Ejemplo:\n    minPerfectSquareSum(13)\n    Salida: 2",
      "arb": "بالنظر إلى عدد صحيح n، أعد العدد الأدنى من الأعداد المربعة الكاملة التي مجموعها يساوي n.\n   \n    @param n العدد الصحيح المستهدف.\n    @return الحد الأدنى لعدد الأعداد المربعة الكاملة.\n\n    مثال:\n    مثال:\n    minPerfectSquareSum(12)\n    الناتج: 3\n   \n    مثال:\n    مثال:\n    minPerfectSquareSum(13)\n    الناتج: 2",
      "sw": "Kwa kupewa nambari nzima n, rudisha idadi ndogo zaidi ya nambari kamilifu za mraba zinazojumlisha hadi n.\n\n    @param n Nambari lengwa.\n    @return Idadi ndogo zaidi ya nambari kamilifu za mraba.\n   \n    Mfano:\n    minPerfectSquareSum(12)\n    Matokeo: 3\n   \n    Mfano:\n    minPerfectSquareSum(13)\n    Matokeo: 2",
      "tr": "Verilen bir tamsayı n için, n'yi toplamak için gereken en az mükemmel kare sayısını döndürün.\n\n    @param n Hedef tamsayı.\n    @return Mükemmel kare sayıların minimum sayısı.\n\n    Örnek:\n    minPerfectSquareSum(12)\n    Çıktı: 3\n\n    Örnek:\n    minPerfectSquareSum(13)\n    Çıktı: 2",
      "vi": "Cho một số nguyên n, trả về số lượng tối thiểu các số chính phương hoàn hảo mà tổng bằng n.\n\n    @param n Số nguyên mục tiêu.\n    @return Số lượng nhỏ nhất của các số chính phương.\n\n    Ví dụ:\n    minPerfectSquareSum(12)\n    Đầu ra: 3\n\n    Ví dụ:\n    minPerfectSquareSum(13)\n    Đầu ra: 2"
    },
    "docstring_bertscore": {
      "es": "0.9948604388907223",
      "arb": "0.9883046431646658",
      "sw": "0.9266191838127571",
      "tr": "0.9371757926736183",
      "vi": "0.9786929190263876"
    }
  },
  {
    "task_id": "Java/53",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "es": "public class Solution {\n\n  /**\n   * Invierte los caracteres de cada palabra en la cadena dada mientras se mantiene el orden original de las palabras.\n   *\n   * @param s La cadena de entrada que contiene palabras separadas por espacios.\n   * @return La cadena con los caracteres de cada palabra invertidos.\n   *\n   * Ejemplo:\n   * reverseWords(\"Mr Ding\")\n   * Salida: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "arb": "public class Solution {\n\n  /**\n   * عكس حروف كل كلمة في السلسلة النصية المعطاة مع الحفاظ على ترتيب الكلمات الأصلي.\n   *\n   * @param s السلسلة النصية المدخلة التي تحتوي على كلمات مفصولة بمسافات.\n   * @return السلسلة النصية مع عكس حروف كل كلمة.\n   *\n   * مثال:\n   * reverseWords(\"Mr Ding\")\n   * الناتج: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "sw": "public class Solution {\n\n  /**\n   * Geuza herufi za kila neno katika mfuatano uliotolewa huku ukihifadhi mpangilio wa awali wa maneno.\n   *\n   * @param s Mfuatano wa ingizo unao na maneno yaliyotenganishwa na nafasi.\n   * @return Mfuatano na herufi za kila neno zimegeuzwa.\n   *\n   * Mfano:\n   * reverseWords(\"Mr Ding\")\n   * Matokeo: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "tr": "public class Solution {\n\n  /**\n   * Verilen dizedeki her kelimenin karakterlerini ters çevirirken orijinal kelime sırasını koruyun.\n   *\n   * @param s Boşluklarla ayrılmış kelimeler içeren giriş dizesi.\n   * @return Her kelimenin karakterleri ters çevrilmiş dize.\n   *\n   * Örnek:\n   * reverseWords(\"Mr Ding\")\n   * Çıktı: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "vi": "public class Solution {\n\n  /**\n   * Đảo ngược các ký tự của mỗi từ trong chuỗi đã cho trong khi duy trì thứ tự từ gốc.\n   *\n   * @param s Chuỗi đầu vào chứa các từ được phân tách bằng dấu cách.\n   * @return Chuỗi với các ký tự của mỗi từ được đảo ngược.\n   *\n   * Ví dụ:\n   * reverseWords(\"Mr Ding\")\n   * Đầu ra: \"rM gniD\"\n   */\n  public static String reverseWords(String s) "
    },
    "prompt_bertscore": {
      "es": "0.9719293559217685",
      "arb": "0.9737041183763153",
      "sw": "0.9548042389904646",
      "tr": "0.9776072053636509",
      "vi": "0.9773321022859175"
    },
    "canonical_solution": "  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }",
    "instruction": {
      "en": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "es": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Java en español utilizando un máximo de 500 caracteres.",
      "arb": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة Java باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Java kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nVerilen Java kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Java bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687935780963708",
      "arb": "0.9048268488182765",
      "sw": "0.9149216420432316",
      "tr": "0.8331250552419215",
      "vi": "0.9220630001325788"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    testReverseWords(\"The quick brown fox\", \"ehT kciuq nworb xof\");\n    testReverseWords(\"Hello World\", \"olleH dlroW\");\n    testReverseWords(\"a b c d e f\", \"a b c d e f\");\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "reverseWords",
    "signature": "public static String reverseWords(String s)",
    "docstring": {
      "en": "Reverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "es": "Invierte los caracteres de cada palabra en la cadena dada mientras mantienes el orden original de las palabras.\n\n    @param s La cadena de entrada que contiene palabras separadas por espacios.\n    @return La cadena con los caracteres de cada palabra invertidos.\n\n    Ejemplo:\n    reverseWords(\"Mr Ding\")\n    Salida: \"rM gniD\"",
      "arb": "عكس حروف كل كلمة في السلسلة المعطاة مع الحفاظ على ترتيب الكلمات الأصلي.\n\n    @param s السلسلة المدخلة التي تحتوي على كلمات مفصولة بمسافات.\n    @return السلسلة مع حروف كل كلمة معكوسة.\n\n    مثال:\n    reverseWords(\"Mr Ding\")\n    الناتج: \"rM gniD\"",
      "sw": "Geuza herufi za kila neno katika kamba uliyopewa huku ukidumisha mpangilio wa awali wa maneno.\n\n    @param s Kamba ya ingizo inayo maneno yaliyotenganishwa na nafasi.\n    @return Kamba yenye herufi za kila neno zimegeuzwa.\n\n    Mfano:\n    reverseWords(\"Mr Ding\")\n    Matokeo: \"rM gniD\"",
      "tr": "Her kelimenin karakterlerini ters çevirirken, verilen stringdeki orijinal kelime sırasını koruyun.\n\n    @param s Kelimelerin boşluklarla ayrıldığı giriş stringi.\n    @return Her kelimenin karakterleri ters çevrilmiş string.\n\n    Örnek:\n    reverseWords(\"Mr Ding\")\n    Çıktı: \"rM gniD\"",
      "vi": "Đảo ngược các ký tự của mỗi từ trong chuỗi đã cho trong khi duy trì thứ tự từ ban đầu.\n\n    @param s Chuỗi đầu vào chứa các từ được phân tách bằng dấu cách.\n    @return Chuỗi với các ký tự của mỗi từ được đảo ngược.\n\n    Ví dụ:\n    reverseWords(\"Mr Ding\")\n    Đầu ra: \"rM gniD\""
    },
    "docstring_bertscore": {
      "es": "0.9814650046241105",
      "arb": "0.9656496564253506",
      "sw": "0.944837165100515",
      "tr": "0.9548131773576112",
      "vi": "0.9725026032014352"
    }
  }
]