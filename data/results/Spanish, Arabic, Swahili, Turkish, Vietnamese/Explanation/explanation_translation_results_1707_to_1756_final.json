[
  {
    "task_id": "Shell/1",
    "prompt": {
      "en": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Check if in given list of numbers, are any two numbers closer to each other than\n#given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "es": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "arb": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#تحقق مما إذا كان في قائمة الأرقام المعطاة، هناك أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "sw": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari zozote mbili zilizo karibu zaidi kuliko\n#kizingiti kilichotolewa.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "tr": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n# Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol et.\n# >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n# False\n# >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n# True",
      "vi": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n#ngưỡng đã cho hay không.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True"
    },
    "prompt_bertscore": {
      "es": "0.9812979564736601",
      "arb": "0.981240155032779",
      "sw": "0.9775351025353352",
      "tr": "0.9496400477139386",
      "vi": "0.9729614393816258"
    },
    "canonical_solution": "local n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}",
    "instruction": {
      "en": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n\nlocal n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n\nlocal n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n\nlocal n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n\nlocal n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n\nlocal n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}\n\nTürkçe olarak Shell kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir açıklama (docstring) sağlayın.",
      "vi": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n\nlocal n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.920868238390654",
      "sw": "0.9148459638680573",
      "tr": "0.8624389268750503",
      "vi": "0.9237231528572685"
    },
    "level": "",
    "test": "# Testing function\ntest_close_elements() {\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.3) == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.05) == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.95) == \"true\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.8) == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.0 4.0 5.0 2.0\" 0.1) == \"true\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 1.0) == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 0.5) == \"false\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_close_elements",
    "entry_point": "has_close_elements",
    "signature": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "es": "0.9730839943267243",
      "arb": "0.9761581967340013",
      "sw": "0.9613546716962332",
      "tr": "0.9587311616235243",
      "vi": "0.9739565775906106"
    }
  },
  {
    "task_id": "Shell/2",
    "prompt": {
      "en": "#!/bin/bash\n\n# Function to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "es": "#!/bin/bash\n\n# Función para encontrar el tercer número más grande en un array. Si el tercer número más grande no existe, devuelve el número más grande.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "arb": "#!/bin/bash\n\n# دالة للعثور على ثالث أكبر عدد في مصفوفة. إذا لم يكن هناك ثالث أكبر عدد، تعيد الدالة أكبر عدد.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "sw": "#!/bin/bash\n\n# Kazi ya kupata nambari ya tatu kwa ukubwa katika safu. Ikiwa nambari ya tatu kwa ukubwa haipo, inarudisha nambari kubwa zaidi.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "tr": "#!/bin/bash\n\n# Bir dizideki üçüncü en büyük sayıyı bulmak için fonksiyon. Eğer üçüncü en büyük sayı yoksa, en büyük sayıyı döndürür.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "vi": "#!/bin/bash\n\n# Hàm để tìm số lớn thứ ba trong một mảng. Nếu số lớn thứ ba không tồn tại, trả về số lớn nhất.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)"
    },
    "prompt_bertscore": {
      "es": "0.9954048847651389",
      "arb": "0.9734208714529595",
      "sw": "0.9886969381672097",
      "tr": "0.9845096111046132",
      "vi": "0.9985917105984626"
    },
    "canonical_solution": "local n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}",
    "instruction": {
      "en": "third_largest_number() {\nlocal numbers=($1)\nlocal n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "third_largest_number() {\nlocal numbers=($1)\nlocal n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "third_largest_number() {\nlocal numbers=($1)\nlocal n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود الشيل باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "third_largest_number() {\nlocal numbers=($1)\nlocal n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "third_largest_number() {\nlocal numbers=($1)\nlocal n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "third_largest_number() {\nlocal numbers=($1)\nlocal n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9172239667898069",
      "sw": "0.9148459638680573",
      "tr": "0.8521282224259102",
      "vi": "0.9388570002186977"
    },
    "level": "",
    "test": "test_third_largest_number() {\n[[ $(third_largest_number \"4 5 1 3 2\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(third_largest_number \"10 5 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(third_largest_number \"7 7 7 7\") == \"7\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(third_largest_number \"9 8 7 6 5\") == \"7\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(third_largest_number \"1 2\") == \"2\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(third_largest_number \"3 3 3 2 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(third_largest_number \"1\") == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_third_largest_number",
    "entry_point": "third_largest_number",
    "signature": "third_largest_number() {\nlocal numbers=($1)",
    "docstring": {
      "en": "\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n",
      "es": "Función para encontrar el tercer número más grande en un arreglo. Si el tercer número más grande no existe, devuelve el número más grande.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "arb": "دالة للعثور على ثالث أكبر رقم في مصفوفة. إذا لم يكن هناك ثالث أكبر رقم، تُرجع أكبر رقم.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "sw": "Kazi ya kupata nambari ya tatu kwa ukubwa katika safu. Ikiwa nambari ya tatu kwa ukubwa haipo, inarudisha nambari kubwa zaidi.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "tr": "Bir dizideki üçüncü en büyük sayıyı bulmak için fonksiyon. Üçüncü en büyük sayı mevcut değilse, en büyük sayıyı döndürür.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "vi": "Hàm để tìm số lớn thứ ba trong một mảng. Nếu số lớn thứ ba không tồn tại, trả về số lớn nhất.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9979241138878043",
      "arb": "0.9618542271045359",
      "sw": "0.9914495579875912",
      "tr": "0.9773958626382298",
      "vi": "0.9979241138878043"
    }
  },
  {
    "task_id": "Shell/3",
    "prompt": {
      "en": "#!/bin/bash\n\n# Calculate taxes based on a progressive tax bracket system.\n# The function takes two arguments:\n# 1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n# 2. An integer representing the total income.\n# It returns the total tax amount.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "es": "#!/bin/bash\n\n# Calcular impuestos basados en un sistema de tramos impositivos progresivos.\n# La función toma dos argumentos:\n# 1. Una cadena que representa los tramos impositivos en el formato \"upper0 percent0 upper1 percent1 ...\"\n# 2. Un entero que representa el ingreso total.\n# Devuelve el monto total de impuestos.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "arb": "#!/bin/bash\n\n# حساب الضرائب بناءً على نظام الشرائح الضريبية التصاعدي.\n# تأخذ الدالة وسيطين:\n# 1. سلسلة تمثل الشرائح الضريبية بالصيغة \"upper0 percent0 upper1 percent1 ...\"\n# 2. عدد صحيح يمثل إجمالي الدخل.\n# تُرجع المبلغ الإجمالي للضريبة.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "sw": "#!/bin/bash\n\n# Kuhesabu kodi kulingana na mfumo wa viwango vya kodi vinavyoongezeka.\n# Kazi inachukua hoja mbili:\n# 1. Mstari wa maandishi unaowakilisha viwango vya kodi katika muundo \"upper0 percent0 upper1 percent1 ...\"\n# 2. Nambari kamili inayowakilisha jumla ya mapato.\n# Inarudisha jumla ya kiasi cha kodi.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "tr": "#!/bin/bash\n\n# Vergileri kademeli bir vergi dilimi sistemine göre hesapla.\n# Fonksiyon iki argüman alır:\n# 1. Vergi dilimlerini \"üst0 yüzde0 üst1 yüzde1 ...\" formatında temsil eden bir dize\n# 2. Toplam geliri temsil eden bir tamsayı.\n# Toplam vergi miktarını döndürür.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "vi": "#!/bin/bash\n\n# Tính thuế dựa trên hệ thống thuế lũy tiến.\n# Hàm này nhận hai tham số:\n# 1. Một chuỗi đại diện cho các khung thuế theo định dạng \"upper0 percent0 upper1 percent1 ...\"\n# 2. Một số nguyên đại diện cho tổng thu nhập.\n# Nó trả về tổng số tiền thuế.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2"
    },
    "prompt_bertscore": {
      "es": "0.992166415032746",
      "arb": "0.9936666703007025",
      "sw": "0.9875564025193073",
      "tr": "0.9914926607802758",
      "vi": "0.9922037575443806"
    },
    "canonical_solution": "local tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}",
    "instruction": {
      "en": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2\nlocal tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2\nlocal tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2\nlocal tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2\nlocal tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2\nlocal tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2\nlocal tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.920868238390654",
      "sw": "0.9148459638680573",
      "tr": "0.8487360127785964",
      "vi": "0.8947882679911542"
    },
    "level": "",
    "test": "# Testing function\ntest_calculate_tax() {\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 25000) == \"4500\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 15000) == \"2000\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 12000) == \"1150\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 5000) == \"250\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20\" 0) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_tax",
    "entry_point": "calculate_tax",
    "signature": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
    "docstring": {
      "en": "\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n",
      "es": "Calcular impuestos basados en un sistema de tramos impositivos progresivos.  \nLa función toma dos argumentos:  \n1. Una cadena que representa los tramos impositivos en el formato \"upper0 percent0 upper1 percent1 ...\"  \n2. Un entero que representa el ingreso total.  \nDevuelve el monto total de impuestos.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "arb": "حساب الضرائب بناءً على نظام شريحة ضريبية تصاعدي.  \nتأخذ الدالة وسيطين:  \n1. سلسلة نصية تمثل الشرائح الضريبية بالتنسيق \"upper0 percent0 upper1 percent1 ...\"  \n2. عدد صحيح يمثل إجمالي الدخل.  \nتعيد المبلغ الإجمالي للضريبة.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "sw": "Hesabu kodi kulingana na mfumo wa viwango vya kodi vya maendeleo. \nKazi inachukua hoja mbili: \n1. Kamba inayowakilisha viwango vya kodi katika muundo \"upper0 percent0 upper1 percent1 ...\" \n2. Nambari kamili inayowakilisha jumla ya mapato. \nInarudisha kiasi cha jumla cha kodi. \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "tr": "Progressif bir vergi dilimi sistemine göre vergileri hesaplayın.\nFonksiyon iki argüman alır:\n1. \"üst0 yüzde0 üst1 yüzde1 ...\" formatında vergi dilimlerini temsil eden bir dize.\n2. Toplam geliri temsil eden bir tamsayı.\nToplam vergi miktarını döndürür.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "vi": "Tính thuế dựa trên hệ thống khung thuế lũy tiến.  \nHàm nhận hai đối số:  \n1. Một chuỗi đại diện cho các khung thuế theo định dạng \"upper0 percent0 upper1 percent1 ...\"  \n2. Một số nguyên đại diện cho tổng thu nhập.  \nNó trả về tổng số tiền thuế.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  "
    },
    "docstring_bertscore": {
      "es": "0.9922385178610618",
      "arb": "0.9932410053941448",
      "sw": "0.9801598043903302",
      "tr": "0.9812481002480203",
      "vi": "0.998502724187759"
    }
  },
  {
    "task_id": "Shell/4",
    "prompt": {
      "en": "#!/bin/bash\n\n# Check if a given square matrix is an X Matrix.\n# An X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\n# The function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\n# Returns true if it's an X Matrix, false otherwise.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "es": "#!/bin/bash\n\n# Verifica si una matriz cuadrada dada es una Matriz X.\n# Una Matriz X tiene elementos no cero en sus diagonales y elementos cero en otros lugares.\n# La función toma un único argumento de cadena que representa la matriz, donde las filas están separadas por punto y coma y los elementos por espacios.\n# Devuelve verdadero si es una Matriz X, falso en caso contrario.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "arb": "#!/bin/bash\n\n# التحقق مما إذا كانت المصفوفة المربعة المعطاة هي مصفوفة X.\n# تحتوي مصفوفة X على عناصر غير صفرية على أقطارها وعناصر صفرية في أماكن أخرى.\n# تأخذ الدالة وسيطًا نصيًا واحدًا يمثل المصفوفة، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\n# تعيد true إذا كانت مصفوفة X، false خلاف ذلك.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "sw": "#!/bin/bash\n\n# Angalia kama mraba uliotolewa ni Matriksi ya X.\n# Matriksi ya X ina vipengele visivyo sifuri kwenye diagonali zake na vipengele vya sifuri kwingineko.\n# Kazi inachukua hoja moja ya kamba inayowakilisha matriksi, ambapo safu zimegawanywa kwa semikoli na vipengele kwa nafasi.\n# Inarejesha kweli ikiwa ni Matriksi ya X, vinginevyo si kweli.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "tr": "#!/bin/bash\n\n# Verilen bir kare matrisin X Matrisi olup olmadığını kontrol edin.\n# Bir X Matrisi, köşegenlerinde sıfır olmayan elemanlara ve diğer yerlerde sıfır elemanlara sahiptir.\n# Fonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı matrisi temsil eden tek bir dize argümanı alır.\n# X Matrisi ise true, değilse false döndürür.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "vi": "#!/bin/bash\n\n# Kiểm tra xem một ma trận vuông cho trước có phải là ma trận X hay không.\n# Một ma trận X có các phần tử khác 0 trên đường chéo và các phần tử 0 ở các vị trí khác.\n# Hàm nhận một đối số chuỗi duy nhất đại diện cho ma trận, trong đó các hàng được ngăn cách bằng dấu chấm phẩy và các phần tử được ngăn cách bằng dấu cách.\n# Trả về true nếu nó là ma trận X, false nếu không phải.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\""
    },
    "prompt_bertscore": {
      "es": "0.9984304227290624",
      "arb": "0.9928697652119907",
      "sw": "0.990509639024534",
      "tr": "0.9931728751734499",
      "vi": "0.9714331772299434"
    },
    "canonical_solution": "local n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}",
    "instruction": {
      "en": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"\nlocal n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"\nlocal n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"\nlocal n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"\nlocal n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"\nlocal n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"\nlocal n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8604031640998236",
      "sw": "0.9429899025568905",
      "tr": "0.8195280111385592",
      "vi": "0.9275384452161866"
    },
    "level": "",
    "test": "# Testing function\ntest_is_x_matrix() {\n[[ $(is_x_matrix \"1 0 0;0 1 0;0 0 1\") == \"false\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 2;0 1 0;3 0 1\") == \"true\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(is_x_matrix \"2 0 0 0;0 3 0 0;0 0 5 0;0 0 0 7\") == \"false\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 0;0 0 0;0 0 1\") == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(is_x_matrix \"0\") == \"false\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(is_x_matrix \"5\") == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 1;0 1 0;1 0 1\") == \"true\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_is_x_matrix",
    "entry_point": "is_x_matrix",
    "signature": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
    "docstring": {
      "en": "\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "es": "Verificar si una matriz cuadrada dada es una Matriz X.  \nUna Matriz X tiene elementos no nulos en sus diagonales y elementos nulos en otros lugares.  \nLa función toma un único argumento de cadena que representa la matriz, donde las filas están separadas por punto y coma y los elementos por espacios.  \nDevuelve verdadero si es una Matriz X, falso en caso contrario.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "arb": "التحقق مما إذا كانت المصفوفة المربعة المعطاة هي مصفوفة X.  \nالمصفوفة X تحتوي على عناصر غير صفرية على أقطارها وعناصر صفرية في أماكن أخرى.  \nتأخذ الدالة وسيطًا نصيًا واحدًا يمثل المصفوفة، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.  \nتعيد true إذا كانت مصفوفة X، false خلاف ذلك.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "sw": "Angalia kama mraba uliotolewa wa matrix ni X Matrix.  \nX Matrix ina vipengele visivyo sifuri kwenye diagonali zake na vipengele vya sifuri sehemu nyingine.  \nKazi inachukua hoja moja ya kamba inayowakilisha matrix, ambapo safu zimegawanywa na alama ya semicolon na vipengele kwa nafasi.  \nInarejesha kweli ikiwa ni X Matrix, vinginevyo ni uongo.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "tr": "Verilen bir kare matrisin bir X Matrisi olup olmadığını kontrol edin.  \nBir X Matrisi, köşegenlerinde sıfır olmayan elemanlara ve diğer yerlerde sıfır elemanlara sahiptir.  \nFonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı matrisi temsil eden tek bir string argümanı alır.  \nEğer bir X Matrisi ise true, aksi halde false döner.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "vi": "Kiểm tra xem một ma trận vuông cho trước có phải là ma trận X hay không.  \nMột ma trận X có các phần tử khác không trên các đường chéo của nó và các phần tử bằng không ở những nơi khác.  \nHàm nhận một đối số chuỗi duy nhất đại diện cho ma trận, trong đó các hàng được ngăn cách bằng dấu chấm phẩy và các phần tử được ngăn cách bằng khoảng trắng.  \nTrả về true nếu đó là ma trận X, false nếu không.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  "
    },
    "docstring_bertscore": {
      "es": "0.9976132573414848",
      "arb": "0.9830735134497309",
      "sw": "0.9766613274891627",
      "tr": "0.9907924886871278",
      "vi": "0.984582111193691"
    }
  },
  {
    "task_id": "Shell/5",
    "prompt": {
      "en": "#!/bin/bash\n\n# Perform operations on an array to remove pairs of equal integers.\n# Returns a two-element array: [number of pairs formed, number of remaining integers].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "es": "#!/bin/bash\n\n# Realiza operaciones en un arreglo para eliminar pares de enteros iguales.\n# Devuelve un arreglo de dos elementos: [número de pares formados, número de enteros restantes].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "arb": "#!/bin/bash\n\n# تنفيذ العمليات على مصفوفة لإزالة أزواج الأعداد الصحيحة المتساوية.\n# يعيد مصفوفة مكونة من عنصرين: [عدد الأزواج المتكونة، عدد الأعداد المتبقية].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "sw": "#!/bin/bash\n\n# Fanya shughuli kwenye safu ili kuondoa jozi za namba sawa.\n# Inarudisha safu yenye vipengele viwili: [idadi ya jozi zilizoundwa, idadi ya namba zilizobaki].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "tr": "#!/bin/bash\n\n# Eşit tam sayı çiftlerini kaldırmak için bir dizi üzerinde işlemler yapar.\n# İki elemanlı bir dizi döndürür: [oluşturulan çiftlerin sayısı, kalan tam sayıların sayısı].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "vi": "#!/bin/bash\n\n# Thực hiện các thao tác trên một mảng để loại bỏ các cặp số nguyên bằng nhau.\n# Trả về một mảng hai phần tử: [số cặp được tạo thành, số lượng số nguyên còn lại].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)"
    },
    "prompt_bertscore": {
      "es": "0.9830061777505601",
      "arb": "0.9785985695953959",
      "sw": "0.9717980612399045",
      "tr": "0.9847300908275619",
      "vi": "0.9959904471284298"
    },
    "canonical_solution": "local -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}",
    "instruction": {
      "en": "process_array() {\nlocal nums=($1)\nlocal -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "process_array() {\nlocal nums=($1)\nlocal -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "process_array() {\nlocal nums=($1)\nlocal -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "process_array() {\nlocal nums=($1)\nlocal -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "process_array() {\nlocal nums=($1)\nlocal -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}\n\nAşağıdaki Shell kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "process_array() {\nlocal nums=($1)\nlocal -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.9274705136258726",
      "tr": "0.865477375813741",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "# Testing function\ntest_process_array() {\n[[ $(process_array \"3 1 2 3 2\") == \"2 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(process_array \"1 2 3 4\") == \"0 4\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(process_array \"5 5 5 5 5\") == \"2 1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(process_array \"1 1 2 2 3 3 4 4\") == \"4 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(process_array \"1\") == \"0 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(process_array \"\") == \"0 0\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(process_array \"2 2 2 2 3 3 3\") == \"3 1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_process_array",
    "entry_point": "process_array",
    "signature": "process_array() {\nlocal nums=($1)",
    "docstring": {
      "en": "\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n",
      "es": "Realiza operaciones en un arreglo para eliminar pares de enteros iguales.\nDevuelve un arreglo de dos elementos: [número de pares formados, número de enteros restantes].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "arb": "إجراء عمليات على مصفوفة لإزالة أزواج من الأعداد الصحيحة المتساوية.  \nيعيد مصفوفة مكونة من عنصرين: [عدد الأزواج المتكونة، عدد الأعداد الصحيحة المتبقية].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "sw": "Fanya shughuli kwenye safu ili kuondoa jozi za namba sawa.\nRudisha safu yenye vipengele viwili: [idadi ya jozi zilizoundwa, idadi ya namba zilizobaki].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "tr": "Dizideki eşit tamsayı çiftlerini kaldırmak için işlemler yapın.\nİki elemanlı bir dizi döndürür: [oluşturulan çift sayısı, kalan tamsayı sayısı].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "vi": "Thực hiện các thao tác trên một mảng để loại bỏ các cặp số nguyên bằng nhau.  \nTrả về một mảng hai phần tử: [số cặp được hình thành, số lượng số nguyên còn lại].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  "
    },
    "docstring_bertscore": {
      "es": "0.9741480572779283",
      "arb": "0.9829741982592135",
      "sw": "0.9631979616322369",
      "tr": "0.9361580106011955",
      "vi": "0.9967585508118917"
    }
  },
  {
    "task_id": "Shell/6",
    "prompt": {
      "en": "#!/bin/bash\n\n# Evaluate poker hands based on given ranks and suits.\n# The function takes two strings: one for ranks and one for suits, each value separated by spaces.\n# Returns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "es": "#!/bin/bash\n\n# Evalúa manos de póker basadas en los rangos y palos dados.\n# La función toma dos cadenas: una para rangos y otra para palos, cada valor separado por espacios.\n# Devuelve el mejor tipo de mano: \"Flush\", \"Three of a Kind\", \"Pair\", o \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "arb": "#!/bin/bash\n\n# تقييم أيدي البوكر بناءً على الرتب والأنواع المعطاة.\n# تأخذ الدالة سلسلتين: واحدة للرتب وواحدة للأنواع، كل قيمة مفصولة بمسافات.\n# تعيد نوع اليد الأفضل: \"Flush\"، \"Three of a Kind\"، \"Pair\"، أو \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "sw": "#!/bin/bash\n\n# Tambua mikono ya poker kulingana na vyeo na suti zilizotolewa.\n# Kazi inachukua mistari miwili: moja kwa vyeo na nyingine kwa suti, kila thamani ikitenganishwa na nafasi.\n# Inarudisha aina bora ya mkono: \"Flush\", \"Three of a Kind\", \"Pair\", au \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "tr": "#!/bin/bash\n\n# Verilen sıralamalar ve renkler temelinde poker ellerini değerlendirir.\n# Fonksiyon, her biri boşluklarla ayrılmış değerler olan iki dize alır: biri sıralamalar için, diğeri renkler için.\n# En iyi el tipini döndürür: \"Flush\", \"Üçlü\", \"Çift\" veya \"Yüksek Kart\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Üçlü\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "vi": "#!/bin/bash\n\n# Đánh giá bài poker dựa trên các hạng và chất cho trước.\n# Hàm nhận hai chuỗi: một cho hạng và một cho chất, mỗi giá trị được tách bằng dấu cách.\n# Trả về loại bài tốt nhất: \"Flush\", \"Three of a Kind\", \"Pair\", hoặc \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)"
    },
    "prompt_bertscore": {
      "es": "0.9876291012387661",
      "arb": "0.9962494611452992",
      "sw": "0.9635423867129514",
      "tr": "0.973041884685945",
      "vi": "0.9831380683235673"
    },
    "canonical_solution": "local -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand",
    "instruction": {
      "en": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)\nlocal -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)\nlocal -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)\nlocal -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)\nlocal -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)\nlocal -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)\nlocal -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9343580220882574",
      "sw": "0.9148459638680573",
      "tr": "0.8547378283719466",
      "vi": "0.9147003677987586"
    },
    "level": "",
    "test": "# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand",
    "entry_point": "evaluate_hand",
    "signature": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
    "docstring": {
      "en": "\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n",
      "es": "Evalúa manos de póker basadas en los rangos y palos dados.  \nLa función toma dos cadenas: una para los rangos y otra para los palos, cada valor separado por espacios.  \nDevuelve el mejor tipo de mano: \"Flush\", \"Three of a Kind\", \"Pair\", o \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "arb": "تقييم أيدي البوكر بناءً على الرتب والأنواع المعطاة.  \nتأخذ الدالة سلسلتين: واحدة للرتب وواحدة للأنواع، كل قيمة مفصولة بمسافات.  \nتُرجع أفضل نوع يد: \"Flush\"، \"Three of a Kind\"، \"Pair\"، أو \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "sw": "Tambua mikono ya poker kulingana na vyeo na suti zilizotolewa.  \nKazi inachukua mistari miwili: moja kwa vyeo na nyingine kwa suti, kila thamani ikitenganishwa na nafasi.  \nInarudisha aina bora ya mkono: \"Flush\", \"Three of a Kind\", \"Pair\", au \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "tr": "Verilen sıralamalar ve türlere göre poker ellerini değerlendirir.\nFonksiyon, her biri boşluklarla ayrılmış değerler olan iki dize alır: biri sıralamalar için, diğeri türler için.\nEn iyi el türünü döndürür: \"Flush\", \"Three of a Kind\", \"Pair\" veya \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "vi": "Đánh giá tay bài poker dựa trên các hạng và chất bài đã cho.  \nHàm nhận hai chuỗi: một cho hạng và một cho chất bài, mỗi giá trị được ngăn cách bởi dấu cách.  \nTrả về loại tay bài tốt nhất: \"Flush\", \"Three of a Kind\", \"Pair\", hoặc \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  "
    },
    "docstring_bertscore": {
      "es": "0.9735529606563478",
      "arb": "0.9951635488521815",
      "sw": "0.9536442375652209",
      "tr": "0.9719184312508117",
      "vi": "0.9704922651149811"
    }
  },
  {
    "task_id": "Shell/7",
    "prompt": {
      "en": "#!/bin/bash\n\n# Calculate the minimum number of operations to reduce all elements of an array to zero.\n# Each operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the minimum number of operations required.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "es": "#!/bin/bash\n\n# Calcular el número mínimo de operaciones para reducir todos los elementos de un array a cero.\n# Cada operación consiste en restar un entero positivo x (menor o igual al elemento no cero más pequeño) de cada elemento positivo en el array.\n# La función toma una cadena que representa el array, con elementos separados por espacios.\n# Devuelve el número mínimo de operaciones requeridas.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "arb": "#!/bin/bash\n\n# حساب الحد الأدنى لعدد العمليات لتقليل جميع عناصر المصفوفة إلى الصفر.\n# تتكون كل عملية من طرح عدد صحيح موجب x (أقل من أو يساوي أصغر عنصر غير صفري) من كل عنصر موجب في المصفوفة.\n# تأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\n# تعيد الحد الأدنى لعدد العمليات المطلوبة.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "sw": "#!/bin/bash\n\n# Hesabu idadi ndogo zaidi ya operesheni za kupunguza vipengele vyote vya safu hadi sifuri.\n# Kila operesheni inajumuisha kutoa namba nzima chanya x (ndogo au sawa na kipengele kidogo zaidi kisicho sifuri) kutoka kwa kila kipengele chanya katika safu.\n# Kazi inachukua kamba inayoashiria safu, na vipengele vikitenganishwa na nafasi.\n# Inarudisha idadi ndogo zaidi ya operesheni zinazohitajika.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "tr": "#!/bin/bash\n\n# Bir dizideki tüm elemanları sıfıra indirmek için gereken minimum işlem sayısını hesaplayın.\n# Her işlem, dizideki her pozitif elemandan pozitif bir tamsayı x (sıfır olmayan en küçük elemana eşit veya daha küçük) çıkarmaktan oluşur.\n# Fonksiyon, elemanları boşluklarla ayrılmış bir dizi temsil eden bir dize alır.\n# Gerekli minimum işlem sayısını döndürür.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "vi": "#!/bin/bash\n\n# Tính số lượng thao tác tối thiểu để giảm tất cả các phần tử của một mảng về không.\n# Mỗi thao tác bao gồm việc trừ đi một số nguyên dương x (nhỏ hơn hoặc bằng phần tử nhỏ nhất khác không) từ mỗi phần tử dương trong mảng.\n# Hàm nhận vào một chuỗi đại diện cho mảng, với các phần tử được phân tách bằng dấu cách.\n# Trả về số lượng thao tác tối thiểu cần thiết.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9963257352116166",
      "sw": "0.9945559385165957",
      "tr": "0.9827076362878647",
      "vi": "0.9957751317953879"
    },
    "canonical_solution": "local operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}",
    "instruction": {
      "en": "min_operations_to_zero() {\nlocal nums=($1)\nlocal operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "min_operations_to_zero() {\nlocal nums=($1)\nlocal operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "min_operations_to_zero() {\nlocal nums=($1)\nlocal operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود الشيل باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "min_operations_to_zero() {\nlocal nums=($1)\nlocal operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "min_operations_to_zero() {\nlocal nums=($1)\nlocal operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yapılmalıdır.",
      "vi": "min_operations_to_zero() {\nlocal nums=($1)\nlocal operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9310005727576247",
      "sw": "0.8784135766394001",
      "tr": "0.8521282224259102",
      "vi": "0.90164717367867"
    },
    "level": "",
    "test": "test_min_operations_to_zero() {\n[[ $(min_operations_to_zero \"3 3 2 2 1\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"4 0 0 4\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 2 3 4 5\") == \"5\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"5 5 5 5 5\") == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 1 1 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"10 10 10 10 20\") == \"2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_min_operations_to_zero",
    "entry_point": "min_operations_to_zero",
    "signature": "min_operations_to_zero() {\nlocal nums=($1)",
    "docstring": {
      "en": "\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "es": "Calcular el número mínimo de operaciones para reducir todos los elementos de un arreglo a cero.\nCada operación consiste en restar un entero positivo x (menor o igual al elemento no cero más pequeño) de cada elemento positivo en el arreglo.\nLa función toma una cadena que representa el arreglo, con elementos separados por espacios.\nDevuelve el número mínimo de operaciones requeridas.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "arb": "احسب الحد الأدنى لعدد العمليات لتقليل جميع عناصر المصفوفة إلى الصفر.\nتتكون كل عملية من طرح عدد صحيح موجب x (أقل من أو يساوي أصغر عنصر غير صفري) من كل عنصر موجب في المصفوفة.\nتأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\nتعيد الحد الأدنى لعدد العمليات المطلوبة.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "sw": "Hesabu idadi ndogo ya operesheni za kupunguza vipengele vyote vya safu hadi sifuri.\nKila operesheni inajumuisha kutoa nambari kamili chanya x (ndogo au sawa na kipengele kidogo kisicho sifuri) kutoka kwa kila kipengele chanya katika safu.\nKazi inachukua kamba inayowakilisha safu, na vipengele vilivyotenganishwa na nafasi.\nRudisha idadi ndogo ya operesheni zinazohitajika.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "tr": "Tüm bir dizinin elemanlarını sıfıra indirmek için gereken minimum işlem sayısını hesaplayın. Her işlem, dizideki her pozitif elemandan, pozitif bir tamsayı x'in (sıfırdan farklı en küçük elemana eşit veya daha küçük) çıkarılmasından oluşur. Fonksiyon, elemanların boşluklarla ayrıldığı diziyi temsil eden bir dize alır. Gerekli minimum işlem sayısını döndürür.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "vi": "Tính toán số lượng tối thiểu các phép toán để giảm tất cả các phần tử của một mảng về không.\nMỗi phép toán bao gồm việc trừ một số nguyên dương x (nhỏ hơn hoặc bằng phần tử dương nhỏ nhất) từ mỗi phần tử dương trong mảng.\nHàm nhận một chuỗi đại diện cho mảng, với các phần tử được phân tách bằng dấu cách.\nTrả về số lượng tối thiểu các phép toán cần thiết.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9938654993121185",
      "sw": "0.9949134732024586",
      "tr": "0.9763508682036052",
      "vi": "0.9790977277429367"
    }
  },
  {
    "task_id": "Shell/8",
    "prompt": {
      "en": "#!/bin/bash\n\n# Merge two sets of items and sum the weights of items with the same value.\n# Each item is represented as [value, weight].\n# The function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\n# Returns a sorted array of unique values and their cumulative weights.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "es": "#!/bin/bash\n\n# Fusionar dos conjuntos de elementos y sumar los pesos de los elementos con el mismo valor.\n# Cada elemento se representa como [valor, peso].\n# La función toma dos cadenas, cada una representando un arreglo de elementos, donde los elementos están separados por punto y coma y los valores por espacios.\n# Devuelve un arreglo ordenado de valores únicos y sus pesos acumulados.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "arb": "#!/bin/bash\n\n# دمج مجموعتين من العناصر وجمع أوزان العناصر ذات القيمة نفسها.\n# يتم تمثيل كل عنصر كـ [قيمة، وزن].\n# تأخذ الدالة سلسلتين، كل واحدة تمثل مصفوفة من العناصر، حيث يتم فصل العناصر بفواصل منقوطة والقيم بمسافات.\n# تعيد مصفوفة مرتبة من القيم الفريدة وأوزانها التراكمية.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "sw": "#!/bin/bash\n\n# Unganisha seti mbili za vitu na jumlisha uzito wa vitu vyenye thamani sawa.\n# Kila kipengee kinawakilishwa kama [thamani, uzito].\n# Kazi inachukua mistari miwili, kila moja ikiwakilisha safu ya vitu, ambapo vitu vinatenganishwa na alama ya nukta na mkato na thamani kwa nafasi.\n# Inarudisha safu iliyopangwa ya thamani za kipekee na uzito wao wa jumla.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "tr": "#!/bin/bash\n\n# İki öğe kümesini birleştir ve aynı değere sahip öğelerin ağırlıklarını topla.\n# Her öğe [değer, ağırlık] olarak temsil edilir.\n# Fonksiyon, her biri öğeleri temsil eden iki dize alır, burada öğeler noktalı virgülle ve değerler boşlukla ayrılmıştır.\n# Benzersiz değerlerin ve bunların kümülatif ağırlıklarının sıralı bir dizisini döndürür.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "vi": "#!/bin/bash\n\n# Gộp hai tập hợp các mục và tính tổng trọng lượng của các mục có cùng giá trị.\n# Mỗi mục được biểu diễn dưới dạng [giá trị, trọng lượng].\n# Hàm nhận hai chuỗi, mỗi chuỗi đại diện cho một mảng các mục, trong đó các mục được ngăn cách bằng dấu chấm phẩy và các giá trị bằng dấu cách.\n# Trả về một mảng đã sắp xếp các giá trị duy nhất và trọng lượng tích lũy của chúng.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })"
    },
    "prompt_bertscore": {
      "es": "0.9760040595583183",
      "arb": "1",
      "sw": "0.9738799062635312",
      "tr": "0.9775265614289507",
      "vi": "0.986141955575958"
    },
    "canonical_solution": "local -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}",
    "instruction": {
      "en": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })\nlocal -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })\nlocal -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español usando como máximo 500 caracteres.",
      "arb": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })\nlocal -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })\nlocal -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })\nlocal -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })\nlocal -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8841772344058895",
      "sw": "0.9148459638680573",
      "tr": "0.8589893130476174",
      "vi": "0.8947882679911542"
    },
    "level": "",
    "test": "test_merge_items() {\n[[ $(merge_items \"10 5;15 10\" \"15 15;20 20\") == \"10 5;15 25;20 20;\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(merge_items \"1 2;3 4\" \"5 6;7 8\") == \"1 2;3 4;5 6;7 8;\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(merge_items \"2 2;4 4\" \"2 3;4 5\") == \"2 5;4 9;\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(merge_items \"\" \"\") == \"\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(merge_items \"10 10\" \"10 10\") == \"10 20;\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(merge_items \"1 1;2 2;3 3\" \"4 4;5 5;6 6\") == \"1 1;2 2;3 3;4 4;5 5;6 6;\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(merge_items \"9 9;8 8\" \"7 7;6 6\") == \"6 6;7 7;8 8;9 9;\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_merge_items",
    "entry_point": "merge_items",
    "signature": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
    "docstring": {
      "en": "\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n",
      "es": "Fusionar dos conjuntos de elementos y sumar los pesos de los elementos con el mismo valor.\nCada elemento se representa como [valor, peso].\nLa función toma dos cadenas, cada una representando un arreglo de elementos, donde los elementos están separados por punto y coma y los valores por espacios.\nDevuelve un arreglo ordenado de valores únicos y sus pesos acumulativos.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "arb": "دمج مجموعتين من العناصر وجمع أوزان العناصر ذات القيمة نفسها.  \nيتم تمثيل كل عنصر كـ [قيمة، وزن].  \nتأخذ الدالة سلسلتين، كل منهما تمثل مصفوفة من العناصر، حيث يتم فصل العناصر بفواصل منقوطة والقيم بمسافات.  \nتعيد مصفوفة مرتبة من القيم الفريدة وأوزانها التراكمية.  \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"  \n10 5;15 25;20 20  ",
      "sw": "Unganisha seti mbili za vitu na jumlisha uzito wa vitu vyenye thamani sawa.  \nKila kipengee kinawakilishwa kama [thamani, uzito].  \nKazi inachukua mistari miwili, kila moja ikiwakilisha safu ya vitu, ambapo vitu vinatenganishwa na alama ya nukta na mkato na thamani kwa nafasi.  \nInarudisha safu iliyopangwa ya thamani za kipekee na uzito wao wa jumla.  \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"  \n10 5;15 25;20 20  ",
      "tr": "İki öğe kümesini birleştir ve aynı değere sahip öğelerin ağırlıklarını topla.\nHer öğe [değer, ağırlık] olarak temsil edilir.\nFonksiyon, her biri öğeleri noktalı virgülle ve değerleri boşlukla ayıran bir dizi öğeyi temsil eden iki dize alır.\nBenzersiz değerlerin ve bunların kümülatif ağırlıklarının sıralı bir dizisini döndürür.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "vi": "Gộp hai tập hợp các mục và cộng tổng trọng lượng của các mục có cùng giá trị.\nMỗi mục được biểu diễn dưới dạng [giá trị, trọng lượng].\nHàm nhận hai chuỗi, mỗi chuỗi đại diện cho một mảng các mục, trong đó các mục được phân tách bằng dấu chấm phẩy và các giá trị bằng dấu cách.\nTrả về một mảng đã sắp xếp các giá trị duy nhất và trọng lượng tích lũy của chúng.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20"
    },
    "docstring_bertscore": {
      "es": "0.9723808427778609",
      "arb": "1",
      "sw": "0.9713155880443708",
      "tr": "0.9554114520652883",
      "vi": "0.9913428934729754"
    }
  },
  {
    "task_id": "Shell/9",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the number of distinct arithmetic triplets in a strictly increasing integer array.\n# A triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\n# The function takes a string representing the array and an integer diff, with elements separated by spaces.\n# Returns the count of distinct arithmetic triplets.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "es": "#!/bin/bash\n\n# Cuenta el número de tripletas aritméticas distintas en un array de enteros estrictamente creciente.\n# Una tripleta (i, j, k) es aritmética si nums[j] - nums[i] == diff y nums[k] - nums[j] == diff.\n# La función toma una cadena que representa el array y un entero diff, con elementos separados por espacios.\n# Devuelve el conteo de tripletas aritméticas distintas.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "arb": "#!/bin/bash\n\n# عد عدد الثلاثيات الحسابية المميزة في مصفوفة أعداد صحيحة تتزايد بصرامة.\n# الثلاثية (i, j, k) تكون حسابية إذا كان nums[j] - nums[i] == diff و nums[k] - nums[j] == diff.\n# تأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا diff، مع العناصر مفصولة بمسافات.\n# تعيد عدد الثلاثيات الحسابية المميزة.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "sw": "#!/bin/bash\n\n# Hesabu idadi ya triplets tofauti za hesabu katika safu ya nambari za mzima inayoongezeka kwa ukali.\n# Triplet (i, j, k) ni ya hesabu ikiwa nums[j] - nums[i] == diff na nums[k] - nums[j] == diff.\n# Kazi inachukua kamba inayowakilisha safu na nambari ya mzima diff, na vipengele vimetenganishwa na nafasi.\n# Inarudisha hesabu ya triplets tofauti za hesabu.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "tr": "#!/bin/bash\n\n# Kesinlikle artan bir tamsayı dizisinde farklı aritmetik üçlülerin sayısını sayar.\n# Bir üçlü (i, j, k) aritmetik ise nums[j] - nums[i] == diff ve nums[k] - nums[j] == diff olur.\n# Fonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize ve bir tamsayı diff alır.\n# Farklı aritmetik üçlülerin sayısını döndürür.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "vi": "#!/bin/bash\n\n# Đếm số bộ ba số học khác nhau trong một mảng số nguyên tăng dần nghiêm ngặt.\n# Một bộ ba (i, j, k) là số học nếu nums[j] - nums[i] == diff và nums[k] - nums[j] == diff.\n# Hàm nhận một chuỗi đại diện cho mảng và một số nguyên diff, với các phần tử được ngăn cách bằng dấu cách.\n# Trả về số lượng bộ ba số học khác nhau.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2"
    },
    "prompt_bertscore": {
      "es": "0.9964925847316859",
      "arb": "0.9924039769684638",
      "sw": "0.9856219412384086",
      "tr": "0.9852836736995062",
      "vi": "0.9928783063183751"
    },
    "canonical_solution": "local count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2\nlocal count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2\nlocal count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2\nlocal count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2\nlocal count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2\nlocal count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2\nlocal count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8990808691556992",
      "sw": "0.9429899025568905",
      "tr": "0.8487360127785964",
      "vi": "0.9147003677987586"
    },
    "level": "",
    "test": "test_count_arithmetic_triplets() {\n[[ $(count_arithmetic_triplets \"1 2 3 4 5\" 1) == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 3 5 7 9\" 2) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"2 4 6 8 10\" 2) == \"3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 4 7 10 13\" 3) == \"3\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 2 4 5 7\" 2) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 5 9 13 17\" 4) == \"3\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"10 20 30 40 50\" 10) == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_arithmetic_triplets",
    "entry_point": "count_arithmetic_triplets",
    "signature": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
    "docstring": {
      "en": "\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n",
      "es": "Cuenta el número de tríos aritméticos distintos en un arreglo de enteros estrictamente creciente.\nUn trío (i, j, k) es aritmético si nums[j] - nums[i] == diff y nums[k] - nums[j] == diff.\nLa función toma una cadena que representa el arreglo y un entero diff, con elementos separados por espacios.\nDevuelve el conteo de tríos aritméticos distintos.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "arb": "احسب عدد الثلاثيات الحسابية المميزة في مصفوفة أعداد صحيحة تزداد بصرامة.\nالثلاثية (i, j, k) تكون حسابية إذا كان nums[j] - nums[i] == diff و nums[k] - nums[j] == diff.\nتأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا diff، مع العناصر مفصولة بمسافات.\nتعيد عدد الثلاثيات الحسابية المميزة.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "sw": "Hesabu idadi ya tatu tofauti za hesabu katika safu ya nambari za mzima zinazoongezeka kwa ukali. \nTatu (i, j, k) ni hesabu ikiwa nums[j] - nums[i] == diff na nums[k] - nums[j] == diff. \nKazi inachukua kamba inayowakilisha safu na nambari mzima diff, na vipengele vimetenganishwa na nafasi. \nInarudisha hesabu ya tatu tofauti za hesabu.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "tr": "Tamamen artan bir tamsayı dizisinde farklı aritmetik üçlülerin sayısını sayın. \nBir üçlü (i, j, k) aritmetik ise nums[j] - nums[i] == diff ve nums[k] - nums[j] == diff olur. \nFonksiyon, diziyi temsil eden bir dize ve bir tamsayı diff alır, elemanlar boşluklarla ayrılır. \nFarklı aritmetik üçlülerin sayısını döndürür.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "vi": "Đếm số bộ ba số học khác nhau trong một mảng số nguyên tăng dần nghiêm ngặt.  \nMột bộ ba (i, j, k) là số học nếu nums[j] - nums[i] == diff và nums[k] - nums[j] == diff.  \nHàm nhận một chuỗi đại diện cho mảng và một số nguyên diff, với các phần tử được ngăn cách bằng dấu cách.  \nTrả về số lượng bộ ba số học khác nhau.  \n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1  \n3  \n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2  \n4  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9797663176055",
      "sw": "0.9848584060537104",
      "tr": "1",
      "vi": "0.9889420480574067"
    }
  },
  {
    "task_id": "Shell/10",
    "prompt": {
      "en": "#!/bin/bash\n\n# Generate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\n# The function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\n# Returns the (n-2) x (n-2) matrix of maximum values.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "es": "#!/bin/bash\n\n# Genera una matriz de valores máximos de cada submatriz 3x3 en una matriz n x n dada.\n# La función toma una cadena que representa la matriz n x n, donde las filas están separadas por punto y coma y los elementos por espacios.\n# Devuelve la matriz (n-2) x (n-2) de valores máximos.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "arb": "#!/bin/bash\n\n# توليد مصفوفة من القيم القصوى من كل مصفوفة فرعية 3x3 في مصفوفة n x n معينة.\n# تأخذ الدالة سلسلة تمثل المصفوفة n x n، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\n# تعيد مصفوفة (n-2) x (n-2) من القيم القصوى.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "sw": "#!/bin/bash\n\n# Tengeneza matrix ya thamani za juu zaidi kutoka kila sub-matrix ya 3x3 katika matrix iliyotolewa ya n x n.\n# Kazi inachukua string inayowakilisha matrix ya n x n, ambapo mistari imetenganishwa na alama ya semicolon na vipengele kwa nafasi.\n# Inarudisha matrix ya (n-2) x (n-2) ya thamani za juu zaidi.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "tr": "#!/bin/bash\n\n# Verilen n x n matrisinde her 3x3 alt matristen maksimum değerlerin bir matrisini oluşturun.\n# Fonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı n x n matrisini temsil eden bir dize alır.\n# Maksimum değerlerin (n-2) x (n-2) matrisini döndürür.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "vi": "#!/bin/bash\n\n# Tạo một ma trận các giá trị lớn nhất từ mỗi ma trận con 3x3 trong một ma trận n x n cho trước.\n# Hàm nhận một chuỗi đại diện cho ma trận n x n, trong đó các hàng được ngăn cách bởi dấu chấm phẩy và các phần tử bởi dấu cách.\n# Trả về ma trận (n-2) x (n-2) của các giá trị lớn nhất.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\""
    },
    "prompt_bertscore": {
      "es": "0.9962335707148164",
      "arb": "0.972324233119266",
      "sw": "0.9762694297473808",
      "tr": "0.984855625228376",
      "vi": "0.9822184096593758"
    },
    "canonical_solution": "local -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}",
    "instruction": {
      "en": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"\nlocal -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"\nlocal -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"\nlocal -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"\nlocal -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"\nlocal -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}\n\nAşağıdaki Shell kodunun işlevini Türkçe olarak en fazla 500 karakter kullanarak açıklayan kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"\nlocal -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8990808691556992",
      "sw": "0.9429899025568905",
      "tr": "0.86620654794252",
      "vi": "0.9042426768676528"
    },
    "level": "",
    "test": "# Testing function\ntest_generate_max_local() {\n[[ $(generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\") == \"11 12 15 16\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_max_local \"9 1 7;4 8 2;3 6 5\") == \"9\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_max_local \"1 2 3;4 5 6;7 8 9\") == \"9\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_max_local \"5 6 7;8 9 10;11 12 13\") == \"13\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_max_local \"10 20 30;40 50 60;70 80 90\") == \"90\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_max_local",
    "entry_point": "generate_max_local",
    "signature": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
    "docstring": {
      "en": "\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "es": "Generar una matriz de valores máximos de cada submatriz 3x3 en una matriz n x n dada.  \nLa función toma una cadena que representa la matriz n x n, donde las filas están separadas por punto y coma y los elementos por espacios.  \nDevuelve la matriz (n-2) x (n-2) de valores máximos.  \n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"  \n11 12;15 16  \n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"  \n9 8  ",
      "arb": "إنشاء مصفوفة من القيم القصوى من كل مصفوفة فرعية 3x3 في مصفوفة n x n معطاة.  \nتأخذ الدالة سلسلة تمثل المصفوفة n x n، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.  \nتعيد المصفوفة (n-2) x (n-2) من القيم القصوى.  \n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"  \n11 12;15 16  \n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"  \n9 8  ",
      "sw": "Tengeneza matriki ya thamani za juu zaidi kutoka kwa kila sub-matriki ya 3x3 katika matriki iliyotolewa ya n x n.\nKazi inachukua kamba inayowakilisha matriki ya n x n, ambapo safu zimegawanywa kwa alama ya nukta na vipengele kwa nafasi.\nInarudisha matriki ya (n-2) x (n-2) ya thamani za juu zaidi.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "tr": "Verilen n x n matrisin her bir 3x3 alt matrisinden maksimum değerlerin bir matrisini oluşturun.\nFonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı n x n matrisini temsil eden bir dize alır.\nMaksimum değerlerin (n-2) x (n-2) matrisini döndürür.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "vi": "Tạo một ma trận các giá trị lớn nhất từ mỗi ma trận con 3x3 trong một ma trận n x n cho trước. \nHàm nhận một chuỗi đại diện cho ma trận n x n, trong đó các hàng được phân tách bằng dấu chấm phẩy và các phần tử bằng dấu cách. \nTrả về ma trận (n-2) x (n-2) của các giá trị lớn nhất.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8"
    },
    "docstring_bertscore": {
      "es": "0.9968618386100297",
      "arb": "0.9585382915235395",
      "sw": "0.9511003782753071",
      "tr": "0.9761119158552202",
      "vi": "0.9747302429247415"
    }
  },
  {
    "task_id": "Shell/11",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the maximum amount of water that can be contained between two lines.\n# The function takes a string representing the array of line heights, with elements separated by spaces.\n# Returns the maximum water container capacity.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "es": "#!/bin/bash\n\n# Encuentra la cantidad máxima de agua que se puede contener entre dos líneas.\n# La función toma una cadena que representa el arreglo de alturas de las líneas, con elementos separados por espacios.\n# Devuelve la capacidad máxima del contenedor de agua.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "arb": "#!/bin/bash\n\n# إيجاد الحد الأقصى من الماء الذي يمكن احتواؤه بين خطين.\n# تأخذ الدالة سلسلة تمثل مصفوفة ارتفاعات الخطوط، مع عناصر مفصولة بمسافات.\n# تعيد سعة حاوية الماء القصوى.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "sw": "#!/bin/bash\n\n# Pata kiasi cha juu zaidi cha maji kinachoweza kushikiliwa kati ya mistari miwili.\n# Kazi inachukua kamba inayowakilisha safu ya urefu wa mistari, na vipengele vimetenganishwa na nafasi.\n# Inarudisha uwezo wa juu zaidi wa chombo cha maji.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "tr": "#!/bin/bash\n\n# İki çizgi arasında tutulabilecek maksimum su miktarını bulun.\n# Fonksiyon, elemanları boşluklarla ayrılmış çizgi yüksekliklerini temsil eden bir dize alır.\n# Maksimum su kabı kapasitesini döndürür.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "vi": "#!/bin/bash\n\n# Tìm lượng nước tối đa có thể chứa giữa hai đường thẳng.\n# Hàm nhận một chuỗi đại diện cho mảng chiều cao của các đường thẳng, với các phần tử được ngăn cách bởi dấu cách.\n# Trả về dung tích chứa nước tối đa.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)"
    },
    "prompt_bertscore": {
      "es": "0.9854838931235893",
      "arb": "0.9971685239183476",
      "sw": "0.9765056012704314",
      "tr": "0.9687683520379794",
      "vi": "0.9954096518942838"
    },
    "canonical_solution": "local max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}",
    "instruction": {
      "en": "max_water_container() {\nlocal -a heights=($1)\nlocal max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "max_water_container() {\nlocal -a heights=($1)\nlocal max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "max_water_container() {\nlocal -a heights=($1)\nlocal max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Shell باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "max_water_container() {\nlocal -a heights=($1)\nlocal max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "max_water_container() {\nlocal -a heights=($1)\nlocal max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "max_water_container() {\nlocal -a heights=($1)\nlocal max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8990808691556992",
      "sw": "0.9136909282023393",
      "tr": "0.8521282224259102",
      "vi": "0.9275384452161866"
    },
    "level": "",
    "test": "test_max_water_container() {\n[[ $(max_water_container \"1 8 6 2 5 4 8 3 7\") == \"49\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(max_water_container \"1 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(max_water_container \"4 3 2 1 4\") == \"16\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 1\") == \"2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(max_water_container \"2 3 4 5 18 17 6\") == \"17\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 4 3\") == \"4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(max_water_container \"3 9 3 4 7 2 12 6\") == \"45\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_max_water_container",
    "entry_point": "max_water_container",
    "signature": "max_water_container() {\nlocal -a heights=($1)",
    "docstring": {
      "en": "\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "es": "Encuentra la cantidad máxima de agua que se puede contener entre dos líneas.\nLa función toma una cadena que representa el arreglo de alturas de las líneas, con elementos separados por espacios.\nDevuelve la capacidad máxima del contenedor de agua.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "arb": "إيجاد الحد الأقصى لكمية الماء التي يمكن احتواؤها بين خطين.\nتأخذ الدالة سلسلة تمثل مصفوفة ارتفاعات الخطوط، مع عناصر مفصولة بمسافات.\nتعيد السعة القصوى لحاوية الماء.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "sw": "Pata kiasi cha juu cha maji kinachoweza kushikiliwa kati ya mistari miwili. \nKazi inachukua kamba inayowakilisha safu ya urefu wa mistari, na vipengele vimetenganishwa na nafasi. \nInarejesha uwezo wa juu wa chombo cha maji. \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "tr": "İki çizgi arasında tutulabilecek maksimum su miktarını bulun.  \nFonksiyon, elemanları boşluklarla ayrılmış çizgi yüksekliklerini temsil eden bir dize alır.  \nMaksimum su kap kapasitesini döndürür.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  ",
      "vi": "Tìm lượng nước tối đa có thể chứa giữa hai đường thẳng.  \nHàm nhận một chuỗi đại diện cho mảng độ cao của các đường thẳng, với các phần tử được ngăn cách bằng dấu cách.  \nTrả về dung tích chứa nước tối đa.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  "
    },
    "docstring_bertscore": {
      "es": "0.9886736984126286",
      "arb": "0.9824569647469987",
      "sw": "0.9678252549888257",
      "tr": "0.9522526331156905",
      "vi": "0.9782458020386781"
    }
  },
  {
    "task_id": "Shell/12",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the next permutation of the array in lexicographic order.\n# If the array is in descending order, rearrange it to the first permutation (ascending order).\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the next permutation of the array.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "es": "#!/bin/bash\n\n# Encuentra la siguiente permutación del arreglo en orden lexicográfico.\n# Si el arreglo está en orden descendente, reorganízalo a la primera permutación (orden ascendente).\n# La función toma una cadena que representa el arreglo, con elementos separados por espacios.\n# Devuelve la siguiente permutación del arreglo.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "arb": "#!/bin/bash\n\n# إيجاد التبديل التالي للمصفوفة بترتيب معجمي.\n# إذا كانت المصفوفة بترتيب تنازلي، قم بإعادة ترتيبها إلى التبديل الأول (ترتيب تصاعدي).\n# تأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.\n# تعيد التبديل التالي للمصفوفة.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "sw": "#!/bin/bash\n\n# Tafuta mpangilio unaofuata wa safu katika mpangilio wa alfabeti.\n# Ikiwa safu iko katika mpangilio wa kushuka, ipange upya kuwa mpangilio wa kwanza (mpangilio wa kupanda).\n# Kazi inachukua kamba inayowakilisha safu, na vipengele vilivyotenganishwa na nafasi.\n# Inarejesha mpangilio unaofuata wa safu.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "tr": "#!/bin/bash\n\n# Dizinin sözlük sırasına göre bir sonraki permütasyonunu bulun.\n# Eğer dizi azalan sıradaysa, onu ilk permütasyona (artan sıra) yeniden düzenleyin.\n# Fonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır.\n# Dizinin bir sonraki permütasyonunu döndürür.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "vi": "#!/bin/bash\n\n# Tìm hoán vị tiếp theo của mảng theo thứ tự từ điển.\n# Nếu mảng đang ở thứ tự giảm dần, sắp xếp lại thành hoán vị đầu tiên (thứ tự tăng dần).\n# Hàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bằng dấu cách.\n# Trả về hoán vị tiếp theo của mảng.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9987271765183284",
      "sw": "0.9758608470535921",
      "tr": "0.9944341780930214",
      "vi": "0.9933373411289468"
    },
    "canonical_solution": "local i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}",
    "instruction": {
      "en": "next_permutation() {\nlocal -a nums=($1)\nlocal i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "next_permutation() {\nlocal -a nums=($1)\nlocal i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "next_permutation() {\nlocal -a nums=($1)\nlocal i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "next_permutation() {\nlocal -a nums=($1)\nlocal i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "next_permutation() {\nlocal -a nums=($1)\nlocal i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}\n\nAşağıdaki Shell kodunun işlevini Türkçe olarak en fazla 500 karakter kullanarak açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "next_permutation() {\nlocal -a nums=($1)\nlocal i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9343580220882574",
      "sw": "0.9136768254452858",
      "tr": "0.8568395364336767",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_next_permutation() {\n[[ $(next_permutation \"1 2 3\") == \"1 3 2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(next_permutation \"3 2 1\") == \"1 2 3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(next_permutation \"1 3 2\") == \"2 1 3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(next_permutation \"2 3 1\") == \"3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(next_permutation \"1 1 5\") == \"1 5 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(next_permutation \"2 1 3\") == \"2 3 1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(next_permutation \"5 4 3 2 1\") == \"1 2 3 4 5\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_next_permutation",
    "entry_point": "next_permutation",
    "signature": "next_permutation() {\nlocal -a nums=($1)",
    "docstring": {
      "en": "\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n",
      "es": "Encuentra la siguiente permutación del arreglo en orden lexicográfico.\nSi el arreglo está en orden descendente, reorganízalo a la primera permutación (orden ascendente).\nLa función toma una cadena que representa el arreglo, con elementos separados por espacios.\nDevuelve la siguiente permutación del arreglo.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "arb": "ابحث عن الترتيب التالي للمصفوفة بترتيب معجمي.  \nإذا كانت المصفوفة بترتيب تنازلي، أعد ترتيبها إلى الترتيب الأول (ترتيب تصاعدي).  \nتأخذ الدالة سلسلة تمثل المصفوفة، مع العناصر مفصولة بمسافات.  \nتعيد الترتيب التالي للمصفوفة.  \n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "sw": "Pata mpangilio unaofuata wa safu katika mpangilio wa lexicographic. Ikiwa safu iko katika mpangilio wa kushuka, ipange upya hadi mpangilio wa kwanza (mpangilio wa kupanda). Kazi inachukua kamba inayoashiria safu, na vipengele vilivyotenganishwa na nafasi. Inarudisha mpangilio unaofuata wa safu. \n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "tr": "Dizinin sözlük sırasına göre bir sonraki permütasyonunu bulun.  \nEğer dizi azalan sıradaysa, onu ilk permütasyona (artan sıra) yeniden düzenleyin.  \nFonksiyon, elemanları boşluklarla ayrılmış diziyi temsil eden bir dize alır.  \nDizinin bir sonraki permütasyonunu döndürür.  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "vi": "Tìm hoán vị tiếp theo của mảng theo thứ tự từ điển. Nếu mảng đang ở thứ tự giảm dần, sắp xếp lại nó thành hoán vị đầu tiên (thứ tự tăng dần). Hàm nhận một chuỗi đại diện cho mảng, với các phần tử được ngăn cách bởi dấu cách. Trả về hoán vị tiếp theo của mảng.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3"
    },
    "docstring_bertscore": {
      "es": "0.9981424086765617",
      "arb": "0.9886500613972855",
      "sw": "0.9872091966132583",
      "tr": "0.9908536668444865",
      "vi": "0.9927335047706007"
    }
  },
  {
    "task_id": "Shell/13",
    "prompt": {
      "en": "#!/bin/bash\n\n# Perform modified binary search to find the target in a rotated sorted array.\n# The function takes a string representing the rotated array and an integer target.\n# Returns the index of the target if found, otherwise -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "es": "#!/bin/bash\n\n# Realiza una búsqueda binaria modificada para encontrar el objetivo en un array ordenado rotado.\n# La función toma una cadena que representa el array rotado y un objetivo entero.\n# Devuelve el índice del objetivo si se encuentra, de lo contrario -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "arb": "#!/bin/bash\n\n# تنفيذ بحث ثنائي معدل للعثور على الهدف في مصفوفة مرتبة ومُدوّرة.\n# تأخذ الدالة سلسلة تمثل المصفوفة المُدوّرة وعددًا صحيحًا كهدف.\n# تُرجع فهرس الهدف إذا تم العثور عليه، وإلا تُرجع -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "sw": "#!/bin/bash\n\n# Fanya utafutaji wa binary uliobadilishwa ili kupata lengo katika safu iliyopangwa iliyozungushwa.\n# Kazi inachukua kamba inayowakilisha safu iliyozungushwa na lengo la nambari nzima.\n# Inarudisha index ya lengo ikiwa limepatikana, la sivyo -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "tr": "#!/bin/bash\n\n# Döndürülmüş sıralı bir dizide hedefi bulmak için değiştirilmiş ikili arama yapar.\n# Fonksiyon, döndürülmüş diziyi temsil eden bir string ve bir tamsayı hedef alır.\n# Hedef bulunursa indeksini döndürür, aksi takdirde -1 döndürür.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "vi": "#!/bin/bash\n\n# Thực hiện tìm kiếm nhị phân đã chỉnh sửa để tìm mục tiêu trong một mảng đã sắp xếp và xoay vòng.\n# Hàm nhận một chuỗi đại diện cho mảng đã xoay vòng và một số nguyên mục tiêu.\n# Trả về chỉ số của mục tiêu nếu tìm thấy, nếu không thì -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2"
    },
    "prompt_bertscore": {
      "es": "0.9906709268939344",
      "arb": "0.972358794805566",
      "sw": "0.9915633731959241",
      "tr": "0.9645385180738414",
      "vi": "0.9890389796833517"
    },
    "canonical_solution": "local left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}",
    "instruction": {
      "en": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2\nlocal left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2\nlocal left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2\nlocal left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2\nlocal left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2\nlocal left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}\n\nAşağıdaki Shell kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) olarak sağlayın.",
      "vi": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2\nlocal left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8841772344058895",
      "sw": "0.9274705136258726",
      "tr": "0.8708078207191932",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_search_rotated_array() {\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 0) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 3) == \"-1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(search_rotated_array \"0 1 2 4 5 6 7\" 3) == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(search_rotated_array \"6 7 0 1 2 4 5\" 3) == \"-1\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(search_rotated_array \"7 0 1 2 4 5 6\" 0) == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(search_rotated_array \"1\" 0) == \"-1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(search_rotated_array \"1 3\" 3) == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_search_rotated_array",
    "entry_point": "search_rotated_array",
    "signature": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
    "docstring": {
      "en": "\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n",
      "es": "Realizar una búsqueda binaria modificada para encontrar el objetivo en un arreglo ordenado rotado.  \nLa función toma una cadena que representa el arreglo rotado y un objetivo entero.  \nDevuelve el índice del objetivo si se encuentra, de lo contrario -1.  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0  \n4  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3  \n-1  ",
      "arb": "قم بإجراء بحث ثنائي معدل للعثور على الهدف في مصفوفة مرتبة ومدورة.\nتأخذ الدالة سلسلة تمثل المصفوفة المدورة وعددًا صحيحًا كهدف.\nتعيد فهرس الهدف إذا تم العثور عليه، وإلا تعيد -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "sw": "Fanya utafutaji wa binary uliobadilishwa ili kupata lengo katika safu iliyopangwa iliyozungushwa.\nKazi inachukua kamba inayowakilisha safu iliyozungushwa na lengo la nambari nzima.\nInarejesha faharasa ya lengo ikiwa limepatikana, vinginevyo -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "tr": "Döndürülmüş sıralı bir dizide hedefi bulmak için değiştirilmiş ikili arama gerçekleştirin.\nFonksiyon, döndürülmüş diziyi temsil eden bir dize ve bir tamsayı hedefi alır.\nHedef bulunursa indeksini, aksi takdirde -1 döndürür.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "vi": "Thực hiện tìm kiếm nhị phân đã được sửa đổi để tìm mục tiêu trong một mảng đã được xoay vòng và sắp xếp.\nHàm nhận một chuỗi đại diện cho mảng đã xoay vòng và một số nguyên mục tiêu.\nTrả về chỉ số của mục tiêu nếu tìm thấy, nếu không thì trả về -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1"
    },
    "docstring_bertscore": {
      "es": "0.9870379772248064",
      "arb": "0.9585754354047931",
      "sw": "0.9806627365151105",
      "tr": "0.9529166544794901",
      "vi": "0.9653115875168292"
    }
  },
  {
    "task_id": "Shell/14",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the start and end positions of the target value in a non-decreasing array.\n# The function takes a string representing the array and an integer target.\n# Returns the start and end positions of the target, or [-1, -1] if not found.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "es": "#!/bin/bash\n\n# Encuentra las posiciones de inicio y fin del valor objetivo en un arreglo no decreciente.\n# La función toma una cadena que representa el arreglo y un entero objetivo.\n# Devuelve las posiciones de inicio y fin del objetivo, o [-1, -1] si no se encuentra.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "arb": "#!/bin/bash\n\n# ابحث عن مواضع البداية والنهاية للقيمة المستهدفة في مصفوفة غير متناقصة.\n# تأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا كهدف.\n# تعيد مواضع البداية والنهاية للهدف، أو [-1, -1] إذا لم يتم العثور عليه.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "sw": "#!/bin/bash\n\n# Tafuta nafasi za mwanzo na mwisho za thamani lengwa katika safu isiyopungua.\n# Kazi inachukua kamba inayowakilisha safu na thamani lengwa ya nambari nzima.\n# Inarudisha nafasi za mwanzo na mwisho za lengwa, au [-1, -1] ikiwa haikupatikana.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "tr": "#!/bin/bash\n\n# Hedef değerin başlangıç ve bitiş pozisyonlarını artmayan bir dizide bulun.\n# Fonksiyon, diziyi temsil eden bir string ve bir tamsayı hedef alır.\n# Hedefin başlangıç ve bitiş pozisyonlarını döndürür veya bulunamazsa [-1, -1] döner.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "vi": "#!/bin/bash\n\n# Tìm vị trí bắt đầu và kết thúc của giá trị mục tiêu trong một mảng không giảm.\n# Hàm nhận một chuỗi đại diện cho mảng và một số nguyên mục tiêu.\n# Trả về vị trí bắt đầu và kết thúc của mục tiêu, hoặc [-1, -1] nếu không tìm thấy.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2"
    },
    "prompt_bertscore": {
      "es": "0.9933536288201916",
      "arb": "0.9833839727352885",
      "sw": "0.986073825355263",
      "tr": "0.9843747410758905",
      "vi": "0.9999996027392379"
    },
    "canonical_solution": "local n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}",
    "instruction": {
      "en": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2\nlocal n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2\nlocal n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2\nlocal n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2\nlocal n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2\nlocal n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2\nlocal n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8882549174981547",
      "sw": "0.9148459638680573",
      "tr": "0.8341917003880788",
      "vi": "0.9147003677987586"
    },
    "level": "",
    "test": "test_find_target_positions() {\n[[ $(find_target_positions \"5 7 7 8 8 10\" 8) == \"3 4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_target_positions \"5 7 7 8 8 10\" 6) == \"-1 -1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 5) == \"4 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 1) == \"0 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_target_positions \"1 1 1 1 1\" 1) == \"0 4\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 3 3 4 5\" 3) == \"2 4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 2 3 4 5\" 2) == \"1 2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_target_positions",
    "entry_point": "find_target_positions",
    "signature": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
    "docstring": {
      "en": "\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n",
      "es": "Encuentra las posiciones de inicio y fin del valor objetivo en un arreglo no decreciente.  \nLa función toma una cadena que representa el arreglo y un entero objetivo.  \nDevuelve las posiciones de inicio y fin del objetivo, o [-1, -1] si no se encuentra.  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  ",
      "arb": "ابحث عن مواضع البداية والنهاية للقيمة المستهدفة في مصفوفة غير متناقصة.\nتأخذ الدالة سلسلة تمثل المصفوفة وعددًا صحيحًا كهدف.\nتعيد مواضع البداية والنهاية للهدف، أو [-1, -1] إذا لم يتم العثور عليه.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "sw": "Pata nafasi za mwanzo na mwisho za thamani lengwa katika safu isiyopungua.\nKazi inachukua kamba inayowakilisha safu na nambari nzima lengwa.\nInarudisha nafasi za mwanzo na mwisho za lengwa, au [-1, -1] ikiwa haikupatikana.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "tr": "Hedef değerin başlangıç ve bitiş pozisyonlarını artmayan bir dizide bulun.\nFonksiyon, diziyi temsil eden bir dize ve bir tamsayı hedefi alır.\nHedefin başlangıç ve bitiş pozisyonlarını döndürür veya bulunamazsa [-1, -1] döner.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "vi": "Tìm vị trí bắt đầu và kết thúc của giá trị mục tiêu trong một mảng không giảm dần. Hàm nhận một chuỗi đại diện cho mảng và một số nguyên mục tiêu. Trả về vị trí bắt đầu và kết thúc của mục tiêu, hoặc [-1, -1] nếu không tìm thấy.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1"
    },
    "docstring_bertscore": {
      "es": "0.9964633860656739",
      "arb": "0.9796592558301223",
      "sw": "0.9910409752938024",
      "tr": "0.9891758360158848",
      "vi": "0.9918650927447161"
    }
  },
  {
    "task_id": "Shell/15",
    "prompt": {
      "en": "#!/bin/bash\n\n# Validate a 9x9 Sudoku board.\n# The function takes a 9x9 Sudoku board as a string, where rows are separated by semicolons and elements by spaces.\n# Returns \"true\" if the Sudoku is valid, \"false\" otherwise.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "es": "#!/bin/bash\n\n# Validar un tablero de Sudoku de 9x9.\n# La función toma un tablero de Sudoku de 9x9 como una cadena, donde las filas están separadas por puntos y comas y los elementos por espacios.\n# Devuelve \"true\" si el Sudoku es válido, \"false\" en caso contrario.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convertir cadena a matriz 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "arb": "#!/bin/bash\n\n# التحقق من صحة لوحة سودوكو 9x9.\n# تأخذ الدالة لوحة سودوكو 9x9 كسلسلة نصية، حيث يتم فصل الصفوف بفواصل منقوطة والعناصر بمسافات.\n# تعيد \"true\" إذا كانت السودوكو صالحة، و\"false\" خلاف ذلك.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# تحويل السلسلة إلى مصفوفة ثنائية الأبعاد\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "sw": "#!/bin/bash\n\n# Thibitisha ubao wa Sudoku wa 9x9.\n# Kazi inachukua ubao wa Sudoku wa 9x9 kama kamba, ambapo mistari imetenganishwa na alama za nukta na vipengele kwa nafasi.\n# Inarudisha \"true\" ikiwa Sudoku ni sahihi, \"false\" vinginevyo.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Badilisha kamba kuwa safu ya 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "tr": "#!/bin/bash\n\n# 9x9 bir Sudoku tahtasını doğrulayın.\n# Fonksiyon, satırların noktalı virgülle ve elemanların boşlukla ayrıldığı bir 9x9 Sudoku tahtasını bir string olarak alır.\n# Sudoku geçerliyse \"true\", aksi takdirde \"false\" döner.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Stringi 2D diziye dönüştür\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "vi": "#!/bin/bash\n\n# Xác thực một bảng Sudoku 9x9.\n# Hàm nhận một bảng Sudoku 9x9 dưới dạng chuỗi, trong đó các hàng được ngăn cách bằng dấu chấm phẩy và các phần tử bằng dấu cách.\n# Trả về \"true\" nếu Sudoku hợp lệ, \"false\" nếu không.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Chuyển chuỗi thành mảng 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\""
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9898275422960603",
      "sw": "0.9895913707730097",
      "tr": "0.9904808376192841",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "for i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}",
    "instruction": {
      "en": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n\nfor i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n\nfor i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n\nfor i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n\nfor i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n\nfor i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n\nfor i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8702536419561059",
      "sw": "0.9148459638680573",
      "tr": "0.8487360127785964",
      "vi": "0.9147003677987586"
    },
    "level": "",
    "test": "# Testing function\ntest_is_valid_sudoku() {\nlocal validSudoku=\"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\nlocal invalidSudoku=\"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n\n[[ $(is_valid_sudoku \"$validSudoku\") == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_valid_sudoku \"$invalidSudoku\") == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_is_valid_sudoku",
    "entry_point": "is_valid_sudoku",
    "signature": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n",
    "docstring": {
      "en": "Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "es": "Convertir cadena a matriz 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "arb": "تحويل سلسلة إلى مصفوفة ثنائية الأبعاد  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "sw": "Geuza kamba kuwa safu ya 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "tr": "Dizgiyi 2D diziye dönüştür  \nyerel -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "vi": "Chuyển đổi chuỗi thành mảng 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9444478495536867",
      "sw": "0.9886153010806044",
      "tr": "0.9730919395419658",
      "vi": "0.9730919395419658"
    }
  },
  {
    "task_id": "Shell/16",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the number of strings that appear exactly once in both arrays.\n# The function takes two strings representing the arrays, where elements are separated by spaces.\n# Returns the count of strings that appear exactly once in both arrays.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "es": "#!/bin/bash\n\n# Cuenta el número de cadenas que aparecen exactamente una vez en ambos arreglos.\n# La función toma dos cadenas que representan los arreglos, donde los elementos están separados por espacios.\n# Devuelve el conteo de cadenas que aparecen exactamente una vez en ambos arreglos.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "arb": "#!/bin/bash\n\n# عد عدد السلاسل التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n# تأخذ الدالة سلسلتين تمثلان المصفوفتين، حيث يتم فصل العناصر بمسافات.\n# تعيد عدد السلاسل التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "sw": "#!/bin/bash\n\n# Hesabu idadi ya mistari inayotokea mara moja tu katika safu zote mbili.\n# Kazi inachukua mistari miwili inayowakilisha safu, ambapo vipengele hutenganishwa na nafasi.\n# Inarudisha idadi ya mistari inayotokea mara moja tu katika safu zote mbili.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "tr": "#!/bin/bash\n\n# İki dizide tam olarak bir kez görünen dizelerin sayısını sayar.\n# Fonksiyon, dizileri temsil eden ve elemanların boşluklarla ayrıldığı iki dize alır.\n# İki dizide tam olarak bir kez görünen dizelerin sayısını döndürür.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "vi": "#!/bin/bash\n\n# Đếm số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.\n# Hàm nhận hai chuỗi đại diện cho các mảng, trong đó các phần tử được ngăn cách bởi dấu cách.\n# Trả về số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)"
    },
    "prompt_bertscore": {
      "es": "0.9921958123291392",
      "arb": "0.9966729411176656",
      "sw": "0.9610183904611411",
      "tr": "0.9876157930032368",
      "vi": "0.9966729411176656"
    },
    "canonical_solution": "local -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}",
    "instruction": {
      "en": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)\nlocal -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)\nlocal -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)\nlocal -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)\nlocal -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)\nlocal -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakterle sınırlı olmalıdır.",
      "vi": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)\nlocal -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8839829738932373",
      "sw": "0.9274705136258726",
      "tr": "0.8206909920195185",
      "vi": "0.9324273347845983"
    },
    "level": "",
    "test": "# Testing function\ntest_count_unique_strings() {\n[[ $(count_unique_strings \"apple banana mango\" \"banana fruits apple\") == \"2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_unique_strings \"hello world\" \"world hello planet\") == \"2\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two three\" \"four five six\") == \"0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two two\" \"two one one\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_unique_strings \"a b c d e\" \"a b c d e\") == \"5\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_unique_strings \"dog cat\" \"cat dog bird\") == \"2\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_unique_strings \"x y z\" \"x y z a b c\") == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_unique_strings",
    "entry_point": "count_unique_strings",
    "signature": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
    "docstring": {
      "en": "\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "es": "Cuenta el número de cadenas que aparecen exactamente una vez en ambos arreglos.\nLa función toma dos cadenas que representan los arreglos, donde los elementos están separados por espacios.\nDevuelve el conteo de cadenas que aparecen exactamente una vez en ambos arreglos.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "arb": "احسب عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\nتأخذ الدالة سلسلتين تمثلان المصفوفتين، حيث يتم فصل العناصر بواسطة مسافات.\nتعيد عدد السلاسل النصية التي تظهر مرة واحدة بالضبط في كلا المصفوفتين.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "sw": "Hesabu idadi ya nyuzi za maandishi zinazotokea mara moja tu katika safu zote mbili. \nKazi inachukua nyuzi mbili za maandishi zinazowakilisha safu, ambapo vipengele vimetenganishwa na nafasi. \nInarejesha hesabu ya nyuzi za maandishi zinazotokea mara moja tu katika safu zote mbili.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "tr": "Her iki dizide de tam olarak bir kez görünen dizelerin sayısını sayın.  \nFonksiyon, elemanların boşluklarla ayrıldığı dizileri temsil eden iki dize alır.  \nHer iki dizide de tam olarak bir kez görünen dizelerin sayısını döndürür.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  ",
      "vi": "Đếm số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.  \nHàm nhận hai chuỗi đại diện cho các mảng, trong đó các phần tử được phân tách bằng dấu cách.  \nTrả về số lượng chuỗi xuất hiện chính xác một lần trong cả hai mảng.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  "
    },
    "docstring_bertscore": {
      "es": "0.9959757484802332",
      "arb": "0.9799232356065176",
      "sw": "0.9702787374553686",
      "tr": "0.9796880572353723",
      "vi": "0.9878150192754148"
    }
  },
  {
    "task_id": "Shell/17",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the frequency of each word in frequency.txt\n# example\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "es": "#!/bin/bash\n\n# Contar la frecuencia de cada palabra en frequency.txt\n# ejemplo\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "arb": "#!/bin/bash\n\n# احسب تكرار كل كلمة في frequency.txt\n# مثال\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "sw": "#!/bin/bash\n\n# Hesabu mara ngapi kila neno linapatikana katika frequency.txt\n# mfano\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "tr": "#!/bin/bash\n\n# frequency.txt dosyasındaki her kelimenin sıklığını say\n# örnek\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "vi": "#!/bin/bash\n\n# Đếm tần suất của mỗi từ trong frequency.txt\n# ví dụ\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.976953115518903",
      "sw": "0.9674818230600164",
      "tr": "0.9771376431428843",
      "vi": "1"
    },
    "canonical_solution": "tr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}",
    "instruction": {
      "en": "count_word_frequency() {\ntr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "count_word_frequency() {\ntr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "count_word_frequency() {\ntr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "count_word_frequency() {\ntr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "count_word_frequency() {\ntr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan Türkçe bir doğal dil açıklaması (docstring) sağlayın ve en fazla 500 karakter kullanın.",
      "vi": "count_word_frequency() {\ntr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9084151066516717",
      "sw": "0.9274705136258726",
      "tr": "0.8541473002491299",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "# Test function for count_word_frequency\ntest_count_word_frequency() {\n# Create a sample frequency.txt file\necho -e \"apple banana apple\\nbanana banana apple\" > frequency.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"apple 3\\nbanana 3\")\n\n# Actual output from the function\nlocal actual_output=$(count_word_frequency)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm frequency.txt\n}\n\n# Call the test function\ntest_count_word_frequency",
    "entry_point": "count_word_frequency",
    "signature": "count_word_frequency() {",
    "docstring": {
      "en": "\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n",
      "es": "Cuenta la frecuencia de cada palabra en frequency.txt  \nejemplo  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "arb": "احسب تكرار كل كلمة في frequency.txt  \nمثال  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "sw": "Hesabu mara ngapi kila neno linatokea katika frequency.txt\nmfano\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "tr": "Her kelimenin sıklığını frequency.txt dosyasında sayın\nörnek\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "vi": "Đếm tần suất của mỗi từ trong frequency.txt\nví dụ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9599352589933579",
      "sw": "0.9451096859832948",
      "tr": "0.9507601244325943",
      "vi": "1"
    }
  },
  {
    "task_id": "Shell/18",
    "prompt": {
      "en": "#!/bin/bash\n\n# Single-line script to output all valid phone numbers from file.txt\n# example\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "es": "#!/bin/bash\n\n# Script de una sola línea para mostrar todos los números de teléfono válidos de file.txt\n# ejemplo\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "arb": "#!/bin/bash\n\n# سكربت سطر واحد لإخراج جميع أرقام الهاتف الصالحة من file.txt\n# مثال\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "sw": "#!/bin/bash\n\n# Skripti ya mstari mmoja kutoa namba za simu halali kutoka file.txt\n# mfano\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "tr": "#!/bin/bash\n\n# file.txt dosyasından tüm geçerli telefon numaralarını çıkarmak için tek satırlık betik\n# örnek\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "vi": "#!/bin/bash\n\n# Script một dòng để xuất tất cả các số điện thoại hợp lệ từ file.txt\n# ví dụ\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {"
    },
    "prompt_bertscore": {
      "es": "0.990349940198182",
      "arb": "0.9849001184337278",
      "sw": "0.9779762606116137",
      "tr": "0.98022118117807",
      "vi": "0.9907362762892948"
    },
    "canonical_solution": "grep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}",
    "instruction": {
      "en": "find_valid_numbers() {\ngrep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "find_valid_numbers() {\ngrep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "find_valid_numbers() {\ngrep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "find_valid_numbers() {\ngrep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "find_valid_numbers() {\ngrep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "find_valid_numbers() {\ngrep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.9148459638680573",
      "tr": "0.8195280111385592",
      "vi": "0.9237231528572685"
    },
    "level": "",
    "test": "test_find_valid_numbers() {\n# Create a sample file.txt file\necho -e \"123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"123-456-7890\\n(123) 456-7890\")\n\n# Actual output from the function\nlocal actual_output=$(find_valid_numbers)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_find_valid_numbers",
    "entry_point": "find_valid_numbers",
    "signature": "find_valid_numbers() {",
    "docstring": {
      "en": "\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n",
      "es": "Script de una sola línea para mostrar todos los números de teléfono válidos de file.txt\nejemplo\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "arb": "برنامج نصي ذو سطر واحد لإخراج جميع أرقام الهواتف الصالحة من file.txt\nمثال\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "sw": "Skripti ya mstari mmoja ili kutoa namba zote za simu halali kutoka file.txt\nmfano\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "tr": "Tek satırlık betik, file.txt dosyasından tüm geçerli telefon numaralarını çıkarmak için\n\nörnek\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "vi": "Script một dòng để xuất tất cả các số điện thoại hợp lệ từ file.txt\nví dụ\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890"
    },
    "docstring_bertscore": {
      "es": "0.9594627173168758",
      "arb": "0.9830381572419068",
      "sw": "0.9712269988944292",
      "tr": "0.9764140326647742",
      "vi": "0.9800799549771542"
    }
  },
  {
    "task_id": "Shell/19",
    "prompt": {
      "en": "#!/bin/bash\n\n# Transpose the content of file.txt\n# example\n# input:1 2 3\\n4 5 6\\n7 8 9\n# output:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "es": "#!/bin/bash\n\n# Transponer el contenido de file.txt\n# ejemplo\n# entrada:1 2 3\\n4 5 6\\n7 8 9\n# salida:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "arb": "#!/bin/bash\n\n# تبديل محتوى الملف file.txt\n# مثال\n# المدخلات:1 2 3\\n4 5 6\\n7 8 9\n# المخرجات:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "sw": "#!/bin/bash\n\n# Badilisha yaliyomo ya file.txt\n# mfano\n# ingizo:1 2 3\\n4 5 6\\n7 8 9\n# matokeo:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "tr": "#!/bin/bash\n\n# file.txt dosyasının içeriğini transpoze et\n# örnek\n# giriş:1 2 3\\n4 5 6\\n7 8 9\n# çıkış:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "vi": "#!/bin/bash\n\n# Chuyển vị nội dung của file.txt\n# ví dụ\n# đầu vào:1 2 3\\n4 5 6\\n7 8 9\n# đầu ra:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9768536016980045",
      "sw": "0.9818727927963751",
      "tr": "0.9919977778392475",
      "vi": "0.9964961600785446"
    },
    "canonical_solution": "awk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}",
    "instruction": {
      "en": "transpose_file() {\nawk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "transpose_file() {\nawk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "transpose_file() {\nawk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "transpose_file() {\nawk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "transpose_file() {\nawk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "transpose_file() {\nawk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8782240832558929",
      "sw": "0.9148459638680573",
      "tr": "0.8547378283719466",
      "vi": "0.9238182968097841"
    },
    "level": "",
    "test": "# Test function for transpose_file\ntest_transpose_file() {\n# Create a sample file.txt file\necho -e \"1 2 3\\n4 5 6\\n7 8 9\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"1 4 7\\n2 5 8\\n3 6 9\")\n\n# Actual output from the function\nlocal actual_output=$(transpose_file)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_transpose_file",
    "entry_point": "transpose_file",
    "signature": "transpose_file() {",
    "docstring": {
      "en": "\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n",
      "es": "Transponer el contenido de file.txt  \nejemplo  \nentrada:1 2 3\\n4 5 6\\n7 8 9  \nsalida:1 4 7\\n2 5 8\\n3 6 9  ",
      "arb": "نقل محتوى الملف file.txt  \nمثال  \nالمدخل: 1 2 3\\n4 5 6\\n7 8 9  \nالمخرج: 1 4 7\\n2 5 8\\n3 6 9  ",
      "sw": "Badilisha yaliyomo ya file.txt  \nmfano  \ningizo:1 2 3\\n4 5 6\\n7 8 9  \nmatokeo:1 4 7\\n2 5 8\\n3 6 9  ",
      "tr": "Dosya.txt içeriğini ters çevir\nörnek\ngirdi:1 2 3\\n4 5 6\\n7 8 9\nçıktı:1 4 7\\n2 5 8\\n3 6 9",
      "vi": "Chuyển đổi nội dung của file.txt  \nví dụ  \nđầu vào:1 2 3\\n4 5 6\\n7 8 9  \nđầu ra:1 4 7\\n2 5 8\\n3 6 9  "
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9401322072649416",
      "sw": "0.971151717980017",
      "tr": "0.9496670614457593",
      "vi": "0.9796870640834672"
    }
  },
  {
    "task_id": "Shell/20",
    "prompt": {
      "en": "#!/bin/bash\n\n# Extract the tenth line from file.txt\n# example\n# input: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# output:Line 10\nextract_tenth_line() {",
      "es": "#!/bin/bash\n\n# Extraer la décima línea de file.txt\n# ejemplo\n# entrada: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# salida:Line 10\nextract_tenth_line() {",
      "arb": "#!/bin/bash\n\n# استخراج السطر العاشر من الملف file.txt\n# مثال\n# الإدخال: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# الإخراج:Line 10\nextract_tenth_line() {",
      "sw": "#!/bin/bash\n\n# Toa mstari wa kumi kutoka file.txt\n# mfano\n# ingizo: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# pato:Mstari 10\nextract_tenth_line() {",
      "tr": "#!/bin/bash\n\n# file.txt dosyasından onuncu satırı çıkar\n# örnek\n# giriş: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# çıkış:Line 10\nextract_tenth_line() {",
      "vi": "#!/bin/bash\n\n# Trích xuất dòng thứ mười từ file.txt\n# ví dụ\n# đầu vào: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# đầu ra: Line 10\nextract_tenth_line() {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.97411766682963",
      "sw": "0.99395984874311",
      "tr": "0.9883179514001951",
      "vi": "0.99395984874311"
    },
    "canonical_solution": "sed -n '10p' file.txt\n}",
    "instruction": {
      "en": "extract_tenth_line() {\nsed -n '10p' file.txt\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "extract_tenth_line() {\nsed -n '10p' file.txt\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "extract_tenth_line() {\nsed -n '10p' file.txt\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "extract_tenth_line() {\nsed -n '10p' file.txt\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "extract_tenth_line() {\nsed -n '10p' file.txt\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter içermelidir.",
      "vi": "extract_tenth_line() {\nsed -n '10p' file.txt\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8990808691556992",
      "sw": "0.9148459638680573",
      "tr": "0.8536332448230116",
      "vi": "0.8947882679911542"
    },
    "level": "",
    "test": "test_extract_tenth_line() {\n# Create a sample file.txt file\nfor i in {1..20}; do echo \"Line $i\"; done > file.txt\n\n# Expected output\nlocal expected_output=\"Line 10\"\n\n# Actual output from the function\nlocal actual_output=$(extract_tenth_line)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_extract_tenth_line",
    "entry_point": "extract_tenth_line",
    "signature": "extract_tenth_line() {",
    "docstring": {
      "en": "\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n",
      "es": "Extraer la décima línea de file.txt  \nejemplo  \nentrada: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nsalida: Line 10  ",
      "arb": "استخراج السطر العاشر من الملف file.txt  \nمثال  \nالمدخلات: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nالناتج:Line 10  ",
      "sw": "Chopoa mstari wa kumi kutoka file.txt  \nmfano  \ningizo: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nmatokeo:Line 10  ",
      "tr": "Onuncu satırı file.txt dosyasından çıkarın\nörnek\ngirdi: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nçıktı:Line 10",
      "vi": "Trích dòng thứ mười từ file.txt  \nví dụ  \nđầu vào: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nđầu ra:Line 10  "
    },
    "docstring_bertscore": {
      "es": "0.9944214657486352",
      "arb": "0.9755905111050036",
      "sw": "0.999999801369619",
      "tr": "0.9721687055309156",
      "vi": "0.999999801369619"
    }
  },
  {
    "task_id": "Shell/21",
    "prompt": {
      "en": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "es": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Esta función encuentra la primera aparición de la subcadena 'needle' en la cadena 'haystack'.\n# Devuelve el índice del primer carácter de la primera aparición de 'needle'.\n# Si 'needle' no es parte de 'haystack', devuelve -1.\n# Ejemplo de uso:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "arb": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# هذه الدالة تجد أول ظهور للجزء 'needle' في السلسلة 'haystack'.\n# تعيد الدالة فهرس أول حرف من أول ظهور لـ 'needle'.\n# إذا لم يكن 'needle' جزءًا من 'haystack'، فإنها تعيد -1.\n# مثال على الاستخدام:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "sw": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Kazi ya hii kazi ni kupata tukio la kwanza la 'needle' katika kamba 'haystack'.\n# Inarudisha kiashiria cha herufi ya kwanza ya tukio la kwanza la 'needle'.\n# Ikiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\n# Mfano wa Matumizi:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "tr": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Bu fonksiyon, 'haystack' dizgesinde 'needle' alt dizgesinin ilk geçtiği yeri bulur.\n# 'needle'in ilk geçtiği yerin ilk karakterinin indeksini döndürür.\n# Eğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\n# Örnek Kullanım:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "vi": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Hàm này tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\n# Nó trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\n# Nếu 'needle' không phải là một phần của 'haystack', nó trả về -1.\n# Ví dụ sử dụng:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4"
    },
    "prompt_bertscore": {
      "es": "0.9862172364903702",
      "arb": "0.9888248561325962",
      "sw": "0.9790504537122503",
      "tr": "0.9815039361787933",
      "vi": "0.9966004410285879"
    },
    "canonical_solution": "# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}",
    "instruction": {
      "en": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español usando un máximo de 500 caracteres.",
      "arb": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.920868238390654",
      "sw": "0.8784135766394001",
      "tr": "0.8487360127785964",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_find_substring_index() {\n[[ $(find_substring_index \"hello\" \"ll\") -eq 2 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"e\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_substring_index \"openai\" \"ai\") -eq 4 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_substring_index \"apple\" \"pp\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_substring_index \"banana\" \"na\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_substring_index \"teststring\" \"string\") -eq 4 ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"\") -eq 0 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_substring_index",
    "entry_point": "find_substring_index",
    "signature": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n",
    "docstring": {
      "en": "This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "es": "Esta función encuentra la primera aparición de la subcadena 'needle' en la cadena 'haystack'.\nDevuelve el índice del primer carácter de la primera aparición de 'needle'.\nSi 'needle' no es parte de 'haystack', devuelve -1.\nUso de Ejemplo:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "arb": "هذه الدالة تجد أول ظهور للجزء النصي 'needle' في السلسلة النصية 'haystack'.\nتعيد الدالة فهرس الحرف الأول من أول ظهور لـ 'needle'.\nإذا لم يكن 'needle' جزءًا من 'haystack'، فإنها تعيد -1.\nمثال على الاستخدام:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "sw": "Kazi ya kificho hii inatafuta tukio la kwanza la neno ndogo 'needle' katika kamba 'haystack'. Inarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'. Ikiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\n\nMfano wa Matumizi:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "tr": "Bu fonksiyon, 'haystack' stringinde 'needle' alt dizisinin ilk geçtiği yeri bulur.\n'Needle'ın ilk geçtiği yerin ilk karakterinin indeksini döndürür.\nEğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\nÖrnek Kullanım:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "vi": "Hàm này tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\nNó trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\nNếu 'needle' không phải là một phần của 'haystack', nó trả về -1.\nVí dụ Sử dụng:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4"
    },
    "docstring_bertscore": {
      "es": "0.9851529749087852",
      "arb": "0.9890266645997277",
      "sw": "0.9670337129204016",
      "tr": "0.9823010398978863",
      "vi": "0.9999996027392379"
    }
  },
  {
    "task_id": "Shell/22",
    "prompt": {
      "en": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# This function simulates a sequence of toggling lights. Initially, all lights are off. \n# In each round, a person toggles the state of lights that are multiples of their number. \n# For example, the first person toggles all lights, the second person toggles every second light, and so on.\n# The function outputs the numbers of the lights that remain on after N rounds.\n# Example Usage:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "es": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Esta función simula una secuencia de encendido y apagado de luces. Inicialmente, todas las luces están apagadas.\n# En cada ronda, una persona cambia el estado de las luces que son múltiplos de su número.\n# Por ejemplo, la primera persona cambia todas las luces, la segunda persona cambia cada segunda luz, y así sucesivamente.\n# La función muestra los números de las luces que permanecen encendidas después de N rondas.\n# Ejemplo de uso:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "arb": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# هذه الدالة تحاكي تسلسل تبديل الأضواء. في البداية، جميع الأضواء مطفأة.\n# في كل جولة، يقوم شخص بتبديل حالة الأضواء التي هي مضاعفات لرقمه.\n# على سبيل المثال، الشخص الأول يبدل جميع الأضواء، الشخص الثاني يبدل كل ضوء ثاني، وهكذا.\n# تقوم الدالة بإخراج أرقام الأضواء التي تبقى مضاءة بعد N جولة.\n# مثال على الاستخدام:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "sw": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Kazi hii inasimulate mfululizo wa kuwasha na kuzima taa. Awali, taa zote zimezimwa.\n# Katika kila raundi, mtu anabadilisha hali ya taa ambazo ni maradufu ya namba yao.\n# Kwa mfano, mtu wa kwanza anabadilisha hali ya taa zote, mtu wa pili anabadilisha kila taa ya pili, na kadhalika.\n# Kazi hii inatoa namba za taa ambazo zinabaki kuwaka baada ya raundi N.\n# Mfano wa Matumizi:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "tr": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Bu fonksiyon, ışıkların açılıp kapatılma sırasını simüle eder. Başlangıçta, tüm ışıklar kapalıdır.\n# Her turda, bir kişi kendi numarasının katları olan ışıkların durumunu değiştirir.\n# Örneğin, ilk kişi tüm ışıkları değiştirir, ikinci kişi her ikinci ışığı değiştirir, ve bu şekilde devam eder.\n# Fonksiyon, N turdan sonra açık kalan ışıkların numaralarını çıktılar.\n# Örnek Kullanım:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "vi": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Hàm này mô phỏng một chuỗi bật tắt đèn. Ban đầu, tất cả đèn đều tắt.\n# Trong mỗi vòng, một người sẽ bật tắt trạng thái của các đèn mà là bội số của số của họ.\n# Ví dụ, người đầu tiên bật tắt tất cả các đèn, người thứ hai bật tắt mỗi đèn thứ hai, và cứ tiếp tục như vậy.\n# Hàm này xuất ra các số của những đèn còn sáng sau N vòng.\n# Ví dụ sử dụng:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9"
    },
    "prompt_bertscore": {
      "es": "0.9590068605924008",
      "arb": "0.9884323624996713",
      "sw": "0.9525281334541859",
      "tr": "0.9588280932494694",
      "vi": "0.9867154014860057"
    },
    "canonical_solution": "local lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}",
    "instruction": {
      "en": "toggle_lights() {\nlocal n=$1\n\nlocal lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "toggle_lights() {\nlocal n=$1\n\nlocal lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "toggle_lights() {\nlocal n=$1\n\nlocal lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "toggle_lights() {\nlocal n=$1\n\nlocal lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "toggle_lights() {\nlocal n=$1\n\nlocal lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "toggle_lights() {\nlocal n=$1\n\nlocal lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.9274705136258726",
      "tr": "0.8619552618972303",
      "vi": "0.9438015062937991"
    },
    "level": "",
    "test": "test_toggle_lights() {\n[[ $(toggle_lights 5) == \"1 4 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(toggle_lights 6) == \"1 4 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(toggle_lights 10) == \"1 4 9 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(toggle_lights 3) == \"1 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(toggle_lights 7) == \"1 4 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_toggle_lights",
    "entry_point": "toggle_lights",
    "signature": "toggle_lights() {\nlocal n=$1\n",
    "docstring": {
      "en": "This function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "es": "Esta función simula una secuencia de alternancia de luces. Inicialmente, todas las luces están apagadas. En cada ronda, una persona alterna el estado de las luces que son múltiplos de su número. Por ejemplo, la primera persona alterna todas las luces, la segunda persona alterna cada segunda luz, y así sucesivamente. La función muestra los números de las luces que permanecen encendidas después de N rondas.\nUso de Ejemplo:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "arb": "هذه الدالة تحاكي تسلسل تبديل الأضواء. في البداية، تكون جميع الأضواء مطفأة. \nفي كل جولة، يقوم شخص بتبديل حالة الأضواء التي هي مضاعفات لرقمه. \nعلى سبيل المثال، يقوم الشخص الأول بتبديل جميع الأضواء، والشخص الثاني يقوم بتبديل كل ضوء ثاني، وهكذا.\nتقوم الدالة بإخراج أرقام الأضواء التي تبقى مضاءة بعد N جولة.\nمثال على الاستخدام:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "sw": "Kazi hii inasimulate mfululizo wa kuwasha na kuzima taa. Awali, taa zote zimezimwa. Katika kila raundi, mtu anabadilisha hali ya taa ambazo ni maradufu ya namba yao. Kwa mfano, mtu wa kwanza anabadilisha hali ya taa zote, mtu wa pili anabadilisha kila taa ya pili, na kadhalika. Kazi hii inatoa namba za taa ambazo zinabaki kuwaka baada ya raundi N.\nMfano wa Matumizi:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "tr": "Bu fonksiyon, ışıkların açılıp kapanma sırasını simüle eder. Başlangıçta tüm ışıklar kapalıdır. \nHer turda, bir kişi kendi numarasının katı olan ışıkların durumunu değiştirir. \nÖrneğin, birinci kişi tüm ışıkları değiştirir, ikinci kişi her ikinci ışığı değiştirir ve bu şekilde devam eder.\nFonksiyon, N turdan sonra açık kalan ışıkların numaralarını çıktılar.\nÖrnek Kullanım:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "vi": "Hàm này mô phỏng một chuỗi các lần bật/tắt đèn. Ban đầu, tất cả các đèn đều tắt. Trong mỗi vòng, một người sẽ bật/tắt trạng thái của các đèn mà là bội số của số của họ. Ví dụ, người đầu tiên bật/tắt tất cả các đèn, người thứ hai bật/tắt mỗi đèn thứ hai, và cứ tiếp tục như vậy. Hàm này xuất ra các số của các đèn vẫn sáng sau N vòng.\nVí dụ sử dụng:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9"
    },
    "docstring_bertscore": {
      "es": "0.9741836121161335",
      "arb": "0.9890983701672812",
      "sw": "0.9439780887025391",
      "tr": "0.946215262684135",
      "vi": "0.9749670103389351"
    }
  },
  {
    "task_id": "Shell/23",
    "prompt": {
      "en": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# This function finds M positive integers that sum up to N and have the maximum possible product.\n# The function outputs the integers in a lexicographically smallest order.\n# If no such combination exists, it outputs an error message.\n# Example Usage:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "es": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Esta función encuentra M enteros positivos que suman N y tienen el producto máximo posible.\n# La función muestra los enteros en el orden lexicográficamente más pequeño.\n# Si no existe tal combinación, muestra un mensaje de error.\n# Ejemplo de uso:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "arb": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# هذه الدالة تجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N وتحقق أكبر حاصل ضرب ممكن.\n# تقوم الدالة بإخراج الأعداد بترتيب معجمي أصغر.\n# إذا لم يكن هناك مثل هذا التكوين، فإنها تخرج رسالة خطأ.\n# مثال على الاستخدام:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "sw": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Kazi hii inapata nambari M ambazo ni chanya ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana.\n# Kazi hii inatoa nambari katika mpangilio mdogo wa lexicographically.\n# Ikiwa hakuna mchanganyiko kama huo upo, inatoa ujumbe wa kosa.\n# Mfano wa Matumizi:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "tr": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Bu fonksiyon, toplamları N olan ve mümkün olan en yüksek çarpıma sahip M pozitif tam sayı bulur.\n# Fonksiyon, tam sayıları sözlük sırasına göre en küçük şekilde çıktılar.\n# Eğer böyle bir kombinasyon yoksa, bir hata mesajı çıktılar.\n# Örnek Kullanım:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "vi": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Hàm này tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể.\n# Hàm xuất ra các số theo thứ tự từ điển nhỏ nhất.\n# Nếu không tồn tại kết hợp nào như vậy, nó sẽ xuất ra thông báo lỗi.\n# Ví dụ sử dụng:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4"
    },
    "prompt_bertscore": {
      "es": "0.9851188104832472",
      "arb": "0.956884693601424",
      "sw": "0.9628253310374155",
      "tr": "0.9709270670190665",
      "vi": "0.9773889105748935"
    },
    "canonical_solution": "if (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}",
    "instruction": {
      "en": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n\nif (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n\nif (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n\nif (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n\nif (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n\nif (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n\nif (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.9274705136258726",
      "tr": "0.8589893130476174",
      "vi": "0.9143334974849873"
    },
    "level": "",
    "test": "test_maximize_product() {\n[[ $(maximize_product 6 3) == \"2 2 2 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(maximize_product 8 3) == \"2 3 3 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(maximize_product 10 2) == \"5 5 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(maximize_product 20 5) == \"4 4 4 4 4 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(maximize_product 7 3) == \"2 2 3 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(maximize_product 12 4) == \"3 3 3 3 \" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(maximize_product 5 6) == \"Error: Cannot divide 5 into 6 parts\" ]] && { echo \"Test 7 passed\"; } || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_maximize_product",
    "entry_point": "maximize_product",
    "signature": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n",
    "docstring": {
      "en": "This function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "es": "Esta función encuentra M enteros positivos que suman N y tienen el producto máximo posible.  \nLa función devuelve los enteros en el orden lexicográficamente más pequeño.  \nSi no existe tal combinación, muestra un mensaje de error.  \nEjemplo de uso:  \n>>> maximize_product 6 3  \n2 2 2  \n>>> maximize_product 8 3  \n2 3 3  \n>>> maximize_product 10 2  \n5 5  \n>>> maximize_product 20 5  \n4 4 4 4 4  ",
      "arb": "هذه الدالة تجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ولها أكبر حاصل ضرب ممكن.\nتقوم الدالة بإخراج الأعداد بترتيب معجمي أصغر.\nإذا لم يكن هناك مثل هذا التكوين، فإنها تُخرج رسالة خطأ.\nمثال على الاستخدام:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "sw": "Kazi ya kazi hii ni kupata nambari M za mzima chanya ambazo jumla yake ni N na zina bidhaa ya juu zaidi inayowezekana. \nKazi hii inatoa nambari katika mpangilio mdogo wa kamusi. \nIkiwa hakuna mchanganyiko kama huo upo, inatoa ujumbe wa kosa. \nMfano wa Matumizi:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "tr": "Bu fonksiyon, toplamları N olan ve mümkün olan en yüksek çarpıma sahip M pozitif tam sayı bulur.\nFonksiyon, tam sayıları sözlükbilimsel olarak en küçük sırada çıktılar.\nEğer böyle bir kombinasyon yoksa, bir hata mesajı verir.\nÖrnek Kullanım:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "vi": "Hàm này tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể.  \nHàm xuất ra các số theo thứ tự từ điển nhỏ nhất.  \nNếu không tồn tại tổ hợp nào như vậy, nó sẽ xuất ra thông báo lỗi.  \nVí dụ Sử dụng:  \n>>> maximize_product 6 3  \n2 2 2  \n>>> maximize_product 8 3  \n2 3 3  \n>>> maximize_product 10 2  \n5 5  \n>>> maximize_product 20 5  \n4 4 4 4 4"
    },
    "docstring_bertscore": {
      "es": "0.9710156561690081",
      "arb": "0.9487160191813643",
      "sw": "0.9395804120664267",
      "tr": "0.96468987442419",
      "vi": "0.9651781079007737"
    }
  },
  {
    "task_id": "Shell/24",
    "prompt": {
      "en": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\n# It outputs the sine value in reduced fraction format.\n# The Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\n# The function assumes that the input numbers form a valid Pythagorean triplet.\n# Example Usage:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "es": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Esta función calcula el seno del ángulo agudo más pequeño en un triplete pitagórico (a, b, c).\n# Muestra el valor del seno en formato de fracción reducida.\n# El triplete pitagórico se proporciona como tres enteros positivos, que representan los lados de un triángulo rectángulo.\n# La función asume que los números de entrada forman un triplete pitagórico válido.\n# Ejemplo de uso:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "arb": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# تقوم هذه الدالة بحساب جيب الزاوية الحادة الأصغر في ثلاثية فيثاغورس (a, b, c).\n# تقوم بإخراج قيمة الجيب في صيغة كسر مبسط.\n# يتم تقديم ثلاثية فيثاغورس كثلاثة أعداد صحيحة موجبة، والتي تمثل أضلاع مثلث قائم الزاوية.\n# تفترض الدالة أن الأرقام المدخلة تشكل ثلاثية فيثاغورس صالحة.\n# مثال على الاستخدام:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "sw": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Kazi ya hii ni kuhesabu sine ya pembe ndogo kali katika Pythagorean triplet (a, b, c).\n# Inatoa thamani ya sine katika muundo wa sehemu iliyopunguzwa.\n# Pythagorean triplet inatolewa kama namba tatu za mzima chanya, ambazo zinawakilisha pande za pembetatu ya mstatili.\n# Kazi hii inadhani kwamba namba za pembejeo zinaunda Pythagorean triplet halali.\n# Mfano wa Matumizi:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "tr": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Bu fonksiyon, bir Pisagor üçlüsündeki (a, b, c) daha küçük dar açının sinüsünü hesaplar.\n# Sinüs değerini sadeleştirilmiş kesir formatında çıktılar.\n# Pisagor üçlüsü, bir dik üçgenin kenarlarını temsil eden üç pozitif tam sayı olarak verilir.\n# Fonksiyon, girilen sayıların geçerli bir Pisagor üçlüsü oluşturduğunu varsayar.\n# Örnek Kullanım:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "vi": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Hàm này tính sin của góc nhọn nhỏ hơn trong bộ ba Pythagore (a, b, c).\n# Nó xuất giá trị sin dưới dạng phân số tối giản.\n# Bộ ba Pythagore được cung cấp dưới dạng ba số nguyên dương, đại diện cho các cạnh của một tam giác vuông.\n# Hàm giả định rằng các số đầu vào tạo thành một bộ ba Pythagore hợp lệ.\n# Ví dụ sử dụng:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17"
    },
    "prompt_bertscore": {
      "es": "0.9842513916092679",
      "arb": "0.9735187962308097",
      "sw": "0.9565160356142233",
      "tr": "0.9663172531360088",
      "vi": "0.969819504014416"
    },
    "canonical_solution": "local -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}",
    "instruction": {
      "en": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n\nlocal -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n\nlocal -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n\nlocal -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n\nlocal -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n\nlocal -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n\nlocal -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8702536419561059",
      "sw": "0.9274705136258726",
      "tr": "0.8457343104603972",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_calculate_sine() {\n[[ $(calculate_sine 3 5 4) == \"3/5\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_sine 5 12 13) == \"5/13\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_sine 8 15 17) == \"8/17\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_sine 7 24 25) == \"7/25\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_sine 9 40 41) == \"9/41\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_sine",
    "entry_point": "calculate_sine",
    "signature": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n",
    "docstring": {
      "en": "This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "es": "Esta función calcula el seno del ángulo agudo más pequeño en un triplete pitagórico (a, b, c).  \nDevuelve el valor del seno en formato de fracción reducida.  \nEl triplete pitagórico se proporciona como tres enteros positivos, que representan los lados de un triángulo rectángulo.  \nLa función asume que los números de entrada forman un triplete pitagórico válido.  \nEjemplo de uso:  \n>>> calculate_sine 3 5 4  \n3/5  \n>>> calculate_sine 5 12 13  \n5/13  \n>>> calculate_sine 8 15 17  \n8/17  ",
      "arb": "هذه الدالة تحسب جيب الزاوية الحادة الأصغر في ثلاثية فيثاغورس (a, b, c).  \nتقوم بإخراج قيمة الجيب في صيغة كسر مبسط.  \nتُعطى ثلاثية فيثاغورس كثلاثة أعداد صحيحة موجبة، والتي تمثل أضلاع مثلث قائم الزاوية.  \nتفترض الدالة أن الأرقام المدخلة تشكل ثلاثية فيثاغورس صحيحة.  \nمثال على الاستخدام:  \n>>> calculate_sine 3 5 4  \n3/5  \n>>> calculate_sine 5 12 13  \n5/13  \n>>> calculate_sine 8 15 17  \n8/17  ",
      "sw": "Kazi hii inahusisha kuhesabu sine ya pembe ndogo kali katika triplet ya Pythagorean (a, b, c). Inatoa thamani ya sine katika muundo wa sehemu iliyopunguzwa. Triplet ya Pythagorean inatolewa kama nambari tatu chanya, ambazo zinawakilisha pande za pembetatu ya mstatili. Kazi hii inadhani kwamba nambari za pembejeo zinaunda triplet halali ya Pythagorean.\n\nMatumizi ya Mfano:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "tr": "Bu fonksiyon, bir Pisagor üçlüsündeki (a, b, c) daha küçük dik açının sinüsünü hesaplar.\nSinüs değerini sadeleştirilmiş kesir formatında çıktılar.\nPisagor üçlüsü, bir dik üçgenin kenarlarını temsil eden üç pozitif tamsayı olarak verilir.\nFonksiyon, girilen sayıların geçerli bir Pisagor üçlüsü oluşturduğunu varsayar.\nÖrnek Kullanım:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "vi": "Hàm này tính giá trị sin của góc nhọn nhỏ hơn trong một bộ ba số Pythagoras (a, b, c). Nó xuất ra giá trị sin dưới dạng phân số tối giản. Bộ ba số Pythagoras được cung cấp dưới dạng ba số nguyên dương, đại diện cho các cạnh của một tam giác vuông. Hàm giả định rằng các số đầu vào tạo thành một bộ ba số Pythagoras hợp lệ.\n\nVí dụ Sử Dụng:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17"
    },
    "docstring_bertscore": {
      "es": "0.9700667988388044",
      "arb": "0.9619112340238929",
      "sw": "0.9427283063450675",
      "tr": "0.9568133852946326",
      "vi": "0.9587494356185796"
    }
  },
  {
    "task_id": "Shell/25",
    "prompt": {
      "en": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# This function calculates the minimum cost needed to buy at least 'n' pencils,\n# where pencils are available in three different packaging options, each with its own quantity and price.\n# The function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\n# Each packaging option is given in the format 'quantity price'.\n# Input: Number of pencils needed and three packaging options.\n# Output: Minimum cost to buy at least 'n' pencils.\n# Example Usage:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "es": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Esta función calcula el costo mínimo necesario para comprar al menos 'n' lápices,\n# donde los lápices están disponibles en tres opciones de empaque diferentes, cada una con su propia cantidad y precio.\n# La función no permite romper el empaque, por lo que puede requerir comprar más lápices de los que se necesitan 'n'.\n# Cada opción de empaque se da en el formato 'cantidad precio'.\n# Entrada: Número de lápices necesarios y tres opciones de empaque.\n# Salida: Costo mínimo para comprar al menos 'n' lápices.\n# Ejemplo de uso:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "arb": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# هذه الدالة تحسب التكلفة الدنيا اللازمة لشراء ما لا يقل عن 'n' من الأقلام الرصاص،\n# حيث تتوفر الأقلام الرصاص في ثلاث خيارات للتغليف، كل منها يحتوي على كمية وسعر خاص به.\n# الدالة لا تسمح بتفكيك التغليف، لذلك قد يتطلب الأمر شراء المزيد من الأقلام الرصاص أكثر من 'n'.\n# كل خيار تغليف يُعطى في صيغة 'الكمية السعر'.\n# المدخلات: عدد الأقلام الرصاص المطلوبة وثلاث خيارات للتغليف.\n# المخرجات: التكلفة الدنيا لشراء ما لا يقل عن 'n' من الأقلام الرصاص.\n# مثال على الاستخدام:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "sw": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Kazi ya hii kazi ni kuhesabu gharama ya chini kabisa inayohitajika kununua angalau 'n' penseli,\n# ambapo penseli zinapatikana katika chaguo tatu tofauti za ufungaji, kila moja ikiwa na idadi na bei yake.\n# Kazi hii hairuhusu kuvunja ufungaji, hivyo inaweza kuhitaji kununua penseli zaidi ya 'n'.\n# Kila chaguo la ufungaji linatolewa katika muundo 'idadi bei'.\n# Ingizo: Idadi ya penseli zinazohitajika na chaguo tatu za ufungaji.\n# Tokeo: Gharama ya chini kabisa ya kununua angalau 'n' penseli.\n# Mfano wa Matumizi:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "tr": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Bu fonksiyon, en az 'n' kalem satın almak için gereken minimum maliyeti hesaplar,\n# kalemler, her biri kendi miktar ve fiyatına sahip üç farklı paketleme seçeneğinde mevcuttur.\n# Fonksiyon, paketlemeyi kırmaya izin vermez, bu nedenle 'n'den fazla kalem satın almayı gerektirebilir.\n# Her paketleme seçeneği 'miktar fiyat' formatında verilir.\n# Girdi: İhtiyaç duyulan kalem sayısı ve üç paketleme seçeneği.\n# Çıktı: En az 'n' kalem satın almak için minimum maliyet.\n# Örnek Kullanım:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "vi": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Hàm này tính toán chi phí tối thiểu cần thiết để mua ít nhất 'n' bút chì,\n# trong đó bút chì có sẵn trong ba tùy chọn đóng gói khác nhau, mỗi tùy chọn có số lượng và giá riêng.\n# Hàm không cho phép phá vỡ bao bì, vì vậy có thể cần mua nhiều bút chì hơn 'n'.\n# Mỗi tùy chọn đóng gói được đưa ra theo định dạng 'số lượng giá'.\n# Đầu vào: Số lượng bút chì cần thiết và ba tùy chọn đóng gói.\n# Đầu ra: Chi phí tối thiểu để mua ít nhất 'n' bút chì.\n# Ví dụ sử dụng:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18"
    },
    "prompt_bertscore": {
      "es": "0.9874856901036589",
      "arb": "0.9853668998291598",
      "sw": "0.9702417922044961",
      "tr": "0.9624858717162269",
      "vi": "0.9829982325353187"
    },
    "canonical_solution": "local min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}",
    "instruction": {
      "en": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n\nlocal min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n\nlocal min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n\nlocal min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n\nlocal min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n\nlocal min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n\nlocal min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.920868238390654",
      "sw": "0.9136909282023393",
      "tr": "0.8619552618972303",
      "vi": "0.8787562140466852"
    },
    "level": "",
    "test": "test_calculate_minimum_cost() {\n[[ $(calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\") -eq 54 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\") -eq 40 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\") -eq 27 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 80 \"8 4\" \"40 19\" \"60 28\") -eq 38 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 120 \"12 6\" \"24 9\" \"48 18\") -eq 45 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_minimum_cost",
    "entry_point": "calculate_minimum_cost",
    "signature": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n",
    "docstring": {
      "en": "This function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "es": "Esta función calcula el costo mínimo necesario para comprar al menos 'n' lápices,\ndonde los lápices están disponibles en tres opciones de empaque diferentes, cada una con su propia cantidad y precio.\nLa función no permite romper el empaque, por lo que puede requerir comprar más lápices de los que se necesitan.\nCada opción de empaque se da en el formato 'cantidad precio'.\nEntrada: Número de lápices necesarios y tres opciones de empaque.\nSalida: Costo mínimo para comprar al menos 'n' lápices.\nEjemplo de uso:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "arb": "هذه الدالة تحسب التكلفة الدنيا اللازمة لشراء ما لا يقل عن 'n' من الأقلام الرصاص، حيث تتوفر الأقلام الرصاص في ثلاث خيارات تغليف مختلفة، كل منها بكمية وسعر خاص به. لا تسمح الدالة بتقسيم التغليف، لذا قد يتطلب الأمر شراء المزيد من الأقلام الرصاص أكثر من 'n'. يتم إعطاء كل خيار تغليف في صيغة 'الكمية السعر'.\nالمدخلات: عدد الأقلام الرصاص المطلوبة وثلاث خيارات تغليف.\nالمخرجات: التكلفة الدنيا لشراء ما لا يقل عن 'n' من الأقلام الرصاص.\nمثال على الاستخدام:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "sw": "Kazi ya kazi hii ni kuhesabu gharama ya chini kabisa inayohitajika kununua angalau 'n' penseli, ambapo penseli zinapatikana katika chaguo tatu tofauti za ufungaji, kila moja ikiwa na kiasi na bei yake. Kazi hii hairuhusu kuvunja ufungaji, hivyo inaweza kuhitaji kununua penseli zaidi ya 'n'. Kila chaguo la ufungaji linatolewa katika muundo 'kiasi bei'. \nIngizo: Idadi ya penseli zinazohitajika na chaguo tatu za ufungaji. \nMatokeo: Gharama ya chini kabisa ya kununua angalau 'n' penseli. \nMfano wa Matumizi:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "tr": "Bu fonksiyon, en az 'n' kalem satın almak için gereken minimum maliyeti hesaplar,\nkalemler, her biri kendi miktar ve fiyatına sahip üç farklı paketleme seçeneğiyle sunulmaktadır.\nFonksiyon, paketlemeyi kırmaya izin vermez, bu nedenle 'n'den fazla kalem satın almak gerekebilir.\nHer paketleme seçeneği 'miktar fiyat' formatında verilir.\nGirdi: Gerekli kalem sayısı ve üç paketleme seçeneği.\nÇıktı: En az 'n' kalem satın almak için minimum maliyet.\nÖrnek Kullanım:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "vi": "Hàm này tính toán chi phí tối thiểu cần thiết để mua ít nhất 'n' bút chì,\ntrong đó bút chì có sẵn trong ba tùy chọn đóng gói khác nhau, mỗi tùy chọn có số lượng và giá riêng.\nHàm không cho phép phá vỡ bao bì, vì vậy có thể cần mua nhiều bút chì hơn 'n'.\nMỗi tùy chọn đóng gói được đưa ra theo định dạng 'số lượng giá'.\nĐầu vào: Số lượng bút chì cần thiết và ba tùy chọn đóng gói.\nĐầu ra: Chi phí tối thiểu để mua ít nhất 'n' bút chì.\nVí dụ sử dụng:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18"
    },
    "docstring_bertscore": {
      "es": "0.9895009939496389",
      "arb": "0.9720789245986878",
      "sw": "0.9655483549310228",
      "tr": "0.9592891143638513",
      "vi": "0.9762046762431635"
    }
  },
  {
    "task_id": "Shell/26",
    "prompt": {
      "en": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\n# The shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\n# Input: Shift amount 'n' and the original string.\n# Output: Transformed string representing the password.\n# Example Usage:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "es": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Esta función genera una contraseña desplazando cada letra de la cadena dada por 'n' posiciones en el alfabeto.\n# El desplazamiento envuelve el alfabeto, por lo que 'z' seguido de un desplazamiento de 1 sería 'a'.\n# Entrada: Cantidad de desplazamiento 'n' y la cadena original.\n# Salida: Cadena transformada que representa la contraseña.\n# Ejemplo de uso:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "arb": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# تقوم هذه الدالة بإنشاء كلمة مرور عن طريق تحريك كل حرف من الأحرف في السلسلة المعطاة بمقدار 'n' من المواقع في الأبجدية.\n# يتم الالتفاف حول الأبجدية، لذا فإن 'z' متبوعًا بتحريك بمقدار 1 سيكون 'a'.\n# المدخلات: مقدار التحريك 'n' والسلسلة الأصلية.\n# المخرجات: سلسلة محولة تمثل كلمة المرور.\n# مثال على الاستخدام:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "sw": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Kazi ya hii kazi ni kutengeneza nenosiri kwa kusogeza kila herufi ya neno lililotolewa kwa nafasi 'n' katika alfabeti.\n# Kusogeza huku huzunguka alfabeti, hivyo 'z' ikifuatiwa na kusogeza kwa 1 itakuwa 'a'.\n# Ingizo: Kiasi cha kusogeza 'n' na neno la asili.\n# Tokeo: Neno lililobadilishwa linalowakilisha nenosiri.\n# Mfano wa Matumizi:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "tr": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Bu fonksiyon, verilen dizenin her harfini alfabede 'n' pozisyon kaydırarak bir şifre oluşturur.\n# Kaydırma alfabeyi sarar, bu yüzden 'z' 1 pozisyon kaydırıldığında 'a' olur.\n# Girdi: Kaydırma miktarı 'n' ve orijinal dize.\n# Çıktı: Şifreyi temsil eden dönüştürülmüş dize.\n# Örnek Kullanım:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "vi": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Hàm này tạo ra một mật khẩu bằng cách dịch chuyển mỗi chữ cái của chuỗi đã cho theo 'n' vị trí trong bảng chữ cái.\n# Sự dịch chuyển này quay vòng quanh bảng chữ cái, vì vậy 'z' sau khi dịch chuyển 1 sẽ thành 'a'.\n# Đầu vào: Số lượng dịch chuyển 'n' và chuỗi gốc.\n# Đầu ra: Chuỗi đã biến đổi đại diện cho mật khẩu.\n# Ví dụ sử dụng:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab"
    },
    "prompt_bertscore": {
      "es": "0.9859002224022385",
      "arb": "0.980870503893673",
      "sw": "0.9440728353942928",
      "tr": "0.9531127026655716",
      "vi": "0.9680798991373124"
    },
    "canonical_solution": "local shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}",
    "instruction": {
      "en": "generate_password() {\nlocal shift=$1\nlocal string=$2\n\nlocal shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "generate_password() {\nlocal shift=$1\nlocal string=$2\n\nlocal shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "generate_password() {\nlocal shift=$1\nlocal string=$2\n\nlocal shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "generate_password() {\nlocal shift=$1\nlocal string=$2\n\nlocal shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "generate_password() {\nlocal shift=$1\nlocal string=$2\n\nlocal shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "generate_password() {\nlocal shift=$1\nlocal string=$2\n\nlocal shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9148916488556953",
      "sw": "0.9429899025568905",
      "tr": "0.8457343104603972",
      "vi": "0.9238182968097841"
    },
    "level": "",
    "test": "test_generate_password() {\n[[ $(generate_password 1 \"qwe\") == \"rxf\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_password 3 \"abc\") == \"def\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_password 2 \"xyz\") == \"zab\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_password 4 \"hello\") == \"lipps\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_password 5 \"password\") == \"ufxxbtwi\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_password",
    "entry_point": "generate_password",
    "signature": "generate_password() {\nlocal shift=$1\nlocal string=$2\n",
    "docstring": {
      "en": "This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "es": "Esta función genera una contraseña desplazando cada letra de la cadena dada por 'n' posiciones en el alfabeto.  \nEl desplazamiento envuelve el alfabeto, por lo que 'z' seguido de un desplazamiento de 1 sería 'a'.  \nEntrada: Cantidad de desplazamiento 'n' y la cadena original.  \nSalida: Cadena transformada que representa la contraseña.  \nEjemplo de uso:  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  ",
      "arb": "هذه الدالة تقوم بتوليد كلمة مرور عن طريق تحريك كل حرف من السلسلة المعطاة بمقدار 'n' من المواضع في الأبجدية.\nالتحريك يلتف حول الأبجدية، لذا فإن 'z' متبوعًا بتحريك بمقدار 1 سيكون 'a'.\nالمدخلات: مقدار التحريك 'n' والسلسلة الأصلية.\nالمخرجات: سلسلة محولة تمثل كلمة المرور.\nمثال على الاستخدام:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "sw": "Kazi ya kazi hii ni kuzalisha nenosiri kwa kubadilisha kila herufi ya kamba iliyotolewa kwa nafasi 'n' katika alfabeti. \nMabadiliko yanazunguka kwenye alfabeti, hivyo 'z' ikifuatiwa na mabadiliko ya 1 itakuwa 'a'. \nIngizo: Kiasi cha mabadiliko 'n' na kamba ya asili. \nMatokeo: Kamba iliyobadilishwa inayowakilisha nenosiri. \nMfano wa Matumizi:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "tr": "Bu fonksiyon, verilen dizenin her harfini alfabede 'n' pozisyon kaydırarak bir şifre oluşturur.\nKaydırma, alfabeyi döner, bu yüzden 'z' harfinden sonra 1 kaydırma 'a' olur.\nGirdi: Kaydırma miktarı 'n' ve orijinal dize.\nÇıktı: Şifreyi temsil eden dönüştürülmüş dize.\nÖrnek Kullanım:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "vi": "Hàm này tạo một mật khẩu bằng cách dịch chuyển mỗi chữ cái của chuỗi đã cho theo 'n' vị trí trong bảng chữ cái.  \nSự dịch chuyển sẽ quay vòng quanh bảng chữ cái, vì vậy 'z' sau khi dịch chuyển 1 sẽ trở thành 'a'.  \nĐầu vào: Số lượng dịch chuyển 'n' và chuỗi gốc.  \nĐầu ra: Chuỗi đã được biến đổi đại diện cho mật khẩu.  \nVí dụ Sử dụng:  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  "
    },
    "docstring_bertscore": {
      "es": "0.9794367898033632",
      "arb": "0.9649268404687646",
      "sw": "0.9430022176405147",
      "tr": "0.9295358723278734",
      "vi": "0.9581638732552887"
    }
  },
  {
    "task_id": "Shell/27",
    "prompt": {
      "en": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generate shell function\n# This function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\n# Input: Upper limit of the range 'n' and the digit 'x' to be counted.\n# Output: Number of occurrences of the digit 'x'.\n# Example Usage:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "es": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generar función de shell\n# Esta función calcula el número de veces que un dígito específico 'x' aparece en todos los enteros desde 1 hasta 'n'.\n# Entrada: Límite superior del rango 'n' y el dígito 'x' a contar.\n# Salida: Número de ocurrencias del dígito 'x'.\n# Ejemplo de uso:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "arb": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# توليد دالة شيل\n# تقوم هذه الدالة بحساب عدد المرات التي يظهر فيها رقم معين 'x' في جميع الأعداد الصحيحة من 1 إلى 'n'.\n# المدخلات: الحد الأعلى للنطاق 'n' والرقم 'x' الذي سيتم حسابه.\n# المخرجات: عدد مرات ظهور الرقم 'x'.\n# مثال على الاستخدام:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "sw": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# tengeneza kazi ya ganda\n# Kazi hii inahesabu idadi ya mara ambazo tarakimu maalum 'x' inajitokeza katika nambari zote kutoka 1 hadi 'n'.\n# Ingizo: Kiwango cha juu cha safu 'n' na tarakimu 'x' inayohesabiwa.\n# Matokeo: Idadi ya matukio ya tarakimu 'x'.\n# Mfano wa Matumizi:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "tr": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# shell fonksiyonu oluştur\n# Bu fonksiyon, belirli bir 'x' rakamının 1'den 'n'ye kadar olan tüm tamsayılarda kaç kez göründüğünü hesaplar.\n# Girdi: Aralığın üst sınırı 'n' ve sayılacak rakam 'x'.\n# Çıktı: 'x' rakamının kaç kez geçtiği.\n# Örnek Kullanım:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "vi": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# tạo hàm shell\n# Hàm này tính số lần một chữ số cụ thể 'x' xuất hiện trong tất cả các số nguyên từ 1 đến 'n'.\n# Đầu vào: Giới hạn trên của phạm vi 'n' và chữ số 'x' cần đếm.\n# Đầu ra: Số lần xuất hiện của chữ số 'x'.\n# Ví dụ sử dụng:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20"
    },
    "prompt_bertscore": {
      "es": "0.9935913893862903",
      "arb": "0.9746843593067225",
      "sw": "0.9822180123986137",
      "tr": "0.9746748250484328",
      "vi": "0.9902033509769783"
    },
    "canonical_solution": "local count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n\nlocal count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n\nlocal count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n\nlocal count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود الشيل باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n\nlocal count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n\nlocal count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n\nlocal count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.925975025487061",
      "sw": "0.9148459638680573",
      "tr": "0.8521282224259102",
      "vi": "0.9237231528572685"
    },
    "level": "",
    "test": "test_count_digit_occurrences() {\n[[ $(count_digit_occurrences 11 1) -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_digit_occurrences 20 2) -eq 3 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_digit_occurrences 100 3) -eq 20 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_digit_occurrences 50 4) -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_digit_occurrences 99 5) -eq 20 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_count_digit_occurrences",
    "entry_point": "count_digit_occurrences",
    "signature": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n",
    "docstring": {
      "en": "generate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "es": "generar función de shell  \nEsta función calcula el número de veces que un dígito específico 'x' aparece en todos los enteros desde 1 hasta 'n'.  \nEntrada: Límite superior del rango 'n' y el dígito 'x' que se va a contar.  \nSalida: Número de ocurrencias del dígito 'x'.  \nEjemplo de uso:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "arb": "توليد دالة shell  \nهذه الدالة تحسب عدد المرات التي يظهر فيها رقم معين 'x' في جميع الأعداد الصحيحة من 1 إلى 'n'.  \nالمدخلات: الحد الأعلى للنطاق 'n' والرقم 'x' الذي سيتم عده.  \nالمخرجات: عدد مرات ظهور الرقم 'x'.  \nمثال على الاستخدام:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "sw": "tengeneza kazi ya ganda  \nKazi ya hii kazi ni kuhesabu mara ngapi tarakimu maalum 'x' inaonekana katika namba zote kutoka 1 hadi 'n'.  \nIngizo: Kiwango cha juu cha safu 'n' na tarakimu 'x' inayohesabiwa.  \nPato: Idadi ya matukio ya tarakimu 'x'.  \nMfano wa Matumizi:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "tr": "hell fonksiyonu oluştur  \nBu fonksiyon, belirli bir 'x' rakamının 1'den 'n'ye kadar olan tüm tamsayılarda kaç kez göründüğünü hesaplar.  \nGirdi: Aralık üst sınırı 'n' ve sayılacak rakam 'x'.  \nÇıktı: 'x' rakamının kaç kez geçtiği.  \nÖrnek Kullanım:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "vi": "tạo hàm shell  \nHàm này tính số lần một chữ số cụ thể 'x' xuất hiện trong tất cả các số nguyên từ 1 đến 'n'.  \nĐầu vào: Giới hạn trên của phạm vi 'n' và chữ số 'x' cần đếm.  \nĐầu ra: Số lần xuất hiện của chữ số 'x'.  \nVí dụ sử dụng:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  "
    },
    "docstring_bertscore": {
      "es": "0.9941157735922225",
      "arb": "0.94743882583131",
      "sw": "0.9568976045761913",
      "tr": "0.981400251119893",
      "vi": "0.9899379807879156"
    }
  },
  {
    "task_id": "Shell/28",
    "prompt": {
      "en": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# This function converts a number 'N' from base 'M' to its decimal representation as an expression.\n# It outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\n# Coefficients that are zero are omitted in the output.\n# Input: Base 'M' and number 'N' in base 'M'.\n# Output: Decimal representation as an expression.\n# Example Usage:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "es": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Esta función convierte un número 'N' de base 'M' a su representación decimal como una expresión.\n# Muestra la expresión como una suma de términos, cada término en la forma de coeficiente*base^potencia.\n# Los coeficientes que son cero se omiten en la salida.\n# Entrada: Base 'M' y número 'N' en base 'M'.\n# Salida: Representación decimal como una expresión.\n# Ejemplo de uso:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "arb": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# تقوم هذه الدالة بتحويل رقم 'N' من الأساس 'M' إلى تمثيله العشري كتعبير.\n# تقوم بإخراج التعبير كمجموع من الحدود، كل حد في شكل معامل*أساس^قوة.\n# يتم حذف المعاملات التي تساوي صفر في الإخراج.\n# المدخل: الأساس 'M' والرقم 'N' في الأساس 'M'.\n# المخرج: التمثيل العشري كتعبير.\n# مثال على الاستخدام:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "sw": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Kazi ya hii kazi ni kubadilisha nambari 'N' kutoka msingi 'M' hadi uwakilishi wake wa desimali kama usemi.\n# Inatoa usemi kama jumla ya vigezo, kila kigezo katika umbo la coefficient*base^power.\n# Vigezo ambavyo ni sifuri havionyeshwi katika matokeo.\n# Ingizo: Msingi 'M' na nambari 'N' katika msingi 'M'.\n# Matokeo: Uwakilishi wa desimali kama usemi.\n# Mfano wa Matumizi:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "tr": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Bu fonksiyon, 'N' sayısını 'M' tabanından ondalık gösterimine bir ifade olarak dönüştürür.\n# Her terim, katsayı*taban^kuvvet şeklinde bir terim toplamı olarak ifadeyi çıktılar.\n# Katsayıları sıfır olan terimler çıktıda atlanır.\n# Girdi: Taban 'M' ve 'M' tabanında sayı 'N'.\n# Çıktı: Ondalık gösterim olarak ifade.\n# Örnek Kullanım:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "vi": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Hàm này chuyển đổi một số 'N' từ cơ số 'M' sang biểu diễn thập phân dưới dạng một biểu thức.\n# Nó xuất biểu thức dưới dạng tổng của các hạng tử, mỗi hạng tử có dạng hệ số*cơ số^mũ.\n# Các hệ số bằng không sẽ bị loại bỏ trong đầu ra.\n# Đầu vào: Cơ số 'M' và số 'N' trong cơ số 'M'.\n# Đầu ra: Biểu diễn thập phân dưới dạng một biểu thức.\n# Ví dụ sử dụng:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0"
    },
    "prompt_bertscore": {
      "es": "0.9965859410107724",
      "arb": "0.9885066502621782",
      "sw": "0.9650323132010942",
      "tr": "0.9568868785356155",
      "vi": "0.9692923389831494"
    },
    "canonical_solution": "local length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}",
    "instruction": {
      "en": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n\nlocal length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n\nlocal length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n\nlocal length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n\nlocal length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n\nlocal length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n\nlocal length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.895333508387095",
      "sw": "0.9136909282023393",
      "tr": "0.8547378283719466",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_convert_to_decimal_expression() {\n[[ $(convert_to_decimal_expression 2 10101) == \"1*2^4+1*2^2+1*2^0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 3 102) == \"1*3^2+2*3^0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 5 143) == \"1*5^2+4*5^1+3*5^0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 8 123) == \"1*8^2+2*8^1+3*8^0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 4 1302) == \"1*4^3+3*4^2+2*4^0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_convert_to_decimal_expression",
    "entry_point": "convert_to_decimal_expression",
    "signature": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n",
    "docstring": {
      "en": "This function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "es": "Esta función convierte un número 'N' de base 'M' a su representación decimal como una expresión.\nProduce la expresión como una suma de términos, cada término en la forma de coeficiente*base^potencia.\nLos coeficientes que son cero se omiten en la salida.\nEntrada: Base 'M' y número 'N' en base 'M'.\nSalida: Representación decimal como una expresión.\nEjemplo de uso:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "arb": "هذه الدالة تحول الرقم 'N' من الأساس 'M' إلى تمثيله العشري كتعبير.\nتقوم بإخراج التعبير كمجموع من الحدود، كل حد في شكل معامل*أساس^قوة.\nالمعاملات التي تكون صفر يتم حذفها في الناتج.\nالمدخل: الأساس 'M' والرقم 'N' في الأساس 'M'.\nالناتج: التمثيل العشري كتعبير.\nمثال على الاستخدام:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "sw": "Kazi ya kazi hii ni kubadilisha namba 'N' kutoka msingi 'M' hadi uwakilishi wake wa desimali kama usemi.\nInatoa usemi kama jumla ya vigezo, kila kigezo katika mfumo wa coefficient*base^power.\nViwango ambavyo ni sifuri havijumuishwi katika matokeo.\nIngizo: Msingi 'M' na namba 'N' katika msingi 'M'.\nMatokeo: Uwakilishi wa desimali kama usemi.\nMfano wa Matumizi:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "tr": "Bu fonksiyon, 'N' sayısını 'M' tabanından ondalık gösterimine bir ifade olarak dönüştürür.\nÇıktı, her terim katsayı*taban^kuvvet formunda olacak şekilde terimlerin toplamı olarak verilir.\nKatsayıları sıfır olan terimler çıktıda yer almaz.\nGirdi: 'M' tabanı ve 'M' tabanında 'N' sayısı.\nÇıktı: Ondalık gösterim olarak ifade.\nÖrnek Kullanım:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "vi": "Hàm này chuyển đổi một số 'N' từ cơ số 'M' sang biểu diễn thập phân dưới dạng một biểu thức.  \nNó xuất ra biểu thức dưới dạng tổng của các hạng tử, mỗi hạng tử có dạng hệ số*cơ số^mũ.  \nCác hệ số bằng không sẽ bị loại bỏ trong đầu ra.  \nĐầu vào: Cơ số 'M' và số 'N' trong cơ số 'M'.  \nĐầu ra: Biểu diễn thập phân dưới dạng một biểu thức.  \nVí dụ sử dụng:  \n>>> convert_to_decimal_expression 2 10101  \n1*2^4+1*2^2+1*2^0  \n>>> convert_to_decimal_expression 3 102  \n1*3^2+2*3^0  "
    },
    "docstring_bertscore": {
      "es": "0.9914235374076756",
      "arb": "0.9892685964038281",
      "sw": "0.9505577200743198",
      "tr": "0.9419540451197936",
      "vi": "0.9613669867798573"
    }
  },
  {
    "task_id": "Shell/29",
    "prompt": {
      "en": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\n# If it's not possible to form such a number, the function returns -1.\n# Input: A string of numbers (only 0s and 5s) representing the cards.\n# Output: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\n# Example Usage:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "es": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Esta función organiza cartas con números 0 y 5 para formar el número más grande divisible por 90.\n# Si no es posible formar tal número, la función devuelve -1.\n# Entrada: Una cadena de números (solo 0s y 5s) que representan las cartas.\n# Salida: El número más grande divisible por 90 que se puede formar, o -1 si no es posible.\n# Ejemplo de uso:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "arb": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# تقوم هذه الدالة بترتيب البطاقات التي تحتوي على الأرقام 0 و 5 لتشكيل أكبر عدد قابل للقسمة على 90.\n# إذا لم يكن من الممكن تشكيل مثل هذا العدد، فإن الدالة تعيد -1.\n# المدخل: سلسلة من الأرقام (فقط 0 و 5) تمثل البطاقات.\n# المخرج: أكبر عدد قابل للقسمة على 90 يمكن تشكيله، أو -1 إذا لم يكن ذلك ممكنًا.\n# مثال على الاستخدام:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "sw": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Kazi ya hii kazi ni kupanga kadi zenye namba 0 na 5 ili kuunda namba kubwa zaidi inayogawanyika kwa 90.\n# Ikiwa haiwezekani kuunda namba kama hiyo, kazi inarudisha -1.\n# Ingizo: Mfuatano wa namba (ni 0 na 5 pekee) zinazowakilisha kadi.\n# Tokeo: Namba kubwa zaidi inayogawanyika kwa 90 inayoweza kuundwa, au -1 ikiwa haiwezekani.\n# Mfano wa Matumizi:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "tr": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Bu fonksiyon, 0 ve 5 rakamlarına sahip kartları 90'a bölünebilen en büyük sayıyı oluşturacak şekilde düzenler.\n# Eğer böyle bir sayı oluşturmak mümkün değilse, fonksiyon -1 döndürür.\n# Girdi: Kartları temsil eden bir sayı dizisi (sadece 0 ve 5'ler).\n# Çıktı: Oluşturulabilecek 90'a bölünebilen en büyük sayı veya mümkün değilse -1.\n# Örnek Kullanım:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "vi": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Hàm này sắp xếp các lá bài với các số 0 và 5 để tạo thành số lớn nhất chia hết cho 90.\n# Nếu không thể tạo thành một số như vậy, hàm sẽ trả về -1.\n# Đầu vào: Một chuỗi các số (chỉ gồm 0 và 5) đại diện cho các lá bài.\n# Đầu ra: Số lớn nhất chia hết cho 90 có thể được tạo thành, hoặc -1 nếu không thể.\n# Ví dụ sử dụng:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1"
    },
    "prompt_bertscore": {
      "es": "0.9984532652228814",
      "arb": "0.9848178854559794",
      "sw": "0.9769739717089116",
      "tr": "0.9831889177011123",
      "vi": "0.9842982683791921"
    },
    "canonical_solution": "local count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}",
    "instruction": {
      "en": "arrange_cards_for_max_number() {\nlocal cards=($1)\n\nlocal count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "arrange_cards_for_max_number() {\nlocal cards=($1)\n\nlocal count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "arrange_cards_for_max_number() {\nlocal cards=($1)\n\nlocal count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "arrange_cards_for_max_number() {\nlocal cards=($1)\n\nlocal count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "arrange_cards_for_max_number() {\nlocal cards=($1)\n\nlocal count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "arrange_cards_for_max_number() {\nlocal cards=($1)\n\nlocal count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.920868238390654",
      "sw": "0.8784135766394001",
      "tr": "0.8612896514903824",
      "vi": "0.9466864139479498"
    },
    "level": "",
    "test": "test_arrange_cards_for_max_number() {\n[[ $(arrange_cards_for_max_number \"5 0 5 0\") == \"0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\") == \"5555555550\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5\") == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 5 0\") == \"5555555550\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_arrange_cards_for_max_number",
    "entry_point": "arrange_cards_for_max_number",
    "signature": "arrange_cards_for_max_number() {\nlocal cards=($1)\n",
    "docstring": {
      "en": "This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "es": "Esta función organiza cartas con números 0 y 5 para formar el número más grande divisible por 90.  \nSi no es posible formar tal número, la función devuelve -1.  \nEntrada: Una cadena de números (solo 0s y 5s) que representan las cartas.  \nSalida: El número más grande divisible por 90 que se puede formar, o -1 si no es posible.  \nEjemplo de uso:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "arb": "هذه الدالة ترتب البطاقات التي تحتوي على الأرقام 0 و5 لتكوين أكبر رقم قابل للقسمة على 90.  \nإذا لم يكن من الممكن تكوين مثل هذا الرقم، فإن الدالة تعيد -1.  \nالمدخل: سلسلة من الأرقام (فقط 0 و5) تمثل البطاقات.  \nالمخرج: أكبر رقم قابل للقسمة على 90 يمكن تكوينه، أو -1 إذا لم يكن ذلك ممكنًا.  \nمثال على الاستخدام:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "sw": "Kazi hii inapanga kadi zenye namba 0 na 5 ili kuunda namba kubwa zaidi inayogawanyika kwa 90.  \nIkiwa haiwezekani kuunda namba kama hiyo, kazi inarudisha -1.  \nIngizo: Mfuatano wa namba (ni 0 na 5 pekee) unaowakilisha kadi.  \nMatokeo: Namba kubwa zaidi inayogawanyika kwa 90 inayoweza kuundwa, au -1 ikiwa haiwezekani.  \nMfano wa Matumizi:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "tr": "Bu fonksiyon, 0 ve 5 sayılarıyla kartları düzenleyerek 90'a bölünebilen en büyük sayıyı oluşturur.\nBöyle bir sayı oluşturmak mümkün değilse, fonksiyon -1 döndürür.\nGirdi: Kartları temsil eden bir sayı dizisi (yalnızca 0 ve 5'ler).\nÇıktı: Oluşturulabilecek 90'a bölünebilen en büyük sayı veya mümkün değilse -1.\nÖrnek Kullanım:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "vi": "Hàm này sắp xếp các lá bài với số 0 và 5 để tạo thành số lớn nhất chia hết cho 90.  \nNếu không thể tạo ra một số như vậy, hàm trả về -1.  \nĐầu vào: Một chuỗi các số (chỉ 0 và 5) đại diện cho các lá bài.  \nĐầu ra: Số lớn nhất chia hết cho 90 có thể được tạo thành, hoặc -1 nếu không thể.  \nVí dụ sử dụng:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  "
    },
    "docstring_bertscore": {
      "es": "0.9919616271098991",
      "arb": "0.9782444116260107",
      "sw": "0.9545341016722572",
      "tr": "0.975552572702226",
      "vi": "0.9571826391729764"
    }
  },
  {
    "task_id": "Shell/30",
    "prompt": {
      "en": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\n# Input: The number of elements 'N' and the permutation 'X' as a string.\n# Output: The lexicographical rank of the permutation.\n# The permutation is considered as a sequence of digits without spaces.\n# Example Usage:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "es": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Esta función calcula el rango lexicográfico de una permutación dada de números del 1 al 'N'.\n# Entrada: El número de elementos 'N' y la permutación 'X' como una cadena.\n# Salida: El rango lexicográfico de la permutación.\n# La permutación se considera como una secuencia de dígitos sin espacios.\n# Ejemplo de uso:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "arb": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# تقوم هذه الدالة بحساب الترتيب المعجمي لتبديل معين من الأرقام من 1 إلى 'N'.\n# المدخل: عدد العناصر 'N' والتبديل 'X' كسلسلة نصية.\n# المخرج: الترتيب المعجمي للتبديل.\n# يعتبر التبديل كسلسلة من الأرقام بدون فراغات.\n# مثال على الاستخدام:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "sw": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Kazi hii inahesabu cheo cha leksikografia cha mpangilio uliotolewa wa nambari kutoka 1 hadi 'N'.\n# Ingizo: Idadi ya vipengele 'N' na mpangilio 'X' kama kamba.\n# Matokeo: Cheo cha leksikografia cha mpangilio huo.\n# Mpangilio unachukuliwa kama mlolongo wa tarakimu bila nafasi.\n# Mfano wa Matumizi:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "tr": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Bu fonksiyon, 1'den 'N'ye kadar olan sayıların verilen bir permütasyonunun leksikografik sırasını hesaplar.\n# Girdi: Eleman sayısı 'N' ve permütasyon 'X' bir string olarak.\n# Çıktı: Permütasyonun leksikografik sırası.\n# Permütasyon, boşluksuz bir rakam dizisi olarak kabul edilir.\n# Örnek Kullanım:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "vi": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Hàm này tính toán thứ hạng từ điển của một hoán vị cho trước của các số từ 1 đến 'N'.\n# Đầu vào: Số lượng phần tử 'N' và hoán vị 'X' dưới dạng chuỗi.\n# Đầu ra: Thứ hạng từ điển của hoán vị.\n# Hoán vị được coi là một dãy các chữ số không có khoảng trắng.\n# Ví dụ sử dụng:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8"
    },
    "prompt_bertscore": {
      "es": "0.99781387402633",
      "arb": "0.9720002669677981",
      "sw": "0.9786595491223736",
      "tr": "0.9816874706508695",
      "vi": "0.9854560848702445"
    },
    "canonical_solution": "local rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}",
    "instruction": {
      "en": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n\nlocal rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n\nlocal rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n\nlocal rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n\nlocal rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n\nlocal rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n\nlocal rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9343580220882574",
      "sw": "0.9429899025568905",
      "tr": "0.8487360127785964",
      "vi": "0.9497659793755147"
    },
    "level": "",
    "test": "test_calculate_lexicographical_rank() {\n[[ $(calculate_lexicographical_rank 3 \"231\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"2143\") -eq 8 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 5 \"31245\") -eq 49 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 3 \"123\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"4321\") -eq 24 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_lexicographical_rank",
    "entry_point": "calculate_lexicographical_rank",
    "signature": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n",
    "docstring": {
      "en": "This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "es": "Esta función calcula el rango lexicográfico de una permutación dada de números del 1 al 'N'.\nEntrada: El número de elementos 'N' y la permutación 'X' como una cadena.\nSalida: El rango lexicográfico de la permutación.\nLa permutación se considera como una secuencia de dígitos sin espacios.\nEjemplo de uso:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "arb": "هذه الدالة تحسب الترتيب المعجمي لتبديل معين من الأرقام من 1 إلى 'N'.\nالمدخلات: عدد العناصر 'N' والتبديل 'X' كسلسلة نصية.\nالمخرجات: الترتيب المعجمي للتبديل.\nيُعتبر التبديل كسلسلة من الأرقام بدون مسافات.\nمثال على الاستخدام:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "sw": "Kazi hii inahesabu cheo cha leksikografia cha mpangilio fulani wa nambari kutoka 1 hadi 'N'.\nIngizo: Idadi ya vipengele 'N' na mpangilio 'X' kama kamba.\nPato: Cheo cha leksikografia cha mpangilio.\nMpangilio unachukuliwa kama mlolongo wa tarakimu bila nafasi.\nMfano wa Matumizi:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "tr": "Bu fonksiyon, 1'den 'N'ye kadar olan sayıların verilen bir permütasyonunun sözlük sırasındaki derecesini hesaplar.\nGirdi: Eleman sayısı 'N' ve permütasyon 'X' bir dize olarak.\nÇıktı: Permütasyonun sözlük sırasındaki derecesi.\nPermütasyon, boşluksuz bir rakam dizisi olarak kabul edilir.\nÖrnek Kullanım:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "vi": "Hàm này tính thứ hạng từ điển của một hoán vị cho trước của các số từ 1 đến 'N'.\nĐầu vào: Số lượng phần tử 'N' và hoán vị 'X' dưới dạng chuỗi.\nĐầu ra: Thứ hạng từ điển của hoán vị.\nHoán vị được coi như một dãy chữ số không có khoảng trắng.\nVí dụ Sử dụng:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8"
    },
    "docstring_bertscore": {
      "es": "0.9969738661449334",
      "arb": "0.9688829617678365",
      "sw": "0.9676069602000683",
      "tr": "1",
      "vi": "0.9831944793517812"
    }
  },
  {
    "task_id": "Shell/31",
    "prompt": {
      "en": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\n# Input: A string of integers representing the sequence.\n# Output: The maximum sum of a continuous non-empty subsequence.\n# Example Usage:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "es": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Esta función encuentra la suma máxima de una subsecuencia continua no vacía en una secuencia dada de enteros.\n# Entrada: Una cadena de enteros que representa la secuencia.\n# Salida: La suma máxima de una subsecuencia continua no vacía.\n# Ejemplo de uso:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "arb": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# هذه الدالة تجد المجموع الأقصى لتسلسل فرعي متصل وغير فارغ في تسلسل معين من الأعداد الصحيحة.\n# المدخل: سلسلة من الأعداد الصحيحة تمثل التسلسل.\n# المخرج: المجموع الأقصى لتسلسل فرعي متصل وغير فارغ.\n# مثال على الاستخدام:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "sw": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Kazi ya hii kazi ni kupata jumla kubwa zaidi ya mfuatano usio na nafasi tupu katika mfuatano uliotolewa wa nambari za mzima.\n# Ingizo: Mfuatano wa nambari za mzima unaowakilisha mfuatano.\n# Tokeo: Jumla kubwa zaidi ya mfuatano usio na nafasi tupu.\n# Mfano wa Matumizi:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "tr": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Bu fonksiyon, verilen bir tamsayı dizisindeki ardışık ve boş olmayan bir alt dizinin maksimum toplamını bulur.\n# Girdi: Diziyi temsil eden bir tamsayılar dizisi.\n# Çıktı: Ardışık ve boş olmayan bir alt dizinin maksimum toplamı.\n# Örnek Kullanım:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "vi": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Hàm này tìm tổng lớn nhất của một dãy con liên tục không rỗng trong một dãy số nguyên đã cho.\n# Đầu vào: Một chuỗi các số nguyên đại diện cho dãy số.\n# Đầu ra: Tổng lớn nhất của một dãy con liên tục không rỗng.\n# Ví dụ sử dụng:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11"
    },
    "prompt_bertscore": {
      "es": "0.9964463038529048",
      "arb": "0.9713843141562089",
      "sw": "0.9565406657814717",
      "tr": "0.9735628921753995",
      "vi": "0.9826323553734525"
    },
    "canonical_solution": "local max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}",
    "instruction": {
      "en": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9210064851358543",
      "sw": "0.9148459638680573",
      "tr": "0.8485630057167151",
      "vi": "0.9275384452161866"
    },
    "level": "",
    "test": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\nlocal max_so_far=0\nlocal max_ending_here=0\n\nfor i in \"${sequence[@]}\"; do\nmax_ending_here=$((max_ending_here + i))\nif [[ max_ending_here -lt 0 ]]; then\nmax_ending_here=0\nfi\nif [[ max_so_far -lt max_ending_here ]]; then\nmax_so_far=$max_ending_here\nfi\ndone\n\necho $max_so_far\n}",
    "entry_point": "calculate_max_subsequence_sum",
    "signature": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n",
    "docstring": {
      "en": "This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "es": "Esta función encuentra la suma máxima de una subsecuencia continua no vacía en una secuencia dada de enteros.  \nEntrada: Una cadena de enteros que representa la secuencia.  \nSalida: La suma máxima de una subsecuencia continua no vacía.  \nEjemplo de uso:  \n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"  \n4  \n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"  \n-1  \n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"  \n11  ",
      "arb": "هذه الدالة تجد مجموع القيم الأعظم لتسلسل فرعي متصل وغير فارغ في تسلسل معين من الأعداد الصحيحة.\nالمدخلات: سلسلة من الأعداد الصحيحة تمثل التسلسل.\nالمخرجات: مجموع القيم الأعظم لتسلسل فرعي متصل وغير فارغ.\nمثال على الاستخدام:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "sw": "Kazi ya kazi hii ni kupata jumla ya juu zaidi ya mlolongo usio na tupu unaoendelea katika mlolongo uliotolewa wa nambari nzima.\nIngizo: Mlolongo wa nambari nzima unaowakilisha mlolongo.\nMatokeo: Jumla ya juu zaidi ya mlolongo usio na tupu unaoendelea.\nMfano wa Matumizi:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "tr": "Bu fonksiyon, verilen bir tamsayı dizisinde ardışık ve boş olmayan bir alt dizinin maksimum toplamını bulur.\nGirdi: Diziyi temsil eden bir tamsayılar dizisi.\nÇıktı: Ardışık ve boş olmayan bir alt dizinin maksimum toplamı.\nÖrnek Kullanım:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "vi": "Hàm này tìm tổng lớn nhất của một dãy con liên tục không rỗng trong một dãy số nguyên đã cho.  \nĐầu vào: Một chuỗi các số nguyên đại diện cho dãy số.  \nĐầu ra: Tổng lớn nhất của một dãy con liên tục không rỗng.  \nVí dụ sử dụng:  \n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"  \n4  \n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"  \n-1  \n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"  \n11  "
    },
    "docstring_bertscore": {
      "es": "0.9944909863819974",
      "arb": "0.9442659041246586",
      "sw": "0.9498045136694355",
      "tr": "0.9401508785207588",
      "vi": "0.9864746614641914"
    }
  },
  {
    "task_id": "Shell/32",
    "prompt": {
      "en": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# This function calculates the minimum number of bridge rotations required to sort train carriages.\n# The bridge can hold two carriages at a time and rotate 180 degrees to swap them.\n# Input: Number of carriages 'N' and a string representing the initial order of carriages.\n# Output: The minimum number of bridge rotations needed to sort the carriages in ascending order.\n# Example Usage:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "es": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Esta función calcula el número mínimo de rotaciones de puente necesarias para ordenar los vagones del tren.\n# El puente puede sostener dos vagones a la vez y girar 180 grados para intercambiarlos.\n# Entrada: Número de vagones 'N' y una cadena que representa el orden inicial de los vagones.\n# Salida: El número mínimo de rotaciones de puente necesarias para ordenar los vagones en orden ascendente.\n# Ejemplo de uso:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "arb": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# هذه الدالة تحسب الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب عربات القطار.\n# يمكن للجسر أن يحمل عربتين في وقت واحد ويدور 180 درجة لتبديلهما.\n# المدخلات: عدد العربات 'N' وسلسلة نصية تمثل الترتيب الأولي للعربات.\n# المخرجات: الحد الأدنى لعدد دورانات الجسر اللازمة لترتيب العربات بترتيب تصاعدي.\n# مثال على الاستخدام:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "sw": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Kazi ya hii ni kuhesabu idadi ndogo zaidi ya mizunguko ya daraja inayohitajika kupanga mabehewa ya treni.\n# Daraja linaweza kushikilia mabehewa mawili kwa wakati mmoja na kuzunguka kwa digrii 180 ili kubadilisha nafasi zao.\n# Ingizo: Idadi ya mabehewa 'N' na kamba inayoonyesha mpangilio wa awali wa mabehewa.\n# Tokeo: Idadi ndogo zaidi ya mizunguko ya daraja inayohitajika kupanga mabehewa kwa mpangilio wa kupanda.\n# Mfano wa Matumizi:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "tr": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Bu fonksiyon, tren vagonlarını sıralamak için gereken minimum köprü dönüşü sayısını hesaplar.\n# Köprü, aynı anda iki vagon tutabilir ve onları değiştirmek için 180 derece dönebilir.\n# Girdi: Vagon sayısı 'N' ve vagonların başlangıç sırasını temsil eden bir dize.\n# Çıktı: Vagonları artan sırayla sıralamak için gereken minimum köprü dönüşü sayısı.\n# Örnek Kullanım:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "vi": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Hàm này tính toán số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu.\n# Cầu có thể giữ hai toa tàu cùng một lúc và quay 180 độ để hoán đổi chúng.\n# Đầu vào: Số lượng toa tàu 'N' và một chuỗi đại diện cho thứ tự ban đầu của các toa tàu.\n# Đầu ra: Số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu theo thứ tự tăng dần.\n# Ví dụ sử dụng:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2"
    },
    "prompt_bertscore": {
      "es": "0.9906031939340015",
      "arb": "0.9757410729338281",
      "sw": "0.9605593556505695",
      "tr": "0.9837691170441152",
      "vi": "0.9833285548589797"
    },
    "canonical_solution": "local count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n\nlocal count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n\nlocal count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n\nlocal count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n\nlocal count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n\nlocal count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n\nlocal count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9020958797094277",
      "sw": "0.8784135766394001",
      "tr": "0.832035368971564",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_calculate_min_bridge_rotations() {\n[[ $(calculate_min_bridge_rotations 4 \"4 3 2 1\") -eq 6 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 5 \"5 4 3 2 1\") -eq 10 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 3 \"3 1 2\") -eq 2 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 6 \"6 5 4 3 2 1\") -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n}\n\ntest_calculate_min_bridge_rotations",
    "entry_point": "calculate_min_bridge_rotations",
    "signature": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n",
    "docstring": {
      "en": "This function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "es": "Esta función calcula el número mínimo de rotaciones de puente necesarias para ordenar los vagones del tren.\nEl puente puede sostener dos vagones a la vez y girar 180 grados para intercambiarlos.\nEntrada: Número de vagones 'N' y una cadena que representa el orden inicial de los vagones.\nSalida: El número mínimo de rotaciones de puente necesarias para ordenar los vagones en orden ascendente.\nEjemplo de uso:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "arb": "هذه الدالة تحسب الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب عربات القطار.\nيمكن للجسر أن يحمل عربتين في وقت واحد ويدور 180 درجة لتبديلهما.\nالمدخلات: عدد العربات 'N' وسلسلة نصية تمثل الترتيب الأولي للعربات.\nالمخرجات: الحد الأدنى لعدد دورانات الجسر المطلوبة لترتيب العربات بترتيب تصاعدي.\nمثال على الاستخدام:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "sw": "Kazi ya hii ni kuhesabu idadi ndogo zaidi ya mizunguko ya daraja inayohitajika kupanga mabehewa ya treni.\nKazi ya daraja ni kushikilia mabehewa mawili kwa wakati mmoja na kuzunguka kwa digrii 180 ili kubadilisha nafasi zao.\nIngizo: Idadi ya mabehewa 'N' na kamba inayoonyesha mpangilio wa awali wa mabehewa.\nMatokeo: Idadi ndogo ya mizunguko ya daraja inayohitajika kupanga mabehewa kwa mpangilio wa kupanda.\nMfano wa Matumizi:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "tr": "Bu fonksiyon, tren vagonlarını sıralamak için gereken minimum köprü dönüş sayısını hesaplar.\nKöprü, aynı anda iki vagon taşıyabilir ve onları değiştirmek için 180 derece dönebilir.\nGirdi: Vagon sayısı 'N' ve vagonların başlangıç sırasını temsil eden bir dize.\nÇıktı: Vagonları artan sıraya göre sıralamak için gereken minimum köprü dönüş sayısı.\nÖrnek Kullanım:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "vi": "Hàm này tính toán số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu. Cầu có thể giữ hai toa tàu cùng một lúc và quay 180 độ để hoán đổi chúng. \nĐầu vào: Số lượng toa tàu 'N' và một chuỗi đại diện cho thứ tự ban đầu của các toa tàu. \nĐầu ra: Số lần quay cầu tối thiểu cần thiết để sắp xếp các toa tàu theo thứ tự tăng dần. \nVí dụ sử dụng:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2"
    },
    "docstring_bertscore": {
      "es": "0.9729709736399155",
      "arb": "0.9638802569910918",
      "sw": "0.9580540306545765",
      "tr": "0.9529587641202695",
      "vi": "0.9701772373306599"
    }
  },
  {
    "task_id": "Shell/33",
    "prompt": {
      "en": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# This function checks if the given word is a \"Lucky Word\".\n# A word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\n# Input: A single word consisting of lowercase letters and with a length less than 100.\n# Output: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\n# Example Usage:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "es": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Esta función verifica si la palabra dada es una \"Palabra de la Suerte\".\n# Una palabra se considera \"de la Suerte\" si la diferencia entre la frecuencia más alta y la más baja de las letras es un número primo.\n# Entrada: Una sola palabra que consiste en letras minúsculas y con una longitud menor a 100.\n# Salida: Dos líneas - la primera línea es 'Lucky Word' o 'No Answer', y la segunda línea es la diferencia si la palabra es \"de la Suerte\", o 0 de lo contrario.\n# Ejemplo de uso:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "arb": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# هذه الدالة تتحقق مما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\".\n# تعتبر الكلمة \"محظوظة\" إذا كان الفرق بين أعلى وأدنى تكرار للحروف هو عدد أولي.\n# المدخل: كلمة واحدة تتكون من حروف صغيرة وطولها أقل من 100.\n# المخرج: سطران - السطر الأول إما 'كلمة محظوظة' أو 'لا إجابة'، والسطر الثاني هو الفرق إذا كانت الكلمة \"محظوظة\"، أو 0 خلاف ذلك.\n# مثال على الاستخدام:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "sw": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Kazi hii hukagua kama neno lililopeanwa ni \"Neno Lenye Bahati\".\n# Neno linachukuliwa kuwa na \"Bahati\" ikiwa tofauti kati ya marudio ya herufi ya juu zaidi na ya chini zaidi ni nambari ya kwanza.\n# Ingizo: Neno moja linalojumuisha herufi ndogo na lenye urefu chini ya 100.\n# Tokeo: Mistari miwili - mstari wa kwanza ni ama 'Neno Lenye Bahati' au 'Hakuna Jibu', na mstari wa pili ni tofauti ikiwa neno lina \"Bahati\", au 0 vinginevyo.\n# Mfano wa Matumizi:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "tr": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Bu fonksiyon verilen kelimenin \"Şanslı Kelime\" olup olmadığını kontrol eder.\n# Bir kelime, en yüksek ve en düşük harf frekansı arasındaki fark asal bir sayı ise \"Şanslı\" kabul edilir.\n# Girdi: Küçük harflerden oluşan ve uzunluğu 100'den az olan tek bir kelime.\n# Çıktı: İki satır - ilk satır 'Şanslı Kelime' veya 'Cevap Yok', ikinci satır ise kelime \"Şanslı\" ise farkı, aksi takdirde 0.\n# Örnek Kullanım:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "vi": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Hàm này kiểm tra xem từ được đưa vào có phải là \"Từ May Mắn\" hay không.\n# Một từ được coi là \"May Mắn\" nếu sự chênh lệch giữa tần suất chữ cái cao nhất và thấp nhất là một số nguyên tố.\n# Đầu vào: Một từ đơn gồm các chữ cái thường và có độ dài nhỏ hơn 100.\n# Đầu ra: Hai dòng - dòng đầu tiên là 'Lucky Word' hoặc 'No Answer', và dòng thứ hai là sự chênh lệch nếu từ là \"May Mắn\", hoặc 0 nếu không.\n# Ví dụ sử dụng:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0"
    },
    "prompt_bertscore": {
      "es": "0.9900098849858503",
      "arb": "0.9855138863111256",
      "sw": "0.9962715091175941",
      "tr": "0.9726559458555942",
      "vi": "0.9792453101160455"
    },
    "canonical_solution": "local max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}",
    "instruction": {
      "en": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n\nlocal max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n\nlocal max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n\nlocal max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n\nlocal max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n\nlocal max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n\nlocal max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9020958797094277",
      "sw": "0.9148459638680573",
      "tr": "0.8547378283719466",
      "vi": "0.9324273347845983"
    },
    "level": "",
    "test": "test_is_lucky_word() {\nlocal result\nresult=$(is_lucky_word \"error\")\n[[ $result == $'Lucky Word\\n2' ]] || { echo \"Test 1 failed\"; exit 1; }\nresult=$(is_lucky_word \"olympic\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 2 failed\"; exit 1; }\nresult=$(is_lucky_word \"apple\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_is_lucky_word",
    "entry_point": "is_lucky_word",
    "signature": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n",
    "docstring": {
      "en": "This function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "es": "Esta función verifica si la palabra dada es una \"Palabra de la Suerte\".  \nUna palabra se considera \"de la Suerte\" si la diferencia entre la frecuencia más alta y la más baja de las letras es un número primo.  \nEntrada: Una sola palabra que consiste en letras minúsculas y con una longitud menor a 100.  \nSalida: Dos líneas - la primera línea es 'Palabra de la Suerte' o 'Sin Respuesta', y la segunda línea es la diferencia si la palabra es \"de la Suerte\", o 0 en caso contrario.  \nEjemplo de Uso:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "arb": "هذه الدالة تتحقق مما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\".\nتعتبر الكلمة \"محظوظة\" إذا كان الفرق بين أعلى وأدنى تكرار للحروف هو عدد أولي.\nالمدخلات: كلمة واحدة تتكون من حروف صغيرة وبطول أقل من 100.\nالمخرجات: سطران - السطر الأول إما 'كلمة محظوظة' أو 'لا إجابة'، والسطر الثاني هو الفرق إذا كانت الكلمة \"محظوظة\"، أو 0 خلاف ذلك.\nمثال على الاستخدام:\n>>> is_lucky_word \"error\"\nكلمة محظوظة\n2\n>>> is_lucky_word \"olympic\"\nلا إجابة\n0",
      "sw": "Kazi hii hukagua kama neno lililopeanwa ni  \"Neno Lenye Bahati\".\nNeno linachukuliwa kuwa \"la Bahati\" ikiwa tofauti kati ya marudio ya herufi ya juu na ya chini ni nambari ya kwanza.\nIngizo: Neno moja linalojumuisha herufi ndogo na lenye urefu chini ya 100.Matokeo: Mistari miwili - mstari wa kwanza ni 'Neno la Bahati' au 'Hakuna Jibu', na mstari wa pili ni tofauti ikiwa neno ni \"la Bahati\", au 0 vinginevyo.\nMfano wa Matumizi:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "tr": "Bu fonksiyon, verilen kelimenin \"Şanslı Kelime\" olup olmadığını kontrol eder. \nBir kelime, en yüksek ve en düşük harf frekansı arasındaki fark asal bir sayı ise \"Şanslı\" olarak kabul edilir. \nGirdi: Küçük harflerden oluşan ve uzunluğu 100'den az olan tek bir kelime. \nÇıktı: İki satır - ilk satır 'Şanslı Kelime' veya 'Cevap Yok', ikinci satır ise kelime \"Şanslı\" ise farkı, aksi takdirde 0. \nÖrnek Kullanım: \n>>> is_lucky_word \"error\"\nŞanslı Kelime\n2\n>>> is_lucky_word \"olympic\"\nCevap Yok\n0",
      "vi": "Hàm này kiểm tra xem từ được cho có phải là \"Từ May Mắn\" hay không.  \nMột từ được coi là \"May Mắn\" nếu sự khác biệt giữa tần suất chữ cái cao nhất và thấp nhất là một số nguyên tố.  \nĐầu vào: Một từ đơn bao gồm các chữ cái thường và có độ dài nhỏ hơn 100.  \nĐầu ra: Hai dòng - dòng đầu tiên là 'Từ May Mắn' hoặc 'Không Có Đáp Án', và dòng thứ hai là sự khác biệt nếu từ là \"May Mắn\", hoặc 0 nếu không phải.  \nVí dụ Sử dụng:  \n>>> is_lucky_word \"error\"  \nTừ May Mắn  \n2  \n>>> is_lucky_word \"olympic\"  \nKhông Có Đáp Án  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.9873224159304482",
      "arb": "0.9723578016536608",
      "sw": "1",
      "tr": "0.978183233468652",
      "vi": "0.9867165932682919"
    }
  },
  {
    "task_id": "Shell/34",
    "prompt": {
      "en": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# This function finds the kth smallest unique number from a list of positive integers. \n# Duplicate numbers are only counted once. If k is greater than the number of unique elements, \n# it returns 'NO RESULT'.\n# Args:\n# $1: A string of space-separated positive integers.\n# $2: An integer representing the value of k.\n# Returns:\n# The kth smallest unique number or 'NO RESULT' if k is too large.\n# Example:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Returns: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Returns: NO RESULT",
      "es": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Esta función encuentra el k-ésimo número único más pequeño de una lista de enteros positivos.\n# Los números duplicados solo se cuentan una vez. Si k es mayor que el número de elementos únicos,\n# devuelve 'NO RESULT'.\n# Argumentos:\n# $1: Una cadena de enteros positivos separados por espacios.\n# $2: Un entero que representa el valor de k.\n# Devuelve:\n# El k-ésimo número único más pequeño o 'NO RESULT' si k es demasiado grande.\n# Ejemplo:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Devuelve: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Devuelve: NO RESULT",
      "arb": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# هذه الدالة تجد الرقم الفريد الأصغر رقم k من قائمة الأعداد الصحيحة الموجبة.\n# الأرقام المكررة تُحسب مرة واحدة فقط. إذا كان k أكبر من عدد العناصر الفريدة،\n# فإنها تعيد 'NO RESULT'.\n# يعيدالحجج:\n# $1: سلسلة من الأعداد الصحيحة الموجبة مفصولة بمسافات.\n# $2: عدد صحيح يمثل قيمة k.\n# يعيد:\n# الرقم الفريد الأصغر رقم k أو 'NO RESULT' إذا كان k كبيرًا جدًا.\n# امثله:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # يعيد: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # يعيد: NO RESULT",
      "sw": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Kazi hii inapata nambari ya kipekee ya k ndogo zaidi kutoka kwenye orodha ya nambari chanya. \n# Nambari zinazojirudia zinahesabiwa mara moja tu. Ikiwa k ni kubwa kuliko idadi ya vipengele vya kipekee, \n# inarudisha 'HAKUNA MATOKEO'.\n# Hoja:\n# $1: Mfuatano wa nambari chanya zilizotenganishwa na nafasi.\n# $2: Nambari inayowakilisha thamani ya k.\n# Inarudisha:\n# Nambari ya kipekee ya k ndogo zaidi au 'HAKUNA MATOKEO' ikiwa k ni kubwa sana.\n# Mfano:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Inarudisha: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Inarudisha: HAKUNA MATOKEO",
      "tr": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Bu fonksiyon, pozitif tamsayılar listesinden k. en küçük benzersiz sayıyı bulur.\n# Yinelenen sayılar yalnızca bir kez sayılır. Eğer k, benzersiz elemanların sayısından büyükse,\n# 'SONUÇ YOK' döner.\n# Argümanlar:\n# $1: Boşlukla ayrılmış pozitif tamsayılar içeren bir dize.\n# $2: k değerini temsil eden bir tamsayı.\n# Döndürür:\n# k. en küçük benzersiz sayı veya k çok büyükse 'SONUÇ YOK'.\n# Örnek:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Döndürür: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Döndürür: SONUÇ YOK",
      "vi": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Hàm này tìm số nhỏ thứ k duy nhất từ một danh sách các số nguyên dương.\n# Các số trùng lặp chỉ được tính một lần. Nếu k lớn hơn số lượng phần tử duy nhất,\n# nó trả về 'NO RESULT'.\n# Tham số:\n# $1: Một chuỗi các số nguyên dương cách nhau bằng dấu cách.\n# $2: Một số nguyên đại diện cho giá trị của k.\n# Trả về:\n# Số nhỏ thứ k duy nhất hoặc 'NO RESULT' nếu k quá lớn.\n# Ví dụ:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Trả về: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Trả về: NO RESULT"
    },
    "prompt_bertscore": {
      "es": "0.9802591195808477",
      "arb": "0.9848852211551502",
      "sw": "0.9631576396648869",
      "tr": "0.9781401306759675",
      "vi": "0.9798982081785073"
    },
    "canonical_solution": "local sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}",
    "instruction": {
      "en": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n\nlocal sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n\nlocal sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n\nlocal sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Shell باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n\nlocal sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n\nlocal sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n\nlocal sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8772291436772891",
      "sw": "0.9148459638680573",
      "tr": "0.8457343104603972",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_kth_smallest_unique_number() {\n[[ $(find_kth_smallest_unique_number \"5 1 3 5 2 4 1\" 4) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"8 7 6 5 4 3 2 1\" 3) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"9 9 8 8 7 7\" 2) == \"8\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"10 20 30 40 50\" 5) == \"50\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"15 15 15 15 15\" 1) == \"15\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"1 2 3 4 5\" 6) == \"NO RESULT\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"3 3 3 3 3\" 2) == \"NO RESULT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_kth_smallest_unique_number",
    "entry_point": "find_kth_smallest_unique_number",
    "signature": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n",
    "docstring": {
      "en": "This function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "es": "Esta función encuentra el k-ésimo número único más pequeño de una lista de enteros positivos. \nLos números duplicados solo se cuentan una vez. Si k es mayor que el número de elementos únicos, \ndevuelve 'SIN RESULTADO'.\nArgumentos:\n$1: Una cadena de enteros positivos separados por espacios.\n$2: Un entero que representa el valor de k.\nDevuelve:\nEl k-ésimo número único más pequeño o 'SIN RESULTADO' si k es demasiado grande.\nEjemplo:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nDevuelve: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nDevuelve: NO RESULT",
      "arb": "هذه الدالة تجد الرقم الفريد الأصغر في المرتبة k من قائمة الأعداد الصحيحة الموجبة. الأرقام المكررة تُحسب مرة واحدة فقط. إذا كان k أكبر من عدد العناصر الفريدة، فإنها تُرجع 'لا توجد نتيجة'.\nالمعطيات:\n$1: سلسلة من الأعداد الصحيحة الموجبة مفصولة بمسافات.\n$2: عدد صحيح يمثل قيمة k.\nالقيم المعادة:\nالرقم الفريد الأصغر في المرتبة k أو 'لا توجد نتيجة' إذا كان k كبيرًا جدًا.\nمثال:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nالقيم المعادة: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nالقيم المعادة: لا توجد نتيجة",
      "sw": "Kazi hii inatafuta nambari ya kipekee ya kth ndogo zaidi kutoka kwenye orodha ya nambari nzima chanya. \nNambari zinazojirudia zinahesabiwa mara moja tu. Ikiwa k ni kubwa kuliko idadi ya vipengele vya kipekee, \ninarudisha 'HAKUNA MATOKEO'.\nHoja:\n$1: Msururu wa nambari nzima chanya zilizotenganishwa na nafasi.\n$2: Nambari nzima inayowakilisha thamani ya k.\nInarejesha:\nNambari ya kipekee ya kth ndogo zaidi au 'HAKUNA MATOKEO' ikiwa k ni kubwa mno.\nMfano:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nInarejesha: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nInarejesha: NO RESULT",
      "tr": "Bu fonksiyon, pozitif tamsayılardan oluşan bir listeden k. en küçük benzersiz sayıyı bulur. \nTekrarlayan sayılar yalnızca bir kez sayılır. Eğer k, benzersiz elemanların sayısından büyükse, \n'SONUÇ YOK' döndürür.\nArgümanlar:\n$1: Boşlukla ayrılmış pozitif tamsayılar içeren bir dize.\n$2: k değerini temsil eden bir tamsayı.\nDöndürür:\nk. en küçük benzersiz sayı veya k çok büyükse 'SONUÇ YOK'.\nÖrnek:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nDöndürür: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nDöndürür: NO RESULT",
      "vi": "Hàm này tìm số nhỏ nhất thứ k duy nhất từ một danh sách các số nguyên dương. \nCác số trùng lặp chỉ được đếm một lần. Nếu k lớn hơn số lượng phần tử duy nhất, \nnó trả về 'NO RESULT'.\nTham số:\n$1: Một chuỗi các số nguyên dương cách nhau bằng dấu cách.\n$2: Một số nguyên đại diện cho giá trị của k.\nTrả về:\nSố nhỏ nhất thứ k duy nhất hoặc 'NO RESULT' nếu k quá lớn.\nVí dụ:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nTrả về: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nTrả về: NO RESULT"
    },
    "docstring_bertscore": {
      "es": "0.9896745969026635",
      "arb": "0.9325427390359795",
      "sw": "0.9836336511242494",
      "tr": "0.978598768225777",
      "vi": "0.9703031689922359"
    }
  },
  {
    "task_id": "Shell/35",
    "prompt": {
      "en": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# This function converts a number from one base to another.\n# The function accepts three arguments: the base of the input number (2 to 16),\n# the number to be converted (in string format), and the base to which it should be converted (2 to 16).\n# The function returns the converted number in string format.\n# The input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\n# If the input number or the base is invalid, the function returns 'INVALID INPUT'.\n# Examples:\n# convert_bases 10 \"255\" 2\n# # Returns: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Returns: \"A\"\n# convert_bases 8 \"17\" 10\n# # Returns: \"15\"",
      "es": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Esta función convierte un número de una base a otra.\n# La función acepta tres argumentos: la base del número de entrada (2 a 16),\n# el número a convertir (en formato de cadena), y la base a la que debe ser convertido (2 a 16).\n# La función devuelve el número convertido en formato de cadena.\n# El número de entrada puede incluir dígitos 0-9 y letras mayúsculas A-F para bases superiores a 10.\n# Si el número de entrada o la base es inválida, la función devuelve 'INVALID INPUT'.\n# Ejemplos:\n# convert_bases 10 \"255\" 2\n# # Devuelve: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Devuelve: \"A\"\n# convert_bases 8 \"17\" 10\n# # Devuelve: \"15\"",
      "arb": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# تقوم هذه الدالة بتحويل رقم من قاعدة إلى أخرى.\n# تقبل الدالة ثلاثة معطيات: قاعدة الرقم المدخل (من 2 إلى 16)،\n# الرقم الذي سيتم تحويله (بصيغة نصية)، والقاعدة التي يجب تحويله إليها (من 2 إلى 16).\n# تعيد الدالة الرقم المحول بصيغة نصية.\n# قد يتضمن الرقم المدخل الأرقام من 0-9 والحروف الكبيرة A-F للقواعد الأعلى من 10.\n# إذا كان الرقم المدخل أو القاعدة غير صالحين، تعيد الدالة 'INVALID INPUT'.\n# أمثلة:\n# convert_bases 10 \"255\" 2\n# # يعيد: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # يعيد: \"A\"\n# convert_bases 8 \"17\" 10\n# # يعيد: \"15\"",
      "sw": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Kazi ya hii kazi ni kubadilisha namba kutoka msingi mmoja hadi mwingine.\n# Kazi hii inakubali hoja tatu: msingi wa namba ya ingizo (2 hadi 16),\n# namba inayopaswa kubadilishwa (katika muundo wa kamba), na msingi ambao inapaswa kubadilishwa (2 hadi 16).\n# Kazi hii inarejesha namba iliyobadilishwa katika muundo wa kamba.\n# Namba ya ingizo inaweza kujumuisha tarakimu 0-9 na herufi kubwa A-F kwa misingi iliyo juu ya 10.\n# Ikiwa namba ya ingizo au msingi ni batili, kazi inarejesha 'INVALID INPUT'.\n# Mifano:\n# convert_bases 10 \"255\" 2\n# # Inarejesha: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Inarejesha: \"A\"\n# convert_bases 8 \"17\" 10\n# # Inarejesha: \"15\"",
      "tr": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Bu fonksiyon bir sayıyı bir tabandan diğerine dönüştürür.\n# Fonksiyon üç argüman alır: giriş sayısının tabanı (2'den 16'ya kadar),\n# dönüştürülecek sayı (string formatında) ve dönüştürüleceği taban (2'den 16'ya kadar).\n# Fonksiyon, dönüştürülmüş sayıyı string formatında döndürür.\n# Giriş sayısı, 10'dan büyük tabanlar için 0-9 arası rakamları ve büyük harf A-F'yi içerebilir.\n# Eğer giriş sayısı veya taban geçersizse, fonksiyon 'INVALID INPUT' döndürür.\n# Örnekler:\n# convert_bases 10 \"255\" 2\n# # Döndürür: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Döndürür: \"A\"\n# convert_bases 8 \"17\" 10\n# # Döndürür: \"15\"",
      "vi": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Hàm này chuyển đổi một số từ một cơ số này sang cơ số khác.\n# Hàm chấp nhận ba tham số: cơ số của số đầu vào (2 đến 16),\n# số cần chuyển đổi (dưới dạng chuỗi), và cơ số mà số đó sẽ được chuyển đổi sang (2 đến 16).\n# Hàm trả về số đã được chuyển đổi dưới dạng chuỗi.\n# Số đầu vào có thể bao gồm các chữ số 0-9 và các chữ cái in hoa A-F cho các cơ số lớn hơn 10.\n# Nếu số đầu vào hoặc cơ số không hợp lệ, hàm trả về 'INVALID INPUT'.\n# Ví dụ:\n# convert_bases 10 \"255\" 2\n# # Trả về: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Trả về: \"A\"\n# convert_bases 8 \"17\" 10\n# # Trả về: \"15\""
    },
    "prompt_bertscore": {
      "es": "0.9934326837118435",
      "arb": "0.9895574049778528",
      "sw": "0.9805169418154309",
      "tr": "0.9831126436347949",
      "vi": "0.9841264530995969"
    },
    "canonical_solution": "if [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}",
    "instruction": {
      "en": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n\nif [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n\nif [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n\nif [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n\nif [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n\nif [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n\nif [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.8784135766394001",
      "tr": "0.8479093131327292",
      "vi": "0.9250829764458333"
    },
    "level": "",
    "test": "test_convert_bases() {\n[[ $(convert_bases 10 \"1024\" 2) == \"10000000000\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_bases 16 \"1A3\" 8) == \"643\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_bases 2 \"1101\" 10) == \"13\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_bases 16 \"ABC\" 2) == \"101010111100\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_bases 8 \"777\" 16) == \"1FF\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(convert_bases 4 \"123\" 10) == \"27\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(convert_bases 20 \"1A\" 2) == \"INVALID INPUT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_convert_bases",
    "entry_point": "convert_bases",
    "signature": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n",
    "docstring": {
      "en": "This function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"",
      "es": "Esta función convierte un número de una base a otra.\nLa función acepta tres argumentos: la base del número de entrada (2 a 16),\nel número a convertir (en formato de cadena) y la base a la que debe convertirse (2 a 16).\nLa función devuelve el número convertido en formato de cadena.\nEl número de entrada puede incluir dígitos del 0 al 9 y letras mayúsculas de la A a la F para bases superiores a 10.\nSi el número de entrada o la base son inválidos, la función devuelve 'ENTRADA INVÁLIDA'.\nEjemplos:\nconvert_bases 10 \"255\" 2\nDevuelve: \"11111111\"\nconvert_bases 2 \"1010\" 16\nDevuelve: \"A\"\nconvert_bases 8 \"17\" 10\nDevuelve: \"15\"",
      "arb": "هذه الدالة تقوم بتحويل رقم من قاعدة إلى أخرى.\nتقبل الدالة ثلاثة معطيات: قاعدة الرقم المدخل (من 2 إلى 16)،\nالرقم المراد تحويله (بصيغة سلسلة نصية)، والقاعدة التي يجب تحويله إليها (من 2 إلى 16).\nتعيد الدالة الرقم المحول بصيغة سلسلة نصية.\nقد يتضمن الرقم المدخل الأرقام من 0-9 والحروف الكبيرة A-F للقواعد الأعلى من 10.\nإذا كان الرقم المدخل أو القاعدة غير صالحين، تعيد الدالة 'INVALID INPUT'.\nأمثلة:\nconvert_bases 10 \"255\" 2\nيعيد: \"11111111\"\nconvert_bases 2 \"1010\" 16\nيعيد: \"A\"\nconvert_bases 8 \"17\" 10\nيعيد: \"15\"",
      "sw": "Kazi ya hii kazi ni kubadilisha namba kutoka msingi mmoja hadi mwingine.   \nKazi hii inakubali hoja tatu: msingi wa namba ya ingizo (2 hadi 16),   \nnamba inayopaswa kubadilishwa (katika muundo wa kamba), na msingi ambao inapaswa kubadilishwa (2 hadi 16).  \nKazi hii inarudisha namba iliyobadilishwa katika muundo wa kamba. \nNamba ya ingizo inaweza kujumuisha tarakimu 0-9 na herufi kubwa A-F kwa misingi iliyo juu ya 10. \nIkiwa namba ya ingizo au msingi si sahihi, kazi inarudisha 'INVALID INPUT'. \nMifano:  \nconvert_bases 10 \"255\" 2   \nInarudisha: \"11111111\"  \nconvert_bases 2 \"1010\" 16  \nInarudisha: \"A\"  convert_bases 8 \"17\" 10\n \nInarudisha: \"15\"  ",
      "tr": "Bu fonksiyon bir sayıyı bir tabandan başka bir tabana dönüştürür.\nFonksiyon üç argüman kabul eder: giriş sayısının tabanı (2'den 16'ya kadar),\ndönüştürülecek sayı (string formatında) ve dönüştürüleceği taban (2'den 16'ya kadar).\nFonksiyon, dönüştürülmüş sayıyı string formatında döndürür.\nGiriş sayısı, 10'dan büyük tabanlar için 0-9 rakamlarını ve büyük harf A-F'yi içerebilir.\nEğer giriş sayısı veya taban geçersizse, fonksiyon 'GEÇERSİZ GİRİŞ' döndürür.\nÖrnekler:\nconvert_bases 10 \"255\" 2\nDöndürür: \"11111111\"\nconvert_bases 2 \"1010\" 16\nDöndürür: \"A\"\nconvert_bases 8 \"17\" 10\nDöndürür: \"15\"",
      "vi": "Hàm này chuyển đổi một số từ một cơ số này sang cơ số khác.  \nHàm chấp nhận ba đối số: cơ số của số đầu vào (2 đến 16), số cần chuyển đổi (dưới dạng chuỗi), và cơ số mà nó cần được chuyển đổi sang (2 đến 16).  \nHàm trả về số đã chuyển đổi dưới dạng chuỗi.  \nSố đầu vào có thể bao gồm các chữ số 0-9 và các chữ cái in hoa A-F cho các cơ số lớn hơn 10.  \nNếu số đầu vào hoặc cơ số không hợp lệ, hàm trả về 'INVALID INPUT'.  \nVí dụ:  \nconvert_bases 10 \"255\" 2  \nTrả về: \"11111111\"  \nconvert_bases 2 \"1010\" 16  \nTrả về: \"A\"  \nconvert_bases 8 \"17\" 10  \nTrả về: \"15\"  "
    },
    "docstring_bertscore": {
      "es": "0.9856934481755811",
      "arb": "0.9867495659115436",
      "sw": "0.8304340108396608",
      "tr": "0.9858024962547693",
      "vi": "0.9834685892776094"
    }
  },
  {
    "task_id": "Shell/36",
    "prompt": {
      "en": "find_sum_segments() {\nlocal M=$1\n# This function identifies all the continuous segments of positive integers that sum to a given integer M.\n# Each segment must contain at least two consecutive numbers.\n# Args:\n# $1: A positive integer M, the target sum (10 <= M <= 2,000,000).\n# Returns:\n# The output consists of several lines, each containing two positive integers separated by a space.\n# These integers represent the first and last numbers in a continuous segment that sums to M.\n# The lines are sorted in ascending order based on the starting number of each segment.\n# Example:\n# find_sum_segments 21\n# # Returns:\n# # 6 8\n# # 10 11",
      "es": "find_sum_segments() {\nlocal M=$1\n# Esta función identifica todos los segmentos continuos de enteros positivos que suman un entero dado M.\n# Cada segmento debe contener al menos dos números consecutivos.\n# Argumentos:\n# $1: Un entero positivo M, la suma objetivo (10 <= M <= 2,000,000).\n# Devuelve:\n# La salida consiste en varias líneas, cada una conteniendo dos enteros positivos separados por un espacio.\n# Estos enteros representan el primer y último número en un segmento continuo que suma M.\n# Las líneas están ordenadas en orden ascendente según el número inicial de cada segmento.\n# Ejemplo:\n# find_sum_segments 21\n# # Devuelve:\n# # 6 8\n# # 10 11",
      "arb": "find_sum_segments() {\nlocal M=$1\n# تحدد هذه الدالة جميع المقاطع المتتالية من الأعداد الصحيحة الموجبة التي يكون مجموعها عددًا صحيحًا معينًا M.\n# يجب أن يحتوي كل مقطع على رقمين متتاليين على الأقل.\n# الوسائط:\n# $1: عدد صحيح موجب M، المجموع المستهدف (10 <= M <= 2,000,000).\n# يعيد:\n# يتكون الإخراج من عدة أسطر، يحتوي كل منها على عددين صحيحين موجبين مفصولين بمسافة.\n# تمثل هذه الأعداد الرقم الأول والأخير في مقطع متواصل يكون مجموعها M.\n# يتم ترتيب الأسطر بترتيب تصاعدي بناءً على الرقم الأول لكل مقطع.\n# مثال:\n# find_sum_segments 21\n# # يعيد:\n# # 6 8\n# # 10 11",
      "sw": "find_sum_segments() {\nlocal M=$1\n# Kazi ya hii kazi ni kutambua vipande vyote vya mfululizo wa namba chanya ambazo jumla yake ni sawa na namba fulani M.\n# Kila kipande lazima kiwe na angalau namba mbili zinazofuatana.\n# Hoja:\n# $1: Namba chanya M, jumla inayolengwa (10 <= M <= 2,000,000).\n# Inarudisha:\n# Matokeo yanajumuisha mistari kadhaa, kila moja ikiwa na namba mbili chanya zilizotenganishwa na nafasi.\n# Namba hizi zinawakilisha namba ya kwanza na ya mwisho katika kipande cha mfululizo kinachojumlisha M.\n# Mistari imepangwa kwa mpangilio wa kupanda kulingana na namba ya kwanza ya kila kipande.\n# Mfano:\n# find_sum_segments 21\n# # Inarudisha:\n# # 6 8\n# # 10 11",
      "tr": "find_sum_segments() {\nlocal M=$1\n# Bu fonksiyon, belirli bir M tamsayısına eşit olan pozitif tam sayıların ardışık tüm segmentlerini tanımlar.\n# Her segment en az iki ardışık sayı içermelidir.\n# Argümanlar:\n# $1: Hedef toplam olan pozitif bir tamsayı M (10 <= M <= 2,000,000).\n# Döndürür:\n# Çıktı, her biri bir boşlukla ayrılmış iki pozitif tamsayı içeren birkaç satırdan oluşur.\n# Bu tamsayılar, M'ye eşit olan bir sürekli segmentteki ilk ve son sayıları temsil eder.\n# Satırlar, her segmentin başlangıç sayısına göre artan sırayla sıralanır.\n# Örnek:\n# find_sum_segments 21\n# # Döndürür:\n# # 6 8\n# # 10 11",
      "vi": "find_sum_segments() {\nlocal M=$1\n# Hàm này xác định tất cả các đoạn liên tục của các số nguyên dương có tổng bằng một số nguyên M cho trước.\n# Mỗi đoạn phải chứa ít nhất hai số liên tiếp.\n# Tham số:\n# $1: Một số nguyên dương M, tổng mục tiêu (10 <= M <= 2,000,000).\n# Trả về:\n# Đầu ra bao gồm nhiều dòng, mỗi dòng chứa hai số nguyên dương được ngăn cách bởi một khoảng trắng.\n# Các số nguyên này đại diện cho số đầu tiên và số cuối cùng trong một đoạn liên tục có tổng bằng M.\n# Các dòng được sắp xếp theo thứ tự tăng dần dựa trên số bắt đầu của mỗi đoạn.\n# Ví dụ:\n# find_sum_segments 21\n# # Trả về:\n# # 6 8\n# # 10 11"
    },
    "prompt_bertscore": {
      "es": "0.9847046661387895",
      "arb": "0.966984055325143",
      "sw": "0.9119815151431531",
      "tr": "0.9730532066176639",
      "vi": "0.9686545368296464"
    },
    "canonical_solution": "local start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}",
    "instruction": {
      "en": "find_sum_segments() {\nlocal M=$1\n\nlocal start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "find_sum_segments() {\nlocal M=$1\n\nlocal start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "find_sum_segments() {\nlocal M=$1\n\nlocal start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "find_sum_segments() {\nlocal M=$1\n\nlocal start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "find_sum_segments() {\nlocal M=$1\n\nlocal start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}\n\nTürkçe olarak Shell kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "find_sum_segments() {\nlocal M=$1\n\nlocal start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.912937721797455",
      "sw": "0.9136909282023393",
      "tr": "0.8745500170978905",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_find_sum_segments() {\nlocal result=$(find_sum_segments 10000)\nlocal expected=\"18 142\n297 328\n388 412\n1998 2002\"\n[[ $result == \"$expected\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(find_sum_segments 100)\nexpected=\"9 16\n18 22\"\n[[ $result == \"$expected\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_find_sum_segments",
    "entry_point": "find_sum_segments",
    "signature": "find_sum_segments() {\nlocal M=$1\n",
    "docstring": {
      "en": "This function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "es": "Esta función identifica todos los segmentos continuos de enteros positivos que suman un entero dado M.  \nCada segmento debe contener al menos dos números consecutivos.  \nArgumentos:  \n$1: Un entero positivo M, la suma objetivo (10 <= M <= 2,000,000).  \nDevuelve:  \nLa salida consiste en varias líneas, cada una conteniendo dos enteros positivos separados por un espacio.  \nEstos enteros representan el primer y último número en un segmento continuo que suma M.  \nLas líneas están ordenadas en orden ascendente basado en el número inicial de cada segmento.  \nEjemplo:  \nfind_sum_segments 21  \nDevuelve:  \n6 8  \n10 11  ",
      "arb": "هذه الدالة تحدد جميع القطاعات المتتالية من الأعداد الصحيحة الموجبة التي يكون مجموعها مساوياً لعدد صحيح معين M.\nيجب أن يحتوي كل قطاع على عددين متتاليين على الأقل.\nالمعطيات:\n$1: عدد صحيح موجب M، المجموع المستهدف (10 <= M <= 2,000,000).\nالمخرجات:\nيتكون الإخراج من عدة أسطر، يحتوي كل منها على عددين صحيحين موجبين مفصولين بمسافة.\nتمثل هذه الأعداد الأرقام الأولى والأخيرة في قطاع متواصل يكون مجموعه M.\nيتم ترتيب الأسطر بترتيب تصاعدي بناءً على الرقم الأول من كل قطاع.\nمثال:\nfind_sum_segments 21\nالمخرجات:\n6 8\n10 11",
      "sw": "TKazi ya hii kazi ni kutambua vipande vyote vya mfululizo wa namba chanya ambazo jumla yake ni sawa na namba fulani M.  \nKila sehemu lazima iwe na angalau namba mbili mfululizo.  \nHoja:  \n$1: Namba kamili chanya M, jumla lengwa (10 <= M <= 2,000,000).  \nInarudishas:  \nMatokeo yanajumuisha mistari kadhaa, kila moja ikiwa na namba mbili chanya zilizotenganishwa na nafasi.  \nNamba hizi zinawakilisha namba ya kwanza na ya mwisho katika sehemu inayoendelea inayojumlisha M.  \nMistari imepangwa kwa mpangilio wa kupanda kulingana na namba ya kuanzia ya kila sehemu.  \nMfano:  \nfind_sum_segments 21  \nInarejesha:  \n6 8  \n10 11  ",
      "tr": "Bu fonksiyon, M adlı verilen bir tam sayıya toplamı eşit olan tüm pozitif tamsayıların ardışık segmentlerini tanımlar.\nHer segment en az iki ardışık sayı içermelidir.\nArgümanlar:\n$1: Hedef toplam olan pozitif bir tamsayı M (10 <= M <= 2,000,000).\nDöndürür:\nÇıktı, her biri bir boşlukla ayrılmış iki pozitif tamsayı içeren birkaç satırdan oluşur.\nBu tamsayılar, M toplamına eşit olan ardışık bir segmentteki ilk ve son sayıları temsil eder.\nSatırlar, her segmentin başlangıç sayısına göre artan sırayla sıralanır.\nÖrnek:\nfind_sum_segments 21\nInarudisha:\n6 8\n10 11",
      "vi": "Hàm này xác định tất cả các đoạn liên tục của các số nguyên dương mà tổng bằng một số nguyên M cho trước.  \nMỗi đoạn phải chứa ít nhất hai số liên tiếp.  \nTham số:  \n$1: Một số nguyên dương M, tổng mục tiêu (10 <= M <= 2,000,000).  \nTrả về:  \nĐầu ra bao gồm nhiều dòng, mỗi dòng chứa hai số nguyên dương được ngăn cách bởi một dấu cách.  \nNhững số nguyên này đại diện cho số đầu tiên và số cuối cùng trong một đoạn liên tục có tổng bằng M.  \nCác dòng được sắp xếp theo thứ tự tăng dần dựa trên số bắt đầu của mỗi đoạn.  \nVí dụ:  \nfind_sum_segments 21  \nTrả về:  \n6 8  \n10 11  "
    },
    "docstring_bertscore": {
      "es": "0.991596544469557",
      "arb": "0.9419528533375073",
      "sw": "0.956588138442539",
      "tr": "0.9743339753145769",
      "vi": "0.9672222131520037"
    }
  },
  {
    "task_id": "Shell/37",
    "prompt": {
      "en": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\n# Example Cases:\n\n# count_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "es": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Esta función calcula el número de formas de gastar todo el dinero disponible en una selección de platos en un restaurante. Cada plato solo se puede comprar una vez. La función toma el número de platos disponibles, la cantidad total de dinero y una cadena que contiene el precio de cada plato.\n\n# Casos de Ejemplo:\n\n# count_meal_combinations 3 5 \"1 2 3\" debería devolver 2 (1+2+2 o 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" debería devolver 3 (1+2+3, 1+1+2+2, o 2+3+1).",
      "arb": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# هذه الدالة تحسب عدد الطرق لإنفاق كل المال المتاح على مجموعة من الأطباق في مطعم. يمكن شراء كل طبق مرة واحدة فقط. تأخذ الدالة عدد الأطباق المتاحة، المبلغ الإجمالي من المال، وسلسلة تحتوي على سعر كل طبق.\n\n# حالات المثال:\n\n# count_meal_combinations 3 5 \"1 2 3\" يجب أن تعيد 2 (1+2+2 أو 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" يجب أن تعيد 3 (1+2+3، 1+1+2+2، أو 2+3+1).",
      "sw": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Kazi ya hii kazi ni kuhesabu idadi ya njia za kutumia pesa zote zilizopo kwenye uchaguzi wa vyakula katika mgahawa. Kila chakula kinaweza kununuliwa mara moja tu. Kazi hii inachukua idadi ya vyakula vilivyopo, jumla ya kiasi cha pesa, na kamba inayoelezea bei ya kila chakula.\n\n# Mifano ya Kesi:\n\n# count_meal_combinations 3 5 \"1 2 3\" inapaswa kurudisha 2 (1+2+2 au 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" inapaswa kurudisha 3 (1+2+3, 1+1+2+2, au 2+3+1).",
      "tr": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Bu fonksiyon, bir restoranda mevcut tüm parayı yemek seçimlerine harcamanın kaç farklı yolu olduğunu hesaplar. Her yemek sadece bir kez satın alınabilir. Fonksiyon, mevcut yemek sayısını, toplam para miktarını ve her yemeğin fiyatını içeren bir dize alır.\n\n# Örnek Durumlar:\n\n# count_meal_combinations 3 5 \"1 2 3\" 2 döndürmelidir (1+2+2 veya 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" 3 döndürmelidir (1+2+3, 1+1+2+2 veya 2+3+1).",
      "vi": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Hàm này tính toán số cách để tiêu hết số tiền có sẵn vào việc chọn món ăn trong một nhà hàng. Mỗi món ăn chỉ có thể được mua một lần. Hàm nhận số lượng món ăn có sẵn, tổng số tiền, và một chuỗi chứa giá của mỗi món ăn.\n\n# Các trường hợp ví dụ:\n\n# count_meal_combinations 3 5 \"1 2 3\" sẽ trả về 2 (1+2+2 hoặc 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" sẽ trả về 3 (1+2+3, 1+1+2+2, hoặc 2+3+1)."
    },
    "prompt_bertscore": {
      "es": "0.9964917902101618",
      "arb": "0.9893230211282317",
      "sw": "0.9657843278236923",
      "tr": "0.9845380152491012",
      "vi": "0.9857961400825762"
    },
    "canonical_solution": "local dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}",
    "instruction": {
      "en": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n\nlocal dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n\nlocal dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n\nlocal dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n\nlocal dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n\nlocal dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}\n\nAşağıdaki Shell kodunun işlevini Türkçe olarak en fazla 500 karakter kullanarak açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n\nlocal dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9148916488556953",
      "sw": "0.9429899025568905",
      "tr": "0.8568395364336767",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_meal_combinations() {\n[[ $(count_meal_combinations 3 5 \"1 2 3\") -eq 1 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 6 \"1 2 3 1\") -eq 2 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_meal_combinations 5 10 \"2 2 2 2 2\") -eq 1 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_meal_combinations 3 3 \"1 1 1\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 8 \"1 2 3 5\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_meal_combinations",
    "entry_point": "count_meal_combinations",
    "signature": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n",
    "docstring": {
      "en": "This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "es": "Esta función calcula el número de formas de gastar todo el dinero disponible en una selección de platos en un restaurante. Cada plato solo se puede comprar una vez. La función toma el número de platos disponibles, la cantidad total de dinero y una cadena que contiene el precio de cada plato.\n\nCasos de Ejemplo:\n\ncount_meal_combinations 3 5 \"1 2 3\" debería devolver 2 (1+2+2 o 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" debería devolver 3 (1+2+3, 1+1+2+2, o 2+3+1).",
      "arb": "هذه الدالة تحسب عدد الطرق لإنفاق كل المال المتاح على مجموعة من الأطباق في مطعم. يمكن شراء كل طبق مرة واحدة فقط. تأخذ الدالة عدد الأطباق المتاحة، المبلغ الإجمالي من المال، وسلسلة تحتوي على سعر كل طبق.\n\nأمثلة الحالات:\n\ncount_meal_combinations 3 5 \"1 2 3\" يجب أن تعيد 2 (1+2+2 أو 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" يجب أن تعيد 3 (1+2+3، 1+1+2+2، أو 2+3+1).",
      "sw": "Kazi hii huhesabu idadi ya njia za kutumia pesa zote zinazopatikana kwenye uchaguzi wa sahani katika mgahawa. Kila sahani inaweza kununuliwa mara moja tu. Kazi hii inachukua idadi ya sahani zinazopatikana, jumla ya kiasi cha pesa, na kamba inayoelezea bei ya kila sahani.\n\nMifano ya Kesi:\n\ncount_meal_combinations 3 5 \"1 2 3\" inapaswa kurudisha 2 (1+2+2 au 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" inapaswa kurudisha 3 (1+2+3, 1+1+2+2, au 2+3+1).",
      "tr": "Bu fonksiyon, bir restoranda mevcut tüm parayı bir yemek seçkisine harcamanın kaç farklı yolu olduğunu hesaplar. Her yemek yalnızca bir kez satın alınabilir. Fonksiyon, mevcut yemek sayısını, toplam para miktarını ve her yemeğin fiyatını içeren bir dizeyi alır.\n\nÖrnek Durumlar:\n\ncount_meal_combinations 3 5 \"1 2 3\" 2 döndürmelidir (1+2+2 veya 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" 3 döndürmelidir (1+2+3, 1+1+2+2 veya 2+3+1).",
      "vi": "Hàm này tính toán số cách để tiêu hết số tiền có sẵn vào việc chọn các món ăn trong một nhà hàng. Mỗi món ăn chỉ có thể được mua một lần. Hàm nhận vào số lượng món ăn có sẵn, tổng số tiền, và một chuỗi chứa giá của mỗi món ăn.\n\nCác trường hợp ví dụ:\n\ncount_meal_combinations 3 5 \"1 2 3\" nên trả về 2 (1+2+2 hoặc 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" nên trả về 3 (1+2+3, 1+1+2+2, hoặc 2+3+1)."
    },
    "docstring_bertscore": {
      "es": "0.9962041734184233",
      "arb": "0.9924039769684638",
      "sw": "0.9745330029563739",
      "tr": "0.9653350259017913",
      "vi": "0.5163878578614025"
    }
  },
  {
    "task_id": "Shell/38",
    "prompt": {
      "en": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# This function finds the previous lexicographical permutation of a given sequence.\n# If the current permutation is the first one in lexicographical order, it returns 'ERROR'.\n# The function takes the number of elements and the current permutation as arguments.\n# Example usage:\n# previous_permutation 3 \"1 2 3\"\n# This would return 'ERROR', as '1 2 3' is the first permutation.\n\n# previous_permutation 4 \"1 3 4 2\"\n# This would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "es": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Esta función encuentra la permutación lexicográfica anterior de una secuencia dada.\n# Si la permutación actual es la primera en orden lexicográfico, devuelve 'ERROR'.\n# La función toma el número de elementos y la permutación actual como argumentos.\n# Ejemplo de uso:\n# previous_permutation 3 \"1 2 3\"\n# Esto devolvería 'ERROR', ya que '1 2 3' es la primera permutación.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Esto devolvería '1 3 2 4', ya que es la permutación anterior en orden lexicográfico.",
      "arb": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# هذه الدالة تجد الترتيب السابق في الترتيب المعجمي لتسلسل معين.\n# إذا كان الترتيب الحالي هو الأول في الترتيب المعجمي، فإنها تعيد 'ERROR'.\n# تأخذ الدالة عدد العناصر والترتيب الحالي كوسائط.\n# مثال على الاستخدام:\n# previous_permutation 3 \"1 2 3\"\n# هذا سيعيد 'ERROR'، لأن '1 2 3' هو الترتيب الأول.\n\n# previous_permutation 4 \"1 3 4 2\"\n# هذا سيعيد '1 3 2 4'، لأنه الترتيب السابق في الترتيب المعجمي.\n",
      "sw": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Kazi ya hii kazi ni kupata mpangilio wa awali wa leksikografia wa mlolongo uliotolewa.\n# Ikiwa mpangilio wa sasa ni wa kwanza katika mpangilio wa leksikografia, inarudisha 'ERROR'.\n# Kazi inachukua idadi ya vipengele na mpangilio wa sasa kama hoja.\n# Mfano wa matumizi:\n# previous_permutation 3 \"1 2 3\"\n# Hii ingerudisha 'ERROR', kwa kuwa '1 2 3' ni mpangilio wa kwanza.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Hii ingerudisha '1 3 2 4', kwa kuwa ni mpangilio wa awali katika mpangilio wa leksikografia.",
      "tr": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Bu fonksiyon, verilen bir dizinin bir önceki sözlük sırasına göre permütasyonunu bulur.\n# Eğer mevcut permütasyon sözlük sırasına göre ilk permütasyon ise, 'ERROR' döner.\n# Fonksiyon, eleman sayısını ve mevcut permütasyonu argüman olarak alır.\n# Örnek kullanım:\n# previous_permutation 3 \"1 2 3\"\n# Bu, '1 2 3' sözlük sırasına göre ilk permütasyon olduğu için 'ERROR' döner.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Bu, sözlük sırasına göre bir önceki permütasyon olan '1 3 2 4' döner.\n",
      "vi": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Hàm này tìm hoán vị từ điển trước của một dãy cho trước.\n# Nếu hoán vị hiện tại là hoán vị đầu tiên theo thứ tự từ điển, nó trả về 'ERROR'.\n# Hàm nhận số lượng phần tử và hoán vị hiện tại làm tham số.\n# Ví dụ sử dụng:\n# previous_permutation 3 \"1 2 3\"\n# Điều này sẽ trả về 'ERROR', vì '1 2 3' là hoán vị đầu tiên.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Điều này sẽ trả về '1 3 2 4', vì đó là hoán vị trước theo thứ tự từ điển."
    },
    "prompt_bertscore": {
      "es": "0.9862565653058151",
      "arb": "0.9760038609279372",
      "sw": "0.9694738871514152",
      "tr": "0.9596518134396211",
      "vi": "0.9847422072808051"
    },
    "canonical_solution": "for (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}",
    "instruction": {
      "en": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n\nfor (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n\nfor (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n\nfor (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n\nfor (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n\nfor (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n\nfor (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8873803479304581",
      "sw": "0.9274705136258726",
      "tr": "0.8487360127785964",
      "vi": "0.9438015062937991"
    },
    "level": "",
    "test": "test_previous_permutation() {\n[[ $(previous_permutation 3 \"1 3 2\") == \"1 2 3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(previous_permutation 3 \"1 2 3\") == \"ERROR\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"2 1 4 3\") == \"2 1 3 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(previous_permutation 5 \"5 4 3 2 1\") == \"5 4 3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"1 4 3 2\") == \"1 4 2 3\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_previous_permutation",
    "entry_point": "previous_permutation",
    "signature": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n",
    "docstring": {
      "en": "This function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "es": "Esta función encuentra la permutación lexicográfica anterior de una secuencia dada.  \nSi la permutación actual es la primera en orden lexicográfico, devuelve 'ERROR'.  \nLa función toma el número de elementos y la permutación actual como argumentos.  \nEjemplo de uso:  \nprevious_permutation 3 \"1 2 3\"  \nEsto devolvería 'ERROR', ya que '1 2 3' es la primera permutación.  \n\nprevious_permutation 4 \"1 3 4 2\"  \nEsto devolvería '1 3 2 4', ya que es la permutación anterior en orden lexicográfico.  ",
      "arb": "هذه الدالة تجد الترتيب السابق في الترتيب المعجمي لتسلسل معين.  \nإذا كان الترتيب الحالي هو الأول في الترتيب المعجمي، فإنها تعيد 'ERROR'.  \nتأخذ الدالة عدد العناصر والترتيب الحالي كوسائط.  \nمثال على الاستخدام:  \nprevious_permutation 3 \"1 2 3\"  \nهذا سيعيد 'ERROR'، لأن '1 2 3' هو الترتيب الأول.  \n\nprevious_permutation 4 \"1 3 4 2\"  \nهذا سيعيد '1 3 2 4'، لأنه الترتيب السابق في الترتيب المعجمي.  ",
      "sw": "Kazi ya hii kazi ni kupata mpangilio wa awali wa leksikografia wa mlolongo uliotolewa. \nIkiwa mpangilio wa sasa ni wa kwanza katika mpangilio wa leksikografia, inarudisha 'ERROR'.  \nKazi hii inachukua idadi ya vipengele na mpangilio wa sasa kama hoja.  \nMfano wa matumizi:  \nprevious_permutation 3 \"1 2 3\"  \nHii ingerudisha 'ERROR', kwa kuwa '1 2 3' ni mpangilio wa kwanza.  \n\nprevious_permutation 4 \"1 3 4 2\"   \nHii ingerudisha '1 3 2 4', kwa kuwa ni mpangilio wa awali katika mpangilio wa leksikografia.  ",
      "tr": "Bu fonksiyon, verilen bir dizinin önceki sözlük sıralamasındaki permütasyonunu bulur.\nEğer mevcut permütasyon sözlük sıralamasında ilk sıradaysa, 'ERROR' döndürür.\nFonksiyon, eleman sayısını ve mevcut permütasyonu argüman olarak alır.\nÖrnek kullanım:\nprevious_permutation 3 \"1 2 3\"\nBu, '1 2 3' ilk permütasyon olduğundan 'ERROR' döndürecektir.\n\nprevious_permutation 4 \"1 3 4 2\"\nBu, sözlük sıralamasında önceki permütasyon olduğu için '1 3 2 4' döndürecektir.",
      "vi": "Hàm này tìm hoán vị từ điển trước của một dãy cho trước.  \nNếu hoán vị hiện tại là hoán vị đầu tiên theo thứ tự từ điển, nó trả về 'ERROR'.  \nHàm nhận số lượng phần tử và hoán vị hiện tại làm đối số.  \nVí dụ sử dụng:  \nprevious_permutation 3 \"1 2 3\"  \nĐiều này sẽ trả về 'ERROR', vì '1 2 3' là hoán vị đầu tiên.  \n  \nprevious_permutation 4 \"1 3 4 2\"  \nĐiều này sẽ trả về '1 3 2 4', vì đó là hoán vị trước theo thứ tự từ điển."
    },
    "docstring_bertscore": {
      "es": "0.9862627228476272",
      "arb": "0.964758799166409",
      "sw": "0.8600643006697781",
      "tr": "0.9855609617114309",
      "vi": "0.9830238558544723"
    }
  },
  {
    "task_id": "Shell/39",
    "prompt": {
      "en": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# This function checks the number of matches each lottery ticket has with the winning numbers\n# and categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\n# The function takes the winning numbers and the lottery tickets as arguments.\n# Example usage:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# This would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# This would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "es": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Esta función verifica el número de coincidencias que tiene cada boleto de lotería con los números ganadores\n# y categoriza cada boleto según el premio ganado. Devuelve el conteo de boletos para cada categoría de premio.\n# La función toma los números ganadores y los boletos de lotería como argumentos.\n# Ejemplo de uso:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Esto devolvería '0 1 0 0 0 0 0', ya que el segundo boleto gana un primer premio.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Esto devolvería '0 0 0 0 0 0 0', ya que ningún boleto coincide con los números ganadores.",
      "arb": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# تقوم هذه الدالة بفحص عدد التطابقات التي يمتلكها كل تذكرة يانصيب مع الأرقام الفائزة\n# وتصنف كل تذكرة بناءً على الجائزة التي فازت بها. تعيد الدالة عدد التذاكر لكل فئة جائزة.\n# تأخذ الدالة الأرقام الفائزة وتذاكر اليانصيب كوسائط.\n# مثال على الاستخدام:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# سيعيد هذا '0 1 0 0 0 0 0'، حيث تفوز التذكرة الثانية بالجائزة الأولى.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# سيعيد هذا '0 0 0 0 0 0 0'، حيث لا تتطابق أي تذاكر مع أي من الأرقام الفائزة.",
      "sw": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Kazi ya hii kazi ni kuangalia idadi ya namba zinazolingana kati ya kila tiketi ya bahati nasibu na namba za ushindi\n# na kuainisha kila tiketi kulingana na zawadi iliyoshindwa. Inarudisha idadi ya tiketi kwa kila kategoria ya zawadi.\n# Kazi hii inachukua namba za ushindi na tiketi za bahati nasibu kama hoja.\n# Mfano wa matumizi:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Hii ingerudisha '0 1 0 0 0 0 0', kwani tiketi ya pili inashinda zawadi ya kwanza.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Hii ingerudisha '0 0 0 0 0 0 0', kwani hakuna tiketi zinazolingana na namba zozote za ushindi.",
      "tr": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Bu fonksiyon, her piyango biletinin kazanan numaralarla eşleşme sayısını kontrol eder\n# ve her bileti kazanılan ödül kategorisine göre sınıflandırır. Her ödül kategorisi için bilet sayısını döndürür.\n# Fonksiyon, kazanan numaraları ve piyango biletlerini argüman olarak alır.\n# Örnek kullanım:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Bu, '0 1 0 0 0 0 0' döndürecektir, çünkü ikinci bilet birinci ödülü kazanır.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Bu, '0 0 0 0 0 0 0' döndürecektir, çünkü hiçbir bilet kazanan numaralarla eşleşmez.",
      "vi": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Hàm này kiểm tra số lượng khớp của mỗi vé số với các số trúng thưởng\n# và phân loại mỗi vé dựa trên giải thưởng đã trúng. Nó trả về số lượng vé cho mỗi loại giải thưởng.\n# Hàm nhận các số trúng thưởng và các vé số làm tham số.\n# Ví dụ sử dụng:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Điều này sẽ trả về '0 1 0 0 0 0 0', vì vé thứ hai trúng giải nhất.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Điều này sẽ trả về '0 0 0 0 0 0 0', vì không có vé nào khớp với bất kỳ số trúng thưởng nào."
    },
    "prompt_bertscore": {
      "es": "0.9906075638023842",
      "arb": "0.9676381451698909",
      "sw": "0.9600947591893289",
      "tr": "0.9821878205806964",
      "vi": "0.9836024661544269"
    },
    "canonical_solution": "shift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}",
    "instruction": {
      "en": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n\nshift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n\nshift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n\nshift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n\nshift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n\nshift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n\nshift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8956417827384612",
      "sw": "0.9429899025568905",
      "tr": "0.8547378283719466",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_check_lottery_winnings() {\nlocal result\nresult=$(check_lottery_winnings \"23 31 1 14 19 17 18\" \"12 8 9 23 1 16 7\" \"11 7 10 21 2 9 31\")\n[[ $result == \"0 0 0 0 0 1 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"5 6 7 8 9 10 11\" \"1 2 3 4 5 6 7\" \"5 6 7 12 13 14 15\")\n[[ $result == \"0 0 0 0 2 0 0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"15 16 17 18 19 20 21\" \"22 23 24 25 26 27 28\" \"29 30 31 32 33 1 2\")\n[[ $result == \"0 0 0 0 0 0 0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_check_lottery_winnings",
    "entry_point": "check_lottery_winnings",
    "signature": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n",
    "docstring": {
      "en": "This function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "es": "Esta función verifica el número de coincidencias que cada boleto de lotería tiene con los números ganadores y categoriza cada boleto según el premio ganado. Devuelve el conteo de boletos para cada categoría de premio. La función toma los números ganadores y los boletos de lotería como argumentos.\nEjemplo de uso:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nEsto devolvería '0 1 0 0 0 0 0', ya que el segundo boleto gana un primer premio.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nEsto devolvería '0 0 0 0 0 0 0', ya que ningún boleto coincide con los números ganadores.",
      "arb": "هذه الدالة تتحقق من عدد التطابقات لكل تذكرة يانصيب مع الأرقام الفائزة وتقوم بتصنيف كل تذكرة بناءً على الجائزة التي فازت بها. تُرجع الدالة عدد التذاكر لكل فئة جائزة. تأخذ الدالة الأرقام الفائزة وتذاكر اليانصيب كوسائط.\n\nمثال على الاستخدام:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nهذا سيعيد '0 1 0 0 0 0 0'، حيث أن التذكرة الثانية تفوز بالجائزة الأولى.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nهذا سيعيد '0 0 0 0 0 0 0'، حيث لا تتطابق أي تذاكر مع أي من الأرقام الفائزة.",
      "sw": "Kazi hii inachunguza idadi ya mechi kila tiketi ya bahati nasibu inavyolingana na namba za ushindi na kuainisha kila tiketi kulingana na zawadi iliyoshinda. Inarudisha hesabu ya tiketi kwa kila aina ya zawadi. Kazi hii inachukua namba za ushindi na tiketi za bahati nasibu kama hoja.\n\nMfano wa matumizi:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nHii ingerudisha '0 1 0 0 0 0 0', kwani tiketi ya pili inashinda zawadi ya kwanza.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nHii ingerudisha '0 0 0 0 0 0 0', kwani hakuna tiketi inayolingana na namba zozote za ushindi.",
      "tr": "Bu fonksiyon, her piyango biletinin kazanan numaralarla kaç eşleşmesi olduğunu kontrol eder ve her bileti kazanılan ödüle göre kategorize eder. Her ödül kategorisi için bilet sayısını döndürür. Fonksiyon, kazanan numaraları ve piyango biletlerini argüman olarak alır.\nÖrnek kullanım:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nBu, '0 1 0 0 0 0 0' döndürecektir, çünkü ikinci bilet birinci ödülü kazanır.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nBu, '0 0 0 0 0 0 0' döndürecektir, çünkü hiçbir bilet kazanan numaralarla eşleşmez.",
      "vi": "Hàm này kiểm tra số lượng kết quả trùng khớp của mỗi vé số với các số trúng thưởng và phân loại từng vé dựa trên giải thưởng đã trúng. Nó trả về số lượng vé cho mỗi loại giải thưởng. Hàm nhận các số trúng thưởng và các vé số làm đối số.\n\nVí dụ sử dụng:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nĐiều này sẽ trả về '0 1 0 0 0 0 0', vì vé thứ hai trúng giải nhất.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nĐiều này sẽ trả về '0 0 0 0 0 0 0', vì không có vé nào trùng với bất kỳ số trúng thưởng nào."
    },
    "docstring_bertscore": {
      "es": "0.9905916733719015",
      "arb": "0.9659773965540581",
      "sw": "0.9735247551422408",
      "tr": "0.9746885305447242",
      "vi": "0.9800660508504817"
    }
  },
  {
    "task_id": "Shell/40",
    "prompt": {
      "en": "calculate_max_pens() {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "es": "calculate_max_pens() {\n    # Esta función calcula el número máximo de bolígrafos que se pueden comprar con una cantidad dada de dinero.\n    # El precio de un bolígrafo es de 1 Yuan y 9 Jiao (1.9 Yuan).\n    # La función toma dos enteros, a y b, como entrada donde 'a' representa la parte en Yuan y 'b' representa la parte en Jiao del dinero total disponible.\n    # Devuelve el número máximo de bolígrafos que se pueden comprar.\n    # Por ejemplo, si a=5 y b=0, la función devolverá 2, ya que el dinero total es de 5 Yuan, y dos bolígrafos cuestan 3.8 Yuan.",
      "arb": "calculate_max_pens() {\n    # هذه الدالة تحسب الحد الأقصى لعدد الأقلام التي يمكن شراؤها بمبلغ معين من المال.\n    # سعر القلم الواحد هو 1 يوان و9 جياو (1.9 يوان).\n    # تأخذ الدالة عددين صحيحين، a و b، كمدخل حيث يمثل 'a' جزء اليوان و 'b' يمثل جزء الجياو من إجمالي المال المتاح.\n    # تُرجع الحد الأقصى لعدد الأقلام التي يمكن شراؤها.\n    # على سبيل المثال، إذا كانت a=5 و b=0، فإن الدالة ستُرجع 2، حيث أن إجمالي المال هو 5 يوان، وقلمان يكلفان 3.8 يوان.",
      "sw": "calculate_max_pens() {\n    # Kazi ya hii kazi ni kuhesabu idadi kubwa zaidi ya kalamu ambazo zinaweza kununuliwa kwa kiasi fulani cha pesa.\n    # Bei ya kalamu moja ni Yuan 1 na Jiao 9 (Yuan 1.9).\n    # Kazi hii inachukua namba mbili nzima, a na b, kama pembejeo ambapo 'a' inawakilisha Yuan na 'b' inawakilisha sehemu ya Jiao ya jumla ya pesa inayopatikana.\n    # Inarudisha idadi kubwa zaidi ya kalamu ambazo zinaweza kununuliwa.\n    # Kwa mfano, ikiwa a=5 na b=0, kazi itarudisha 2, kwani jumla ya pesa ni Yuan 5, na kalamu mbili zinagharimu Yuan 3.8.",
      "tr": "calculate_max_pens() {\n    # Bu fonksiyon, belirli bir miktar para ile satın alınabilecek maksimum kalem sayısını hesaplar.\n    # Bir kalemin fiyatı 1 Yuan ve 9 Jiao'dur (1.9 Yuan).\n    # Fonksiyon, 'a' Yuan'ı ve 'b' Jiao'yu temsil eden iki tam sayı alır ve toplam mevcut parayı belirtir.\n    # Satın alınabilecek maksimum kalem sayısını döndürür.\n    # Örneğin, eğer a=5 ve b=0 ise, fonksiyon 2 döndürecektir, çünkü toplam para 5 Yuan'dır ve iki kalem 3.8 Yuan'a mal olur.",
      "vi": "calculate_max_pens() {\n    # Hàm này tính toán số lượng bút tối đa có thể mua với một số tiền nhất định.\n    # Giá của một cây bút là 1 Yuan và 9 Jiao (1.9 Yuan).\n    # Hàm nhận hai số nguyên, a và b, làm đầu vào, trong đó 'a' đại diện cho phần Yuan và 'b' đại diện cho phần Jiao của tổng số tiền có sẵn.\n    # Nó trả về số lượng bút tối đa có thể mua được.\n    # Ví dụ, nếu a=5 và b=0, hàm sẽ trả về 2, vì tổng số tiền là 5 Yuan, và hai cây bút có giá 3.8 Yuan."
    },
    "prompt_bertscore": {
      "es": "0.9891974867274176",
      "arb": "0.9786911313529583",
      "sw": "0.9632903247594182",
      "tr": "0.944439109816921",
      "vi": "0.9799528315332918"
    },
    "canonical_solution": "    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}",
    "instruction": {
      "en": "calculate_max_pens() {\n    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_max_pens() {\n    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_max_pens() {\n    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "calculate_max_pens() {\n    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_max_pens() {\n    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "calculate_max_pens() {\n    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9148916488556953",
      "sw": "0.9429899025568905",
      "tr": "0.862221227977436",
      "vi": "0.8947882679911542"
    },
    "level": "",
    "test": "test_calculate_max_pens() {\n    local result\n\n    result=$(calculate_max_pens 5 5)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 1 failed: Expected 2, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 20 1)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 2 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 3 8)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 11 0)\n    [[ \"$result\" -eq 5 ]] || { echo \"Test 4 failed: Expected 5, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 100 5)\n    [[ \"$result\" -eq 52 ]] || { echo \"Test 5 failed: Expected 52, got $result\"; exit 1; }\n}\n\ntest_calculate_max_pens",
    "entry_point": "calculate_max_pens",
    "signature": "calculate_max_pens() {",
    "docstring": {
      "en": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "es": "Esta función calcula el número máximo de bolígrafos que se pueden comprar con una cantidad dada de dinero.  \nEl precio de un bolígrafo es de 1 Yuan y 9 Jiao (1.9 Yuan).  \nLa función toma dos enteros, a y b, como entrada donde 'a' representa la parte en Yuan y 'b' representa la parte en Jiao del dinero total disponible.  \nDevuelve el número máximo de bolígrafos que se pueden comprar.  \nPor ejemplo, si a=5 y b=0, la función devolverá 2, ya que el dinero total es 5 Yuan, y dos bolígrafos cuestan 3.8 Yuan.",
      "arb": "هذه الدالة تحسب الحد الأقصى لعدد الأقلام التي يمكن شراؤها بمبلغ معين من المال. سعر القلم الواحد هو 1 يوان و9 جياو (1.9 يوان). تأخذ الدالة عددين صحيحين، a و b، كمدخل حيث يمثل 'a' جزء اليوان و 'b' جزء الجياو من إجمالي المال المتاح. تُرجع الدالة الحد الأقصى لعدد الأقلام التي يمكن شراؤها. على سبيل المثال، إذا كان a=5 و b=0، فستُرجع الدالة 2، لأن إجمالي المال هو 5 يوان، وتكلفة قلمين هي 3.8 يوان.",
      "sw": " Kazi ya hii kazi ni kuhesabu idadi kubwa zaidi ya kalamu ambazo zinaweza kununuliwa na kiasi fulani cha pesa.\n  Bei ya kalamu moja ni Yuan 1 na Jiao 9 (Yuan 1.9).\n Kazi hii inachukua namba mbili kamili, a na b, kama ingizo ambapo 'a' inawakilisha Yuan na 'b' inawakilisha sehemu ya Jiao ya jumla ya pesa zilizopo.\n Inarudisha idadi kubwa zaidi ya kalamu ambazo zinaweza kununuliwa.\n Kwa mfano, ikiwa a=5 na b=0, kazi itarudisha 2, kwani jumla ya pesa ni Yuan 5, na kalamu mbili zinagharimu Yuan 3.8.",
      "tr": "Bu fonksiyon, belirli bir miktar parayla satın alınabilecek maksimum kalem sayısını hesaplar.\nBir kalemin fiyatı 1 Yuan ve 9 Jiao'dur (1.9 Yuan).\nFonksiyon, iki tamsayı alır: 'a' ve 'b', burada 'a' toplam mevcut paranın Yuan kısmını ve 'b' ise Jiao kısmını temsil eder.\nSatın alınabilecek maksimum kalem sayısını döndürür.\nÖrneğin, a=5 ve b=0 ise, fonksiyon 2 döndürecektir, çünkü toplam para 5 Yuan'dır ve iki kalem 3.8 Yuan tutarındadır.",
      "vi": "Hàm này tính toán số lượng bút tối đa có thể mua được với một số tiền nhất định. \nGiá của một chiếc bút là 1 Nhân dân tệ và 9 Jiao (1.9 Nhân dân tệ). \nHàm nhận hai số nguyên, a và b, làm đầu vào, trong đó 'a' đại diện cho phần Nhân dân tệ và 'b' đại diện cho phần Jiao của tổng số tiền có sẵn. \nNó trả về số lượng bút tối đa có thể mua được. \nVí dụ, nếu a=5 và b=0, hàm sẽ trả về 2, vì tổng số tiền là 5 Nhân dân tệ, và hai chiếc bút có giá 3.8 Nhân dân tệ."
    },
    "docstring_bertscore": {
      "es": "0.9876588957959214",
      "arb": "0.9665643493300162",
      "sw": "0.8571917080992516",
      "tr": "0.9312490593642994",
      "vi": "0.4198159515364313"
    }
  },
  {
    "task_id": "Shell/41",
    "prompt": {
      "en": "calculate_expression() {\n    # Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n    # Args:\n    #     a (int): The first integer.\n    #     b (int): The second integer.\n    #     c (int): The third integer.\n    #\n    # Returns:\n    #     The result of the expression (a+b)*c.\n    #\n    # Examples:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "es": "calculate_expression() {\n    # Calcular el valor de la expresión (a+b)*c con los enteros dados a, b, y c.\n    # Argumentos:\n    #     a (int): El primer entero.\n    #     b (int): El segundo entero.\n    #     c (int): El tercer entero.\n    #\n    # Devuelve:\n    #     El resultado de la expresión (a+b)*c.\n    #\n    # Ejemplos:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "arb": "calculate_expression() {\n    # احسب قيمة التعبير (a+b)*c باستخدام الأعداد الصحيحة المعطاة a و b و c.\n    # الوسائط:\n    #     a (int): العدد الصحيح الأول.\n    #     b (int): العدد الصحيح الثاني.\n    #     c (int): العدد الصحيح الثالث.\n    #\n    # يعيد:\n    #     نتيجة التعبير (a+b)*c.\n    #\n    # أمثلة:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "sw": "calculate_expression() {\n    # Hesabu thamani ya usemi (a+b)*c na nambari kamili zilizotolewa a, b, na c.\n    # Hoja:\n    #     a (int): Nambari ya kwanza.\n    #     b (int): Nambari ya pili.\n    #     c (int): Nambari ya tatu.\n    #\n    # Inarejesha:\n    #     Matokeo ya usemi (a+b)*c.\n    #\n    # Mifano:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "tr": "calculate_expression() {\n    # Verilen tamsayılar a, b ve c ile ifadenin (a+b)*c değerini hesapla.\n    # Argümanlar:\n    #     a (int): Birinci tamsayı.\n    #     b (int): İkinci tamsayı.\n    #     c (int): Üçüncü tamsayı.\n    #\n    # Döndürür:\n    #     İfadenin (a+b)*c sonucu.\n    #\n    # Örnekler:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "vi": "calculate_expression() {\n    # Tính giá trị của biểu thức (a+b)*c với các số nguyên a, b và c đã cho.\n    # Tham số:\n    #     a (int): Số nguyên thứ nhất.\n    #     b (int): Số nguyên thứ hai.\n    #     c (int): Số nguyên thứ ba.\n    #\n    # Trả về:\n    #     Kết quả của biểu thức (a+b)*c.\n    #\n    # Ví dụ:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3"
    },
    "prompt_bertscore": {
      "es": "0.9869670661787768",
      "arb": "0.9849972486900539",
      "sw": "0.9678177070343463",
      "tr": "0.9763079640413016",
      "vi": "0.9845980016241738"
    },
    "canonical_solution": "    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}",
    "instruction": {
      "en": "calculate_expression() {\n    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_expression() {\n    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "calculate_expression() {\n    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "calculate_expression() {\n    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_expression() {\n    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "calculate_expression() {\n    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8990808691556992",
      "sw": "0.9429899025568905",
      "tr": "0.8429219028953242",
      "vi": "0.9275384452161866"
    },
    "level": "",
    "test": "test_calculate_expression() {\n    local result\n\n    result=$(calculate_expression 1 2 3)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_expression -1 2 -3)\n    [[ \"$result\" -eq -3 ]] || { echo \"Test 2 failed: Expected -3, got $result\"; exit 1; }\n\n    result=$(calculate_expression 0 0 1)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 3 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(calculate_expression 10 -5 2)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 4 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_expression 100 200 -1)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 5 failed: Expected -300, got $result\"; exit 1; }\n}\n\ntest_calculate_expression",
    "entry_point": "calculate_expression",
    "signature": "calculate_expression() {",
    "docstring": {
      "en": " Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "es": "Calcular el valor de la expresión (a+b)*c con los enteros dados a, b y c.\nArgumentos:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nEl resultado de la expresión (a+b)*c.\n\nEjemplos:\n>>> calculate_expression 1 2 3\n9\n>>> calculate_expression -1 2 -3\n-3",
      "arb": "احسب قيمة التعبير (a+b)*c باستخدام الأعداد الصحيحة المعطاة a، b، و c.\nيعيدالحجج:\n a (int): العدد الصحيح الأول.\n b (int): العدد الصحيح الثاني.\n c (int): العدد الصحيح الثالث.\n\nيعيد:\n نتيجة التعبير (a+b)*c.\n\nامثله:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "sw": "Hesabu thamani ya usemi (a+b)*c kwa namba kamili zilizotolewa a, b, na c.\n\nHoja:\n a (int): Namba kamili ya kwanza.\n b (int): Namba kamili ya pili.\n c (int): Namba kamili ya tatu.\n\nInarejesha:\n Matokeo ya usemi (a+b)*c.\n\nMifano:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "tr": "Hesaplama ifadesinin değerini (a+b)*c verilen tamsayılar a, b ve c ile hesaplayın.\nArgümanlar:\n    a (int): İlk tamsayı.\n    b (int): İkinci tamsayı.\n    c (int): Üçüncü tamsayı.\n\nDöndürür:\n    İfadenin sonucu (a+b)*c.\n\nÖrnekler:\n    >>> calculate_expression 1 2 3\n    9\n    >>> calculate_expression -1 2 -3\n    -3",
      "vi": "Tính giá trị của biểu thức (a+b)*c với các số nguyên a, b và c được cho.\n\nTham số:\n a (int): Số nguyên thứ nhất.\n b (int): Số nguyên thứ hai.\n c (int): Số nguyên thứ ba.\n\nTrả về:\n Kết quả của biểu thức (a+b)*c.\n\nVí dụ:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3"
    },
    "docstring_bertscore": {
      "es": "0.9956978645771654",
      "arb": "0.9931685053050671",
      "sw": "0.9916559349534864",
      "tr": "0.9836696032232166",
      "vi": "0.9956978645771654"
    }
  },
  {
    "task_id": "Shell/42",
    "prompt": {
      "en": "print_ascii_code() {\n    # Prints the ASCII code of a given visible character (excluding space).\n    # Args:\n    #     char (string): A single character for which the ASCII code will be printed.\n    #\n    # Output:\n    #     Prints the ASCII code of the given character.\n    #\n    # Examples:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "es": "print_ascii_code() {\n    # Imprime el código ASCII de un carácter visible dado (excluyendo el espacio).\n    # Argumentos:\n    #     char (string): Un solo carácter para el cual se imprimirá el código ASCII.\n    #\n    # Salida:\n    #     Imprime el código ASCII del carácter dado.\n    #\n    # Ejemplos:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "arb": "print_ascii_code() {\n    # يطبع رمز ASCII لحرف مرئي معين (باستثناء المسافة).\n    # المعطيات:\n    #     char (string): حرف واحد سيتم طباعة رمز ASCII له.\n    #\n    # المخرجات:\n    #     يطبع رمز ASCII للحرف المعطى.\n    #\n    # أمثلة:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "sw": "print_ascii_code() {\n    # Inachapisha msimbo wa ASCII wa herufi inayoonekana iliyotolewa (isipokuwa nafasi).\n    # Hoja:\n    #     char (string): Herufi moja ambayo msimbo wa ASCII utaonyeshwa.\n    #\n    # Matokeo:\n    #     Inachapisha msimbo wa ASCII wa herufi iliyotolewa.\n    #\n    # Mifano:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "tr": "print_ascii_code() {\n    # Verilen bir görünen karakterin (boşluk hariç) ASCII kodunu yazdırır.\n    # Argümanlar:\n    #     char (string): ASCII kodu yazdırılacak tek bir karakter.\n    #\n    # Çıktı:\n    #     Verilen karakterin ASCII kodunu yazdırır.\n    #\n    # Örnekler:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "vi": "print_ascii_code() {\n    # In ra mã ASCII của một ký tự có thể nhìn thấy được (không bao gồm khoảng trắng).\n    # Tham số:\n    #     char (string): Một ký tự duy nhất mà mã ASCII sẽ được in ra.\n    #\n    # Đầu ra:\n    #     In ra mã ASCII của ký tự đã cho.\n    #\n    # Ví dụ:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122"
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.970610847452459",
      "sw": "0.9782581171223022",
      "tr": "0.9717623077713182",
      "vi": "0.9499691782553134"
    },
    "canonical_solution": "    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}",
    "instruction": {
      "en": "print_ascii_code() {\n    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "print_ascii_code() {\n    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando un máximo de 500 caracteres.",
      "arb": "print_ascii_code() {\n    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود الشيل باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "print_ascii_code() {\n    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "print_ascii_code() {\n    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "print_ascii_code() {\n    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9033172579224112",
      "sw": "0.9274705136258726",
      "tr": "0.8485630057167151",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_print_ascii_code() {\n    local result\n\n    result=$(print_ascii_code 'B')\n    [[ \"$result\" -eq 66 ]] || { echo \"Test 1 failed: Expected 66, got $result\"; exit 1; }\n\n    result=$(print_ascii_code 'z')\n    [[ \"$result\" -eq 122 ]] || { echo \"Test 2 failed: Expected 122, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '1')\n    [[ \"$result\" -eq 49 ]] || { echo \"Test 3 failed: Expected 49, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '%')\n    [[ \"$result\" -eq 37 ]] || { echo \"Test 4 failed: Expected 37, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '?')\n    [[ \"$result\" -eq 63 ]] || { echo \"Test 5 failed: Expected 63, got $result\"; exit 1; }\n}\n\ntest_print_ascii_code",
    "entry_point": "print_ascii_code",
    "signature": "print_ascii_code() {",
    "docstring": {
      "en": " Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "es": "Imprime el código ASCII de un carácter visible dado (excluyendo el espacio).\nArgumentos:\n char (string): Un solo carácter para el cual se imprimirá el código ASCII.\n\nSalida:\nImprime el código ASCII del carácter dado.\n\nEjemplos:\n>>> print_ascii_code 'B'\n66\n>>> print_ascii_code 'z'\n122",
      "arb": "يطبع الشيفرة ASCII لحرف مرئي معين (باستثناء المسافة).\nيعيدالحجج:\nchar (string): حرف واحد سيتم طباعة الشيفرة ASCII الخاصة به.\n\nالناتج:\nيطبع الشيفرة ASCII للحرف المعطى.\n\nامثله:\n>>> print_ascii_code 'B'\n66\n>>> print_ascii_code 'z'\n122",
      "sw": "Inachapisha msimbo wa ASCII wa herufi inayoonekana iliyotolewa (isipokuwa nafasi).\nHoja:\n char (string): Herufi moja ambayo msimbo wa ASCII utachapishwa.\n\nMatokeo:\n Inachapisha msimbo wa ASCII wa herufi iliyotolewa.\n\nMifano:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "tr": " Verilen görünür karakterin (boşluk hariç) ASCII kodunu yazdırır.\n Argümanlar:\n char (string): ASCII kodu yazdırılacak tek bir karakter.\n\n Çıktı:\n Verilen karakterin ASCII kodunu yazdırır.\n\n Örnekler:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "vi": "In ra mã ASCII của một ký tự có thể nhìn thấy được (không bao gồm khoảng trắng).  \nTham số:  \nchar (string): Một ký tự đơn mà mã ASCII của nó sẽ được in ra.  \n\nĐầu ra:  \nIn ra mã ASCII của ký tự đã cho.  \n\nVí dụ:  \n>>> print_ascii_code 'B'  \n66  \n>>> print_ascii_code 'z'  \n122  "
    },
    "docstring_bertscore": {
      "es": "0.992894792640001",
      "arb": "0.9879379714812754",
      "sw": "0.9789829193826984",
      "tr": "0.9831712395972001",
      "vi": "0.9617485557418254"
    }
  },
  {
    "task_id": "Shell/43",
    "prompt": {
      "en": "ascii_to_char() {\n    # Converts an ASCII code to its corresponding character.\n    # Args:\n    #     ascii_code (int): The ASCII code to be converted.\n    #\n    # Output:\n    #     Prints the character corresponding to the given ASCII code.\n    #\n    # Examples:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "es": "ascii_to_char() {\n    # Convierte un código ASCII a su carácter correspondiente.\n    # Argumentos:\n    #     ascii_code (int): El código ASCII a convertir.\n    #\n    # Salida:\n    #     Imprime el carácter correspondiente al código ASCII dado.\n    #\n    # Ejemplos:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "arb": "ascii_to_char() {\n    # يحول رمز ASCII إلى الحرف المقابل له.\n    # الوسائط:\n    #     ascii_code (int): رمز ASCII الذي سيتم تحويله.\n    #\n    # المخرجات:\n    #     يطبع الحرف المقابل لرمز ASCII المعطى.\n    #\n    # أمثلة:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "sw": "ascii_to_char() {\n    # Hubadilisha msimbo wa ASCII kuwa herufi inayolingana.\n    # Hoja:\n    #     ascii_code (int): Msimbo wa ASCII utakaobadilishwa.\n    #\n    # Matokeo:\n    #     Huchapisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n    #\n    # Mifano:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "tr": "ascii_to_char() {\n    # Bir ASCII kodunu karşılık gelen karaktere dönüştürür.\n    # Argümanlar:\n    #     ascii_code (int): Dönüştürülecek ASCII kodu.\n    #\n    # Çıktı:\n    #     Verilen ASCII koduna karşılık gelen karakteri yazdırır.\n    #\n    # Örnekler:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "vi": "ascii_to_char() {\n    # Chuyển đổi mã ASCII thành ký tự tương ứng.\n    # Tham số:\n    #     ascii_code (int): Mã ASCII cần chuyển đổi.\n    #\n    # Đầu ra:\n    #     In ra ký tự tương ứng với mã ASCII đã cho.\n    #\n    # Ví dụ:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a"
    },
    "prompt_bertscore": {
      "es": "0.9949619390154311",
      "arb": "0.9842670834093696",
      "sw": "0.9810762849684251",
      "tr": "0.9880092797880669",
      "vi": "0.9578605646634485"
    },
    "canonical_solution": "    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}",
    "instruction": {
      "en": "ascii_to_char() {\n    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "ascii_to_char() {\n    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "ascii_to_char() {\n    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "ascii_to_char() {\n    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "ascii_to_char() {\n    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "ascii_to_char() {\n    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8882549174981547",
      "sw": "0.9148459638680573",
      "tr": "0.8552834660286495",
      "vi": "0.90164717367867"
    },
    "level": "",
    "test": "test_ascii_to_char() {\n    local result\n\n    result=$(ascii_to_char 66)\n    [[ \"$result\" == \"B\" ]] || { echo \"Test 1 failed: Expected B, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 97)\n    [[ \"$result\" == \"a\" ]] || { echo \"Test 2 failed: Expected a, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 36)\n    [[ \"$result\" == \"$\" ]] || { echo \"Test 3 failed: Expected $, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 57)\n    [[ \"$result\" == \"9\" ]] || { echo \"Test 4 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 32)\n    [[ \"$result\" == \" \" ]] || { echo \"Test 5 failed: Expected space, got $result\"; exit 1; }\n}\n\ntest_ascii_to_char",
    "entry_point": "ascii_to_char",
    "signature": "ascii_to_char() {",
    "docstring": {
      "en": " Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "es": "Convierte un código ASCII a su carácter correspondiente.\nArgumentos:\n ascii_code (int): El código ASCII que se va a convertir.\n\nSalida:\n Imprime el carácter correspondiente al código ASCII dado.\n\nEjemplos:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "arb": "يحول كود ASCII إلى الحرف المقابل له.\nيعيدالحجج:\nascii_code (int): كود ASCII الذي سيتم تحويله.\n\nالناتج:\nيطبع الحرف المقابل لكود ASCII المعطى.\n\nامثله:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "sw": "Inabadilisha msimbo wa ASCII kuwa herufi inayolingana nayo.\nHoja:\n ascii_code (int): Msimbo wa ASCII utakaobadilishwa.\n\nMatokeo:\n Inachapisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\nMifano:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "tr": "ASCII kodunu karşılık gelen karaktere dönüştürür.\nArgümanlar:\n ascii_code (int): Dönüştürülecek ASCII kodu.\n\n Çıktı:\n Verilen ASCII koduna karşılık gelen karakteri yazdırır.\n\n Örnekler:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "vi": "Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.\nTham số:\n ascii_code (int): Mã ASCII cần được chuyển đổi.\n\nĐầu ra:\n In ra ký tự tương ứng với mã ASCII đã cho.\n\nVí dụ:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a"
    },
    "docstring_bertscore": {
      "es": "0.9912970098549564",
      "arb": "0.9919393805072232",
      "sw": "0.9732095287275384",
      "tr": "0.9914811402181757",
      "vi": "0.9863491270633773"
    }
  },
  {
    "task_id": "Shell/44",
    "prompt": {
      "en": "int_to_bool_to_int() {\n    # Converts an integer to a boolean value, then converts this boolean back to an integer.\n    # The process involves assigning an integer value to a boolean variable and then\n    # assigning this boolean value back to an integer variable.\n    # Args:\n    #     initial_int (int): The initial integer value.\n    #\n    # Output:\n    #     Prints the integer value obtained after conversion from integer to boolean and back to integer.\n    #\n    # Examples:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "es": "int_to_bool_to_int() {\n    # Convierte un entero a un valor booleano, luego convierte este booleano de nuevo a un entero.\n    # El proceso implica asignar un valor entero a una variable booleana y luego\n    # asignar este valor booleano de nuevo a una variable entera.\n    # Argumentos:\n    #     initial_int (int): El valor entero inicial.\n    #\n    # Salida:\n    #     Imprime el valor entero obtenido después de la conversión de entero a booleano y de vuelta a entero.\n    #\n    # Ejemplos:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "arb": "int_to_bool_to_int() {\n    # يحول عددًا صحيحًا إلى قيمة منطقية، ثم يحول هذه القيمة المنطقية مرة أخرى إلى عدد صحيح.\n    # تتضمن العملية تعيين قيمة عدد صحيح إلى متغير منطقي ثم\n    # تعيين هذه القيمة المنطقية مرة أخرى إلى متغير عدد صحيح.\n    # الوسائط:\n    #     initial_int (int): القيمة العددية الصحيحة الأولية.\n    #\n    # المخرجات:\n    #     يطبع القيمة العددية الصحيحة التي تم الحصول عليها بعد التحويل من عدد صحيح إلى منطقي ثم العودة إلى عدد صحيح.\n    #\n    # أمثلة:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "sw": "int_to_bool_to_int() {\n    # Inabadilisha nambari nzima kuwa thamani ya boolean, kisha inabadilisha boolean hii kurudi kuwa nambari nzima.\n    # Mchakato unahusisha kupeana thamani ya nambari nzima kwa kigezo cha boolean na kisha\n    # kupeana thamani hii ya boolean kurudi kwa kigezo cha nambari nzima.\n    # Hoja:\n    #     initial_int (int): Thamani ya awali ya nambari nzima.\n    #\n    # Matokeo:\n    #     Inachapisha thamani ya nambari nzima iliyopatikana baada ya kubadilishwa kutoka nambari nzima hadi boolean na kurudi kwa nambari nzima.\n    #\n    # Mifano:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "tr": "int_to_bool_to_int() {\n    # Bir tam sayıyı boolean bir değere dönüştürür, ardından bu boolean değeri tekrar bir tam sayıya dönüştürür.\n    # Süreç, bir tam sayı değerini bir boolean değişkene atamayı ve ardından\n    # bu boolean değeri tekrar bir tam sayı değişkene atamayı içerir.\n    # Argümanlar:\n    #     initial_int (int): Başlangıçtaki tam sayı değeri.\n    #\n    # Çıktı:\n    #     Tam sayıdan boolean'a ve tekrar tam sayıya dönüşümden sonra elde edilen tam sayı değerini yazdırır.\n    #\n    # Örnekler:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "vi": "int_to_bool_to_int() {\n    # Chuyển đổi một số nguyên thành một giá trị boolean, sau đó chuyển đổi boolean này trở lại thành một số nguyên.\n    # Quá trình bao gồm việc gán một giá trị số nguyên cho một biến boolean và sau đó\n    # gán giá trị boolean này trở lại cho một biến số nguyên.\n    # Tham số:\n    #     initial_int (int): Giá trị số nguyên ban đầu.\n    #\n    # Đầu ra:\n    #     In ra giá trị số nguyên thu được sau khi chuyển đổi từ số nguyên sang boolean và trở lại số nguyên.\n    #\n    # Ví dụ:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1"
    },
    "prompt_bertscore": {
      "es": "0.9991284098880189",
      "arb": "0.9868576208388267",
      "sw": "0.9665258150360955",
      "tr": "0.9906129268226722",
      "vi": "0.9789135973797173"
    },
    "canonical_solution": "    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}",
    "instruction": {
      "en": "int_to_bool_to_int() {\n    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "int_to_bool_to_int() {\n    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "int_to_bool_to_int() {\n    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int_to_bool_to_int() {\n    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int_to_bool_to_int() {\n    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "int_to_bool_to_int() {\n    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9020958797094277",
      "sw": "0.9136909282023393",
      "tr": "0.8397906935686902",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_int_to_bool_to_int() {\n    local result\n\n    result=$(int_to_bool_to_int 0)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 1 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -5)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 2 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 10)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 4 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 5 failed: Expected 1, got $result\"; exit 1; }\n}\n\ntest_int_to_bool_to_int",
    "entry_point": "int_to_bool_to_int",
    "signature": "int_to_bool_to_int() {",
    "docstring": {
      "en": " Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "es": "Convierte un entero a un valor booleano, luego convierte este booleano de nuevo a un entero.  \nEl proceso implica asignar un valor entero a una variable booleana y luego  \nasignar este valor booleano de nuevo a una variable entera.  \nArgumentos:  \ninitial_int (int): El valor entero inicial.  \n\nSalida:  \nImprime el valor entero obtenido después de la conversión de entero a booleano y de nuevo a entero.  \n\nEjemplos:  \n>>> int_to_bool_to_int 0  \n0  \n>>> int_to_bool_to_int -5  \n1  ",
      "arb": "يقوم بتحويل عدد صحيح إلى قيمة منطقية، ثم يقوم بتحويل هذه القيمة المنطقية مرة أخرى إلى عدد صحيح. تتضمن العملية تعيين قيمة عدد صحيح إلى متغير منطقي ثم تعيين هذه القيمة المنطقية مرة أخرى إلى متغير عدد صحيح.\nيعيدالحجج:\ninitial_int (int): القيمة العددية الصحيحة الأولية.\n\nالناتج:\nيطبع القيمة العددية الصحيحة التي تم الحصول عليها بعد التحويل من عدد صحيح إلى قيمة منطقية ثم العودة إلى عدد صحيح.\n\nامثله:\n>>> int_to_bool_to_int 0\n0\n>>> int_to_bool_to_int -5\n1",
      "sw": "Inabadilisha nambari kamili kuwa thamani ya boolean, kisha inabadilisha boolean hii tena kuwa nambari kamili. \nMchakato unahusisha kutoa thamani ya nambari kamili kwa kigezo cha boolean na kisha \nkutoa thamani hii ya boolean tena kwa kigezo cha nambari kamili.\nHoja:\n initial_int (int): Thamani ya awali ya nambari kamili.\n\n Matokeo:\n Inachapisha thamani ya nambari kamili inayopatikana baada ya kubadilishwa kutoka nambari kamili hadi boolean na kurudi kwa nambari kamili.\n\n Mifano:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "tr": "Bir tam sayıyı boolean bir değere dönüştürür, ardından bu boolean değeri tekrar bir tam sayıya dönüştürür. \nBu süreç, bir tam sayı değerini bir boolean değişkene atamayı ve ardından bu boolean değerini tekrar bir tam sayı değişkene atamayı içerir.\nArgümanlar:\n initial_int (int): Başlangıçtaki tam sayı değeri.\n\n Çıktı:\n Tam sayıdan boolean'a ve tekrar tam sayıya dönüştürme işleminden sonra elde edilen tam sayı değerini yazdırır.\n\n Örnekler:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "vi": "Chuyển đổi một số nguyên thành giá trị boolean, sau đó chuyển đổi boolean này trở lại thành số nguyên. Quá trình này bao gồm việc gán một giá trị số nguyên cho một biến boolean và sau đó gán giá trị boolean này trở lại cho một biến số nguyên. \nTham số:\n initial_int (int): Giá trị số nguyên ban đầu.\n\nĐầu ra:\n In ra giá trị số nguyên thu được sau khi chuyển đổi từ số nguyên sang boolean và trở lại số nguyên.\n\nVí dụ:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1"
    },
    "docstring_bertscore": {
      "es": "0.9989554028261375",
      "arb": "0.978900487774569",
      "sw": "0.9675942478556822",
      "tr": "0.985658489228519",
      "vi": "0.985151783126499"
    }
  },
  {
    "task_id": "Shell/45",
    "prompt": {
      "en": "reverse_number() {\n    # Reverses a three-digit number.\n    # This function takes a three-digit number as input and prints its reverse.\n    # The output maintains leading zeros if present.\n    # Args:\n    #     number (int): A three-digit number to be reversed.\n    #\n    # Output:\n    #     Prints the reversed number, maintaining any leading zeros.\n    #\n    # Examples:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "es": "reverse_number() {\n    # Invierte un número de tres dígitos.\n    # Esta función toma un número de tres dígitos como entrada e imprime su inverso.\n    # La salida mantiene ceros a la izquierda si están presentes.\n    # Argumentos:\n    #     number (int): Un número de tres dígitos a invertir.\n    #\n    # Salida:\n    #     Imprime el número invertido, manteniendo cualquier cero a la izquierda.\n    #\n    # Ejemplos:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "arb": "reverse_number() {\n    # يعكس رقمًا مكونًا من ثلاثة أرقام.\n    # تأخذ هذه الدالة رقمًا مكونًا من ثلاثة أرقام كمدخل وتطبع عكسه.\n    # يحافظ الناتج على الأصفار البادئة إذا كانت موجودة.\n    # الوسائط:\n    #     number (int): رقم مكون من ثلاثة أرقام ليتم عكسه.\n    #\n    # الناتج:\n    #     يطبع الرقم المعكوس، مع الحفاظ على أي أصفار بادئة.\n    #\n    # أمثلة:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "sw": "reverse_number() {\n    # Inarudisha namba ya tarakimu tatu.\n    # Kazi hii inachukua namba ya tarakimu tatu kama ingizo na kuchapisha kinyume chake.\n    # Matokeo yanahifadhi sifuri za mwanzo ikiwa zipo.\n    # Hoja:\n    #     number (int): Namba ya tarakimu tatu inayotakiwa kurudishwa kinyume.\n    #\n    # Matokeo:\n    #     Inachapisha namba iliyogeuzwa, ikihifadhi sifuri za mwanzo ikiwa zipo.\n    #\n    # Mifano:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "tr": "reverse_number() {\n    # Üç basamaklı bir sayıyı ters çevirir.\n    # Bu fonksiyon, üç basamaklı bir sayıyı girdi olarak alır ve tersini yazdırır.\n    # Çıktı, varsa baştaki sıfırları korur.\n    # Argümanlar:\n    #     number (int): Ters çevrilecek üç basamaklı bir sayı.\n    #\n    # Çıktı:\n    #     Baştaki sıfırları koruyarak ters çevrilmiş sayıyı yazdırır.\n    #\n    # Örnekler:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "vi": "reverse_number() {\n    # Đảo ngược một số có ba chữ số.\n    # Hàm này nhận một số có ba chữ số làm đầu vào và in ra số đảo ngược của nó.\n    # Đầu ra giữ nguyên các số 0 đứng đầu nếu có.\n    # Tham số:\n    #     number (int): Một số có ba chữ số cần được đảo ngược.\n    #\n    # Đầu ra:\n    #     In ra số đã đảo ngược, giữ nguyên bất kỳ số 0 đứng đầu nào.\n    #\n    # Ví dụ:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040"
    },
    "prompt_bertscore": {
      "es": "0.9910689821775284",
      "arb": "0.985623927542219",
      "sw": "0.966973130654186",
      "tr": "0.9699243808556024",
      "vi": "0.9659259512853701"
    },
    "canonical_solution": "    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}",
    "instruction": {
      "en": "reverse_number() {\n    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "reverse_number() {\n    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "reverse_number() {\n    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "reverse_number() {\n    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "reverse_number() {\n    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "reverse_number() {\n    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.9148459638680573",
      "tr": "0.8484527658552407",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_reverse_number() {\n    local result\n\n    result=$(reverse_number 123)\n    [[ \"$result\" == \"321\" ]] || { echo \"Test 1 failed: Expected 321, got $result\"; exit 1; }\n\n    result=$(reverse_number 040)\n    [[ \"$result\" == \"040\" ]] || { echo \"Test 2 failed: Expected 040, got $result\"; exit 1; }\n\n    result=$(reverse_number 500)\n    [[ \"$result\" == \"005\" ]] || { echo \"Test 3 failed: Expected 005, got $result\"; exit 1; }\n\n    result=$(reverse_number 999)\n    [[ \"$result\" == \"999\" ]] || { echo \"Test 4 failed: Expected 999, got $result\"; exit 1; }\n\n    result=$(reverse_number 100)\n    [[ \"$result\" == \"001\" ]] || { echo \"Test 5 failed: Expected 001, got $result\"; exit 1; }\n}\n\ntest_reverse_number",
    "entry_point": "reverse_number",
    "signature": "reverse_number() {",
    "docstring": {
      "en": " Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "es": "Invierte un número de tres dígitos.  \nEsta función toma un número de tres dígitos como entrada e imprime su inverso.  \nLa salida mantiene los ceros a la izquierda si están presentes.  \nArgumentos:  \nnumber (int): Un número de tres dígitos para ser invertido.\n\nSalida:  \nImprime el número invertido, manteniendo cualquier cero a la izquierda.\n\nEjemplos:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040",
      "arb": "يعكس رقمًا مكونًا من ثلاثة أرقام.\nتأخذ هذه الدالة رقمًا مكونًا من ثلاثة أرقام كمدخل وتطبع عكسه.\nيحافظ الإخراج على الأصفار البادئة إذا كانت موجودة.\nيعيدالحجج:\nnumber (int): رقم مكون من ثلاثة أرقام ليتم عكسه.\n\nالناتج:\nيطبع الرقم المعكوس، مع الحفاظ على أي أصفار بادئة.\n\nامثله:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "sw": "Rejesha nambari ya tarakimu tatu.\nKazi hii inachukua nambari ya tarakimu tatu kama ingizo na kuchapisha mgeuko wake.\nMatokeo yanahifadhi sifuri zinazoongoza ikiwa zipo.\nHoja:\n number (int): Nambari ya tarakimu tatu inayopaswa kurejeshwa.\n\n Matokeo:\n Inachapisha nambari iliyorejeshwa, ikihifadhi sifuri zozote zinazoongoza.\n\n Mifano:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "tr": "Üç basamaklı bir sayıyı tersine çevirir.\nBu fonksiyon, giriş olarak üç basamaklı bir sayı alır ve tersini yazdırır.\nÇıktı, varsa baştaki sıfırları korur.\nArgümanlar:\n    number (int): Tersine çevrilecek üç basamaklı bir sayı.\n\nÇıktı:\n    Varsa baştaki sıfırları koruyarak tersine çevrilmiş sayıyı yazdırır.\n\nÖrnekler:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "vi": "Đảo ngược một số có ba chữ số.  \nHàm này nhận một số có ba chữ số làm đầu vào và in ra số đảo ngược của nó.  \nKết quả đầu ra giữ nguyên các số 0 ở đầu nếu có.  \nTham số:  \nnumber (int): Một số có ba chữ số cần được đảo ngược.\n\nĐầu ra:  \nIn ra số đã đảo ngược, duy trì bất kỳ số 0 ở đầu nào.\n\nVí dụ:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  "
    },
    "docstring_bertscore": {
      "es": "0.9798527218212503",
      "arb": "0.969608757180138",
      "sw": "0.9626924473125031",
      "tr": "0.9680286524990054",
      "vi": "0.9482959159254755"
    }
  },
  {
    "task_id": "Shell/46",
    "prompt": {
      "en": "calculate_nth_term() {\n    # Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n    # The difference between any two consecutive terms is constant.\n    # Args:\n    #     a1 (int): The first term of the arithmetic sequence.\n    #     a2 (int): The second term of the arithmetic sequence.\n    #     n (int): The term number to calculate.\n    #\n    # Output:\n    #     Prints the value of the nth term in the arithmetic sequence.\n    #\n    # Examples:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "es": "calculate_nth_term() {\n    # Calcula el enésimo término de una secuencia aritmética dada los dos primeros términos a1 y a2.\n    # La diferencia entre dos términos consecutivos es constante.\n    # Argumentos:\n    #     a1 (int): El primer término de la secuencia aritmética.\n    #     a2 (int): El segundo término de la secuencia aritmética.\n    #     n (int): El número del término a calcular.\n    #\n    # Salida:\n    #     Imprime el valor del enésimo término en la secuencia aritmética.\n    #\n    # Ejemplos:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "arb": "calculate_nth_term() {\n    # يحسب الحد النوني لمتتالية حسابية معطاة الحدين الأولين a1 و a2.\n    # الفرق بين أي حدين متتاليين ثابت.\n    # الوسائط:\n    #     a1 (int): الحد الأول من المتتالية الحسابية.\n    #     a2 (int): الحد الثاني من المتتالية الحسابية.\n    #     n (int): رقم الحد المراد حسابه.\n    #\n    # المخرجات:\n    #     يطبع قيمة الحد النوني في المتتالية الحسابية.\n    #\n    # أمثلة:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "sw": "calculate_nth_term() {\n    # Inahesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza a1 na a2.\n    # Tofauti kati ya maneno mawili mfululizo ni thabiti.\n    # Hoja:\n    #     a1 (int): Neno la kwanza la mlolongo wa hesabu.\n    #     a2 (int): Neno la pili la mlolongo wa hesabu.\n    #     n (int): Nambari ya neno la kuhesabu.\n    #\n    # Matokeo:\n    #     Inachapisha thamani ya neno la nth katika mlolongo wa hesabu.\n    #\n    # Mifano:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "tr": "calculate_nth_term() {\n    # İlk iki terimi a1 ve a2 verilen bir aritmetik dizinin n'inci terimini hesaplar.\n    # Ardışık iki terim arasındaki fark sabittir.\n    # Argümanlar:\n    #     a1 (int): Aritmetik dizinin ilk terimi.\n    #     a2 (int): Aritmetik dizinin ikinci terimi.\n    #     n (int): Hesaplanacak terim numarası.\n    #\n    # Çıktı:\n    #     Aritmetik dizideki n'inci terimin değerini yazdırır.\n    #\n    # Örnekler:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "vi": "calculate_nth_term() {\n    # Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên a1 và a2.\n    # Hiệu số giữa hai số hạng liên tiếp bất kỳ là không đổi.\n    # Tham số:\n    #     a1 (int): Số hạng đầu tiên của dãy số học.\n    #     a2 (int): Số hạng thứ hai của dãy số học.\n    #     n (int): Số thứ tự của số hạng cần tính.\n    #\n    # Đầu ra:\n    #     In ra giá trị của số hạng thứ n trong dãy số học.\n    #\n    # Ví dụ:\n    # >>> calculate_nth_term 1 3 5\n    # 9"
    },
    "prompt_bertscore": {
      "es": "0.9808335586428005",
      "arb": "0.9833577535249919",
      "sw": "0.9808335586428005",
      "tr": "0.981667408982385",
      "vi": "0.9703421005469188"
    },
    "canonical_solution": "    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}",
    "instruction": {
      "en": "calculate_nth_term() {\n    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_nth_term() {\n    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_nth_term() {\n    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "calculate_nth_term() {\n    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_nth_term() {\n    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "calculate_nth_term() {\n    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8890881719465961",
      "sw": "0.8717966027559849",
      "tr": "0.8669116857951938",
      "vi": "0.9388570002186977"
    },
    "level": "",
    "test": "test_calculate_nth_term() {\n    local result\n\n    result=$(calculate_nth_term 1 3 5)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 2 5 10)\n    [[ \"$result\" -eq 29 ]] || { echo \"Test 2 failed: Expected 20, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term -1 1 50)\n    [[ \"$result\" -eq 97 ]] || { echo \"Test 3 failed: Expected 97, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 100 -100 3)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 4 failed: Expected -300, got $result\"; exit 1; }\n\n}\n\ntest_calculate_nth_term",
    "entry_point": "calculate_nth_term",
    "signature": "calculate_nth_term() {",
    "docstring": {
      "en": " Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9",
      "es": "Calcula el enésimo término de una secuencia aritmética dada los dos primeros términos a1 y a2.  \nLa diferencia entre dos términos consecutivos es constante.  \nArgumentos:  \na1 (int): El primer término de la secuencia aritmética.  \na2 (int): El segundo término de la secuencia aritmética.  \nn (int): El número del término a calcular.  \n\nSalida:  \nImprime el valor del enésimo término en la secuencia aritmética.  \n\nEjemplos:  \n>>> calculate_nth_term 1 3 5  \n9",
      "arb": "يحسب الحد النوني لمتتالية حسابية معطاة الحدين الأولين a1 و a2. الفرق بين أي حدين متتاليين ثابت.\nيعيدالحجج:\n    a1 (int): الحد الأول من المتتالية الحسابية.\n    a2 (int): الحد الثاني من المتتالية الحسابية.\n    n (int): رقم الحد المراد حسابه.\n\nالناتج:\n    يطبع قيمة الحد النوني في المتتالية الحسابية.\n\nامثله:\n    >>> calculate_nth_term 1 3 5\n    9",
      "sw": "Hesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza a1 na a2. Tofauti kati ya maneno yoyote mawili mfululizo ni thabiti.\nHoja:\na1 (int): Neno la kwanza la mlolongo wa hesabu.\na2 (int): Neno la pili la mlolongo wa hesabu.\nn (int): Nambari ya neno la kuhesabu.\n\nMatokeo:\nChapisha thamani ya neno la nth katika mlolongo wa hesabu.\n\nMifano:\n>>> calculate_nth_term 1 3 5\n9",
      "tr": " nth terimini, ilk iki terim a1 ve a2 verilen bir aritmetik dizinin hesaplar.\n Herhangi iki ardışık terim arasındaki fark sabittir.\n Argümanlar:\n a1 (int): Aritmetik dizinin ilk terimi.\n a2 (int): Aritmetik dizinin ikinci terimi.\n n (int): Hesaplanacak terim numarası.\n\n Çıktı:\n Aritmetik dizideki nth terimin değerini yazdırır.\n\n Örnekler:\n >>> calculate_nth_term 1 3 5\n 9",
      "vi": "Tính toán số hạng thứ n của một cấp số cộng cho trước hai số hạng đầu tiên a1 và a2.  \nHiệu giữa hai số hạng liên tiếp bất kỳ là không đổi.  \nTham số:  \na1 (int): Số hạng đầu tiên của cấp số cộng.  \na2 (int): Số hạng thứ hai của cấp số cộng.  \nn (int): Số thứ tự của số hạng cần tính.  \n\nĐầu ra:  \nIn ra giá trị của số hạng thứ n trong cấp số cộng.  \n\nVí dụ:  \n>>> calculate_nth_term 1 3 5  \n9"
    },
    "docstring_bertscore": {
      "es": "0.9794058034639218",
      "arb": "0.9940261912903757",
      "sw": "0.9854481396550031",
      "tr": "0.9656148961086695",
      "vi": "0.9691387976986094"
    }
  },
  {
    "task_id": "Shell/47",
    "prompt": {
      "en": "multiply_numbers() {\n    # Calculates the product of two positive integers A and B.\n    # Given two positive integers, this function computes their product.\n    # It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n    # Args:\n    #     A (int): The first positive integer.\n    #     B (int): The second positive integer.\n    #\n    # Output:\n    #     Prints the product of A and B.\n    #\n    # Examples:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "es": "multiply_numbers() {\n    # Calcula el producto de dos enteros positivos A y B.\n    # Dado dos enteros positivos, esta función calcula su producto.\n    # Es importante considerar el rango del resultado para asegurar que no exceda los límites aritméticos del shell.\n    # Argumentos:\n    #     A (int): El primer entero positivo.\n    #     B (int): El segundo entero positivo.\n    #\n    # Salida:\n    #     Imprime el producto de A y B.\n    #\n    # Ejemplos:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "arb": "multiply_numbers() {\n    # يحسب حاصل ضرب عددين صحيحين موجبين A و B.\n    # بالنظر إلى عددين صحيحين موجبين، تقوم هذه الدالة بحساب حاصل ضربهما.\n    # من المهم مراعاة نطاق النتيجة لضمان عدم تجاوزها حدود الحساب في الشيل.\n    # الوسائط:\n    #     A (int): العدد الصحيح الموجب الأول.\n    #     B (int): العدد الصحيح الموجب الثاني.\n    #\n    # المخرجات:\n    #     يطبع حاصل ضرب A و B.\n    #\n    # أمثلة:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "sw": "multiply_numbers() {\n    # Inahesabu bidhaa ya nambari mbili nzima chanya A na B.\n    # Ukipewa nambari mbili nzima chanya, kazi hii inahesabu bidhaa yao.\n    # Ni muhimu kuzingatia upeo wa matokeo ili kuhakikisha kwamba hayazidi mipaka ya hesabu ya shell.\n    # Hoja:\n    #     A (int): Nambari ya kwanza nzima chanya.\n    #     B (int): Nambari ya pili nzima chanya.\n    #\n    # Matokeo:\n    #     Inachapisha bidhaa ya A na B.\n    #\n    # Mifano:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "tr": "multiply_numbers() {\n    # İki pozitif tam sayının A ve B çarpımını hesaplar.\n    # İki pozitif tam sayı verildiğinde, bu fonksiyon onların çarpımını hesaplar.\n    # Sonucun shell aritmetik sınırlarını aşmadığından emin olmak için aralığı dikkate almak önemlidir.\n    # Argümanlar:\n    #     A (int): İlk pozitif tam sayı.\n    #     B (int): İkinci pozitif tam sayı.\n    #\n    # Çıktı:\n    #     A ve B'nin çarpımını yazdırır.\n    #\n    # Örnekler:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "vi": "multiply_numbers() {\n    # Tính tích của hai số nguyên dương A và B.\n    # Cho hai số nguyên dương, hàm này tính toán tích của chúng.\n    # Điều quan trọng là xem xét phạm vi của kết quả để đảm bảo rằng nó không vượt quá giới hạn số học của shell.\n    # Đối số:\n    #     A (int): Số nguyên dương thứ nhất.\n    #     B (int): Số nguyên dương thứ hai.\n    #\n    # Đầu ra:\n    #     In ra tích của A và B.\n    #\n    # Ví dụ:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088"
    },
    "prompt_bertscore": {
      "es": "0.9762716146815723",
      "arb": "0.9780189661435361",
      "sw": "0.9824647113318591",
      "tr": "0.9715896979701989",
      "vi": "0.971966301172641"
    },
    "canonical_solution": "    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}",
    "instruction": {
      "en": "multiply_numbers() {\n    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "multiply_numbers() {\n    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español usando un máximo de 500 caracteres.",
      "arb": "multiply_numbers() {\n    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "multiply_numbers() {\n    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "multiply_numbers() {\n    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "multiply_numbers() {\n    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.9274301916585226",
      "sw": "0.9429899025568905",
      "tr": "0.8283732206364238",
      "vi": "0.9147003677987586"
    },
    "level": "",
    "test": "test_multiply_numbers() {\n    local result\n\n    result=$(multiply_numbers 5 10)\n    [[ \"$result\" -eq 50 ]] || { echo \"Test 1 failed: Expected 50, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 123 456)\n    [[ \"$result\" -eq 56088 ]] || { echo \"Test 2 failed: Expected 56088, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 1 50000)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 3 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 250 200)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 4 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 500 100)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 5 failed: Expected 50000, got $result\"; exit 1; }\n}\n\ntest_multiply_numbers",
    "entry_point": "multiply_numbers",
    "signature": "multiply_numbers() {",
    "docstring": {
      "en": " Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "es": "Calcula el producto de dos enteros positivos A y B.  \nDado dos enteros positivos, esta función calcula su producto.  \nEs importante considerar el rango del resultado para asegurar que no exceda los límites de la aritmética de shell.  \nArgumentos:  \nA (int): El primer entero positivo.  \nB (int): El segundo entero positivo.  \n\nSalida:  \nImprime el producto de A y B.  \n\nEjemplos:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "arb": "يحسب حاصل ضرب عددين صحيحين موجبين A و B.  \nبالنظر إلى عددين صحيحين موجبين، تقوم هذه الدالة بحساب حاصل ضربهما.  \nمن المهم مراعاة نطاق النتيجة لضمان عدم تجاوزها حدود الحساب في الشيل.  \nالمعطيات:  \nA (int): العدد الصحيح الموجب الأول.  \nB (int): العدد الصحيح الموجب الثاني.  \n\nالمخرجات:  \nيطبع حاصل ضرب A و B.  \n\nأمثلة:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "sw": "Hesabu bidhaa ya nambari mbili nzima chanya A na B.  \nKwa kuzingatia nambari mbili nzima chanya, kazi hii inahesabu bidhaa yao.  \nNi muhimu kuzingatia upeo wa matokeo ili kuhakikisha kuwa hayazidi mipaka ya hesabu ya shell.  \nHoja:  \nA (int): Nambari ya kwanza nzima chanya.  \nB (int): Nambari ya pili nzima chanya.  \n\nMatokeo:  \nInachapisha bidhaa ya A na B.  \n\nMifano:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "tr": "İki pozitif tam sayı A ve B'nin çarpımını hesaplar.\n İki pozitif tam sayı verildiğinde, bu fonksiyon onların çarpımını hesaplar.\n Sonucun kabuk aritmetik sınırlarını aşmadığından emin olmak için aralığı dikkate almak önemlidir.\n Argümanlar:\n A (int): Birinci pozitif tam sayı.\n B (int): İkinci pozitif tam sayı.\n\n Çıktı:\n A ve B'nin çarpımını yazdırır.\n\n Örnekler:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "vi": "Tính tích của hai số nguyên dương A và B.  \nCho hai số nguyên dương, hàm này tính tích của chúng.  \nĐiều quan trọng là phải xem xét phạm vi của kết quả để đảm bảo rằng nó không vượt quá giới hạn số học của shell.  \nTham số:  \nA (int): Số nguyên dương thứ nhất.  \nB (int): Số nguyên dương thứ hai.  \n\nĐầu ra:  \nIn ra tích của A và B.  \n\nVí dụ:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  "
    },
    "docstring_bertscore": {
      "es": "0.983762562241541",
      "arb": "0.9602554511675861",
      "sw": "0.9707852449270076",
      "tr": "0.961883227140167",
      "vi": "0.9600393413130202"
    }
  },
  {
    "task_id": "Shell/48",
    "prompt": {
      "en": "calculate_power_of_two() {\n    # Calculates 2 to the power of n.\n    # Given a non-negative integer n, this function computes 2^n.\n    # It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n    # Args:\n    #     n (int): The exponent to raise 2 to. Must be a non-negative integer.\n    #\n    # Output:\n    #     Prints the value of 2 raised to the power of n.\n    #\n    # Examples:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "es": "calculate_power_of_two() {\n    # Calcula 2 elevado a la potencia de n.\n    # Dado un entero no negativo n, esta función calcula 2^n.\n    # Es importante asegurar que n esté dentro del rango válido para evitar desbordamiento aritmético en shell.\n    # Argumentos:\n    #     n (int): El exponente al que se eleva 2. Debe ser un entero no negativo.\n    #\n    # Salida:\n    #     Imprime el valor de 2 elevado a la potencia de n.\n    #\n    # Ejemplos:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "arb": "calculate_power_of_two() {\n    # يحسب 2 مرفوعًا إلى أس n.\n    # بالنظر إلى عدد صحيح غير سالب n، تقوم هذه الدالة بحساب 2^n.\n    # من المهم التأكد من أن n ضمن النطاق الصحيح لتجنب تجاوز الحساب في الشل.\n    # الوسائط:\n    #     n (int): الأس الذي سيتم رفع 2 إليه. يجب أن يكون عددًا صحيحًا غير سالب.\n    #\n    # المخرجات:\n    #     يطبع قيمة 2 مرفوعة إلى الأس n.\n    #\n    # أمثلة:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "sw": "calculate_power_of_two() {\n    # Inahesabu 2 kwa nguvu ya n.\n    # Ukipewa nambari isiyo hasi n, kazi hii inahesabu 2^n.\n    # Ni muhimu kuhakikisha kuwa n iko ndani ya safu halali ili kuepuka kufurika kwa hesabu kwenye shell.\n    # Hoja:\n    #     n (int): Kielelezo cha kuinua 2. Lazima iwe nambari isiyo hasi.\n    #\n    # Matokeo:\n    #     Inachapisha thamani ya 2 iliyoinuliwa kwa nguvu ya n.\n    #\n    # Mifano:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "tr": "calculate_power_of_two() {\n    # n'ninci kuvveti olarak 2'yi hesaplar.\n    # Negatif olmayan bir tamsayı n verildiğinde, bu fonksiyon 2^n'i hesaplar.\n    # Aritmetik taşmayı önlemek için n'nin geçerli aralıkta olduğundan emin olmak önemlidir.\n    # Argümanlar:\n    #     n (int): 2'nin üssü olarak yükseltileceği sayı. Negatif olmayan bir tamsayı olmalıdır.\n    #\n    # Çıktı:\n    #     2'nin n'inci kuvvetine yükseltilmiş değerini yazdırır.\n    #\n    # Örnekler:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "vi": "calculate_power_of_two() {\n    # Tính 2 lũy thừa n.\n    # Cho một số nguyên không âm n, hàm này tính 2^n.\n    # Điều quan trọng là đảm bảo rằng n nằm trong phạm vi hợp lệ để tránh tràn số học trong shell.\n    # Tham số:\n    #     n (int): Số mũ để nâng 2 lên. Phải là một số nguyên không âm.\n    #\n    # Đầu ra:\n    #     In ra giá trị của 2 lũy thừa n.\n    #\n    # Ví dụ:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024"
    },
    "prompt_bertscore": {
      "es": "0.9795013446771995",
      "arb": "0.95980515609378",
      "sw": "0.9701806140471374",
      "tr": "0.9468530648376381",
      "vi": "0.9709671903560355"
    },
    "canonical_solution": "    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}",
    "instruction": {
      "en": "calculate_power_of_two() {\n    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "calculate_power_of_two() {\n    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "calculate_power_of_two() {\n    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Shell باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "calculate_power_of_two() {\n    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "calculate_power_of_two() {\n    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "calculate_power_of_two() {\n    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8839829738932373",
      "sw": "0.9429899025568905",
      "tr": "0.8552834660286495",
      "vi": "0.9182000364822124"
    },
    "level": "",
    "test": "test_calculate_power_of_two() {\n    local result\n\n    result=$(calculate_power_of_two 5)\n    [[ \"$result\" -eq 32 ]] || { echo \"Test 1 failed: Expected 32, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 10)\n    [[ \"$result\" -eq 1024 ]] || { echo \"Test 2 failed: Expected 1024, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 0)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 15)\n    [[ \"$result\" -eq 32768 ]] || { echo \"Test 4 failed: Expected 32768, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 20)\n    [[ \"$result\" -eq 1048576 ]] || { echo \"Test 5 failed: Expected 1048576, got $result\"; exit 1; }\n}\n\ntest_calculate_power_of_two",
    "entry_point": "calculate_power_of_two",
    "signature": "calculate_power_of_two() {",
    "docstring": {
      "en": " Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "es": "Calcula 2 elevado a la potencia de n.\nDado un entero no negativo n, esta función calcula 2^n.\nEs importante asegurar que n esté dentro del rango válido para evitar desbordamiento aritmético en shell.\nArgumentos:\nn (int): El exponente al que se eleva 2. Debe ser un entero no negativo.\n\nSalida:\nImprime el valor de 2 elevado a la potencia de n.\n\nEjemplos:\n>>> calculate_power_of_two 5\n32\n>>> calculate_power_of_two 10\n1024",
      "arb": "يحسب 2 مرفوعًا للقوة n.  \nبالنظر إلى عدد صحيح غير سالب n، تقوم هذه الدالة بحساب 2^n.  \nمن المهم التأكد من أن n ضمن النطاق الصحيح لتجنب تجاوز الحسابات في الشل.  \nالمعطيات:  \nn (int): الأس الذي سيتم رفع 2 إليه. يجب أن يكون عددًا صحيحًا غير سالب.\n\nالمخرجات:  \nيطبع قيمة 2 مرفوعة للقوة n.\n\nأمثلة:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "sw": "Inahesabu 2 kwa nguvu ya n.  \nKwa kupewa nambari isiyo hasi n, kazi hii inahesabu 2^n.  \nNi muhimu kuhakikisha kuwa n iko ndani ya kiwango halali ili kuepuka kufurika kwa hesabu kwenye ganda.  \nHoja:  \nn (int): Kipimo cha kuongeza 2. Lazima iwe nambari isiyo hasi.  \n\nMatokeo:  \nInachapisha thamani ya 2 iliyoinuliwa kwa nguvu ya n.  \n\nMifano:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "tr": " 2'nin n'inci kuvvetini hesaplar.\n Negatif olmayan bir tamsayı n verildiğinde, bu fonksiyon 2^n'i hesaplar.\n n'in geçerli aralıkta olduğundan emin olmak önemlidir, aksi takdirde shell'de aritmetik taşma meydana gelebilir.\n Argümanlar:\n n (int): 2'nin üssü olarak yükseltileceği üs. Negatif olmayan bir tamsayı olmalıdır.\n\n Çıktı:\n 2'nin n'inci kuvvetine yükseltilmiş değerini yazdırır.\n\n Örnekler:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "vi": "Tính toán 2 lũy thừa n.  \nCho một số nguyên không âm n, hàm này tính 2^n.  \nĐiều quan trọng là đảm bảo rằng n nằm trong phạm vi hợp lệ để tránh tràn số học trong shell.  \nTham số:  \nn (int): Số mũ để nâng 2 lên. Phải là một số nguyên không âm.  \n\nĐầu ra:  \nIn ra giá trị của 2 lũy thừa n.  \n\nVí dụ:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  "
    },
    "docstring_bertscore": {
      "es": "0.980170133170144",
      "arb": "0.9042315535663149",
      "sw": "0.9570358513213916",
      "tr": "0.9348099062051117",
      "vi": "0.9757521962351661"
    }
  },
  {
    "task_id": "Shell/49",
    "prompt": {
      "en": "check_sign() {\n    # Check the sign of a given integer.\n    # If the integer is greater than zero, return \"positive\".\n    # If the integer is zero, return \"zero\".\n    # If the integer is less than zero, return \"negative\".\n    #\n    # Example:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "es": "check_sign() {\n    # Verificar el signo de un entero dado.\n    # Si el entero es mayor que cero, devolver \"positive\".\n    # Si el entero es cero, devolver \"zero\".\n    # Si el entero es menor que cero, devolver \"negative\".\n    #\n    # Ejemplo:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "arb": "check_sign() {\n    # تحقق من إشارة عدد صحيح معين.\n    # إذا كان العدد الصحيح أكبر من الصفر، أعد \"positive\".\n    # إذا كان العدد الصحيح يساوي الصفر، أعد \"zero\".\n    # إذا كان العدد الصحيح أقل من الصفر، أعد \"negative\".\n    #\n    # مثال:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "sw": "check_sign() {\n    # Angalia ishara ya nambari kamili iliyotolewa.\n    # Ikiwa nambari kamili ni kubwa kuliko sifuri, rudisha \"positive\".\n    # Ikiwa nambari kamili ni sifuri, rudisha \"zero\".\n    # Ikiwa nambari kamili ni ndogo kuliko sifuri, rudisha \"negative\".\n    #\n    # Mfano:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "tr": "check_sign() {\n    # Verilen bir tam sayının işaretini kontrol et.\n    # Eğer tam sayı sıfırdan büyükse, \"positive\" döndür.\n    # Eğer tam sayı sıfırsa, \"zero\" döndür.\n    # Eğer tam sayı sıfırdan küçükse, \"negative\" döndür.\n    #\n    # Örnek:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "vi": "check_sign() {\n    # Kiểm tra dấu của một số nguyên đã cho.\n    # Nếu số nguyên lớn hơn không, trả về \"positive\".\n    # Nếu số nguyên bằng không, trả về \"zero\".\n    # Nếu số nguyên nhỏ hơn không, trả về \"negative\".\n    #\n    # Ví dụ:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9882567732428363",
      "sw": "0.9970002839856111",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}",
    "instruction": {
      "en": "check_sign() {\n    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "check_sign() {\n    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "check_sign() {\n    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "check_sign() {\n    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "check_sign() {\n    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}\n\nAşağıdaki Shell kodunun işlevini en fazla 500 karakter kullanarak Türkçe olarak açıklayan kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "check_sign() {\n    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Shell bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8702536419561059",
      "sw": "0.9429899025568905",
      "tr": "0.8631097016718051",
      "vi": "0.9275384452161866"
    },
    "level": "",
    "test": "\ntest_check_sign() {\n    [[ $(check_sign 95) == \"positive\" ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(check_sign 0) == \"zero\" ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(check_sign -95) == \"negative\" ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(check_sign 1000000000) == \"positive\" ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(check_sign -1000000000) == \"negative\" ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(check_sign 1) == \"positive\" ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(check_sign -1) == \"negative\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_check_sign",
    "entry_point": "check_sign",
    "signature": "check_sign() {",
    "docstring": {
      "en": " Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "es": "Verifica el signo de un entero dado.  \nSi el entero es mayor que cero, devuelve \"positive\".  \nSi el entero es cero, devuelve \"zero\".  \nSi el entero es menor que cero, devuelve \"negative\".  \n\nEjemplo:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "arb": " تحقق من إشارة عدد صحيح معين.\n إذا كان العدد الصحيح أكبر من الصفر، أعد \"positive\".\n إذا كان العدد الصحيح يساوي الصفر، أعد \"zero\".\n إذا كان العدد الصحيح أقل من الصفر، أعد \"negative\".\n\n مثال:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "sw": " Angalia ishara ya nambari nzima iliyotolewa.\n Ikiwa nambari nzima ni kubwa kuliko sifuri, rudisha \"positive\".\n Ikiwa nambari nzima ni sifuri, rudisha \"zero\".\n Ikiwa nambari nzima ni ndogo kuliko sifuri, rudisha \"negative\".\n\n Mfano:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "tr": " Belirtilen bir tam sayının işaretini kontrol edin.\n Eğer tam sayı sıfırdan büyükse, \"positive\" döndürün.\n Eğer tam sayı sıfırsa, \"zero\" döndürün.\n Eğer tam sayı sıfırdan küçükse, \"negative\" döndürün.\n\n Örnek:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "vi": "Kiểm tra dấu của một số nguyên cho trước.  \nNếu số nguyên lớn hơn không, trả về \"positive\".  \nNếu số nguyên bằng không, trả về \"zero\".  \nNếu số nguyên nhỏ hơn không, trả về \"negative\".  \n\nVí dụ:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9870782991921564",
      "sw": "0.9964069750374599",
      "tr": "1",
      "vi": "0.9870782991921564"
    }
  },
  {
    "task_id": "Shell/50",
    "prompt": {
      "en": "absolute_value() {\n    # Calculate the absolute value of a given integer.\n    # If the integer is positive, return the number as is.\n    # If the integer is negative, return the number multiplied by -1.\n    #\n    # Example:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "es": "absolute_value() {\n    # Calcular el valor absoluto de un entero dado.\n    # Si el entero es positivo, devolver el número tal cual.\n    # Si el entero es negativo, devolver el número multiplicado por -1.\n    #\n    # Ejemplo:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "arb": "absolute_value() {\n    # حساب القيمة المطلقة لعدد صحيح معطى.\n    # إذا كان العدد الصحيح موجبًا، أعد الرقم كما هو.\n    # إذا كان العدد الصحيح سالبًا، أعد الرقم مضروبًا في -1.\n    #\n    # مثال:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "sw": "absolute_value() {\n    # Hesabu thamani kamili ya nambari nzima iliyotolewa.\n    # Ikiwa nambari ni chanya, rudisha nambari kama ilivyo.\n    # Ikiwa nambari ni hasi, rudisha nambari iliyozidishwa kwa -1.\n    #\n    # Mfano:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "tr": "absolute_value() {\n    # Verilen bir tam sayının mutlak değerini hesapla.\n    # Eğer tam sayı pozitifse, sayıyı olduğu gibi döndür.\n    # Eğer tam sayı negatifse, sayıyı -1 ile çarparak döndür.\n    #\n    # Örnek:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "vi": "absolute_value() {\n    # Tính giá trị tuyệt đối của một số nguyên cho trước.\n    # Nếu số nguyên là dương, trả về số đó như là.\n    # Nếu số nguyên là âm, trả về số đó nhân với -1.\n    #\n    # Ví dụ:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.992666764962573",
      "sw": "0.9817430871575593",
      "tr": "1",
      "vi": "0.9818410119354095"
    },
    "canonical_solution": "    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}",
    "instruction": {
      "en": "absolute_value() {\n    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}\n\nProvide a concise natural language description (docstring) of the Shell code in English using at most 500 characters.",
      "es": "absolute_value() {\n    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Shell en español utilizando como máximo 500 caracteres.",
      "arb": "absolute_value() {\n    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Shell باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "absolute_value() {\n    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Shell kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "absolute_value() {\n    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}\n\nAşağıdaki Shell kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "absolute_value() {\n    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Shell bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9685307901022616",
      "arb": "0.8990808691556992",
      "sw": "0.9429899025568905",
      "tr": "0.8547378283719466",
      "vi": "0.9147003677987586"
    },
    "level": "",
    "test": "test_absolute_value() {\n    [[ $(absolute_value 95) -eq 95 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(absolute_value -95) -eq 95 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(absolute_value 0) -eq 0 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(absolute_value 10000) -eq 10000 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(absolute_value -10000) -eq 10000 ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(absolute_value 1) -eq 1 ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(absolute_value -1) -eq 1 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_absolute_value",
    "entry_point": "absolute_value",
    "signature": "absolute_value() {",
    "docstring": {
      "en": " Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "es": "Calcular el valor absoluto de un entero dado.  \nSi el entero es positivo, devuelve el número tal cual.  \nSi el entero es negativo, devuelve el número multiplicado por -1.  \n\nEjemplo:  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0  ",
      "arb": "احسب القيمة المطلقة لعدد صحيح معطى.  \nإذا كان العدد الصحيح موجبًا، أعد الرقم كما هو.  \nإذا كان العدد الصحيح سالبًا، أعد الرقم مضروبًا في -1.\n\nمثال:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "sw": "Hesabu thamani kamili ya nambari kamili iliyotolewa.  \nIkiwa nambari kamili ni chanya, rudisha nambari kama ilivyo.  \nIkiwa nambari kamili ni hasi, rudisha nambari iliyozidishwa na -1.  \n\nMfano:  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0  ",
      "tr": " Verilen bir tamsayının mutlak değerini hesaplayın.\n Eğer tamsayı pozitifse, sayıyı olduğu gibi döndürün.\n Eğer tamsayı negatifse, sayıyı -1 ile çarparak döndürün.\n\n Örnek:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "vi": "Tính giá trị tuyệt đối của một số nguyên cho trước.  \nNếu số nguyên là dương, trả về số đó như là.  \nNếu số nguyên là âm, trả về số đó nhân với -1.\n\nVí dụ:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9885586914220094",
      "sw": "0.9944707260831318",
      "tr": "1",
      "vi": "0.9751932503429338"
    }
  }
]