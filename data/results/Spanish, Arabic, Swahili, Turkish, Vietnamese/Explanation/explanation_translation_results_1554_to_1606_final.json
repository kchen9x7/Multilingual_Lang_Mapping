[
  {
    "task_id": "Rust/1",
    "prompt": {
      "en": "\n /*\n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n ",
      "es": " /*\n  Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "arb": " /*\n  تحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "sw": " /*\n  Angalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote zilizo karibu zaidi kwa kila mmoja kuliko\n  kizingiti kilichopewa.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "tr": " /*\n  Verilen sayı listesindeki herhangi iki sayının \n  verilen eşikten daha yakın olup olmadığını kontrol edin.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "vi": " /*\n  Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n  ngưỡng đã cho hay không.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{"
    },
    "prompt_bertscore": {
      "es": "0.9826371225025973",
      "arb": "0.9796838859973706",
      "sw": "0.9700010521826818",
      "tr": "0.9741853997895629",
      "vi": "0.9850562419132213"
    },
    "canonical_solution": "\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n ",
    "instruction": {
      "en": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9431116629804649",
      "tr": "0.9313245389090926",
      "vi": "0.9446800484691164"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_has_close_elements() {\n  assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n  }\n \n }\n ",
    "entry_point": "has_close_elements",
    "signature": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.",
      "es": "Verifique si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.",
      "arb": "تحقق مما إذا كانت هناك أي عددين في قائمة الأرقام المعطاة أقرب إلى بعضهما البعض من العتبة المحددة.",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya nambari, kuna nambari zozote mbili zilizo karibu zaidi kuliko kizingiti kilichotolewa.",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9332872057040983",
      "arb": "0.8951442136339688",
      "sw": "0.8950061655191495",
      "tr": "0.8477976828585876",
      "vi": "0.8560142272004768"
    }
  },
  {
    "task_id": "Rust/2",
    "prompt": {
      "en": "\n /*\n  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n ",
      "es": " /*\n  La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n  separar esos grupos en cadenas separadas y devolver la lista de estas.\n  Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n  Ignorar cualquier espacio en la cadena de entrada.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "arb": " /*\n  الإدخال إلى هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n  فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها.\n  المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض.\n  تجاهل أي مسافات في سلسلة الإدخال.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "sw": " /*\n  Ingizo kwa kazi hii ni kamba inayo na vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\n  kutenganisha vikundi hivyo katika kamba tofauti na kurudisha orodha ya hizo.\n  Vikundi vilivyotenganishwa vimebalansiwa (kila mabano ya kufungua yamefungwa ipasavyo) na havijapachikwa ndani ya kila kimoja\n  Puuza nafasi zozote katika kamba ya ingizo.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "tr": " /*\n  Bu fonksiyona giriş, birden fazla iç içe geçmiş parantez grubunu içeren bir dizedir. Amacınız,\n  bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir.\n  Ayrı gruplar dengelidir (her açık parantez uygun şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n  Giriş dizesindeki boşlukları yok sayın.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "vi": " /*\n  Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n  tách những nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n  Các nhóm riêng biệt là cân bằng (mỗi dấu ngoặc mở được đóng đúng cách) và không lồng vào nhau.\n  Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{"
    },
    "prompt_bertscore": {
      "es": "0.9590908812435786",
      "arb": "0.9541569025786719",
      "sw": "0.9476821480480777",
      "tr": "0.9589411139362782",
      "vi": "0.9517798928088275"
    },
    "canonical_solution": "\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n ",
    "instruction": {
      "en": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9086584288684394",
      "sw": "0.9153697521828462",
      "tr": "0.9457959539497705",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_separate_paren_groups() {\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()()) ((())) () ((())()())\")),\n  vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"() (()) ((())) (((())))\")),\n  vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()(())((())))\")),\n  vec![\"(()(())((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n  vec![\"()\", \"(())\", \"(()())\"]\n  );\n  }\n \n }\n ",
    "entry_point": "separate_paren_groups",
    "signature": "fn separate_paren_groups(paren_string: String) -> Vec<String>{",
    "docstring": {
      "en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.",
      "es": "La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es separar esos grupos en cadenas separadas y devolver la lista de estos. Los grupos separados están equilibrados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí. Ignora cualquier espacio en la cadena de entrada.",
      "arb": "مدخل هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها. المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض. تجاهل أي مسافات في سلسلة المدخلات.",
      "sw": "Ingizo kwa kazi hii ni kamba inayojumuisha vikundi vingi vya mabano yaliyojipanga. Lengo lako ni\n  kutenganisha vikundi hivyo katika kamba tofauti na kurudisha orodha ya hizo.\n  Vikundi vilivyotenganishwa vina usawa (kila mabano ya kufungua yanafungwa ipasavyo) na havijajipanga ndani ya kila mmoja.\n  Puuza nafasi zozote katika kamba ya ingizo.",
      "tr": "Bu fonksiyona girdi, birden fazla iç içe geçmiş parantez grubunu içeren bir dizedir. Amacınız, bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir. Ayrı gruplar dengelidir (her açık parantez doğru şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir. Girdi dizesindeki boşlukları yoksayın.",
      "vi": "Đầu vào cho hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó. Các nhóm riêng biệt là cân bằng (mỗi dấu mở được đóng đúng cách) và không lồng vào nhau. Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào."
    },
    "docstring_bertscore": {
      "es": "0.9240973724951381",
      "arb": "0.8970325926664674",
      "sw": "0.8906696670403959",
      "tr": "0.8942152193418685",
      "vi": "0.8907662014055787"
    }
  },
  {
    "task_id": "Rust/3",
    "prompt": {
      "en": "\n /*\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n ",
      "es": " /*\n  Dado un número de punto flotante positivo, se puede descomponer en\n  una parte entera (el mayor entero menor que el número dado) y decimales\n  (parte sobrante siempre menor que 1).\n \n  Devuelve la parte decimal del número.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "arb": " /*\n  بالنظر إلى رقم عشري موجب، يمكن تحليله إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وأجزاء عشرية\n  (الجزء المتبقي دائماً أصغر من 1).\n \n  أعد الجزء العشري من الرقم.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "sw": " /*\n  Kwa kuzingatia nambari chanya ya nukta kuelea, inaweza kugawanywa kuwa\n  sehemu ya integer (nambari kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali\n  (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n\n  Rudisha sehemu ya desimali ya nambari.\n\n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "tr": " /*\n  Pozitif bir kayan nokta sayısı verildiğinde, bu sayı bir tamsayı kısmına\n  (verilen sayıdan küçük en büyük tamsayı) ve ondalık kısma\n  (her zaman 1'den küçük olan kalan kısım) ayrılabilir.\n \n  Sayının ondalık kısmını döndür.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "vi": " /*\n  Cho một số thực dương, nó có thể được phân tách thành\n  phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n  (phần còn lại luôn nhỏ hơn 1).\n \n  Trả về phần thập phân của số.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n"
    },
    "prompt_bertscore": {
      "es": "0.9695894900331776",
      "arb": "0.9605071158603573",
      "sw": "0.9467525578648344",
      "tr": "0.9341025834182465",
      "vi": "0.9481666075474218"
    },
    "canonical_solution": "\n  return number % 1.0;\n }\n ",
    "instruction": {
      "en": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9034153813306425",
      "sw": "0.9099693893832697",
      "tr": "0.8732084675043809",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_truncate_number() {\n  assert_eq!(truncate_number(&3.5), 0.5);\n  let t1: f32 = 1.33 - 0.33;\n  assert!(truncate_number(&t1) < 0.000001);\n  let t2: f32 = 123.456 - 0.456;\n  assert!(truncate_number(&t2) < 0.000001);\n  }\n \n }\n ",
    "entry_point": "truncate_number",
    "signature": "fn truncate_number(number: &f32) -> f32{",
    "docstring": {
      "en": "Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.",
      "es": "Dado un número de punto flotante positivo, se puede descomponer en una parte entera (el entero más grande menor que el número dado) y decimales (la parte restante siempre menor que 1).\n\nDevuelve la parte decimal del número.",
      "arb": "بالنظر إلى رقم عشري موجب، يمكن تحليله إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وعشري (الجزء المتبقي دائماً أصغر من 1).\n\nإرجاع الجزء العشري من الرقم.",
      "sw": "Kwa kupewa namba chanya ya nukta, inaweza kugawanywa katika sehemu ya namba kamili (namba kamili kubwa zaidi iliyo ndogo kuliko namba iliyotolewa) na desimali (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n\nRudisha sehemu ya desimali ya namba.",
      "tr": "Verilen pozitif bir kayan nokta sayısı, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n\nSayının ondalık kısmını döndürün.",
      "vi": "Đưa ra một số thực dương, nó có thể được phân tách thành\n  phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n  (phần còn lại luôn nhỏ hơn 1).\n \n  Trả về phần thập phân của số đó."
    },
    "docstring_bertscore": {
      "es": "0.9449336994656979",
      "arb": "0.8955293579427954",
      "sw": "0.8725740420673554",
      "tr": "0.9150912723886353",
      "vi": "0.864658224122353"
    }
  },
  {
    "task_id": "Rust/4",
    "prompt": {
      "en": " /*\n  You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n ",
      "es": " /*\n  Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n  saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n  en ese momento la función debería devolver True. De lo contrario, debería devolver False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "arb": " /*\n  لديك قائمة بعمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي وقت ينخفض رصيد الحساب إلى ما دون الصفر، وفي هذه الحالة يجب أن تعيد الدالة True. خلاف ذلك، يجب أن تعيد False.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "sw": " /*\n  Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n  salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na\n  wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "tr": " /*\n  Sıfır bakiye ile başlayan bir banka hesabı üzerinde yapılan para yatırma ve çekme işlemlerinin bir listesi veriliyor. \n  Göreviniz, herhangi bir noktada hesap bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada \n  fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "vi": " /*\n  Bạn được cung cấp một danh sách các hoạt động gửi tiền và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện nếu tại bất kỳ thời điểm nào số dư của tài khoản giảm xuống dưới không, và tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{"
    },
    "prompt_bertscore": {
      "es": "0.9838372472648101",
      "arb": "0.9625794266256943",
      "sw": "0.9700534906032751",
      "tr": "0.9620554396805243",
      "vi": "0.9786059189194942"
    },
    "canonical_solution": "\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n ",
    "instruction": {
      "en": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9153697521828462",
      "tr": "0.8659743490270903",
      "vi": "0.9035627650733704"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_below_zero() {\n  assert_eq!(below_zero(vec![]), false);\n  assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);\n  assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n  assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n  }\n \n }\n ",
    "entry_point": "below_zero",
    "signature": "fn below_zero(operations:Vec<i32>) -> bool{",
    "docstring": {
      "en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.",
      "es": "Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese momento la función debería devolver True. De lo contrario, debería devolver False.",
      "arb": "أنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي اكتشاف ما إذا كان في أي لحظة ينخفض رصيد الحساب إلى ما دون الصفر، وفي هذه الحالة يجب أن تُرجع الدالة True. خلاف ذلك، يجب أن تُرجع False.",
      "sw": "Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudi True. Vinginevyo, inapaswa kurudi False.",
      "tr": "Verilen bir banka hesabı üzerinde yapılan para yatırma ve çekme işlemlerinin bir listesidir ve hesap sıfır bakiye ile başlar. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu durumda fonksiyon True döndürmelidir. Aksi takdirde, False döndürmelidir.",
      "vi": "Bạn được cung cấp một danh sách các giao dịch gửi tiền và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư tài khoản có giảm xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Nếu không, nó nên trả về False."
    },
    "docstring_bertscore": {
      "es": "0.9533512577531944",
      "arb": "0.931930162940868",
      "sw": "0.9308094903310691",
      "tr": "0.878139665343953",
      "vi": "0.9433972934683931"
    }
  },
  {
    "task_id": "Rust/5",
    "prompt": {
      "en": "\n /*\n  For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n ",
      "es": " /*\n  Para una lista dada de números de entrada, calcula la Desviación Absoluta Media\n  alrededor de la media de este conjunto de datos.\n  La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n  elemento y un punto central (la media en este caso):\n  MAD = promedio | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "arb": " /*\n  لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n  حول متوسط هذه المجموعة من البيانات.\n  الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل\n  عنصر ونقطة مركزية (المتوسط في هذه الحالة):\n  MAD = متوسط | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "sw": " /*\n  Kwa orodha fulani ya namba za pembejeo, hesabu Mkengeuko wa Kati wa Kawaida\n  kuzunguka wastani wa seti hii ya data.\n  Mkengeuko wa Kati wa Kawaida ni wastani wa tofauti kamili kati ya kila\n  kipengele na sehemu ya kati (wastani katika kesi hii):\n  MAD = wastani | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "tr": " /*\n  Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapma'yı hesaplayın.\n  Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n  MAD = ortalama | x - x_ortalama |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "vi": " /*\n  Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình\n  xung quanh trung bình của tập dữ liệu này.\n  Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi\n  phần tử và một điểm trung tâm (trung bình trong trường hợp này):\n  MAD = trung bình | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n "
    },
    "prompt_bertscore": {
      "es": "0.9719069106887116",
      "arb": "0.9512638510788988",
      "sw": "0.9604656021107211",
      "tr": "0.981120778173777",
      "vi": "0.9672927269372712"
    },
    "canonical_solution": "\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n ",
    "instruction": {
      "en": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9177737756845115",
      "sw": "0.9153697521828462",
      "tr": "0.8732084675043809",
      "vi": "0.9362652710069544"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_mean_absolute_deviation() {\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n  }\n \n }\n ",
    "entry_point": "mean_absolute_deviation",
    "signature": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
    "docstring": {
      "en": "For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |",
      "es": "Para una lista dada de números de entrada, calcular la Desviación Absoluta Media\nalrededor de la media de este conjunto de datos.\nLa Desviación Absoluta Media es la diferencia absoluta promedio entre cada\nelemento y un punto central (la media en este caso):\nMAD = promedio | x - x_mean |",
      "arb": "لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة حول متوسط هذه المجموعة من البيانات. الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة):  \nMAD = متوسط | x - x_mean |",
      "sw": "Kwa orodha fulani ya nambari za ingizo, hesabu Mkengeuko Wastani wa Kawaida\n  kuzunguka wastani wa seti hii ya data.\n  Mkengeuko Wastani wa Kawaida ni wastani wa tofauti kamili kati ya kila\n  kipengele na kituo (wastani katika kesi hii):\n  MAD = wastani | x - x_mean |",
      "tr": "Verilen bir giriş numaraları listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapmayı hesaplayın.\n  Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n  MAD = ortalama | x - x_mean |",
      "vi": "Đối với một danh sách các số đầu vào đã cho, tính Độ lệch Tuyệt đối Trung bình xung quanh giá trị trung bình của tập dữ liệu này. Độ lệch Tuyệt đối Trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi phần tử và một điểm trung tâm (trong trường hợp này là giá trị trung bình): MAD = trung bình | x - x_mean |"
    },
    "docstring_bertscore": {
      "es": "0.9595793133505434",
      "arb": "0.8884463971854724",
      "sw": "0.9510056315835534",
      "tr": "0.9293622693748489",
      "vi": "0.9390715210302153"
    }
  },
  {
    "task_id": "Rust/6",
    "prompt": {
      "en": "/*\n  Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "es": "/*\n  Determina la longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n  La función no requiere que los caracteres estén posicionados consecutivamente en 'source', pero deben mantener su orden de 'target'.\n\n  Argumentos:\n  - source: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n  - target: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n\n  Devuelve:\n  - La longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n\n  Ejemplo:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") devuelve 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") devuelve 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") devuelve 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "arb": "/*\n  يحدد طول أطول تسلسل متجاور من الأحرف من 'target' الموجود في 'source'.\n  لا تتطلب الدالة أن تكون الأحرف متتالية في 'source'، ولكن يجب أن تحتفظ بترتيبها من 'target'.\n\n  الوسائط:\n  - source: سلسلة تتكون من أحرف إنجليزية كبيرة.\n  - target: سلسلة تتكون من أحرف إنجليزية كبيرة.\n\n  تعيد:\n  - طول أطول تسلسل متجاور من الأحرف من 'target' الموجود في 'source'.\n\n  مثال:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") يعيد 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") يعيد 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") يعيد 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "sw": "/*\n  Huamua urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao umejumuishwa katika 'source'.\n  Kazi haidai herufi ziwe zimepangwa kwa mfululizo katika 'source', lakini lazima ziwe na mpangilio wao kutoka 'target'.\n\n  Hoja:\n  - source: Kamba inayojumuisha herufi kubwa za Kiingereza.\n  - target: Kamba inayojumuisha herufi kubwa za Kiingereza.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao umejumuishwa katika 'source'.\n\n  Mfano:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") inarudisha 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") inarudisha 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") inarudisha 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "tr": "/*\n  'target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğunu belirler.\n  Fonksiyon, karakterlerin 'source' içinde ardışık olarak yer almasını gerektirmez, ancak 'target' içindeki sıralarını korumalıdırlar.\n\n  Argümanlar:\n  - source: Büyük harf İngilizce harflerden oluşan bir dize.\n  - target: Büyük harf İngilizce harflerden oluşan bir dize.\n\n  Döndürür:\n  - 'target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğu.\n\n  Örnek:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 döndürür\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 döndürür\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 döndürür\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "vi": "/*\n  Xác định độ dài của dãy ký tự liên tiếp dài nhất từ 'target' có trong 'source'.\n  Hàm không yêu cầu các ký tự phải được đặt liên tiếp trong 'source', nhưng chúng phải giữ nguyên thứ tự từ 'target'.\n\n  Tham số:\n  - source: Một chuỗi gồm các chữ cái tiếng Anh viết hoa.\n  - target: Một chuỗi gồm các chữ cái tiếng Anh viết hoa.\n\n  Trả về:\n  - Độ dài của dãy ký tự liên tiếp dài nhất từ 'target' có trong 'source'.\n\n  Ví dụ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") trả về 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") trả về 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") trả về 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9693092225655373",
      "arb": "0.9727788980614548",
      "sw": "0.9766148479800005",
      "tr": "0.9592140320798201",
      "vi": "0.9606739653804266"
    },
    "canonical_solution": "{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}",
    "instruction": {
      "en": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olacak şekilde olmalıdır.",
      "vi": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9431116629804649",
      "tr": "0.8553319318416219",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_contained_sequence(\"ABCDEABCD\", \"AABZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"XYZ\", \"XYZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"ABCDEF\", \"FED\"), 1);\n        assert_eq!(longest_contained_sequence(\"ABCD\", \"BCD\"), 3);\n    }\n    \n\n}",
    "entry_point": "longest_contained_sequence",
    "signature": "fn longest_contained_sequence(source: &str, target: &str) -> usize",
    "docstring": {
      "en": "Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "es": "Determina la longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.  \nLa función no requiere que los caracteres estén posicionados consecutivamente en 'source', pero deben mantener su orden de 'target'.\n\nArgumentos:\n- source: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n- target: Una cadena que consiste en letras mayúsculas del alfabeto inglés.\n\nDevuelve:\n- La longitud de la secuencia contigua más larga de caracteres de 'target' que está contenida en 'source'.\n\nEjemplo:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") devuelve 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") devuelve 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") devuelve 0",
      "arb": "يحدد طول أطول تسلسل متجاور من الأحرف من 'target' الذي يتم تضمينه في 'source'. \nلا تتطلب الدالة أن تكون الأحرف متتالية في 'source'، ولكن يجب أن تحتفظ بترتيبها من 'target'.\n\nالمعطيات:\n- source: سلسلة نصية تتكون من حروف إنجليزية كبيرة.\n- target: سلسلة نصية تتكون من حروف إنجليزية كبيرة.\n\nالقيم المعادة:\n- طول أطول تسلسل متجاور من الأحرف من 'target' الذي يتم تضمينه في 'source'.\n\nمثال:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") يعيد 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") يعيد 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") يعيد 0",
      "sw": "Inabainisha urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'. \nKazi hii haihitaji herufi kuwa katika nafasi mfululizo ndani ya 'source', lakini lazima zibaki katika mpangilio wao kutoka 'target'.\n\nHoja:\n- source: Kamba inayojumuisha herufi kubwa za Kiingereza.\n- target: Kamba inayojumuisha herufi kubwa za Kiingereza.\n\nInarejesha:\n- Urefu wa mlolongo mrefu zaidi wa herufi mfululizo kutoka 'target' ambao unapatikana ndani ya 'source'.\n\nMfano:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") inarejesha 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") inarejesha 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") inarejesha 0",
      "tr": "'Target' içindeki karakterlerin 'source' içinde bulunan en uzun ardışık dizisinin uzunluğunu belirler.\n  Fonksiyon, karakterlerin 'source' içinde ardışık olarak konumlandırılmasını gerektirmez, ancak 'target' içindeki sıralarını korumalıdırlar.\n\n  Argümanlar:\n  - source: Büyük harf İngilizce harflerden oluşan bir dize.\n  - target: Büyük harf İngilizce harflerden oluşan bir dize.\n\n  Döndürür:\n  - 'source' içinde bulunan 'target' içindeki karakterlerin en uzun ardışık dizisinin uzunluğu.\n\n  Örnek:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 döndürür\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 döndürür\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 döndürür",
      "vi": "Xác định độ dài của chuỗi ký tự liền kề dài nhất từ 'target' mà được chứa trong 'source'. \nHàm không yêu cầu các ký tự phải được đặt liên tiếp trong 'source', nhưng chúng phải giữ nguyên thứ tự từ 'target'.\n\nCác tham số:\n- source: Một chuỗi bao gồm các chữ cái tiếng Anh viết hoa.\n- target: Một chuỗi bao gồm các chữ cái tiếng Anh viết hoa.\n\nTrả về:\n- Độ dài của chuỗi ký tự liền kề dài nhất từ 'target' mà được chứa trong 'source'.\n\nVí dụ:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") trả về 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") trả về 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9699869494256284",
      "arb": "0.9720850821404999",
      "sw": "0.9585615312781206",
      "tr": "0.958563914842693",
      "vi": "0.9492388143442481"
    }
  },
  {
    "task_id": "Rust/7",
    "prompt": {
      "en": "/*\n  Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "es": "/*\n  Calcula la puntuación más alta, la puntuación más baja y la puntuación promedio de una lista de puntuaciones de estudiantes.\n  \n  La función toma un vector de puntuaciones enteras, cada una en el rango de 0 a 100, que representan las puntuaciones de los estudiantes en un examen. Devuelve una tupla que contiene la puntuación más alta, la puntuación más baja y la puntuación promedio calculada a partir de estas puntuaciones.\n\n  Argumentos:\n  - scores: Un Vec<i32> que contiene las puntuaciones del examen de los estudiantes.\n\n  Devuelve:\n  - Una tupla (i32, i32, f64), donde el primer elemento es la puntuación más alta, el segundo es la puntuación más baja, y el tercero es la puntuación promedio redondeada a dos decimales.\n\n  Ejemplo:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) devuelve (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) devuelve (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) devuelve (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "arb": "/*\n  يحسب أعلى درجة، وأدنى درجة، ومتوسط الدرجة من قائمة درجات الطلاب.\n  \n  تأخذ الدالة متجهًا من الدرجات الصحيحة، كل منها يتراوح بين 0 إلى 100، ويمثل درجات الطلاب في امتحان. وتعيد دالة تحتوي على أعلى درجة، وأدنى درجة، ومتوسط الدرجة المحسوب من هذه الدرجات.\n\n  الوسائط:\n  - scores: متجه Vec<i32> يحتوي على درجات امتحان الطلاب.\n\n  يعيد:\n  - دالة (i32, i32, f64)، حيث أن العنصر الأول هو أعلى درجة، والثاني هو أدنى درجة، والثالث هو متوسط الدرجة مقربًا إلى منزلتين عشريتين.\n\n  مثال:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) يعيد (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) يعيد (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) يعيد (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "sw": "/*\n  Inahesabu alama ya juu zaidi, alama ya chini zaidi, na wastani wa alama kutoka kwenye orodha ya alama za wanafunzi.\n  \n  Kazi inachukua vector ya alama za nambari kamili, kila moja ikiwa kati ya 0 hadi 100, ikiwakilisha alama za wanafunzi katika mtihani. Inarudisha tuple inayojumuisha alama ya juu zaidi, alama ya chini zaidi, na wastani wa alama uliokokotolewa kutoka kwenye alama hizi.\n\n  Hoja:\n  - scores: Vec<i32> inayojumuisha alama za mtihani za wanafunzi.\n\n  Inarudisha:\n  - Tuple (i32, i32, f64), ambapo kipengele cha kwanza ni alama ya juu zaidi, cha pili ni alama ya chini zaidi, na cha tatu ni wastani wa alama uliopatanishwa hadi sehemu mbili za desimali.\n\n  Mfano:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) inarudisha (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) inarudisha (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) inarudisha (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "tr": "/*\n  Bir öğrenci notları listesinden en yüksek notu, en düşük notu ve ortalama notu hesaplar.\n  \n  Fonksiyon, bir sınavda öğrencilerin notlarını temsil eden, 0 ile 100 arasında değişen tamsayı notlarının bir vektörünü alır. Bu notlardan hesaplanan en yüksek notu, en düşük notu ve ortalama notu içeren bir demet döndürür.\n\n  Argümanlar:\n  - scores: Öğrencilerin sınav notlarını içeren bir Vec<i32>.\n\n  Döndürür:\n  - Bir demet (i32, i32, f64), burada ilk eleman en yüksek not, ikinci eleman en düşük not ve üçüncü eleman iki ondalık basamağa yuvarlanmış ortalama nottur.\n\n  Örnek:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) (99, 10, 71.29) döndürür\n  - exam_statistics(vec![100, 85, 76, 90]) (100, 76, 87.75) döndürür\n  - exam_statistics(vec![50, 50, 50, 50]) (50, 50, 50.00) döndürür\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "vi": "/*\n  Tính điểm cao nhất, điểm thấp nhất và điểm trung bình từ danh sách điểm số của học sinh.\n  \n  Hàm nhận vào một vector các điểm số nguyên, mỗi điểm nằm trong khoảng từ 0 đến 100, đại diện cho điểm số của học sinh trong một kỳ thi. Nó trả về một bộ giá trị chứa điểm cao nhất, điểm thấp nhất, và điểm trung bình được tính từ các điểm số này.\n\n  Tham số:\n  - scores: Một Vec<i32> chứa điểm thi của học sinh.\n\n  Trả về:\n  - Một bộ giá trị (i32, i32, f64), trong đó phần tử đầu tiên là điểm cao nhất, phần tử thứ hai là điểm thấp nhất, và phần tử thứ ba là điểm trung bình được làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) trả về (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) trả về (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) trả về (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)"
    },
    "prompt_bertscore": {
      "es": "0.9688315164991484",
      "arb": "0.9796670024149826",
      "sw": "0.9794677761428047",
      "tr": "0.9863002639896428",
      "vi": "0.9771247321681171"
    },
    "canonical_solution": "{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}",
    "instruction": {
      "en": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nRust kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8770704380028422",
      "sw": "0.9431116629804649",
      "tr": "0.8727299669164678",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]), (99, 10, 71.29));\n        assert_eq!(exam_statistics(vec![100, 85, 76, 90]), (100, 76, 87.75));\n        assert_eq!(exam_statistics(vec![50, 50, 50, 50]), (50, 50, 50.00));\n    }\n}",
    "entry_point": "exam_statistics",
    "signature": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
    "docstring": {
      "en": "Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "es": "Calcula la puntuación más alta, la puntuación más baja y la puntuación media de una lista de puntuaciones de estudiantes.\n\nLa función toma un vector de puntuaciones enteras, cada una en el rango de 0 a 100, que representa las puntuaciones de los estudiantes en un examen. Devuelve una tupla que contiene la puntuación más alta, la puntuación más baja y la puntuación media calculada a partir de estas puntuaciones.\n\nArgumentos:\n- scores: Un Vec<i32> que contiene las puntuaciones del examen de los estudiantes.\n\nDevuelve:\n- Una tupla (i32, i32, f64), donde el primer elemento es la puntuación más alta, el segundo es la puntuación más baja, y el tercero es la puntuación media redondeada a dos decimales.\n\nEjemplo:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) devuelve (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) devuelve (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) devuelve (50, 50, 50.00)",
      "arb": "يحسب أعلى درجة، وأدنى درجة، ومتوسط الدرجة من قائمة درجات الطلاب.\n\nتأخذ الدالة متجهًا من الدرجات الصحيحة، كل منها يتراوح بين 0 إلى 100، ويمثل درجات الطلاب في الامتحان. تُرجع الدالة زوجًا يحتوي على أعلى درجة، وأدنى درجة، ومتوسط الدرجة المحسوب من هذه الدرجات.\n\nالمعطيات:\n- scores: متجه Vec<i32> يحتوي على درجات الامتحان للطلاب.\n\nالقيم المعادة:\n- زوج (i32، i32، f64)، حيث أن العنصر الأول هو أعلى درجة، والثاني هو أدنى درجة، والثالث هو متوسط الدرجة مقربًا إلى منزلتين عشريتين.\n\nمثال:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) يعيد (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) يعيد (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) يعيد (50, 50, 50.00)",
      "sw": "Hesabu alama ya juu zaidi, alama ya chini zaidi, na wastani wa alama kutoka kwenye orodha ya alama za wanafunzi.\n\nKazi hii inachukua vekta ya alama za nambari kamili, kila moja ikiwa kati ya 0 hadi 100, ikiwakilisha alama za wanafunzi kwenye mtihani. Inarudisha jozi inayojumuisha alama ya juu zaidi, alama ya chini zaidi, na wastani wa alama uliohesabiwa kutoka kwenye alama hizi.\n\nHoja:\n- scores: A Vec<i32> inayojumuisha alama za mtihani za wanafunzi.\n\nInarudisha:\n- Jozi (i32, i32, f64), ambapo kipengele cha kwanza ni alama ya juu zaidi, cha pili ni alama ya chini zaidi, na cha tatu ni wastani wa alama uliopigwa mduara hadi sehemu mbili za desimali.\n\nMfano:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) inarudisha (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) inarudisha (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) inarudisha (50, 50, 50.00)",
      "tr": "En yüksek puanı, en düşük puanı ve bir öğrenci puanları listesinden ortalama puanı hesaplar.\n\n  Fonksiyon, bir sınavda öğrencilerin puanlarını temsil eden, 0 ile 100 arasında değişen tamsayı puanlarının bir vektörünü alır. Bu puanlardan hesaplanan en yüksek puanı, en düşük puanı ve ortalama puanı içeren bir demet döndürür.\n\n  Argümanlar:\n  - scores: Öğrencilerin sınav puanlarını içeren bir Vec<i32>.\n\n  Döndürür:\n  - Bir demet (i32, i32, f64), burada ilk eleman en yüksek puan, ikinci eleman en düşük puan ve üçüncü eleman iki ondalık basamağa yuvarlanmış ortalama puandır.\n\n  Örnek:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) (99, 10, 71.29) döndürür\n  - exam_statistics(vec![100, 85, 76, 90]) (100, 76, 87.75) döndürür\n  - exam_statistics(vec![50, 50, 50, 50]) (50, 50, 50.00) döndürür",
      "vi": "Tính điểm cao nhất, điểm thấp nhất và điểm trung bình từ danh sách điểm số của học sinh.\n\nHàm này nhận một vector các điểm số nguyên, mỗi điểm nằm trong khoảng từ 0 đến 100, đại diện cho điểm số của học sinh trong một kỳ thi. Nó trả về một bộ giá trị chứa điểm cao nhất, điểm thấp nhất và điểm trung bình được tính từ các điểm số này.\n\nTham số:\n- scores: Một Vec<i32> chứa điểm thi của học sinh.\n\nTrả về:\n- Một bộ giá trị (i32, i32, f64), trong đó phần tử đầu tiên là điểm cao nhất, phần tử thứ hai là điểm thấp nhất, và phần tử thứ ba là điểm trung bình được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) Trả về (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) Trả về (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) Trả về (50, 50, 50.00)"
    },
    "docstring_bertscore": {
      "es": "0.9727091787977116",
      "arb": "0.9726501855745442",
      "sw": "0.9785183229214579",
      "tr": "0.9859596128861678",
      "vi": "0.9838561171510084"
    }
  },
  {
    "task_id": "Rust/8",
    "prompt": {
      "en": "/*\n  Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "es": "/*\n  Calcula la suma de puntuaciones para todas las subcadenas no vacías de una cadena dada, donde la puntuación de una subcadena se define como el conteo de caracteres que aparecen exactamente una vez en ella.\n\n  Argumentos:\n  - s: Una cadena que consiste en letras minúsculas del alfabeto inglés.\n\n  Devuelve:\n  - Un entero que representa la suma total de puntuaciones para todas las subcadenas no vacías.\n\n  Ejemplo:\n  - sum_of_unique_chars_scores(\"abc\") devuelve 10 (Puntuaciones: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") devuelve 4 (Puntuaciones: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "arb": "/*\n  يحسب مجموع الدرجات لجميع المقاطع الفرعية غير الفارغة في سلسلة معينة، حيث يتم تعريف درجة المقطع الفرعي على أنها عدد الأحرف التي تظهر مرة واحدة فقط فيه.\n\n  الوسائط:\n  - s: سلسلة تتكون من أحرف إنجليزية صغيرة.\n\n  يعيد:\n  - عدد صحيح يمثل مجموع الدرجات الكلي لجميع المقاطع الفرعية غير الفارغة.\n\n  مثال:\n  - sum_of_unique_chars_scores(\"abc\") يعيد 10 (الدرجات: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") يعيد 4 (الدرجات: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "sw": "/*\n  Inahesabu jumla ya alama za sehemu ndogo zote zisizo tupu za kamba fulani, ambapo alama ya sehemu ndogo inafafanuliwa kama idadi ya herufi zinazojitokeza mara moja tu ndani yake.\n\n  Hoja:\n  - s: Kamba inayojumuisha herufi ndogo za Kiingereza.\n\n  Inarudisha:\n  - Nambari nzima inayowakilisha jumla ya alama za sehemu ndogo zote zisizo tupu.\n\n  Mfano:\n  - sum_of_unique_chars_scores(\"abc\") inarudisha 10 (Alama: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") inarudisha 4 (Alama: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "tr": "/*\n  Belirtilen bir dizgenin tüm boş olmayan alt dizgelerinin puanlarının toplamını hesaplar, burada bir alt dizgenin puanı, içinde tam olarak bir kez görünen karakterlerin sayısı olarak tanımlanır.\n\n  Argümanlar:\n  - s: Küçük harflerden oluşan bir dizge.\n\n  Döndürür:\n  - Tüm boş olmayan alt dizgelerin puanlarının toplamını temsil eden bir tamsayı.\n\n  Örnek:\n  - sum_of_unique_chars_scores(\"abc\") 10 döndürür (Puanlar: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 döndürür (Puanlar: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "vi": "/*\n  Tính tổng điểm của tất cả các chuỗi con không rỗng của một chuỗi cho trước, trong đó điểm của một chuỗi con được định nghĩa là số lượng ký tự xuất hiện chính xác một lần trong đó.\n\n  Tham số:\n  - s: Một chuỗi bao gồm các chữ cái tiếng Anh viết thường.\n\n  Trả về:\n  - Một số nguyên đại diện cho tổng điểm của tất cả các chuỗi con không rỗng.\n\n  Ví dụ:\n  - sum_of_unique_chars_scores(\"abc\") trả về 10 (Điểm: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") trả về 4 (Điểm: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9869074770644664",
      "arb": "0.9919657983479009",
      "sw": "0.9773493831290676",
      "tr": "0.9876060601145661",
      "vi": "0.9719819929727428"
    },
    "canonical_solution": "{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}",
    "instruction": {
      "en": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9238518653441791",
      "sw": "0.9153697521828462",
      "tr": "0.8659743490270903",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(sum_of_unique_chars_scores(\"abc\"), 10); // a=1, b=1, c=1, ab=2, bc=2, abc=3\n        assert_eq!(sum_of_unique_chars_scores(\"aab\"), 6);  // a=1, a=1, b=1, aa=0, ab=2, aab=1\n        assert_eq!(sum_of_unique_chars_scores(\"ababc\"), 21);\n    }\n\n\n}",
    "entry_point": "sum_of_unique_chars_scores",
    "signature": "fn sum_of_unique_chars_scores(s: &str) -> i32",
    "docstring": {
      "en": "Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "es": "Calcula la suma de las puntuaciones para todas las subcadenas no vacías de una cadena dada, donde la puntuación de una subcadena se define como el conteo de caracteres que aparecen exactamente una vez en ella.\n\n  Argumentos:\n  - s: Una cadena que consiste en letras minúsculas del alfabeto inglés.\n\n  Retorna:\n  - Un entero que representa la suma total de las puntuaciones para todas las subcadenas no vacías.\n\n  Ejemplo:\n  - sum_of_unique_chars_scores(\"abc\") retorna 10 (Puntuaciones: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") retorna 4 (Puntuaciones: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "arb": "يحسب مجموع الدرجات لجميع المقاطع الفرعية غير الفارغة لسلسلة معينة، حيث يتم تعريف درجة المقطع الفرعي على أنها عدد الأحرف التي تظهر مرة واحدة فقط فيها.\n\n  الحجج:\n  - s: سلسلة تتكون من أحرف إنجليزية صغيرة.\n\n  يعيد:\n  - عدد صحيح يمثل مجموع الدرجات الكلي لجميع المقاطع الفرعية غير الفارغة.\n\n  مثال:\n  - sum_of_unique_chars_scores(\"abc\") يعيد 10 (الدرجات: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") يعيد 4 (الدرجات: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "sw": "Hesabu jumla ya alama za vipande vidogo visivyo tupu vya kamba fulani, ambapo alama ya kipande kidogo inafafanuliwa kama idadi ya herufi zinazojitokeza mara moja tu ndani yake.\n\n  Hoja:\n  - s: Kamba inayojumuisha herufi ndogo za Kiingereza.\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha jumla ya alama za vipande vidogo visivyo tupu.\n\n  Mfano:\n  - sum_of_unique_chars_scores(\"abc\") inarudisha 10 (Alama: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") inarudisha 4 (Alama: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "tr": "Verilen bir dizgenin tüm boş olmayan alt dizgelerinin puanlarının toplamını hesaplar, burada bir alt dizgenin puanı, içinde tam olarak bir kez görünen karakterlerin sayısı olarak tanımlanır.\n\n  Argümanlar:\n  - s: Küçük harfli İngilizce harflerden oluşan bir dizge.\n\n  Döndürür:\n  - Tüm boş olmayan alt dizgeler için puanların toplamını temsil eden bir tamsayı.\n\n  Örnek:\n  - sum_of_unique_chars_scores(\"abc\") 10 döndürür (Puanlar: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 döndürür (Puanlar: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "vi": "Tính tổng điểm cho tất cả các chuỗi con không rỗng của một chuỗi cho trước, trong đó điểm của một chuỗi con được định nghĩa là số lượng ký tự xuất hiện chính xác một lần trong đó.\n\n  Tham số:\n  - s: Một chuỗi bao gồm các chữ cái tiếng Anh viết thường.\n\n  Trả về:\n  - Một số nguyên đại diện cho tổng điểm của tất cả các chuỗi con không rỗng.\n\n  Ví dụ:\n  - sum_of_unique_chars_scores(\"abc\") trả về 10 (Điểm: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") trả về 4 (Điểm: a=0, a=0, b=1, aa=0, ab=1, aab=1)"
    },
    "docstring_bertscore": {
      "es": "0.9802851401607632",
      "arb": "0.9916428253483381",
      "sw": "0.9624795155440338",
      "tr": "0.9884124994615677",
      "vi": "0.9676117273292132"
    }
  },
  {
    "task_id": "Rust/9",
    "prompt": {
      "en": "/*\n  Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "es": "/*\n  Genera una secuencia de enteros donde cada entero subsiguiente es la mitad del anterior, redondeado hacia abajo, comenzando desde un valor inicial.\n\n  Argumentos:\n  - initial_value: Un entero que representa el valor inicial de la secuencia.\n\n  Retorna:\n  - Un vector de enteros que representa la secuencia donde cada elemento es la mitad de su predecesor, deteniéndose cuando el valor se vuelve menor que 1.\n\n  Ejemplo:\n  - generate_dividing_sequence(20) devuelve [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) devuelve [5, 2, 1]\n  - generate_dividing_sequence(1) Devuelve [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "arb": "/*\n  يولد تسلسلاً من الأعداد الصحيحة حيث يكون كل عدد صحيح لاحق نصف العدد السابق، مقربًا إلى الأسفل، بدءًا من قيمة ابتدائية.\n\n  الحجج:\n  - initial_value: عدد صحيح يمثل القيمة الابتدائية للتسلسل.\n\n  يعيد:\n  - متجه من الأعداد الصحيحة يمثل التسلسل حيث يكون كل عنصر نصف سابقه، ويتوقف عندما تصبح القيمة أقل من 1.\n\n  مثال:\n  - generate_dividing_sequence(20) يعيد [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) يعيد [5, 2, 1]\n  - generate_dividing_sequence(1) يعيد [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "sw": "/*\n  Hutengeneza mlolongo wa namba za mzima ambapo kila namba inayofuata ni nusu ya ile iliyotangulia, ikipunguzwa hadi chini, kuanzia na thamani ya awali.\n\n  Hoja:\n  - initial_value: Namba ya mzima inayowakilisha thamani ya kuanzia ya mlolongo.\n\n  Inarejesha:\n  - Vector ya namba za mzima inayowakilisha mlolongo ambapo kila kipengele ni nusu ya kile kilichotangulia, ikisimama wakati thamani inakuwa chini ya 1.\n\n  Mfano:\n  - generate_dividing_sequence(20) inarejesha [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) inarejesha [5, 2, 1]\n  - generate_dividing_sequence(1) inarejesha [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "tr": "/*\n  Her bir ardışık tam sayının bir öncekinin yarısı olduğu, aşağı yuvarlanmış bir tam sayı dizisi üretir, başlangıç değerinden başlayarak.\n\n  Argümanlar:\n  - initial_value: Dizinin başlangıç değerini temsil eden bir tam sayı.\n\n  Döndürür:\n  - Her bir elemanın selefinin yarısı olduğu ve değer 1'den küçük olduğunda durduğu diziyi temsil eden bir tam sayı vektörü.\n\n  Örnek:\n  - generate_dividing_sequence(20) Döndürür [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) Döndürür [5, 2, 1]\n  - generate_dividing_sequence(1) Döndürür [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "vi": "/*\n  Tạo ra một dãy số nguyên mà mỗi số tiếp theo là một nửa của số trước đó, làm tròn xuống, bắt đầu từ một giá trị ban đầu.\n\n  Tham số:\n  - initial_value: Một số nguyên đại diện cho giá trị bắt đầu của dãy số.\n\n  Trả về:\n  - Một vector các số nguyên đại diện cho dãy số mà mỗi phần tử là một nửa của phần tử trước đó, dừng lại khi giá trị nhỏ hơn 1.\n\n  Ví dụ:\n  - generate_dividing_sequence(20) trả về [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) trả về [5, 2, 1]\n  - generate_dividing_sequence(1) trả về [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>"
    },
    "prompt_bertscore": {
      "es": "0.9978945179610302",
      "arb": "0.9978945179610302",
      "sw": "0.9893951239565473",
      "tr": "0.9670317266165913",
      "vi": "0.9801165029672646"
    },
    "canonical_solution": "{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}",
    "instruction": {
      "en": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nRust kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8947833022316284",
      "sw": "0.9431116629804649",
      "tr": "0.8697858674087687",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(generate_dividing_sequence(20), vec![20, 10, 5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(5), vec![5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(1), vec![1]);\n        assert_eq!(generate_dividing_sequence(15), vec![15, 7, 3, 1]);        \n    }\n    \n\n}\n ",
    "entry_point": "generate_dividing_sequence",
    "signature": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
    "docstring": {
      "en": "Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "es": "Genera una secuencia de enteros donde cada entero subsiguiente es la mitad del anterior, redondeado hacia abajo, comenzando desde un valor inicial.\n\n  Argumentos:\n  - initial_value: Un entero que representa el valor inicial de la secuencia.\n\n  Retorna:\n  - Un vector de enteros que representa la secuencia donde cada elemento es la mitad de su predecesor, deteniéndose cuando el valor se vuelve menor que 1.\n\n  Ejemplo:\n  - generate_dividing_sequence(20) Devuelve [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) Devuelve [5, 2, 1]\n  - generate_dividing_sequence(1) Devuelve [1]",
      "arb": "ينشئ تسلسلاً من الأعداد الصحيحة حيث يكون كل عدد صحيح لاحق نصف العدد السابق، مقربًا إلى الأسفل، بدءًا من قيمة ابتدائية.\n\n  الحجج:\n  - initial_value: عدد صحيح يمثل القيمة الابتدائية للتسلسل.\n\n  يعيد:\n  - متجه من الأعداد الصحيحة يمثل التسلسل حيث يكون كل عنصر نصف سابقه، ويتوقف عندما تصبح القيمة أقل من 1.\n\n  مثال:\n  - generate_dividing_sequence(20) يعيد [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) يعيد [5, 2, 1]\n  - generate_dividing_sequence(1) يعيد [1]",
      "sw": "Hutengeneza mfuatano wa nambari za mzima ambapo kila nambari inayofuata ni nusu ya ile iliyotangulia, ikipunguzwa chini, kuanzia thamani ya awali.\n\n  Hoja:\n  - initial_value: Nambari ya mzima inayowakilisha thamani ya kuanzia ya mfuatano.\n\n  Inarejesha:\n  - Vekta ya nambari za mzima inayowakilisha mfuatano ambapo kila kipengele ni nusu ya kile kilichotangulia, ikisimama wakati thamani inakuwa chini ya 1.\n\n  Mfano:\n  - generate_dividing_sequence(20) inarejesha [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) inarejesha [5, 2, 1]\n  - generate_dividing_sequence(1) inarejesha [1]",
      "tr": "Başlangıç değerinden başlayarak, her bir sonraki tamsayının bir öncekinin yarısı olduğu, aşağı yuvarlanmış bir tamsayı dizisi oluşturur.\n\n  Argümanlar:\n  - initial_value: Dizinin başlangıç değerini temsil eden bir tamsayı.\n\n  Döndürür:\n  - Her bir elemanın kendisinden öncekinin yarısı olduğu ve değer 1'den küçük olduğunda durduğu diziyi temsil eden bir tamsayı vektörü.\n\n  Örnek:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] döndürür\n  - generate_dividing_sequence(5) [5, 2, 1] döndürür\n  - generate_dividing_sequence(1) [1] döndürür",
      "vi": "Tạo ra một dãy số nguyên mà mỗi số nguyên tiếp theo là một nửa của số trước đó, làm tròn xuống, bắt đầu từ một giá trị ban đầu.\n\n  Tham số:\n  - initial_value: Một số nguyên đại diện cho giá trị bắt đầu của dãy số.\n\n  Trả về:\n  - Một vector của các số nguyên đại diện cho dãy số mà mỗi phần tử là một nửa của phần tử trước đó, dừng lại khi giá trị trở nên nhỏ hơn 1.\n\n  Ví dụ:\n  - generate_dividing_sequence(20) trả về [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) trả về [5, 2, 1]\n  - generate_dividing_sequence(1) trả về [1]"
    },
    "docstring_bertscore": {
      "es": "0.9972142089059857",
      "arb": "0.9877818480017819",
      "sw": "0.9802819620746667",
      "tr": "0.9641039148001371",
      "vi": "0.9868492783628232"
    }
  },
  {
    "task_id": "Rust/10",
    "prompt": {
      "en": "/*\n  Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "es": "/*\n  Expande una cadena comprimida donde los caracteres consecutivos están representados por el carácter seguido de su cantidad.\n  La cantidad es un solo dígito (1-9), y especifica cuántas veces aparece consecutivamente el carácter. Si un carácter aparece solo una vez, no va seguido de una cantidad.\n\n  Argumentos:\n  - compressed: Una cadena que contiene el formato comprimido, que consiste en caracteres y cantidades de un solo dígito.\n\n  Devuelve:\n  - Una cadena que representa la forma expandida de la cadena comprimida.\n\n  Ejemplo:\n  - expand_compressed_string(\"a3b2c\") devuelve \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") devuelve \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") devuelve \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "arb": "/*\n  يوسع سلسلة مضغوطة حيث يتم تمثيل الأحرف المتتالية بالحرف متبوعًا بعدده.\n  العدد هو رقم واحد (1-9)، ويحدد عدد مرات ظهور الحرف بشكل متتالٍ. إذا ظهر الحرف مرة واحدة فقط، فإنه لا يتبعه عدد.\n\n  الوسائط:\n  - compressed: سلسلة تحتوي على التنسيق المضغوط، تتكون من أحرف وأعداد مكونة من رقم واحد.\n\n  يعيد:\n  - سلسلة تمثل الشكل الموسع للسلسلة المضغوطة.\n\n  مثال:\n  - expand_compressed_string(\"a3b2c\") يعيد \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") يعيد \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") يعيد \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "sw": "/*\n  Inapanua mfuatano ulioshinikizwa ambapo herufi zinazofuatana zinawakilishwa na herufi ikifuatiwa na idadi yake.\n  Idadi ni tarakimu moja (1-9), na inaeleza ni mara ngapi herufi inaonekana mfululizo. Ikiwa herufi inaonekana mara moja tu, haifuatiwi na idadi.\n\n  Hoja:\n  - compressed: Mfuatano wa herufi unao na muundo ulioshinikizwa, unaojumuisha herufi na idadi za tarakimu moja.\n\n  Inarejesha:\n  - Mfuatano wa herufi unaowakilisha umbo lililopanuliwa la mfuatano ulioshinikizwa.\n\n  Mfano:\n  - expand_compressed_string(\"a3b2c\") inarejesha \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") inarejesha \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") inarejesha \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "tr": "/*\n  Ardışık karakterlerin karakter ve ardından sayısı ile temsil edildiği sıkıştırılmış bir dizeyi genişletir.\n  Sayı tek basamaklıdır (1-9) ve karakterin ardışık olarak kaç kez göründüğünü belirtir. Bir karakter yalnızca bir kez görünüyorsa, ardından bir sayı gelmez.\n\n  Argümanlar:\n  - compressed: Karakterler ve tek basamaklı sayılardan oluşan sıkıştırılmış formatı içeren bir dize.\n\n  Döndürür:\n  - Sıkıştırılmış dizenin genişletilmiş biçimini temsil eden bir dize.\n\n  Örnek:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" döndürür\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" döndürür\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" döndürür\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "vi": "/*\n  Mở rộng một chuỗi đã nén nơi các ký tự liên tiếp được biểu diễn bằng ký tự theo sau là số lượng của nó.\n  Số lượng là một chữ số đơn (1-9), và nó chỉ định số lần ký tự xuất hiện liên tiếp. Nếu một ký tự chỉ xuất hiện một lần, nó không được theo sau bởi số lượng.\n\n  Tham số:\n  - compressed: Một chuỗi chứa định dạng nén, bao gồm các ký tự và số lượng là chữ số đơn.\n\n  Trả về:\n  - Một chuỗi biểu diễn dạng mở rộng của chuỗi đã nén.\n\n  Ví dụ:\n  - expand_compressed_string(\"a3b2c\") trả về \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") trả về \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") trả về \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9780080414725792",
      "arb": "0.9770113142205462",
      "sw": "0.9670746307788949",
      "tr": "0.9716463076287939",
      "vi": "0.9779691099178964"
    },
    "canonical_solution": "{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}",
    "instruction": {
      "en": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olmalıdır.",
      "vi": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9153697521828462",
      "tr": "0.8497257879672933",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(expand_compressed_string(\"a3b2c\"), \"aaabbc\");\n        assert_eq!(expand_compressed_string(\"H3el5o2\"), \"HHHellllloo\");\n        assert_eq!(expand_compressed_string(\"x9y1z2\"), \"xxxxxxxxxyzz\");\n        assert_eq!(expand_compressed_string(\"r4s\"), \"rrrrs\");\n        \n    }\n    \n\n}\n ",
    "entry_point": "expand_compressed_string",
    "signature": "fn expand_compressed_string(compressed: &str) -> String",
    "docstring": {
      "en": "Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "es": "Expande una cadena comprimida donde los caracteres consecutivos están representados por el carácter seguido de su cuenta.\n  La cuenta es un solo dígito (1-9) y especifica cuántas veces aparece el carácter consecutivamente. Si un carácter aparece solo una vez, no va seguido de una cuenta.\n\n  Argumentos:\n  - compressed: Una cadena que contiene el formato comprimido, que consiste en caracteres y cuentas de un solo dígito.\n\n  Devuelve:\n  - Una cadena que representa la forma expandida de la cadena comprimida.\n\n  Ejemplo:\n  - expand_compressed_string(\"a3b2c\") devuelve \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") devuelve \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") devuelve \"xxxxxxxxxyzz\"",
      "arb": "يوسع سلسلة مضغوطة حيث يتم تمثيل الأحرف المتتالية بواسطة الحرف متبوعًا بعدده.\n  العدد هو رقم واحد (1-9)، ويحدد عدد مرات ظهور الحرف بشكل متتالي. إذا ظهر الحرف مرة واحدة فقط، فإنه لا يتبعه عدد.\n\n  الحجج:\n  - compressed: سلسلة تحتوي على التنسيق المضغوط، تتكون من أحرف وأعداد مكونة من رقم واحد.\n\n  العوائد:\n  - سلسلة تمثل الشكل الموسع للسلسلة المضغوطة.\n\n  مثال:\n  - expand_compressed_string(\"a3b2c\") يعيد \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") يعيد \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") يعيد \"xxxxxxxxxyzz\"",
      "sw": "Hupanua mfuatano uliobanwa ambapo herufi mfululizo zinawakilishwa na herufi ikifuatiwa na idadi yake. Idadi ni tarakimu moja (1-9), na inaeleza ni mara ngapi herufi inaonekana mfululizo. Ikiwa herufi inaonekana mara moja tu, haifuatiwi na idadi.\n\nHoja:  \n- compressed: Mfuatano wa herufi unaoelezea muundo uliobanwa, unaojumuisha herufi na idadi za tarakimu moja.\n\nInarejesha:  \n- Mfuatano wa herufi unaowakilisha muundo uliohupanuliwa wa mfuatano uliobanwa.\n\nMifano:  \n- expand_compressed_string(\"a3b2c\") Inarejesha \"aaabbc\"  \n- expand_compressed_string(\"H3el5o2\") Inarejesha \"HHHellllloo\"  \n- expand_compressed_string(\"x9y1z2\") Inarejesha \"xxxxxxxxxyzz\"",
      "tr": "Sıkıştırılmış bir dizeyi, ardışık karakterlerin karakter ve ardından gelen sayısıyla temsil edildiği formatta genişletir.\n  Sayı, karakterin ardışık olarak kaç kez göründüğünü belirten tek basamaklı bir sayıdır (1-9). Bir karakter yalnızca bir kez görünüyorsa, ardından bir sayı gelmez.\n\n  Argümanlar:\n  - compressed: Karakterler ve tek basamaklı sayılardan oluşan sıkıştırılmış formatı içeren bir dize.\n\n  Döndürür:\n  - Sıkıştırılmış dizenin genişletilmiş halini temsil eden bir dize.\n\n  Örnek:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" döndürür\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" döndürür\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" döndürür",
      "vi": "Mở rộng một chuỗi nén nơi các ký tự liên tiếp được biểu diễn bằng ký tự theo sau là số đếm của nó. \nSố đếm là một chữ số đơn (1-9), và nó chỉ định số lần ký tự xuất hiện liên tiếp. Nếu một ký tự chỉ xuất hiện một lần, nó không được theo sau bởi số đếm.\n\nTham số:\n- compressed: Một chuỗi chứa định dạng nén, bao gồm các ký tự và các chữ số đơn.\n\nTrả về:\n- Một chuỗi đại diện cho dạng mở rộng của chuỗi nén.\n\nVí dụ:\n- expand_compressed_string(\"a3b2c\") Trả về \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") Trả về \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") Trả về \"xxxxxxxxxyzz\""
    },
    "docstring_bertscore": {
      "es": "0.99171035967789",
      "arb": "0.9730009668274517",
      "sw": "0.961872103838829",
      "tr": "0.9500021508985652",
      "vi": "0.9792320018805162"
    }
  },
  {
    "task_id": "Rust/11",
    "prompt": {
      "en": "/*\n  Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "es": "/*\n  Calcula el número de caminos distintos desde la esquina superior izquierda hasta la esquina inferior derecha de una cuadrícula,\n  con la restricción de que solo se puede mover a la derecha o hacia abajo y no se puede entrar en celdas donde tanto el número de fila como de columna son pares.\n\n  Argumentos:\n  - rows: El número de filas en la cuadrícula.\n  - cols: El número de columnas en la cuadrícula.\n\n  Devuelve:\n  - El número de caminos distintos que satisfacen las restricciones dadas.\n\n  Ejemplo:\n  - count_walking_paths(3, 4) Devuelve 2\n  - count_walking_paths(2, 2) Devuelve 0\n  - count_walking_paths(4, 5) Devuelve 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "arb": "/*\n  يحسب عدد المسارات المميزة من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى لشبكة،\n  مع القيد أنه يمكن التحرك فقط إلى اليمين أو إلى الأسفل ولا يمكن الدخول إلى الخلايا حيث يكون كلا رقمي الصف والعمود زوجيين.\n\n  الوسائط:\n  - rows: عدد الصفوف في الشبكة.\n  - cols: عدد الأعمدة في الشبكة.\n\n  يعيد:\n  - عدد المسارات المميزة التي تفي بالقيود المعطاة.\n\n  مثال:\n  - count_walking_paths(3, 4) يعيد 2\n  - count_walking_paths(2, 2) يعيد 0\n  - count_walking_paths(4, 5) يعيد 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya njia tofauti kutoka kona ya juu-kushoto hadi kona ya chini-kulia ya gridi,\n  kwa kizuizi kwamba mtu anaweza kusonga kulia au chini na hawezi kuingia kwenye seli ambapo namba za safu na safu wima ni sawa.\n\n  Hoja:\n  - rows: Idadi ya safu katika gridi.\n  - cols: Idadi ya safu wima katika gridi.\n\n  Inarudisha:\n  - Idadi ya njia tofauti zinazokidhi vikwazo vilivyotolewa.\n\n  Mfano:\n  - count_walking_paths(3, 4) inarudisha 2\n  - count_walking_paths(2, 2) inarudisha 0\n  - count_walking_paths(4, 5) inarudisha 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "tr": "/*\n  Bir ızgaranın sol üst köşesinden sağ alt köşesine kadar olan farklı yolların sayısını hesaplar,\n  yalnızca sağa veya aşağı hareket edilebileceği ve hem satır hem de sütun numaralarının çift olduğu hücrelere girilemeyeceği kısıtlamasıyla.\n\n  Argümanlar:\n  - rows: Izgaradaki satır sayısı.\n  - cols: Izgaradaki sütun sayısı.\n\n  Döndürür:\n  - Verilen kısıtlamaları karşılayan farklı yolların sayısı.\n\n  Örnek:\n  - count_walking_paths(3, 4) 2 döndürür\n  - count_walking_paths(2, 2) 0 döndürür\n  - count_walking_paths(4, 5) 3 döndürür\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "vi": "/*\n  Tính toán số lượng đường đi khác nhau từ góc trên bên trái đến góc dưới bên phải của một lưới,\n  với điều kiện rằng chỉ có thể di chuyển sang phải hoặc xuống dưới và không thể vào các ô mà cả số hàng và số cột đều là số chẵn.\n\n  Tham số:\n  - rows: Số hàng trong lưới.\n  - cols: Số cột trong lưới.\n\n  Trả về:\n  - Số lượng đường đi khác nhau thỏa mãn các điều kiện đã cho.\n\n  Ví dụ:\n  - count_walking_paths(3, 4) trả về 2\n  - count_walking_paths(2, 2) trả về 0\n  - count_walking_paths(4, 5) trả về 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9874054434297208",
      "arb": "0.9888393561504117",
      "sw": "0.9688337014333398",
      "tr": "0.9665025752815144",
      "vi": "0.9627470706672877"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}",
    "instruction": {
      "en": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nRust kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9431116629804649",
      "tr": "0.8671522271866271",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(count_walking_paths(3, 4), 2);\n        assert_eq!(count_walking_paths(2, 2), 0);\n        assert_eq!(count_walking_paths(4, 5), 3);\n        assert_eq!(count_walking_paths(1, 1), 1);        \n    }\n    \n\n}",
    "entry_point": "count_walking_paths",
    "signature": "fn count_walking_paths(rows: i32, cols: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "es": "Calcula el número de caminos distintos desde la esquina superior izquierda hasta la esquina inferior derecha de una cuadrícula, con la restricción de que solo se puede mover a la derecha o hacia abajo y no se puede entrar en celdas donde tanto el número de fila como el de columna sean pares.\n\nArgumentos:\n- rows: El número de filas en la cuadrícula.\n- cols: El número de columnas en la cuadrícula.\n\nDevuelve:\n- El número de caminos distintos que satisfacen las restricciones dadas.\n\nEjemplo:\n- count_walking_paths(3, 4) devuelve 2\n- count_walking_paths(2, 2) devuelve 0\n- count_walking_paths(4, 5) devuelve 3",
      "arb": "يحسب عدد المسارات المميزة من الزاوية العلوية اليسرى إلى الزاوية السفلية اليمنى من الشبكة، مع القيد الذي يسمح بالتحرك فقط إلى اليمين أو إلى الأسفل ولا يمكن الدخول إلى الخلايا حيث يكون كل من أرقام الصفوف والأعمدة زوجيًا.\n\nالحجج:\n- rows: عدد الصفوف في الشبكة.\n- cols: عدد الأعمدة في الشبكة.\n\nالقيم المعادة:\n- عدد المسارات المميزة التي تلبي القيود المعطاة.\n\nمثال:\n- count_walking_paths(3, 4) يعيد 2\n- count_walking_paths(2, 2) يعيد 0\n- count_walking_paths(4, 5) يعيد 3",
      "sw": "Hesabu idadi ya njia tofauti kutoka kona ya juu-kushoto hadi kona ya chini-kulia ya gridi,\n  kwa kizuizi kwamba mtu anaweza kusonga kulia au chini na hawezi kuingia kwenye seli ambapo namba za safu na safu wima ni sawa.\n\n  Hoja:\n  - rows: Idadi ya safu kwenye gridi.\n  - cols: Idadi ya safu wima kwenye gridi.\n\n  Inarudisha:\n  - Idadi ya njia tofauti zinazokidhi vikwazo vilivyotolewa.\n\n  Mfano:\n  - count_walking_paths(3, 4) inarudisha 2\n  - count_walking_paths(2, 2) inarudisha 0\n  - count_walking_paths(4, 5) inarudisha 3",
      "tr": "Üst sol köşeden alt sağ köşeye bir ızgara üzerinde, yalnızca sağa veya aşağıya hareket edilebilen ve hem satır hem de sütun numaralarının çift olduğu hücrelere girilemeyen kısıtlamasıyla, farklı yolların sayısını hesaplar.\n\nArgümanlar:\n- rows: Izgaradaki satır sayısı.\n- cols: Izgaradaki sütun sayısı.\n\nDöndürür:\n- Verilen kısıtlamaları karşılayan farklı yolların sayısı.\n\nÖrnek:\n- count_walking_paths(3, 4) 2 döndürür\n- count_walking_paths(2, 2) 0 döndürür\n- count_walking_paths(4, 5) 3 döndürür",
      "vi": "Tính toán số lượng đường đi khác nhau từ góc trên bên trái đến góc dưới bên phải của một lưới,\nvới điều kiện rằng chỉ có thể di chuyển sang phải hoặc xuống dưới và không thể vào các ô mà cả số hàng và số cột đều là số chẵn.\n\nTham số:\n- rows: Số hàng trong lưới.\n- cols: Số cột trong lưới.\n\nTrả về:\n- Số lượng đường đi khác nhau thỏa mãn các điều kiện đã cho.\n\nVí dụ:\n- count_walking_paths(3, 4) trả về 2\n- count_walking_paths(2, 2) trả về 0\n- count_walking_paths(4, 5) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9837613704592548",
      "arb": "0.9578333523012467",
      "sw": "0.9534048879560738",
      "tr": "0.9521046534818195",
      "vi": "0.9694921611464705"
    }
  },
  {
    "task_id": "Rust/12",
    "prompt": {
      "en": "/*\n  Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "es": "/*\n  Cuenta el número de letras mayúsculas, letras minúsculas y dígitos en una cadena dada.\n\n  Argumentos:\n  - input: Una cadena que puede contener letras inglesas mayúsculas y minúsculas, así como dígitos.\n\n  Devuelve:\n  - Una tupla que contiene tres valores usize que representan los conteos de letras mayúsculas, letras minúsculas y dígitos, respectivamente.\n\n  Ejemplo:\n  - count_character_types(\"Rust3IsFun!\") Devuelve (3, 6, 1)\n  - count_character_types(\"1234\") Devuelve (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") Devuelve (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "arb": "/*\n  يحسب عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام في سلسلة معينة.\n\n  يعيدالحجج:\n  - input: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، بالإضافة إلى أرقام.\n\n  يعيد:\n  - زوج يحتوي على ثلاث قيم من نوع usize تمثل عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام، على التوالي.\n\n  امثله:\n  - count_character_types(\"Rust3IsFun!\") يعيد (3, 6, 1)\n  - count_character_types(\"1234\") يعيد (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") يعيد (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "sw": "/*\n  Inahesabu idadi ya herufi kubwa, herufi ndogo, na tarakimu katika kamba iliyotolewa.\n\n  Hoja:\n  - input: Kamba ambayo inaweza kuwa na herufi kubwa na ndogo za Kiingereza, pamoja na tarakimu.\n\n  Inarejesha:\n  - Jozi yenye thamani tatu za usize zinazowakilisha idadi ya herufi kubwa, herufi ndogo, na tarakimu, mtawalia.\n\n  Mfano:\n  - count_character_types(\"Rust3IsFun!\") inarejesha (3, 6, 1)\n  - count_character_types(\"1234\") inarejesha (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") inarejesha (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "tr": "/*\n  Verilen bir string içindeki büyük harflerin, küçük harflerin ve rakamların sayısını sayar.\n\n  Argümanlar:\n  - input: Büyük ve küçük İngilizce harfler ile rakamlar içerebilen bir string.\n\n  Döndürür:\n  - Büyük harflerin, küçük harflerin ve rakamların sayısını temsil eden üç usize değeri içeren bir demet.\n\n  Örnek:\n  - count_character_types(\"Rust3IsFun!\") (3, 6, 1) döndürür\n  - count_character_types(\"1234\") (0, 0, 4) döndürür\n  - count_character_types(\"HelloWorld!\") (2, 8, 0) döndürür\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "vi": "/*\n  Đếm số lượng chữ cái viết hoa, chữ cái viết thường và chữ số trong một chuỗi cho trước.\n\n  Tham số:\n  - input: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, cũng như các chữ số.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị usize đại diện cho số lượng chữ cái viết hoa, chữ cái viết thường và chữ số, tương ứng.\n\n  Ví dụ:\n  - count_character_types(\"Rust3IsFun!\") trả về (3, 6, 1)\n  - count_character_types(\"1234\") trả về (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") trả về (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)"
    },
    "prompt_bertscore": {
      "es": "0.9978726686191164",
      "arb": "0.9929712653366994",
      "sw": "0.9961326664812508",
      "tr": "0.9783159185631833",
      "vi": "0.9856368385169862"
    },
    "canonical_solution": "{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}",
    "instruction": {
      "en": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9153697521828462",
      "tr": "0.8583050313849522",
      "vi": "0.9506258502950148"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_character_types(\"Rust3IsFun!\"), (3, 6, 1));\n        assert_eq!(count_character_types(\"1234\"), (0, 0, 4));\n        assert_eq!(count_character_types(\"HelloWorld!\"), (2, 8, 0));\n        assert_eq!(count_character_types(\"NoDigitsHere\"), (3, 9, 0));        \n    }\n    \n\n}",
    "entry_point": "count_character_types",
    "signature": "fn count_character_types(input: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "es": "Cuenta el número de letras mayúsculas, letras minúsculas y dígitos en una cadena dada.\n\n  Argumentos:\n  - input: Una cadena que puede contener letras inglesas mayúsculas y minúsculas, así como dígitos.\n\n  Retorna:\n  - Una tupla que contiene tres valores usize que representan los conteos de letras mayúsculas, letras minúsculas y dígitos, respectivamente.\n\n  Ejemplo:\n  - count_character_types(\"Rust3IsFun!\") Devuelve (3, 6, 1)\n  - count_character_types(\"1234\") Devuelve (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") Devuelve (2, 8, 0)",
      "arb": "يحسب عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام في سلسلة معينة.\n\n  الحجج:\n  - input: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، بالإضافة إلى أرقام.\n\n  يعيد:\n  - زوج يحتوي على ثلاث قيم من نوع usize تمثل عدد الأحرف الكبيرة، الأحرف الصغيرة، والأرقام، على التوالي.\n\n  مثال:\n  - count_character_types(\"Rust3IsFun!\") يعيد (3, 6, 1)\n  - count_character_types(\"1234\") يعيد (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") يعيد (2, 8, 0)",
      "sw": "Hesabu idadi ya herufi kubwa, herufi ndogo, na tarakimu katika mfuatano wa herufi uliotolewa.\n\n  Hoja:\n  - input: Mfuatano wa herufi ambao unaweza kuwa na herufi kubwa na ndogo za Kiingereza, pamoja na tarakimu.\n\n  Inarejesha:\n  - Jozi inayojumuisha thamani tatu za usize zinazowakilisha hesabu ya herufi kubwa, herufi ndogo, na tarakimu, mtawalia.\n\n  Mfano:\n  - count_character_types(\"Rust3IsFun!\") inarejesha (3, 6, 1)\n  - count_character_types(\"1234\") inarejesha (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") inarejesha (2, 8, 0)",
      "tr": "Büyük harf, küçük harf ve rakamların sayısını verilen bir stringde sayar.\n\n  Argümanlar:\n  - input: Büyük ve küçük İngilizce harfler ile rakamlar içerebilen bir string.\n\n  Döndürür:\n  - Büyük harf, küçük harf ve rakamların sayısını sırasıyla temsil eden üç usize değeri içeren bir demet.\n\n  Örnek:\n  - count_character_types(\"Rust3IsFun!\") (3, 6, 1) döndürür\n  - count_character_types(\"1234\") (0, 0, 4) döndürür\n  - count_character_types(\"HelloWorld!\") (2, 8, 0) döndürür",
      "vi": "Đếm số lượng chữ cái viết hoa, chữ cái viết thường và chữ số trong một chuỗi cho trước.\n\n  Tham số:\n  - input: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, cũng như các chữ số.\n\n  Trả về:\n  - Một bộ giá trị chứa ba giá trị usize đại diện cho số lượng chữ cái viết hoa, chữ cái viết thường và chữ số, theo thứ tự tương ứng.\n\n  Ví dụ:\n  - count_character_types(\"Rust3IsFun!\") trả về (3, 6, 1)\n  - count_character_types(\"1234\") trả về (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") trả về (2, 8, 0)"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9883954172487988",
      "sw": "0.9645957236235795",
      "tr": "0.9840952681297744",
      "vi": "0.9734027960882854"
    }
  },
  {
    "task_id": "Rust/13",
    "prompt": {
      "en": "\n/*\n  Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "es": "/*\n  Convierte una secuencia dada de números en la cadena más grande posible lexicográficamente de letras mayúsculas del alfabeto inglés, donde cada letra corresponde a su posición en el alfabeto (A=1, B=2, ..., Z=26).\n\n  La función interpreta la secuencia de números como un número de uno o dos dígitos (que representa una letra) para maximizar el orden lexicográfico de la cadena resultante.\n\n  Argumentos:\n  - encoded_sequence: Una cadena que consiste en dígitos que representan las posiciones de las letras codificadas.\n\n  Devuelve:\n  - Una cadena de letras mayúsculas del alfabeto inglés que representa la interpretación más grande posible lexicográficamente de la secuencia codificada.\n\n  Ejemplos:\n  - max_lexicographic_string(\"123242526\") devuelve \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") devuelve \"WRS\"\n  - max_lexicographic_string(\"102\") devuelve \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "arb": "/*\n  يحول تسلسل الأرقام المعطى إلى أكبر سلسلة ممكنة من الأحرف الإنجليزية الكبيرة بترتيب معجمي، حيث يتوافق كل حرف مع موضعه في الأبجدية (A=1, B=2, ..., Z=26).\n\n  تفسر الدالة تسلسل الأرقام إما كرقم مكون من رقم واحد أو رقم مزدوج (يمثل حرفًا) لزيادة الترتيب المعجمي للسلسلة الناتجة إلى الحد الأقصى.\n\n  الوسائط:\n  - encoded_sequence: سلسلة تتكون من أرقام تمثل مواضع الأحرف المشفرة.\n\n  يعيد:\n  - سلسلة من الأحرف الإنجليزية الكبيرة التي تمثل أكبر تفسير ممكن للترتيب المعجمي لتسلسل الترميز.\n\n  أمثلة:\n  - max_lexicographic_string(\"123242526\") يعيد \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") يعيد \"WRS\"\n  - max_lexicographic_string(\"102\") يعيد \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "sw": "/*\n  Hubadilisha mlolongo uliotolewa wa nambari kuwa herufi kubwa za Kiingereza kwa mpangilio wa lexicographically mkubwa zaidi, ambapo kila herufi inalingana na nafasi yake katika alfabeti (A=1, B=2, ..., Z=26).\n\n  Kazi hii inatafsiri mlolongo wa nambari kama nambari ya tarakimu moja au mbili (inayowakilisha herufi) ili kuongeza mpangilio wa lexicographic wa mfululizo wa herufi unaopatikana.\n\n  Hoja:\n  - encoded_sequence: Mlolongo wa tarakimu unaowakilisha nafasi za herufi zilizofichwa.\n\n  Inarudisha:\n  - Mlolongo wa herufi kubwa za Kiingereza unaowakilisha tafsiri ya lexicographically kubwa zaidi ya mlolongo uliowekwa.\n\n  Mifano:\n  - max_lexicographic_string(\"123242526\") inarudisha \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") inarudisha \"WRS\"\n  - max_lexicographic_string(\"102\") inarudisha \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "tr": "/*\n  Verilen bir sayı dizisini, her harfin alfabedeki konumuna karşılık geldiği (A=1, B=2, ..., Z=26) en büyük sözlük sırasına sahip büyük harfli İngilizce harfler dizisine dönüştürür.\n\n  Fonksiyon, sayı dizisini tek haneli veya çift haneli bir sayı (bir harfi temsil eden) olarak yorumlayarak, ortaya çıkan dizinin sözlük sırasını en üst düzeye çıkarır.\n\n  Argümanlar:\n  - encoded_sequence: Kodlanmış harf pozisyonlarını temsil eden rakamlardan oluşan bir dize.\n\n  Döndürür:\n  - Kodlanmış dizinin sözlük sırasına göre en büyük olası yorumunu temsil eden büyük harfli İngilizce harfler dizisi.\n\n  Örnekler:\n  - max_lexicographic_string(\"123242526\") \"LCXYZ\" döndürür\n  - max_lexicographic_string(\"231819\") \"WRS\" döndürür\n  - max_lexicographic_string(\"102\") \"JB\" döndürür\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "vi": "/*\n  Chuyển đổi một dãy số đã cho thành chuỗi lớn nhất có thể theo thứ tự từ điển của các chữ cái tiếng Anh viết hoa, trong đó mỗi chữ cái tương ứng với vị trí của nó trong bảng chữ cái (A=1, B=2, ..., Z=26).\n\n  Hàm này diễn giải dãy số dưới dạng số một chữ số hoặc số hai chữ số (đại diện cho một chữ cái) để tối đa hóa thứ tự từ điển của chuỗi kết quả.\n\n  Tham số:\n  - encoded_sequence: Một chuỗi gồm các chữ số đại diện cho các vị trí chữ cái được mã hóa.\n\n  Trả về:\n  - Một chuỗi các chữ cái tiếng Anh viết hoa đại diện cho cách diễn giải lớn nhất có thể theo thứ tự từ điển của dãy được mã hóa.\n\n  Ví dụ:\n  - max_lexicographic_string(\"123242526\") trả về \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") trả về \"WRS\"\n  - max_lexicographic_string(\"102\") trả về \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9701452578393132",
      "arb": "0.9754890109802948",
      "sw": "0.9447988294369752",
      "tr": "0.9658931772724993",
      "vi": "0.971049820594546"
    },
    "canonical_solution": "{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}",
    "instruction": {
      "en": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nRust kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9431116629804649",
      "tr": "0.8952218781129534",
      "vi": "0.9506258502950148"
    },
    "level": "",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_lexicographic_string(\"123242526\"), \"LCXYZ\");\n        assert_eq!(max_lexicographic_string(\"231819\"), \"WRS\");\n        assert_eq!(max_lexicographic_string(\"102\"), \"JB\");\n        assert_eq!(max_lexicographic_string(\"26\"), \"Z\");   \n    }\n    \n\n}",
    "entry_point": "max_lexicographic_string",
    "signature": "fn max_lexicographic_string(encoded_sequence: &str) -> String",
    "docstring": {
      "en": "Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "es": "Convierte una secuencia dada de números en la cadena más grande posible en orden lexicográfico de letras mayúsculas del alfabeto inglés, donde cada letra corresponde a su posición en el alfabeto (A=1, B=2, ..., Z=26).\n\n  La función interpreta la secuencia de números como un número de uno o dos dígitos (representando una letra) para maximizar el orden lexicográfico de la cadena resultante.\n\n  Argumentos:\n  - encoded_sequence: Una cadena que consiste en dígitos que representan las posiciones de las letras codificadas.\n\n  Retorna:\n  - Una cadena de letras mayúsculas del alfabeto inglés que representa la interpretación más grande posible en orden lexicográfico de la secuencia codificada.\n\n  Ejemplos:\n  - max_lexicographic_string(\"123242526\") retorna \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") retorna \"WRS\"\n  - max_lexicographic_string(\"102\") retorna \"JB\"",
      "arb": "يحوّل تسلسلًا معينًا من الأرقام إلى أكبر سلسلة ممكنة من الأحرف الإنجليزية الكبيرة بترتيب معجمي، حيث يتوافق كل حرف مع موضعه في الأبجدية (A=1، B=2، ...، Z=26).\n\nتفسر الدالة تسلسل الأرقام كرقم مكون من رقم واحد أو رقمين (يمثل حرفًا) لتعظيم الترتيب المعجمي للسلسلة الناتجة.\n\nالأوساط:\n- encoded_sequence: سلسلة تتكون من أرقام تمثل مواضع الأحرف المشفرة.\n\nالقيم المعادة:\n- سلسلة من الأحرف الإنجليزية الكبيرة التي تمثل أكبر تفسير ممكن بترتيب معجمي للتسلسل المشفر.\n\nأمثلة:\n- max_lexicographic_string(\"123242526\") يعيد \"LCXYZ\"\n- max_lexicographic_string(\"231819\") يعيد \"WRS\"\n- max_lexicographic_string(\"102\") يعيد \"JB\"",
      "sw": "Inabadilisha mlolongo uliotolewa wa nambari kuwa kamba kubwa zaidi ya herufi kubwa za Kiingereza kwa mpangilio wa lexicographically, ambapo kila herufi inalingana na nafasi yake katika alfabeti (A=1, B=2, ..., Z=26).\n\n  Kazi hii inatafsiri mlolongo wa nambari kama nambari ya tarakimu moja au mbili (inayowakilisha herufi) ili kuongeza mpangilio wa lexicographic wa kamba inayotokana.\n\n  Hoja:\n  - encoded_sequence: Kamba inayojumuisha tarakimu zinazowakilisha nafasi za herufi zilizofichwa.\n\n  Inarudisha:\n  - Kamba ya herufi kubwa za Kiingereza inayowakilisha tafsiri kubwa zaidi ya lexicographically ya mlolongo uliofichwa.\n\n  Mifano:\n  - max_lexicographic_string(\"123242526\") inarudisha \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") inarudisha \"WRS\"\n  - max_lexicographic_string(\"102\") inarudisha \"JB\"",
      "tr": "Verilen bir sayı dizisini, her harfin alfabedeki konumuna karşılık geldiği (A=1, B=2, ..., Z=26) en büyük leksikografik sıradaki büyük harflerden oluşan bir dizeye dönüştürür.\n\n  Fonksiyon, sayı dizisini tek haneli veya iki haneli bir sayı (bir harfi temsil eden) olarak yorumlayarak ortaya çıkan dizenin leksikografik sırasını maksimize eder.\n\n  Argümanlar:\n  - encoded_sequence: Kodlanmış harf konumlarını temsil eden rakamlardan oluşan bir dize.\n\n  Döndürür:\n  - Kodlanmış dizinin leksikografik olarak en büyük olası yorumunu temsil eden büyük harflerden oluşan bir dize.\n\n  Örnekler:\n  - max_lexicographic_string(\"123242526\") \"LCXYZ\" döndürür\n  - max_lexicographic_string(\"231819\") \"WRS\" döndürür\n  - max_lexicographic_string(\"102\") \"JB\" döndürür",
      "vi": "Chuyển đổi một dãy số đã cho thành chuỗi lớn nhất có thể theo thứ tự từ điển của các chữ cái tiếng Anh viết hoa, trong đó mỗi chữ cái tương ứng với vị trí của nó trong bảng chữ cái (A=1, B=2, ..., Z=26).\n\nHàm này diễn giải dãy số dưới dạng số một chữ số hoặc số hai chữ số (đại diện cho một chữ cái) để tối đa hóa thứ tự từ điển của chuỗi kết quả.\n\nCác đối số:\n- encoded_sequence: Một chuỗi gồm các chữ số đại diện cho các vị trí chữ cái được mã hóa.\n\nTrả về:\n- Một chuỗi các chữ cái tiếng Anh viết hoa đại diện cho cách diễn giải lớn nhất có thể theo thứ tự từ điển của dãy được mã hóa.\n\nVí dụ:\n- max_lexicographic_string(\"123242526\") trả về \"LCXYZ\"\n- max_lexicographic_string(\"231819\") trả về \"WRS\"\n- max_lexicographic_string(\"102\") trả về \"JB\""
    },
    "docstring_bertscore": {
      "es": "0.9594265665875276",
      "arb": "0.962862077657907",
      "sw": "0.9646700113860865",
      "tr": "0.9722711988075297",
      "vi": "0.9642099834236098"
    }
  },
  {
    "task_id": "Rust/14",
    "prompt": {
      "en": "/*\n    Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "es": "/*\n    Calcula la suma máxima de números a lo largo de un camino desde la cima hasta la base de un triángulo numérico dado.\n\n    El camino se mueve hacia abajo ya sea al número más cercano a la izquierda o a la derecha en la siguiente fila. La diferencia entre el número de movimientos hacia la izquierda y hacia la derecha no debe exceder uno.\n\n    Argumentos:\n    - triangle: Un vector de vectores de i32, que representa las filas del triángulo numérico. Cada vector interno representa una fila en el triángulo.\n\n    Devuelve:\n    - La suma máxima alcanzable en cualquier camino válido desde la cima hasta la base del triángulo.\n\n    Ejemplos:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) devuelve 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) devuelve 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "arb": "/*\n    يحسب المجموع الأقصى للأرقام على طول مسار من الأعلى إلى الأسفل في مثلث رقمي معين.\n\n    يتحرك المسار لأسفل إلى إما الرقم الأقرب إلى اليسار أو اليمين في الصف التالي. يجب ألا يتجاوز الفرق بين عدد التحركات إلى اليسار واليمين واحدًا.\n\n    الوسائط:\n    - triangle: متجه من المتجهات من i32، يمثل الصفوف في المثلث الرقمي. كل متجه داخلي يمثل صفًا في المثلث.\n\n    يعيد:\n    - المجموع الأقصى الممكن تحقيقه على أي مسار صالح من الأعلى إلى الأسفل في المثلث.\n\n    أمثلة:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) يعيد 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) يعيد 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "sw": "/*\n    Hukokotoa jumla ya juu zaidi ya namba kando ya njia kutoka juu hadi chini ya pembetatu ya namba iliyotolewa.\n\n    Njia inasogea chini hadi namba ya karibu zaidi kushoto au kulia kwenye safu inayofuata. Tofauti kati ya idadi ya hatua kwenda kushoto na kulia haipaswi kuzidi moja.\n\n    Hoja:\n    - triangle: Kifurushi cha vifurushi vya i32, kinachowakilisha safu za pembetatu ya namba. Kila kifurushi cha ndani kinawakilisha safu katika pembetatu.\n\n    Inarudisha:\n    - Jumla ya juu zaidi inayoweza kupatikana kwenye njia yoyote halali kutoka juu hadi chini ya pembetatu.\n\n    Mifano:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) inarudisha 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) inarudisha 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "tr": "/*\n    Verilen sayısal bir üçgenin tepesinden tabanına kadar olan bir yoldaki maksimum sayı toplamını hesaplar.\n\n    Yol, bir sonraki satırdaki en yakın sol veya sağ sayıya doğru ilerler. Sola ve sağa yapılan hareketlerin sayısı arasındaki fark birden fazla olmamalıdır.\n\n    Argümanlar:\n    - triangle: Sayısal üçgenin satırlarını temsil eden i32 vektörlerinin bir vektörü. Her iç vektör üçgendeki bir satırı temsil eder.\n\n    Döndürür:\n    - Üçgenin tepesinden tabanına kadar herhangi bir geçerli yolda elde edilebilecek maksimum toplam.\n\n    Örnekler:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 döndürür\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 döndürür\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "vi": "/*\n    Tính tổng lớn nhất của các số dọc theo một đường đi từ đỉnh đến đáy của một tam giác số cho trước.\n\n    Đường đi di chuyển xuống đến số gần nhất bên trái hoặc bên phải ở hàng tiếp theo. Sự khác biệt giữa số lần di chuyển sang trái và sang phải không được vượt quá một.\n\n    Tham số:\n    - triangle: Một vector của các vector i32, đại diện cho các hàng của tam giác số. Mỗi vector bên trong đại diện cho một hàng trong tam giác.\n\n    Trả về:\n    - Tổng lớn nhất có thể đạt được trên bất kỳ đường đi hợp lệ nào từ đỉnh đến đáy của tam giác.\n\n    Ví dụ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) trả về 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) trả về 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9823634098375312",
      "arb": "0.9699976754662043",
      "sw": "0.9611405481454776",
      "tr": "0.9681674951353488",
      "vi": "0.9794941939834823"
    },
    "canonical_solution": "{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}",
    "instruction": {
      "en": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nيرجى تقديم وصف مختصر بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nRust kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9431116629804649",
      "tr": "0.9041278685074147",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]), 27);\n        assert_eq!(max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]), 8);      \n    }\n    \n\n}",
    "entry_point": "max_triangle_path_sum",
    "signature": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32",
    "docstring": {
      "en": "Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "es": "Calcula la suma máxima de números a lo largo de un camino desde la parte superior hasta la parte inferior de un triángulo numérico dado.\n\nEl camino se mueve hacia abajo ya sea al número más cercano a la izquierda o a la derecha en la siguiente fila. La diferencia entre el número de movimientos hacia la izquierda y hacia la derecha no debe exceder uno.\n\nArgumentos:\n- triangle: Un vector de vectores de i32, que representa las filas del triángulo numérico. Cada vector interno representa una fila en el triángulo.\n\nRetorna:\n- La suma máxima alcanzable en cualquier camino válido desde la parte superior hasta la parte inferior del triángulo.\n\nEjemplos:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) devuelve 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) devuelve 11",
      "arb": "يحسب مجموع الأرقام الأقصى على طول مسار من الأعلى إلى الأسفل في مثلث رقمي معين.\n\nالمسار يتحرك إلى الأسفل إما إلى الرقم الأقرب على اليسار أو اليمين في الصف التالي. يجب ألا يتجاوز الفرق بين عدد الحركات إلى اليسار واليمين واحدًا.\n\nالمعطيات:\n- triangle: متجه من المتجهات من i32، يمثل صفوف المثلث الرقمي. كل متجه داخلي يمثل صفًا في المثلث.\n\nالقيم المعادة:\n- المجموع الأقصى الممكن تحقيقه على أي مسار صالح من الأعلى إلى الأسفل في المثلث.\n\nأمثلة:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) يعيد 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) يعيد 11",
      "sw": "Hesabu jumla ya juu zaidi ya namba kwenye njia kutoka juu hadi chini ya pembetatu ya nambari iliyotolewa.\n\nNjia inashuka kwenda kwenye namba ya karibu kushoto au kulia kwenye safu inayofuata. Tofauti kati ya idadi ya hatua kwenda kushoto na kulia haipaswi kuzidi moja.\n\nHoja:\n- pembetatu: Kundi la vikundi vya i32, linalowakilisha safu za pembetatu ya nambari. Kila kundi la ndani linawakilisha safu katika pembetatu.\n\nRudisha:\n- Jumla ya juu zaidi inayoweza kupatikana kwenye njia yoyote halali kutoka juu hadi chini ya pembetatu.\n\nMifano:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) inarudisha 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) inarudisha 11",
      "tr": "Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    Yol, bir sonraki satırdaki en yakın sol veya sağ sayıya doğru hareket eder. Sola ve sağa yapılan hareketlerin sayısı arasındaki fark birden fazla olmamalıdır.\n\n    Argümanlar:\n    - triangle: Sayısal üçgenin satırlarını temsil eden i32 vektörlerinin bir vektörü. Her iç vektör üçgendeki bir satırı temsil eder.\n\n    Döndürür:\n    - Üçgenin tepesinden tabanına kadar herhangi bir geçerli yolda elde edilebilecek maksimum toplam.\n\n    Örnekler:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) Döndürür 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) Döndürür 11",
      "vi": "Tính tổng lớn nhất của các số dọc theo một đường đi từ đỉnh đến đáy của một tam giác số cho trước.\n\n    Đường đi di chuyển xuống đến số gần nhất bên trái hoặc bên phải ở hàng tiếp theo. Sự khác biệt giữa số lần di chuyển sang trái và sang phải không được vượt quá một.\n\n    Đối số:\n    - triangle: Một vector của các vector của i32, đại diện cho các hàng của tam giác số. Mỗi vector bên trong đại diện cho một hàng trong tam giác.\n\n    Trả về:\n    - Tổng lớn nhất có thể đạt được trên bất kỳ đường đi hợp lệ nào từ đỉnh đến đáy của tam giác.\n\n    Ví dụ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) trả về 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) trả về 11"
    },
    "docstring_bertscore": {
      "es": "0.987275539160524",
      "arb": "0.9703701074306447",
      "sw": "0.949397321388314",
      "tr": "0.9713471702749553",
      "vi": "0.9815094978294623"
    }
  },
  {
    "task_id": "Rust/15",
    "prompt": {
      "en": "\n/*\n    Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "es": "/*\n    Calcula el número de secciones distintas formadas en un plano por un conjunto dado de líneas.\n\n    Cada línea está representada por una tupla (pendiente, intersección-y), siguiendo la ecuación y = pendiente * x + intersección-y.\n    Esta función asume que las líneas no se superponen y que las líneas paralelas no contribuyen a nuevas secciones.\n\n    Argumentos:\n    - lines: Un segmento de tuplas, donde cada tupla representa una línea en el plano con su pendiente e intersección-y como (i32, i32).\n\n    Devuelve:\n    - Un entero que representa el número total de secciones distintas formadas en el plano.\n\n    Ejemplo:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) devuelve 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) devuelve 2 (Líneas paralelas)\n    - count_plane_sections(&[]) devuelve 0 (Sin líneas)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "arb": "/*\n    يحسب عدد الأقسام المميزة التي تتكون على مستوى بواسطة مجموعة معينة من الخطوط.\n\n    يتم تمثيل كل خط بواسطة زوج (الميل، التقاطع مع المحور y)، وفقًا للمعادلة y = الميل * x + التقاطع مع المحور y.\n    تفترض هذه الدالة أن الخطوط ليست متداخلة وأن الخطوط المتوازية لا تساهم في أقسام جديدة.\n\n    الوسائط:\n    - lines: جزء من الأزواج، حيث يمثل كل زوج خطًا على المستوى بميله وتقاطعه مع المحور y كـ (i32, i32).\n\n    يعيد:\n    - عدد صحيح يمثل إجمالي عدد الأقسام المميزة التي تتكون على المستوى.\n\n    مثال:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) يعيد 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) يعيد 2 (خطوط متوازية)\n    - count_plane_sections(&[]) يعيد 0 (لا خطوط)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "sw": "/*\n    Inahesabu idadi ya sehemu tofauti zinazoundwa kwenye ndege na seti fulani ya mistari.\n\n    Kila mstari unawakilishwa na jozi (mteremko, y-intercept), kufuatia mlinganyo y = mteremko * x + y-intercept.\n    Kazi hii inadhani mistari haipishani na mistari sambamba haichangii sehemu mpya.\n\n    Hoja:\n    - mistari: Kipande cha jozi, ambapo kila jozi inawakilisha mstari kwenye ndege na mteremko wake na y-intercept kama (i32, i32).\n\n    Inarudisha:\n    - Nambari kamili inayowakilisha jumla ya idadi ya sehemu tofauti zinazoundwa kwenye ndege.\n\n    Mfano:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) inarudisha 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) inarudisha 2 (Mistari sambamba)\n    - count_plane_sections(&[]) inarudisha 0 (Hakuna mistari)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "tr": "/*\n    Verilen bir dizi doğru tarafından bir düzlemde oluşturulan farklı bölümlerin sayısını hesaplar.\n\n    Her doğru, y = eğim * x + y-keseni denklemini takip eden bir (eğim, y-keseni) demeti ile temsil edilir.\n    Bu fonksiyon, doğruların üst üste gelmediğini ve paralel doğruların yeni bölümlere katkıda bulunmadığını varsayar.\n\n    Argümanlar:\n    - lines: Her demetin düzlemdeki bir doğruyu eğimi ve y-keseni ile (i32, i32) olarak temsil ettiği bir demet dilimi.\n\n    Döndürür:\n    - Düzlemde oluşturulan toplam farklı bölüm sayısını temsil eden bir tamsayı.\n\n    Örnek:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 döndürür\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 döndürür (Paralel doğrular)\n    - count_plane_sections(&[]) 0 döndürür (Doğru yok)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "vi": "/*\n    Tính toán số lượng phần khác biệt được hình thành trên mặt phẳng bởi một tập hợp các đường thẳng cho trước.\n\n    Mỗi đường thẳng được biểu diễn bằng một bộ đôi (hệ số góc, giao điểm y), theo phương trình y = hệ số góc * x + giao điểm y.\n    Hàm này giả định rằng các đường thẳng không trùng nhau và các đường thẳng song song không đóng góp vào các phần mới.\n\n    Tham số:\n    - lines: Một lát cắt của các bộ đôi, trong đó mỗi bộ đôi đại diện cho một đường thẳng trên mặt phẳng với hệ số góc và giao điểm y của nó là (i32, i32).\n\n    Trả về:\n    - Một số nguyên đại diện cho tổng số phần khác biệt được hình thành trên mặt phẳng.\n\n    Ví dụ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) trả về 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) trả về 2 (Các đường thẳng song song)\n    - count_plane_sections(&[]) trả về 0 (Không có đường thẳng)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9849303102516451",
      "arb": "0.977164060983562",
      "sw": "0.9780386305512586",
      "tr": "0.9908407558697192",
      "vi": "0.9633719618460235"
    },
    "canonical_solution": "{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}",
    "instruction": {
      "en": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nAşağıdaki Rust kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9116098777002368",
      "sw": "0.9153697521828462",
      "tr": "0.8516989821724938",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_plane_sections(&[(1, 1), (2, 2), (3, 3)]), 6);\n        assert_eq!(count_plane_sections(&[(0, 1), (0, 2)]), 3);\n    }\n    \n\n}\n ",
    "entry_point": "count_plane_sections",
    "signature": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize",
    "docstring": {
      "en": "Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)",
      "es": "Calcula el número de secciones distintas formadas en un plano por un conjunto dado de líneas.\n\n    Cada línea está representada por una tupla (pendiente, intersección en y), siguiendo la ecuación y = pendiente * x + intersección en y.\n    Esta función asume que las líneas no se superponen y que las líneas paralelas no contribuyen a nuevas secciones.\n\n    Argumentos:\n    - lines: Un segmento de tuplas, donde cada tupla representa una línea en el plano con su pendiente e intersección en y como (i32, i32).\n\n    Retorna:\n    - Un entero que representa el número total de secciones distintas formadas en el plano.\n\n    Ejemplo:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) retorna 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) retorna 2 (Líneas paralelas)\n    - count_plane_sections(&[]) retorna 0 (Sin líneas)",
      "arb": "يحسب عدد الأقسام المميزة التي تتشكل على مستوى بواسطة مجموعة معينة من الخطوط.\n\n    يتم تمثيل كل خط بواسطة زوج (الميل، التقاطع مع المحور y)، وفقًا للمعادلة y = الميل * x + التقاطع مع المحور y.\n    تفترض هذه الدالة أن الخطوط ليست متداخلة وأن الخطوط المتوازية لا تساهم في تشكيل أقسام جديدة.\n\n    الحجج:\n    - lines: جزء من الأزواج، حيث يمثل كل زوج خطًا على المستوى مع ميله وتقاطعه مع المحور y كـ (i32، i32).\n\n    يعيد:\n    - عدد صحيح يمثل العدد الإجمالي للأقسام المميزة التي تتشكل على المستوى.\n\n    مثال:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) يعيد 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) يعيد 2 (خطوط متوازية)\n    - count_plane_sections(&[]) يعيد 0 (لا خطوط)",
      "sw": "Hesabu idadi ya sehemu tofauti zinazoundwa kwenye ndege na seti fulani ya mistari.\n\n    Kila mstari unawakilishwa na jozi (mteremko, y-intercept), kufuatia mlinganyo y = mteremko * x + y-intercept.\n    Kazi hii inadhani mistari haipishani na mistari sambamba haichangii sehemu mpya.\n\n    Hoja:\n    - mistari: Sehemu ya jozi, ambapo kila jozi inawakilisha mstari kwenye ndege na mteremko wake na y-intercept kama (i32, i32).\n\n    Inarudisha:\n    - Nambari kamili inayowakilisha jumla ya idadi ya sehemu tofauti zinazoundwa kwenye ndege.\n\n    Mfano:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) inarudisha 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) inarudisha 2 (Mistari sambamba)\n    - count_plane_sections(&[]) inarudisha 0 (Hakuna mistari)",
      "tr": "Belirli bir dizi doğru tarafından bir düzlemde oluşturulan farklı bölümlerin sayısını hesaplar.\n\n    Her doğru, y = eğim * x + y-keseni denklemini takip eden bir (eğim, y-keseni) demeti ile temsil edilir.\n    Bu fonksiyon, doğruların üst üste gelmediğini ve paralel doğruların yeni bölümlere katkıda bulunmadığını varsayar.\n\n    Argümanlar:\n    - lines: Her bir demetin eğim ve y-keseni olarak (i32, i32) ile düzlemde bir doğruyu temsil ettiği demet dilimi.\n\n    Döndürür:\n    - Düzlemde oluşturulan toplam farklı bölüm sayısını temsil eden bir tamsayı.\n\n    Örnek:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 döndürür\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 döndürür (Paralel doğrular)\n    - count_plane_sections(&[]) 0 döndürür (Doğru yok)",
      "vi": "Tính toán số lượng phần riêng biệt được tạo thành trên một mặt phẳng bởi một tập hợp các đường thẳng cho trước.\n\n    Mỗi đường thẳng được biểu diễn bởi một bộ đôi (hệ số góc, giao điểm trục y), theo phương trình y = hệ số góc * x + giao điểm trục y.\n    Hàm này giả định rằng các đường thẳng không trùng nhau và các đường thẳng song song không tạo ra các phần mới.\n\n    Đối số:\n    - lines: Một lát cắt của các bộ đôi, trong đó mỗi bộ đôi đại diện cho một đường thẳng trên mặt phẳng với hệ số góc và giao điểm trục y là (i32, i32).\n\n    Trả về:\n    - Một số nguyên đại diện cho tổng số phần riêng biệt được tạo thành trên mặt phẳng.\n\n    Ví dụ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) trả về 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) trả về 2 (Các đường thẳng song song)\n    - count_plane_sections(&[]) trả về 0 (Không có đường thẳng nào)"
    },
    "docstring_bertscore": {
      "es": "0.9793094677291199",
      "arb": "0.9681218101477108",
      "sw": "0.9748186334443021",
      "tr": "0.9703709019521688",
      "vi": "0.9611892125888312"
    }
  },
  {
    "task_id": "Rust/16",
    "prompt": {
      "en": "\n/*\n  Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "es": "/*\n  Calcula el número de pesos distintos que se pueden medir utilizando un conjunto dado de pesos en una balanza.\n  Los pesos pueden colocarse en cualquiera de los lados de la balanza, y el mismo peso no puede usarse más de una vez.\n\n  Argumentos:\n  - weights: Un slice de enteros que representa los pesos.\n\n  Devuelve:\n  - El número total de pesos distintos que se pueden medir.\n\n  Ejemplo:\n  - distinct_weights_count(&[1, 4, 6]) devuelve 10\n  - distinct_weights_count(&[2, 3]) devuelve 5 (pesos: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) devuelve 1 (solo se puede medir cero)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "arb": "/*\n  يحسب عدد الأوزان المميزة التي يمكن قياسها باستخدام مجموعة معينة من الأوزان على ميزان.\n  يمكن وضع الأوزان على أي جانب من الميزان، ولا يمكن استخدام نفس الوزن أكثر من مرة.\n\n  الوسائط:\n  - weights: جزء من الأعداد الصحيحة يمثل الأوزان.\n\n  يعيد:\n  - العدد الإجمالي للأوزان المميزة التي يمكن قياسها.\n\n  مثال:\n  - distinct_weights_count(&[1, 4, 6]) يعيد 10\n  - distinct_weights_count(&[2, 3]) يعيد 5 (الأوزان: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) يعيد 1 (يمكن قياس الصفر فقط)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya uzito tofauti ambao unaweza kupimwa kwa kutumia seti iliyotolewa ya uzito kwenye mizani.\n  Uzito unaweza kuwekwa upande wowote wa mizani, na uzito huo huo hauwezi kutumika zaidi ya mara moja.\n\n  Hoja:\n  - weights: Sehemu ya nambari za mzima inayowakilisha uzito.\n\n  Inarudisha:\n  - Jumla ya idadi ya uzito tofauti ambao unaweza kupimwa.\n\n  Mfano:\n  - distinct_weights_count(&[1, 4, 6]) inarudisha 10\n  - distinct_weights_count(&[2, 3]) inarudisha 5 (uzito: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) inarudisha 1 (ni sifuri tu inaweza kupimwa)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "tr": "/*\n  Verilen bir ağırlık seti kullanılarak bir terazi üzerinde ölçülebilecek farklı ağırlıkların sayısını hesaplar.\n  Ağırlıklar terazinin her iki tarafına da yerleştirilebilir ve aynı ağırlık birden fazla kez kullanılamaz.\n\n  Argümanlar:\n  - weights: Ağırlıkları temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Ölçülebilecek toplam farklı ağırlık sayısı.\n\n  Örnek:\n  - distinct_weights_count(&[1, 4, 6]) 10 döndürür\n  - distinct_weights_count(&[2, 3]) 5 döndürür (ağırlıklar: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 döndürür (sadece sıfır ölçülebilir)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "vi": "/*\n  Tính số lượng trọng lượng khác nhau có thể đo được bằng cách sử dụng một tập hợp trọng lượng cho trước trên một cân thăng bằng.\n  Các trọng lượng có thể được đặt ở bất kỳ bên nào của cân, và cùng một trọng lượng không thể được sử dụng nhiều hơn một lần.\n\n  Tham số:\n  - weights: Một mảng số nguyên đại diện cho các trọng lượng.\n\n  Trả về:\n  - Tổng số lượng trọng lượng khác nhau có thể đo được.\n\n  Ví dụ:\n  - distinct_weights_count(&[1, 4, 6]) trả về 10\n  - distinct_weights_count(&[2, 3]) trả về 5 (trọng lượng: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) trả về 1 (chỉ có thể đo được số không)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9937042114427181",
      "arb": "0.9879443276534685",
      "sw": "0.9740926394016195",
      "tr": "0.9661341159246947",
      "vi": "0.9765894232912281"
    },
    "canonical_solution": "{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}",
    "instruction": {
      "en": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nRust kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9153697521828462",
      "tr": "0.868483845261085",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(distinct_weights_count(&[1, 4, 6]), 10);\n        assert_eq!(distinct_weights_count(&[2, 3]), 4);\n        assert_eq!(distinct_weights_count(&[]), 0);\n        assert_eq!(distinct_weights_count(&[1, 2, 2]), 5);  \n        \n    }\n    \n\n}",
    "entry_point": "distinct_weights_count",
    "signature": "fn distinct_weights_count(weights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)",
      "es": "Calcula el número de pesos distintos que se pueden medir utilizando un conjunto dado de pesas en una balanza.\n  Las pesas se pueden colocar en cualquiera de los lados de la balanza, y la misma pesa no se puede usar más de una vez.\n\n  Argumentos:\n  - weights: Un slice de enteros que representa las pesas.\n\n  Retorna:\n  - El número total de pesos distintos que se pueden medir.\n\n  Ejemplo:\n  - distinct_weights_count(&[1, 4, 6]) Devuelve 10\n  - distinct_weights_count(&[2, 3]) Devuelve 5 (pesos: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) Devuelve 1 (solo se puede medir cero)",
      "arb": "يحسب عدد الأوزان المميزة التي يمكن قياسها باستخدام مجموعة معينة من الأوزان على ميزان.\nيمكن وضع الأوزان على أي جانب من الميزان، ولا يمكن استخدام نفس الوزن أكثر من مرة.\n\nالمعطيات:\n- weights: مجموعة من الأعداد الصحيحة تمثل الأوزان.\n\nالقيم المعادة:\n- العدد الإجمالي للأوزان المميزة التي يمكن قياسها.\n\nمثال:\n- distinct_weights_count(&[1, 4, 6]) يعيد 10\n- distinct_weights_count(&[2, 3]) يعيد 5 (الأوزان: 1، 2، 3، 5)\n- distinct_weights_count(&[]) يعيد 1 (يمكن قياس الصفر فقط)",
      "sw": "Inahesabu idadi ya uzito tofauti ambao unaweza kupimwa kwa kutumia seti fulani ya uzito kwenye mizani ya usawa. Uzito unaweza kuwekwa upande wowote wa mizani, na uzito huo huo hauwezi kutumiwa zaidi ya mara moja.\n\nHoja:\n- weights: Sehemu ya nambari za mzima inayowakilisha uzito.\n\nInarejesha:\n- Jumla ya idadi ya uzito tofauti ambao unaweza kupimwa.\n\nMfano:\n- distinct_weights_count(&[1, 4, 6]) inarejesha 10\n- distinct_weights_count(&[2, 3]) inarejesha 5 (uzito: 1, 2, 3, 5)\n- distinct_weights_count(&[]) inarejesha 1 (ni sifuri pekee inayoweza kupimwa)",
      "tr": "Verilen bir ağırlık seti kullanılarak bir terazi üzerinde ölçülebilecek farklı ağırlıkların sayısını hesaplar. \nAğırlıklar terazinin her iki tarafına da yerleştirilebilir ve aynı ağırlık birden fazla kez kullanılamaz.\n\nArgümanlar:\n- weights: Ağırlıkları temsil eden bir tamsayı dilimi.\n\nDöndürür:\n- Ölçülebilecek toplam farklı ağırlık sayısı.\n\nÖrnek:\n- distinct_weights_count(&[1, 4, 6]) 10 döndürür\n- distinct_weights_count(&[2, 3]) 5 döndürür (ağırlıklar: 1, 2, 3, 5)\n- distinct_weights_count(&[]) 1 döndürür (sadece sıfır ölçülebilir)",
      "vi": "Tính toán số lượng trọng lượng khác nhau có thể được đo bằng cách sử dụng một tập hợp các quả cân trên một cân thăng bằng. Các quả cân có thể được đặt ở bất kỳ bên nào của cân, và cùng một quả cân không thể được sử dụng nhiều hơn một lần.\n\nTham số:\n- weights: Một mảng số nguyên đại diện cho các quả cân.\n\nTrả về:\n- Tổng số lượng trọng lượng khác nhau có thể được đo.\n\nVí dụ:\n- distinct_weights_count(&[1, 4, 6]) trả về 10\n- distinct_weights_count(&[2, 3]) trả về 5 (trọng lượng: 1, 2, 3, 5)\n- distinct_weights_count(&[]) trả về 1 (chỉ có số không có thể được đo)"
    },
    "docstring_bertscore": {
      "es": "0.9931138819502825",
      "arb": "0.9589458810654231",
      "sw": "0.9727183157952392",
      "tr": "0.9636031676095481",
      "vi": "0.9742221464100543"
    }
  },
  {
    "task_id": "Rust/17",
    "prompt": {
      "en": "/*\n  Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "es": "/*\n  Encuentra el sueño de mayor valor que está dentro de la capacidad del usuario.\n\n  Esta función toma un arreglo de valores de sueños y la puntuación de capacidad del usuario. Devuelve el valor del sueño más alto que no excede la capacidad del usuario.\n\n  Argumentos:\n  - dreams: Un arreglo de enteros sin signo de 32 bits, cada uno representando la capacidad requerida para un sueño.\n  - ability: Un entero sin signo de 32 bits que representa la puntuación de capacidad del usuario.\n\n  Devuelve:\n  - El valor del sueño que es el más alto pero aún dentro de la capacidad del usuario.\n\n  Ejemplos:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) devuelve 98\n  - max_dream_within_ability(&[20, 40, 60], 50) devuelve 40\n  - max_dream_within_ability(&[10, 20, 30], 5) devuelve 0 (Ningún sueño dentro de la capacidad)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "arb": "/*\n  يجد الحلم الأعلى قيمة الذي يكون ضمن قدرة المستخدم.\n\n  تأخذ هذه الدالة مصفوفة من قيم الأحلام ودرجة قدرة المستخدم. وتعيد أعلى قيمة حلم لا تتجاوز قدرة المستخدم.\n\n  الوسائط:\n  - dreams: مصفوفة من الأعداد الصحيحة غير الموقعة 32 بت، كل منها يمثل القدرة المطلوبة لحلم.\n  - ability: عدد صحيح غير موقع 32 بت يمثل درجة قدرة المستخدم.\n\n  يعيد:\n  - قيمة الحلم الذي يكون الأعلى ولكنه لا يزال ضمن قدرة المستخدم.\n\n  أمثلة:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) يعيد 98\n  - max_dream_within_ability(&[20, 40, 60], 50) يعيد 40\n  - max_dream_within_ability(&[10, 20, 30], 5) يعيد 0 (لا يوجد حلم ضمن القدرة)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "sw": "/*\n  Inapata ndoto yenye thamani ya juu zaidi ambayo iko ndani ya uwezo wa mtumiaji.\n\n  Kazi hii inachukua safu ya thamani za ndoto na alama ya uwezo wa mtumiaji. Inarudisha thamani ya juu zaidi ya ndoto ambayo haizidi uwezo wa mtumiaji.\n\n  Hoja:\n  - dreams: Safu ya nambari zisizo na ishara za biti 32, kila moja ikiwakilisha uwezo unaohitajika kwa ndoto.\n  - ability: Nambari isiyo na ishara ya biti 32 inayowakilisha alama ya uwezo wa mtumiaji.\n\n  Inarudisha:\n  - Thamani ya ndoto ambayo ni ya juu zaidi lakini bado iko ndani ya uwezo wa mtumiaji.\n\n  Mifano:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) inarudisha 98\n  - max_dream_within_ability(&[20, 40, 60], 50) inarudisha 40\n  - max_dream_within_ability(&[10, 20, 30], 5) inarudisha 0 (Hakuna ndoto ndani ya uwezo)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "tr": "/*\n  Kullanıcının yeteneği dahilinde olan en yüksek değerli hayali bulur.\n\n  Bu fonksiyon, hayal değerlerinin bir dizisini ve kullanıcının yetenek puanını alır. Kullanıcının yeteneğini aşmayan en yüksek hayal değerini döndürür.\n\n  Argümanlar:\n  - dreams: Her biri bir hayal için gereken yeteneği temsil eden, 32-bit işaretsiz tamsayıların bir dizisi.\n  - ability: Kullanıcının yetenek puanını temsil eden, 32-bit işaretsiz bir tamsayı.\n\n  Döndürür:\n  - Kullanıcının yeteneği dahilinde olan en yüksek hayalin değeri.\n\n  Örnekler:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 döndürür\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 döndürür\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 döndürür (Yetenek dahilinde hayal yok)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "vi": "/*\n  Tìm giấc mơ có giá trị cao nhất nằm trong khả năng của người dùng.\n\n  Hàm này nhận một mảng các giá trị giấc mơ và điểm khả năng của người dùng. Nó trả về giá trị giấc mơ cao nhất mà không vượt quá khả năng của người dùng.\n\n  Tham số:\n  - dreams: Một mảng các số nguyên không dấu 32-bit, mỗi số đại diện cho khả năng cần thiết cho một giấc mơ.\n  - ability: Một số nguyên không dấu 32-bit đại diện cho điểm khả năng của người dùng.\n\n  Trả về:\n  - Giá trị của giấc mơ cao nhất nhưng vẫn nằm trong khả năng của người dùng.\n\n  Ví dụ:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) trả về 98\n  - max_dream_within_ability(&[20, 40, 60], 50) trả về 40\n  - max_dream_within_ability(&[10, 20, 30], 5) trả về 0 (Không có giấc mơ nào trong khả năng)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 "
    },
    "prompt_bertscore": {
      "es": "0.9611850413508294",
      "arb": "0.9845876728443599",
      "sw": "0.986535045100026",
      "tr": "0.9751783530643562",
      "vi": "0.9698963739718764"
    },
    "canonical_solution": "{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}",
    "instruction": {
      "en": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9041177383579819",
      "sw": "0.9153697521828462",
      "tr": "0.8418600248783117",
      "vi": "0.9220453220286667"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_dream_within_ability(&[50, 69, 240, 135, 98], 100), 98);\n        assert_eq!(max_dream_within_ability(&[20, 40, 60], 50), 40);\n        assert_eq!(max_dream_within_ability(&[10, 20, 30], 5), 0); // No dream within ability\n        assert_eq!(max_dream_within_ability(&[120, 200, 300, 400], 350), 300);\n    \n    }\n    \n\n}",
    "entry_point": "max_dream_within_ability",
    "signature": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
    "docstring": {
      "en": "Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)",
      "es": "Encuentra el sueño de mayor valor que esté dentro de la capacidad del usuario.\n\n  Esta función toma un arreglo de valores de sueños y la puntuación de capacidad del usuario. Devuelve el valor del sueño más alto que no excede la capacidad del usuario.\n\n  Argumentos:\n  - dreams: Un arreglo de enteros sin signo de 32 bits, cada uno representando la capacidad requerida para un sueño.\n  - ability: Un entero sin signo de 32 bits que representa la puntuación de capacidad del usuario.\n\n  Devuelve:\n  - El valor del sueño que es el más alto pero aún dentro de la capacidad del usuario.\n\n  Ejemplos:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) devuelve 98\n  - max_dream_within_ability(&[20, 40, 60], 50) devuelve 40\n  - max_dream_within_ability(&[10, 20, 30], 5) devuelve 0 (Ningún sueño dentro de la capacidad)",
      "arb": "يعثر على الحلم الأعلى قيمة الذي يقع ضمن قدرة المستخدم.\n\nتأخذ هذه الدالة مصفوفة من قيم الأحلام ودرجة قدرة المستخدم. تُرجع أعلى قيمة حلم لا تتجاوز قدرة المستخدم.\n\nالأوساط:\n- dreams: مصفوفة من الأعداد الصحيحة غير الموقعة 32 بت، كل منها يمثل القدرة المطلوبة لحلم.\n- ability: عدد صحيح غير موقع 32 بت يمثل درجة قدرة المستخدم.\n\nالقيم المعادة:\n- قيمة الحلم الذي هو الأعلى ولكنه لا يزال ضمن قدرة المستخدم.\n\nأمثلة:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) يعيد 98\n- max_dream_within_ability(&[20, 40, 60], 50) يعيد 40\n- max_dream_within_ability(&[10, 20, 30], 5) يعيد 0 (لا يوجد حلم ضمن القدرة)",
      "sw": "Inapata ndoto yenye thamani ya juu zaidi ambayo iko ndani ya uwezo wa mtumiaji.\n\n  Kazi hii inachukua safu ya thamani za ndoto na alama ya uwezo wa mtumiaji. Inarudisha thamani ya juu zaidi ya ndoto ambayo haizidi uwezo wa mtumiaji.\n\n  Hoja:\n  - dreams: Safu ya nambari zisizo na ishara za biti 32, kila moja ikiwakilisha uwezo unaohitajika kwa ndoto.\n  - ability: Nambari isiyo na ishara ya biti 32 inayowakilisha alama ya uwezo wa mtumiaji.\n\n  Inarudisha:\n  - Thamani ya ndoto ambayo ni ya juu zaidi lakini bado iko ndani ya uwezo wa mtumiaji.\n\n  Mifano:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) inarudisha 98\n  - max_dream_within_ability(&[20, 40, 60], 50) inarudisha 40\n  - max_dream_within_ability(&[10, 20, 30], 5) inarudisha 0 (Hakuna ndoto ndani ya uwezo)",
      "tr": "Kullanıcının yeteneği dahilinde en yüksek değerli hayali bulur.\n\nBu fonksiyon, bir dizi hayal değerini ve kullanıcının yetenek puanını alır. Kullanıcının yeteneğini aşmayan en yüksek hayal değerini döndürür.\n\nArgümanlar:\n- dreams: Her biri bir hayal için gereken yeteneği temsil eden, işaretsiz 32-bit tamsayılarından oluşan bir dizi.\n- ability: Kullanıcının yetenek puanını temsil eden, işaretsiz 32-bit bir tamsayı.\n\nDöndürülenler:\n- Kullanıcının yeteneği dahilinde olan en yüksek hayalin değeri.\n\nÖrnekler:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 döndürür\n- max_dream_within_ability(&[20, 40, 60], 50) 40 döndürür\n- max_dream_within_ability(&[10, 20, 30], 5) 0 döndürür (Yetenek dahilinde hayal yok)",
      "vi": "Tìm giấc mơ có giá trị cao nhất nằm trong khả năng của người dùng.\n\nHàm này nhận một mảng các giá trị giấc mơ và điểm khả năng của người dùng. Nó trả về giá trị giấc mơ cao nhất không vượt quá khả năng của người dùng.\n\nCác đối số:\n- dreams: Một mảng các số nguyên không dấu 32-bit, mỗi số đại diện cho khả năng cần thiết cho một giấc mơ.\n- ability: Một số nguyên không dấu 32-bit đại diện cho điểm khả năng của người dùng.\n\nTrả về:\n- Giá trị của giấc mơ cao nhất nhưng vẫn nằm trong khả năng của người dùng.\n\nVí dụ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) trả về 98\n- max_dream_within_ability(&[20, 40, 60], 50) trả về 40\n- max_dream_within_ability(&[10, 20, 30], 5) trả về 0 (Không có giấc mơ nào trong khả năng)"
    },
    "docstring_bertscore": {
      "es": "0.9534960593009689",
      "arb": "0.9725685484879388",
      "sw": "0.9800608864605748",
      "tr": "0.9734655632886924",
      "vi": "0.9668674592914754"
    }
  },
  {
    "task_id": "Rust/18",
    "prompt": {
      "en": "/*\n  Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "es": "/*\n  Calcula el valor del polinomio f(x) = ax^3 + bx^2 + cx + d para un conjunto dado de coeficientes y el valor de x.\n  Esta función utiliza números reales tanto para los coeficientes como para el valor de x, proporcionando el valor del polinomio como un número de punto flotante de doble precisión.\n\n  Argumentos:\n  - x: El valor en el cual se evalúa el polinomio.\n  - a: El coeficiente de x^3.\n  - b: El coeficiente de x^2.\n  - c: El coeficiente de x.\n  - d: El término constante en el polinomio.\n\n  Retorna:\n  - El valor calculado del polinomio en x, como un número de punto flotante de doble precisión.\n\n  Ejemplo:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) Devuelve 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "arb": "/*\n  يحسب قيمة كثير الحدود f(x) = ax^3 + bx^2 + cx + d لمجموعة معينة من المعاملات وقيمة x.\n  تستخدم هذه الدالة الأعداد الحقيقية لكل من المعاملات وقيمة x، وتوفر قيمة كثير الحدود كرقم عشري مزدوج الدقة.\n\n  الوسائط:\n  - x: القيمة التي يتم تقييم كثير الحدود عندها.\n  - a: معامل x^3.\n  - b: معامل x^2.\n  - c: معامل x.\n  - d: الحد الثابت في كثير الحدود.\n\n  يعيد:\n  - القيمة المحسوبة لكثير الحدود عند x، كرقم عشري مزدوج الدقة.\n\n  مثال:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) يعيد 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "sw": "/*\n  Inahesabu thamani ya polinomu f(x) = ax^3 + bx^2 + cx + d kwa seti fulani ya vigezo na thamani ya x.\n  Kazi hii hutumia namba halisi kwa vigezo vyote na thamani ya x, ikitoa thamani ya polinomu kama namba ya nukta-mbili ya usahihi wa juu.\n\n  Hoja:\n  - x: Thamani ambayo polinomu inakokotolewa.\n  - a: Kigezo cha x^3.\n  - b: Kigezo cha x^2.\n  - c: Kigezo cha x.\n  - d: Neno la kudumu katika polinomu.\n\n  Inarudisha:\n  - Thamani iliyokokotolewa ya polinomu katika x, kama namba ya nukta-mbili ya usahihi wa juu.\n\n  Mfano:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) inarudisha 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "tr": "/*\n  Verilen bir katsayı kümesi ve x değeri için f(x) = ax^3 + bx^2 + cx + d polinomunun değerini hesaplar.\n  Bu fonksiyon, hem katsayılar hem de x değeri için gerçek sayılar kullanır ve polinomun değerini çift hassasiyetli kayan nokta sayısı olarak sağlar.\n\n  Argümanlar:\n  - x: Polinomun değerlendirildiği değer.\n  - a: x^3'ün katsayısı.\n  - b: x^2'nin katsayısı.\n  - c: x'in katsayısı.\n  - d: Polinomdaki sabit terim.\n\n  Döndürür:\n  - x'te polinomun hesaplanan değerini, çift hassasiyetli kayan nokta sayısı olarak.\n\n  Örnek:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 döndürür\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "vi": "/*\n  Tính giá trị của đa thức f(x) = ax^3 + bx^2 + cx + d cho một tập hợp các hệ số và giá trị của x.\n  Hàm này sử dụng số thực cho cả hệ số và giá trị của x, cung cấp giá trị của đa thức dưới dạng số dấu phẩy động có độ chính xác kép.\n\n  Tham số:\n  - x: Giá trị tại đó đa thức được đánh giá.\n  - a: Hệ số của x^3.\n  - b: Hệ số của x^2.\n  - c: Hệ số của x.\n  - d: Hằng số trong đa thức.\n\n  Trả về:\n  - Giá trị đã tính toán của đa thức tại x, dưới dạng số dấu phẩy động có độ chính xác kép.\n\n  Ví dụ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) trả về 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 "
    },
    "prompt_bertscore": {
      "es": "0.9802756059024735",
      "arb": "0.9619275217151378",
      "sw": "0.9579040647168952",
      "tr": "0.959287326690422",
      "vi": "0.9575310368613116"
    },
    "canonical_solution": "{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}",
    "instruction": {
      "en": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nRust kodunun işlevini açıklayan özlü bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8953887276330227",
      "sw": "0.9431116629804649",
      "tr": "0.8690288870266447",
      "vi": "0.9074056670552524"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert!((polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) - 33.0838692).abs() < 1e-7);\n        assert!((polynomial_value(0.0, 1.0, 1.0, 1.0, 1.0) - 1.0).abs() < 1e-7);\n        assert!((polynomial_value(1.0, 1.0, 1.0, 1.0, 1.0) - 4.0).abs() < 1e-7);\n    }\n    \n\n}",
    "entry_point": "polynomial_value",
    "signature": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64",
    "docstring": {
      "en": "Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "es": "Calcula el valor del polinomio f(x) = ax^3 + bx^2 + cx + d para un conjunto dado de coeficientes y el valor de x. \n  Esta función utiliza números reales tanto para los coeficientes como para el valor de x, proporcionando el valor del polinomio como un número de punto flotante de doble precisión.\n\n  Argumentos:\n  - x: El valor en el cual se evalúa el polinomio.\n  - a: El coeficiente de x^3.\n  - b: El coeficiente de x^2.\n  - c: El coeficiente de x.\n  - d: El término constante en el polinomio.\n\n  Retorna:\n  - El valor calculado del polinomio en x, como un número de punto flotante de doble precisión.\n\n  Ejemplo:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) devuelve 33.0838692",
      "arb": "يحسب قيمة كثير الحدود f(x) = ax^3 + bx^2 + cx + d لمجموعة معينة من المعاملات وقيمة x. تستخدم هذه الدالة الأعداد الحقيقية لكل من المعاملات وقيمة x، وتوفر قيمة كثير الحدود كرقم عشري ذو دقة مزدوجة.\n\nالأوساط:\n- x: القيمة التي يتم تقييم كثير الحدود عندها.\n- a: معامل x^3.\n- b: معامل x^2.\n- c: معامل x.\n- d: الحد الثابت في كثير الحدود.\n\nالقيم المعادة:\n- القيمة المحسوبة لكثير الحدود عند x، كرقم عشري ذو دقة مزدوجة.\n\nمثال:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) يعيد 33.0838692",
      "sw": "Inahesabu thamani ya polinomu f(x) = ax^3 + bx^2 + cx + d kwa seti fulani ya viambajengo na thamani ya x. \n  Kazi hii hutumia namba halisi kwa viambajengo vyote na thamani ya x, ikitoa thamani ya polinomu kama namba ya nukta-mbili ya usahihi wa juu.\n\n  Hoja:\n  - x: Thamani ambayo polinomu inakadiria.\n  - a: Kiambajengo cha x^3.\n  - b: Kiambajengo cha x^2.\n  - c: Kiambajengo cha x.\n  - d: Neno la mara kwa mara katika polinomu.\n\n  Inarejesha:\n  - Thamani iliyokokotolewa ya polinomu kwa x, kama namba ya nukta-mbili ya usahihi wa juu.\n\n  Mfano:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) inarejesha 33.0838692",
      "tr": "Verilen katsayılar kümesi ve x değeri için f(x) = ax^3 + bx^2 + cx + d polinomunun değerini hesaplar. \n  Bu fonksiyon, hem katsayılar hem de x değeri için reel sayılar kullanır ve polinomun değerini çift hassasiyetli kayan noktalı sayı olarak sağlar.\n\n  Argümanlar:\n  - x: Polinomun değerlendirildiği değer.\n  - a: x^3'ün katsayısı.\n  - b: x^2'nin katsayısı.\n  - c: x'in katsayısı.\n  - d: Polinomdaki sabit terim.\n\n  Döndürür:\n  - x'te polinomun hesaplanan değerini, çift hassasiyetli kayan noktalı sayı olarak.\n\n  Örnek:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 döndürür.",
      "vi": "Tính giá trị của đa thức f(x) = ax^3 + bx^2 + cx + d cho một tập hợp các hệ số và giá trị của x đã cho. \nHàm này sử dụng số thực cho cả các hệ số và giá trị của x, cung cấp giá trị của đa thức dưới dạng số dấu phẩy động có độ chính xác kép.\n\nTham số:\n- x: Giá trị tại đó đa thức được đánh giá.\n- a: Hệ số của x^3.\n- b: Hệ số của x^2.\n- c: Hệ số của x.\n- d: Hằng số trong đa thức.\n\nTrả về:\n- Giá trị đã tính toán của đa thức tại x, dưới dạng số dấu phẩy động có độ chính xác kép.\n\nVí dụ:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) trả về 33.0838692"
    },
    "docstring_bertscore": {
      "es": "0.9900134603327089",
      "arb": "0.9444238152775813",
      "sw": "0.9639003186595764",
      "tr": "0.8532445251673263",
      "vi": "0.9669008291954894"
    }
  },
  {
    "task_id": "Rust/19",
    "prompt": {
      "en": "/*\n  Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "es": "/*\n  Calcula el número mínimo de cubos que una jirafa necesita beber para saciar su sed, dada la capacidad de los cubos.\n  \n  Una jirafa necesita beber 20 litros de agua para saciar su sed. Esta función determina cuántos cubos de agua necesitaría, basándose en el volumen de cada cubo. Los cubos son de forma cilíndrica, con una altura y un radio dados.\n\n  Argumentos:\n  - height: La altura del cubo en centímetros (entero).\n  - radius: El radio de la base del cubo en centímetros (entero).\n\n  Devuelve:\n  - Un entero que representa el número mínimo de cubos necesarios para que la jirafa sacie su sed.\n\n  Ejemplo:\n  - min_buckets_needed(23, 11) devuelve 3\n  - min_buckets_needed(30, 10) devuelve 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "arb": "/*\n  يحسب الحد الأدنى لعدد الدلاء التي يحتاجها الزرافة للشرب لإرواء عطشه، بالنظر إلى حجم الدلاء.\n\n  يحتاج الزرافة إلى شرب 20 لترًا من الماء لإرواء عطشه. تحدد هذه الدالة عدد الدلاء من الماء التي سيحتاجها، بناءً على حجم كل دلو. الدلاء أسطوانية الشكل، مع ارتفاع ونصف قطر معطى.\n\n  الوسائط:\n  - height: ارتفاع الدلو بالسنتيمترات (عدد صحيح).\n  - radius: نصف قطر قاعدة الدلو بالسنتيمترات (عدد صحيح).\n\n  يعيد:\n  - عدد صحيح يمثل الحد الأدنى لعدد الدلاء اللازمة للزرافة لإرواء عطشه.\n\n  مثال:\n  - min_buckets_needed(23, 11) يعيد 3\n  - min_buckets_needed(30, 10) يعيد 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ndogo ya ndoo ambazo twiga anahitaji kunywa ili kuzima kiu chake, kutokana na ukubwa wa ndoo.\n\n  Twiga anahitaji kunywa lita 20 za maji ili kuzima kiu chake. Kazi hii inaamua ni ndoo ngapi za maji zitahitajika, kulingana na ujazo wa kila ndoo. Ndoo ni za umbo la mviringo, zikiwa na urefu na kipenyo vilivyotolewa.\n\n  Hoja:\n  - height: Urefu wa ndoo kwa sentimita (nambari kamili).\n  - radius: Kipenyo cha msingi wa ndoo kwa sentimita (nambari kamili).\n\n  Inarudisha:\n  - Nambari kamili inayowakilisha idadi ndogo ya ndoo zinazohitajika kwa twiga kuzima kiu chake.\n\n  Mfano:\n  - min_buckets_needed(23, 11) inarudisha 3\n  - min_buckets_needed(30, 10) inarudisha 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "tr": "/*\n  Bir zürafanın susuzluğunu gidermek için içmesi gereken minimum kova sayısını, kovaların boyutuna göre hesaplar.\n  \n  Bir zürafa susuzluğunu gidermek için 20 litre su içmelidir. Bu fonksiyon, her bir kovanın hacmine bağlı olarak kaç kova suya ihtiyaç duyulacağını belirler. Kovalar, verilen yükseklik ve yarıçap ile silindirik şekildedir.\n\n  Argümanlar:\n  - height: Kovanın yüksekliği santimetre cinsinden (tam sayı).\n  - radius: Kovanın tabanının yarıçapı santimetre cinsinden (tam sayı).\n\n  Döndürür:\n  - Zürafanın susuzluğunu gidermesi için gereken minimum kova sayısını temsil eden bir tam sayı.\n\n  Örnek:\n  - min_buckets_needed(23, 11) 3 döndürür\n  - min_buckets_needed(30, 10) 3 döndürür\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "vi": "/*\n  Tính toán số lượng xô tối thiểu mà một con hươu cao cổ cần để uống cho hết khát, dựa trên kích thước của các xô.\n\n  Một con hươu cao cổ cần uống 20 lít nước để hết khát. Hàm này xác định số lượng xô nước cần thiết, dựa trên thể tích của mỗi xô. Các xô có hình trụ, với chiều cao và bán kính cho trước.\n\n  Tham số:\n  - height: Chiều cao của xô tính bằng centimet (số nguyên).\n  - radius: Bán kính của đáy xô tính bằng centimet (số nguyên).\n\n  Trả về:\n  - Một số nguyên đại diện cho số lượng xô tối thiểu cần thiết để con hươu cao cổ hết khát.\n\n  Ví dụ:\n  - min_buckets_needed(23, 11) trả về 3\n  - min_buckets_needed(30, 10) trả về 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9859115443339574",
      "arb": "0.9731968163831521",
      "sw": "0.9768033482116026",
      "tr": "0.98631893524546",
      "vi": "0.9695432091543964"
    },
    "canonical_solution": "{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}",
    "instruction": {
      "en": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9090135799897298",
      "sw": "0.9153697521828462",
      "tr": "0.9124240636320988",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(min_buckets_needed(23, 11), 3);\n        assert_eq!(min_buckets_needed(30, 10), 3);\n        assert_eq!(min_buckets_needed(50, 5), 6);\n        assert_eq!(min_buckets_needed(40, 8), 3);    \n    }\n    \n\n}",
    "entry_point": "min_buckets_needed",
    "signature": "fn min_buckets_needed(height: i32, radius: i32) -> i32",
    "docstring": {
      "en": "Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3",
      "es": "Calcula el número mínimo de cubos que una jirafa necesita beber para saciar su sed, dada la capacidad de los cubos.\n\nUna jirafa necesita beber 20 litros de agua para saciar su sed. Esta función determina cuántos cubos de agua necesitaría, basándose en el volumen de cada cubo. Los cubos tienen forma cilíndrica, con una altura y un radio dados.\n\nArgumentos:\n- height: La altura del cubo en centímetros (entero).\n- radius: El radio de la base del cubo en centímetros (entero).\n\nDevuelve:\n- Un entero que representa el número mínimo de cubos necesarios para que la jirafa sacie su sed.\n\nEjemplo:\n- min_buckets_needed(23, 11) devuelve 3\n- min_buckets_needed(30, 10) devuelve 3",
      "arb": "يحسب الحد الأدنى لعدد الدلاء التي يحتاجها الزرافة للشرب لإرواء عطشه، بالنظر إلى حجم الدلاء.\n\nتحتاج الزرافة إلى شرب 20 لترًا من الماء لإرواء عطشها. تحدد هذه الدالة عدد الدلاء التي ستحتاجها من الماء، بناءً على حجم كل دلو. الدلاء أسطوانية الشكل، مع ارتفاع ونصف قطر معينين.\n\nالأوساط:\n- height: ارتفاع الدلو بالسنتيمترات (عدد صحيح).\n- radius: نصف قطر قاعدة الدلو بالسنتيمترات (عدد صحيح).\n\nالقيم المعادة:\n- عدد صحيح يمثل الحد الأدنى لعدد الدلاء اللازمة للزرافة لإرواء عطشها.\n\nمثال:\n- min_buckets_needed(23, 11) يعيد 3\n- min_buckets_needed(30, 10) يعيد 3",
      "sw": "Hesabu idadi ndogo ya ndoo ambazo twiga anahitaji kunywa ili kukata kiu chake, kutokana na ukubwa wa ndoo.\n\nTwiga anahitaji kunywa lita 20 za maji ili kukata kiu chake. Kazi hii inaamua ni ndoo ngapi za maji zitahitajika, kulingana na ujazo wa kila ndoo. Ndoo ni za umbo la silinda, zikiwa na urefu na kipenyo kilichopewa.\n\nHoja:\n- height: Urefu wa ndoo kwa sentimita (nambari kamili).\n- radius: Kipenyo cha msingi wa ndoo kwa sentimita (nambari kamili).\n\nRudisha:\n- Nambari kamili inayowakilisha idadi ndogo ya ndoo zinazohitajika kwa twiga kukata kiu chake.\n\nMfano:\n- min_buckets_needed(23, 11) inarudisha 3\n- min_buckets_needed(30, 10) inarudisha 3",
      "tr": "Zürafanın susuzluğunu gidermek için içmesi gereken minimum kova sayısını, kovaların boyutuna göre hesaplar.\n\nBir zürafa susuzluğunu gidermek için 20 litre su içmelidir. Bu fonksiyon, her bir kovanın hacmine göre kaç kova suya ihtiyaç duyacağını belirler. Kovalar, verilen yükseklik ve yarıçap ile silindirik şekildedir.\n\nArgümanlar:\n- height: Kovanın yüksekliği santimetre cinsinden (tamsayı).\n- radius: Kovanın tabanının yarıçapı santimetre cinsinden (tamsayı).\n\nDöndürür:\n- Zürafanın susuzluğunu gidermesi için gereken minimum kova sayısını temsil eden bir tamsayı.\n\nÖrnek:\n- min_buckets_needed(23, 11) 3 döndürür\n- min_buckets_needed(30, 10) 3 döndürür",
      "vi": "Tính toán số lượng xô tối thiểu mà một con hươu cao cổ cần để uống cho hết khát, dựa trên kích thước của các xô.\n\nMột con hươu cao cổ cần uống 20 lít nước để hết khát. Hàm này xác định số lượng xô nước cần thiết, dựa trên thể tích của mỗi xô. Các xô có hình trụ, với chiều cao và bán kính được cho.\n\nTham số:\n- height: Chiều cao của xô tính bằng centimet (số nguyên).\n- radius: Bán kính của đáy xô tính bằng centimet (số nguyên).\n\nTrả về:\n- Một số nguyên đại diện cho số lượng xô tối thiểu cần thiết để hươu cao cổ hết khát.\n\nVí dụ:\n- min_buckets_needed(23, 11) Trả về 3\n- min_buckets_needed(30, 10) Trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9828309857544874",
      "arb": "0.9761786556632479",
      "sw": "0.9638963460519556",
      "tr": "0.9842891313816645",
      "vi": "0.9722302809490364"
    }
  },
  {
    "task_id": "Rust/20",
    "prompt": {
      "en": "/*\n  Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "es": "/*\n  Calcula el área de un triángulo dadas las coordenadas de sus vértices.\n\n  Argumentos:\n  - x1, y1: Las coordenadas x e y del primer vértice.\n  - x2, y2: Las coordenadas x e y del segundo vértice.\n  - x3, y3: Las coordenadas x e y del tercer vértice.\n\n  Devuelve:\n  - El área del triángulo, redondeada a dos decimales.\n\n  Ejemplos:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) devuelve 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "arb": "/*\n  يحسب مساحة المثلث المعطى إحداثيات رؤوسه.\n\n  الحجج:\n  - x1, y1: الإحداثيات السينية والصادية للرأس الأول.\n  - x2, y2: الإحداثيات السينية والصادية للرأس الثاني.\n  - x3, y3: الإحداثيات السينية والصادية للرأس الثالث.\n\n  يعيد:\n  - مساحة المثلث، مقربة إلى منزلتين عشريتين.\n\n  أمثلة:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) يعيد 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "sw": "/*\n  Inahesabu eneo la pembetatu ikizingatia kuratibu za vilele vyake.\n\n  Hoja:\n  - x1, y1: Kuratibu za x na y za kilele cha kwanza.\n  - x2, y2: Kuratibu za x na y za kilele cha pili.\n  - x3, y3: Kuratibu za x na y za kilele cha tatu.\n\n  Inarudisha:\n  - Eneo la pembetatu, limezungushwa hadi sehemu mbili za desimali.\n\n  Mifano:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) inarudisha 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "tr": "/*\n  Üçgenin köşelerinin koordinatları verildiğinde alanını hesaplar.\n\n  Argümanlar:\n  - x1, y1: Birinci köşenin x ve y koordinatları.\n  - x2, y2: İkinci köşenin x ve y koordinatları.\n  - x3, y3: Üçüncü köşenin x ve y koordinatları.\n\n  Döndürür:\n  - Üçgenin alanı, iki ondalık basamağa yuvarlanmış halde.\n\n  Örnekler:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 döndürür\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "vi": "/*\n  Tính diện tích của một tam giác với tọa độ của các đỉnh.\n\n  Tham số:\n  - x1, y1: Tọa độ x và y của đỉnh thứ nhất.\n  - x2, y2: Tọa độ x và y của đỉnh thứ hai.\n  - x3, y3: Tọa độ x và y của đỉnh thứ ba.\n\n  Trả về:\n  - Diện tích của tam giác, làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) trả về 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 "
    },
    "prompt_bertscore": {
      "es": "0.9883034513823796",
      "arb": "1",
      "sw": "0.9935089577781608",
      "tr": "0.9811682508348443",
      "vi": "0.9841910079734333"
    },
    "canonical_solution": "{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}",
    "instruction": {
      "en": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa ve öz bir açıklamasını (docstring) sağlayın.",
      "vi": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9238518653441791",
      "sw": "0.9153697521828462",
      "tr": "0.8858075925734238",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0), 6.00);\n        assert_eq!(triangle_area(1.0, 2.0, 4.0, 5.0, 6.0, 3.0), 6.00); // Example test case, replace with correct area\n        assert_eq!(triangle_area(0.0, 0.0, 7.0, 8.0, 9.0, 10.0), 1.00); \n    }\n    \n\n}",
    "entry_point": "triangle_area",
    "signature": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32",
    "docstring": {
      "en": "Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "es": "Calcula el área de un triángulo dadas las coordenadas de sus vértices.\n\n  Argumentos:\n  - x1, y1: Las coordenadas x e y del primer vértice.\n  - x2, y2: Las coordenadas x e y del segundo vértice.\n  - x3, y3: Las coordenadas x e y del tercer vértice.\n\n  Retorna:\n  - El área del triángulo, redondeada a dos decimales.\n\n  Ejemplos:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) retorna 6.00",
      "arb": "يحسب مساحة المثلث المعطى إحداثيات رؤوسه.\n\n  الحجج:\n  - x1, y1: الإحداثيات السينية والصادية للرأس الأول.\n  - x2, y2: الإحداثيات السينية والصادية للرأس الثاني.\n  - x3, y3: الإحداثيات السينية والصادية للرأس الثالث.\n\n  يعيد:\n  - مساحة المثلث، مقربة إلى منزلتين عشريتين.\n\n  أمثلة:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) يعيد 6.00",
      "sw": "Hesabu eneo la pembetatu ukipewa kuratibu za vilele vyake.\n\n  Hoja:\n  - x1, y1: Kuratibu za x na y za kilele cha kwanza.\n  - x2, y2: Kuratibu za x na y za kilele cha pili.\n  - x3, y3: Kuratibu za x na y za kilele cha tatu.\n\n  Inarejesha:\n  - Eneo la pembetatu, limezungushwa hadi sehemu mbili za desimali.\n\n  Mifano:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) inarejesha 6.00",
      "tr": "Üçgenin köşelerinin koordinatları verildiğinde alanını hesaplar.\n\n  Argümanlar:\n  - x1, y1: İlk köşenin x ve y koordinatları.\n  - x2, y2: İkinci köşenin x ve y koordinatları.\n  - x3, y3: Üçüncü köşenin x ve y koordinatları.\n\n  Döndürür:\n  - İki ondalık basamağa yuvarlanmış üçgenin alanı.\n\n  Örnekler:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 döndürür.",
      "vi": "Tính diện tích của một tam giác dựa trên tọa độ của các đỉnh của nó.\n\n  Tham số:\n  - x1, y1: Tọa độ x và y của đỉnh thứ nhất.\n  - x2, y2: Tọa độ x và y của đỉnh thứ hai.\n  - x3, y3: Tọa độ x và y của đỉnh thứ ba.\n\n  Trả về:\n  - Diện tích của tam giác, được làm tròn đến hai chữ số thập phân.\n\n  Ví dụ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) trả về 6.00"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.99799621671612",
      "tr": "0.9943503560722247",
      "vi": "0.9832876370004866"
    }
  },
  {
    "task_id": "Rust/21",
    "prompt": {
      "en": "\n/*\n  Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "es": "/*\n  Calcula el franqueo basado en el peso de un paquete y si se elige el servicio exprés.\n  El franqueo se calcula de la siguiente manera:\n  - Para un peso de hasta 1000 gramos inclusive, la tarifa base es de 8 unidades.\n  - Por cada 500 gramos adicionales o fracción, se añade una tarifa adicional de 4 unidades.\n  - Si se elige el servicio exprés (denotado por 'y'), se añade una tarifa adicional de 5 unidades.\n  - Si no se elige el servicio exprés (denotado por 'n'), no se añade tarifa adicional.\n\n  Argumentos:\n  - weight: El peso del paquete en gramos.\n  - express: Un carácter que indica si se elige el servicio exprés ('y' para sí, 'n' para no).\n\n  Retorna:\n  - El costo total del franqueo como un entero sin signo.\n\n  Ejemplos:\n  - calculate_postage(1200, 'y') retorna 17.\n  - calculate_postage(1000, 'n') retorna 8.\n  - calculate_postage(1500, 'y') retorna 17.\n  - calculate_postage(2000, 'n') retorna 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "arb": "/*\n  يحسب رسوم البريد بناءً على وزن الطرد وما إذا تم اختيار خدمة البريد السريع.\n  يتم حساب رسوم البريد كما يلي:\n  - للوزن حتى 1000 جرام بما في ذلك، تكون الرسوم الأساسية 8 وحدات.\n  - لكل 500 جرام إضافية أو جزء منها، يتم إضافة رسوم إضافية قدرها 4 وحدات.\n  - إذا تم اختيار خدمة البريد السريع (يُرمز لها بـ 'y')، يتم إضافة رسوم إضافية قدرها 5 وحدات.\n  - إذا لم يتم اختيار خدمة البريد السريع (يُرمز لها بـ 'n')، لا يتم إضافة أي رسوم إضافية.\n\n  الوسائط:\n  - الوزن: وزن الطرد بالجرامات.\n  - البريد السريع: حرف يشير إلى ما إذا تم اختيار خدمة البريد السريع ('y' تعني نعم، 'n' تعني لا).\n\n  يعيد:\n  - إجمالي تكلفة رسوم البريد كعدد صحيح غير موقع.\n\n  أمثلة:\n  - calculate_postage(1200, 'y') يعيد 17.\n  - calculate_postage(1000, 'n') يعيد 8.\n  - calculate_postage(1500, 'y') يعيد 17.\n  - calculate_postage(2000, 'n') يعيد 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "sw": "/*\n  Inakokotoa gharama ya posta kulingana na uzito wa kifurushi na kama huduma ya haraka imechaguliwa.\n  Gharama ya posta inakokotolewa kama ifuatavyo:\n  - Kwa uzito hadi na ikijumuisha gramu 1000, ada ya msingi ni vitengo 8.\n  - Kwa kila gramu 500 za ziada au sehemu yake, ada ya ziada ya vitengo 4 inaongezwa.\n  - Ikiwa huduma ya haraka (inayoonyeshwa na 'y') imechaguliwa, ada ya ziada ya vitengo 5 inaongezwa.\n  - Ikiwa huduma ya haraka haijachaguliwa (inayoonyeshwa na 'n'), hakuna ada ya ziada inayoongezwa.\n\n  Hoja:\n  - weight: Uzito wa kifurushi kwa gramu.\n  - express: Tabia inayoonyesha kama huduma ya haraka imechaguliwa ('y' kwa ndiyo, 'n' kwa hapana).\n\n  Inarejesha:\n  - Jumla ya gharama ya posta kama namba kamili isiyo na ishara.\n\n  Mifano:\n  - calculate_postage(1200, 'y') inarejesha 17.\n  - calculate_postage(1000, 'n') inarejesha 8.\n  - calculate_postage(1500, 'y') inarejesha 17.\n  - calculate_postage(2000, 'n') inarejesha 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "tr": "/*\n  Bir paketin ağırlığına ve ekspres hizmetin seçilip seçilmediğine göre posta ücretini hesaplar.\n  Posta ücreti aşağıdaki gibi hesaplanır:\n  - Ağırlık 1000 grama kadar ve dahil olmak üzere, temel ücret 8 birimdir.\n  - Her ek 500 gram veya bir kısmı için, ek bir ücret olarak 4 birim eklenir.\n  - Ekspres hizmet seçilirse ('y' ile belirtilir), ek bir ücret olarak 5 birim eklenir.\n  - Ekspres hizmet seçilmezse ('n' ile belirtilir), ek bir ücret eklenmez.\n\n  Argümanlar:\n  - weight: Paketin ağırlığı gram cinsindendir.\n  - express: Ekspres hizmetin seçilip seçilmediğini belirten bir karakter ('y' evet için, 'n' hayır için).\n\n  Döndürür:\n  - Toplam posta maliyetini işaretsiz bir tam sayı olarak döndürür.\n\n  Örnekler:\n  - calculate_postage(1200, 'y') 17 döndürür.\n  - calculate_postage(1000, 'n') 8 döndürür.\n  - calculate_postage(1500, 'y') 17 döndürür.\n  - calculate_postage(2000, 'n') 16 döndürür.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "vi": "/*\n  Tính toán phí bưu điện dựa trên trọng lượng của gói hàng và liệu có chọn dịch vụ chuyển phát nhanh hay không.\n  Phí bưu điện được tính như sau:\n  - Đối với trọng lượng lên đến và bao gồm 1000 gram, phí cơ bản là 8 đơn vị.\n  - Đối với mỗi 500 gram bổ sung hoặc phần lẻ của nó, một khoản phí bổ sung là 4 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh (được biểu thị bằng 'y') được chọn, một khoản phí bổ sung là 5 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh không được chọn (được biểu thị bằng 'n'), không có khoản phí bổ sung nào được thêm vào.\n\n  Tham số:\n  - weight: Trọng lượng của gói hàng tính bằng gram.\n  - express: Một ký tự chỉ định liệu dịch vụ chuyển phát nhanh có được chọn hay không ('y' cho có, 'n' cho không).\n\n  Trả về:\n  - Tổng chi phí bưu điện dưới dạng số nguyên không dấu.\n\n  Ví dụ:\n  - calculate_postage(1200, 'y') trả về 17.\n  - calculate_postage(1000, 'n') trả về 8.\n  - calculate_postage(1500, 'y') trả về 17.\n  - calculate_postage(2000, 'n') trả về 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 "
    },
    "prompt_bertscore": {
      "es": "0.9811978467616185",
      "arb": "0.9709328273001165",
      "sw": "0.9804251745793928",
      "tr": "0.9794951871353874",
      "vi": "0.9624938169314683"
    },
    "canonical_solution": "{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}",
    "instruction": {
      "en": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9168674252558493",
      "sw": "0.9153697521828462",
      "tr": "0.8732084675043809",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_postage(1200, 'y'), 17);\n        assert_eq!(calculate_postage(1000, 'n'), 8);\n        assert_eq!(calculate_postage(1500, 'y'), 17);\n        assert_eq!(calculate_postage(2000, 'n'), 16);\n        \n    }\n    \n\n}",
    "entry_point": "calculate_postage",
    "signature": "fn calculate_postage(weight: u32, express: char) -> u32",
    "docstring": {
      "en": "Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "es": "Calcula el franqueo basado en el peso de un paquete y si se elige el servicio exprés.\n  El franqueo se calcula de la siguiente manera:\n  - Para un peso de hasta 1000 gramos inclusive, la tarifa base es de 8 unidades.\n  - Por cada 500 gramos adicionales o fracción, se añade una tarifa adicional de 4 unidades.\n  - Si se elige el servicio exprés (denotado por 'y'), se añade una tarifa adicional de 5 unidades.\n  - Si no se elige el servicio exprés (denotado por 'n'), no se añade ninguna tarifa adicional.\n\n  Argumentos:\n  - weight: El peso del paquete en gramos.\n  - express: Un carácter que indica si se elige el servicio exprés ('y' para sí, 'n' para no).\n\n  Retorna:\n  - El costo total del franqueo como un entero sin signo.\n\n  Ejemplos:\n  - calculate_postage(1200, 'y') retorna 17.\n  - calculate_postage(1000, 'n') retorna 8.\n  - calculate_postage(1500, 'y') retorna 17.\n  - calculate_postage(2000, 'n') retorna 16.",
      "arb": "يحسب رسوم البريد بناءً على وزن الطرد وما إذا تم اختيار خدمة البريد السريع.\nيتم حساب رسوم البريد كما يلي:\n- بالنسبة للوزن حتى 1000 جرام شاملة، تكون الرسوم الأساسية 8 وحدات.\n- لكل 500 جرام إضافية أو جزء منها، تضاف رسوم إضافية قدرها 4 وحدات.\n- إذا تم اختيار خدمة البريد السريع (يشار إليها بـ 'y')، تضاف رسوم إضافية قدرها 5 وحدات.\n- إذا لم يتم اختيار خدمة البريد السريع (يشار إليها بـ 'n')، لا تضاف رسوم إضافية.\n\nالمعطيات:\n- الوزن: وزن الطرد بالجرامات.\n- البريد السريع: حرف يشير إلى ما إذا تم اختيار خدمة البريد السريع ('y' تعني نعم، 'n' تعني لا).\n\nالقيم المعادة:\n- إجمالي تكلفة البريد كعدد صحيح غير موقع.\n\nأمثلة:\n- calculate_postage(1200, 'y') يعيد 17.\n- calculate_postage(1000, 'n') يعيد 8.\n- calculate_postage(1500, 'y') يعيد 17.\n- calculate_postage(2000, 'n') يعيد 16.",
      "sw": "Hesabu gharama ya posta kulingana na uzito wa kifurushi na kama huduma ya haraka imechaguliwa.\n  Gharama ya posta inahesabiwa kama ifuatavyo:\n  - Kwa uzito hadi na ikiwa ni pamoja na gramu 1000, ada ya msingi ni vitengo 8.\n  - Kwa kila gramu 500 za ziada au sehemu yake, ada ya ziada ya vitengo 4 inaongezwa.\n  - Ikiwa huduma ya haraka (inayoonyeshwa na 'y') imechaguliwa, ada ya ziada ya vitengo 5 inaongezwa.\n  - Ikiwa huduma ya haraka haijachaguliwa (inayoonyeshwa na 'n'), hakuna ada ya ziada inayoongezwa.\n\n  Hoja:\n  - weight: Uzito wa kifurushi kwa gramu.\n  - express: Tabia inayoonyesha kama huduma ya haraka imechaguliwa ('y' kwa ndio, 'n' kwa hapana).\n\n  Inarudisha:\n  - Jumla ya gharama ya posta kama namba kamili isiyo na ishara.\n\n  Mifano:\n  - calculate_postage(1200, 'y') inarudisha 17.\n  - calculate_postage(1000, 'n') inarudisha 8.\n  - calculate_postage(1500, 'y') inarudisha 17.\n  - calculate_postage(2000, 'n') inarudisha 16.",
      "tr": "Paketin ağırlığına ve ekspres hizmetin seçilip seçilmediğine göre posta ücretini hesaplar.\n  Posta ücreti şu şekilde hesaplanır:\n  - Ağırlık 1000 gram ve altı için, temel ücret 8 birimdir.\n  - Her ek 500 gram veya bir kısmı için, ek 4 birim ücret eklenir.\n  - Ekspres hizmet ('y' ile belirtilir) seçilirse, ek 5 birim ücret eklenir.\n  - Ekspres hizmet seçilmezse ('n' ile belirtilir), ek ücret eklenmez.\n\n  Argümanlar:\n  - weight: Paketin ağırlığı gram cinsindendir.\n  - express: Ekspres hizmetin seçilip seçilmediğini belirten bir karakter ('y' evet için, 'n' hayır için).\n\n  Döndürür:\n  - Toplam posta maliyeti, işaretsiz bir tam sayı olarak.\n\n  Örnekler:\n  - calculate_postage(1200, 'y') 17 döndürür.\n  - calculate_postage(1000, 'n') 8 döndürür.\n  - calculate_postage(1500, 'y') 17 döndürür.\n  - calculate_postage(2000, 'n') 16 döndürür.",
      "vi": "Tính toán cước phí dựa trên trọng lượng của gói hàng và liệu dịch vụ chuyển phát nhanh có được chọn hay không. \n  Cước phí được tính như sau:\n  - Đối với trọng lượng lên đến và bao gồm 1000 gram, phí cơ bản là 8 đơn vị.\n  - Đối với mỗi 500 gram bổ sung hoặc phần lẻ của nó, một khoản phí bổ sung 4 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh (được biểu thị bằng 'y') được chọn, một khoản phí bổ sung 5 đơn vị được thêm vào.\n  - Nếu dịch vụ chuyển phát nhanh không được chọn (được biểu thị bằng 'n'), không có khoản phí bổ sung nào được thêm vào.\n\n  Tham số:\n  - weight: Trọng lượng của gói hàng tính bằng gram.\n  - express: Một ký tự chỉ định liệu dịch vụ chuyển phát nhanh có được chọn hay không ('y' cho có, 'n' cho không).\n\n  Trả về:\n  - Tổng chi phí cước phí dưới dạng số nguyên không âm.\n\n  Ví dụ:\n  - calculate_postage(1200, 'y') trả về 17.\n  - calculate_postage(1000, 'n') trả về 8.\n  - calculate_postage(1500, 'y') trả về 17.\n  - calculate_postage(2000, 'n') trả về 16."
    },
    "docstring_bertscore": {
      "es": "0.9758338333217713",
      "arb": "0.9431791973100168",
      "sw": "0.9775813834141163",
      "tr": "0.9624759401971751",
      "vi": "0.9563440217042471"
    }
  },
  {
    "task_id": "Rust/22",
    "prompt": {
      "en": "\n/*\n  Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "es": "/*\n  Calcula el número de pacientes que no pueden ser atendidos en función del stock de medicamentos disponible y sus solicitudes.\n\n  Argumentos:\n  - total_medicine: La cantidad total de medicamentos disponible al comienzo del día.\n  - num_patients: El número de pacientes que vienen a obtener medicamentos.\n  - patient_requests: Un arreglo de usize, cada uno representando la cantidad de medicamento solicitada por un paciente, en el orden en que llegan.\n\n  Devuelve:\n  - El número de pacientes que no pueden ser atendidos porque el stock de medicamentos es insuficiente.\n\n  Ejemplo:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) devuelve 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) devuelve 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) devuelve 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "arb": "/*\n  يحسب عدد المرضى الذين لا يمكن خدمتهم بناءً على المخزون المتاح من الدواء وطلباتهم.\n\n  المعطيات:\n  - total_medicine: إجمالي كمية الدواء المتاحة في بداية اليوم.\n  - num_patients: عدد المرضى القادمين للحصول على الدواء.\n  - patient_requests: مصفوفة من usize، كل عنصر يمثل كمية الدواء المطلوبة من قبل مريض، بترتيب وصولهم.\n\n  يعيد:\n  - عدد المرضى الذين لا يمكن خدمتهم لأن مخزون الدواء غير كافٍ.\n\n  مثال:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) يعيد 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) يعيد 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) يعيد 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "sw": "/*\n  Hukokotoa idadi ya wagonjwa ambao hawawezi kuhudumiwa kulingana na hisa ya dawa inayopatikana na maombi yao.\n\n  Hoja:\n  - total_medicine: Jumla ya kiasi cha dawa kinachopatikana mwanzoni mwa siku.\n  - num_patients: Idadi ya wagonjwa wanaokuja kupata dawa.\n  - patient_requests: Safu ya usize, kila moja ikiwakilisha kiasi cha dawa kinachoombwa na mgonjwa, kwa mpangilio wanaofika.\n\n  Inarudisha:\n  - Idadi ya wagonjwa ambao hawawezi kuhudumiwa kwa sababu hisa ya dawa haitoshi.\n\n  Mfano:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) inarudisha 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) inarudisha 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) inarudisha 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "tr": "/*\n  Mevcut ilaç stoğuna ve hasta taleplerine göre hizmet verilemeyen hasta sayısını hesaplar.\n\n  Argümanlar:\n  - total_medicine: Günün başında mevcut olan toplam ilaç miktarı.\n  - num_patients: İlaç almaya gelen hasta sayısı.\n  - patient_requests: Her bir hastanın, geldikleri sıraya göre talep ettiği ilaç miktarını temsil eden usize dizisi.\n\n  Döndürür:\n  - İlaç stoğu yetersiz olduğu için hizmet verilemeyen hasta sayısı.\n\n  Örnek:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 döndürür\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 döndürür\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 döndürür\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "vi": "/*\n  Tính toán số lượng bệnh nhân không thể được phục vụ dựa trên lượng thuốc có sẵn và yêu cầu của họ.\n\n  Tham số:\n  - total_medicine: Tổng số lượng thuốc có sẵn vào đầu ngày.\n  - num_patients: Số lượng bệnh nhân đến để nhận thuốc.\n  - patient_requests: Một mảng usize, mỗi phần tử đại diện cho lượng thuốc mà một bệnh nhân yêu cầu, theo thứ tự họ đến.\n\n  Trả về:\n  - Số lượng bệnh nhân không thể được phục vụ vì lượng thuốc không đủ.\n\n  Ví dụ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) trả về 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) trả về 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) trả về 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9789700084079312",
      "arb": "0.978274206183166",
      "sw": "0.9892544936467746",
      "tr": "0.9681144608236125",
      "vi": "0.9748992773790022"
    },
    "canonical_solution": "{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}",
    "instruction": {
      "en": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.91331869486828",
      "sw": "0.9431116629804649",
      "tr": "0.8418600248783117",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]), 2);\n        assert_eq!(count_unserved_patients(50, 4, &[10, 15, 10, 20]), 1);\n        assert_eq!(count_unserved_patients(10, 3, &[5, 10, 5]), 1);\n        assert_eq!(count_unserved_patients(20, 5, &[4, 5, 7, 3, 2]), 1);\n        \n    }\n    \n\n}",
    "entry_point": "count_unserved_patients",
    "signature": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize",
    "docstring": {
      "en": "Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "es": "Calcula el número de pacientes que no pueden ser atendidos en función del stock de medicinas disponible y sus solicitudes.\n\n  Argumentos:\n  - total_medicine: La cantidad total de medicina disponible al comienzo del día.\n  - num_patients: El número de pacientes que vienen a obtener medicina.\n  - patient_requests: Un arreglo de usize, cada uno representando la cantidad de medicina solicitada por un paciente, en el orden en que llegan.\n\n  Retorna:\n  - El número de pacientes que no pueden ser atendidos porque el stock de medicinas es insuficiente.\n\n  Ejemplo:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) retorna 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) retorna 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) retorna 1",
      "arb": "يحسب عدد المرضى الذين لا يمكن خدمتهم بناءً على مخزون الدواء المتاح وطلباتهم.\n\n  الحجج:\n  - total_medicine: إجمالي كمية الدواء المتاحة في بداية اليوم.\n  - num_patients: عدد المرضى الذين يأتون للحصول على الدواء.\n  - patient_requests: مصفوفة من usize، كل عنصر يمثل كمية الدواء المطلوبة من قبل مريض، حسب ترتيب وصولهم.\n\n  يعيد:\n  - عدد المرضى الذين لا يمكن خدمتهم لأن مخزون الدواء غير كافٍ.\n\n  مثال:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) يعيد 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) يعيد 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) يعيد 1",
      "sw": "Hesabu idadi ya wagonjwa ambao hawawezi kuhudumiwa kulingana na hisa ya dawa inayopatikana na maombi yao.\n\n  Hoja:\n  - total_medicine: Jumla ya kiasi cha dawa kinachopatikana mwanzoni mwa siku.\n  - num_patients: Idadi ya wagonjwa wanaokuja kupata dawa.\n  - patient_requests: Safu ya usize, kila moja ikiwakilisha kiasi cha dawa kinachoombwa na mgonjwa, kwa mpangilio wanaofika.\n\n  Inarejesha:\n  - Idadi ya wagonjwa ambao hawawezi kuhudumiwa kwa sababu hisa ya dawa haitoshi.\n\n  Mfano:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) inarejesha 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) inarejesha 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) inarejesha 1",
      "tr": "Hastaların taleplerine ve mevcut ilaç stokuna göre hizmet verilemeyen hasta sayısını hesaplar.\n\n  Argümanlar:\n  - total_medicine: Günün başında mevcut olan toplam ilaç miktarı.\n  - num_patients: İlaç almaya gelen hasta sayısı.\n  - patient_requests: Her bir hastanın, geldikleri sırayla talep ettiği ilaç miktarını temsil eden usize dizisi.\n\n  Döndürür:\n  - İlaç stoğu yetersiz olduğu için hizmet verilemeyen hasta sayısı.\n\n  Örnek:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 döndürür\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 döndürür\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 döndürür",
      "vi": "Tính toán số lượng bệnh nhân không thể được phục vụ dựa trên lượng thuốc có sẵn và yêu cầu của họ.\n\n  Tham số:\n  - total_medicine: Tổng số lượng thuốc có sẵn vào đầu ngày.\n  - num_patients: Số lượng bệnh nhân đến để lấy thuốc.\n  - patient_requests: Một mảng usize, mỗi phần tử đại diện cho lượng thuốc mà một bệnh nhân yêu cầu, theo thứ tự họ đến.\n\n  Trả về:\n  - Số lượng bệnh nhân không thể được phục vụ vì lượng thuốc không đủ.\n\n  Ví dụ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) trả về 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) trả về 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9760660322372011",
      "arb": "0.9758973950437025",
      "sw": "0.991852777661092",
      "tr": "0.9607947326520958",
      "vi": "0.9684578927524218"
    }
  },
  {
    "task_id": "Rust/23",
    "prompt": {
      "en": "/*\n  Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "es": "/*\n  Determina si una secuencia es un \"Jolly Jumper\". Una secuencia se considera un \"Jolly Jumper\" si las diferencias absolutas entre elementos sucesivos, cuando se ordenan, forman una secuencia de números consecutivos comenzando desde 1. Por ejemplo, una secuencia de [3, 1, 4, 2] es un Jolly Jumper porque las diferencias absolutas son 2, 3, 2, formando una secuencia consecutiva 1, 2, 3. Una secuencia con un solo elemento siempre es un Jolly Jumper.\n\n  Argumentos:\n  - sequence: Un fragmento de enteros, representando la secuencia.\n\n  Retorna:\n  - Un valor booleano que indica si la secuencia es un Jolly Jumper.\n\n  Ejemplos:\n  - is_jolly_jumper(&[1, 4, 2, 3]) retorna true.\n  - is_jolly_jumper(&[1, 3]) retorna false.\n  - is_jolly_jumper(&[5]) retorna true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "arb": "/*\n  يحدد ما إذا كانت تسلسل هو \"Jolly Jumper\". يعتبر التسلسل \"Jolly Jumper\" إذا كانت الفروقات المطلقة بين العناصر المتتالية، عند ترتيبها، تشكل تسلسلًا من الأرقام المتتالية بدءًا من 1. على سبيل المثال، يعتبر التسلسل [3, 1, 4, 2] Jolly Jumper لأن الفروقات المطلقة هي 2، 3، 2، مما يشكل تسلسلًا متتاليًا 1، 2، 3. التسلسل الذي يحتوي على عنصر واحد دائمًا ما يكون Jolly Jumper.\n\n  الحجج:\n  - sequence: شريحة من الأعداد الصحيحة، تمثل التسلسل.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كان التسلسل Jolly Jumper.\n\n  أمثلة:\n  - is_jolly_jumper(&[1, 4, 2, 3]) يعيد true.\n  - is_jolly_jumper(&[1, 3]) يعيد false.\n  - is_jolly_jumper(&[5]) يعيد true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "sw": "/*\n  Huamua ikiwa mlolongo ni \"Jolly Jumper\". Mlolongo unachukuliwa kuwa \"Jolly Jumper\" ikiwa tofauti za thamani kamili kati ya vipengele vinavyofuatana, zinapopangwa, huunda mlolongo wa nambari mfululizo kuanzia 1. Kwa mfano, mlolongo wa [3, 1, 4, 2] ni Jolly Jumper kwa sababu tofauti za thamani kamili ni 2, 3, 2, zikifomu mlolongo mfululizo 1, 2, 3. Mlolongo wenye kipengele kimoja daima ni Jolly Jumper.\n\n  Hoja:\n  - sequence: Kipande cha nambari za mzima, kinachowakilisha mlolongo.\n\n  Inarejesha:\n  - Thamani ya boolean inayoonyesha ikiwa mlolongo ni Jolly Jumper.\n\n  Mifano:\n  - is_jolly_jumper(&[1, 4, 2, 3]) inarejesha true.\n  - is_jolly_jumper(&[1, 3]) inarejesha false.\n  - is_jolly_jumper(&[5]) inarejesha true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "tr": "/*\n  Bir dizinin \"Jolly Jumper\" olup olmadığını belirler. Bir dizi, ardışık elemanlar arasındaki mutlak farklar sıralandığında, 1'den başlayarak ardışık sayılar dizisi oluşturuyorsa \"Jolly Jumper\" olarak kabul edilir. Örneğin, [3, 1, 4, 2] dizisi bir Jolly Jumper'dır çünkü mutlak farklar 2, 3, 2 olup, 1, 2, 3 ardışık dizisini oluşturur. Tek bir eleman içeren bir dizi her zaman bir Jolly Jumper'dır.\n\n  Argümanlar:\n  - sequence: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin bir Jolly Jumper olup olmadığını belirten bir boolean değeri.\n\n  Örnekler:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true döndürür.\n  - is_jolly_jumper(&[1, 3]) false döndürür.\n  - is_jolly_jumper(&[5]) true döndürür.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "vi": "/*\n  Xác định xem một dãy có phải là \"Jolly Jumper\" hay không. Một dãy được coi là \"Jolly Jumper\" nếu các giá trị tuyệt đối của sự khác biệt giữa các phần tử liên tiếp, khi sắp xếp, tạo thành một dãy số liên tiếp bắt đầu từ 1. Ví dụ, một dãy [3, 1, 4, 2] là một Jolly Jumper vì các giá trị tuyệt đối của sự khác biệt là 2, 3, 2, tạo thành một dãy liên tiếp 1, 2, 3. Một dãy chỉ có một phần tử luôn luôn là một Jolly Jumper.\n\n  Tham số:\n  - sequence: Một mảng các số nguyên, đại diện cho dãy số.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có phải là một Jolly Jumper hay không.\n\n  Ví dụ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) trả về true.\n  - is_jolly_jumper(&[1, 3]) trả về false.\n  - is_jolly_jumper(&[5]) trả về true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "es": "0.9986213065252368",
      "arb": "0.9897033983079134",
      "sw": "0.9900039260744192",
      "tr": "0.9833819864314781",
      "vi": "0.9560788501455655"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}",
    "instruction": {
      "en": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nRust kodunun işlevini açıklayan en fazla 500 karakterlik bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9153697521828462",
      "tr": "0.8637504832810237",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_jolly_jumper(&[1, 4, 2, 3]), true);\n        assert_eq!(is_jolly_jumper(&[1, 3]), false);\n        assert_eq!(is_jolly_jumper(&[5]), true);\n        assert_eq!(is_jolly_jumper(&[10, 7, 8, 9]), false);\n    }\n    \n\n}",
    "entry_point": "is_jolly_jumper",
    "signature": "fn is_jolly_jumper(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.",
      "es": "Determina si una secuencia es un \"Jolly Jumper\". Una secuencia se considera un \"Jolly Jumper\" si las diferencias absolutas entre elementos sucesivos, cuando se ordenan, forman una secuencia de números consecutivos comenzando desde 1. Por ejemplo, una secuencia de [3, 1, 4, 2] es un Jolly Jumper porque las diferencias absolutas son 2, 3, 2, formando una secuencia consecutiva 1, 2, 3. Una secuencia con un solo elemento siempre es un Jolly Jumper.\n\n  Argumentos:\n  - sequence: Un segmento de enteros, que representa la secuencia.\n\n  Devuelve:\n  - Un valor booleano que indica si la secuencia es un Jolly Jumper.\n\n  Ejemplos:\n  - is_jolly_jumper(&[1, 4, 2, 3]) devuelve true.\n  - is_jolly_jumper(&[1, 3]) devuelve false.\n  - is_jolly_jumper(&[5]) devuelve true.",
      "arb": "يحدد ما إذا كانت سلسلة ما هي \"Jolly Jumper\". تعتبر السلسلة \"Jolly Jumper\" إذا كانت الفروق المطلقة بين العناصر المتتالية، عند ترتيبها، تشكل سلسلة من الأرقام المتتالية تبدأ من 1. على سبيل المثال، السلسلة [3, 1, 4, 2] هي Jolly Jumper لأن الفروق المطلقة هي 2، 3، 2، مما يشكل سلسلة متتالية 1، 2، 3. السلسلة التي تحتوي على عنصر واحد دائمًا ما تكون Jolly Jumper.\n\n  الحجج:\n  - sequence: شريحة من الأعداد الصحيحة، تمثل السلسلة.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة Jolly Jumper.\n\n  أمثلة:\n  - is_jolly_jumper(&[1, 4, 2, 3]) يعيد true.\n  - is_jolly_jumper(&[1, 3]) يعيد false.\n  - is_jolly_jumper(&[5]) يعيد true.",
      "sw": "Huamua ikiwa mlolongo ni \"Jolly Jumper\". Mlolongo unachukuliwa kuwa \"Jolly Jumper\" ikiwa tofauti za thamani kabisa kati ya vipengele vinavyofuatana, zinapopangwa, zinaunda mlolongo wa namba mfululizo kuanzia 1. Kwa mfano, mlolongo wa [3, 1, 4, 2] ni Jolly Jumper kwa sababu tofauti za thamani kabisa ni 2, 3, 2, zikaunda mlolongo mfululizo 1, 2, 3. Mlolongo wenye kipengele kimoja daima ni Jolly Jumper.\n\n  Hoja:\n  - sequence: Kipande cha namba nzima, kinachowakilisha mlolongo.\n\n  Inarejesha:\n  - Thamani ya boolean inayoonyesha ikiwa mlolongo ni Jolly Jumper.\n\n  Mifano:\n  - is_jolly_jumper(&[1, 4, 2, 3]) inarudisha true.\n  - is_jolly_jumper(&[1, 3]) inarudisha false.\n  - is_jolly_jumper(&[5]) inarudisha true.",
      "tr": "Bir dizinin \"Jolly Jumper\" olup olmadığını belirler. Bir dizi, ardışık elemanlar arasındaki mutlak farklar sıralandığında, 1'den başlayarak ardışık sayılar dizisi oluşturuyorsa \"Jolly Jumper\" olarak kabul edilir. Örneğin, [3, 1, 4, 2] dizisi bir Jolly Jumper'dır çünkü mutlak farklar 2, 3, 2 olup, ardışık bir dizi olan 1, 2, 3'ü oluşturur. Tek bir elemanı olan bir dizi her zaman bir Jolly Jumper'dır.\n\n  Argümanlar:\n  - sequence: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin bir Jolly Jumper olup olmadığını belirten bir boolean değeri.\n\n  Örnekler:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true döndürür.\n  - is_jolly_jumper(&[1, 3]) false döndürür.\n  - is_jolly_jumper(&[5]) true döndürür.",
      "vi": "Xác định xem một dãy số có phải là \"Jolly Jumper\" hay không. Một dãy số được coi là \"Jolly Jumper\" nếu các chênh lệch tuyệt đối giữa các phần tử liên tiếp, khi được sắp xếp, tạo thành một dãy số liên tiếp bắt đầu từ 1. Ví dụ, một dãy số [3, 1, 4, 2] là một Jolly Jumper vì các chênh lệch tuyệt đối là 2, 3, 2, tạo thành một dãy liên tiếp 1, 2, 3. Một dãy số với một phần tử luôn là một Jolly Jumper.\n\n  Tham số:\n  - sequence: Một dãy số nguyên, đại diện cho dãy số.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có phải là Jolly Jumper hay không.\n\n  Ví dụ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) trả về true.\n  - is_jolly_jumper(&[1, 3]) trả về false.\n  - is_jolly_jumper(&[5]) trả về true."
    },
    "docstring_bertscore": {
      "es": "0.9950684048996657",
      "arb": "0.9869672648091579",
      "sw": "0.9887543423473287",
      "tr": "0.9808579901796678",
      "vi": "0.9726176101920545"
    }
  },
  {
    "task_id": "Rust/24",
    "prompt": {
      "en": "/*\n  Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "es": "/*\n  Calcula la transposición de una matriz cuadrada dada.\n\n  Argumentos:\n  - matrix: Una matriz cuadrada representada como un vector de vectores de i32.\n\n  Retorna:\n  - Una nueva matriz que es la transposición de la matriz de entrada. En la matriz transpuesta, las filas y columnas de la matriz original se intercambian, de modo que el elemento en (i, j) en la matriz original se mueve a la posición (j, i) en la matriz transpuesta.\n\n  Ejemplo:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) retorna vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "arb": "/*\n  يحسب المصفوفة المنقولة لمصفوفة مربعة معينة.\n\n  الوسائط:\n  - matrix: مصفوفة مربعة ممثلة كمتجه من المتجهات من i32.\n\n  يعيد:\n  - مصفوفة جديدة وهي المصفوفة المنقولة للمصفوفة المدخلة. في المصفوفة المنقولة، يتم تبديل الصفوف والأعمدة للمصفوفة الأصلية، بحيث ينتقل العنصر في الموضع (i, j) في المصفوفة الأصلية إلى الموضع (j, i) في المصفوفة المنقولة.\n\n  مثال:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) يعيد vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "sw": "/*\n  Inahesabu kibadilisho cha matrix mraba uliotolewa.\n\n  Hoja:\n  - matrix: Matrix mraba inayowakilishwa kama vector ya vectors ya i32.\n\n  Inarudisha:\n  - Matrix mpya ambayo ni kibadilisho cha matrix ya ingizo. Katika matrix iliyobadilishwa, mistari na safu za matrix ya awali zinabadilishwa, ili kipengele katika (i, j) kwenye matrix ya awali kihamie kwenye nafasi (j, i) katika matrix iliyobadilishwa.\n\n  Mfano:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) inarudisha vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "tr": "/*\n  Verilen bir kare matrisin transpozunu hesaplar.\n\n  Argümanlar:\n  - matrix: i32 vektörlerinin bir vektörü olarak temsil edilen bir kare matris.\n\n  Döndürür:\n  - Girdi matrisinin transpozu olan yeni bir matris. Transpoze matrisinde, orijinal matrisin satır ve sütunları değiştirilir, böylece orijinal matrisin (i, j) konumundaki eleman transpoze matrisin (j, i) konumuna taşınır.\n\n  Örnek:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] döndürür.\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "vi": "/*\n  Tính toán ma trận chuyển vị của một ma trận vuông cho trước.\n\n  Tham số:\n  - matrix: Một ma trận vuông được biểu diễn dưới dạng một vector của các vector của i32.\n\n  Trả về:\n  - Một ma trận mới là ma trận chuyển vị của ma trận đầu vào. Trong ma trận chuyển vị, các hàng và cột của ma trận gốc được hoán đổi, sao cho phần tử tại vị trí (i, j) trong ma trận gốc chuyển đến vị trí (j, i) trong ma trận chuyển vị.\n\n  Ví dụ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) trả về vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> "
    },
    "prompt_bertscore": {
      "es": "0.9910417698153265",
      "arb": "0.9869068811733233",
      "sw": "0.9897564326196497",
      "tr": "0.9801212700964095",
      "vi": "0.9788375219437809"
    },
    "canonical_solution": "{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}",
    "instruction": {
      "en": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9431116629804649",
      "tr": "0.8624248241179968",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![3, 4]]),\n            vec![vec![1, 3], vec![2, 4]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]),\n            vec![vec![1, 4, 7], vec![2, 5, 8], vec![3, 6, 9]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![1, 2]]),\n            vec![vec![1, 1], vec![2, 2]]\n        );\n    }\n    \n\n}",
    "entry_point": "transpose_matrix",
    "signature": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>",
    "docstring": {
      "en": "Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "es": "Calcula la transposición de una matriz cuadrada dada.\n\n  Argumentos:\n  - matrix: Una matriz cuadrada representada como un vector de vectores de i32.\n\n  Retorna:\n  - Una nueva matriz que es la transposición de la matriz de entrada. En la matriz transpuesta, las filas y columnas de la matriz original se intercambian, de modo que el elemento en (i, j) en la matriz original se mueve a la posición (j, i) en la matriz transpuesta.\n\n  Ejemplo:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) retorna vec![vec![1, 3], vec![2, 4]]",
      "arb": "يحسب المصفوفة المنقولة لمصفوفة مربعة معينة.\n\n  الحجج:\n  - matrix: مصفوفة مربعة ممثلة كمتجه من المتجهات من i32.\n\n  العوائد:\n  - مصفوفة جديدة وهي المصفوفة المنقولة للمصفوفة المدخلة. في المصفوفة المنقولة، يتم تبديل الصفوف والأعمدة للمصفوفة الأصلية، بحيث ينتقل العنصر في الموضع (i, j) في المصفوفة الأصلية إلى الموضع (j, i) في المصفوفة المنقولة.\n\n  مثال:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) يعيد vec![vec![1, 3], vec![2, 4]]",
      "sw": "Hesabu ubadilishaji wa matrix ya mraba uliyopewa.\n\n  Hoja:\n  - matrix: Matrix ya mraba inayowakilishwa kama vector ya vectors ya i32.\n\n  Inarejesha:\n  - Matrix mpya ambayo ni ubadilishaji wa matrix ya ingizo. Katika matrix iliyobadilishwa, safu na safu za matrix ya awali zinabadilishwa, ili kipengele kilicho kwenye (i, j) katika matrix ya awali kihamie kwenye nafasi (j, i) katika matrix iliyobadilishwa.\n\n  Mfano:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) inarejesha vec![vec![1, 3], vec![2, 4]]",
      "tr": "Verilen bir kare matrisin transpozunu hesaplar.\n\n  Argümanlar:\n  - matrix: i32 vektörlerinin vektörü olarak temsil edilen bir kare matris.\n\n  Döndürür:\n  - Girdi matrisinin transpozu olan yeni bir matris. Transpoze matrisinde, orijinal matrisin satır ve sütunları yer değiştirir, böylece orijinal matristeki (i, j) konumundaki eleman transpoze matrisinde (j, i) konumuna taşınır.\n\n  Örnek:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] döndürür.",
      "vi": "Tính toán chuyển vị của một ma trận vuông cho trước.\n\n  Tham số:\n  - matrix: Một ma trận vuông được biểu diễn dưới dạng một vector của các vector của i32.\n\n  Trả về:\n  - Một ma trận mới là chuyển vị của ma trận đầu vào. Trong ma trận chuyển vị, các hàng và cột của ma trận gốc được hoán đổi, sao cho phần tử tại vị trí (i, j) trong ma trận gốc chuyển đến vị trí (j, i) trong ma trận chuyển vị.\n\n  Ví dụ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) trả về vec![vec![1, 3], vec![2, 4]]"
    },
    "docstring_bertscore": {
      "es": "0.9852882421982699",
      "arb": "0.9804674828505532",
      "sw": "0.9849555363100365",
      "tr": "0.9713767662017295",
      "vi": "0.9744851330345444"
    }
  },
  {
    "task_id": "Rust/25",
    "prompt": {
      "en": "/*\n    Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "es": "/*\n    Transforma una contraseña dada según un algoritmo específico.\n\n    El algoritmo funciona de la siguiente manera:\n    - Las letras minúsculas se transforman en números basados en el mapeo del teclado telefónico (por ejemplo, abc -> 2, def -> 3, ...).\n    - Las letras mayúsculas se convierten primero a minúsculas y luego se desplazan a la siguiente letra en el alfabeto (por ejemplo, A -> b, Z -> a).\n    - Los números y otros símbolos permanecen sin cambios.\n\n    Argumentos:\n    - input: Una cadena que representa la contraseña a transformar. La longitud de la contraseña no excede los 100 caracteres.\n\n    Devuelve:\n    - Una nueva cadena que representa la contraseña transformada.\n\n    Ejemplos:\n    - transform_password(\"YUANzi1987\") Devuelve \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "arb": "/*\n    يحول كلمة المرور المعطاة وفقًا لخوارزمية محددة.\n\n    تعمل الخوارزمية كما يلي:\n    - يتم تحويل الأحرف الصغيرة إلى أرقام بناءً على خريطة لوحة مفاتيح الهاتف (مثال: abc -> 2, def -> 3, ...).\n    - يتم تحويل الأحرف الكبيرة أولاً إلى أحرف صغيرة ثم يتم تحريكها إلى الحرف التالي في الأبجدية (مثال: A -> b, Z -> a).\n    - تبقى الأرقام والرموز الأخرى دون تغيير.\n\n    المعطيات:\n    - input: سلسلة تمثل كلمة المرور المراد تحويلها. لا يتجاوز طول كلمة المرور 100 حرف.\n\n    يعيد:\n    - سلسلة جديدة تمثل كلمة المرور المحولة.\n\n    أمثلة:\n    - transform_password(\"YUANzi1987\") يعيد \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "sw": "/*\n    Hubadilisha nenosiri lililopewa kulingana na algoriti maalum.\n\n    Algoriti inafanya kazi kama ifuatavyo:\n    - Herufi ndogo hubadilishwa kuwa namba kulingana na ramani ya keypad ya simu (mfano, abc -> 2, def -> 3, ...).\n    - Herufi kubwa kwanza hubadilishwa kuwa herufi ndogo kisha zinasogezwa hadi herufi inayofuata katika alfabeti (mfano, A -> b, Z -> a).\n    - Namba na alama nyingine hubaki bila kubadilika.\n\n    Hoja:\n    - input: Kamba inayowakilisha nenosiri litakalobadilishwa. Urefu wa nenosiri hauzidi herufi 100.\n\n    Inarudisha:\n    - Kamba mpya inayowakilisha nenosiri lililobadilishwa.\n\n    Mifano:\n    - transform_password(\"YUANzi1987\") inarudisha \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "tr": "/*\n    Belirli bir algoritmaya göre verilen bir şifreyi dönüştürür.\n\n    Algoritma şu şekilde çalışır:\n    - Küçük harfler, telefon tuş takımı eşlemesine göre sayılara dönüştürülür (örneğin, abc -> 2, def -> 3, ...).\n    - Büyük harfler önce küçük harfe dönüştürülür ve ardından alfabede bir sonraki harfe kaydırılır (örneğin, A -> b, Z -> a).\n    - Sayılar ve diğer semboller değişmeden kalır.\n\n    Argümanlar:\n    - input: Dönüştürülecek şifreyi temsil eden bir dize. Şifre uzunluğu 100 karakteri geçmez.\n\n    Döndürür:\n    - Dönüştürülmüş şifreyi temsil eden yeni bir dize.\n\n    Örnekler:\n    - transform_password(\"YUANzi1987\") \"zvbo941987\" döndürür\n*/\n\nfn transform_password(input: &str) -> String ",
      "vi": "/*\n    Chuyển đổi một mật khẩu đã cho theo một thuật toán cụ thể.\n\n    Thuật toán hoạt động như sau:\n    - Các chữ cái thường được chuyển đổi thành số dựa trên ánh xạ bàn phím điện thoại (ví dụ: abc -> 2, def -> 3, ...).\n    - Các chữ cái hoa trước tiên được chuyển thành chữ thường và sau đó được chuyển sang chữ cái tiếp theo trong bảng chữ cái (ví dụ: A -> b, Z -> a).\n    - Các số và ký hiệu khác không thay đổi.\n\n    Tham số:\n    - input: Một chuỗi đại diện cho mật khẩu cần chuyển đổi. Độ dài mật khẩu không vượt quá 100 ký tự.\n\n    Trả về:\n    - Một chuỗi mới đại diện cho mật khẩu đã được chuyển đổi.\n\n    Ví dụ:\n    - transform_password(\"YUANzi1987\") trả về \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9817339501600317",
      "arb": "0.9706189912980814",
      "sw": "0.9885322735813318",
      "tr": "0.9924536345637225",
      "vi": "0.9774419448866298"
    },
    "canonical_solution": "{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}",
    "instruction": {
      "en": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nRust kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9034153813306425",
      "sw": "0.9431116629804649",
      "tr": "0.9157807184412075",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(transform_password(\"YUANzi1987\"), \"zvbo941987\");\n        assert_eq!(transform_password(\"ABcdE\"), \"bc23f\");\n        assert_eq!(transform_password(\"Zebra123!\"), \"a3272123!\");\n    }\n    \n\n}",
    "entry_point": "transform_password",
    "signature": "fn transform_password(input: &str) -> String",
    "docstring": {
      "en": "Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "es": "Transforma una contraseña dada según un algoritmo específico.\n\n    El algoritmo funciona de la siguiente manera:\n    - Las letras minúsculas se transforman en números basados en el mapeo del teclado telefónico (por ejemplo, abc -> 2, def -> 3, ...).\n    - Las letras mayúsculas se convierten primero en minúsculas y luego se desplazan a la siguiente letra en el alfabeto (por ejemplo, A -> b, Z -> a).\n    - Los números y otros símbolos permanecen sin cambios.\n\n    Argumentos:\n    - input: Una cadena que representa la contraseña a transformar. La longitud de la contraseña no excede los 100 caracteres.\n\n    Devuelve:\n    - Una nueva cadena que representa la contraseña transformada.\n\n    Ejemplos:\n    - transform_password(\"YUANzi1987\") devuelve \"zvbo941987\"",
      "arb": "تحول كلمة المرور المعطاة وفقًا لخوارزمية محددة.\n\n    تعمل الخوارزمية كما يلي:\n    - يتم تحويل الأحرف الصغيرة إلى أرقام بناءً على تخطيط لوحة مفاتيح الهاتف (مثلًا، abc -> 2، def -> 3، ...).\n    - يتم تحويل الأحرف الكبيرة أولاً إلى أحرف صغيرة ثم يتم تحريكها إلى الحرف التالي في الأبجدية (مثلًا، A -> b، Z -> a).\n    - تبقى الأرقام والرموز الأخرى دون تغيير.\n\n    يعيدالحجج:\n    - input: سلسلة تمثل كلمة المرور التي سيتم تحويلها. لا يتجاوز طول كلمة المرور 100 حرف.\n\n    يعيد:\n    - سلسلة جديدة تمثل كلمة المرور المحولة.\n\n    امثله:\n    - transform_password(\"YUANzi1987\") يعيد \"zvbo941987\"",
      "sw": "Hubadilisha nenosiri lililopewa kulingana na algorithimu maalum.\n\n    Algorithimu inafanya kazi kama ifuatavyo:\n    - Herufi ndogo hubadilishwa kuwa namba kulingana na ramani ya kibodi ya simu (mfano, abc -> 2, def -> 3, ...).\n    - Herufi kubwa hubadilishwa kwanza kuwa herufi ndogo kisha kuhamishwa kwa herufi inayofuata katika alfabeti (mfano, A -> b, Z -> a).\n    - Namba na alama nyingine hubaki bila kubadilika.\n\n    Hoja:\n    - input: Mfuatano wa herufi unaowakilisha nenosiri litakalobadilishwa. Urefu wa nenosiri hauzidi herufi 100.\n\n    Inarudisha:\n    - Mfuatano mpya wa herufi unaowakilisha nenosiri lililobadilishwa.\n\n    Mifano:\n    - transform_password(\"YUANzi1987\") inarudisha \"zvbo941987\"",
      "tr": "Belirli bir algoritmaya göre verilen bir şifreyi dönüştürür.\n\n    Algoritma şu şekilde çalışır:\n    - Küçük harfler, telefon tuş takımı eşlemesine göre numaralara dönüştürülür (örneğin, abc -> 2, def -> 3, ...).\n    - Büyük harfler önce küçük harfe dönüştürülür ve ardından alfabede bir sonraki harfe kaydırılır (örneğin, A -> b, Z -> a).\n    - Sayılar ve diğer semboller değişmeden kalır.\n\n    Argümanlar:\n    - input: Dönüştürülecek şifreyi temsil eden bir dize. Şifre uzunluğu 100 karakteri geçmez.\n\n    Döndürür:\n    - Dönüştürülmüş şifreyi temsil eden yeni bir dize.\n\n    Örnekler:\n    - transform_password(\"YUANzi1987\") \"zvbo941987\" döndürür.",
      "vi": "Chuyển đổi một mật khẩu đã cho theo một thuật toán cụ thể.\n\n    Thuật toán hoạt động như sau:\n    - Các chữ cái thường được chuyển đổi thành số dựa trên ánh xạ bàn phím điện thoại (ví dụ: abc -> 2, def -> 3, ...).\n    - Các chữ cái hoa trước tiên được chuyển thành chữ thường và sau đó chuyển sang chữ cái tiếp theo trong bảng chữ cái (ví dụ: A -> b, Z -> a).\n    - Các số và ký hiệu khác không thay đổi.\n\n    Tham số:\n    - input: Một chuỗi đại diện cho mật khẩu cần được chuyển đổi. Độ dài mật khẩu không vượt quá 100 ký tự.\n\n    Trả về:\n    - Một chuỗi mới đại diện cho mật khẩu đã được chuyển đổi.\n\n    Ví dụ:\n    - transform_password(\"YUANzi1987\") trả về \"zvbo941987\""
    },
    "docstring_bertscore": {
      "es": "0.9852018379825198",
      "arb": "0.9901989811085955",
      "sw": "0.9617253159872443",
      "tr": "0.9929527927112632",
      "vi": "0.9754095588278808"
    }
  },
  {
    "task_id": "Rust/26",
    "prompt": {
      "en": "\n/*\n  Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "es": "/*\n  Determina si la secuencia de números dada forma una secuencia aritmética.\n\n  Una secuencia aritmética es una secuencia de números tal que la diferencia entre números consecutivos es constante.\n\n  Argumentos:\n  - sequence: Un segmento de matriz de enteros que representa la secuencia a verificar.\n\n  Devuelve:\n  - Un valor booleano que indica si la secuencia forma una secuencia aritmética (`true`) o no (`false`).\n\n  Ejemplos:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) devuelve true (ya que la diferencia es 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) devuelve false (ya que la diferencia no es constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) devuelve true (ya que la diferencia es 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "arb": "/*\n  يحدد ما إذا كانت سلسلة الأرقام المعطاة تشكل متتالية حسابية.\n\n  المتتالية الحسابية هي سلسلة من الأرقام بحيث يكون الفرق بين الأرقام المتتالية ثابتًا.\n\n  الحجج:\n  - sequence: مقطع من مصفوفة الأعداد الصحيحة يمثل السلسلة المراد التحقق منها.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة تشكل متتالية حسابية (`true`) أو لا (`false`).\n\n  أمثلة:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) يعيد true (حيث أن الفرق هو 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) يعيد false (حيث أن الفرق ليس ثابتًا)\n  - is_arithmetic_sequence(&[10, 10, 10]) يعيد true (حيث أن الفرق هو 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "sw": "/*\n  Huamua kama mlolongo uliotolewa wa nambari unaunda mlolongo wa hesabu.\n\n  Mlolongo wa hesabu ni mlolongo wa nambari ambapo tofauti kati ya nambari mfululizo ni ya kudumu.\n\n  Hoja:\n  - sequence: Kipande cha safu ya nambari nzima kinachowakilisha mlolongo unaopaswa kukaguliwa.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha kama mlolongo unaunda mlolongo wa hesabu (`true`) au la (`false`).\n\n  Mifano:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) inarudisha true (kwa kuwa tofauti ni 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) inarudisha false (kwa kuwa tofauti si ya kudumu)\n  - is_arithmetic_sequence(&[10, 10, 10]) inarudisha true (kwa kuwa tofauti ni 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "tr": "/*\n  Verilen sayı dizisinin aritmetik bir dizi oluşturup oluşturmadığını belirler.\n\n  Aritmetik bir dizi, ardışık sayılar arasındaki farkın sabit olduğu bir sayı dizisidir.\n\n  Argümanlar:\n  - sequence: Kontrol edilecek diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizinin aritmetik bir dizi oluşturup oluşturmadığını belirten bir boolean değer (`true` veya `false`).\n\n  Örnekler:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true döndürür (çünkü fark 2'dir)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false döndürür (çünkü fark sabit değildir)\n  - is_arithmetic_sequence(&[10, 10, 10]) true döndürür (çünkü fark 0'dır)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "vi": "/*\n  Xác định xem dãy số đã cho có tạo thành một dãy số cấp số cộng hay không.\n\n  Một dãy số cấp số cộng là một dãy số mà hiệu giữa các số liên tiếp là không đổi.\n\n  Tham số:\n  - sequence: Một mảng con của các số nguyên đại diện cho dãy số cần kiểm tra.\n\n  Trả về:\n  - Một giá trị boolean cho biết liệu dãy số có tạo thành một dãy số cấp số cộng (`true`) hay không (`false`).\n\n  Ví dụ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) trả về true (vì hiệu là 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) trả về false (vì hiệu không không đổi)\n  - is_arithmetic_sequence(&[10, 10, 10]) trả về true (vì hiệu là 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "es": "0.9888103561147806",
      "arb": "0.9831120477436517",
      "sw": "0.9852213037598612",
      "tr": "0.9713594853585795",
      "vi": "0.9674641449561043"
    },
    "canonical_solution": "{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}",
    "instruction": {
      "en": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nRust kodunun işlevini açıklayan, en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9206946354376295",
      "sw": "0.9431116629804649",
      "tr": "0.8853124070335039",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_arithmetic_sequence(&[5, 7, 9, 11]), true);  // True, as 2 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[1, 2, 4, 8]), false);  // False, as difference changes\n        assert_eq!(is_arithmetic_sequence(&[10, 10, 10]), true);   // True, as 0 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[3, 6, 9, 12, 16]), false); // False, last difference is not 3\n    }\n}",
    "entry_point": "is_arithmetic_sequence",
    "signature": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)",
      "es": "Determina si la secuencia dada de números forma una secuencia aritmética.\n\n  Una secuencia aritmética es una secuencia de números tal que la diferencia entre números consecutivos es constante.\n\n  Argumentos:\n  - sequence: Un segmento de matriz de enteros que representa la secuencia a verificar.\n\n  Retorna:\n  - Un valor booleano que indica si la secuencia forma una secuencia aritmética (`true`) o no (`false`).\n\n  Ejemplos:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) devuelve true (ya que la diferencia es 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) devuelve false (ya que la diferencia no es constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) devuelve true (ya que la diferencia es 0)",
      "arb": "يحدد ما إذا كانت سلسلة الأرقام المعطاة تشكل متتالية حسابية.\n\n  المتتالية الحسابية هي سلسلة من الأرقام بحيث يكون الفرق بين الأرقام المتتالية ثابتًا.\n\n  الحجج:\n  - sequence: مقطع من مصفوفة الأعداد الصحيحة يمثل السلسلة التي سيتم التحقق منها.\n\n  يعيد:\n  - قيمة منطقية تشير إلى ما إذا كانت السلسلة تشكل متتالية حسابية (`true`) أم لا (`false`).\n\n  أمثلة:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) يعيد true (حيث أن الفرق هو 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) يعيد false (حيث أن الفرق ليس ثابتًا)\n  - is_arithmetic_sequence(&[10, 10, 10]) يعيد true (حيث أن الفرق هو 0)",
      "sw": "Huamua kama mlolongo uliotolewa wa nambari unaunda mlolongo wa hesabu.\n\n  Mlolongo wa hesabu ni mlolongo wa nambari ambapo tofauti kati ya nambari mfululizo ni ya kudumu.\n\n  Hoja:\n  - sequence: Kipande cha safu ya nambari nzima kinachowakilisha mlolongo unaopaswa kukaguliwa.\n\n  Inarudisha:\n  - Thamani ya boolean inayoonyesha kama mlolongo unaunda mlolongo wa hesabu (`true`) au la (`false`).\n\n  Mifano:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) inarudisha true (kwa kuwa tofauti ni 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) inarudisha false (kwa kuwa tofauti si ya kudumu)\n  - is_arithmetic_sequence(&[10, 10, 10]) inarudisha true (kwa kuwa tofauti ni 0)",
      "tr": "Verilen sayı dizisinin aritmetik bir dizi oluşturup oluşturmadığını belirler.\n\n  Aritmetik bir dizi, ardışık sayılar arasındaki farkın sabit olduğu bir sayı dizisidir.\n\n  Argümanlar:\n  - sequence: Kontrol edilecek diziyi temsil eden tamsayıların bir dizi dilimi.\n\n  Döndürür:\n  - Dizinin aritmetik bir dizi oluşturup oluşturmadığını belirten bir boolean değeri (`true`) veya değilse (`false`).\n\n  Örnekler:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true döndürür (çünkü fark 2'dir)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false döndürür (çünkü fark sabit değildir)\n  - is_arithmetic_sequence(&[10, 10, 10]) true döndürür (çünkü fark 0'dır)",
      "vi": "Xác định liệu dãy số đã cho có phải là một dãy số cấp số cộng hay không.\n\nMột dãy số cấp số cộng là một dãy số mà hiệu giữa các số liên tiếp là không đổi.\n\nCác đối số:\n- sequence: Một mảng con của các số nguyên đại diện cho dãy số cần kiểm tra.\n\nTrả về:\n- Một giá trị boolean cho biết liệu dãy số có phải là một dãy số cấp số cộng (`true`) hay không (`false`).\n\nVí dụ:\n- is_arithmetic_sequence(&[5, 7, 9, 11]) trả về true (vì hiệu là 2)\n- is_arithmetic_sequence(&[1, 2, 4, 8]) trả về false (vì hiệu không không đổi)\n- is_arithmetic_sequence(&[10, 10, 10]) trả về true (vì hiệu là 0)"
    },
    "docstring_bertscore": {
      "es": "0.9843366040427318",
      "arb": "0.9776965890351166",
      "sw": "0.9850701460398936",
      "tr": "0.9826788348826146",
      "vi": "0.9583297296234529"
    }
  },
  {
    "task_id": "Rust/27",
    "prompt": {
      "en": "\n/*\n  Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "es": "/*\n  Calcula el día del año para una fecha dada en el formato YYYY/MM/DD.\n\n  Argumentos:\n  - date: Una cadena que representa una fecha en el formato YYYY/MM/DD.\n\n  Retorna:\n  - Ok(usize): El día del año como un número si la fecha es válida.\n  - Err(String): Un mensaje de error si la fecha es inválida.\n\n  Ejemplo:\n  - day_of_year(\"1985/1/20\") Devuelve Ok(20)\n  - day_of_year(\"2006/3/12\") Devuelve Ok(71)\n  - day_of_year(\"2024/2/30\") Devuelve Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "arb": "/*\n  يحسب اليوم من السنة لتاريخ معين في صيغة YYYY/MM/DD.\n\n  الوسائط:\n  - date: سلسلة تمثل تاريخًا في صيغة YYYY/MM/DD.\n\n  يعيد:\n  - Ok(usize): اليوم من السنة كرقم إذا كان التاريخ صالحًا.\n  - Err(String): رسالة خطأ إذا كان التاريخ غير صالح.\n\n  مثال:\n  - day_of_year(\"1985/1/20\") يعيد Ok(20)\n  - day_of_year(\"2006/3/12\") يعيد Ok(71)\n  - day_of_year(\"2024/2/30\") يعيد Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "sw": "/*\n  Inahesabu siku ya mwaka kwa tarehe iliyotolewa katika muundo wa YYYY/MM/DD.\n\n  Hoja:\n  - date: Kamba inayowakilisha tarehe katika muundo wa YYYY/MM/DD.\n\n  Inarejesha:\n  - Ok(usize): Siku ya mwaka kama nambari ikiwa tarehe ni sahihi.\n  - Err(String): Ujumbe wa kosa ikiwa tarehe si sahihi.\n\n  Mfano:\n  - day_of_year(\"1985/1/20\") inarejesha Ok(20)\n  - day_of_year(\"2006/3/12\") inarejesha Ok(71)\n  - day_of_year(\"2024/2/30\") inarejesha Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "tr": "/*\n  YYYY/MM/DD formatındaki bir tarih dizesi için yılın gününü hesaplar.\n\n  Argümanlar:\n  - date: YYYY/MM/DD formatında bir tarihi temsil eden bir dize.\n\n  Döndürür:\n  - Ok(usize): Tarih geçerliyse yılın günü olarak bir sayı.\n  - Err(String): Tarih geçersizse bir hata mesajı.\n\n  Örnek:\n  - day_of_year(\"1985/1/20\") Döndürür Ok(20)\n  - day_of_year(\"2006/3/12\") Döndürür Ok(71)\n  - day_of_year(\"2024/2/30\") Döndürür Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "vi": "/*\n  Tính toán ngày trong năm cho một chuỗi ngày đã cho theo định dạng YYYY/MM/DD.\n\n  Tham số:\n  - date: Một chuỗi đại diện cho một ngày theo định dạng YYYY/MM/DD.\n\n  Trả về:\n  - Ok(usize): Ngày trong năm dưới dạng một số nếu ngày hợp lệ.\n  - Err(String): Một thông báo lỗi nếu ngày không hợp lệ.\n\n  Ví dụ:\n  - day_of_year(\"1985/1/20\") trả về Ok(20)\n  - day_of_year(\"2006/3/12\") trả về Ok(71)\n  - day_of_year(\"2024/2/30\") trả về Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> "
    },
    "prompt_bertscore": {
      "es": "0.9957890359220604",
      "arb": "0.9957890359220604",
      "sw": "0.9943614793735627",
      "tr": "0.9751706064794958",
      "vi": "0.9920418737838372"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nRust kodunun işlevini açıklayan özlü bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8805792436838235",
      "sw": "0.9153697521828462",
      "tr": "0.8781877338961634",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(day_of_year(\"1985/1/20\"), Ok(20));\n        assert_eq!(day_of_year(\"2006/3/12\"), Ok(71));\n        assert_eq!(day_of_year(\"2024/2/30\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/13/10\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/2/29\"), Ok(60)); // Leap year case\n\n    }\n    \n\n}",
    "entry_point": "day_of_year",
    "signature": "fn day_of_year(date: &str) -> Result<usize, String>",
    "docstring": {
      "en": "Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "es": "Calcula el día del año para una cadena de fecha dada en el formato YYYY/MM/DD.\n\n  Argumentos:\n  - date: Una cadena que representa una fecha en el formato YYYY/MM/DD.\n\n  Retorna:\n  - Ok(usize): El día del año como un número si la fecha es válida.\n  - Err(String): Un mensaje de error si la fecha es inválida.\n\n  Ejemplo:\n  - day_of_year(\"1985/1/20\") Devuelve Ok(20)\n  - day_of_year(\"2006/3/12\") Devuelve Ok(71)\n  - day_of_year(\"2024/2/30\") Devuelve Err(\"Invalid\")",
      "arb": "يحسب اليوم من السنة لتاريخ معين في صيغة YYYY/MM/DD.\n\n  الحجج:\n  - date: سلسلة تمثل تاريخًا في الصيغة YYYY/MM/DD.\n\n  يعيد:\n  - Ok(usize): اليوم من السنة كرقم إذا كان التاريخ صالحًا.\n  - Err(String): رسالة خطأ إذا كان التاريخ غير صالح.\n\n  مثال:\n  - day_of_year(\"1985/1/20\") يعيد Ok(20)\n  - day_of_year(\"2006/3/12\") يعيد Ok(71)\n  - day_of_year(\"2024/2/30\") يعيد Err(\"Invalid\")",
      "sw": "Hesabu siku ya mwaka kwa tarehe iliyotolewa katika muundo wa YYYY/MM/DD.\n\n  Hoja:\n  - date: Kamba inayowakilisha tarehe katika muundo wa YYYY/MM/DD.\n\n  Inarejesha:\n  - Ok(usize): Siku ya mwaka kama nambari ikiwa tarehe ni sahihi.\n  - Err(String): Ujumbe wa kosa ikiwa tarehe si sahihi.\n\n  Mfano:\n  - day_of_year(\"1985/1/20\") inarejesha Ok(20)\n  - day_of_year(\"2006/3/12\") inarejesha Ok(71)\n  - day_of_year(\"2024/2/30\") inarejesha Err(\"Invalid\")",
      "tr": "Yılın gününü, YYYY/MM/DD formatındaki bir tarih dizesi için hesaplar.\n\n  Argümanlar:\n  - date: YYYY/MM/DD formatında bir tarihi temsil eden bir dize.\n\n  Döndürür:\n  - Ok(usize): Tarih geçerliyse, yılın günü olarak bir sayı.\n  - Err(String): Tarih geçersizse bir hata mesajı.\n\n  Örnek:\n  - day_of_year(\"1985/1/20\") Ok(20) döndürür\n  - day_of_year(\"2006/3/12\") Ok(71) döndürür\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") döndürür",
      "vi": "Tính toán ngày trong năm cho một chuỗi ngày đã cho theo định dạng YYYY/MM/DD.\n\n  Tham số:\n  - date: Một chuỗi đại diện cho một ngày theo định dạng YYYY/MM/DD.\n\n  Trả về:\n  - Ok(usize): Ngày trong năm dưới dạng một số nếu ngày hợp lệ.\n  - Err(String): Một thông báo lỗi nếu ngày không hợp lệ.\n\n  Ví dụ:\n  - day_of_year(\"1985/1/20\") trả về Ok(20)\n  - day_of_year(\"2006/3/12\") trả về Ok(71)\n  - day_of_year(\"2024/2/30\") trả về Err(\"Invalid\")"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9908479065634365",
      "sw": "0.9906659611344085",
      "tr": "0.9863832914889153",
      "vi": "0.988567232528394"
    }
  },
  {
    "task_id": "Rust/28",
    "prompt": {
      "en": "/*\n  Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "es": "/*\n  Elimina números duplicados de un vector dado y luego ordena los números restantes en orden ascendente.\n\n  Argumentos:\n  - numbers: Un vector de enteros que van de 1 a 1000, con una longitud que no excede 100.\n\n  Devuelve:\n  - Un vector que contiene los elementos únicos del vector original, ordenados en orden ascendente.\n\n  Ejemplos:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) Devuelve vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) Devuelve vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) Devuelve vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "arb": "/*\n  يزيل الأرقام المكررة من متجه معين ثم يقوم بترتيب الأرقام المتبقية بترتيب تصاعدي.\n\n  الوسائط:\n  - numbers: متجه من الأعداد الصحيحة يتراوح من 1 إلى 1000، بطول لا يتجاوز 100.\n\n  يعيد:\n  - متجه يحتوي على العناصر الفريدة من المتجه الأصلي، مرتبة بترتيب تصاعدي.\n\n  أمثلة:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) يعيد vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) يعيد vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) يعيد vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "sw": "/*\n  Huondoa namba zinazojirudia kutoka kwenye vector iliyotolewa na kisha kupanga namba zilizobaki kwa mpangilio wa kuongezeka.\n\n  Hoja:\n  - numbers: Vector ya namba za mzima kati ya 1 hadi 1000, yenye urefu usiozidi 100.\n\n  Inarudisha:\n  - Vector inayojumuisha vipengele vya kipekee vya vector ya awali, vilivyopangwa kwa mpangilio wa kuongezeka.\n\n  Mifano:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) inarudisha vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) inarudisha vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) inarudisha vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "tr": "/*\n  Verilen bir vektörden tekrar eden sayıları kaldırır ve ardından kalan sayıları artan sırayla sıralar.\n\n  Argümanlar:\n  - numbers: Uzunluğu 100'ü geçmeyen, 1 ile 1000 arasında tamsayılardan oluşan bir vektör.\n\n  Döndürür:\n  - Orijinal vektörün benzersiz elemanlarını içeren ve artan sırayla sıralanmış bir vektör.\n\n  Örnekler:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) Döndürür vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) Döndürür vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) Döndürür vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "vi": "/*\n  Loại bỏ các số trùng lặp từ một vector cho trước và sau đó sắp xếp các số còn lại theo thứ tự tăng dần.\n\n  Tham số:\n  - numbers: Một vector các số nguyên từ 1 đến 1000, với độ dài không vượt quá 100.\n\n  Trả về:\n  - Một vector chứa các phần tử duy nhất của vector ban đầu, được sắp xếp theo thứ tự tăng dần.\n\n  Ví dụ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) trả về vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) trả về vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) trả về vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9916986404854089",
      "sw": "0.9917542569920987",
      "tr": "0.9957383851748964",
      "vi": "0.9796737558479378"
    },
    "canonical_solution": "{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}",
    "instruction": {
      "en": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nRust kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9431116629804649",
      "tr": "0.9140782574453574",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(dedup_and_sort(vec![10, 20, 20, 10, 30]), vec![10, 20, 30]);\n        assert_eq!(dedup_and_sort(vec![5, 4, 3, 2, 1]), vec![1, 2, 3, 4, 5]);\n        assert_eq!(dedup_and_sort(vec![1, 1, 1, 1, 1]), vec![1]);\n        assert_eq!(dedup_and_sort(vec![50]), vec![50]);\n    }\n    \n\n}",
    "entry_point": "dedup_and_sort",
    "signature": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>",
    "docstring": {
      "en": "Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "es": "Elimina los números duplicados de un vector dado y luego ordena los números restantes en orden ascendente.\n\n  Argumentos:\n  - numbers: Un vector de enteros que varía de 1 a 1000, con una longitud que no excede 100.\n\n  Retorna:\n  - Un vector que contiene los elementos únicos del vector original, ordenados en orden ascendente.\n\n  Ejemplos:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) retorna vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) retorna vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) retorna vec![1, 2, 3, 4, 5]",
      "arb": "يزيل الأرقام المكررة من متجه معين ثم يرتب الأرقام المتبقية بترتيب تصاعدي.\n\n  الحجج:\n  - numbers: متجه من الأعداد الصحيحة يتراوح من 1 إلى 1000، بطول لا يتجاوز 100.\n\n  العوائد:\n  - متجه يحتوي على العناصر الفريدة من المتجه الأصلي، مرتبة بترتيب تصاعدي.\n\n  أمثلة:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) يعيد vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) يعيد vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) يعيد vec![1, 2, 3, 4, 5]",
      "sw": "Huondoa namba zinazojirudia kutoka kwenye vector iliyotolewa na kisha kupanga namba zilizobaki kwa mpangilio wa kuongezeka.\n\n  Hoja:\n  - numbers: Vector ya nambari za mzima kati ya 1 hadi 1000, na urefu usiozidi 100.\n\n  Inarudi:\n  - Vector inayojumuisha vipengele vya kipekee vya vector ya asili, vilivyopangwa kwa mpangilio wa kupanda.\n\n  Mifano:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) inarudi vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) inarudi vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) inarudi vec![1, 2, 3, 4, 5]",
      "tr": "Tekrarlayan sayıları verilen bir vektörden kaldırır ve ardından kalan sayıları artan sırayla sıralar.\n\n  Argümanlar:\n  - numbers: Uzunluğu 100'ü geçmeyen, 1 ile 1000 arasında değişen tamsayılar vektörü.\n\n  Döndürür:\n  - Orijinal vektörün benzersiz elemanlarını içeren ve artan sırayla sıralanmış bir vektör.\n\n  Örnekler:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) vec![2, 3, 5] döndürür\n  - dedup_and_sort(vec![7, 5, 7, 5]) vec![5, 7] döndürür\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) vec![1, 2, 3, 4, 5] döndürür",
      "vi": "Loại bỏ các số trùng lặp từ một vector cho trước và sau đó sắp xếp các số còn lại theo thứ tự tăng dần.\n\n  Tham số:\n  - numbers: Một vector các số nguyên trong khoảng từ 1 đến 1000, với độ dài không vượt quá 100.\n\n  Trả về:\n  - Một vector chứa các phần tử duy nhất của vector gốc, được sắp xếp theo thứ tự tăng dần.\n\n  Ví dụ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) trả về vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) trả về vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) trả về vec![1, 2, 3, 4, 5]"
    },
    "docstring_bertscore": {
      "es": "0.9899487068284916",
      "arb": "0.9963972421487892",
      "sw": "0.9945817604661303",
      "tr": "0.9971321745586182",
      "vi": "0.981621525364366"
    }
  },
  {
    "task_id": "Rust/29",
    "prompt": {
      "en": "/*\n  Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "es": "/*\n  Calcula el número de combinaciones C(n, m), que representa el número de formas de elegir m elementos de un conjunto de n elementos distintos.\n\n  Argumentos:\n  - n: Un entero sin signo de 32 bits que representa el número total de elementos (n ≤ 20).\n  - m: Un entero sin signo de 32 bits que representa el número de elementos a elegir (m ≤ n).\n\n  Retorna:\n  - El número de combinaciones C(n, m).\n\n  Ejemplo:\n  - calculate_combinations(5, 2) retorna 10\n  - calculate_combinations(18, 13) retorna 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "arb": "/*\n  يحسب عدد التوافيق C(n, m)، والذي يمثل عدد الطرق لاختيار m عنصرًا من مجموعة تحتوي على n عنصرًا مميزًا.\n\n  الوسائط:\n  - n: عدد صحيح غير موقع 32-بت يمثل العدد الكلي للعناصر (n ≤ 20).\n  - m: عدد صحيح غير موقع 32-بت يمثل عدد العناصر التي سيتم اختيارها (m ≤ n).\n\n  يعيد:\n  - عدد التوافيق C(n, m).\n\n  مثال:\n  - calculate_combinations(5, 2) يعيد 10\n  - calculate_combinations(18, 13) يعيد 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "sw": "/*\n  Inahesabu namba ya mchanganyiko C(n, m), ambayo inawakilisha idadi ya njia za kuchagua vipengele m kutoka kwenye seti ya vipengele n tofauti.\n\n  Hoja:\n  - n: Namba isiyo na ishara ya biti 32 inayowakilisha jumla ya idadi ya vipengele (n ≤ 20).\n  - m: Namba isiyo na ishara ya biti 32 inayowakilisha idadi ya vipengele vya kuchagua (m ≤ n).\n\n  Inarudisha:\n  - Namba ya mchanganyiko C(n, m).\n\n  Mfano:\n  - calculate_combinations(5, 2) inarudisha 10\n  - calculate_combinations(18, 13) inarudisha 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "tr": "/*\n  C(n, m) kombinasyon sayısını hesaplar, bu da n farklı elemandan m eleman seçmenin yollarının sayısını temsil eder.\n\n  Argümanlar:\n  - n: Toplam eleman sayısını temsil eden 32-bit işaretsiz bir tamsayı (n ≤ 20).\n  - m: Seçilecek eleman sayısını temsil eden 32-bit işaretsiz bir tamsayı (m ≤ n).\n\n  Döndürür:\n  - C(n, m) kombinasyon sayısı.\n\n  Örnek:\n  - calculate_combinations(5, 2) 10 döndürür\n  - calculate_combinations(18, 13) 8568 döndürür\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "vi": "/*\n  Tính số tổ hợp C(n, m), đại diện cho số cách chọn m phần tử từ một tập hợp gồm n phần tử khác nhau.\n\n  Tham số:\n  - n: Một số nguyên không dấu 32-bit đại diện cho tổng số phần tử (n ≤ 20).\n  - m: Một số nguyên không dấu 32-bit đại diện cho số phần tử cần chọn (m ≤ n).\n\n  Trả về:\n  - Số tổ hợp C(n, m).\n\n  Ví dụ:\n  - calculate_combinations(5, 2) trả về 10\n  - calculate_combinations(18, 13) trả về 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 "
    },
    "prompt_bertscore": {
      "es": "0.9800674412631489",
      "arb": "0.9690527907436213",
      "sw": "0.9914777635016981",
      "tr": "0.969614517461188",
      "vi": "0.9698876342351109"
    },
    "canonical_solution": "{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}",
    "instruction": {
      "en": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9153697521828462",
      "tr": "0.8586830250000616",
      "vi": "0.9242012561844194"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_combinations(5, 2), 10);\n        assert_eq!(calculate_combinations(18, 13), 8568);\n        assert_eq!(calculate_combinations(10, 0), 1);\n        assert_eq!(calculate_combinations(20, 20), 1);\n        assert_eq!(calculate_combinations(15, 5), 3003);\n    }\n    \n\n}",
    "entry_point": "calculate_combinations",
    "signature": "fn calculate_combinations(n: u32, m: u32) -> u64",
    "docstring": {
      "en": "Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568",
      "es": "Calcula el número de combinaciones C(n, m), que representa el número de formas de elegir m elementos de un conjunto de n elementos distintos.\n\n  Argumentos:\n  - n: Un entero sin signo de 32 bits que representa el número total de elementos (n ≤ 20).\n  - m: Un entero sin signo de 32 bits que representa el número de elementos a elegir (m ≤ n).\n\n  Retorna:\n  - El número de combinaciones C(n, m).\n\n  Ejemplo:\n  - calculate_combinations(5, 2) retorna 10\n  - calculate_combinations(18, 13) retorna 8568",
      "arb": "يحسب عدد التوافيق C(n, m)، الذي يمثل عدد الطرق لاختيار m عنصرًا من مجموعة مكونة من n عنصرًا مميزًا.\n\n  الحجج:\n  - n: عدد صحيح غير موقع 32 بت يمثل العدد الإجمالي للعناصر (n ≤ 20).\n  - m: عدد صحيح غير موقع 32 بت يمثل عدد العناصر المراد اختيارها (m ≤ n).\n\n  يعيد:\n  - عدد التوافيق C(n, m).\n\n  مثال:\n  - calculate_combinations(5, 2) يعيد 10\n  - calculate_combinations(18, 13) يعيد 8568",
      "sw": "Hesabu nambari ya mchanganyiko C(n, m), ambayo inawakilisha idadi ya njia za kuchagua vipengele m kutoka kwenye seti ya vipengele n tofauti.\n\n  Hoja:\n  - n: Nambari isiyo na ishara ya biti 32 inayowakilisha jumla ya idadi ya vipengele (n ≤ 20).\n  - m: Nambari isiyo na ishara ya biti 32 inayowakilisha idadi ya vipengele vya kuchagua (m ≤ n).\n\n  Inarejesha:\n  - Nambari ya mchanganyiko C(n, m).\n\n  Mfano:\n  - calculate_combinations(5, 2) inarejesha 10\n  - calculate_combinations(18, 13) inarejesha 8568",
      "tr": "n elemanlı bir kümeden m eleman seçmenin yollarının sayısını temsil eden kombinasyon sayısı C(n, m)'yi hesaplar.\n\n  Argümanlar:\n  - n: Toplam eleman sayısını temsil eden işaretsiz 32-bit tamsayı (n ≤ 20).\n  - m: Seçilecek eleman sayısını temsil eden işaretsiz 32-bit tamsayı (m ≤ n).\n\n  Döndürür:\n  - Kombinasyon sayısı C(n, m).\n\n  Örnek:\n  - calculate_combinations(5, 2) 10 döndürür\n  - calculate_combinations(18, 13) 8568 döndürür",
      "vi": "Tính toán số tổ hợp C(n, m), đại diện cho số cách chọn m phần tử từ một tập hợp gồm n phần tử khác nhau.\n\n  Tham số:\n  - n: Một số nguyên không dấu 32-bit đại diện cho tổng số phần tử (n ≤ 20).\n  - m: Một số nguyên không dấu 32-bit đại diện cho số phần tử cần chọn (m ≤ n).\n\n  Trả về:\n  - Số tổ hợp C(n, m).\n\n  Ví dụ:\n  - calculate_combinations(5, 2) trả về 10\n  - calculate_combinations(18, 13) trả về 8568"
    },
    "docstring_bertscore": {
      "es": "0.9736771046444945",
      "arb": "0.971692588507575",
      "sw": "0.9736771046444945",
      "tr": "0.9389289044166322",
      "vi": "0.9623857620041852"
    }
  },
  {
    "task_id": "Rust/30",
    "prompt": {
      "en": "/*\n  Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "es": "/*\n  Determina si Yuanzi puede ganar una carrera de caballos contra un oponente organizando óptimamente sus caballos.\n\n  La función compara las velocidades de los caballos de Yuanzi con las de los caballos del oponente. Cada caballo tiene una velocidad fija y no hay empates. Yuanzi gana si gana más de la mitad de las carreras individuales.\n\n  Argumentos:\n  - yuanzi_horses: Un arreglo de enteros que representa las velocidades de los caballos de Yuanzi.\n  - opponent_horses: Un arreglo de enteros que representa las velocidades de los caballos del oponente.\n\n  Retorna:\n  - Un valor booleano: `true` si Yuanzi puede ganar la carrera, `false` de lo contrario.\n\n  Ejemplos:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) retorna true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) retorna false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "arb": "/*\n  يحدد ما إذا كان بإمكان يوانزي الفوز بسباق الخيل ضد خصم عن طريق ترتيب خيوله بشكل مثالي.\n\n  تقارن الدالة سرعات خيول يوانزي بسرعات خيول الخصم. كل حصان لديه سرعة ثابتة ولا توجد تعادلات. يفوز يوانزي إذا فاز بأكثر من نصف السباقات الفردية.\n\n  الوسائط:\n  - yuanzi_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول يوانزي.\n  - opponent_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول الخصم.\n\n  يعيد:\n  - قيمة منطقية: `true` إذا كان بإمكان يوانزي الفوز بالسباق، `false` خلاف ذلك.\n\n  أمثلة:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) يعيد true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) يعيد false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "sw": "/*\n  Huamua ikiwa Yuanzi anaweza kushinda mbio za farasi dhidi ya mpinzani kwa kupanga farasi wake kwa njia bora.\n\n  Kazi inalinganisha kasi za farasi wa Yuanzi na zile za farasi wa mpinzani. Kila farasi ana kasi iliyowekwa na hakuna sare. Yuanzi anashinda ikiwa anashinda zaidi ya nusu ya mbio za kibinafsi.\n\n  Hoja:\n  - yuanzi_horses: Kundi la nambari za mzima linalowakilisha kasi za farasi wa Yuanzi.\n  - opponent_horses: Kundi la nambari za mzima linalowakilisha kasi za farasi wa mpinzani.\n\n  Inarudisha:\n  - Thamani ya boolean: `true` ikiwa Yuanzi anaweza kushinda mbio, `false` vinginevyo.\n\n  Mifano:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) inarudisha true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) inarudisha false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "tr": "/*\n  Yuanzi'nin rakibine karşı bir at yarışı kazanıp kazanamayacağını atlarını en iyi şekilde düzenleyerek belirler.\n\n  Fonksiyon, Yuanzi'nin atlarının hızlarını rakibinin atlarının hızlarıyla karşılaştırır. Her atın sabit bir hızı vardır ve beraberlik yoktur. Yuanzi, bireysel yarışların yarısından fazlasını kazanırsa kazanır.\n\n  Argümanlar:\n  - yuanzi_horses: Yuanzi'nin atlarının hızlarını temsil eden bir tamsayı dizisi.\n  - opponent_horses: Rakibin atlarının hızlarını temsil eden bir tamsayı dizisi.\n\n  Döndürür:\n  - Bir boolean değer: Yuanzi yarışı kazanabiliyorsa `true`, aksi takdirde `false`.\n\n  Örnekler:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true döndürür\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false döndürür\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "vi": "/*\n  Xác định xem Yuanzi có thể thắng một cuộc đua ngựa chống lại đối thủ bằng cách sắp xếp tối ưu các con ngựa của mình hay không.\n\n  Hàm so sánh tốc độ của các con ngựa của Yuanzi với tốc độ của các con ngựa của đối thủ. Mỗi con ngựa có tốc độ cố định và không có trận hòa. Yuanzi thắng nếu anh ta thắng hơn một nửa số cuộc đua cá nhân.\n\n  Tham số:\n  - yuanzi_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của Yuanzi.\n  - opponent_horses: Một mảng số nguyên đại diện cho tốc độ của các con ngựa của đối thủ.\n\n  Trả về:\n  - Một giá trị boolean: `true` nếu Yuanzi có thể thắng cuộc đua, `false` nếu không.\n\n  Ví dụ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) trả về true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) trả về false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "es": "0.99512104195064",
      "arb": "0.9937324169568251",
      "sw": "0.9960571869364575",
      "tr": "0.9848367553421776",
      "vi": "0.9847477689314741"
    },
    "canonical_solution": "{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}",
    "instruction": {
      "en": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9238518653441791",
      "sw": "0.9099693893832697",
      "tr": "0.872144404553177",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]), true);\n        assert_eq!(can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]), false);\n    }\n    \n\n}",
    "entry_point": "can_win_horse_race",
    "signature": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "es": "Determina si Yuanzi puede ganar una carrera de caballos contra un oponente organizando óptimamente sus caballos.\n\n  La función compara las velocidades de los caballos de Yuanzi con las de los caballos del oponente. Cada caballo tiene una velocidad fija y no hay empates. Yuanzi gana si gana más de la mitad de las carreras individuales.\n\n  Argumentos:\n  - yuanzi_horses: Un arreglo de enteros que representa las velocidades de los caballos de Yuanzi.\n  - opponent_horses: Un arreglo de enteros que representa las velocidades de los caballos del oponente.\n\n  Retorna:\n  - Un valor booleano: `true` si Yuanzi puede ganar la carrera, `false` de lo contrario.\n\n  Ejemplos:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) retorna true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) retorna false",
      "arb": "يحدد ما إذا كان يمكن ليوانزي الفوز في سباق الخيل ضد خصم عن طريق ترتيب خيوله بشكل مثالي.\n\nتقارن الدالة سرعات خيول يوانزي مع سرعات خيول الخصم. كل حصان له سرعة ثابتة ولا توجد تعادلات. يفوز يوانزي إذا فاز في أكثر من نصف السباقات الفردية.\n\nالمعطيات:\n- yuanzi_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول يوانزي.\n- opponent_horses: مصفوفة من الأعداد الصحيحة تمثل سرعات خيول الخصم.\n\nالقيم المعادة:\n- قيمة منطقية: `true` إذا كان يمكن ليوانزي الفوز في السباق، `false` خلاف ذلك.\n\nأمثلة:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) تعيد true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) تعيد false",
      "sw": "Huamua ikiwa Yuanzi anaweza kushinda mbio za farasi dhidi ya mpinzani kwa kupanga farasi wake kwa njia bora.\n\n  Kazi hii inalinganisha kasi za farasi wa Yuanzi na zile za farasi wa mpinzani. Kila farasi ana kasi iliyowekwa na hakuna sare. Yuanzi anashinda ikiwa atashinda zaidi ya nusu ya mbio za kibinafsi.\n\n  Hoja:\n  - yuanzi_horses: Mfululizo wa nambari za mzima zinazoonyesha kasi za farasi wa Yuanzi.\n  - opponent_horses: Mfululizo wa nambari za mzima zinazoonyesha kasi za farasi wa mpinzani.\n\n  Inarudisha:\n  - Thamani ya boolean: `true` ikiwa Yuanzi anaweza kushinda mbio, `false` vinginevyo.\n\n  Mifano:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) inarudisha true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) inarudisha false",
      "tr": "Yuanzi'nin atlarını en iyi şekilde düzenleyerek bir rakibe karşı at yarışını kazanıp kazanamayacağını belirler.\n\n  Fonksiyon, Yuanzi'nin atlarının hızlarını rakibin atlarının hızlarıyla karşılaştırır. Her atın sabit bir hızı vardır ve eşitlik yoktur. Yuanzi, bireysel yarışların yarısından fazlasını kazanırsa kazanır.\n\n  Argümanlar:\n  - yuanzi_horses: Yuanzi'nin atlarının hızlarını temsil eden bir tamsayı dizisi.\n  - opponent_horses: Rakibin atlarının hızlarını temsil eden bir tamsayı dizisi.\n\n  Döndürülenler:\n  - Bir boolean değeri: Yuanzi yarışı kazanabiliyorsa `true`, aksi takdirde `false`.\n\n  Örnekler:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true döndürür\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false döndürür",
      "vi": "Xác định liệu Yuanzi có thể thắng một cuộc đua ngựa chống lại đối thủ bằng cách sắp xếp tối ưu các con ngựa của mình.\n\nHàm so sánh tốc độ của các con ngựa của Yuanzi với các con ngựa của đối thủ. Mỗi con ngựa có tốc độ cố định và không có trường hợp hòa. Yuanzi thắng nếu anh thắng hơn một nửa số cuộc đua cá nhân.\n\nCác đối số:\n- yuanzi_horses: Một mảng các số nguyên đại diện cho tốc độ của các con ngựa của Yuanzi.\n- opponent_horses: Một mảng các số nguyên đại diện cho tốc độ của các con ngựa của đối thủ.\n\nTrả về:\n- Một giá trị boolean: `true` nếu Yuanzi có thể thắng cuộc đua, `false` nếu không.\n\nVí dụ:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) trả về true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) trả về false"
    },
    "docstring_bertscore": {
      "es": "0.999083916682667",
      "arb": "0.9814060114009431",
      "sw": "0.9819131147637251",
      "tr": "0.9795106803051081",
      "vi": "0.9814924156166932"
    }
  },
  {
    "task_id": "Rust/31",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "es": "/*\n  Calcula el número de diferentes maneras de subir una escalera de un número dado de escalones, donde en cada paso, se puede subir un escalón o dos escalones. Comienzas en el nivel 0.\n\n  Argumentos:\n  - stairs: Un entero que representa el número de escalones en la escalera.\n\n  Devuelve:\n  - Un entero que representa el número de diferentes maneras de subir la escalera.\n\n  Ejemplo:\n  - count_ways_to_climb(2) devuelve 2 (1 paso + 1 paso, 2 pasos)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "arb": "/*\n  يحسب عدد الطرق المختلفة لتسلق سلم بعدد معين من الدرجات، حيث يمكن عند كل درجة إما تسلق درجة واحدة أو درجتين. تبدأ من المستوى 0.\n\n  الوسائط:\n  - stairs: عدد صحيح يمثل عدد الدرجات في السلم.\n\n  يعيد:\n  - عدد صحيح يمثل عدد الطرق المختلفة لتسلق السلم.\n\n  مثال:\n  - count_ways_to_climb(2) يعيد 2 (1 درجة + 1 درجة، درجتين)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya njia tofauti za kupanda ngazi ya idadi fulani ya hatua, ambapo katika kila hatua, mtu anaweza kupanda hatua moja au hatua mbili. Unaanzia kiwango cha 0.\n\n  Hoja:\n  - stairs: Nambari nzima inayowakilisha idadi ya hatua kwenye ngazi.\n\n  Inarejesha:\n  - Nambari nzima inayowakilisha idadi ya njia tofauti za kupanda ngazi.\n\n  Mfano:\n  - count_ways_to_climb(2) inarejesha 2 (hatua 1 + hatua 1, hatua 2)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "tr": "/*\n  Belirli bir basamak sayısına sahip bir merdiveni çıkmanın farklı yollarının sayısını hesaplar, burada her adımda bir veya iki basamak çıkılabilir. Seviye 0'dan başlarsınız.\n\n  Argümanlar:\n  - stairs: Merdivendeki basamak sayısını temsil eden bir tamsayı.\n\n  Döndürür:\n  - Merdiveni çıkmanın farklı yollarının sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - count_ways_to_climb(2) 2 döndürür (1 basamak + 1 basamak, 2 basamak)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "vi": "/*\n  Tính số cách khác nhau để leo lên một cầu thang với số bậc thang cho trước, trong đó tại mỗi bậc, có thể leo lên một bậc hoặc hai bậc. Bạn bắt đầu ở mức 0.\n\n  Tham số:\n  - stairs: Một số nguyên đại diện cho số bậc thang trong cầu thang.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cách khác nhau để leo lên cầu thang.\n\n  Ví dụ:\n  - count_ways_to_climb(2) trả về 2 (1 bước + 1 bước, 2 bước)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9909742354857747",
      "arb": "0.9858539415234573",
      "sw": "0.9763312037958827",
      "tr": "0.9403183239319712",
      "vi": "0.9791841319586868"
    },
    "canonical_solution": "{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}",
    "instruction": {
      "en": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español usando como máximo 500 caracteres.",
      "arb": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nRust kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde özlü bir şekilde sağlayın.",
      "vi": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9431116629804649",
      "tr": "0.8500839185442992",
      "vi": "0.9395003640228696"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n  \n    #[test]\n    fn main() {\n      \n        assert_eq!(count_ways_to_climb(2), 2); // 2 ways: (1+1), (2)\n        assert_eq!(count_ways_to_climb(3), 3); // 3 ways: (1+1+1), (1+2), (2+1)\n        assert_eq!(count_ways_to_climb(4), 5); // 5 ways: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)\n        assert_eq!(count_ways_to_climb(10), 89); \n        assert_eq!(count_ways_to_climb(24), 75025); \n        println!(\"All test cases passed.\");\n    }\n    \n\n}",
    "entry_point": "count_ways_to_climb",
    "signature": "fn count_ways_to_climb(stairs: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "es": "Calcula el número de diferentes maneras de subir una escalera de un número dado de escalones, donde en cada paso, uno puede subir un escalón o dos escalones. Comienzas en el nivel 0.\n\n  Argumentos:\n  - stairs: Un entero que representa el número de escalones en la escalera.\n\n  Devuelve:\n  - Un entero que representa el número de diferentes maneras de subir la escalera.\n\n  Ejemplo:\n  - count_ways_to_climb(2) devuelve 2 (1 paso + 1 paso, 2 pasos)",
      "arb": "يحسب عدد الطرق المختلفة لتسلق درج بعدد معين من الخطوات، حيث يمكن في كل خطوة إما تسلق خطوة واحدة أو خطوتين. تبدأ من المستوى 0.\n\n  الحجج:\n  - stairs: عدد صحيح يمثل عدد الخطوات في الدرج.\n\n  يعيد:\n  - عدد صحيح يمثل عدد الطرق المختلفة لتسلق الدرج.\n\n  مثال:\n  - count_ways_to_climb(2) يعيد 2 (خطوة واحدة + خطوة واحدة، خطوتين)",
      "sw": "Hesabu idadi ya njia tofauti za kupanda ngazi yenye idadi fulani ya hatua, ambapo katika kila hatua, mtu anaweza kupanda hatua moja au hatua mbili. Unaanzia kiwango cha 0.\n\n  Hoja:\n  - stairs: Nambari nzima inayowakilisha idadi ya hatua kwenye ngazi.\n\n  Inarudi:\n  - Nambari nzima inayowakilisha idadi ya njia tofauti za kupanda ngazi.\n\n  Mfano:\n  - count_ways_to_climb(2) inarudi 2 (hatua 1 + hatua 1, hatua 2)",
      "tr": "Verilen basamak sayısına sahip bir merdiveni çıkmanın farklı yollarının sayısını hesaplar, burada her adımda bir veya iki adım çıkılabilir. 0. seviyeden başlarsınız.\n\n  Argümanlar:\n  - stairs: Merdivendeki basamak sayısını temsil eden bir tamsayı.\n\n  Döndürür:\n  - Merdiveni çıkmanın farklı yollarının sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - count_ways_to_climb(2) 2 döndürür (1 adım + 1 adım, 2 adım)",
      "vi": "Tính toán số cách khác nhau để leo lên một cầu thang với số bậc thang cho trước, trong đó tại mỗi bậc, bạn có thể leo một bậc hoặc hai bậc. Bạn bắt đầu ở mức 0.\n\n  Tham số:\n  - stairs: Một số nguyên đại diện cho số bậc thang trong cầu thang.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cách khác nhau để leo lên cầu thang.\n\n  Ví dụ:\n  - count_ways_to_climb(2) trả về 2 (1 bậc + 1 bậc, 2 bậc)"
    },
    "docstring_bertscore": {
      "es": "0.9920480313256493",
      "arb": "0.9632744343289353",
      "sw": "0.9539588680887802",
      "tr": "0.9433736564530499",
      "vi": "0.9716959652240525"
    }
  },
  {
    "task_id": "Rust/32",
    "prompt": {
      "en": "\n/*\n  Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "es": "/*\n  Encuentra todos los rangos de números naturales consecutivos cuya suma es igual a la suma objetivo dada.\n\n  La función identifica todas las posibles secuencias contiguas de números naturales donde la suma de todos los números en la secuencia es igual a la suma objetivo. La función devuelve un vector de tuplas, cada tupla representa el inicio y el final de una secuencia.\n\n  Argumentos:\n  - target_sum: Un entero que representa la suma objetivo (10 <= target_sum <= 2,000,000).\n\n  Devuelve:\n  - Un vector de tuplas. Cada tupla contiene dos enteros: el primer y último número en una secuencia contigua que suma la suma objetivo.\n\n  Ejemplo:\n  - find_sum_sequence_ranges(10000) Devuelve vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "arb": "/*\n  يجد جميع نطاقات الأعداد الطبيعية المتتالية التي يساوي مجموعها المجموع المستهدف المعطى.\n\n  تحدد الدالة جميع التسلسلات المتجاورة الممكنة للأعداد الطبيعية حيث يساوي مجموع جميع الأعداد في التسلسل المجموع المستهدف. تعيد الدالة متجهًا من الأزواج، كل زوج يمثل بداية ونهاية تسلسل.\n\n  الوسائط:\n  - target_sum: عدد صحيح يمثل المجموع المستهدف (10 <= target_sum <= 2,000,000).\n\n  يعيد:\n  - متجه من الأزواج. يحتوي كل زوج على عددين صحيحين: الأول والأخير في تسلسل متجاور يجمع إلى المجموع المستهدف.\n\n  مثال:\n  - find_sum_sequence_ranges(10000) يعيد vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "sw": "/*\n  Inapata safu zote za namba za asili mfululizo ambazo jumla yake ni sawa na jumla lengwa.\n\n  Kazi hii inatambua mfuatano wote unaowezekana wa namba za asili mfululizo ambapo jumla ya namba zote katika mfuatano ni sawa na jumla lengwa. Kazi hii inarejesha vekta ya jozi, kila jozi inawakilisha mwanzo na mwisho wa mfuatano.\n\n  Hoja:\n  - target_sum: Nambari nzima inayowakilisha jumla lengwa (10 <= target_sum <= 2,000,000).\n\n  Inarejesha:\n  - Vekta ya jozi. Kila jozi ina nambari mbili: nambari ya kwanza na ya mwisho katika mfuatano mfululizo ambao jumla yake ni sawa na jumla lengwa.\n\n  Mfano:\n  - find_sum_sequence_ranges(10000) inarejesha vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "tr": "/*\n  Verilen hedef toplamına eşit olan ardışık doğal sayıların tüm aralıklarını bulur.\n\n  Fonksiyon, toplamı hedef toplamına eşit olan tüm olası ardışık doğal sayı dizilerini tanımlar. Fonksiyon, her biri bir dizinin başlangıç ve bitişini temsil eden birer demet içeren bir vektör döndürür.\n\n  Argümanlar:\n  - target_sum: Hedef toplamı temsil eden bir tamsayı (10 <= target_sum <= 2,000,000).\n\n  Döndürür:\n  - Bir demet vektörü. Her demet, hedef toplamına eşit olan ardışık bir dizideki ilk ve son sayıyı içeren iki tamsayı içerir.\n\n  Örnek:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] döndürür\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "vi": "/*\n  Tìm tất cả các dãy số tự nhiên liên tiếp có tổng bằng tổng mục tiêu đã cho.\n\n  Hàm xác định tất cả các dãy số liên tiếp có thể có của các số tự nhiên mà tổng của tất cả các số trong dãy bằng tổng mục tiêu. Hàm trả về một vector các bộ giá trị, mỗi bộ giá trị đại diện cho điểm bắt đầu và kết thúc của một dãy.\n\n  Tham số:\n  - target_sum: Một số nguyên đại diện cho tổng mục tiêu (10 <= target_sum <= 2,000,000).\n\n  Trả về:\n  - Một vector các bộ giá trị. Mỗi bộ giá trị chứa hai số nguyên: số đầu tiên và số cuối cùng trong một dãy liên tiếp có tổng bằng tổng mục tiêu.\n\n  Ví dụ:\n  - find_sum_sequence_ranges(10000) trả về vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> "
    },
    "prompt_bertscore": {
      "es": "0.9929746420531771",
      "arb": "0.9716761021859491",
      "sw": "0.9509021451550342",
      "tr": "0.967206521351902",
      "vi": "0.9693086266743942"
    },
    "canonical_solution": "{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}",
    "instruction": {
      "en": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9431116629804649",
      "tr": "0.8583050313849522",
      "vi": "0.8850249888721463"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_sum_sequence_ranges(10000), vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]);\n        assert_eq!(find_sum_sequence_ranges(15), vec![(1, 5), (4, 6), (7, 8)]);\n        assert_eq!(find_sum_sequence_ranges(28), vec![(1, 7)]);\n        assert_eq!(find_sum_sequence_ranges(21334), vec![(5332, 5335)]);\n        println!(\"All test cases passed!\");\n    }\n    \n\n}",
    "entry_point": "find_sum_sequence_ranges",
    "signature": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>",
    "docstring": {
      "en": "Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "es": "Encuentra todos los rangos de números naturales consecutivos cuya suma es igual a la suma objetivo dada.\n\n  La función identifica todas las posibles secuencias contiguas de números naturales donde la suma de todos los números en la secuencia es igual a la suma objetivo. La función devuelve un vector de tuplas, cada tupla representa el inicio y el final de una secuencia.\n\n  Argumentos:\n  - target_sum: Un entero que representa la suma objetivo (10 <= target_sum <= 2,000,000).\n\n  Devuelve:\n  - Un vector de tuplas. Cada tupla contiene dos enteros: el primer y último número en una secuencia contigua que suma la suma objetivo.\n\n  Ejemplo:\n  - find_sum_sequence_ranges(10000) devuelve vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "arb": "يجد جميع النطاقات من الأعداد الطبيعية المتتالية التي يساوي مجموعها المجموع المستهدف المعطى.\n\nتحدد الدالة جميع التسلسلات المتجاورة الممكنة من الأعداد الطبيعية حيث يساوي مجموع جميع الأعداد في التسلسل المجموع المستهدف. تعيد الدالة متجهًا من الأزواج، يمثل كل زوج بداية ونهاية تسلسل.\n\nالمعطيات:\n- target_sum: عدد صحيح يمثل المجموع المستهدف (10 <= target_sum <= 2,000,000).\n\nالقيم المعادة:\n- متجه من الأزواج. يحتوي كل زوج على عددين صحيحين: الأول والأخير في تسلسل متجاور يكون مجموعهم هو المجموع المستهدف.\n\nمثال:\n- find_sum_sequence_ranges(10000) يعيد vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "sw": "Inapata safu zote za nambari asilia zinazofuatana ambazo jumla yake ni sawa na jumla lengwa iliyotolewa.\n\nKazi hii inatambua mfuatano wote unaowezekana wa nambari asilia ambapo jumla ya nambari zote katika mfuatano ni sawa na jumla lengwa. Kazi hii inarudisha vekta ya jozi, kila jozi ikiwakilisha mwanzo na mwisho wa mfuatano.\n\nHoja:\n- target_sum: Nambari kamili inayowakilisha jumla lengwa (10 <= target_sum <= 2,000,000).\n\nInarudisha:\n- Vekta ya jozi. Kila jozi ina nambari mbili kamili: nambari ya kwanza na ya mwisho katika mfuatano unaoendelea ambao jumla yake ni sawa na jumla lengwa.\n\nMfano:\n- find_sum_sequence_ranges(10000) inarudisha vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "tr": "Verilen hedef toplamına eşit olan ardışık doğal sayıların tüm aralıklarını bulur.\n\n  Fonksiyon, toplamı hedef toplamına eşit olan tüm olası ardışık doğal sayı dizilerini tanımlar. Fonksiyon, her biri bir dizinin başlangıç ve bitişini temsil eden birer demet içeren bir vektör döndürür.\n\n  Argümanlar:\n  - target_sum: Hedef toplamı temsil eden bir tamsayı (10 <= target_sum <= 2,000,000).\n\n  Döndürülenler:\n  - Bir demet vektörü. Her demet, hedef toplamına eşit olan ardışık bir dizideki ilk ve son sayıyı içeren iki tamsayı içerir.\n\n  Örnek:\n  - find_sum_sequence_ranges(10000) Döndürür vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "vi": "Tìm tất cả các dãy số tự nhiên liên tiếp có tổng bằng tổng mục tiêu đã cho.\n\nHàm này xác định tất cả các dãy số tự nhiên liên tiếp có tổng của tất cả các số trong dãy bằng tổng mục tiêu. Hàm trả về một vector các bộ giá trị, mỗi bộ giá trị đại diện cho điểm bắt đầu và kết thúc của một dãy.\n\nCác tham số:\n- target_sum: Một số nguyên đại diện cho tổng mục tiêu (10 <= target_sum <= 2,000,000).\n\nTrả về:\n- Một vector các bộ giá trị. Mỗi bộ giá trị chứa hai số nguyên: số đầu tiên và số cuối cùng trong một dãy liên tiếp có tổng bằng tổng mục tiêu.\n\nVí dụ:\n- find_sum_sequence_ranges(10000) trả về vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]"
    },
    "docstring_bertscore": {
      "es": "0.984388843832944",
      "arb": "0.949966993321122",
      "sw": "0.9477310111218122",
      "tr": "0.9633630234788769",
      "vi": "0.9481646212436114"
    }
  },
  {
    "task_id": "Rust/33",
    "prompt": {
      "en": "/*\n  Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "es": "/*\n  Convierte una cadena binaria (que consiste en '0's y '1's) en su forma invertida.\n  Cada '0' en la cadena de entrada se reemplaza con un '1', y cada '1' se reemplaza con un '0'.\n\n  Argumentos:\n  - input: Una cadena que consiste en dígitos binarios ('0' y '1').\n\n  Devuelve:\n  - Una nueva cadena que representa la secuencia binaria invertida de la cadena de entrada.\n\n  Ejemplo:\n  - invert_binary_string(\"0110\") devuelve \"1001\"\n  - invert_binary_string(\"1111\") devuelve \"0000\"\n  - invert_binary_string(\"0000\") devuelve \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "arb": "/*\n  يحول سلسلة ثنائية (تتكون من '0' و '1') إلى شكلها المعكوس.\n  يتم استبدال كل '0' في سلسلة الإدخال بـ '1'، وكل '1' يتم استبداله بـ '0'.\n\n  الحجج:\n  - input: سلسلة تتكون من أرقام ثنائية ('0' و '1').\n\n  يعيد:\n  - سلسلة جديدة تمثل التسلسل الثنائي المعكوس لسلسلة الإدخال.\n\n  مثال:\n  - invert_binary_string(\"0110\") يعيد \"1001\"\n  - invert_binary_string(\"1111\") يعيد \"0000\"\n  - invert_binary_string(\"0000\") يعيد \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "sw": "/*\n  Hubadilisha kamba ya binary (inayojumuisha '0's na '1's) kuwa umbo lake lililogeuzwa. \n  Kila '0' katika kamba ya ingizo inabadilishwa na '1', na kila '1' inabadilishwa na '0'.\n\n  Hoja:\n  - input: Kamba inayojumuisha tarakimu za binary ('0' na '1').\n\n  Inarudisha:\n  - Kamba mpya inayowakilisha mlolongo wa binary uliogeuzwa wa kamba ya ingizo.\n\n  Mfano:\n  - invert_binary_string(\"0110\") inarudisha \"1001\"\n  - invert_binary_string(\"1111\") inarudisha \"0000\"\n  - invert_binary_string(\"0000\") inarudisha \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "tr": "/*\n  İkili bir dizeyi ('0' ve '1'lerden oluşan) ters çevrilmiş biçimine dönüştürür.\n  Giriş dizisindeki her '0' bir '1' ile ve her '1' bir '0' ile değiştirilir.\n\n  Argümanlar:\n  - input: İkili rakamlardan ('0' ve '1') oluşan bir dize.\n\n  Döndürür:\n  - Giriş dizisinin ters çevrilmiş ikili dizisini temsil eden yeni bir dize.\n\n  Örnek:\n  - invert_binary_string(\"0110\") \"1001\" döndürür\n  - invert_binary_string(\"1111\") \"0000\" döndürür\n  - invert_binary_string(\"0000\") \"1111\" döndürür\n*/\nfn invert_binary_string(input: &str) -> String ",
      "vi": "/*\n  Chuyển đổi một chuỗi nhị phân (bao gồm các ký tự '0' và '1') thành dạng đảo ngược của nó. \n  Mỗi '0' trong chuỗi đầu vào được thay thế bằng '1', và mỗi '1' được thay thế bằng '0'.\n\n  Tham số:\n  - input: Một chuỗi bao gồm các chữ số nhị phân ('0' và '1').\n\n  Trả về:\n  - Một chuỗi mới đại diện cho chuỗi nhị phân đảo ngược của chuỗi đầu vào.\n\n  Ví dụ:\n  - invert_binary_string(\"0110\") trả về \"1001\"\n  - invert_binary_string(\"1111\") trả về \"0000\"\n  - invert_binary_string(\"0000\") trả về \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9977705726032644",
      "arb": "0.9770007868103513",
      "sw": "0.984201138122866",
      "tr": "0.9867956481599437",
      "vi": "0.965458971259557"
    },
    "canonical_solution": "{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}",
    "instruction": {
      "en": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nRust kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9099811085757508",
      "sw": "0.9346146525405544",
      "tr": "0.8853124070335039",
      "vi": "0.9074056670552524"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n   \n        assert_eq!(invert_binary_string(\"0110100100100\"), \"1001011011011\");\n        assert_eq!(invert_binary_string(\"1000000010000000000\"), \"0111111101111111111\");\n        assert_eq!(invert_binary_string(\"11110000\"), \"00001111\");\n        assert_eq!(invert_binary_string(\"0000\"), \"1111\");\n        println!(\"All test cases passed!\");\n        \n        \n    }\n    \n\n}",
    "entry_point": "invert_binary_string",
    "signature": "fn invert_binary_string(input: &str) -> String",
    "docstring": {
      "en": "Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "es": "Convierte una cadena binaria (que consiste en '0's y '1's) en su forma invertida. \n  Cada '0' en la cadena de entrada se reemplaza con un '1', y cada '1' se reemplaza con un '0'.\n\n  Argumentos:\n  - input: Una cadena que consiste en dígitos binarios ('0' y '1').\n\n  Devuelve:\n  - Una nueva cadena que representa la secuencia binaria invertida de la cadena de entrada.\n\n  Ejemplo:\n  - invert_binary_string(\"0110\") devuelve \"1001\"\n  - invert_binary_string(\"1111\") devuelve \"0000\"\n  - invert_binary_string(\"0000\") devuelve \"1111\"",
      "arb": "يقوم بتحويل سلسلة ثنائية (تتكون من '0' و '1') إلى شكلها المقلوب. \nيتم استبدال كل '0' في سلسلة الإدخال بـ '1'، وكل '1' يتم استبداله بـ '0'.\n\n  الحجج:\n  - input: سلسلة تتكون من أرقام ثنائية ('0' و '1').\n\n  يعيد:\n  - سلسلة جديدة تمثل التسلسل الثنائي المقلوب لسلسلة الإدخال.\n\n  مثال:\n  - invert_binary_string(\"0110\") يعيد \"1001\"\n  - invert_binary_string(\"1111\") يعيد \"0000\"\n  - invert_binary_string(\"0000\") يعيد \"1111\"",
      "sw": "Hubadilisha kamba ya binary (inayojumuisha '0's na '1's) kuwa umbo lake lililogeuzwa. \n  Kila '0' katika mfuatano wa ingizo hubadilishwa na '1', na kila '1' hubadilishwa na '0'.\n\n  Hoja:\n  - input: Mfuatano wa herufi zinazojumuisha tarakimu za binary ('0' na '1').\n\n  Inarudisha:\n  - Mfuatano mpya wa herufi unaowakilisha mfuatano wa binary uliogeuzwa wa mfuatano wa ingizo.\n\n  Mfano:\n  - invert_binary_string(\"0110\") inarudisha \"1001\"\n  - invert_binary_string(\"1111\") inarudisha \"0000\"\n  - invert_binary_string(\"0000\") inarudisha \"1111\"",
      "tr": "İkili bir dizeyi (sadece '0' ve '1'lerden oluşan) ters çevrilmiş biçimine dönüştürür. \nGirdi dizisindeki her '0', '1' ile ve her '1', '0' ile değiştirilir.\n\nArgümanlar:\n- input: İkili rakamlardan ('0' ve '1') oluşan bir dize.\n\nDöndürülenler:\n- Girdi dizisinin ters çevrilmiş ikili dizisini temsil eden yeni bir dize.\n\nÖrnek:\n- invert_binary_string(\"0110\") \"1001\" döndürür\n- invert_binary_string(\"1111\") \"0000\" döndürür\n- invert_binary_string(\"0000\") \"1111\" döndürür",
      "vi": "Chuyển đổi một chuỗi nhị phân (bao gồm các ký tự '0' và '1') thành dạng đảo ngược của nó. \n  Mỗi '0' trong chuỗi đầu vào được thay thế bằng '1', và mỗi '1' được thay thế bằng '0'.\n\n  Tham số:\n  - input: Một chuỗi bao gồm các chữ số nhị phân ('0' và '1').\n\n  Trả về:\n  - Một chuỗi mới đại diện cho dãy nhị phân đảo ngược của chuỗi đầu vào.\n\n  Ví dụ:\n  - invert_binary_string(\"0110\") trả về \"1001\"\n  - invert_binary_string(\"1111\") trả về \"0000\"\n  - invert_binary_string(\"0000\") trả về \"1111\""
    },
    "docstring_bertscore": {
      "es": "0.9973453049574688",
      "arb": "0.9761645529061944",
      "sw": "0.9707347928102248",
      "tr": "0.9826722800800405",
      "vi": "0.9636742772859586"
    }
  },
  {
    "task_id": "Rust/34",
    "prompt": {
      "en": "/*\n  Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "es": "/*\n  Calcula la distancia total mínima desde todos los residentes hasta una oficina de correos ubicada dentro de su ciudad. La ciudad está dispuesta en una cuadrícula, con calles que corren de norte a sur y de este a oeste, formando bloques.\n\n  La distancia entre dos puntos (x1, y1) y (x2, y2) se define como |x1 - x2| + |y1 - y2|.\n\n  Argumentos:\n  - residents: Un slice de tuplas, cada una representando las coordenadas (x, y) de la ubicación de un residente.\n\n  Retorna:\n  - La distancia total mínima desde todos los residentes hasta la oficina de correos.\n\n  Ejemplos:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) retorna 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) retorna 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "arb": "/*\n  يحسب الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب بريد يقع داخل مدينتهم. المدينة مرتبة في شبكة، مع شوارع تمتد من الشمال إلى الجنوب ومن الشرق إلى الغرب، مكونة كتل.\n\n  المسافة بين نقطتين (x1, y1) و(x2, y2) تُعرف بأنها |x1 - x2| + |y1 - y2|.\n\n  الوسائط:\n  - residents: مجموعة من الأزواج، كل منها يمثل إحداثيات (x, y) لموقع أحد السكان.\n\n  يعيد:\n  - الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب البريد.\n\n  أمثلة:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) يعيد 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) يعيد 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
      "sw": "/*\n  Inahesabu umbali wa chini kabisa wa jumla kutoka kwa wakazi wote hadi ofisi ya posta iliyo ndani ya jiji lao. Jiji limepangwa katika gridi, na barabara zinazoenda kaskazini-kusini na mashariki-magharibi, zikifanya vitalu.\n\n  Umbali kati ya pointi mbili (x1, y1) na (x2, y2) unafafanuliwa kama |x1 - x2| + |y1 - y2|.\n\n  Hoja:\n  - residents: Sehemu ya jozi, kila moja ikiwakilisha kuratibu za (x, y) za eneo la mkazi.\n\n  Inarudisha:\n  - Umbali wa chini kabisa wa jumla kutoka kwa wakazi wote hadi ofisi ya posta.\n\n  Mifano:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) inarudisha 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) inarudisha 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
      "tr": "/*\n  Bir şehirde bulunan bir postaneye tüm sakinlerden olan minimum toplam mesafeyi hesaplar. Şehir, kuzey-güney ve doğu-batı yönünde uzanan sokaklarla, bloklar oluşturan bir ızgara şeklinde düzenlenmiştir.\n\n  İki nokta (x1, y1) ve (x2, y2) arasındaki mesafe |x1 - x2| + |y1 - y2| olarak tanımlanır.\n\n  Argümanlar:\n  - residents: Her biri bir sakinin konumunun (x, y) koordinatlarını temsil eden bir dilim.\n\n  Döndürür:\n  - Tüm sakinlerden postaneye olan minimum toplam mesafe.\n\n  Örnekler:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 döndürür\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 döndürür\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "vi": "/*\n  Tính tổng khoảng cách tối thiểu từ tất cả cư dân đến một bưu điện nằm trong thành phố của họ. Thành phố được bố trí theo dạng lưới, với các con đường chạy theo hướng bắc-nam và đông-tây, tạo thành các khối.\n\n  Khoảng cách giữa hai điểm (x1, y1) và (x2, y2) được định nghĩa là |x1 - x2| + |y1 - y2|.\n\n  Tham số:\n  - residents: Một mảng các bộ giá trị, mỗi bộ đại diện cho tọa độ (x, y) của vị trí cư dân.\n\n  Trả về:\n  - Tổng khoảng cách tối thiểu từ tất cả cư dân đến bưu điện.\n\n  Ví dụ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) trả về 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) trả về 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9935671564798041",
      "arb": "0.9820112381719563",
      "sw": "0.9941235201770828",
      "tr": "0.9738606391165708",
      "vi": "0.9821842452338377"
    },
    "canonical_solution": "{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}",
    "instruction": {
      "en": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nRust kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9238518653441791",
      "sw": "0.8607483837020623",
      "tr": "0.8593647244677733",
      "vi": "0.9212964854921653"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]), 10);\n        assert_eq!(minimum_distance_to_post_office(&[(0, 0), (1, 1)]), 2);\n    \n    }\n\n}",
    "entry_point": "minimum_distance_to_post_office",
    "signature": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
    "docstring": {
      "en": "Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "es": "Calcula la distancia total mínima desde todos los residentes hasta una oficina de correos ubicada dentro de su ciudad. La ciudad está dispuesta en una cuadrícula, con calles que corren de norte a sur y de este a oeste, formando bloques.\n\n  La distancia entre dos puntos (x1, y1) y (x2, y2) se define como |x1 - x2| + |y1 - y2|.\n\n  Argumentos:\n  - residents: Un slice de tuplas, cada una representando las coordenadas (x, y) de la ubicación de un residente.\n\n  Retornos:\n  - La distancia total mínima desde todos los residentes hasta la oficina de correos.\n\n  Ejemplos:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) Devuelve 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) Devuelve 2",
      "arb": "يحسب الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب بريد يقع داخل مدينتهم. المدينة مرتبة في شبكة، مع شوارع تمتد من الشمال إلى الجنوب ومن الشرق إلى الغرب، مكونة كتل.\n\nالمسافة بين نقطتين (x1, y1) و(x2, y2) تُعرّف كـ |x1 - x2| + |y1 - y2|.\n\nالأوساط:\n- residents: شريحة من الأزواج، كل منها يمثل إحداثيات (x, y) لموقع أحد السكان.\n\nالقيم المعادة:\n- الحد الأدنى للمسافة الإجمالية من جميع السكان إلى مكتب البريد.\n\nأمثلة:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) يعيد 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) يعيد 2",
      "sw": "Hesabu umbali wa chini kabisa kutoka kwa wakazi wote hadi ofisi ya posta iliyoko ndani ya mji wao. Mji umewekwa katika gridi, na barabara zinaelekea kaskazini-kusini na mashariki-magharibi, zikifanyiza vitalu.\n\nUmbali kati ya pointi mbili (x1, y1) na (x2, y2) unafafanuliwa kama |x1 - x2| + |y1 - y2|.\n\nHoja:\n- residents: Sehemu ya tuples, kila moja ikiwakilisha kuratibu (x, y) ya eneo la mkazi.\n\nInarejesha:\n- Umbali wa chini kabisa kutoka kwa wakazi wote hadi ofisi ya posta.\n\nMifano:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) inarejesha 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) inarejesha 2",
      "tr": "Tüm sakinlerden, şehirlerinde bulunan bir postaneye olan minimum toplam mesafeyi hesaplar. Şehir, kuzey-güney ve doğu-batı yönünde uzanan sokaklarla bloklar oluşturan bir ızgara şeklinde düzenlenmiştir.\n\n  İki nokta (x1, y1) ve (x2, y2) arasındaki mesafe |x1 - x2| + |y1 - y2| olarak tanımlanır.\n\n  Argümanlar:\n  - residents: Her biri bir sakinin konumunu temsil eden (x, y) koordinatlarından oluşan bir dilim.\n\n  Döndürür:\n  - Tüm sakinlerden postaneye olan minimum toplam mesafe.\n\n  Örnekler:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 döndürür\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 döndürür",
      "vi": "Tính toán tổng khoảng cách tối thiểu từ tất cả cư dân đến một bưu điện nằm trong thành phố của họ. Thành phố được bố trí theo dạng lưới, với các con đường chạy theo hướng bắc-nam và đông-tây, tạo thành các khối.\n\nKhoảng cách giữa hai điểm (x1, y1) và (x2, y2) được định nghĩa là |x1 - x2| + |y1 - y2|.\n\nCác tham số:\n- residents: Một mảng các bộ giá trị, mỗi bộ đại diện cho tọa độ (x, y) của vị trí cư dân.\n\nTrả về:\n- Tổng khoảng cách tối thiểu từ tất cả cư dân đến bưu điện.\n\nVí dụ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) trả về 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9878273343590389",
      "arb": "0.9759879704974544",
      "sw": "0.9838733979941585",
      "tr": "0.974152427146311",
      "vi": "0.9762378475167963"
    }
  },
  {
    "task_id": "Rust/35",
    "prompt": {
      "en": "/*\n  Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "es": "/*\n  Calcula el número máximo de misiles que pueden ser interceptados por el sistema, dadas sus alturas en el orden en que son detectados.\n  El sistema de intercepción puede interceptar cualquier altura para el primer misil, pero las intercepciones subsecuentes deben ser a alturas menores o iguales a la intercepción anterior.\n\n  Argumentos:\n  - heights: Una porción de enteros que representa las alturas de los misiles entrantes.\n\n  Devuelve:\n  - Un entero que representa el número máximo de misiles que pueden ser interceptados.\n\n  Ejemplo:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) devuelve 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) devuelve 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) devuelve 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "arb": "/*\n  يحسب الحد الأقصى لعدد الصواريخ التي يمكن للنظام اعتراضها، بالنظر إلى ارتفاعاتها بالترتيب الذي يتم اكتشافها فيه.\n  يمكن لنظام الاعتراض اعتراض أي ارتفاع للصاروخ الأول، ولكن يجب أن تكون الاعتراضات اللاحقة عند ارتفاعات أقل من أو تساوي الاعتراض السابق.\n\n  الوسائط:\n  - heights: مجموعة من الأعداد الصحيحة تمثل ارتفاعات الصواريخ القادمة.\n\n  يعيد:\n  - عدد صحيح يمثل الحد الأقصى لعدد الصواريخ التي يمكن اعتراضها.\n\n  مثال:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) يعيد 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) يعيد 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) يعيد 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "sw": "/*\n  Inakokotoa idadi ya juu ya makombora ambayo yanaweza kuzuiliwa na mfumo, kutokana na urefu wao kwa mpangilio yanavyogunduliwa.\n  Mfumo wa kuzuia unaweza kuzuia urefu wowote kwa kombora la kwanza, lakini vizuizi vinavyofuata lazima viwe kwenye urefu ulio sawa au chini ya kizuizi kilichopita.\n\n  Hoja:\n  - heights: Sehemu ya nambari za mzima inayowakilisha urefu wa makombora yanayokuja.\n\n  Inarejesha:\n  - Nambari ya mzima inayowakilisha idadi ya juu ya makombora ambayo yanaweza kuzuiliwa.\n\n  Mfano:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) inarejesha 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) inarejesha 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) inarejesha 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "tr": "/*\n  Sistem tarafından tespit edildikleri sıraya göre yükseklikleri verilen füzelerden en fazla kaç tanesinin engellenebileceğini hesaplar.\n  Önleme sistemi, ilk füze için herhangi bir yüksekliği engelleyebilir, ancak sonraki önlemeler, önceki önlemeden daha az veya eşit yüksekliklerde olmalıdır.\n\n  Argümanlar:\n  - heights: Gelen füzelerin yüksekliklerini temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Engellenebilecek maksimum füze sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 döndürür\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 döndürür\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 döndürür\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "vi": "/*\n  Tính toán số lượng tên lửa tối đa có thể bị hệ thống đánh chặn, dựa trên độ cao của chúng theo thứ tự chúng được phát hiện.\n  Hệ thống đánh chặn có thể đánh chặn bất kỳ độ cao nào cho tên lửa đầu tiên, nhưng các lần đánh chặn tiếp theo phải ở độ cao nhỏ hơn hoặc bằng độ cao của lần đánh chặn trước đó.\n\n  Tham số:\n  - heights: Một mảng các số nguyên đại diện cho độ cao của các tên lửa đang đến.\n\n  Trả về:\n  - Một số nguyên đại diện cho số lượng tên lửa tối đa có thể bị đánh chặn.\n\n  Ví dụ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) trả về 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) trả về 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) trả về 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9974317091732189",
      "arb": "0.9752180791405632",
      "sw": "0.9855736740558171",
      "tr": "0.9887352738307494",
      "vi": "0.9609671438228341"
    },
    "canonical_solution": "{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}",
    "instruction": {
      "en": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8856542499192649",
      "sw": "0.9099693893832697",
      "tr": "0.8624248241179968",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]), 5);\n        assert_eq!(max_missiles_intercepted(&[500, 400, 300, 200, 100]), 5);\n        assert_eq!(max_missiles_intercepted(&[100, 200, 300, 400, 500]), 1);\n    }\n    \n\n}",
    "entry_point": "max_missiles_intercepted",
    "signature": "fn max_missiles_intercepted(heights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "es": "Calcula el número máximo de misiles que puede interceptar el sistema, dadas sus alturas en el orden en que son detectados. \n  El sistema de intercepción puede interceptar cualquier altura para el primer misil, pero las intercepciones posteriores deben ser a alturas menores o iguales a la intercepción anterior.\n\n  Argumentos:\n  - heights: Un segmento de enteros que representa las alturas de los misiles entrantes.\n\n  Devuelve:\n  - Un entero que representa el número máximo de misiles que se pueden interceptar.\n\n  Ejemplo:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) devuelve 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) devuelve 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) devuelve 1",
      "arb": "يحسب الحد الأقصى لعدد الصواريخ التي يمكن للنظام اعتراضها، بالنظر إلى ارتفاعاتها بالترتيب الذي يتم اكتشافها فيه. يمكن لنظام الاعتراض اعتراض أي ارتفاع للصاروخ الأول، لكن الاعتراضات اللاحقة يجب أن تكون عند ارتفاعات أقل من أو تساوي الاعتراض السابق.\n\n  الحجج:\n  - heights: جزء من الأعداد الصحيحة يمثل ارتفاعات الصواريخ القادمة.\n\n  العوائد:\n  - عدد صحيح يمثل الحد الأقصى لعدد الصواريخ التي يمكن اعتراضها.\n\n  مثال:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) يعيد 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) يعيد 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) يعيد 1",
      "sw": "Hesabu idadi ya juu ya makombora ambayo yanaweza kukamatwa na mfumo, ukizingatia urefu wao kwa mpangilio ambao yanagunduliwa. Mfumo wa kukamata unaweza kukamata urefu wowote kwa kombora la kwanza, lakini makombora yanayofuata lazima yakamatwe katika urefu ulio sawa au chini ya ule wa kukamatwa kwa awali.\n\nHoja:\n- heights: Sehemu ya nambari za mzima zinazowakilisha urefu wa makombora yanayokuja.\n\nInarejesha:\n- Nambari ya mzima inayowakilisha idadi ya juu ya makombora ambayo yanaweza kukamatwa.\n\nMfano:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) inarejesha 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) inarejesha 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) inarejesha 1",
      "tr": "Füze sisteminin tespit edilen yüksekliklerine göre durdurabileceği maksimum füze sayısını hesaplar. \n  Önleme sistemi, ilk füze için herhangi bir yüksekliği durdurabilir, ancak sonraki önlemeler önceki önlemenin yüksekliğine eşit veya daha az yükseklikte olmalıdır.\n\n  Argümanlar:\n  - heights: Gelen füzelerin yüksekliklerini temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Durdurulabilecek maksimum füze sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 döndürür\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 döndürür\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 döndürür",
      "vi": "Tính toán số lượng tên lửa tối đa có thể bị hệ thống đánh chặn, dựa trên độ cao của chúng theo thứ tự được phát hiện. Hệ thống đánh chặn có thể đánh chặn bất kỳ độ cao nào cho tên lửa đầu tiên, nhưng các lần đánh chặn tiếp theo phải ở độ cao nhỏ hơn hoặc bằng lần đánh chặn trước đó.\n\nTham số:\n- heights: Một mảng số nguyên đại diện cho độ cao của các tên lửa đang tới.\n\nTrả về:\n- Một số nguyên đại diện cho số lượng tên lửa tối đa có thể bị đánh chặn.\n\nVí dụ:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) Trả về 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) Trả về 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) Trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9833859590390989",
      "arb": "0.9740407968721694",
      "sw": "0.9747298456639795",
      "tr": "0.9607482531429337",
      "vi": "0.9772911844274244"
    }
  },
  {
    "task_id": "Rust/36",
    "prompt": {
      "en": "/*\n  Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "es": "/*\n  Calcula el número de caminos que un peón puede tomar para moverse desde el origen (0, 0) a un punto dado (n, m) en un tablero de ajedrez,\n  evitando los puntos de control de un caballo estacionario ubicado en (horse_x, horse_y).\n\n  El peón solo puede moverse un paso a la derecha o un paso hacia abajo a la vez. Los puntos de control del caballo incluyen su \n  posición actual y todos los puntos a los que puede llegar en un movimiento. El peón debe evitar estos puntos de control.\n\n  Argumentos:\n  - n: coordenada x del punto de destino, un entero que no excede 15.\n  - m: coordenada y del punto de destino, un entero que no excede 15.\n  - horse_x: coordenada x de la posición del caballo, un entero.\n  - horse_y: coordenada y de la posición del caballo, un entero.\n\n  Devuelve:\n  - El número total de caminos válidos desde (0, 0) hasta (n, m) evitando los puntos de control del caballo.\n\n  Ejemplos:\n  - count_paths(6, 6, 3, 3) devuelve 6\n  - count_paths(5, 5, 1, 1) devuelve 12\n  - count_paths(7, 7, 2, 2) devuelve 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "arb": "/*\n  يحسب عدد المسارات التي يمكن أن يسلكها البيدق للتحرك من النقطة الأصلية (0, 0) إلى نقطة معينة (n, m) على رقعة الشطرنج،\n  متجنبًا نقاط التحكم لحصان ثابت موجود في الموقع (horse_x, horse_y).\n\n  يمكن للبيدق التحرك خطوة واحدة فقط إما إلى اليمين أو خطوة واحدة إلى الأسفل في كل مرة. تشمل نقاط التحكم للحصان موقعه الحالي\n  وجميع النقاط التي يمكنه الوصول إليها في خطوة واحدة. يجب على البيدق تجنب هذه النقاط.\n\n  الوسائط:\n  - n: الإحداثي السيني للنقطة الوجهة، عدد صحيح لا يتجاوز 15.\n  - m: الإحداثي الصادي للنقطة الوجهة، عدد صحيح لا يتجاوز 15.\n  - horse_x: الإحداثي السيني لموقع الحصان، عدد صحيح.\n  - horse_y: الإحداثي الصادي لموقع الحصان، عدد صحيح.\n\n  يعيد:\n  - العدد الإجمالي للمسارات الصالحة من (0, 0) إلى (n, m) متجنبًا نقاط التحكم للحصان.\n\n  أمثلة:\n  - count_paths(6, 6, 3, 3) يعيد 6\n  - count_paths(5, 5, 1, 1) يعيد 12\n  - count_paths(7, 7, 2, 2) يعيد 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "sw": "/*\n  Inahesabu idadi ya njia ambazo pawn inaweza kuchukua kuhamia kutoka asili (0, 0) hadi kwenye nukta iliyotolewa (n, m) kwenye ubao wa chess,\n  ikiepuka sehemu za udhibiti za farasi aliyesimama aliye kwenye (horse_x, horse_y).\n\n  Pawn inaweza kusonga hatua moja tu kulia au hatua moja chini kwa wakati mmoja. Sehemu za udhibiti za farasi ni pamoja na nafasi yake ya sasa na \n  pointi zote ambazo inaweza kufikia kwa hatua moja. Pawn lazima iepuke sehemu hizi za udhibiti.\n\n  Hoja:\n  - n: x-kiwianzo cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - m: y-kiwianzo cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - horse_x: x-kiwianzo cha nafasi ya farasi, namba kamili.\n  - horse_y: y-kiwianzo cha nafasi ya farasi, namba kamili.\n\n  Inarudisha:\n  - Jumla ya idadi ya njia halali kutoka (0, 0) hadi (n, m) ikiepuka sehemu za udhibiti za farasi.\n\n  Mifano:\n  - count_paths(6, 6, 3, 3) inarudisha 6\n  - count_paths(5, 5, 1, 1) inarudisha 12\n  - count_paths(7, 7, 2, 2) inarudisha 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "tr": "/*\n  Bir piyonun (0, 0) başlangıç noktasından bir satranç tahtasında verilen bir noktaya (n, m) hareket edebileceği yolların sayısını hesaplar,\n  (horse_x, horse_y) konumunda duran bir atın kontrol noktalarından kaçınarak.\n\n  Piyon sadece bir adım sağa veya bir adım aşağıya hareket edebilir. Atın kontrol noktaları, mevcut konumunu ve bir hamlede ulaşabileceği tüm noktaları içerir.\n  Piyon bu kontrol noktalarından kaçınmalıdır.\n\n  Argümanlar:\n  - n: Hedef noktanın x-koordinatı, 15'i geçmeyen bir tamsayı.\n  - m: Hedef noktanın y-koordinatı, 15'i geçmeyen bir tamsayı.\n  - horse_x: Atın konumunun x-koordinatı, bir tamsayı.\n  - horse_y: Atın konumunun y-koordinatı, bir tamsayı.\n\n  Döndürür:\n  - Atın kontrol noktalarından kaçınarak (0, 0) ile (n, m) arasında geçerli yolların toplam sayısı.\n\n  Örnekler:\n  - count_paths(6, 6, 3, 3) 6 döndürür\n  - count_paths(5, 5, 1, 1) 12 döndürür\n  - count_paths(7, 7, 2, 2) 28 döndürür\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
      "vi": "/*\n  Tính toán số lượng đường đi mà một quân tốt có thể thực hiện để di chuyển từ điểm gốc (0, 0) đến một điểm cho trước (n, m) trên bàn cờ,\n  tránh các điểm kiểm soát của một con ngựa đứng yên tại vị trí (horse_x, horse_y).\n\n  Quân tốt chỉ có thể di chuyển một bước sang phải hoặc một bước xuống dưới mỗi lần. Các điểm kiểm soát của con ngựa bao gồm vị trí hiện tại của nó \n  và tất cả các điểm mà nó có thể đến trong một nước đi. Quân tốt phải tránh các điểm kiểm soát này.\n\n  Tham số:\n  - n: tọa độ x của điểm đích, là một số nguyên không vượt quá 15.\n  - m: tọa độ y của điểm đích, là một số nguyên không vượt quá 15.\n  - horse_x: tọa độ x của vị trí con ngựa, là một số nguyên.\n  - horse_y: tọa độ y của vị trí con ngựa, là một số nguyên.\n\n  Trả về:\n  - Tổng số đường đi hợp lệ từ (0, 0) đến (n, m) tránh các điểm kiểm soát của con ngựa.\n\n  Ví dụ:\n  - count_paths(6, 6, 3, 3) trả về 6\n  - count_paths(5, 5, 1, 1) trả về 12\n  - count_paths(7, 7, 2, 2) trả về 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.984223980616685",
      "arb": "0.9569272005029655",
      "sw": "0.9483874845311325",
      "tr": "0.9512392209116505",
      "vi": "0.9643780247259652"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}",
    "instruction": {
      "en": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nRust kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda Türkçe bir açıklama (docstring) sağlayın.",
      "vi": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9153697521828462",
      "tr": "0.8342205017933289",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_paths(6, 6, 3, 3), 6);\n        assert_eq!(count_paths(5, 5, 1, 1), 10);\n        assert_eq!(count_paths(7, 7, 2, 2), 0);\n    }\n    \n\n}",
    "entry_point": "count_paths",
    "signature": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
    "docstring": {
      "en": "Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "es": "Calcula el número de caminos que un peón puede tomar para moverse desde el origen (0, 0) hasta un punto dado (n, m) en un tablero de ajedrez, evitando los puntos de control de un caballo estacionario ubicado en (horse_x, horse_y).\n\nEl peón solo puede moverse un paso a la derecha o un paso hacia abajo a la vez. Los puntos de control del caballo incluyen su posición actual y todos los puntos que puede alcanzar en un movimiento. El peón debe evitar estos puntos de control.\n\nArgumentos:\n- n: coordenada x del punto de destino, un entero que no excede 15.\n- m: coordenada y del punto de destino, un entero que no excede 15.\n- horse_x: coordenada x de la posición del caballo, un entero.\n- horse_y: coordenada y de la posición del caballo, un entero.\n\nDevuelve:\n- El número total de caminos válidos desde (0, 0) hasta (n, m) evitando los puntos de control del caballo.\n\nEjemplos:\n- count_paths(6, 6, 3, 3) devuelve 6\n- count_paths(5, 5, 1, 1) devuelve 12\n- count_paths(7, 7, 2, 2) devuelve 28",
      "arb": "يحسب عدد المسارات التي يمكن أن يسلكها البيدق للتحرك من النقطة الأصلية (0, 0) إلى نقطة معينة (n, m) على رقعة الشطرنج، متجنبًا نقاط التحكم الخاصة بحصان ثابت يقع في (horse_x, horse_y).\n\nيمكن للبيدق التحرك خطوة واحدة فقط إما إلى اليمين أو خطوة واحدة إلى الأسفل في كل مرة. تشمل نقاط التحكم الخاصة بالحصان موقعه الحالي وجميع النقاط التي يمكنه الوصول إليها في حركة واحدة. يجب على البيدق تجنب هذه النقاط.\n\nالمعطيات:\n- n: الإحداثي السيني للنقطة الوجهة، عدد صحيح لا يتجاوز 15.\n- m: الإحداثي الصادي للنقطة الوجهة، عدد صحيح لا يتجاوز 15.\n- horse_x: الإحداثي السيني لموقع الحصان، عدد صحيح.\n- horse_y: الإحداثي الصادي لموقع الحصان، عدد صحيح.\n\nالقيم المعادة:\n- العدد الإجمالي للمسارات الصالحة من (0, 0) إلى (n, m) متجنبًا نقاط التحكم الخاصة بالحصان.\n\nأمثلة:\n- count_paths(6, 6, 3, 3) يعيد 6\n- count_paths(5, 5, 1, 1) يعيد 12\n- count_paths(7, 7, 2, 2) يعيد 28",
      "sw": "Hesabu idadi ya njia ambazo pawn inaweza kuchukua ili kuhamia kutoka asili (0, 0) hadi kwenye nukta iliyotolewa (n, m) kwenye ubao wa chess, ikiepuka pointi za udhibiti za farasi aliyesimama mahali pake kwenye (horse_x, horse_y).\n\n  Pawn inaweza tu kusonga hatua moja kulia au hatua moja chini kwa wakati mmoja. Pointi za udhibiti za farasi ni pamoja na nafasi yake ya sasa na pointi zote ambazo inaweza kufikia kwa hatua moja. Pawn lazima iepuke hizi pointi za udhibiti.\n\n  Hoja:\n  - n: x-kiwianishi cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - m: y-kiwianishi cha nukta ya mwisho, namba kamili isiyozidi 15.\n  - horse_x: x-kiwianishi cha nafasi ya farasi, namba kamili.\n  - horse_y: y-kiwianishi cha nafasi ya farasi, namba kamili.\n\n  Inarejesha:\n  - Jumla ya idadi ya njia halali kutoka (0, 0) hadi (n, m) ikiepuka pointi za udhibiti za farasi.\n\n  Mifano:\n  - count_paths(6, 6, 3, 3) inarejesha 6\n  - count_paths(5, 5, 1, 1) inarejesha 12\n  - count_paths(7, 7, 2, 2) inarejesha 28",
      "tr": "Hesaplar, bir piyonun bir satranç tahtasında başlangıç noktası (0, 0) ile verilen bir nokta (n, m) arasında hareket edebileceği yolların sayısını, (horse_x, horse_y) konumunda duran bir atın kontrol noktalarından kaçınarak.\n\nPiyon yalnızca bir adım sağa veya bir adım aşağıya hareket edebilir. Atın kontrol noktaları, mevcut konumu ve bir hamlede ulaşabileceği tüm noktaları içerir. Piyon bu kontrol noktalarından kaçınmalıdır.\n\nArgümanlar:\n- n: Varış noktasının x-koordinatı, 15'i aşmayan bir tamsayı.\n- m: Varış noktasının y-koordinatı, 15'i aşmayan bir tamsayı.\n- horse_x: Atın konumunun x-koordinatı, bir tamsayı.\n- horse_y: Atın konumunun y-koordinatı, bir tamsayı.\n\nDöndürür:\n- Atın kontrol noktalarından kaçınarak (0, 0) ile (n, m) arasında geçerli yolların toplam sayısı.\n\nÖrnekler:\n- count_paths(6, 6, 3, 3) 6 döndürür\n- count_paths(5, 5, 1, 1) 12 döndürür\n- count_paths(7, 7, 2, 2) 28 döndürür",
      "vi": "Tính toán số đường đi mà một quân tốt có thể thực hiện để di chuyển từ điểm gốc (0, 0) đến một điểm cho trước (n, m) trên bàn cờ, tránh các điểm kiểm soát của một quân mã đứng yên nằm tại (horse_x, horse_y).\n\nQuân tốt chỉ có thể di chuyển một bước sang phải hoặc một bước xuống dưới tại một thời điểm. Các điểm kiểm soát của quân mã bao gồm vị trí hiện tại của nó và tất cả các điểm mà nó có thể đến trong một nước đi. Quân tốt phải tránh các điểm kiểm soát này.\n\nCác đối số:\n- n: tọa độ x của điểm đích, một số nguyên không vượt quá 15.\n- m: tọa độ y của điểm đích, một số nguyên không vượt quá 15.\n- horse_x: tọa độ x của vị trí quân mã, một số nguyên.\n- horse_y: tọa độ y của vị trí quân mã, một số nguyên.\n\nTrả về:\n- Tổng số đường đi hợp lệ từ (0, 0) đến (n, m) tránh các điểm kiểm soát của quân mã.\n\nVí dụ:\n- count_paths(6, 6, 3, 3) trả về 6\n- count_paths(5, 5, 1, 1) trả về 12\n- count_paths(7, 7, 2, 2) trả về 28"
    },
    "docstring_bertscore": {
      "es": "0.9808055517590746",
      "arb": "0.9416406063785205",
      "sw": "0.9490187318820614",
      "tr": "0.9459228787632517",
      "vi": "0.9645985044489139"
    }
  },
  {
    "task_id": "Rust/37",
    "prompt": {
      "en": "\n/*\n  Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "es": "/*\n  Calcula la diferencia entre el k-ésimo número más grande y el k-ésimo número más pequeño en una lista dada de enteros.\n  Si el k-ésimo número más grande o más pequeño no existe, la función devuelve None.\n\n  Argumentos:\n  - numbers: Un Vec<i32> que representa la secuencia de enteros no negativos.\n  - k: Un valor usize que representa la posición k-ésima.\n\n  Devuelve:\n  - Un valor Option<i32> que representa la diferencia si ambos números k-ésimo más grande y más pequeño existen, de lo contrario None.\n\n  Ejemplo:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) devuelve Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) devuelve None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "arb": "/*\n  يحسب الفرق بين العدد k الأكبر والعدد k الأصغر في قائمة معينة من الأعداد الصحيحة.\n  إذا لم يكن العدد k الأكبر أو الأصغر موجودًا، فإن الدالة تعيد None.\n\n  الوسائط:\n  - numbers: عبارة عن Vec<i32> تمثل تسلسل الأعداد الصحيحة غير السالبة.\n  - k: قيمة من نوع usize تمثل الموضع k.\n\n  يعيد:\n  - قيمة من نوع Option<i32> تمثل الفرق إذا كان كلا العددين k الأكبر والأصغر موجودين، وإلا يعيد None.\n\n  مثال:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) يعيد Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) يعيد None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "sw": "/*\n  Inahesabu tofauti kati ya nambari ya kth kubwa zaidi na kth ndogo zaidi katika orodha iliyotolewa ya nambari za mzima.\n  Ikiwa nambari ya kth kubwa au ndogo zaidi haipo, kazi inarudisha None.\n\n  Hoja:\n  - numbers: A Vec<i32> inayowakilisha mlolongo wa nambari zisizo hasi.\n  - k: Thamani ya usize inayowakilisha nafasi ya kth.\n\n  Inarudisha:\n  - Thamani ya Option<i32> inayowakilisha tofauti ikiwa nambari zote mbili za kth kubwa na ndogo zipo, vinginevyo None.\n\n  Mfano:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) inarudisha Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) inarudisha None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "tr": "/*\n  Verilen bir tamsayı listesindeki k. en büyük ve k. en küçük sayı arasındaki farkı hesaplar.\n  Eğer k. en büyük veya en küçük sayı mevcut değilse, fonksiyon None döner.\n\n  Argümanlar:\n  - numbers: Negatif olmayan tamsayıların dizisini temsil eden bir Vec<i32>.\n  - k: k. pozisyonu temsil eden bir usize değeri.\n\n  Döndürülenler:\n  - Hem k. en büyük hem de en küçük sayı mevcutsa farkı temsil eden bir Option<i32> değeri, aksi takdirde None.\n\n  Örnek:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) döner // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None döner\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "vi": "/*\n  Tính toán sự khác biệt giữa số lớn thứ k và số nhỏ thứ k trong một danh sách số nguyên đã cho.\n  Nếu số lớn thứ k hoặc nhỏ thứ k không tồn tại, hàm trả về None.\n\n  Tham số:\n  - numbers: Một Vec<i32> đại diện cho dãy số nguyên không âm.\n  - k: Một giá trị usize đại diện cho vị trí thứ k.\n\n  Trả về:\n  - Một giá trị Option<i32> đại diện cho sự khác biệt nếu cả số lớn thứ k và nhỏ thứ k tồn tại, ngược lại trả về None.\n\n  Ví dụ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) trả về Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) trả về None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> "
    },
    "prompt_bertscore": {
      "es": "0.9723625687828057",
      "arb": "0.9667701304047683",
      "sw": "0.9953997203752319",
      "tr": "0.9670211992063965",
      "vi": "0.9653032450408258"
    },
    "canonical_solution": "{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}",
    "instruction": {
      "en": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Rust باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nRust kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9041177383579819",
      "sw": "0.9153697521828462",
      "tr": "0.8743412565674228",
      "vi": "0.9242012561844194"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n     \n        assert_eq!(kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2), Some(4)); // 5 - 1 = 4\n        assert_eq!(kth_largest_minus_kth_smallest(vec![10, 20, 30], 4), None);\n        assert_eq!(kth_largest_minus_kth_smallest(vec![7, 7, 7, 7], 1), Some(0)); // 7 - 7 = 0\n        \n        \n    }\n    \n\n}",
    "entry_point": "kth_largest_minus_kth_smallest",
    "signature": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>",
    "docstring": {
      "en": "Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "es": "Calcula la diferencia entre el k-ésimo número más grande y el k-ésimo número más pequeño en una lista dada de enteros.\n  Si el k-ésimo número más grande o más pequeño no existe, la función devuelve None.\n\n  Argumentos:\n  - numbers: Un Vec<i32> que representa la secuencia de enteros no negativos.\n  - k: Un valor usize que representa la posición k-ésima.\n\n  Devuelve:\n  - Un valor Option<i32> que representa la diferencia si ambos números k-ésimo más grande y más pequeño existen, de lo contrario None.\n\n  Ejemplo:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) devuelve Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) devuelve None",
      "arb": "يحسب الفرق بين أكبر عدد في المرتبة k وأصغر عدد في المرتبة k في قائمة معينة من الأعداد الصحيحة.\nإذا لم يكن هناك عدد في المرتبة k كأكبر أو أصغر عدد، فإن الدالة تعيد None.\n\nالأوساط:\n- numbers: متجه من نوع Vec<i32> يمثل تسلسل الأعداد الصحيحة غير السالبة.\n- k: قيمة من نوع usize تمثل المرتبة k.\n\nالقيم المعادة:\n- قيمة من نوع Option<i32> تمثل الفرق إذا كان كلا العددين في المرتبة k كأكبر وأصغر عدد موجودين، وإلا تعيد None.\n\nمثال:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) تعيد Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) تعيد None",
      "sw": "Hesabu tofauti kati ya nambari ya kth kubwa zaidi na kth ndogo zaidi katika orodha iliyotolewa ya nambari za mzima.\n\nIkiwa nambari ya kth kubwa au ndogo zaidi haipo, kazi inarejesha None.\n\nHoja:\n- numbers: A Vec<i32> inayoonyesha mlolongo wa nambari zisizo hasi.\n- k: Thamani ya usize inayoonyesha nafasi ya kth.\n\nInarejesha:\n- Thamani ya Option<i32> inayoonyesha tofauti ikiwa nambari zote mbili za kth kubwa na ndogo zipo, vinginevyo None.\n\nMfano:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) inarejesha Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) inarejesha None",
      "tr": "Verilen bir tamsayı listesindeki en büyük k. ve en küçük k. sayı arasındaki farkı hesaplar.\n  Eğer en büyük veya en küçük k. sayı yoksa, fonksiyon None döndürür.\n\n  Argümanlar:\n  - numbers: Negatif olmayan tamsayıları temsil eden bir Vec<i32>.\n  - k: k. pozisyonu temsil eden bir usize değeri.\n\n  Döndürülenler:\n  - Eğer hem en büyük hem de en küçük k. sayılar mevcutsa farkı temsil eden bir Option<i32> değeri, aksi takdirde None.\n\n  Örnek:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) döndürür // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None döndürür",
      "vi": "Tính toán sự khác biệt giữa số lớn thứ k và số nhỏ thứ k trong một danh sách số nguyên đã cho. Nếu số lớn thứ k hoặc nhỏ thứ k không tồn tại, hàm trả về None.\n\nTham số:\n- numbers: Một Vec<i32> đại diện cho dãy số nguyên không âm.\n- k: Một giá trị usize đại diện cho vị trí thứ k.\n\nTrả về:\n- Một giá trị Option<i32> đại diện cho sự khác biệt nếu cả số lớn thứ k và nhỏ thứ k tồn tại, nếu không thì trả về None.\n\nVí dụ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) trả về Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) trả về None"
    },
    "docstring_bertscore": {
      "es": "0.9685925641507634",
      "arb": "0.9056811580871075",
      "sw": "0.9845924399735048",
      "tr": "0.959793834162061",
      "vi": "0.9593147376830049"
    }
  },
  {
    "task_id": "Rust/38",
    "prompt": {
      "en": "/*\n  Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "es": "/*\n  Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado a partir de un conjunto de hierbas, cada una con su propio requisito de tiempo y valor.\n\n  Argumentos:\n  - total_time: Un u32 que representa el tiempo total disponible para recolectar hierbas.\n  - herbs: Un slice de tuplas, donde cada tupla contiene dos valores u32 que representan el tiempo requerido para recolectar una hierba y su valor, respectivamente.\n\n  Devuelve:\n  - Un u32 que representa el valor total máximo de hierbas que se pueden recolectar dentro del tiempo dado.\n\n  Ejemplos:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) devuelve 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) devuelve 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) devuelve 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "arb": "/*\n  يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين من مجموعة من الأعشاب، كل منها بمتطلباته الزمنية وقيمته الخاصة.\n\n  الوسائط:\n  - total_time: يمثل الوقت الإجمالي المتاح لجمع الأعشاب.\n  - herbs: مقطع من الأزواج، حيث يحتوي كل زوج على قيمتين تمثلان الوقت المطلوب لجمع عشبة وقيمتها، على التوالي.\n\n  يعيد:\n  - قيمة تمثل القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الوقت المحدد.\n\n  أمثلة:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) يعيد 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) يعيد 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) يعيد 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "sw": "/*\n  Inakokotoa thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya kikomo cha muda kilichopewa kutoka kwa seti ya mimea, kila moja ikiwa na mahitaji yake ya muda na thamani.\n\n  Hoja:\n  - total_time: u32 inayowakilisha muda wote unaopatikana kwa ajili ya kukusanya mimea.\n  - herbs: Sehemu ya jozi, ambapo kila jozi ina maadili mawili ya u32 yanayowakilisha muda unaohitajika kukusanya mmea na thamani yake, mtawalia.\n\n  Inarudisha:\n  - u32 inayowakilisha thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n  Mifano:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) inarudisha 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) inarudisha 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) inarudisha 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
      "tr": "/*\n  Belirli bir zaman sınırı içinde, her birinin kendi zaman gereksinimi ve değeri olan bir dizi ottan toplanabilecek maksimum toplam ot değerini hesaplar.\n\n  Argümanlar:\n  - total_time: Ot toplamak için mevcut toplam zamanı temsil eden bir u32.\n  - herbs: Her biri bir otu toplamak için gereken zamanı ve değerini temsil eden iki u32 değeri içeren bir dilim.\n\n  Döndürür:\n  - Verilen zaman içinde toplanabilecek otların maksimum toplam değerini temsil eden bir u32.\n\n  Örnekler:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 döndürür\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 döndürür\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 döndürür\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "vi": "/*\n  Tính toán giá trị tổng tối đa của các loại thảo mộc có thể thu thập được trong giới hạn thời gian cho trước từ một tập hợp các loại thảo mộc, mỗi loại có yêu cầu thời gian và giá trị riêng.\n\n  Tham số:\n  - total_time: Một u32 đại diện cho tổng thời gian có sẵn để thu thập thảo mộc.\n  - herbs: Một mảng các bộ giá trị, trong đó mỗi bộ chứa hai giá trị u32 đại diện cho thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó, tương ứng.\n\n  Trả về:\n  - Một u32 đại diện cho giá trị tổng tối đa của các loại thảo mộc có thể thu thập được trong thời gian cho trước.\n\n  Ví dụ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) trả về 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) trả về 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) trả về 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 "
    },
    "prompt_bertscore": {
      "es": "0.9986912244193611",
      "arb": "0.9552428148717896",
      "sw": "0.9709137587835371",
      "tr": "0.959708025837454",
      "vi": "0.9796376051185894"
    },
    "canonical_solution": "{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}",
    "instruction": {
      "en": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9239644887702259",
      "sw": "0.9153697521828462",
      "tr": "0.9044075400839118",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]), 3);\n        assert_eq!(max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]), 110);\n        assert_eq!(max_herbs_value(5, &[(2, 20), (3, 30)]), 50);\n    }\n    \n\n}",
    "entry_point": "max_herbs_value",
    "signature": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
    "docstring": {
      "en": "Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "es": "Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado a partir de un conjunto de hierbas, cada una con su propio requisito de tiempo y valor.\n\n  Argumentos:\n  - total_time: Un u32 que representa el tiempo total disponible para recolectar hierbas.\n  - herbs: Un slice de tuplas, donde cada tupla contiene dos valores u32 que representan el tiempo requerido para recolectar una hierba y su valor, respectivamente.\n\n  Retorna:\n  - Un u32 que representa el valor total máximo de hierbas que se pueden recolectar dentro del tiempo dado.\n\n  Ejemplos:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) retorna 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) retorna 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) retorna 30",
      "arb": "يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين من مجموعة من الأعشاب، كل منها له متطلب زمني وقيمة خاصة به.\n\nالأوساط:\n- total_time: يمثل عدد صحيح غير موقع 32 يمثل إجمالي الوقت المتاح لجمع الأعشاب.\n- herbs: مقطع من الأزواج، حيث يحتوي كل زوج على قيمتين من نوع u32 تمثلان الوقت المطلوب لجمع عشبة وقيمتها، على التوالي.\n\nالقيم المعادة:\n- عدد صحيح غير موقع 32 يمثل القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الوقت المحدد.\n\nأمثلة:\n- max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) يعيد 3\n- max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) يعيد 100\n- max_herbs_value(5, &[(2, 20), (3, 30)]) يعيد 30",
      "sw": "Hesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliowekwa kutoka kwa seti ya mimea, kila moja ikiwa na mahitaji yake ya muda na thamani.\n\n  Hoja:\n  - total_time: u32 inayoashiria muda wote unaopatikana wa kukusanya mimea.\n  - herbs: Sehemu ya jozi, ambapo kila jozi ina maadili mawili ya u32 yanayoashiria muda unaohitajika kukusanya mmea na thamani yake, mtawalia.\n\n  Inarudisha:\n  - u32 inayoashiria thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n  Mifano:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) inarudisha 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) inarudisha 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) inarudisha 30",
      "tr": "Otların her birinin kendi zaman gereksinimi ve değeri olan bir ot setinden, belirli bir zaman sınırı içinde toplanabilecek maksimum toplam ot değerini hesaplar.\n\n  Argümanlar:\n  - total_time: Ot toplamak için mevcut toplam zamanı temsil eden bir u32.\n  - herbs: Her bir demetin bir otu toplamak için gereken zamanı ve değerini temsil eden iki u32 değeri içeren bir dilim.\n\n  Döndürür:\n  - Belirtilen zaman içinde toplanabilecek otların maksimum toplam değerini temsil eden bir u32.\n\n  Örnekler:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 döndürür\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 döndürür\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 döndürür",
      "vi": "Tính toán tổng giá trị tối đa của các loại thảo mộc có thể thu thập được trong một giới hạn thời gian nhất định từ một tập hợp các loại thảo mộc, mỗi loại có yêu cầu thời gian và giá trị riêng.\n\n  Tham số:\n  - total_time: Một u32 đại diện cho tổng thời gian có sẵn để thu thập thảo mộc.\n  - herbs: Một lát cắt của các bộ giá trị, trong đó mỗi bộ chứa hai giá trị u32 đại diện cho thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó, tương ứng.\n\n  Trả về:\n  - Một u32 đại diện cho tổng giá trị tối đa của các loại thảo mộc có thể thu thập được trong thời gian đã cho.\n\n  Ví dụ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) trả về 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) trả về 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) trả về 30"
    },
    "docstring_bertscore": {
      "es": "0.9988795260205822",
      "arb": "0.9428514571813092",
      "sw": "0.9685846189355221",
      "tr": "0.9645071344736379",
      "vi": "0.9855109068554101"
    }
  },
  {
    "task_id": "Rust/39",
    "prompt": {
      "en": "/*\n  Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "es": "/*\n  Valida la corrección de un número ISBN dado.\n\n  Un número ISBN es una cadena con el formato \"x-xxx-xxxxx-x\", donde 'x' representa un dígito, y '-' es un separador. El último dígito es un dígito de control, calculado como la suma de los primeros 9 dígitos, cada uno multiplicado por su posición (1 a 9), módulo 11. Si el resultado es 10, el dígito de control es 'X'.\n\n  Argumentos:\n  - isbn: Una cadena que representa un número ISBN.\n\n  Devuelve:\n  - Una respuesta en forma de cadena. Si el ISBN es correcto, devuelve \"Right\". De lo contrario, devuelve el número ISBN corregido.\n\n  Ejemplo:\n  - validate_isbn(\"0-670-82162-4\") devuelve \"Right\"\n  - validate_isbn(\"0-670-82162-0\") devuelve \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "arb": "/*\n  يتحقق من صحة رقم ISBN المعطى.\n\n  رقم ISBN هو سلسلة نصية بتنسيق \"x-xxx-xxxxx-x\"، حيث يمثل 'x' رقماً، و'-' هو فاصل. الرقم الأخير هو رقم التحقق، يتم حسابه كمجموع الأرقام التسعة الأولى كل منها مضروب في موضعه (من 1 إلى 9)، ثم يؤخذ الباقي من القسمة على 11. إذا كانت النتيجة 10، فإن رقم التحقق هو 'X'.\n\n  الوسائط:\n  - isbn: سلسلة نصية تمثل رقم ISBN.\n\n  يعيد:\n  - استجابة نصية. إذا كان رقم ISBN صحيحاً، يعيد \"Right\". خلاف ذلك، يعيد رقم ISBN المصحح.\n\n  مثال:\n  - validate_isbn(\"0-670-82162-4\") يعيد \"Right\"\n  - validate_isbn(\"0-670-82162-0\") يعيد \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "sw": "/*\n  Inathibitisha usahihi wa nambari ya ISBN iliyotolewa.\n\n  Nambari ya ISBN ni kamba iliyo na muundo \"x-xxx-xxxxx-x\", ambapo 'x' inawakilisha tarakimu, na '-' ni kitenganishi. Tarakimu ya mwisho ni tarakimu ya ukaguzi, inayohesabiwa kama jumla ya tarakimu 9 za kwanza kila moja ikizidishwa na nafasi yake (1 hadi 9), modulo 11. Ikiwa matokeo ni 10, tarakimu ya ukaguzi ni 'X'.\n\n  Hoja:\n  - isbn: Kamba inayowakilisha nambari ya ISBN.\n\n  Inarudisha:\n  - Jibu la kamba. Ikiwa ISBN ni sahihi, inarudisha \"Right\". Vinginevyo, inarudisha nambari ya ISBN iliyosahihishwa.\n\n  Mfano:\n  - validate_isbn(\"0-670-82162-4\") inarudisha \"Right\"\n  - validate_isbn(\"0-670-82162-0\") inarudisha \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "tr": "/*\n  Belirtilen bir ISBN numarasının doğruluğunu kontrol eder.\n\n  Bir ISBN numarası \"x-xxx-xxxxx-x\" şeklinde biçimlendirilmiş bir dizgedir, burada 'x' bir rakamı ve '-' bir ayırıcıyı temsil eder. Son rakam, ilk 9 rakamın her birinin pozisyonlarıyla (1'den 9'a kadar) çarpılıp toplanması, ardından 11 ile mod alınmasıyla hesaplanan bir kontrol rakamıdır. Sonuç 10 ise, kontrol rakamı 'X' olur.\n\n  Argümanlar:\n  - isbn: Bir ISBN numarasını temsil eden bir dizge.\n\n  Döndürür:\n  - Bir dizge yanıtı. Eğer ISBN doğruysa, \"Right\" döndürür. Aksi takdirde, düzeltilmiş ISBN numarasını döndürür.\n\n  Örnek:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" döndürür\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" döndürür\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "vi": "/*\n  Xác thực tính đúng đắn của một số ISBN đã cho.\n\n  Một số ISBN là một chuỗi định dạng như \"x-xxx-xxxxx-x\", trong đó 'x' đại diện cho một chữ số, và '-' là một dấu phân cách. Chữ số cuối cùng là chữ số kiểm tra, được tính bằng tổng của 9 chữ số đầu tiên, mỗi chữ số nhân với vị trí của nó (từ 1 đến 9), sau đó lấy modulo 11. Nếu kết quả là 10, chữ số kiểm tra là 'X'.\n\n  Tham số:\n  - isbn: Một chuỗi đại diện cho một số ISBN.\n\n  Trả về:\n  - Một chuỗi phản hồi. Nếu ISBN đúng, trả về \"Right\". Ngược lại, trả về số ISBN đã được sửa.\n\n  Ví dụ:\n  - validate_isbn(\"0-670-82162-4\") trả về \"Right\"\n  - validate_isbn(\"0-670-82162-0\") trả về \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9812139358224824",
      "arb": "0.9508363984989118",
      "sw": "0.9792182963842249",
      "tr": "0.9529168531098712",
      "vi": "0.9690325304447558"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}",
    "instruction": {
      "en": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nRust kodunun Türkçe açıklamasını (docstring) en fazla 500 karakter kullanarak doğal dilde sağlayın.",
      "vi": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9238518653441791",
      "sw": "0.9431116629804649",
      "tr": "0.8808162097283981",
      "vi": "0.9212964854921653"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(validate_isbn(\"0-670-82162-4\"), \"Right\");\n        assert_eq!(validate_isbn(\"0-670-82162-0\"), \"0-670-82162-4\");\n        assert_eq!(validate_isbn(\"0-123-45678-9\"), \"Right\");\n        assert_eq!(validate_isbn(\"1-234-56789-X\"), \"Right\");\n    }\n    \n\n}",
    "entry_point": "validate_isbn",
    "signature": "fn validate_isbn(isbn: &str) -> String",
    "docstring": {
      "en": "Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"",
      "es": "Valida la corrección de un número ISBN dado.\n\n  Un número ISBN es una cadena con el formato \"x-xxx-xxxxx-x\", donde 'x' representa un dígito, y '-' es un separador. El último dígito es un dígito de control, calculado como la suma de los primeros 9 dígitos, cada uno multiplicado por su posición (1 a 9), módulo 11. Si el resultado es 10, el dígito de control es 'X'.\n\n  Argumentos:\n  - isbn: Una cadena que representa un número ISBN.\n\n  Retorna:\n  - Una respuesta en forma de cadena. Si el ISBN es correcto, retorna \"Right\". De lo contrario, retorna el número ISBN corregido.\n\n  Ejemplo:\n  - validate_isbn(\"0-670-82162-4\") retorna \"Right\"\n  - validate_isbn(\"0-670-82162-0\") retorna \"0-670-82162-4\"",
      "arb": "يتحقق من صحة رقم ISBN المعطى.\n\n  رقم ISBN هو سلسلة نصية بتنسيق \"x-xxx-xxxxx-x\"، حيث يمثل 'x' رقماً، و'-' هو فاصل. الرقم الأخير هو رقم التحقق، يتم حسابه كمجموع الأرقام التسعة الأولى كل منها مضروب في موقعه (من 1 إلى 9)، ثم يؤخذ الباقي عند القسمة على 11. إذا كانت النتيجة 10، فإن رقم التحقق هو 'X'.\n\n  الحجج:\n  - isbn: سلسلة نصية تمثل رقم ISBN.\n\n  العوائد:\n  - استجابة نصية. إذا كان ISBN صحيحاً، يُرجع \"Right\". خلاف ذلك، يُرجع رقم ISBN المصحح.\n\n  مثال:\n  - validate_isbn(\"0-670-82162-4\") يُرجع \"Right\"\n  - validate_isbn(\"0-670-82162-0\") يُرجع \"0-670-82162-4\"",
      "sw": "Inathibitisha usahihi wa nambari ya ISBN iliyotolewa.\n\n  Nambari ya ISBN ni kamba iliyopangwa kama \"x-xxx-xxxxx-x\", ambapo 'x' inawakilisha tarakimu, na '-' ni kitenganishi. Tarakimu ya mwisho ni tarakimu ya ukaguzi, inayohesabiwa kama jumla ya tarakimu 9 za kwanza kila moja ikizidishwa na nafasi yake (1 hadi 9), modulo 11. Ikiwa matokeo ni 10, tarakimu ya ukaguzi ni 'X'.\n\n  Hoja:\n  - isbn: Kamba inayowakilisha nambari ya ISBN.\n\n  Inarudisha:\n  - Jibu la kamba. Ikiwa ISBN ni sahihi, inarudisha \"Right\". Vinginevyo, inarudisha nambari ya ISBN iliyosahihishwa.\n\n  Mfano:\n  - validate_isbn(\"0-670-82162-4\") inarudisha \"Right\"\n  - validate_isbn(\"0-670-82162-0\") inarudisha \"0-670-82162-4\"",
      "tr": "Verilen bir ISBN numarasının doğruluğunu doğrular.\n\n  Bir ISBN numarası \"x-xxx-xxxxx-x\" şeklinde biçimlendirilmiş bir dizgidir, burada 'x' bir rakamı temsil eder ve '-' bir ayırıcıdır. Son rakam, ilk 9 rakamın her birinin pozisyonlarıyla (1'den 9'a kadar) çarpılıp toplanması, ardından 11'e göre mod alınarak hesaplanan bir kontrol rakamıdır. Sonuç 10 ise, kontrol rakamı 'X' olur.\n\n  Argümanlar:\n  - isbn: Bir ISBN numarasını temsil eden bir dizgi.\n\n  Döndürülenler:\n  - Bir dizgi yanıtı. Eğer ISBN doğruysa, \"Right\" döner. Aksi takdirde, düzeltilmiş ISBN numarasını döner.\n\n  Örnek:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" döner\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" döner",
      "vi": "Xác thực tính chính xác của một số ISBN đã cho.\n\nMột số ISBN là một chuỗi được định dạng dưới dạng \"x-xxx-xxxxx-x\", trong đó 'x' đại diện cho một chữ số, và '-' là một dấu phân cách. Chữ số cuối cùng là một chữ số kiểm tra, được tính bằng tổng của 9 chữ số đầu tiên, mỗi chữ số nhân với vị trí của nó (từ 1 đến 9), sau đó lấy modulo 11. Nếu kết quả là 10, chữ số kiểm tra là 'X'.\n\nTham số:\n- isbn: Một chuỗi đại diện cho một số ISBN.\n\nTrả về:\n- Một chuỗi phản hồi. Nếu ISBN đúng, trả về \"Right\". Ngược lại, trả về số ISBN đã được chỉnh sửa.\n\nVí dụ:\n- validate_isbn(\"0-670-82162-4\") trả về \"Right\"\n- validate_isbn(\"0-670-82162-0\") trả về \"0-670-82162-4\""
    },
    "docstring_bertscore": {
      "es": "0.9826895609231905",
      "arb": "0.9546093825866694",
      "sw": "0.9777377055239908",
      "tr": "0.9484158886756205",
      "vi": "0.9687808657519845"
    }
  },
  {
    "task_id": "Rust/40",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "es": "/*\n  Calcula el número de formas diferentes de pasar una pelota entre 'n' estudiantes parados en un círculo, de manera que después de 'm' pases, la pelota regrese al estudiante original.\n\n  Argumentos:\n  - n: El número de estudiantes en el círculo. Es un entero donde 3 <= n <= 30.\n  - m: El número de veces que se pasa la pelota. Es un entero donde 1 <= m <= 30.\n\n  Devuelve:\n  - El número de secuencias de pases distintas que devuelven la pelota al estudiante inicial después de 'm' pases.\n\n  Ejemplos:\n  - count_passing_ways(3, 3) devuelve 2\n  - count_passing_ways(4, 2) devuelve 4\n  - count_passing_ways(5, 5) devuelve 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "arb": "/*\n  يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب الواقفين في دائرة، بحيث تعود الكرة بعد 'm' تمريرات إلى الطالب الأصلي.\n\n  الوسائط:\n  - n: عدد الطلاب في الدائرة. وهو عدد صحيح حيث 3 <= n <= 30.\n  - m: عدد المرات التي يتم فيها تمرير الكرة. وهو عدد صحيح حيث 1 <= m <= 30.\n\n  يعيد:\n  - عدد تسلسلات التمرير المميزة التي تعيد الكرة إلى الطالب المبتدئ بعد 'm' تمريرات.\n\n  أمثلة:\n  - count_passing_ways(3, 3) يعيد 2\n  - count_passing_ways(4, 2) يعيد 4\n  - count_passing_ways(5, 5) يعيد 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliokaa kwenye duara, ambapo baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa awali.\n\n  Hoja:\n  - n: Idadi ya wanafunzi kwenye duara. Ni nambari kamili ambapo 3 <= n <= 30.\n  - m: Idadi ya mara ambazo mpira unapitishwa. Ni nambari kamili ambapo 1 <= m <= 30.\n\n  Inarudisha:\n  - Idadi ya mfuatano tofauti wa kupitisha ambao unarudisha mpira kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n  Mifano:\n  - count_passing_ways(3, 3) inarudisha 2\n  - count_passing_ways(4, 2) inarudisha 4\n  - count_passing_ways(5, 5) inarudisha 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "tr": "/*\n  Topun bir dairede duran 'n' öğrenci arasında, 'm' paslaşmadan sonra topun orijinal öğrenciye geri dönecek şekilde kaç farklı yolla paslaşılabileceğini hesaplar.\n\n  Argümanlar:\n  - n: Dairedeki öğrenci sayısı. 3 <= n <= 30 olan bir tam sayıdır.\n  - m: Topun kaç kez paslandığı. 1 <= m <= 30 olan bir tam sayıdır.\n\n  Döndürür:\n  - 'm' paslaşmadan sonra topu başlangıçtaki öğrenciye geri döndüren farklı paslaşma dizilerinin sayısı.\n\n  Örnekler:\n  - count_passing_ways(3, 3) 2 döndürür\n  - count_passing_ways(4, 2) 4 döndürür\n  - count_passing_ways(5, 5) 6 döndürür\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "vi": "/*\n  Tính số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh đứng thành vòng tròn, sao cho sau 'm' lần chuyền, quả bóng quay trở lại học sinh ban đầu.\n\n  Tham số:\n  - n: Số lượng học sinh trong vòng tròn. Đây là một số nguyên mà 3 <= n <= 30.\n  - m: Số lần quả bóng được chuyền. Đây là một số nguyên mà 1 <= m <= 30.\n\n  Trả về:\n  - Số lượng chuỗi chuyền bóng khác nhau đưa quả bóng trở về học sinh bắt đầu sau 'm' lần chuyền.\n\n  Ví dụ:\n  - count_passing_ways(3, 3) trả về 2\n  - count_passing_ways(4, 2) trả về 4\n  - count_passing_ways(5, 5) trả về 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9969957154868473",
      "arb": "0.9907472009602518",
      "sw": "0.987571895689028",
      "tr": "0.9925042853108864",
      "vi": "0.9875802381650316"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}",
    "instruction": {
      "en": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nAşağıdaki Rust kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9454590768235352",
      "arb": "0.9239644887702259",
      "sw": "0.9346146525405544",
      "tr": "0.847720018379603",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_passing_ways(3, 3), 2);\n        assert_eq!(count_passing_ways(4, 2), 2);\n        assert_eq!(count_passing_ways(5, 5), 2);    \n        assert_eq!(count_passing_ways(10, 3), 0);    \n        assert_eq!(count_passing_ways(30, 10), 252);    \n    }\n    \n\n}",
    "entry_point": "count_passing_ways",
    "signature": "fn count_passing_ways(n: i32, m: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "es": "Calcula el número de diferentes maneras de pasar una pelota entre 'n' estudiantes parados en un círculo, de tal manera que después de 'm' pases, la pelota regrese al estudiante original.\n\n  Argumentos:\n  - n: El número de estudiantes en el círculo. Es un entero donde 3 <= n <= 30.\n  - m: El número de veces que se pasa la pelota. Es un entero donde 1 <= m <= 30.\n\n  Retorna:\n  - El número de secuencias de pases distintas que regresan la pelota al estudiante inicial después de 'm' pases.\n\n  Ejemplos:\n  - count_passing_ways(3, 3) retorna 2\n  - count_passing_ways(4, 2) retorna 4\n  - count_passing_ways(5, 5) retorna 6",
      "arb": "يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب الواقفين في دائرة، بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الأصلي.\n\n  الحجج:\n  - n: عدد الطلاب في الدائرة. هو عدد صحيح حيث 3 <= n <= 30.\n  - m: عدد مرات تمرير الكرة. هو عدد صحيح حيث 1 <= m <= 30.\n\n  يعيد:\n  - عدد تسلسلات التمرير المميزة التي تعيد الكرة إلى الطالب المبتدئ بعد 'm' تمريرات.\n\n  أمثلة:\n  - count_passing_ways(3, 3) يعيد 2\n  - count_passing_ways(4, 2) يعيد 4\n  - count_passing_ways(5, 5) يعيد 6",
      "sw": "Hesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' walioko kwenye mduara, ili baada ya 'm' kupitisha, mpira urudi kwa mwanafunzi wa awali.\n\n  Hoja:\n  - n: Idadi ya wanafunzi kwenye mduara. Ni nambari kamili ambapo 3 <= n <= 30.\n  - m: Idadi ya mara ambazo mpira unapita. Ni nambari kamili ambapo 1 <= m <= 30.\n\n  Inarudi:\n  - Idadi ya mfuatano tofauti ya kupitisha ambayo inarudisha mpira kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n  Mifano:\n  - count_passing_ways(3, 3) inarudi 2\n  - count_passing_ways(4, 2) inarudi 4\n  - count_passing_ways(5, 5) inarudi 6",
      "tr": "Top şeklinde dizilmiş 'n' öğrenci arasında bir topu farklı şekillerde paslaşarak, 'm' paslaşmadan sonra topun ilk öğrenciye geri dönmesini sağlayan yolların sayısını hesaplar.\n\n  Argümanlar:\n  - n: Çemberdeki öğrenci sayısı. 3 <= n <= 30 olan bir tam sayıdır.\n  - m: Topun kaç kez paslandığı. 1 <= m <= 30 olan bir tam sayıdır.\n\n  Döndürür:\n  - 'm' paslaşmadan sonra topu başlangıçtaki öğrenciye geri döndüren farklı paslaşma dizilerinin sayısı.\n\n  Örnekler:\n  - count_passing_ways(3, 3) 2 döndürür\n  - count_passing_ways(4, 2) 4 döndürür\n  - count_passing_ways(5, 5) 6 döndürür",
      "vi": "Tính toán số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh đứng thành vòng tròn, sao cho sau 'm' lần chuyền, quả bóng quay trở lại học sinh ban đầu.\n\n  Tham số:\n  - n: Số lượng học sinh trong vòng tròn. Đây là một số nguyên với 3 <= n <= 30.\n  - m: Số lần quả bóng được chuyền. Đây là một số nguyên với 1 <= m <= 30.\n\n  Trả về:\n  - Số lượng chuỗi chuyền bóng khác nhau mà đưa quả bóng trở lại học sinh bắt đầu sau 'm' lần chuyền.\n\n  Ví dụ:\n  - count_passing_ways(3, 3) trả về 2\n  - count_passing_ways(4, 2) trả về 4\n  - count_passing_ways(5, 5) trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9940543968044827",
      "arb": "0.9956716453668687",
      "sw": "0.9819119229814389",
      "tr": "0.9811176000876805",
      "vi": "0.9788879740605638"
    }
  },
  {
    "task_id": "Rust/41",
    "prompt": {
      "en": "\n/*\n  Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "es": "/*\n  Calcula la suma máxima posible de diferencias absolutas entre pares de elementos de dos arreglos.\n  \n  Argumentos:\n  - a: Un arreglo de enteros.\n  - b: Un arreglo de enteros, de la misma longitud que 'a'.\n  \n  Retorna:\n  - La suma máxima de diferencias absolutas que se puede obtener emparejando cada elemento de 'a' con uno de 'b'.\n\n  Ejemplos:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) retorna 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) retorna 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) retorna 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "arb": "/*\n  يحسب الحد الأقصى الممكن لمجموع الفروقات المطلقة بين أزواج العناصر من مصفوفتين.\n\n  المعطيات:\n  - a: مصفوفة من الأعداد الصحيحة.\n  - b: مصفوفة من الأعداد الصحيحة، لها نفس طول 'a'.\n\n  يعيد:\n  - الحد الأقصى لمجموع الفروقات المطلقة الذي يمكن الحصول عليه عن طريق إقران كل عنصر من 'a' مع واحد من 'b'.\n\n  أمثلة:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) يعيد 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) يعيد 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) يعيد 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "sw": "/*\n  Inakokotoa jumla ya juu zaidi inayowezekana ya tofauti za thamani kamili kati ya jozi za vipengele kutoka safu mbili.\n  \n  Hoja:\n  - a: Safu ya nambari za mzima.\n  - b: Safu ya nambari za mzima, yenye urefu sawa na 'a'.\n  \n  Inarejesha:\n  - Jumla ya juu zaidi ya tofauti za thamani kamili inayoweza kupatikana kwa kuoanisha kila kipengele kutoka 'a' na kimoja kutoka 'b'.\n\n  Mifano:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) inarejesha 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) inarejesha 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) inarejesha 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "tr": "/*\n  İki dizideki eleman çiftleri arasındaki mutlak farkların maksimum olası toplamını hesaplar.\n  \n  Argümanlar:\n  - a: Bir tamsayı dizisi.\n  - b: 'a' ile aynı uzunlukta bir tamsayı dizisi.\n  \n  Döndürür:\n  - Her bir elemanı 'a'dan biriyle eşleştirerek elde edilebilecek mutlak farkların maksimum toplamı.\n\n  Örnekler:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 döndürür.\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 döndürür.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 döndürür.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "vi": "/*\n  Tính tổng lớn nhất có thể của các chênh lệch tuyệt đối giữa các cặp phần tử từ hai mảng.\n  \n  Tham số:\n  - a: Một mảng các số nguyên.\n  - b: Một mảng các số nguyên, có cùng độ dài với 'a'.\n  \n  Trả về:\n  - Tổng lớn nhất của các chênh lệch tuyệt đối có thể đạt được bằng cách ghép từng phần tử từ 'a' với một phần tử từ 'b'.\n\n  Ví dụ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) trả về 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) trả về 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) trả về 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 "
    },
    "prompt_bertscore": {
      "es": "0.9958587551858036",
      "arb": "0.9932584848676759",
      "sw": "0.9859276333948213",
      "tr": "0.9723152947521193",
      "vi": "0.9916410376749089"
    },
    "canonical_solution": "{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}",
    "instruction": {
      "en": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9099693893832697",
      "tr": "0.8732084675043809",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]), 14);\n        assert_eq!(max_pairing_difference(&[1, 2], &[3, 4]), 4);\n        assert_eq!(max_pairing_difference(&[10, 20, 30], &[30, 20, 10]), 40);\n    }\n    \n}",
    "entry_point": "max_pairing_difference",
    "signature": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64",
    "docstring": {
      "en": "Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "es": "Calcula la suma máxima posible de diferencias absolutas entre pares de elementos de dos arreglos.\n  \n  Argumentos:\n  - a: Un arreglo de enteros.\n  - b: Un arreglo de enteros, de la misma longitud que 'a'.\n  \n  Retorna:\n  - La suma máxima de diferencias absolutas que se puede obtener emparejando cada elemento de 'a' con uno de 'b'.\n\n  Ejemplos:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) retorna 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) retorna 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) retorna 60.",
      "arb": "يحسب الحد الأقصى الممكن لمجموع الفروق المطلقة بين أزواج العناصر من مصفوفتين.\n\n  الحجج:\n  - a: مصفوفة من الأعداد الصحيحة.\n  - b: مصفوفة من الأعداد الصحيحة، لها نفس طول 'a'.\n\n  يعيد:\n  - الحد الأقصى لمجموع الفروق المطلقة التي يمكن الحصول عليها عن طريق إقران كل عنصر من 'a' مع عنصر من 'b'.\n\n  أمثلة:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) يعيد 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) يعيد 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) يعيد 60.",
      "sw": "Inahesabu jumla ya juu kabisa ya tofauti za thamani kamili kati ya jozi za vipengele kutoka safu mbili.\n\n  Hoja:\n  - a: Safu ya namba za mzima.\n  - b: Safu ya namba za mzima, yenye urefu sawa na 'a'.\n  \n  Inarejesha:\n  - Jumla ya juu kabisa ya tofauti za thamani kamili inayoweza kupatikana kwa kuoanisha kila kipengele kutoka 'a' na kimoja kutoka 'b'.\n\n  Mifano:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) inarejesha 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) inarejesha 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) inarejesha 60.",
      "tr": "Mutlak farkların maksimum olası toplamını iki diziden eleman çiftleri arasında hesaplar.\n\n  Argümanlar:\n  - a: Bir tamsayı dizisi.\n  - b: 'a' ile aynı uzunlukta bir tamsayı dizisi.\n  \n  Döndürülen:\n  - Her bir elemanı 'a'dan biriyle eşleştirerek elde edilebilecek mutlak farkların maksimum toplamı.\n\n  Örnekler:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 döndürür.\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 döndürür.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 döndürür.",
      "vi": "Tính tổng lớn nhất có thể của các chênh lệch tuyệt đối giữa các cặp phần tử từ hai mảng.\n\n  Tham số:\n  - a: Một mảng số nguyên.\n  - b: Một mảng số nguyên, có cùng độ dài với 'a'.\n  \n  Trả về:\n  - Tổng lớn nhất của các chênh lệch tuyệt đối có thể đạt được bằng cách ghép mỗi phần tử từ 'a' với một phần tử từ 'b'.\n\n  Ví dụ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) trả về 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) trả về 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) trả về 60."
    },
    "docstring_bertscore": {
      "es": "0.9960172622298694",
      "arb": "0.9944210684878731",
      "sw": "0.9798267012413346",
      "tr": "0.9758099976760471",
      "vi": "0.9888506780821307"
    }
  },
  {
    "task_id": "Rust/42",
    "prompt": {
      "en": "/*\n  Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "es": "/*\n  Encuentra el número con el mayor factor primo en una lista dada de números.\n\n  La función itera a través de cada número en la lista y calcula su mayor factor primo.\n  Luego compara estos factores para encontrar el número con el mayor factor primo.\n\n  Argumentos:\n  - numbers: Un segmento de enteros.\n\n  Devuelve:\n  - El número de la lista que tiene el mayor factor primo.\n\n  Ejemplos:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) Devuelve 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) Devuelve 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) Devuelve 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "arb": "/*\n  يجد الرقم الذي يحتوي على أكبر عامل أولي في قائمة الأرقام المعطاة.\n\n  تقوم الدالة بالمرور عبر كل رقم في القائمة وتحسب أكبر عامل أولي له.\n  ثم تقارن بين هذه العوامل للعثور على الرقم الذي يحتوي على أكبر عامل أولي.\n\n  الحجج:\n  - numbers: شريحة من الأعداد الصحيحة.\n\n  يعيد:\n  - الرقم من القائمة الذي يحتوي على أكبر عامل أولي.\n\n  أمثلة:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) يعيد 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) يعيد 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) يعيد 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "sw": "/*\n  Inapata nambari yenye kipengele kikubwa zaidi cha msingi katika orodha iliyotolewa ya nambari.\n\n  Kazi inarudia kupitia kila nambari katika orodha na kuhesabu kipengele chake kikubwa zaidi cha msingi. \n  Kisha inalinganisha vipengele hivi ili kupata nambari yenye kipengele kikubwa zaidi cha msingi.\n\n  Hoja:\n  - numbers: Sehemu ya nambari za mzima.\n\n  Inarejesha:\n  - Nambari kutoka kwenye orodha ambayo ina kipengele kikubwa zaidi cha msingi.\n\n  Mifano:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) inarejesha 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) inarejesha 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) inarejesha 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "tr": "/*\n  Verilen bir sayı listesinde en büyük asal çarpanı olan sayıyı bulur.\n\n  Fonksiyon, listedeki her sayıyı iterasyonla dolaşır ve en büyük asal çarpanını hesaplar.\n  Daha sonra bu çarpanları karşılaştırarak en büyük asal çarpanı olan sayıyı bulur.\n\n  Argümanlar:\n  - numbers: Bir tamsayı dilimi.\n\n  Döndürür:\n  - Listeden en büyük asal çarpanı olan sayıyı döndürür.\n\n  Örnekler:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 döndürür\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 döndürür\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 döndürür\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "vi": "/*\n  Tìm số có ước số nguyên tố lớn nhất trong một danh sách các số.\n\n  Hàm này duyệt qua từng số trong danh sách và tính toán ước số nguyên tố lớn nhất của nó.\n  Sau đó, nó so sánh các ước số này để tìm ra số có ước số nguyên tố lớn nhất.\n\n  Tham số:\n  - numbers: Một mảng số nguyên.\n\n  Trả về:\n  - Số từ danh sách có ước số nguyên tố lớn nhất.\n\n  Ví dụ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) trả về 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) trả về 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) trả về 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32"
    },
    "prompt_bertscore": {
      "es": "0.9932368341561431",
      "arb": "0.9944135205333938",
      "sw": "0.9943694245888041",
      "tr": "0.9844720699625976",
      "vi": "0.9717656844877958"
    },
    "canonical_solution": "{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}",
    "instruction": {
      "en": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yapılmalıdır.",
      "vi": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9153697521828462",
      "tr": "0.8659743490270903",
      "vi": "0.9035627650733704"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_prime_factor_in_list(&[36, 38, 40, 42]), 38);\n        assert_eq!(max_prime_factor_in_list(&[10, 15, 21, 22]), 22);\n        assert_eq!(max_prime_factor_in_list(&[7, 11, 13, 19]), 19);\n        assert_eq!(max_prime_factor_in_list(&[2, 3, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "max_prime_factor_in_list",
    "signature": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32",
    "docstring": {
      "en": "Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "es": "Encuentra el número con el factor primo más grande en una lista dada de números.\n\n  La función itera a través de cada número en la lista y calcula su mayor factor primo. \n  Luego compara estos factores para encontrar el número con el mayor factor primo.\n\n  Argumentos:\n  - numbers: Una porción de enteros.\n\n  Retorna:\n  - El número de la lista que tiene el mayor factor primo.\n\n  Ejemplos:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) retorna 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) retorna 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) retorna 19",
      "arb": "يجد العدد الذي يحتوي على أكبر عامل أولي في قائمة الأعداد المعطاة.\n\nتقوم الدالة بالمرور عبر كل عدد في القائمة وتحسب أكبر عامل أولي له. ثم تقارن بين هذه العوامل للعثور على العدد الذي يحتوي على أكبر عامل أولي.\n\nالحجج:\n- numbers: شريحة من الأعداد الصحيحة.\n\nالقيم المعادة:\n- العدد من القائمة الذي يحتوي على أكبر عامل أولي.\n\nأمثلة:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) يعيد 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) يعيد 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) يعيد 19",
      "sw": "Inapata namba yenye kipengele kikubwa zaidi cha msingi katika orodha iliyotolewa ya namba.\n\n  Kazi hii inazunguka kupitia kila namba katika orodha na kuhesabu kipengele chake kikubwa zaidi cha msingi. \n  Kisha inalinganisha vipengele hivi ili kupata namba yenye kipengele kikubwa zaidi cha msingi.\n\n  Hoja:\n  - numbers: Sehemu ya namba za mzima.\n\n  Inarejesha:\n  - Namba kutoka kwenye orodha ambayo ina kipengele kikubwa zaidi cha msingi.\n\n  Mifano:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) inarejesha 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) inarejesha 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) inarejesha 19",
      "tr": "Verilen bir sayı listesindeki en büyük asal çarpana sahip sayıyı bulur.\n\n  Fonksiyon, listedeki her sayıyı iterasyona tabi tutar ve en büyük asal çarpanını hesaplar. \n  Daha sonra bu çarpanları karşılaştırarak en büyük asal çarpana sahip sayıyı bulur.\n\n  Argümanlar:\n  - numbers: Bir tamsayı dilimi.\n\n  Döndürür:\n  - Listedeki en büyük asal çarpana sahip sayıyı döndürür.\n\n  Örnekler:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 döndürür\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 döndürür\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 döndürür",
      "vi": "Tìm số có ước số nguyên tố lớn nhất trong một danh sách các số đã cho.\n\n  Hàm này duyệt qua từng số trong danh sách và tính toán ước số nguyên tố lớn nhất của nó.\n  Sau đó, nó so sánh các ước số này để tìm ra số có ước số nguyên tố lớn nhất.\n\n  Tham số:\n  - numbers: Một danh sách các số nguyên.\n\n  Trả về:\n  - Số từ danh sách có ước số nguyên tố lớn nhất.\n\n  Ví dụ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) trả về 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) trả về 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) trả về 19"
    },
    "docstring_bertscore": {
      "es": "0.9942208490637899",
      "arb": "0.982658177322987",
      "sw": "0.987087634820065",
      "tr": "0.9790645564693038",
      "vi": "0.9737708581843431"
    }
  },
  {
    "task_id": "Rust/43",
    "prompt": {
      "en": "/*\n  Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "es": "/*\n  Calcula la longitud de la subsecuencia no decreciente más larga en una secuencia dada de números.\n  \n  La función toma un vector de enteros y devuelve la longitud de la subsecuencia más larga donde cada elemento no es menor que el anterior.\n\n  Argumentos:\n  - sequence: Un vector de enteros.\n\n  Devuelve:\n  - La longitud de la subsecuencia no decreciente más larga en la secuencia dada.\n\n  Ejemplos:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) Devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) Devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) Devuelve 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "arb": "/*\n  يحسب طول أطول سلسلة غير متناقصة في تسلسل معين من الأرقام.\n\n  تأخذ الدالة متجهًا من الأعداد الصحيحة وتعيد طول أطول سلسلة حيث لا يكون أي عنصر أقل من العنصر السابق.\n\n  الوسائط:\n  - sequence: متجه من الأعداد الصحيحة.\n\n  يعيد:\n  - طول أطول سلسلة غير متناقصة في التسلسل المعطى.\n\n  أمثلة:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) يعيد 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) يعيد 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) يعيد 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "sw": "/*\n  Inahesabu urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa wa nambari.\n  \n  Kazi inachukua vector ya nambari nzima na inarejesha urefu wa mlolongo mrefu zaidi ambapo kila kipengele si chini ya kile kilichotangulia.\n\n  Hoja:\n  - sequence: Vector ya nambari nzima.\n\n  Inarejesha:\n  - Urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa.\n\n  Mifano:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) inarejesha 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) inarejesha 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) inarejesha 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "tr": "/*\n  Verilen bir sayı dizisindeki en uzun artmayan alt dizinin uzunluğunu hesaplar.\n  \n  Fonksiyon, bir tamsayılar vektörünü alır ve her bir elemanın bir öncekinden küçük olmadığı en uzun alt dizinin uzunluğunu döndürür.\n\n  Argümanlar:\n  - sequence: Bir tamsayılar vektörü.\n\n  Döndürür:\n  - Verilen dizideki en uzun artmayan alt dizinin uzunluğu.\n\n  Örnekler:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 döndürür\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 döndürür\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 döndürür\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "vi": "/*\n  Tính độ dài của dãy con không giảm dài nhất trong một dãy số cho trước.\n  \n  Hàm nhận một vector các số nguyên và trả về độ dài của dãy con dài nhất mà mỗi phần tử không nhỏ hơn phần tử trước đó.\n\n  Tham số:\n  - sequence: Một vector các số nguyên.\n\n  Trả về:\n  - Độ dài của dãy con không giảm dài nhất trong dãy cho trước.\n\n  Ví dụ:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) trả về 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) trả về 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) trả về 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.991784448810016",
      "sw": "0.9874423886805933",
      "tr": "0.9907158173600483",
      "vi": "0.9879461153268978"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}",
    "instruction": {
      "en": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olmalıdır.",
      "vi": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9431116629804649",
      "tr": "0.8594225259086544",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![1, 2, 3]), 3);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![]), 0);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![10]), 1);        \n    }\n    \n\n}",
    "entry_point": "longest_non_decreasing_subsequence_length",
    "signature": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize",
    "docstring": {
      "en": "Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "es": "Calcula la longitud de la subsecuencia no decreciente más larga en una secuencia dada de números.\n  \n  La función toma un vector de enteros y devuelve la longitud de la subsecuencia más larga donde cada elemento no es menor que el anterior.\n\n  Argumentos:\n  - sequence: Un vector de enteros.\n\n  Devuelve:\n  - La longitud de la subsecuencia no decreciente más larga en la secuencia dada.\n\n  Ejemplos:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) devuelve 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) devuelve 4",
      "arb": "يحسب طول أطول سلسلة غير متناقصة في تسلسل معين من الأرقام.\n\nتأخذ الدالة متجهًا من الأعداد الصحيحة وتعيد طول أطول سلسلة حيث لا يكون أي عنصر أقل من العنصر السابق.\n\nالأوساط:\n- sequence: متجه من الأعداد الصحيحة.\n\nالإرجاع:\n- طول أطول سلسلة غير متناقصة في التسلسل المعطى.\n\nأمثلة:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) يعيد 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) يعيد 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) يعيد 4",
      "sw": "Hesabu urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa wa nambari.\n\n  Kazi inachukua vekta ya nambari nzima na inarudisha urefu wa mlolongo mrefu zaidi ambapo kila kipengele si chini ya kile kilichotangulia.\n\n  Hoja:\n  - sequence: Vekta ya nambari nzima.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi usiopungua katika mlolongo uliotolewa.\n\n  Mifano:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) inarudisha 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) inarudisha 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) inarudisha 4",
      "tr": "Verilen bir sayı dizisindeki en uzun artmayan alt dizinin uzunluğunu hesaplar.\n\nFonksiyon, bir tamsayı vektörü alır ve her bir elemanın bir öncekinden küçük olmadığı en uzun alt dizinin uzunluğunu döndürür.\n\nArgümanlar:\n- sequence: Bir tamsayı vektörü.\n\nDöndürülenler:\n- Verilen dizideki en uzun artmayan alt dizinin uzunluğu.\n\nÖrnekler:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 döndürür\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 döndürür\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 döndürür",
      "vi": "Tính toán độ dài của dãy con không giảm dài nhất trong một dãy số cho trước.\n\nHàm nhận một vector số nguyên và trả về độ dài của dãy con dài nhất mà mỗi phần tử không nhỏ hơn phần tử trước đó.\n\nCác đối số:\n- sequence: Một vector số nguyên.\n\nTrả về:\n- Độ dài của dãy con không giảm dài nhất trong dãy cho trước.\n\nVí dụ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) trả về 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) trả về 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) trả về 4"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9822682658850155",
      "sw": "0.994852890936243",
      "tr": "0.9781365553291088",
      "vi": "0.9906776803268896"
    }
  },
  {
    "task_id": "Rust/44",
    "prompt": {
      "en": "/*\n  Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "es": "/*\n  Cuenta el número de pares de estudiantes cuyas puntuaciones en cada materia (Chino, Matemáticas, Inglés) difieren en no más de 5 puntos, y cuya diferencia de puntuación total es de no más de 10 puntos. Tales pares se consideran \"igualmente emparejados\".\n\n  Argumentos:\n  - scores: Un vector de tuplas, cada una contiene tres enteros que representan las puntuaciones de un estudiante en Chino, Matemáticas e Inglés, respectivamente.\n\n  Devuelve:\n  - Un entero que representa el número de pares de estudiantes \"igualmente emparejados\".\n\n  Ejemplo:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) devuelve 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "arb": "/*\n  يحسب عدد أزواج الطلاب الذين تختلف درجاتهم في كل مادة (الصينية، الرياضيات، الإنجليزية) بما لا يزيد عن 5 نقاط، والذين يكون فرق مجموع درجاتهم لا يزيد عن 10 نقاط. تعتبر هذه الأزواج \"متكافئة\".\n\n  المعطيات:\n  - scores: متجه من الأزواج، يحتوي كل منها على ثلاثة أعداد صحيحة تمثل درجات الطالب في الصينية، الرياضيات، والإنجليزية، على التوالي.\n\n  يعيد:\n  - عدد صحيح يمثل عدد أزواج الطلاب \"المتكافئة\".\n\n  مثال:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) يعيد 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "sw": "/*\n  Inahesabu idadi ya jozi za wanafunzi ambao alama zao katika kila somo (Kichina, Hisabati, Kiingereza) zinatofautiana kwa si zaidi ya alama 5, na tofauti ya jumla ya alama zao ni si zaidi ya alama 10. Jozi kama hizo zinachukuliwa kuwa \"zinafanana sawa\".\n\n  Hoja:\n  - scores: Vekta ya jozi, kila moja ikiwa na namba tatu za mzima zinazoashiria alama za mwanafunzi katika Kichina, Hisabati, na Kiingereza, mtawalia.\n\n  Inarudisha:\n  - Nambari ya mzima inayowakilisha idadi ya jozi za wanafunzi \"wanaofanana sawa\".\n\n  Mfano:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) inarudisha 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
      "tr": "/*\n  Her bir dersteki (Çince, Matematik, İngilizce) puanları arasındaki fark 5 puandan fazla olmayan ve toplam puan farkı 10 puandan fazla olmayan öğrenci çiftlerinin sayısını sayar. Bu tür çiftler \"eşit derecede eşleşmiş\" olarak kabul edilir.\n\n  Argümanlar:\n  - scores: Her biri bir öğrencinin Çince, Matematik ve İngilizce derslerindeki puanlarını temsil eden üç tam sayı içeren bir demet vektörü.\n\n  Döndürür:\n  - \"Eşit derecede eşleşmiş\" öğrenci çiftlerinin sayısını temsil eden bir tam sayı.\n\n  Örnek:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 döndürür\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "vi": "/*\n  Đếm số cặp học sinh mà điểm số của họ trong mỗi môn học (Ngữ văn, Toán, Tiếng Anh) chênh lệch không quá 5 điểm, và tổng điểm chênh lệch không quá 10 điểm. Những cặp như vậy được coi là \"tương xứng\".\n\n  Tham số:\n  - scores: Một vector chứa các bộ ba số nguyên, mỗi bộ ba đại diện cho điểm số của một học sinh trong các môn Ngữ văn, Toán, và Tiếng Anh, theo thứ tự.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cặp học sinh \"tương xứng\".\n\n  Ví dụ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) trả về 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9960975089038075",
      "arb": "0.9528282639599296",
      "sw": "0.9742565094659733",
      "tr": "0.975256414804103",
      "vi": "0.9404847761912786"
    },
    "canonical_solution": "{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
    "instruction": {
      "en": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.922991994424679",
      "sw": "0.8894202819436864",
      "tr": "0.8732084675043809",
      "vi": "0.9278963771628115"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]), 2);\n        assert_eq!(count_comparable_pairs(vec![(100, 100, 100), (95, 95, 95), (90, 90, 90)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 85, 80), (80, 85, 90), (70, 75, 80)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90)]), 0);\n    }\n    \n\n}",
    "entry_point": "count_comparable_pairs",
    "signature": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
    "docstring": {
      "en": "Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "es": "Cuenta el número de pares de estudiantes cuyas puntuaciones en cada asignatura (Chino, Matemáticas, Inglés) difieren en no más de 5 puntos, y cuya diferencia de puntuación total es de no más de 10 puntos. Tales pares se consideran \"igualmente emparejados\".\n\n  Argumentos:\n  - scores: Un vector de tuplas, cada una contiene tres enteros que representan las puntuaciones de un estudiante en Chino, Matemáticas e Inglés, respectivamente.\n\n  Retorna:\n  - Un entero que representa el número de pares de estudiantes \"igualmente emparejados\".\n\n  Ejemplo:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) retorna 2",
      "arb": "يحسب عدد أزواج الطلاب الذين تختلف درجاتهم في كل مادة (الصينية، الرياضيات، الإنجليزية) بما لا يزيد عن 5 نقاط، والذين يكون الفرق في مجموع درجاتهم لا يزيد عن 10 نقاط. تعتبر مثل هذه الأزواج \"متكافئة\".\n\n  الحجج:\n  - scores: متجه من الأزواج، يحتوي كل منها على ثلاثة أعداد صحيحة تمثل درجات الطالب في الصينية والرياضيات والإنجليزية، على التوالي.\n\n  يعيد:\n  - عدد صحيح يمثل عدد أزواج الطلاب \"المتكافئة\".\n\n  مثال:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) يعيد 2",
      "sw": "Hesabu idadi ya jozi za wanafunzi ambao alama zao katika kila somo (Kichina, Hisabati, Kiingereza) hazitofautiani kwa zaidi ya pointi 5, na tofauti ya jumla ya alama zao sio zaidi ya pointi 10. Jozi kama hizo zinachukuliwa kuwa \"zinashabihiana sawa\".\n\n  Hoja:\n  - scores: Vector ya tuples, kila moja ikiwa na nambari tatu za integer zinazowakilisha alama za mwanafunzi katika Kichina, Hisabati, na Kiingereza, mtawalia.\n\n  Inarejesha:\n  - Nambari ya integer inayowakilisha idadi ya jozi za wanafunzi \"zinazoshabihiana sawa\".\n\n  Mfano:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) inarejesha 2",
      "tr": "Her bir dersteki (Çince, Matematik, İngilizce) puanları en fazla 5 puan fark eden ve toplam puan farkı en fazla 10 puan olan öğrenci çiftlerinin sayısını sayar. Bu tür çiftler \"eşit derecede eşleşmiş\" olarak kabul edilir.\n\n  Argümanlar:\n  - scores: Her biri sırasıyla bir öğrencinin Çince, Matematik ve İngilizce derslerindeki puanlarını temsil eden üç tamsayı içeren demetlerin bir vektörü.\n\n  Döndürür:\n  - \"Eşit derecede eşleşmiş\" öğrenci çiftlerinin sayısını temsil eden bir tamsayı.\n\n  Örnek:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 döndürür.",
      "vi": "Đếm số cặp học sinh có điểm số trong mỗi môn học (Ngữ văn, Toán, Tiếng Anh) chênh lệch không quá 5 điểm, và tổng điểm chênh lệch không quá 10 điểm. Những cặp như vậy được coi là \"tương đương nhau\".\n\n  Tham số:\n  - scores: Một vector chứa các bộ ba số nguyên, mỗi bộ ba đại diện cho điểm số của một học sinh trong các môn Ngữ văn, Toán và Tiếng Anh, tương ứng.\n\n  Trả về:\n  - Một số nguyên đại diện cho số cặp học sinh \"tương đương nhau\".\n\n  Ví dụ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9951857954548574",
      "arb": "0.9474569011959841",
      "sw": "0.952785558428007",
      "tr": "0.968231454118042",
      "vi": "0.9360495584131505"
    }
  },
  {
    "task_id": "Rust/45",
    "prompt": {
      "en": "/*\n  Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "es": "/*\n  Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial y una tasa de conversión de colillas de cigarrillos a cigarrillos nuevos.\n\n  Argumentos:\n  - initial_cigarettes: El número inicial de cigarrillos que Peter tiene.\n  - butts_for_new: El número de colillas de cigarrillos requeridas para intercambiar por un cigarrillo nuevo.\n\n  Devuelve:\n  - El número total de cigarrillos que Peter puede fumar incluyendo aquellos obtenidos al intercambiar colillas por nuevos.\n\n  Ejemplo:\n  - total_smoked_cigarettes(4, 3) Devuelve 5\n  - total_smoked_cigarettes(10, 3) Devuelve 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
      "arb": "/*\n  يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بناءً على كمية أولية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n\n  الوسائط:\n  - initial_cigarettes: العدد الأولي للسجائر التي يمتلكها بيتر.\n  - butts_for_new: عدد أعقاب السجائر المطلوبة للتبادل مقابل سيجارة جديدة واحدة.\n\n  يعيد:\n  - العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بما في ذلك تلك التي تم الحصول عليها عن طريق تبادل الأعقاب بسجائر جديدة.\n\n  مثال:\n  - total_smoked_cigarettes(4, 3) يعيد 5\n  - total_smoked_cigarettes(10, 3) يعيد 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "sw": "/*\n  Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na kiasi cha awali na kiwango cha kubadilisha vipande vya sigara kuwa sigara mpya.\n\n  Hoja:\n  - initial_cigarettes: Idadi ya awali ya sigara ambazo Peter anazo.\n  - butts_for_new: Idadi ya vipande vya sigara vinavyohitajika kubadilishwa kwa sigara moja mpya.\n\n  Inarudisha:\n  - Jumla ya sigara ambazo Peter anaweza kuvuta ikiwa ni pamoja na zile zilizopatikana kwa kubadilisha vipande kwa mpya.\n\n  Mfano:\n  - total_smoked_cigarettes(4, 3) inarudisha 5\n  - total_smoked_cigarettes(10, 3) inarudisha 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "tr": "/*\n  Peter'ın başlangıç miktarı ve izmaritlerin yeni sigaralara dönüştürülme oranı verildiğinde, toplam kaç sigara içebileceğini hesaplar.\n\n  Argümanlar:\n  - initial_cigarettes: Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - butts_for_new: Bir yeni sigara ile değiştirmek için gereken sigara izmariti sayısı.\n\n  Döndürür:\n  - İzmaritleri yenileriyle değiştirerek elde edilenler de dahil olmak üzere, Peter'ın içebileceği toplam sigara sayısı.\n\n  Örnek:\n  - total_smoked_cigarettes(4, 3) 5 döndürür\n  - total_smoked_cigarettes(10, 3) 14 döndürür\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "vi": "/*\n  Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá sang điếu thuốc mới.\n\n  Tham số:\n  - initial_cigarettes: Số lượng điếu thuốc ban đầu mà Peter có.\n  - butts_for_new: Số lượng đầu lọc thuốc lá cần thiết để đổi lấy một điếu thuốc mới.\n\n  Trả về:\n  - Tổng số điếu thuốc mà Peter có thể hút bao gồm cả những điếu thuốc có được bằng cách đổi đầu lọc lấy điếu mới.\n\n  Ví dụ:\n  - total_smoked_cigarettes(4, 3) trả về 5\n  - total_smoked_cigarettes(10, 3) trả về 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9875180668557676",
      "arb": "0.9840225694103156",
      "sw": "0.9746998524764432",
      "tr": "0.9898932889521829",
      "vi": "0.9688454206258209"
    },
    "canonical_solution": "{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}",
    "instruction": {
      "en": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nRust kodunun işlevini Türkçe olarak en fazla 500 karakter kullanarak açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.8962398588157572",
      "sw": "0.9431116629804649",
      "tr": "0.8915468188030459",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(total_smoked_cigarettes(4, 3), 5);\n        assert_eq!(total_smoked_cigarettes(10, 3), 14);\n        assert_eq!(total_smoked_cigarettes(1, 2), 1); // Edge case: Not enough to exchange\n        assert_eq!(total_smoked_cigarettes(100, 5), 124); // Larger numbers\n    }\n    \n\n}",
    "entry_point": "total_smoked_cigarettes",
    "signature": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial y una tasa de conversión de colillas de cigarrillo a nuevos cigarrillos.\n\n  Argumentos:\n  - initial_cigarettes: El número inicial de cigarrillos que tiene Peter.\n  - butts_for_new: El número de colillas de cigarrillo requerido para intercambiar por un cigarrillo nuevo.\n\n  Retorna:\n  - El número total de cigarrillos que Peter puede fumar, incluyendo aquellos obtenidos al intercambiar colillas por nuevos.\n\n  Ejemplo:\n  - total_smoked_cigarettes(4, 3) Devuelve 5\n  - total_smoked_cigarettes(10, 3) Devuelve 14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى كمية أولية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n\n  الحجج:\n  - initial_cigarettes: العدد الأولي للسجائر التي يمتلكها بيتر.\n  - butts_for_new: عدد أعقاب السجائر المطلوبة للتبادل مقابل سيجارة جديدة واحدة.\n\n  يعيد:\n  - العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بما في ذلك تلك التي تم الحصول عليها عن طريق تبادل الأعقاب مقابل سجائر جديدة.\n\n  مثال:\n  - total_smoked_cigarettes(4, 3) يعيد 5\n  - total_smoked_cigarettes(10, 3) يعيد 14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na kiasi cha awali na kiwango cha ubadilishaji wa vipande vya sigara kuwa sigara mpya.\n\n  Hoja:\n  - initial_cigarettes: Idadi ya awali ya sigara ambazo Peter anazo.\n  - butts_for_new: Idadi ya vipande vya sigara vinavyohitajika kubadilishwa kwa sigara moja mpya.\n\n  Inarejesha:\n  - Jumla ya sigara ambazo Peter anaweza kuvuta ikiwa ni pamoja na zile zilizopatikana kwa kubadilisha vipande kwa mpya.\n\n  Mfano:\n  - total_smoked_cigarettes(4, 3) inarejesha 5\n  - total_smoked_cigarettes(10, 3) inarejesha 14",
      "tr": "Peter'ın başlangıç miktarı ve izmaritlerin yeni sigaralara dönüştürülme oranı verildiğinde toplam kaç sigara içebileceğini hesaplar.\n\n  Argümanlar:\n  - initial_cigarettes: Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - butts_for_new: Bir yeni sigara ile değiştirmek için gereken izmarit sayısı.\n\n  Döndürür:\n  - Peter'ın izmaritleri yeni sigaralarla değiştirerek elde ettikleri dahil olmak üzere içebileceği toplam sigara sayısı.\n\n  Örnek:\n  - total_smoked_cigarettes(4, 3) 5 döndürür\n  - total_smoked_cigarettes(10, 3) 14 döndürür",
      "vi": "Tính tổng số điếu thuốc lá mà Peter có thể hút được với số lượng ban đầu và tỷ lệ chuyển đổi từ đầu mẩu thuốc lá thành điếu thuốc mới.\n\n  Tham số:\n  - initial_cigarettes: Số lượng điếu thuốc ban đầu mà Peter có.\n  - butts_for_new: Số lượng đầu mẩu thuốc lá cần thiết để đổi lấy một điếu thuốc mới.\n\n  Trả về:\n  - Tổng số điếu thuốc mà Peter có thể hút bao gồm cả những điếu có được bằng cách đổi đầu mẩu lấy điếu mới.\n\n  Ví dụ:\n  - total_smoked_cigarettes(4, 3) trả về 5\n  - total_smoked_cigarettes(10, 3) trả về 14"
    },
    "docstring_bertscore": {
      "es": "0.9855486466278067",
      "arb": "0.9918349009267988",
      "sw": "0.97147091700234",
      "tr": "0.9409400370246105",
      "vi": "0.95964009424714"
    }
  },
  {
    "task_id": "Rust/46",
    "prompt": {
      "en": "/*\n  Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "es": "/*\n  Encuentra la longitud de la secuencia consecutiva más larga en el arreglo dado de números.\n  Una secuencia consecutiva se define como una secuencia de enteros donde cada número sigue al anterior por exactamente uno.\n  Esta función no requiere que el arreglo de entrada esté ordenado.\n\n  Argumentos:\n  - numbers: Un segmento de enteros que representa la secuencia.\n\n  Retorna:\n  - La longitud de la secuencia consecutiva más larga encontrada en el arreglo.\n\n  Ejemplo:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) devuelve 4 (porque la secuencia consecutiva más larga es 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) devuelve 5 (porque la secuencia es 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) devuelve 4 (porque la secuencia es 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "arb": "/*\n  يجد طول أطول سلسلة متتالية في مصفوفة الأرقام المعطاة.\n  تُعرف السلسلة المتتالية بأنها سلسلة من الأعداد الصحيحة حيث يتبع كل رقم الرقم السابق بفارق واحد بالضبط.\n  هذه الدالة لا تتطلب أن تكون المصفوفة المدخلة مرتبة.\n\n  المعطيات:\n  - numbers: جزء من الأعداد الصحيحة يمثل السلسلة.\n\n  يعيد:\n  - طول أطول سلسلة متتالية موجودة في المصفوفة.\n\n  مثال:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) يعيد 4 (لأن أطول سلسلة متتالية هي 1، 2، 3، 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) يعيد 5 (لأن السلسلة هي 1، 2، 3، 4، 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) يعيد 4 (لأن السلسلة هي 1، 2، 3، 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "sw": "/*\n  Inapata urefu wa mlolongo mrefu zaidi wa mfululizo katika safu iliyotolewa ya nambari.\n  Mlolongo wa mfululizo unafafanuliwa kama mlolongo wa nambari za mzima ambapo kila nambari inafuata ile ya awali kwa moja tu.\n  Kazi hii haihitaji safu ya ingizo kupangwa.\n\n  Hoja:\n  - numbers: Sehemu ya nambari za mzima inayowakilisha mlolongo.\n\n  Inarudisha:\n  - Urefu wa mlolongo mrefu zaidi wa mfululizo uliopatikana katika safu.\n\n  Mfano:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) inarudisha 4 (kwa sababu mlolongo mrefu zaidi wa mfululizo ni 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) inarudisha 5 (kwa sababu mlolongo ni 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) inarudisha 4 (kwa sababu mlolongo ni 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "tr": "/*\n  Verilen sayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\n  Ardışık bir dizi, her sayının bir öncekini tam olarak bir birim takip ettiği bir tamsayılar dizisi olarak tanımlanır.\n  Bu fonksiyon, giriş dizisinin sıralı olmasını gerektirmez.\n\n  Argümanlar:\n  - numbers: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizide bulunan en uzun ardışık dizinin uzunluğu.\n\n  Örnek:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 döndürür (çünkü en uzun ardışık dizi 1, 2, 3, 4'tür)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 döndürür (çünkü dizi 1, 2, 3, 4, 5'tir)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 döndürür (çünkü dizi 1, 2, 3, 4'tür)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "vi": "/*\n  Tìm độ dài của dãy liên tiếp dài nhất trong mảng số đã cho.\n  Một dãy liên tiếp được định nghĩa là một dãy số nguyên mà mỗi số theo sau số trước đó đúng một đơn vị.\n  Hàm này không yêu cầu mảng đầu vào phải được sắp xếp.\n\n  Tham số:\n  - numbers: Một lát cắt của các số nguyên đại diện cho dãy số.\n\n  Trả về:\n  - Độ dài của dãy liên tiếp dài nhất tìm thấy trong mảng.\n\n  Ví dụ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) trả về 4 (vì dãy liên tiếp dài nhất là 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) trả về 5 (vì dãy là 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) trả về 4 (vì dãy là 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9942335614081762",
      "arb": "0.981400052489512",
      "sw": "0.9987631286172958",
      "tr": "0.9929625255999339",
      "vi": "0.9880132523956876"
    },
    "canonical_solution": "{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}",
    "instruction": {
      "en": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yapılmalıdır.",
      "vi": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9238518653441791",
      "sw": "0.9346146525405544",
      "tr": "0.8659743490270903",
      "vi": "0.9395003640228696"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]), 5);\n        assert_eq!(longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[6, 6, 2, 3, 1, 4, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "longest_consecutive_sequence",
    "signature": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga en el array de números dado.\n  Una secuencia consecutiva se define como una secuencia de enteros donde cada número sigue al anterior por exactamente uno.\n  Esta función no requiere que el array de entrada esté ordenado.\n\n  Argumentos:\n  - numbers: Una porción de enteros que representa la secuencia.\n\n  Retorna:\n  - La longitud de la secuencia consecutiva más larga encontrada en el array.\n\n  Ejemplo:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) devuelve 4 (porque la secuencia consecutiva más larga es 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) devuelve 5 (porque la secuencia es 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) devuelve 4 (porque la secuencia es 1, 2, 3, 4)",
      "arb": "يجد طول أطول تسلسل متتالي في مصفوفة الأرقام المعطاة.\n  يُعرّف التسلسل المتتالي على أنه تسلسل من الأعداد الصحيحة حيث يتبع كل رقم الرقم السابق بواحد بالضبط.\n  لا تتطلب هذه الدالة أن تكون مصفوفة الإدخال مرتبة.\n\n  الحجج:\n  - numbers: جزء من الأعداد الصحيحة التي تمثل التسلسل.\n\n  يعيد:\n  - طول أطول تسلسل متتالي موجود في المصفوفة.\n\n  مثال:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) يعيد 4 (لأن أطول تسلسل متتالي هو 1، 2، 3، 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) يعيد 5 (لأن التسلسل هو 1، 2، 3، 4، 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) يعيد 4 (لأن التسلسل هو 1، 2، 3، 4)",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa mfululizo katika safu iliyotolewa ya nambari.\n  Mlolongo wa mfululizo unafafanuliwa kama mlolongo wa nambari za mzima ambapo kila nambari inafuata iliyotangulia kwa moja tu.\n  Kazi hii haihitaji safu ya ingizo kupangwa.\n\n  Hoja:\n  - numbers: Sehemu ya nambari za mzima inayoashiria mlolongo.\n\n  Inarejesha:\n  - Urefu wa mlolongo mrefu zaidi wa mfululizo uliopatikana kwenye safu.\n\n  Mfano:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) inarejesha 4 (kwa sababu mlolongo mrefu zaidi wa mfululizo ni 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) inarejesha 5 (kwa sababu mlolongo ni 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) inarejesha 4 (kwa sababu mlolongo ni 1, 2, 3, 4)",
      "tr": "Verilen sayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.  \n  Ardışık bir dizi, her sayının bir öncekini tam olarak bir birim takip ettiği bir tamsayı dizisi olarak tanımlanır.  \n  Bu fonksiyon, giriş dizisinin sıralı olmasını gerektirmez.\n\n  Argümanlar:\n  - numbers: Diziyi temsil eden bir tamsayı dilimi.\n\n  Döndürür:\n  - Dizide bulunan en uzun ardışık dizinin uzunluğu.\n\n  Örnek:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 döndürür (çünkü en uzun ardışık dizi 1, 2, 3, 4'tür)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 döndürür (çünkü dizi 1, 2, 3, 4, 5'tir)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 döndürür (çünkü dizi 1, 2, 3, 4'tür)",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong mảng số đã cho.  \nMột dãy liên tiếp được định nghĩa là một dãy số nguyên mà mỗi số theo sau số trước đó đúng một đơn vị.  \nHàm này không yêu cầu mảng đầu vào phải được sắp xếp.\n\nTham số:  \n- numbers: Một mảng số nguyên đại diện cho dãy số.\n\nTrả về:  \n- Độ dài của dãy số liên tiếp dài nhất tìm thấy trong mảng.\n\nVí dụ:  \n- longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) trả về 4 (bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4)  \n- longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) trả về 5 (bởi vì dãy số là 1, 2, 3, 4, 5)  \n- longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) trả về 4 (bởi vì dãy số là 1, 2, 3, 4)  "
    },
    "docstring_bertscore": {
      "es": "0.9950004733093518",
      "arb": "0.9866425041361658",
      "sw": "0.9956017274727444",
      "tr": "0.9795118720873944",
      "vi": "0.99069694747385"
    }
  },
  {
    "task_id": "Rust/47",
    "prompt": {
      "en": "/*\n  Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "es": "/*\n  Compara el área de un cuadrado con lado de longitud 'a' con el área de un rectángulo con dimensiones 'b' x 'c'.\n  Devuelve una cadena que indica si el cuadrado ('Alice') o el rectángulo ('Bob') tiene un área mayor.\n  \n  Argumentos:\n  - a: Un usize que representa la longitud del lado del cuadrado.\n  - b: Un usize que representa la longitud del rectángulo.\n  - c: Un usize que representa el ancho del rectángulo.\n\n  Devuelve:\n  - Una cadena que es 'Alice' si el área del cuadrado es mayor, o 'Bob' si el área del rectángulo es mayor.\n\n  Ejemplo:\n  - compare_area(5, 4, 6) devuelve \"Alice\"\n  - compare_area(7, 5, 10) devuelve \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "arb": "/*\n  يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأبعاد 'b' x 'c'.\n  يعيد سلسلة نصية تشير إلى ما إذا كان المربع ('Alice') أو المستطيل ('Bob') لديه مساحة أكبر.\n  \n  الوسائط:\n  - a: عدد صحيح غير سالب يمثل طول ضلع المربع.\n  - b: عدد صحيح غير سالب يمثل طول المستطيل.\n  - c: عدد صحيح غير سالب يمثل عرض المستطيل.\n\n  يعيد:\n  - سلسلة نصية إما 'Alice' إذا كانت مساحة المربع أكبر، أو 'Bob' إذا كانت مساحة المستطيل أكبر.\n\n  مثال:\n  - compare_area(5, 4, 6) يعيد \"Alice\"\n  - compare_area(7, 5, 10) يعيد \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "sw": "/*\n  Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye vipimo 'b' x 'c'.\n  Inarudisha kamba inayoonyesha kama mraba ('Alice') au mstatili ('Bob') una eneo kubwa zaidi.\n  \n  Hoja:\n  - a: Usize inayowakilisha urefu wa upande wa mraba.\n  - b: Usize inayowakilisha urefu wa mstatili.\n  - c: Usize inayowakilisha upana wa mstatili.\n\n  Inarudisha:\n  - Kamba ambayo ni 'Alice' ikiwa eneo la mraba ni kubwa zaidi, au 'Bob' ikiwa eneo la mstatili ni kubwa zaidi.\n\n  Mfano:\n  - compare_area(5, 4, 6) inarudisha \"Alice\"\n  - compare_area(7, 5, 10) inarudisha \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "tr": "/*\n  'a' kenar uzunluğuna sahip bir karenin alanını, 'b' x 'c' boyutlarındaki bir dikdörtgenin alanı ile karşılaştırır.\n  Karenin ('Alice') veya dikdörtgenin ('Bob') daha büyük bir alana sahip olup olmadığını belirten bir dize döndürür.\n  \n  Argümanlar:\n  - a: Karenin kenar uzunluğunu temsil eden bir usize.\n  - b: Dikdörtgenin uzunluğunu temsil eden bir usize.\n  - c: Dikdörtgenin genişliğini temsil eden bir usize.\n\n  Döndürür:\n  - Eğer karenin alanı daha büyükse 'Alice', eğer dikdörtgenin alanı daha büyükse 'Bob' olan bir dize.\n\n  Örnek:\n  - compare_area(5, 4, 6) \"Alice\" döndürür\n  - compare_area(7, 5, 10) \"Bob\" döndürür\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "vi": "/*\n  So sánh diện tích của một hình vuông có độ dài cạnh 'a' với diện tích của một hình chữ nhật có kích thước 'b' x 'c'.\n  Trả về một chuỗi cho biết liệu hình vuông ('Alice') hay hình chữ nhật ('Bob') có diện tích lớn hơn.\n  \n  Tham số:\n  - a: Một usize đại diện cho độ dài cạnh của hình vuông.\n  - b: Một usize đại diện cho chiều dài của hình chữ nhật.\n  - c: Một usize đại diện cho chiều rộng của hình chữ nhật.\n\n  Trả về:\n  - Một chuỗi là 'Alice' nếu diện tích của hình vuông lớn hơn, hoặc 'Bob' nếu diện tích của hình chữ nhật lớn hơn.\n\n  Ví dụ:\n  - compare_area(5, 4, 6) trả về \"Alice\"\n  - compare_area(7, 5, 10) trả về \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String "
    },
    "prompt_bertscore": {
      "es": "0.9837466718110582",
      "arb": "0.9536013334029174",
      "sw": "0.9781814457952227",
      "tr": "0.9890191166452483",
      "vi": "0.9778682056843306"
    },
    "canonical_solution": "{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}",
    "instruction": {
      "en": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nRust kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9041177383579819",
      "sw": "0.9431116629804649",
      "tr": "0.8971732229762401",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(compare_area(5, 4, 6), \"Alice\");\n        assert_eq!(compare_area(7, 5, 10), \"Bob\");\n        assert_eq!(compare_area(6, 3, 8), \"Alice\");\n        assert_eq!(compare_area(9, 4, 5), \"Alice\");\n    }\n    \n\n}",
    "entry_point": "compare_area",
    "signature": "fn compare_area(a: usize, b: usize, c: usize) -> String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "es": "Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con dimensiones 'b' x 'c'. Devuelve una cadena que indica si el cuadrado ('Alice') o el rectángulo ('Bob') tiene un área mayor.\n\n  Argumentos:\n  - a: Un usize que representa la longitud del lado del cuadrado.\n  - b: Un usize que representa la longitud del rectángulo.\n  - c: Un usize que representa el ancho del rectángulo.\n\n  Devuelve:\n  - Una cadena que es 'Alice' si el área del cuadrado es mayor, o 'Bob' si el área del rectángulo es mayor.\n\n  Ejemplo:\n  - compare_area(5, 4, 6) devuelve \"Alice\"\n  - compare_area(7, 5, 10) devuelve \"Bob\"",
      "arb": "يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأبعاد 'b' x 'c'.  \nيعيد سلسلة نصية تشير إلى ما إذا كان المربع ('Alice') أو المستطيل ('Bob') له مساحة أكبر.\n\nالحجج:\n- a: عدد صحيح غير سالب يمثل طول ضلع المربع.\n- b: عدد صحيح غير سالب يمثل طول المستطيل.\n- c: عدد صحيح غير سالب يمثل عرض المستطيل.\n\nالقيم المعادة:\n- سلسلة نصية تكون إما 'Alice' إذا كانت مساحة المربع أكبر، أو 'Bob' إذا كانت مساحة المستطيل أكبر.\n\nمثال:\n- compare_area(5, 4, 6) يعيد \"Alice\"\n- compare_area(7, 5, 10) يعيد \"Bob\"",
      "sw": "Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye vipimo 'b' x 'c'. \nInarejesha kamba inayoonyesha ikiwa mraba ('Alice') au mstatili ('Bob') una eneo kubwa zaidi.\n\nHoja:\n- a: Urefu wa upande wa mraba unaowakilishwa na usize.\n- b: Urefu wa mstatili unaowakilishwa na usize.\n- c: Upana wa mstatili unaowakilishwa na usize.\n\nInarejesha:\n- Kamba ambayo ni 'Alice' ikiwa eneo la mraba ni kubwa zaidi, au 'Bob' ikiwa eneo la mstatili ni kubwa zaidi.\n\nMfano:\n- compare_area(5, 4, 6) inarejesha \"Alice\"\n- compare_area(7, 5, 10) inarejesha \"Bob\"",
      "tr": "Kenar uzunluğu 'a' olan bir karenin alanını, boyutları 'b' x 'c' olan bir dikdörtgenin alanı ile karşılaştırır.\n  Karenin ('Alice') veya dikdörtgenin ('Bob') daha büyük bir alana sahip olduğunu belirten bir dize döndürür.\n  \n  Argümanlar:\n  - a: Karenin kenar uzunluğunu temsil eden bir usize.\n  - b: Dikdörtgenin uzunluğunu temsil eden bir usize.\n  - c: Dikdörtgenin genişliğini temsil eden bir usize.\n\n  Döndürülenler:\n  - Karenin alanı daha büyükse 'Alice', dikdörtgenin alanı daha büyükse 'Bob' olan bir dize.\n\n  Örnek:\n  - compare_area(5, 4, 6) \"Alice\" döndürür\n  - compare_area(7, 5, 10) \"Bob\" döndürür",
      "vi": "So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật có kích thước 'b' x 'c'.  \nTrả về một chuỗi cho biết liệu hình vuông ('Alice') hay hình chữ nhật ('Bob') có diện tích lớn hơn.\n\nTham số:  \n- a: Một usize đại diện cho độ dài cạnh của hình vuông.  \n- b: Một usize đại diện cho chiều dài của hình chữ nhật.  \n- c: Một usize đại diện cho chiều rộng của hình chữ nhật.\n\nTrả về:  \n- Một chuỗi là 'Alice' nếu diện tích của hình vuông lớn hơn, hoặc 'Bob' nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:  \n- compare_area(5, 4, 6) Trả về \"Alice\"  \n- compare_area(7, 5, 10) Trả về \"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9843814945088457",
      "arb": "0.9454729809502077",
      "sw": "0.9535588265013759",
      "tr": "0.9857774688267589",
      "vi": "0.9735245565118598"
    }
  },
  {
    "task_id": "Rust/48",
    "prompt": {
      "en": "/*\n  Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "es": "/*\n  Encuentra M enteros positivos cuya suma es igual a N y cuyo producto es maximizado, devolviendo la secuencia lexicográficamente más pequeña de estos enteros.\n\n  Argumentos:\n  - n: La suma que los M enteros deben igualar.\n  - m: El número de enteros a encontrar.\n\n  Devuelve:\n  - Un vector de M enteros cuya suma es N y cuyo producto es maximizado.\n\n  Ejemplo:\n  - max_product_partition(6, 3) devuelve vec![2, 2, 2]\n  - max_product_partition(8, 3) devuelve vec![2, 3, 3]\n  - max_product_partition(10, 2) devuelve vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "arb": "/*\n  يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها يساوي N ويكون حاصل ضربها هو الأكبر، ويعيد التسلسل الأصغر لغوياً لهذه الأعداد.\n\n  الحجج:\n  - n: المجموع الذي يجب أن تساويه الأعداد الصحيحة M.\n  - m: عدد الأعداد الصحيحة المطلوب إيجادها.\n\n  يعيد:\n  - متجه من M من الأعداد الصحيحة التي يكون مجموعها N ويكون حاصل ضربها هو الأكبر.\n\n  مثال:\n  - max_product_partition(6, 3) يعيد vec![2, 2, 2]\n  - max_product_partition(8, 3) يعيد vec![2, 3, 3]\n  - max_product_partition(10, 2) يعيد vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "sw": "/*\n  Inapata nambari M chanya ambazo jumla yake ni sawa na N na ambazo bidhaa yake imewezeshwa, ikirudisha mlolongo mdogo zaidi wa leksikografia wa nambari hizi.\n\n  Hoja:\n  - n: Jumla ambayo nambari M lazima iwe sawa nayo.\n  - m: Idadi ya nambari za kupata.\n\n  Inarudisha:\n  - Vekta ya nambari M ambazo jumla yake ni N na bidhaa yake imewezeshwa.\n\n  Mfano:\n  - max_product_partition(6, 3) inarudisha vec![2, 2, 2]\n  - max_product_partition(8, 3) inarudisha vec![2, 3, 3]\n  - max_product_partition(10, 2) inarudisha vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "tr": "/*\n  Toplamı N olan ve çarpımı maksimize edilmiş M pozitif tam sayıyı bulan, bu tam sayıların sözlük sırasına göre en küçük dizisini döndüren fonksiyon.\n\n  Argümanlar:\n  - n: M tam sayının eşit olması gereken toplam.\n  - m: Bulunacak tam sayıların sayısı.\n\n  Döndürür:\n  - Toplamı N olan ve çarpımı maksimize edilmiş M tam sayısından oluşan bir vektör.\n\n  Örnek:\n  - max_product_partition(6, 3) vec![2, 2, 2] döndürür\n  - max_product_partition(8, 3) vec![2, 3, 3] döndürür\n  - max_product_partition(10, 2) vec![5, 5] döndürür\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "vi": "/*\n  Tìm M số nguyên dương có tổng bằng N và có tích lớn nhất, trả về dãy số nhỏ nhất theo thứ tự từ điển của các số nguyên này.\n\n  Tham số:\n  - n: Tổng mà M số nguyên phải bằng.\n  - m: Số lượng số nguyên cần tìm.\n\n  Trả về:\n  - Một vector gồm M số nguyên có tổng là N và có tích lớn nhất.\n\n  Ví dụ:\n  - max_product_partition(6, 3) trả về vec![2, 2, 2]\n  - max_product_partition(8, 3) trả về vec![2, 3, 3]\n  - max_product_partition(10, 2) trả về vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "es": "0.9914292976887256",
      "arb": "0.9743562219172528",
      "sw": "0.9713382319078088",
      "tr": "0.9636687156352897",
      "vi": "0.9544919920314778"
    },
    "canonical_solution": "{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}",
    "instruction": {
      "en": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9166920346293955",
      "sw": "0.9431116629804649",
      "tr": "0.9366770317868397",
      "vi": "0.9242012561844194"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_product_partition(6, 3), vec![2, 2, 2]);\n        assert_eq!(max_product_partition(8, 3), vec![2, 3, 3]);\n        assert_eq!(max_product_partition(10, 2), vec![5, 5]);\n        assert_eq!(max_product_partition(7, 3), vec![2, 2, 3]);\n    }\n    \n\n}",
    "entry_point": "max_product_partition",
    "signature": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>",
    "docstring": {
      "en": "Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]",
      "es": "Encuentra M enteros positivos cuya suma es igual a N y cuyo producto es maximizado, devolviendo la secuencia lexicográficamente más pequeña de estos enteros.\n\n  Argumentos:\n  - n: La suma a la que deben igualar los M enteros.\n  - m: El número de enteros a encontrar.\n\n  Devuelve:\n  - Un vector de M enteros cuya suma es N y cuyo producto es maximizado.\n\n  Ejemplo:\n  - max_product_partition(6, 3) devuelve vec![2, 2, 2]\n  - max_product_partition(8, 3) devuelve vec![2, 3, 3]\n  - max_product_partition(10, 2) devuelve vec![5, 5]",
      "arb": "يعثر على M من الأعداد الصحيحة الموجبة التي يكون مجموعها يساوي N ويكون حاصل ضربها هو الأقصى، مع إرجاع التسلسل الأصغر لغوياً لهذه الأعداد.\n\nالأوساط:\n- n: المجموع الذي يجب أن تساويه الأعداد الصحيحة M.\n- m: عدد الأعداد الصحيحة المطلوب إيجادها.\n\nالقيم المعادة:\n- متجه من M من الأعداد الصحيحة التي يكون مجموعها N ويكون حاصل ضربها هو الأقصى.\n\nمثال:\n- max_product_partition(6, 3) يعيد vec![2, 2, 2]\n- max_product_partition(8, 3) يعيد vec![2, 3, 3]\n- max_product_partition(10, 2) يعيد vec![5, 5]",
      "sw": "Inapata nambari M chanya ambazo jumla yake ni sawa na N na ambazo bidhaa yake imewezeshwa, ikirudisha mlolongo mdogo zaidi wa leksikografia wa nambari hizi.\n\n  Hoja:\n  - n: Jumla ambayo nambari M lazima ziwe sawa nayo.\n  - m: Idadi ya nambari za kupata.\n\n  Inarejesha:\n  - Vekta ya nambari M ambazo jumla yake ni N na bidhaa yake imewezeshwa.\n\n  Mfano:\n  - max_product_partition(6, 3) inarejesha vec![2, 2, 2]\n  - max_product_partition(8, 3) inarejesha vec![2, 3, 3]\n  - max_product_partition(10, 2) inarejesha vec![5, 5]",
      "tr": "M pozitif tam sayının toplamı N'ye eşit olacak ve çarpımları maksimize edilecek şekilde bulunur, bu tam sayıların sözlük sırasına göre en küçük dizisini döndürür.\n\n  Argümanlar:\n  - n: M tam sayısının eşit olması gereken toplam.\n  - m: Bulunacak tam sayıların sayısı.\n\n  Döndürür:\n  - Toplamı N olan ve çarpımı maksimize edilmiş M tam sayısından oluşan bir vektör.\n\n  Örnek:\n  - max_product_partition(6, 3) vec![2, 2, 2] döndürür\n  - max_product_partition(8, 3) vec![2, 3, 3] döndürür\n  - max_product_partition(10, 2) vec![5, 5] döndürür",
      "vi": "Tìm M số nguyên dương có tổng bằng N và có tích lớn nhất, trả về dãy số nhỏ nhất theo thứ tự từ điển của các số nguyên này.\n\n  Tham số:\n  - n: Tổng mà M số nguyên phải bằng.\n  - m: Số lượng số nguyên cần tìm.\n\n  Trả về:\n  - Một vector gồm M số nguyên có tổng là N và có tích lớn nhất.\n\n  Ví dụ:\n  - max_product_partition(6, 3) trả về vec![2, 2, 2]\n  - max_product_partition(8, 3) trả về vec![2, 3, 3]\n  - max_product_partition(10, 2) trả về vec![5, 5]"
    },
    "docstring_bertscore": {
      "es": "0.9878966563620202",
      "arb": "0.9741685162071748",
      "sw": "0.9841639942416125",
      "tr": "0.9581487773463301",
      "vi": "0.9412375853354007"
    }
  },
  {
    "task_id": "Rust/49",
    "prompt": {
      "en": "/*\n  Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "es": "/*\n  Calcula el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n\n  Argumentos:\n  - title: Una cadena que puede contener letras inglesas mayúsculas y minúsculas, dígitos, espacios y caracteres de nueva línea.\n\n  Retorna:\n  - El conteo de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n\n  Ejemplos:\n  - count_title_chars(\"234\") Devuelve 3\n  - count_title_chars(\"Ca 45\") Devuelve 4\n  - count_title_chars(\"Hello\\nWorld\") Devuelve 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "arb": "/*\n  يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n\n  الوسائط:\n  - title: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف سطر جديد.\n\n  يعيد:\n  - عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n\n  أمثلة:\n  - count_title_chars(\"234\") يعيد 3\n  - count_title_chars(\"Ca 45\") يعيد 4\n  - count_title_chars(\"Hello\\nWorld\") يعيد 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "sw": "/*\n  Inahesabu idadi ya herufi katika mfuatano wa herufi uliotolewa wa kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.\n\n  Hoja:\n  - title: Mfuatano wa herufi ambao unaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n\n  Inarejesha:\n  - Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.\n\n  Mifano:\n  - count_title_chars(\"234\") inarejesha 3\n  - count_title_chars(\"Ca 45\") inarejesha 4\n  - count_title_chars(\"Hello\\nWorld\") inarejesha 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "tr": "/*\n  Verilen bir başlık dizgesindeki karakter sayısını, boşluklar ve yeni satır karakterleri hariç tutarak hesaplar.\n\n  Argümanlar:\n  - title: Büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilen bir dizge.\n\n  Döndürür:\n  - Başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak döndürür.\n\n  Örnekler:\n  - count_title_chars(\"234\") 3 döndürür\n  - count_title_chars(\"Ca 45\") 4 döndürür\n  - count_title_chars(\"Hello\\nWorld\") 10 döndürür\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "vi": "/*\n  Tính số ký tự trong một chuỗi tiêu đề cho trước, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Tham số:\n  - title: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n\n  Trả về:\n  - Số lượng ký tự trong tiêu đề, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  - count_title_chars(\"234\") trả về 3\n  - count_title_chars(\"Ca 45\") trả về 4\n  - count_title_chars(\"Hello\\nWorld\") trả về 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9925438127567123",
      "sw": "0.981570278726059",
      "tr": "0.9883022596000933",
      "vi": "0.9883429788282055"
    },
    "canonical_solution": "{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}",
    "instruction": {
      "en": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة Rust باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9129853930889035",
      "sw": "0.9346146525405544",
      "tr": "0.9121316797112154",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_title_chars(\"234\"), 3);\n        assert_eq!(count_title_chars(\"Ca 45\"), 4);\n        assert_eq!(count_title_chars(\"Hello\\nWorld\"), 10);\n    }\n    \n\n}",
    "entry_point": "count_title_chars",
    "signature": "fn count_title_chars(title: &str) -> usize",
    "docstring": {
      "en": "Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "es": "Calcula el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n\n  Argumentos:\n  - title: Una cadena que puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n\n  Retorna:\n  - El conteo de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n\n  Ejemplos:\n  - count_title_chars(\"234\") retorna 3\n  - count_title_chars(\"Ca 45\") retorna 4\n  - count_title_chars(\"Hello\\nWorld\") retorna 10",
      "arb": "يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n\n  الحجج:\n  - title: سلسلة قد تحتوي على أحرف إنجليزية كبيرة وصغيرة، وأرقام، ومسافات، وأحرف السطر الجديد.\n\n  يعيد:\n  - عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n\n  أمثلة:\n  - count_title_chars(\"234\") يعيد 3\n  - count_title_chars(\"Ca 45\") يعيد 4\n  - count_title_chars(\"Hello\\nWorld\") يعيد 10",
      "sw": "Hesabu idadi ya herufi katika kichwa kilichopewa, ukiondoa nafasi na herufi za kurudi mstari mpya.\n\n  Hoja:\n  - title: Kamba ambayo inaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n\n  Inarejesha:\n  - Idadi ya herufi katika kichwa, ukiondoa nafasi na herufi za kurudi mstari mpya.\n\n  Mifano:\n  - count_title_chars(\"234\") inarejesha 3\n  - count_title_chars(\"Ca 45\") inarejesha 4\n  - count_title_chars(\"Hello\\nWorld\") inarejesha 10",
      "tr": "Verilen bir başlık dizgesindeki karakter sayısını, boşluklar ve yeni satır karakterleri hariç, hesaplar.\n\n  Argümanlar:\n  - title: Büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilen bir dizge.\n\n  Döndürür:\n  - Başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç.\n\n  Örnekler:\n  - count_title_chars(\"234\") 3 döndürür\n  - count_title_chars(\"Ca 45\") 4 döndürür\n  - count_title_chars(\"Hello\\nWorld\") 10 döndürür",
      "vi": "Tính toán số ký tự trong một chuỗi tiêu đề cho trước, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Tham số:\n  - title: Một chuỗi có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n\n  Trả về:\n  - Số lượng ký tự trong tiêu đề, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  - count_title_chars(\"234\") trả về 3\n  - count_title_chars(\"Ca 45\") trả về 4\n  - count_title_chars(\"Hello\\nWorld\") trả về 10"
    },
    "docstring_bertscore": {
      "es": "0.9974912982875294",
      "arb": "0.9906039884555257",
      "sw": "0.9712395126084344",
      "tr": "0.9886981299494959",
      "vi": "0.9829469858970118"
    }
  },
  {
    "task_id": "Rust/50",
    "prompt": {
      "en": "/*\n  Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "es": "/*\n  Cuenta el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n\n  Argumentos:\n  - n: El número de estudiantes inscritos en el Curso A.\n  - m: El número de estudiantes inscritos en el Curso B.\n  - a: Un vector que contiene los IDs de los estudiantes inscritos en el Curso A.\n  - b: Un vector que contiene los IDs de los estudiantes inscritos en el Curso B.\n\n  Retorna:\n  - El número de estudiantes que están inscritos en ambos cursos.\n\n  Ejemplo:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) Devuelve 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) Devuelve 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "arb": "/*\n  يحسب عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n\n  المعطيات:\n  - n: عدد الطلاب المسجلين في الدورة A.\n  - m: عدد الطلاب المسجلين في الدورة B.\n  - a: متجه يحتوي على معرفات الطلاب المسجلين في الدورة A.\n  - b: متجه يحتوي على معرفات الطلاب المسجلين في الدورة B.\n\n  يعيد:\n  - عدد الطلاب الذين سجلوا في كلا الدورتين.\n\n  مثال:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) يعيد 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) يعيد 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "sw": "/*\n  Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n\n  Hoja:\n  - n: Idadi ya wanafunzi waliojiandikisha katika Kozi A.\n  - m: Idadi ya wanafunzi waliojiandikisha katika Kozi B.\n  - a: Vector inayobeba ID za wanafunzi waliojiandikisha katika Kozi A.\n  - b: Vector inayobeba ID za wanafunzi waliojiandikisha katika Kozi B.\n\n  Inarudisha:\n  - Idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\n  Mfano:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) inarudisha 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) inarudisha 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "tr": "/*\n  Hem Kurs A'ya hem de Kurs B'ye kayıtlı olan öğrencilerin sayısını sayar.\n\n  Argümanlar:\n  - n: Kurs A'ya kayıtlı öğrenci sayısı.\n  - m: Kurs B'ye kayıtlı öğrenci sayısı.\n  - a: Kurs A'ya kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n  - b: Kurs B'ye kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n\n  Döndürür:\n  - Her iki kursa da kayıtlı olan öğrencilerin sayısı.\n\n  Örnek:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 döndürür\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 döndürür\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "vi": "/*\n  Đếm số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n\n  Tham số:\n  - n: Số lượng sinh viên đã đăng ký Khóa học A.\n  - m: Số lượng sinh viên đã đăng ký Khóa học B.\n  - a: Một vector chứa ID của sinh viên đã đăng ký Khóa học A.\n  - b: Một vector chứa ID của sinh viên đã đăng ký Khóa học B.\n\n  Trả về:\n  - Số lượng sinh viên đã đăng ký cả hai khóa học.\n\n  Ví dụ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) trả về 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) trả về 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize "
    },
    "prompt_bertscore": {
      "es": "0.9933544233417158",
      "arb": "0.9658355744619992",
      "sw": "0.9745717358806757",
      "tr": "0.9758241004331006",
      "vi": "0.9767437590972922"
    },
    "canonical_solution": "{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}",
    "instruction": {
      "en": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nRust kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9010018235706876",
      "sw": "0.9431116629804649",
      "tr": "0.868483845261085",
      "vi": "0.9242012561844194"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]), 4);\n        assert_eq!(count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]), 0);\n        assert_eq!(count_students_enrolled_in_both(4, 4, vec![1, 3, 5, 7], vec![2, 4, 1, 3]), 2);\n    \n    }\n\n}",
    "entry_point": "count_students_enrolled_in_both",
    "signature": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "es": "Cuenta el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n\n  Argumentos:\n  - n: El número de estudiantes inscritos en el Curso A.\n  - m: El número de estudiantes inscritos en el Curso B.\n  - a: Un vector que contiene los IDs de los estudiantes inscritos en el Curso A.\n  - b: Un vector que contiene los IDs de los estudiantes inscritos en el Curso B.\n\n  Retorna:\n  - El número de estudiantes que están inscritos en ambos cursos.\n\n  Ejemplo:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) Devuelve 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) Devuelve 0",
      "arb": "يحسب عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n\n  الحجج:\n  - n: عدد الطلاب المسجلين في الدورة A.\n  - m: عدد الطلاب المسجلين في الدورة B.\n  - a: متجه يحتوي على معرفات الطلاب المسجلين في الدورة A.\n  - b: متجه يحتوي على معرفات الطلاب المسجلين في الدورة B.\n\n  يعيد:\n  - عدد الطلاب الذين سجلوا في كلتا الدورتين.\n\n  مثال:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) يعيد 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) يعيد 0",
      "sw": "Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n\n  Hoja:\n  - n: Idadi ya wanafunzi waliojiandikisha katika Kozi A.\n  - m: Idadi ya wanafunzi waliojiandikisha katika Kozi B.\n  - a: Vekta inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n  - b: Vekta inayobeba vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n\n  Inarejesha:\n  - Idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\n  Mfano:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) inarejesha 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) inarejesha 0",
      "tr": "Her iki Kurs A ve Kurs B'ye de kayıtlı olan öğrencilerin sayısını sayar.\n\n  Argümanlar:\n  - n: Kurs A'ya kayıtlı öğrenci sayısı.\n  - m: Kurs B'ye kayıtlı öğrenci sayısı.\n  - a: Kurs A'ya kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n  - b: Kurs B'ye kayıtlı öğrencilerin kimliklerini içeren bir vektör.\n\n  Döndürür:\n  - Her iki kursa da kayıtlı olan öğrencilerin sayısı.\n\n  Örnek:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 döndürür\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 döndürür",
      "vi": "Đếm số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n\n  Tham số:\n  - n: Số lượng sinh viên đã đăng ký Khóa học A.\n  - m: Số lượng sinh viên đã đăng ký Khóa học B.\n  - a: Một vector chứa ID của sinh viên đã đăng ký Khóa học A.\n  - b: Một vector chứa ID của sinh viên đã đăng ký Khóa học B.\n\n  Trả về:\n  - Số lượng sinh viên đã đăng ký cả hai khóa học.\n\n  Ví dụ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) trả về 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.991414599040529",
      "arb": "0.9665045615853247",
      "sw": "0.9726630965493115",
      "tr": "0.980955716327137",
      "vi": "0.9696552366893001"
    }
  },
  {
    "task_id": "Rust/51",
    "prompt": {
      "en": "/*\n  Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "es": "/*\n  Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\n  Argumentos:\n  - delivered: El número de paquetes entregados exitosamente (0 <= delivered <= 100).\n  - failed: El número de entregas fallidas (0 <= failed <= 100).\n\n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\n  Ejemplos:\n  - calculate_droid_earnings(5, 2) Devuelve 730.\n  - calculate_droid_earnings(0, 10) Devuelve -100.\n  - calculate_droid_earnings(10, 5) Devuelve 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "arb": "/*\n  يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة.\n  يكسب Deliv-e-droid 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة.\n  بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\n  المعطيات:\n  - delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n  - failed: عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n\n  يعيد:\n  - إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق الأرباح.\n\n  أمثلة:\n  - calculate_droid_earnings(5, 2) يعيد 730.\n  - calculate_droid_earnings(0, 10) يعيد -100.\n  - calculate_droid_earnings(10, 5) يعيد 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "sw": "/*\n  Inahesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa.\n  Deliv-e-droid inapata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na inapoteza vitengo 10 kwa kila uwasilishaji ulioshindwa.\n  Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\n  Hoja:\n  - delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n  - failed: Idadi ya uwasilishaji ulioshindwa (0 <= failed <= 100).\n\n  Inarudisha:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n\n  Mifano:\n  - calculate_droid_earnings(5, 2) inarudisha 730.\n  - calculate_droid_earnings(0, 10) inarudisha -100.\n  - calculate_droid_earnings(10, 5) inarudisha 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "tr": "/*\n  Deliv-e-droid'un başarılı ve başarısız teslimat sayısına göre toplam kazancını hesaplar.\n  Deliv-e-droid her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ek olarak, başarılı teslimat sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n\n  Argümanlar:\n  - delivered: Başarıyla teslim edilen paketlerin sayısı (0 <= delivered <= 100).\n  - failed: Başarısız teslimatların sayısı (0 <= failed <= 100).\n\n  Döndürür:\n  - Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\n  Örnekler:\n  - calculate_droid_earnings(5, 2) 730 döndürür.\n  - calculate_droid_earnings(0, 10) -100 döndürür.\n  - calculate_droid_earnings(10, 5) 950 döndürür.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "vi": "/*\n  Tính toán tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại.\n  Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại.\n  Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\n  Tham số:\n  - delivered: Số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n  - failed: Số lượng giao hàng thất bại (0 <= failed <= 100).\n\n  Trả về:\n  - Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu lỗ vượt quá lợi nhuận.\n\n  Ví dụ:\n  - calculate_droid_earnings(5, 2) trả về 730.\n  - calculate_droid_earnings(0, 10) trả về -100.\n  - calculate_droid_earnings(10, 5) trả về 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 "
    },
    "prompt_bertscore": {
      "es": "0.9854699889969168",
      "arb": "0.9729729599437259",
      "sw": "0.9743494684842976",
      "tr": "0.9797528107395898",
      "vi": "0.9684491530156563"
    },
    "canonical_solution": "{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}",
    "instruction": {
      "en": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando un máximo de 500 caracteres.",
      "arb": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للشيفرة البرمجية بلغة Rust باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nRust kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.914758963761164",
      "sw": "0.9431116629804649",
      "tr": "0.9124240636320988",
      "vi": "0.9426885802688606"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_droid_earnings(5, 2), 730);\n        assert_eq!(calculate_droid_earnings(0, 10), -100);\n        assert_eq!(calculate_droid_earnings(10, 5), 950);\n        assert_eq!(calculate_droid_earnings(3, 3), 120);\n    }\n    \n\n}",
    "entry_point": "calculate_droid_earnings",
    "signature": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.",
      "es": "Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\n  Argumentos:\n  - delivered: El número de paquetes entregados exitosamente (0 <= delivered <= 100).\n  - failed: El número de entregas fallidas (0 <= failed <= 100).\n\n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\n  Ejemplos:\n  - calculate_droid_earnings(5, 2) Devuelve 730.\n  - calculate_droid_earnings(0, 10) Devuelve -100.\n  - calculate_droid_earnings(10, 5) Devuelve 950.",
      "arb": "يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد التسليمات الناجحة والفاشلة. يكسب Deliv-e-droid 50 وحدة من المال لكل تسليم ناجح ويفقد 10 وحدات لكل تسليم فاشل. بالإضافة إلى ذلك، إذا كان عدد التسليمات الناجحة أكبر من عدد التسليمات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\n  الحجج:\n  - delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n  - failed: عدد التسليمات الفاشلة (0 <= failed <= 100).\n\n  يعيد:\n  - إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n\n  أمثلة:\n  - calculate_droid_earnings(5, 2) يعيد 730.\n  - calculate_droid_earnings(0, 10) يعيد -100.\n  - calculate_droid_earnings(10, 5) يعيد 950.",
      "sw": "Hesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa.\n  Deliv-e-droid hupata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na hupoteza vitengo 10 kwa kila uwasilishaji ulioshindwa.\n  Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ulioshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\n  Hoja:\n  - delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n  - failed: Idadi ya uwasilishaji ulioshindwa (0 <= failed <= 100).\n\n  Inarudi:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara ni kubwa kuliko faida.\n\n  Mifano:\n  - calculate_droid_earnings(5, 2) inarudi 730.\n  - calculate_droid_earnings(0, 10) inarudi -100.\n  - calculate_droid_earnings(10, 5) inarudi 950.",
      "tr": "Deliv-e-droid'un başarılı ve başarısız teslimat sayısına göre toplam kazancını hesaplar.\n  Deliv-e-droid her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n  Ek olarak, eğer başarılı teslimat sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n\n  Argümanlar:\n  - delivered: Başarıyla teslim edilen paket sayısı (0 <= delivered <= 100).\n  - failed: Başarısız teslimat sayısı (0 <= failed <= 100).\n\n  Döndürür:\n  - Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n\n  Örnekler:\n  - calculate_droid_earnings(5, 2) 730 döner.\n  - calculate_droid_earnings(0, 10) -100 döner.\n  - calculate_droid_earnings(10, 5) 950 döner.",
      "vi": "Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại. Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\n  Tham số:\n  - delivered: Số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n  - failed: Số lượng giao hàng thất bại (0 <= failed <= 100).\n\n  Trả về:\n  - Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất lớn hơn lợi nhuận.\n\n  Ví dụ:\n  - calculate_droid_earnings(5, 2) trả về 730.\n  - calculate_droid_earnings(0, 10) trả về -100.\n  - calculate_droid_earnings(10, 5) trả về 950."
    },
    "docstring_bertscore": {
      "es": "0.9914157908228153",
      "arb": "0.9883763487322194",
      "sw": "0.9820851286737013",
      "tr": "0.9778048425927806",
      "vi": "0.9739077145168761"
    }
  },
  {
    "task_id": "Rust/52",
    "prompt": {
      "en": "/*\n  Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "es": "/*\n  Encuentra los números de ID faltantes y duplicados de una serie de secuencias de ID.\n  Cada secuencia de IDs se representa como un vector dentro de un vector más grande, simulando el formato de entrada descrito.\n  Se asume que los IDs son parte de un rango continuo pero con un ID faltante y un ID duplicado.\n  La función identifica y devuelve tanto el ID faltante (que ha sido omitido) como el ID duplicado (que aparece más de una vez).\n\n  Argumentos:\n  - data: Un vector de vectores, donde cada vector interno contiene una secuencia de números de ID.\n\n  Devuelve:\n  - Una tupla que contiene dos valores usize: el primero es el ID faltante, y el segundo es el ID duplicado.\n\n  Ejemplo:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) Devuelve (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "arb": "/*\n  يعثر على أرقام الهوية المفقودة والمكررة من سلسلة من تسلسلات الهوية.\n  يتم تمثيل كل تسلسل من أرقام الهوية كمتجه داخل متجه أكبر، مما يحاكي تنسيق الإدخال الموصوف.\n  يُفترض أن أرقام الهوية جزء من نطاق مستمر ولكن مع هوية مفقودة واحدة وهوية مكررة واحدة.\n  تحدد الدالة وتعيد كل من الهوية المفقودة (التي تم تخطيها) والهوية المكررة (التي تظهر أكثر من مرة).\n\n  الوسائط:\n  - data: متجه من المتجهات، حيث يحتوي كل متجه داخلي على تسلسل من أرقام الهوية.\n\n  يعيد:\n  - زوج يحتوي على قيمتين من نوع usize: الأولى هي الهوية المفقودة، والثانية هي الهوية المكررة.\n\n  مثال:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) يعيد (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "sw": "/*\n  Inapata namba za ID zilizopotea na zilizorudiwa kutoka kwa mfululizo wa misururu ya ID.\n  Kila mfululizo wa ID unawakilishwa kama vector ndani ya vector kubwa zaidi, ikisimulia muundo wa pembejeo ulivyoelezwa.\n  ID zinadhaniwa kuwa sehemu ya safu endelevu lakini zikiwa na ID moja iliyopotea na ID moja iliyorudiwa.\n  Kazi inatambua na kurudisha zote mbili, ID iliyopotea (ambayo imeachwa) na ID iliyorudiwa (inayoonekana zaidi ya mara moja).\n\n  Hoja:\n  - data: Vector ya vectors, ambapo kila vector ya ndani ina mfululizo wa namba za ID.\n\n  Inarudisha:\n  - Jozi inayojumuisha thamani mbili za usize: ya kwanza ni ID iliyopotea, na ya pili ni ID iliyorudiwa.\n\n  Mfano:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) inarudisha (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "tr": "/*\n  Bir dizi kimlik numarası dizisinden eksik ve yinelenen kimlik numaralarını bulur.\n  Her kimlik dizisi, açıklanan giriş formatını simüle eden daha büyük bir vektör içinde bir vektör olarak temsil edilir.\n  Kimliklerin sürekli bir aralığın parçası olduğu varsayılır, ancak bir eksik kimlik ve bir yinelenen kimlik vardır.\n  Fonksiyon, hem atlanan eksik kimliği hem de birden fazla kez görünen yinelenen kimliği tanımlar ve döndürür.\n\n  Argümanlar:\n  - data: Her bir iç vektörün bir kimlik numarası dizisi içerdiği bir vektörler vektörü.\n\n  Döndürür:\n  - İki usize değeri içeren bir demet: ilki eksik kimlik, ikincisi ise yinelenen kimliktir.\n\n  Örnek:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) döndürür\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "vi": "/*\n  Tìm số ID bị thiếu và số ID trùng lặp từ một loạt các chuỗi ID.\n  Mỗi chuỗi ID được biểu diễn dưới dạng một vector trong một vector lớn hơn, mô phỏng định dạng đầu vào được mô tả.\n  Các ID được giả định là một phần của một dãy liên tục nhưng có một ID bị thiếu và một ID trùng lặp.\n  Hàm xác định và trả về cả ID bị thiếu (đã bị bỏ qua) và ID trùng lặp (xuất hiện nhiều hơn một lần).\n\n  Tham số:\n  - data: Một vector của các vector, trong đó mỗi vector con chứa một chuỗi các số ID.\n\n  Trả về:\n  - Một bộ giá trị chứa hai giá trị usize: giá trị đầu tiên là ID bị thiếu, và giá trị thứ hai là ID trùng lặp.\n\n  Ví dụ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) trả về (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) "
    },
    "prompt_bertscore": {
      "es": "0.9910093930632179",
      "arb": "0.9800060644754092",
      "sw": "0.9645774496285242",
      "tr": "0.9601253482680082",
      "vi": "0.9646547168467469"
    },
    "canonical_solution": "{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}",
    "instruction": {
      "en": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nRust kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9104286228242223",
      "sw": "0.9153697521828462",
      "tr": "0.868483845261085",
      "vi": "0.9085122369079978"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]), (7, 9));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 2, 4, 7], vec![5, 3, 3]]), (6, 3));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 1, 3, 4, 5]]), (2, 1)); // Edge case with minimal input\n    \n    }\n    \n\n}",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)",
    "docstring": {
      "en": "Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "es": "Encuentra los números de ID faltantes y duplicados de una serie de secuencias de ID.  \nCada secuencia de IDs se representa como un vector dentro de un vector más grande, simulando el formato de entrada descrito.  \nSe asume que los IDs son parte de un rango continuo pero con un ID faltante y un ID duplicado.  \nLa función identifica y devuelve tanto el ID faltante (que ha sido omitido) como el ID duplicado (que aparece más de una vez).\n\nArgumentos:\n- data: Un vector de vectores, donde cada vector interno contiene una secuencia de números de ID.\n\nDevuelve:\n- Una tupla que contiene dos valores usize: el primero es el ID faltante, y el segundo es el ID duplicado.\n\nEjemplo:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) devuelve (7, 9)",
      "arb": "يعثر على أرقام الهوية المفقودة والمكررة من سلسلة من تسلسلات الهوية.\n  يتم تمثيل كل سلسلة من معرفات الهوية كمتجه داخل متجه أكبر، مما يحاكي تنسيق الإدخال الموصوف.\n  يُفترض أن تكون معرفات الهوية جزءًا من نطاق متواصل ولكن مع معرف مفقود واحد ومعرف مكرر واحد.\n  تحدد الدالة وتعيد كل من المعرف المفقود (الذي تم تخطيه) والمعرف المكرر (الذي يظهر أكثر من مرة).\n\n  الحجج:\n  - data: متجه من المتجهات، حيث يحتوي كل متجه داخلي على سلسلة من أرقام الهوية.\n\n  العوائد:\n  - زوج يحتوي على قيمتين من نوع usize: الأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n\n  مثال:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) يعيد (7, 9)",
      "sw": "Inapata nambari za ID zilizopotea na zilizorudiwa kutoka kwa mfululizo wa misururu ya ID.\n  Kila mfululizo wa ID unawakilishwa kama vekta ndani ya vekta kubwa zaidi, ikifananisha muundo wa pembejeo ulioelezewa.\n  ID zinadhaniwa kuwa sehemu ya safu endelevu lakini zikiwa na ID moja iliyopotea na ID moja iliyorudiwa.\n  Kazi hii inatambua na kurudisha ID zote mbili zilizopotea (ambayo imeachwa) na ID iliyorudiwa (ambayo inaonekana zaidi ya mara moja).\n\n  Hoja:\n  - data: Vekta ya vekta, ambapo kila vekta ya ndani ina mfululizo wa nambari za ID.\n\n  Inarudisha:\n  - Jozi inayojumuisha thamani mbili za usize: ya kwanza ni ID iliyopotea, na ya pili ni ID iliyorudiwa.\n\n  Mfano:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) inarudisha (7, 9)",
      "tr": "Eksik ve yinelenen kimlik numaralarını bir dizi kimlik dizisinden bulur.\n  Her kimlik dizisi, açıklanan giriş formatını simüle ederek daha büyük bir vektör içinde bir vektör olarak temsil edilir.\n  Kimliklerin sürekli bir aralığın parçası olduğu varsayılır, ancak bir eksik kimlik ve bir yinelenen kimlik vardır.\n  Fonksiyon, hem eksik kimliği (atlanan) hem de yinelenen kimliği (birden fazla kez görünen) tanımlar ve döndürür.\n\n  Argümanlar:\n  - data: Her bir iç vektörün bir dizi kimlik numarası içerdiği bir vektörler vektörü.\n\n  Döndürür:\n  - İki usize değeri içeren bir demet: birincisi eksik kimlik, ikincisi yinelenen kimliktir.\n\n  Örnek:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) döndürür.",
      "vi": "Tìm số ID bị thiếu và số ID trùng lặp từ một loạt các chuỗi ID.  \nMỗi chuỗi ID được biểu diễn dưới dạng một vector trong một vector lớn hơn, mô phỏng định dạng đầu vào đã mô tả.  \nCác ID được giả định là một phần của một dải liên tục nhưng có một ID bị thiếu và một ID trùng lặp.  \nHàm xác định và trả về cả ID bị thiếu (đã bị bỏ qua) và ID trùng lặp (xuất hiện nhiều hơn một lần).\n\nCác đối số:\n- data: Một vector của các vector, trong đó mỗi vector bên trong chứa một chuỗi số ID.\n\nTrả về:\n- Một bộ giá trị chứa hai giá trị usize: giá trị đầu tiên là ID bị thiếu, và giá trị thứ hai là ID trùng lặp.\n\nVí dụ:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) trả về (7, 9)"
    },
    "docstring_bertscore": {
      "es": "0.9886443011162355",
      "arb": "0.9789322686355346",
      "sw": "0.9567087070838272",
      "tr": "0.9512330633698384",
      "vi": "0.9700381960639354"
    }
  },
  {
    "task_id": "Rust/53",
    "prompt": {
      "en": "/*\n  Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "es": "/*\n  Cuenta el número de caracteres dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n  \n  Argumentos:\n  - s: Una cadena de exactamente 8 caracteres que puede incluir dígitos, letras minúsculas y letras mayúsculas.\n\n  Devuelve:\n  - Una tupla que contiene tres valores usize: el conteo de caracteres dígitos, el conteo de letras minúsculas y el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - count_chars_types(\"yLOI2022\") devuelve (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") devuelve (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") devuelve (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "arb": "/*\n  يحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n  الوسائط:\n  - s: سلسلة تحتوي على 8 أحرف بالضبط قد تشمل أرقامًا، أحرفًا صغيرة، وأحرفًا كبيرة.\n\n  يعيد:\n  - زوج يحتوي على ثلاثة قيم من نوع usize: عدد الأحرف الرقمية، عدد الأحرف الصغيرة، وعدد الأحرف الكبيرة في السلسلة.\n\n  أمثلة:\n  - count_chars_types(\"yLOI2022\") يعيد (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") يعيد (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") يعيد (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "sw": "/*\n  Inahesabu idadi ya herufi za nambari, herufi ndogo, na herufi kubwa katika kamba iliyotolewa ya urefu wa 8.\n  \n  Hoja:\n  - s: Kamba ya herufi nane kamili ambayo inaweza kujumuisha nambari, herufi ndogo, na herufi kubwa.\n\n  Inarejesha:\n  - Jozi inayo na thamani tatu za usize: idadi ya herufi za nambari, idadi ya herufi ndogo, na idadi ya herufi kubwa katika kamba.\n\n  Mifano:\n  - count_chars_types(\"yLOI2022\") inarejesha (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") inarejesha (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") inarejesha (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "tr": "/*\n  Verilen uzunluğu 8 olan bir stringdeki rakam karakterlerinin, küçük harflerin ve büyük harflerin sayısını sayar.\n  \n  Argümanlar:\n  - s: Rakamlar, küçük harfler ve büyük harfler içerebilen tam olarak 8 karakterlik bir string.\n\n  Döndürür:\n  - Bir tuple döndürür: stringdeki rakam karakterlerinin sayısını, küçük harflerin sayısını ve büyük harflerin sayısını içeren üç usize değeri.\n\n  Örnekler:\n  - count_chars_types(\"yLOI2022\") (4, 1, 3) döndürür\n  - count_chars_types(\"IAKIOIOI\") (0, 0, 8) döndürür\n  - count_chars_types(\"1n2s0e1s\") (4, 4, 0) döndürür\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "vi": "/*\n  Đếm số lượng ký tự chữ số, chữ cái thường và chữ cái hoa trong một chuỗi có độ dài 8.\n\n  Tham số:\n  - s: Một chuỗi gồm chính xác 8 ký tự có thể bao gồm chữ số, chữ cái thường và chữ cái hoa.\n\n  Trả về:\n  - Một bộ ba giá trị usize: số lượng ký tự chữ số, số lượng chữ cái thường và số lượng chữ cái hoa trong chuỗi.\n\n  Ví dụ:\n  - count_chars_types(\"yLOI2022\") trả về (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") trả về (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") trả về (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9751348530109096",
      "sw": "0.9813980661857017",
      "tr": "0.9679646935163122",
      "vi": "0.9700376001727923"
    },
    "canonical_solution": "{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}",
    "instruction": {
      "en": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "es": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Rust en español utilizando como máximo 500 caracteres.",
      "arb": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة Rust باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Rust kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nRust kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Rust bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9674426928749525",
      "arb": "0.9003894461059571",
      "sw": "0.9431116629804649",
      "tr": "0.8617613986453403",
      "vi": "0.9035627650733704"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_chars_types(\"yLOI2022\"), (4, 1, 3));\n        assert_eq!(count_chars_types(\"IAKIOIOI\"), (0, 0, 8));\n        assert_eq!(count_chars_types(\"1n2s0e1s\"), (4, 4, 0));\n    }\n    \n\n}",
    "entry_point": "count_chars_types",
    "signature": "fn count_chars_types(s: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "es": "Cuenta el número de caracteres numéricos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n\n  Argumentos:\n  - s: Una cadena de exactamente 8 caracteres que puede incluir dígitos, letras minúsculas y letras mayúsculas.\n\n  Retorna:\n  - Una tupla que contiene tres valores usize: el conteo de caracteres numéricos, el conteo de letras minúsculas y el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - count_chars_types(\"yLOI2022\") retorna (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") retorna (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") retorna (4, 4, 0)",
      "arb": "يحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n  الحجج:\n  - s: سلسلة تحتوي على 8 أحرف بالضبط قد تشمل أرقامًا، أحرفًا صغيرة، وأحرفًا كبيرة.\n\n  الإرجاع:\n  - زوج يحتوي على ثلاث قيم من نوع usize: عدد الأحرف الرقمية، عدد الأحرف الصغيرة، وعدد الأحرف الكبيرة في السلسلة.\n\n  أمثلة:\n  - count_chars_types(\"yLOI2022\") يعيد (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") يعيد (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") يعيد (4, 4, 0)",
      "sw": "Hesabu idadi ya herufi za tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa ya urefu wa 8.\n\n  Hoja:\n  - s: Kamba yenye herufi 8 kamili ambayo inaweza kujumuisha tarakimu, herufi ndogo, na herufi kubwa.\n\n  Inarejesha:\n  - Jozi inayojumuisha thamani tatu za usize: idadi ya herufi za tarakimu, idadi ya herufi ndogo, na idadi ya herufi kubwa katika kamba.\n\n  Mifano:\n  - count_chars_types(\"yLOI2022\") inarejesha (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") inarejesha (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") inarejesha (4, 4, 0)",
      "tr": "Verilen 8 karakter uzunluğundaki bir dizgede rakam karakterlerinin, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  Argümanlar:\n  - s: Tam olarak 8 karakterden oluşan, rakamlar, küçük harfler ve büyük harfler içerebilen bir dizge.\n\n  Döndürür:\n  - Bir üçlü döndürür, üç adet usize değeri içerir: dizgedeki rakam karakterlerinin sayısı, küçük harflerin sayısı ve büyük harflerin sayısı.\n\n  Örnekler:\n  - count_chars_types(\"yLOI2022\") döndürür (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") döndürür (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") döndürür (4, 4, 0)",
      "vi": "Đếm số lượng ký tự chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi có độ dài 8.\n\nTham số:\n- s: Một chuỗi có chính xác 8 ký tự có thể bao gồm chữ số, chữ cái thường, và chữ cái hoa.\n\nTrả về:\n- Một bộ giá trị chứa ba giá trị usize: số lượng ký tự chữ số, số lượng chữ cái thường, và số lượng chữ cái hoa trong chuỗi.\n\nVí dụ:\n- count_chars_types(\"yLOI2022\") trả về (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") trả về (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") trả về (4, 4, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9925227579363227",
      "arb": "0.9665051574764678",
      "sw": "0.9735863305603616",
      "tr": "0.9655970193743764",
      "vi": "0.9785222955290785"
    }
  }
]