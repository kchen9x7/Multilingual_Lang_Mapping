[
  {
    "task_id": "Go/1",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular el área de un triángulo dados sus tres lados.\nParámetros:\n- a (float64): Longitud del lado 'a'.\n- b (float64): Longitud del lado 'b'.\n- c (float64): Longitud del lado 'c'.\n\nDevuelve:\n- float64: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve -1.\n\nEjemplos:\n\tcalculateTriangleArea(3, 5, 4)  // Devuelve 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب مساحة المثلث المعطى أطوال أضلاعه الثلاثة.\nالمعطيات:\n- a (float64): طول الضلع 'a'.\n- b (float64): طول الضلع 'b'.\n- c (float64): طول الضلع 'c'.\n\nالقيم المعادة:\n- float64: إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين.\nوإلا، أعد -1.\n\nأمثلة:\n\tcalculateTriangleArea(3, 5, 4)  // يعيد 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\nVigezo:\n- a (float64): Urefu wa upande 'a'.\n- b (float64): Urefu wa upande 'b'.\n- c (float64): Urefu wa upande 'c'.\n\nRudisha:\n- float64: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha -1.\n\nMifano:\n\tcalculateTriangleArea(3, 5, 4)  // Inarudisha 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\nParametreler:\n- a (float64): 'a' kenarının uzunluğu.\n- b (float64): 'b' kenarının uzunluğu.\n- c (float64): 'c' kenarının uzunluğu.\n\nDöndürür:\n- float64: Sağlanan kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, -1 döndürün.\n\nÖrnekler:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 döndürür\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính diện tích của một tam giác khi biết ba cạnh của nó.\nTham số:\n- a (float64): Độ dài cạnh 'a'.\n- b (float64): Độ dài cạnh 'b'.\n- c (float64): Độ dài cạnh 'c'.\n\nTrả về:\n- float64: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNgược lại, trả về -1.\n\nVí dụ:\n\tcalculateTriangleArea(3, 5, 4)  // Trả về 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {"
    },
    "prompt_bertscore": {
      "es": "0.9844051315241888",
      "arb": "0.9672708775953573",
      "sw": "0.9972867089950634",
      "tr": "0.9992789717168433",
      "vi": "0.9988115944302682"
    },
    "canonical_solution": "if a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}",
    "instruction": {
      "es": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9150640600264335",
      "tr": "0.8700927513474676",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestCalculateTriangleArea(t *testing.T) {\n\t// Using a small delta for floating point comparison\n\tconst delta = 1e-6\n\n\tassert := assert.New(t)\n\n\t// Triangle with sides 3, 5, 4 should return area 6.00\n\tassert.InDelta(6.00, calculateTriangleArea(3, 5, 4), delta)\n\n\t// Not a triangle with sides 1, 1, 4 should return -1\n\tassert.Equal(-1.0, calculateTriangleArea(1, 1, 4))\n\n\t// Triangle with sides 7, 24, 25 should return area 84.00\n\tassert.InDelta(84.00, calculateTriangleArea(7, 24, 25), delta)\n\n\t// Triangle with sides 10.5, 6.2, 7.3 should return close to calculated area\n\tassert.InDelta(22.15, calculateTriangleArea(10.5, 6.2, 7.3), 1e-2) // Looser delta for specific precision\n}",
    "entry_point": "calculateTriangleArea",
    "signature": "func calculateTriangleArea(a, b, c float64) float64",
    "docstring": {
      "es": "Calcular el área de un triángulo dados sus tres lados.\nParámetros:\n- a (float64): Longitud del lado 'a'.\n- b (float64): Longitud del lado 'b'.\n- c (float64): Longitud del lado 'c'.\n\nDevuelve:\n- float64: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve -1.\n\nEjemplos:\n\tcalculateTriangleArea(3, 5, 4)  // Devuelve 6.00",
      "arb": "احسب مساحة المثلث المعطى أضلاعه الثلاثة.\nالمعلمات:\n- a (float64): طول الضلع 'a'.\n- b (float64): طول الضلع 'b'.\n- c (float64): طول الضلع 'c'.\n\nالقيم المعادة:\n- float64: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقتين عشريتين.\nبخلاف ذلك، يتم إرجاع -1.\n\nأمثلة:\n\tcalculateTriangleArea(3, 5, 4)  // يعيد 6.00",
      "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\nVigezo:\n- a (float64): Urefu wa upande 'a'.\n- b (float64): Urefu wa upande 'b'.\n- c (float64): Urefu wa upande 'c'.\n\nRudisha:\n- float64: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha -1.\n\nMifano:\n\tcalculateTriangleArea(3, 5, 4)  // Inarudisha 6.00",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\nParametreler:\n- a (float64): 'a' kenarının uzunluğu.\n- b (float64): 'b' kenarının uzunluğu.\n- c (float64): 'c' kenarının uzunluğu.\n\nDöndürülen:\n- float64: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, -1 döndürün.\n\nÖrnekler:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 döndürür",
      "vi": "Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.  \nTham số:  \n- a (float64): Độ dài cạnh 'a'.  \n- b (float64): Độ dài cạnh 'b'.  \n- c (float64): Độ dài cạnh 'c'.  \n\nTrả về:  \n- float64: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.  \nNếu không, trả về -1.  \n\nVí dụ:  \n\tcalculateTriangleArea(3, 5, 4)  // Trả về 6.00  "
    },
    "docstring_bertscore": {
      "es": "0.9897665627690826",
      "arb": "0.9714862115416797",
      "sw": "0.9914283045368204",
      "tr": "0.9958367072135087",
      "vi": "0.9773297187213451"
    }
  },
  {
    "task_id": "Go/2",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular el valor de la función para una entrada dada.\nParámetros:\n- x (int): Valor de entrada para la función.\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "arb": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب قيمة الدالة لإدخال معين.\nالمعلمات:\n- x (int): قيمة الإدخال للدالة.\nالإرجاع:\n- string: إذا لم يكن x في النطاق المحدد، يرجع \"غير معرف\".\nوإلا، يرجع قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "sw": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\nInarudisha:\n- string: Ikiwa x haimo kwenye kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "tr": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBelirli bir giriş için fonksiyonun değerini hesapla.\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\nDöndürür:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "vi": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính giá trị của hàm cho một đầu vào cho trước.\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {"
    },
    "prompt_bertscore": {
      "es": "0.9793052964911181",
      "arb": "0.9816801213267712",
      "sw": "0.9837846102138359",
      "tr": "0.9876978273506042",
      "vi": "0.9927712445429974"
    },
    "canonical_solution": "if 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}",
    "instruction": {
      "es": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nGo kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9013430705653055",
      "sw": "0.9338646242217667",
      "tr": "0.8841142685751014",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestCalculateFunctionValue(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Not define\", calculateFunctionValue(40)) // the provided test case\n\n\t// Additional test cases based on provided function definitions\n\tassert.Equal(\"Not define\", calculateFunctionValue(40))\n\tassert.Equal(\"-0.14550\", calculateFunctionValue(5))\n\tassert.Equal(\"0.76266\", calculateFunctionValue(15))\n\tassert.Equal(\"0.31314\", calculateFunctionValue(25))\n\tassert.Equal(\"Not define\", calculateFunctionValue(-1))\n}",
    "entry_point": "calculateFunctionValue",
    "signature": "func calculateFunctionValue(x int) string",
    "docstring": {
      "es": "Calcular el valor de la función para una entrada dada.\nParámetros:\n- x (int): Valor de entrada para la función.\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de Funciones:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "arb": "حساب قيمة الدالة لإدخال معين.\nالمعلمات:\n- x (int): قيمة الإدخال للدالة.\nالقيم المعادة:\n- string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "sw": "Hesabu thamani ya kazi kwa ingizo lililopewa.\nVigezo:\n- x (int): Thamani ya ingizo kwa kazi.\nInarejesha:\n- string: Ikiwa x haimo katika eneo lililobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "tr": "Fonksiyonun değerini verilen bir girdi için hesaplayın.\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\nDöndürür:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "vi": "Tính giá trị của hàm cho một đầu vào cho trước.\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Không xác định\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\""
    },
    "docstring_bertscore": {
      "es": "0.9774916024818885",
      "arb": "0.9751475653552958",
      "sw": "0.9642193190515184",
      "tr": "0.9923723947378793",
      "vi": "0.9881707662878483"
    }
  },
  {
    "task_id": "Go/3",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEncontrar el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nLa función devuelve dos valores: el entero máximo y mínimo.\n\nEjemplo de uso:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nابحث عن الحد الأقصى والأدنى من ثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nتُعيد الدالة قيمتين: العدد الصحيح الأكبر والعدد الصحيح الأصغر.\n\nمثال على الاستخدام:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPata kubwa na ndogo ya nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nKazi inarejesha maadili mawili: nambari kubwa na ndogo.\n\nMfano wa matumizi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç farklı tamsayının maksimum ve minimumunu bulun.\n\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürülenler:\nFonksiyon iki değer döndürür: maksimum ve minimum tamsayı.\n\nÖrnek kullanım:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nHàm trả về hai giá trị: số nguyên lớn nhất và nhỏ nhất.\n\nVí dụ sử dụng:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {"
    },
    "prompt_bertscore": {
      "es": "0.993771944402651",
      "arb": "0.9759706896543044",
      "sw": "0.97667423846393",
      "tr": "0.9798809273353573",
      "vi": "0.975364866992148"
    },
    "canonical_solution": "var max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}",
    "instruction": {
      "es": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Go باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nGo kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda Türkçe bir açıklama (docstring) sağlayın.",
      "vi": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9231167343039689",
      "sw": "0.9338646242217667",
      "tr": "0.8337048573241623",
      "vi": "0.9181495843654295"
    },
    "level": "",
    "test": "func TestFindMaxMin(t *testing.T) {\n\tassert := assert.New(t)\n\tvar max, min int\n\n\tmax, min = FindMaxMin(1, 2, 3)\n\tassert.Equal(3, max)\n\tassert.Equal(1, min)\n\n\t// Additional tests\n\tmax, min = FindMaxMin(5, 3, 4)\n\tassert.Equal(5, max)\n\tassert.Equal(3, min)\n\n\tmax, min = FindMaxMin(10, -2, 7)\n\tassert.Equal(10, max)\n\tassert.Equal(-2, min)\n\n\tmax, min = FindMaxMin(-1, -3, -2)\n\tassert.Equal(-1, max)\n\tassert.Equal(-3, min)\n}",
    "entry_point": "FindMaxMin",
    "signature": "func FindMaxMin(a, b, c int) (int, int)",
    "docstring": {
      "es": "Encuentra el máximo y mínimo de tres enteros distintos.\n\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nLa función devuelve dos valores: el entero máximo y mínimo.\n\nEjemplo de uso:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nتعيد الدالة قيمتين: العدد الصحيح الأكبر والأصغر.\n\nمثال على الاستخدام:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "sw": "Pata kiwango cha juu na cha chini cha nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nKazi inarejesha maadili mawili: nambari ya juu na ya chini.\n\nMfano wa matumizi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nFonksiyon iki değer döndürür: maksimum ve minimum tam sayı.\n\nÖrnek kullanım:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất trong ba số nguyên khác nhau.\n\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nHàm trả về hai giá trị: số nguyên lớn nhất và nhỏ nhất.\n\nVí dụ sử dụng:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)"
    },
    "docstring_bertscore": {
      "es": "0.9909841670048264",
      "arb": "0.9683029610552146",
      "sw": "0.9788182547968206",
      "tr": "0.972478370294949",
      "vi": "0.9600522522877875"
    }
  },
  {
    "task_id": "Go/4",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (float64): coordenada x del punto A.\n- ya (float64): coordenada y del punto A.\n- xb (float64): coordenada x del punto B.\n- yb (float64): coordenada y del punto B.\n\nDevuelve:\nfloat64: La distancia entre los puntos A y B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (float64): الإحداثي السيني للنقطة A.\n- ya (float64): الإحداثي الصادي للنقطة A.\n- xb (float64): الإحداثي السيني للنقطة B.\n- yb (float64): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nfloat64: المسافة بين النقطتين A و B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (float64): x-kiwianishi cha pointi A.\n- ya (float64): y-kiwianishi cha pointi A.\n- xb (float64): x-kiwianishi cha pointi B.\n- yb (float64): y-kiwianishi cha pointi B.\n\nRudisha:\nfloat64: Umbali kati ya pointi A na B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (float64): A noktasının x-koordinatı.\n- ya (float64): A noktasının y-koordinatı.\n- xb (float64): B noktasının x-koordinatı.\n- yb (float64): B noktasının y-koordinatı.\n\nDöndürür:\nfloat64: A ve B noktaları arasındaki mesafe.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (float64): tọa độ x của điểm A.\n- ya (float64): tọa độ y của điểm A.\n- xb (float64): tọa độ x của điểm B.\n- yb (float64): tọa độ y của điểm B.\n\nTrả về:\nfloat64: Khoảng cách giữa điểm A và B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9802376674996959",
      "sw": "0.9965515779548533",
      "tr": "0.9973365652207031",
      "vi": "0.999134567429831"
    },
    "canonical_solution": "return math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}",
    "instruction": {
      "es": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Go باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8695155314601802",
      "sw": "0.9338646242217667",
      "tr": "0.8699094155057724",
      "vi": "0.9263474574515014"
    },
    "level": "",
    "test": "func TestCalculateDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.InDelta(5, calculateDistance(0, 0, 3, 4), 1e-6)\n\tassert.InDelta(0, calculateDistance(0, 0, 0, 0), 1e-6)\n\tassert.InDelta(4.242640687, calculateDistance(-1, -1, 2, 2), 1e-6)\n\tassert.InDelta(5.68243, calculateDistance(1.5, 3.9, 4.2, -1.1), 1e-6)\n}",
    "entry_point": "calculateDistance",
    "signature": "func calculateDistance(xa, ya, xb, yb float64) float64",
    "docstring": {
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (float64): coordenada x del punto A.\n- ya (float64): coordenada y del punto A.\n- xb (float64): coordenada x del punto B.\n- yb (float64): coordenada y del punto B.\n\nDevuelve:\nfloat64: La distancia entre los puntos A y B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (float64): الإحداثي السيني للنقطة A.\n- ya (float64): الإحداثي الصادي للنقطة A.\n- xb (float64): الإحداثي السيني للنقطة B.\n- yb (float64): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nfloat64: المسافة بين النقطتين A و B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (float64): x-kiwianishi cha pointi A.\n- ya (float64): y-kiwianishi cha pointi A.\n- xb (float64): x-kiwianishi cha pointi B.\n- yb (float64): y-kiwianishi cha pointi B.\n\nRudisha:\nfloat64: Umbali kati ya pointi A na B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (float64): A noktasının x-koordinatı.\n- ya (float64): A noktasının y-koordinatı.\n- xb (float64): B noktasının x-koordinatı.\n- yb (float64): B noktasının y-koordinatı.\n\nDöndürülenler:\nfloat64: A ve B noktaları arasındaki mesafe.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (float64): tọa độ x của điểm A.\n- ya (float64): tọa độ y của điểm A.\n- xb (float64): tọa độ x của điểm B.\n- yb (float64): tọa độ y của điểm B.\n\nTrả về:\nfloat64: Khoảng cách giữa các điểm A và B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.970901443699913",
      "sw": "0.9971246266041389",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "Go/5",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de tomar el módulo 10007 de la salida.\n\nEjemplos:\n    ExtraNumber(1)    // devuelve 1\n*/\nfunc processRequest(n int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nيعيد:\nint: النتيجة بعد أخذ باقي القسمة 10007 من المخرج.\n\nأمثلة:\n    ExtraNumber(1)    // يعيد 1\n*/\nfunc processRequest(n int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPata faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n\nMifano:\n    ExtraNumber(1)    // inarejesha 1\n*/\nfunc processRequest(n int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nN'in faktöriyelini bulun ve sonucun 10007 ile modunu alın.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: Çıktının 10007 ile modunun alınmasından sonra elde edilen sonuç.\n\nÖrnekler:\n    ExtraNumber(1)    // 1 döndürür\n*/\nfunc processRequest(n int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi lấy phần dư 10007 của đầu ra.\n\nVí dụ:\n    ExtraNumber(1)    // trả về 1\n*/\nfunc processRequest(n int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9475617780371706",
      "sw": "0.9824863620433918",
      "tr": "0.9654111013377277",
      "vi": "0.9705848268725434"
    },
    "canonical_solution": "if n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}",
    "instruction": {
      "es": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nAşağıdaki Go kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9025638528871459",
      "sw": "0.9338646242217667",
      "tr": "0.8646516693197789",
      "vi": "0.9141525452078644"
    },
    "level": "",
    "test": "func TestProcessRequest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, processRequest(0), \"Factorial of 0 should be 1\")\n\tassert.Equal(1, processRequest(1), \"Factorial of 1 should be 1\")\n\tassert.Equal(2, processRequest(2), \"Factorial of 2 should be 2\")\n\tassert.Equal(6, processRequest(3), \"Factorial of 3 should be 6\")\n\tassert.Equal(24, processRequest(4), \"Factorial of 4 should be 24\")\n\tassert.Equal(6266, processRequest(10), \"Factorial of 10 modulus 10007 should be 6266\")\n\tassert.Equal(6991, processRequest(10000), \"Boundary condition for Factorial of 10000 modulus 10007 should be 6991\")\n}",
    "entry_point": "processRequest",
    "signature": "func processRequest(n int) int",
    "docstring": {
      "es": "Encuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de tomar el módulo 10007 de la salida.\n\nEjemplos:\n    ExtraNumber(1)    // devuelve 1",
      "arb": "احسب المضروب لـ N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (int): عدد صحيح يمثل القيمة المدخلة (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد أخذ باقي القسمة 10007 من المخرجات.\n\nأمثلة:\n    ExtraNumber(1)    // يعيد 1",
      "sw": "Pata faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (int): Nambari ya mzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n\nMifano:\n    ExtraNumber(1)    // inarejesha 1",
      "tr": "N'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürür:\nint: Çıktının 10007 modunu aldıktan sonraki sonucu.\n\nÖrnekler:\n    ExtraNumber(1)    // 1 döndürür",
      "vi": "Tìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi lấy phần dư 10007 của đầu ra.\n\nVí dụ:\n    ExtraNumber(1)    // trả về 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.8857509829148289",
      "sw": "0.9774383695397711",
      "tr": "1",
      "vi": "0.9504290075874091"
    }
  },
  {
    "task_id": "Go/6",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calcula el área de un triángulo dada su base y altura.\n​\nParámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​\nDevuelve:\n​float64: El área calculada del triángulo, redondeada a una precisión de float64.\n​\nEjemplos:\n\tcalculateTriangleArea2(1, 2) // devuelve 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 يحسب مساحة المثلث بناءً على قاعدته وارتفاعه.\n\nالمعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n\nالقيم المعادة:\n​float64: المساحة المحسوبة للمثلث، مقربة إلى دقة float64.\n\nأمثلة:\n\tcalculateTriangleArea2(1, 2) // يعيد 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 huhesabu eneo la pembetatu ikizingatia msingi wake na urefu.\n​\nVigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​\nInarejesha:\n​float64: Eneo lililohesabiwa la pembetatu, limezungushwa hadi usahihi wa float64.\n​\nMifano:\n\tcalculateTriangleArea2(1, 2) // inarejesha 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2, bir üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplar.\n​\nParametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​\nDöndürür:\n​float64: Hesaplanan üçgen alanı, float64 hassasiyetine yuvarlanmış olarak.\n​\nÖrnekler:\n\tcalculateTriangleArea2(1, 2) // 1.0 döndürür\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n\nTham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n\nTrả về:\n​float64: Diện tích đã tính của tam giác, được làm tròn đến độ chính xác float64.\n\nVí dụ:\n\tcalculateTriangleArea2(1, 2) // trả về 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {"
    },
    "prompt_bertscore": {
      "es": "0.9858513593285039",
      "arb": "0.979241734769187",
      "sw": "0.9817132926004041",
      "tr": "0.9714806498910108",
      "vi": "0.9773483899771623"
    },
    "canonical_solution": "// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}",
    "instruction": {
      "es": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9156106908350415",
      "sw": "0.9102365472457616",
      "tr": "0.8699948265696174",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestCalculateTriangleArea2(t *testing.T) {\n\t// Using testify for assert comparison with delta for approximation\n\tassert := assert.New(t)\n\n\t// Adding more comprehensive test cases and correcting the expected values\n\tassert.InDelta(1.0, calculateTriangleArea2(1, 2), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(6.0, calculateTriangleArea2(3, 4), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(20.0, calculateTriangleArea2(5, 8), 1e-6)   // Additional test case\n\tassert.InDelta(10.5, calculateTriangleArea2(7, 3), 1e-6)   // Additional test case\n\tassert.InDelta(50.0, calculateTriangleArea2(10, 10), 1e-6) // Additional test case\n}",
    "entry_point": "calculateTriangleArea2",
    "signature": "func calculateTriangleArea2(base, height int) float64",
    "docstring": {
      "es": "CalculateTriangleArea2 calcula el área de un triángulo dado su base y altura.\n\nParámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n\nDevuelve:\nfloat64: El área calculada del triángulo, redondeada a una precisión de float64.\n\nEjemplos:\n\tcalculateTriangleArea2(1, 2) // devuelve 1.0",
      "arb": "CalculateTriangleArea2 يحسب مساحة المثلث بناءً على قاعدته وارتفاعه.\n\nالمعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n\nالقيم المعادة:\nfloat64: المساحة المحسوبة للمثلث، مقربة إلى دقة float64.\n\nأمثلة:\n\tcalculateTriangleArea2(1, 2) // يعيد 1.0",
      "sw": "CalculateTriangleArea2 huhesabu eneo la pembetatu ikizingatia msingi wake na urefu.\n\nVigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n\nInarejesha:\nfloat64: Eneo lililohesabiwa la pembetatu, limezungushwa hadi usahihi wa float64.\n\nMifano:\n\tcalculateTriangleArea2(1, 2) // inarejesha 1.0",
      "tr": "CalculateTriangleArea2, bir üçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplar.\n\nParametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n\nDöndürülen:\nfloat64: Hesaplanan üçgen alanı, float64 hassasiyetine yuvarlanmış olarak.\n\nÖrnekler:\n\tcalculateTriangleArea2(1, 2) // 1.0 döndürür",
      "vi": "CalculateTriangleArea2 tính diện tích của một tam giác dựa trên độ dài đáy và chiều cao của nó.\n\nTham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n\nTrả về:\nfloat64: Diện tích đã tính của tam giác, được làm tròn đến độ chính xác float64.\n\nVí dụ:\n\tcalculateTriangleArea2(1, 2) // trả về 1.0"
    },
    "docstring_bertscore": {
      "es": "0.9902601592659542",
      "arb": "0.9713859031992571",
      "sw": "0.985897441576904",
      "tr": "0.9745917975491603",
      "vi": "0.9799562082497695"
    }
  },
  {
    "task_id": "Go/7",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular la distancia de Hamming entre dos enteros.\n\nLa distancia de Hamming mide el número de bits diferentes entre\ndos valores enteros cuando se representan en forma binaria.\n\nParámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- int: El número de bits que necesitan ser cambiados para convertir x en y.\n\nEjemplos:\n    hammingDistance(1, 2) // devuelve 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب مسافة هامنج بين عددين صحيحين.\n\nتقيس مسافة هامنج عدد البتات المختلفة بين\nقيمتين صحيحيتين عند تمثيلهما في شكل ثنائي.\n\nالمعطيات:\n- x (int): العدد الصحيح الأول (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني (y <= 1,000,000,000).\n\nالإرجاع:\n- int: عدد البتات التي تحتاج إلى قلب لتحويل x إلى y.\n\nأمثلة:\n    hammingDistance(1, 2) // يعيد 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu umbali wa Hamming kati ya namba mbili.\n\nUmbali wa Hamming hupima idadi ya biti zinazotofautiana kati ya\nmaadili mawili ya namba nzima yanapowakilishwa katika mfumo wa binary.\n\nVigezo:\n- x (int): Namba ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Namba ya pili chanya (y <= 1,000,000,000).\n\nInarudisha:\n- int: Idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n    hammingDistance(1, 2) // inarudisha 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nHamming mesafesi, iki tamsayı değeri ikili biçimde temsil edildiğinde\nfarklı olan bitlerin sayısını ölçer.\n\nParametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürülen:\n- int: x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n    hammingDistance(1, 2) // 2 döndürür\n*/\nfunc hammingDistance(x int, y int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính khoảng cách Hamming giữa hai số nguyên.\n\nKhoảng cách Hamming đo lường số lượng bit khác nhau giữa\nhai giá trị số nguyên khi được biểu diễn dưới dạng nhị phân.\n\nTham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- int: Số lượng bit cần phải lật để chuyển đổi x thành y.\n\nVí dụ:\n    hammingDistance(1, 2) // trả về 2\n*/\nfunc hammingDistance(x int, y int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9938216019979098",
      "arb": "0.9869017167834163",
      "sw": "0.9799774617005401",
      "tr": "0.9865149834315414",
      "vi": "0.9987800121996837"
    },
    "canonical_solution": "distance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}",
    "instruction": {
      "es": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nAşağıdaki Go kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8969755857471104",
      "sw": "0.9150640600264335",
      "tr": "0.8652129987765835",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestHammingDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, hammingDistance(1, 2), \"1 and 2 should have a Hamming distance of 2\")\n\tassert.Equal(2, hammingDistance(4, 7), \"4 and 7 should have a Hamming distance of 2\")\n\tassert.Equal(3, hammingDistance(25, 30), \"25 and 30 should have a Hamming distance of 3\")\n\tassert.Equal(0, hammingDistance(0, 0), \"0 and 0 should have a Hamming distance of 0\")\n\tassert.Equal(28, hammingDistance(0xFFFFFFF, 0), \"0xFFFFFFF and 0 should have a Hamming distance of 28\")\n}",
    "entry_point": "hammingDistance",
    "signature": "func hammingDistance(x int, y int) int",
    "docstring": {
      "es": "Calcular la distancia de Hamming entre dos enteros.\n\nLa distancia de Hamming mide el número de bits diferentes entre\ndos valores enteros cuando se representan en forma binaria.\n\nParámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- int: El número de bits que necesitan ser cambiados para convertir x en y.\n\nEjemplos:\n    hammingDistance(1, 2) // devuelve 2",
      "arb": "حساب مسافة هامنج بين عددين صحيحين.\n\nتقيس مسافة هامنج عدد البتات المختلفة بين قيمتين صحيحتين عند تمثيلهما في شكل ثنائي.\n\nالمعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالقيم المعادة:\n- int: عدد البتات التي تحتاج إلى قلب لتحويل x إلى y.\n\nأمثلة:\n    hammingDistance(1, 2) // يعيد 2",
      "sw": "Hesabu umbali wa Hamming kati ya namba mbili za mzima.\n\nUmbali wa Hamming hupima idadi ya biti zinazotofautiana kati ya\nmaadili mawili ya mzima yanapowakilishwa katika mfumo wa binary.\n\nVigezo:\n- x (int): Namba ya kwanza ya mzima chanya (x <= 1,000,000,000).\n- y (int): Namba ya pili ya mzima chanya (y <= 1,000,000,000).\n\nInarejesha:\n- int: Idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n    hammingDistance(1, 2) // inarejesha 2",
      "tr": "İki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nHamming mesafesi, iki tamsayı değeri ikili biçimde temsil edildiğinde, farklı olan bitlerin sayısını ölçer.\n\nParametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürülenler:\n- int: x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n    hammingDistance(1, 2) // 2 döndürür",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên.\n\nKhoảng cách Hamming đo lường số lượng bit khác nhau giữa\nhai giá trị số nguyên khi được biểu diễn dưới dạng nhị phân.\n\nTham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- int: Số lượng bit cần phải thay đổi để chuyển đổi x thành y.\n\nVí dụ:\n    hammingDistance(1, 2) // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9916215718975674",
      "arb": "0.9944278219208282",
      "sw": "0.9841387681832211",
      "tr": "0.9835192400247733",
      "vi": "0.9901699810729644"
    }
  },
  {
    "task_id": "Go/8",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta la cantidad de enteros impares en una lista dada de números.\n\nParámetros:\n- count (int): La cantidad de números a evaluar.\n- nums ([]int): Un slice de enteros.\n\nDevuelve:\nint: La cantidad de números impares en la lista de entrada.\n\nEjemplos:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // devuelve 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- nums ([]int): شريحة من الأعداد الصحيحة.\n\nالإرجاع:\nint: عدد الأعداد الفردية في قائمة الإدخال.\n\nأمثلة:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // يعيد 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya namba zisizo za kawaida katika orodha iliyotolewa ya namba.\n\nVigezo:\n- count (int): Idadi ya namba za kutathmini.\n- nums ([]int): Sehemu ya namba nzima.\n\nInarudisha:\nint: Idadi ya namba zisizo za kawaida katika orodha ya pembejeo.\n\nMifano:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // inarudisha 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- nums ([]int): Bir tamsayı dilimi.\n\nDöndürür:\nint: Girdi listesindeki tek sayıların sayısı.\n\nÖrnekler:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 döndürür\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng số nguyên lẻ trong một danh sách số cho trước.\n\nTham số:\n- count (int): Số lượng số cần đánh giá.\n- nums ([]int): Một slice của các số nguyên.\n\nTrả về:\nint: Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // trả về 3\n*/\nfunc countOddNumbers(count int, nums []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9879973619652048",
      "arb": "0.9813333126814843",
      "sw": "0.9809118190129282",
      "tr": "0.976674437094311",
      "vi": "0.9921135793513908"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yapılmalıdır.",
      "vi": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8996296848984986",
      "sw": "0.9425243129437447",
      "tr": "0.863991421933219",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestCountOddNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, countOddNumbers(5, []int{1, 4, 3, 2, 5}))\n\tassert.Equal(0, countOddNumbers(4, []int{2, 2, 0, 0}))\n\tassert.Equal(4, countOddNumbers(6, []int{7, 7, 8, 1, 9, 10})) // Additional Test Sample\n}",
    "entry_point": "countOddNumbers",
    "signature": "func countOddNumbers(count int, nums []int) int",
    "docstring": {
      "es": "Cuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n- count (int): La cantidad de números a evaluar.\n- nums ([]int): Un segmento de enteros.\n\nDevuelve:\nint: La cantidad de números impares en la lista de entrada.\n\nEjemplos:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // devuelve 3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- nums ([]int): جزء من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: عدد الأعداد الفردية في قائمة الإدخال.\n\nأمثلة:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // يعيد 3",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n\nVigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- nums ([]int): Sehemu ya nambari za mzima.\n\nInarejesha:\nint: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n\nMifano:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // inarejesha 3",
      "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- nums ([]int): Bir tamsayı dilimi.\n\nDöndürür:\nint: Girdi listesindeki tek sayıların sayısı.\n\nÖrnekler:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 döndürür",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n- count (int): Số lượng số cần đánh giá.\n- nums ([]int): Một mảng các số nguyên.\n\nTrả về:\nint: Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9820076628250978",
      "arb": "0.9591886073910477",
      "sw": "0.9576873589711861",
      "tr": "0.9675483642376631",
      "vi": "0.9773124378781951"
    }
  },
  {
    "task_id": "Go/9",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcular la suma de números pares en una lista dada.\nParámetros:\n- numbers ([]int): Una porción de enteros.\n- size (int): La longitud de la porción.\nDevuelve:\nint: La suma de los números pares en la porción de entrada.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب مجموع الأعداد الزوجية في قائمة معينة.\nالمعطيات:\n- numbers ([]int): شريحة من الأعداد الصحيحة.\n- size (int): طول الشريحة.\nالمخرجات:\nint: مجموع الأعداد الزوجية في الشريحة المدخلة.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\nVigezo:\n- numbers ([]int): Sehemu ya namba kamili.\n- size (int): Urefu wa sehemu.\nInarudisha:\nint: Jumla ya namba shufwa katika sehemu ya ingizo.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir listedeki çift sayıların toplamını hesapla.\nParametreler:\n- numbers ([]int): Bir tamsayı dilimi.\n- size (int): Dilimin uzunluğu.\nDöndürür:\nint: Girdi dilimindeki çift sayıların toplamı.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTính tổng các số chẵn trong một danh sách cho trước.\nTham số:\n- numbers ([]int): Một slice của các số nguyên.\n- size (int): Độ dài của slice.\nTrả về:\nint: Tổng của các số chẵn trong slice đầu vào.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9971651472018701",
      "arb": "0.9782084595270435",
      "sw": "0.997056893644206",
      "tr": "0.999999801369619",
      "vi": "0.9971651472018701"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nGo kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9029702506467433",
      "sw": "0.9102365472457616",
      "tr": "0.8829046095545989",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestCalculateEvenSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, calculateEvenSum([]int{1, 4, 3, 2, 5}))\n\tassert.Equal(4, calculateEvenSum([]int{2, 2, 0, 0}))\n\tassert.Equal(0, calculateEvenSum([]int{7, 11, 19})) // Should return 0 because there are no even numbers\n\tassert.Equal(12+14+16+18+20, calculateEvenSum([]int{12, 14, 16, 18, 20}))\n}",
    "entry_point": "calculateEvenSum",
    "signature": "func calculateEvenSum(numbers []int) int",
    "docstring": {
      "es": "Calcular la suma de los números pares en una lista dada.\nParámetros:\n- numbers ([]int): Una porción de enteros.\nDevuelve:\nint: La suma de los números pares en la porción de entrada.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "arb": "حساب مجموع الأعداد الزوجية في قائمة معينة.  \nالمعلمات:  \n- numbers ([]int): شريحة من الأعداد الصحيحة.  \nالقيم المعادة:  \nint: مجموع الأعداد الزوجية في الشريحة المدخلة.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.  \nVigezo:  \n- numbers ([]int): Sehemu ya nambari za mzima.  \nRudisha:  \nint: Jumla ya namba shufwa katika sehemu ya pembejeo.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})  \n    6  ",
      "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.  \nParametreler:  \n- numbers ([]int): Bir tamsayı dilimi.  \nDöndürür:  \nint: Girdi dilimindeki çift sayıların toplamı.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "vi": "Tính tổng các số chẵn trong một danh sách cho trước.  \nTham số:  \n- numbers ([]int): Một mảng các số nguyên.  \nTrả về:  \nint: Tổng các số chẵn trong mảng đầu vào.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9899943918161296",
      "arb": "0.9917216816096089",
      "sw": "0.9747147497550208",
      "tr": "0.9999996027392379",
      "vi": "0.9762797585271947"
    }
  },
  {
    "task_id": "Go/10",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDeterminar si dos intervalos cerrados se intersectan.\n\nArgumentos:\na, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\nc, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n\nDevuelve:\nint: 1 si los intervalos se intersectan, 0 en caso contrario.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n\nالمعطيات:\na, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\nc, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n\nالقيم المعادة:\nint: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua kama vipindi viwili vilivyofungwa vinakatiza.\n\nHoja:\na, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\nc, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n\nInarejesha:\nint: 1 ikiwa vipindi vinakatiza, 0 vinginevyo.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n\nArgümanlar:\na, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\nc, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n\nDöndürür:\nint: Aralıklar kesişiyorsa 1, aksi takdirde 0.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nXác định xem hai khoảng đóng có giao nhau hay không.\n\nTham số:\na, b: Đại diện cho khoảng đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\nc, d: Đại diện cho khoảng đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n\nTrả về:\nint: 1 nếu các khoảng giao nhau, 0 nếu không.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9586809081371226",
      "sw": "0.9898648848076949",
      "tr": "0.9854640300854859",
      "vi": "0.9553715273587002"
    },
    "canonical_solution": "if (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}",
    "instruction": {
      "es": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nAşağıdaki Go kodunun işlevselliğini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9338646242217667",
      "tr": "0.8682303928948845",
      "vi": "0.9263474574515014"
    },
    "level": "",
    "test": "func TestAreIntervalsIntersecting(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, AreIntervalsIntersecting(1, 1, 1, 2))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 2, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 4, 7))\n\tassert.Equal(0, AreIntervalsIntersecting(3, 5, 6, 7))\n\t// Additional test cases\n\tassert.Equal(1, AreIntervalsIntersecting(0, 0, 0, 0))\n\tassert.Equal(1, AreIntervalsIntersecting(1, 3, 2, 4))\n\tassert.Equal(0, AreIntervalsIntersecting(1, 3, 4, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(10, 20, 20, 30))\n\tassert.Equal(0, AreIntervalsIntersecting(10, 20, 21, 30))\n}",
    "entry_point": "AreIntervalsIntersecting",
    "signature": "func AreIntervalsIntersecting(a, b, c, d int) int",
    "docstring": {
      "es": "Determinar si dos intervalos cerrados se intersectan.\n\nArgumentos:\na, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\nc, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n\nDevuelve:\nint: 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n\nالحجج:\na, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\nc, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n\nالقيم المعادة:\nint: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.",
      "sw": "Amua kama vipindi viwili vilivyofungwa vinakatana.\n\nHoja:\na, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\nc, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n\nRudisha:\nint: 1 ikiwa vipindi vinakatana, 0 vinginevyo.",
      "tr": "İki kapalı aralığın kesişip kesişmediğini belirleyin.\n\nArgümanlar:\na, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\nc, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n\nDöndürülenler:\nint: Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\nTham số:\na, b: Đại diện cho khoảng đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\nc, d: Đại diện cho khoảng đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n\nTrả về:\nint: 1 nếu các khoảng giao nhau, 0 nếu không."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9534092578244566",
      "sw": "0.9766982727400352",
      "tr": "0.9802779894670459",
      "vi": "0.9352081601190867"
    }
  },
  {
    "task_id": "Go/11",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nfunc HelloMMCODEEVAL() string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {"
    },
    "prompt_bertscore": {
      "es": "0.9982075594415412",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.9982075594415412"
    },
    "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}",
    "instruction": {
      "es": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8952355836092448",
      "sw": "0.9338646242217667",
      "tr": "0.8457458310224972",
      "vi": "0.9263474574515014"
    },
    "level": "",
    "test": "func TestHelloMMCODEEVAL(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\", HelloMMCODEEVAL())\n}",
    "entry_point": "HelloMMCODEEVAL",
    "signature": "func HelloMMCODEEVAL() string",
    "docstring": {
      "es": "Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ifadesini döndür",
      "vi": "Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "es": "0.956679309787434",
      "arb": "0.999999801369619",
      "sw": "0.8942376645749255",
      "tr": "0.8884491780108068",
      "vi": "0.956679309787434"
    }
  },
  {
    "task_id": "Go/12",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore calcula la puntuación total para un estudiante basada en las puntuaciones individuales en diferentes materias.\n\nParámetros:\n- scores (variadic ints): Lista de puntuaciones para cada materia.\n\nDevuelve:\n- int: La puntuación total obtenida sumando las puntuaciones individuales.\n\nEjemplos:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // devuelve 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحسب CalculateTotalScore الدرجة الإجمالية لطالب بناءً على الدرجات الفردية في مواد مختلفة.\n\nالمعلمات:\n- scores (variadic ints): قائمة الدرجات لكل مادة.\n\nالقيم المعادة:\n- int: الدرجة الإجمالية التي تم الحصول عليها عن طريق جمع الدرجات الفردية.\n\nأمثلة:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // يعيد 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore huhesabu jumla ya alama kwa mwanafunzi kulingana na alama za kila somo tofauti.\n\nVigezo:\n- scores (variadic ints): Orodha ya alama kwa kila somo.\n\nInarejesha:\n- int: Jumla ya alama inayopatikana kwa kujumlisha alama za kila moja.\n\nMifano:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // inarejesha 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore, farklı derslerdeki bireysel puanlara dayalı olarak bir öğrenci için toplam puanı hesaplar.\n\nParametreler:\n- scores (değişken sayıda int): Her ders için puan listesi.\n\nDöndürür:\n- int: Bireysel puanların toplanmasıyla elde edilen toplam puan.\n\nÖrnekler:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 döndürür\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore tính tổng điểm cho một học sinh dựa trên điểm số cá nhân trong các môn học khác nhau.\n\nTham số:\n- scores (biến đổi ints): Danh sách điểm số cho mỗi môn học.\n\nTrả về:\n- int: Tổng điểm đạt được bằng cách cộng các điểm số cá nhân lại.\n\nVí dụ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // trả về 500\n*/\nfunc CalculateTotalScore(scores ...int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9867988262460403",
      "arb": "0.9829716160642601",
      "sw": "0.9726311170579648",
      "tr": "0.9655561015158831",
      "vi": "0.9812657783519324"
    },
    "canonical_solution": "total := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}",
    "instruction": {
      "es": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nGo kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9231167343039689",
      "sw": "0.9338646242217667",
      "tr": "0.8809872304864691",
      "vi": "0.9181495843654295"
    },
    "level": "",
    "test": "func TestCalculateTotalScore(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(500, CalculateTotalScore(100, 100, 100, 100, 100), \"should return the correct total score\")\n\tassert.Equal(0, CalculateTotalScore(0, 0, 0, 0, 0), \"should handle zero scores correctly\")\n\tassert.Equal(150, CalculateTotalScore(20, 30, 40, 10, 50), \"should return the correct total score for varied inputs\")\n\tassert.Equal(236, CalculateTotalScore(23, 45, 67, 89, 12), \"should return the correct total score for varied inputs\")\n\tassert.Equal(25, CalculateTotalScore(5, 5, 5, 5, 5), \"should return the correct total score for uniform inputs\")\n}",
    "entry_point": "CalculateTotalScore",
    "signature": "func CalculateTotalScore(scores ...int) int",
    "docstring": {
      "es": "CalculateTotalScore calcula el puntaje total para un estudiante basado en los puntajes individuales en diferentes materias.\n\nParámetros:\n- scores (variadic ints): Lista de puntajes para cada materia.\n\nDevuelve:\n- int: El puntaje total obtenido al sumar los puntajes individuales.\n\nEjemplos:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // devuelve 500",
      "arb": "احسبTotalScore يحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات الفردية في مواد مختلفة.\n\nالمعلمات:\n- scores (variadic ints): قائمة الدرجات لكل مادة.\n\nالقيم المعادة:\n- int: المجموع الكلي الذي يتم الحصول عليه من جمع الدرجات الفردية.\n\nأمثلة:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // يعيد 500",
      "sw": "CalculateTotalScore huhesabu jumla ya alama kwa mwanafunzi kulingana na alama za kila somo.\n\nVigezo:\n- scores (variadic ints): Orodha ya alama kwa kila somo.\n\nInarejesha:\n- int: Jumla ya alama inayopatikana kwa kujumlisha alama za kila somo.\n\nMifano:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // inarejesha 500",
      "tr": "CalculateTotalScore, bir öğrencinin farklı derslerdeki bireysel puanlarına dayanarak toplam puanı hesaplar.\n\nParametreler:\n- scores (değişken sayıda int): Her bir ders için puanların listesi.\n\nDöndürülenler:\n- int: Bireysel puanların toplanmasıyla elde edilen toplam puan.\n\nÖrnekler:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 döndürür",
      "vi": "CalculateTotalScore tính tổng điểm cho một học sinh dựa trên điểm số cá nhân trong các môn học khác nhau.\n\nTham số:\n- scores (variadic ints): Danh sách điểm số cho mỗi môn học.\n\nTrả về:\n- int: Tổng điểm đạt được bằng cách cộng các điểm số cá nhân.\n\nVí dụ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // trả về 500"
    },
    "docstring_bertscore": {
      "es": "0.9826899581839525",
      "arb": "0.964746682713166",
      "sw": "0.959434909063531",
      "tr": "0.9600190810141546",
      "vi": "0.9724618839733231"
    }
  },
  {
    "task_id": "Go/13",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers decodifica una serie de números para revelar el patrón oculto que indica\nlos valores reales que cada dígito representa. El patrón se define de la siguiente manera:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado correspondiente a cada cadena de datos según el patrón predefinido.\n\nEjemplo de uso:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers تقوم بفك تشفير سلسلة من الأرقام للكشف عن النمط المخفي الذي يشير إلى\nالقيم الفعلية التي يمثلها كل رقم. يتم تعريف النمط على النحو التالي:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- dataStr: سلسلة تمثل سلسلة من الأرقام. لا يتجاوز الطول 100.\n\nالإرجاع:\nint: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط المحدد مسبقًا.\n\nمثال على الاستخدام:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers hufasiri mfululizo wa namba ili kufichua muundo uliofichwa ambao unaonyesha\nthamani halisi ambazo kila tarakimu inawakilisha. Muundo umefafanuliwa kama ifuatavyo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- dataStr: Kamba inayowakilisha mfululizo wa namba. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo yanayolingana na kila kamba ya data kulingana na muundo uliowekwa awali.\n\nMfano wa matumizi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers, her bir rakamın temsil ettiği gerçek değerleri gösteren gizli deseni ortaya çıkarmak için bir dizi sayıyı çözer. Desen aşağıdaki gibi tanımlanmıştır:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- dataStr: Bir dizi sayıyı temsil eden bir dize. Uzunluğu 100'ü geçmez.\n\nDöndürür:\nint: Önceden tanımlanmış desene göre her veri dizesine karşılık gelen sonuç.\n\nÖrnek kullanım:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers giải mã một chuỗi số để tiết lộ mẫu ẩn chỉ ra\ncác giá trị thực tế mà mỗi chữ số đại diện. Mẫu được định nghĩa như sau:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- dataStr: Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu đã định trước.\n\nVí dụ sử dụng:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {"
    },
    "prompt_bertscore": {
      "es": "0.9892487333657246",
      "arb": "0.9773315063947744",
      "sw": "0.9777933220306806",
      "tr": "0.9899359944841053",
      "vi": "0.9849934747128142"
    },
    "canonical_solution": "a := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9425243129437447",
      "tr": "0.8491257255861869",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestDecodeNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, DecodeNumbers(\"0000\"))\n\tassert.Equal(8, DecodeNumbers(\"8888\"))\n\tassert.Equal(1, DecodeNumbers(\"1234\"))\n\tassert.Equal(3, DecodeNumbers(\"5678\"))\n\tassert.Equal(2, DecodeNumbers(\"9012\"))\n\tassert.Equal(0, DecodeNumbers(\"1357\"))\n\tassert.Equal(4, DecodeNumbers(\"2468\"))\n\n\t// Additional test samples\n\tassert.Equal(4, DecodeNumbers(\"9999\"))\n\tassert.Equal(0, DecodeNumbers(\"1111\"))\n\tassert.Equal(0, DecodeNumbers(\"2222\"))\n\tassert.Equal(0, DecodeNumbers(\"3333\"))\n\tassert.Equal(4, DecodeNumbers(\"4444\"))\n\tassert.Equal(0, DecodeNumbers(\"5555\"))\n\tassert.Equal(4, DecodeNumbers(\"6666\"))\n\tassert.Equal(0, DecodeNumbers(\"7777\"))\n\tassert.Equal(3, DecodeNumbers(\"0001\"))\n\tassert.Equal(1, DecodeNumbers(\"2301\"))\n}",
    "entry_point": "DecodeNumbers",
    "signature": "func DecodeNumbers(dataStr string) int",
    "docstring": {
      "es": "DecodeNumbers decodifica una serie de números para revelar el patrón oculto que indica los valores reales que representa cada dígito. El patrón se define de la siguiente manera: 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado correspondiente a cada cadena de datos según el patrón predefinido.\n\nEjemplo de uso:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "arb": "DecodeNumbers يقوم بفك ترميز سلسلة من الأرقام للكشف عن النمط المخفي الذي يشير إلى القيم الفعلية التي يمثلها كل رقم. يتم تعريف النمط كما يلي:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- dataStr: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط المحدد مسبقًا.\n\nمثال على الاستخدام:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "sw": "DecodeNumbers inafasiri mfululizo wa namba ili kufichua mpangilio uliofichwa ambao unaonyesha thamani halisi ambayo kila tarakimu inawakilisha. Mpangilio umeelezwa kama ifuatavyo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- dataStr: Kamba inayowakilisha mfululizo wa namba. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo yanayolingana na kila kamba ya data kulingana na mpangilio uliowekwa awali.\n\nMfano wa matumizi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "tr": "DecodeNumbers, her bir rakamın temsil ettiği gerçek değerleri gösteren gizli deseni ortaya çıkarmak için bir dizi sayıyı çözer. Desen aşağıdaki gibi tanımlanmıştır:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- dataStr: Bir dizi sayıyı temsil eden bir dize. Uzunluğu 100'ü geçmez.\n\nDöndürür:\nint: Önceden tanımlanmış desene göre her veri dizesine karşılık gelen sonuç.\n\nÖrnek kullanım:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "vi": "DecodeNumbers giải mã một chuỗi số để tiết lộ mẫu ẩn chỉ ra các giá trị thực mà mỗi chữ số đại diện. Mẫu được định nghĩa như sau:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- dataStr: Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu được định nghĩa trước.\n\nVí dụ sử dụng:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))"
    },
    "docstring_bertscore": {
      "es": "0.9871909226182032",
      "arb": "0.9685657490493238",
      "sw": "0.9654206355960173",
      "tr": "0.9780765689540363",
      "vi": "0.9826111019226818"
    }
  },
  {
    "task_id": "Go/14",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods cuenta el número de diferentes métodos de coloreo para n cuadrados\ncon m colores, considerando el requisito de que los cuadrados adyacentes y los\nprimeros/últimos cuadrados deben tener colores diferentes.\n\nArgumentos:\n    n int: El número de cuadrados.\n    m int: El número de colores.\n\nDevuelve:\n    int: El conteo de diferentes métodos de coloreo que satisfacen las condiciones especificadas.\n\nEjemplos:\n    CountColoringMethods(1,1) devuelve 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods يحسب عدد طرق التلوين المختلفة لمربعات n\nبألوان m، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة و\nالمربعات الأولى/الأخيرة بألوان مختلفة.\n\nالمعطيات:\n    n int: عدد المربعات.\n    m int: عدد الألوان.\n\nيُرجع:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة.\n\nأمثلة:\n    CountColoringMethods(1,1) يعيد 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods huhesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n\nna rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na\nmiraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n\nHoja:\n    n int: Idadi ya miraba.\n    m int: Idadi ya rangi.\n\nInarudisha:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa.\n\nMifano:\n    CountColoringMethods(1,1) inarudisha 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods, n kare için farklı boyama yöntemlerinin sayısını\nkomşu karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini dikkate alarak sayar.\n\nArgümanlar:\n    n int: Karelerin sayısı.\n    m int: Renklerin sayısı.\n\nDöndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n\nÖrnekler:\n    CountColoringMethods(1,1) 1 döndürür\n*/\nfunc CountColoringMethods(n, m int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods đếm số lượng phương pháp tô màu khác nhau cho n ô vuông\nvới m màu, xem xét yêu cầu rằng các ô vuông liền kề và\ncác ô đầu/cuối phải có màu khác nhau.\n\nTham số:\n    n int: Số lượng ô vuông.\n    m int: Số lượng màu.\n\nTrả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n\nVí dụ:\n    CountColoringMethods(1,1) trả về 1\n*/\nfunc CountColoringMethods(n, m int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9947984662118394",
      "arb": "0.9574619134887115",
      "sw": "0.974231680668344",
      "tr": "0.9609041779920461",
      "vi": "0.9706295187082763"
    },
    "canonical_solution": "const mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}",
    "instruction": {
      "es": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nAşağıdaki Go kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8848247694480632",
      "sw": "0.9425243129437447",
      "tr": "0.8494709451884255",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestCountColoringMethods(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountColoringMethods(1, 1))\n\tassert.Equal(2, CountColoringMethods(2, 2))\n\tassert.Equal(6, CountColoringMethods(3, 3))\n\tassert.Equal(2, CountColoringMethods(4, 2))\n\t// Add your tests here\n\tassert.Equal(6, CountColoringMethods(2, 3))\n\tassert.Equal(67911, CountColoringMethods(1000, 1000))\n\tassert.Equal(501817, CountColoringMethods(999, 66))\n\tassert.Equal(30, CountColoringMethods(5, 3))\n\n\t// Test with unknown expected result, assuming a placeholder value is \"expectedResult\".\n\t// Replace \"expectedResult\" with the actual expected value if known.\n\texpectedResult := 566585 // Placeholder for the expected result of CountColoringMethods(1000, 10)\n\tassert.Equal(expectedResult, CountColoringMethods(1000, 10))\n}",
    "entry_point": "CountColoringMethods",
    "signature": "func CountColoringMethods(n, m int) int",
    "docstring": {
      "es": "CountColoringMethods cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\nArgumentos:\n    n int: El número de cuadrados.\n    m int: El número de colores.\n\nDevuelve:\n    int: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n\nEjemplos:\n    CountColoringMethods(1,1) devuelve 1",
      "arb": "CountColoringMethods يحسب عدد طرق التلوين المختلفة لعدد n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة بألوان مختلفة.\n\nيعيدالحجج\n    n int: عدد المربعات.\n    m int: عدد الألوان.\n\nيعيد:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n\nامثله:\n    CountColoringMethods(1,1) يعيد 1",
      "sw": "CountColoringMethods huhesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m, kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\nHoja:\n    n int: Idadi ya miraba.\n    m int: Idadi ya rangi.\n\nInarudisha:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa.\n\nMifano:\n    CountColoringMethods(1,1) inarudisha 1",
      "tr": "CountColoringMethods, n kare için m renk ile farklı boyama yöntemlerinin sayısını, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini dikkate alarak sayar.\n\nArgümanlar:\n    n int: Karelerin sayısı.\n    m int: Renklerin sayısı.\n\nDöndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n\nÖrnekler:\n    CountColoringMethods(1,1) döndürür 1",
      "vi": "CountColoringMethods đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và các ô vuông đầu/cuối phải có màu khác nhau.\n\nTham số:\n    n int: Số lượng ô vuông.\n    m int: Số lượng màu.\n\n Trả về: \n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n\nVí dụ:\n    CountColoringMethods(1,1) trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9929988749596633",
      "arb": "0.9495864175110592",
      "sw": "0.9522633591562664",
      "tr": "0.9639748050524644",
      "vi": "0.9828609789420236"
    }
  },
  {
    "task_id": "Go/15",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\nParámetros:\n- n (int): El número de lanzamientos de moneda.\nDevuelve:\n- uint64: El conteo de secuencias válidas.\nEjemplo:\n    countValidCoinTossSequences(1)\n    // Devuelve: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون وجود رؤوس متتالية في n من الرميات.\nالمعلمات:\n- n (int): عدد رميات العملة.\nيعيد:\n- uint64: عدد التسلسلات الصحيحة.\nمثال:\n    countValidCoinTossSequences(1)\n    // يعيد 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\nInarejesha:\n- uint64: Hesabu ya mfuatano halali.\nMfano:\n    countValidCoinTossSequences(1)\n    // Inarejesha: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nArdışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını n atışta sayın.\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\nDöndürür:\n- uint64: Geçerli dizilerin sayısı.\nÖrnek:\n    countValidCoinTossSequences(1)\n    // Döndürür: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\nTham số:\n- n (int): Số lần tung đồng xu.\nTrả về:\n- uint64: Số lượng chuỗi hợp lệ.\nVí dụ:\n    countValidCoinTossSequences(1)\n    // Trả về: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {"
    },
    "prompt_bertscore": {
      "es": "0.9863670037976704",
      "arb": "0.978917371356957",
      "sw": "0.9861580446368218",
      "tr": "0.9846909606424981",
      "vi": "0.9842084874469643"
    },
    "canonical_solution": "var a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}",
    "instruction": {
      "es": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8969755857471104",
      "sw": "0.9338646242217667",
      "tr": "0.8491257255861869",
      "vi": "0.9014763515509799"
    },
    "level": "",
    "test": "func TestCountValidCoinTossSequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(uint64(2), CountValidCoinTossSequences(1))\n\tassert.Equal(uint64(3), CountValidCoinTossSequences(2))\n\tassert.Equal(uint64(5), CountValidCoinTossSequences(3))\n\tassert.Equal(uint64(8), CountValidCoinTossSequences(4))  // Additional test\n\tassert.Equal(uint64(13), CountValidCoinTossSequences(5)) // Additional test\n\t// Feel free to add more tests here\n\tassert.Equal(uint64(267914296), CountValidCoinTossSequences(40)) // Additional test\n\tassert.Equal(uint64(165580141), CountValidCoinTossSequences(39))\n\tassert.Equal(uint64(102334155), CountValidCoinTossSequences(38))\n\t// Use t.Log instead of fmt.Print or fmt.Println in tests\n\tt.Log(\"All tests passed!\")\n}",
    "entry_point": "CountValidCoinTossSequences",
    "signature": "func CountValidCoinTossSequences(n int) uint64",
    "docstring": {
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\nParámetros:\n- n (int): El número de lanzamientos de moneda.\nDevuelve:\n- uint64: El conteo de secuencias válidas.\nEjemplo:\n    countValidCoinTossSequences(1)\n    // Devuelve: 2",
      "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\nالمعلمات:\n- n (int): عدد رميات العملة.\nالقيم المعادة:\n- uint64: عدد التسلسلات الصحيحة.\nمثال:\n    countValidCoinTossSequences(1)\n    // يعيد: 2",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha mara n.\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\nInarejesha:\n- uint64: Idadi ya mfuatano halali.\nMfano:\n    countValidCoinTossSequences(1)\n    // Inarejesha: 2",
      "tr": "n atışında ardışık yazı olmayan geçerli madeni para atış dizilerinin sayısını sayın.\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\nDöndürür:\n- uint64: Geçerli dizilerin sayısı.\nÖrnek:\n    countValidCoinTossSequences(1)\n    // Döndürür: 2",
      "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- uint64: Số lượng dãy hợp lệ.\n\nVí dụ:\n    countValidCoinTossSequences(1)\n    // Trả về: 2"
    },
    "docstring_bertscore": {
      "es": "0.9867082507922884",
      "arb": "0.9667113358119821",
      "sw": "0.9727622131094479",
      "tr": "0.9940178488143723",
      "vi": "0.9767189302996628"
    }
  },
  {
    "task_id": "Go/16",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n- n (uint64): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\nint: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاعثر على طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعطيات:\n- n (uint64): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPata urefu wa mlolongo mrefu zaidi wa mfululizo wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (uint64): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nRudisha:\nint: Urefu wa mlolongo mrefu zaidi wa mfululizo wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir negatif olmayan tam sayının ikili gösteriminde ardışık 1'lerin en uzun dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (uint64): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\nint: Verilen tam sayının ikili gösterimindeki ardışık 1'lerin en uzun dizisinin uzunluğu.\n\nÖrnekler:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTìm độ dài của dãy liên tiếp dài nhất của số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (uint64): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\nint: Độ dài của dãy liên tiếp dài nhất của số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9875814299473178",
      "sw": "0.9722803358050572",
      "tr": "0.9969397017193955",
      "vi": "0.9971738869386356"
    },
    "canonical_solution": "max := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}",
    "instruction": {
      "es": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nGo kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir açıklama (docstring) sağlayın.",
      "vi": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9081642364804247",
      "sw": "0.8853141947069332",
      "tr": "0.8363426687843056",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestFindLongestConsecutiveOnesLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, findLongestConsecutiveOnesLength(7))\n\tassert.Equal(2, findLongestConsecutiveOnesLength(13))\n\tassert.Equal(3, findLongestConsecutiveOnesLength(12345))         // New test sample\n\tassert.Equal(4, findLongestConsecutiveOnesLength(0b11011101111)) // New test sample using binary literal for clarity\n\tassert.Equal(32, findLongestConsecutiveOnesLength(0xFFFFFFFF))   // New test sample: all ones for a 32-bit number\n\tassert.Equal(0, findLongestConsecutiveOnesLength(0))             // New test sample: no ones in a zero\n}",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "func findLongestConsecutiveOnesLength(n uint64) int",
    "docstring": {
      "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n- n (uint64): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\nint: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "arb": "ابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (uint64): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالإرجاع:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "sw": "Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo na alama hasi.\n\nVigezo:\n- n (uint64): Nambari isiyo na alama hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\nint: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "tr": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParametreler:\n- n (uint64): Negatif olmayan bir tamsayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürülenler:\nint: Verilen tamsayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (uint64): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\nint: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.975057585792687",
      "tr": "0.999999801369619",
      "vi": "0.9975707504399434"
    }
  },
  {
    "task_id": "Go/17",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra a utilizar en el ID.\n- word2 (string): La segunda palabra a utilizar en el ID.\nDevuelve:\nstring: Un ID divino formado invirtiendo cada otro carácter de la segunda\n        palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nيعيد:\nstring: معرف مقدس يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\nVigezo:\n- word1 (string): Neno la kwanza litakalotumika katika kitambulisho.\n- word2 (string): Neno la pili litakalotumika katika kitambulisho.\nRudisha:\nstring: Kitambulisho cha kiungu kinachoundwa kwa kurudisha kila herufi nyingine ya\n        neno la pili na kuichanganya na neno la kwanza.\nmfano:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBelirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (string): Kimlikte kullanılacak ilk kelime.\n- word2 (string): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nstring: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle\n        birleştirerek oluşturulan kutsal bir kimlik.\nÖrnek:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (string): Từ đầu tiên được sử dụng trong ID.\n- word2 (string): Từ thứ hai được sử dụng trong ID.\nTrả về:\nstring: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai\n        và kết hợp nó với từ đầu tiên.\nví dụ:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {"
    },
    "prompt_bertscore": {
      "es": "0.9839826447037276",
      "arb": "0.9616095144751009",
      "sw": "0.9592460115711668",
      "tr": "0.9566632207265702",
      "vi": "0.9656905742838438"
    },
    "canonical_solution": "length1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}",
    "instruction": {
      "es": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9351273175540055",
      "sw": "0.860484801186429",
      "tr": "0.8561933918041703",
      "vi": "0.9386444657109903"
    },
    "level": "",
    "test": "func TestCreateID(t *testing.T) {\n\tassert.Equal(t, \"ftiasch\", CreateID(\"fish\", \"cat\"))\n\tassert.Equal(t, \"imccpac\", CreateID(\"icpc\", \"acm\"))\n\tassert.Equal(t, \"owo\", CreateID(\"oo\", \"w\"))\n\tassert.Equal(t, \"hdellrloow\", CreateID(\"hello\", \"world\"))\n\tassert.Equal(t, \"afbecd\", CreateID(\"abc\", \"def\"))\n\tassert.Equal(t, \"bauaauabnbbn\", CreateID(\"buaanb\", \"nbbuaa\"))\n\tassert.Equal(t, \"xuttuxiesvgooloid\", CreateID(\"xtuisgood\", \"ilovextu\"))\n}",
    "entry_point": "CreateID",
    "signature": "func CreateID(word1, word2 string) string",
    "docstring": {
      "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra que se utilizará en el ID.\n- word2 (string): La segunda palabra que se utilizará en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda\n        palabra y combinarlo con la primera palabra.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة محددة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nstring: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "sw": "Creates an ID by combining two words in a specific manner.  \nVigezo:  \n- word1 (string): Neno la kwanza litakalotumika katika ID.  \n- word2 (string): Neno la pili litakalotumika katika ID.  \nInarejesha:  \nstring: ID ya kipekee inayoundwa kwa kurudisha kila herufi nyingine ya neno la pili na kuliunganisha na neno la kwanza.  \nmfano:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "tr": "Belirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (string): Kimlikte kullanılacak ilk kelime.\n- word2 (string): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nstring: İkinci kelimenin her iki karakterini ters çevirerek ve bunu ilk kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nörn.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (string): Từ đầu tiên được sử dụng trong ID.  \n- word2 (string): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \nstring: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp nó với từ đầu tiên.  \nví dụ:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  "
    },
    "docstring_bertscore": {
      "es": "0.9892463498011522",
      "arb": "0.9486409368973331",
      "sw": "0.9499453426095892",
      "tr": "0.9610015068787532",
      "vi": "0.9544067795980138"
    }
  },
  {
    "task_id": "Go/18",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\nint: El número total de diferentes esquemas de permutación.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث أن عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالإرجاع:\nint: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nInarudisha:\nint: Jumla ya idadi ya mipango tofauti ya mpangilio.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn uzunluğunda bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\nfarklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon şemalarının toplam sayısı.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nint: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {"
    },
    "prompt_bertscore": {
      "es": "0.993264841039869",
      "arb": "0.9817677173248076",
      "sw": "0.9712448756287223",
      "tr": "0.9794741323149978",
      "vi": "0.9951683159813264"
    },
    "canonical_solution": "factorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}",
    "instruction": {
      "es": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nAşağıdaki Go kodunun işlevselliğini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9150640600264335",
      "tr": "0.8761440259056955",
      "vi": "0.9263474574515014"
    },
    "level": "",
    "test": "func TestCountPermutationsOfBinaryString(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, countPermutationsOfBinaryString(2, 0))\n\tassert.Equal(0, countPermutationsOfBinaryString(2, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 0))\n\tassert.Equal(3, countPermutationsOfBinaryString(3, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 2))\n\tassert.Equal(145422675, countPermutationsOfBinaryString(30, 2))\n\tassert.Equal(4, countPermutationsOfBinaryString(4, 2))\n\tassert.Equal(1, countPermutationsOfBinaryString(5, 5))\n\tassert.Equal(13884156, countPermutationsOfBinaryString(33, 17))\n\tassert.Equal(1, countPermutationsOfBinaryString(1000000, 1000000))\n\t// Add more test cases if necessary\n}",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "func countPermutationsOfBinaryString(n, m int) int",
    "docstring": {
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\nint: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nيعيد:\nint: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n\nInarejesha:\nint: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizgenin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı ise n - m olan farklı permütasyon düzenlerinin sayısını hesaplayın.\n\nParametreler:\n- n (int): İkili dizgenin uzunluğu.\n- m (int): İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon düzenlerinin toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nint: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9808319695997523",
      "sw": "0.9621329055291279",
      "tr": "0.9633185302735251",
      "vi": "0.9963775777410667"
    }
  },
  {
    "task_id": "Go/19",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nResponde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver según el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\nSe supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n*/\nfunc answerQuestions() string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nأجب عن سلسلة من الأسئلة بتقديم خيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع بيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع بيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.\n*/\nfunc answerQuestions() string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSwali la 2:\nUkipata 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n    A. Maelezo ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maelezo ya kufuta pointer ni thamani za kushoto.\n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinapewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujipigia yenyewe kutoka ndani ya mwili wake.\nSwali la 5:\nNi kauli gani kuhusu pointer si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti ya thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n*/\nfunc answerQuestions() string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Önek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerleri arasındaki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n*/\nfunc answerQuestions() string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\nCâu hỏi 1:\nHằng số như 1e6 thuộc loại dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, loại dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có loại nào trong số trên\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong stack.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ trong thân hàm.\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n*/\nfunc answerQuestions() string {"
    },
    "prompt_bertscore": {
      "es": "0.9517673790948222",
      "arb": "0.9506876243435166",
      "sw": "0.9165160481117985",
      "tr": "0.9417270105942707",
      "vi": "0.9357257908920636"
    },
    "canonical_solution": "return \"DDDBA\"\n}",
    "instruction": {
      "es": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nGo kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.907135728367426",
      "sw": "0.9102365472457616",
      "tr": "0.8715266640681585",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestAnswerQuestions(t *testing.T) {\n\texpectedAnswers := \"DDDBA\"\n\tactualAnswers := answerQuestions()\n\n\tassert.Equal(t, expectedAnswers, actualAnswers, \"they should be equal\")\n}",
    "entry_point": "answerQuestions",
    "signature": "func answerQuestions() string",
    "docstring": {
      "es": "Responde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores de la izquierda en las expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores de la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor de la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores de la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores de la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "الإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n    C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسرى.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهم.\n    B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعود فقط بسلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.  \nSwali la 1:  \nKonstanti kama 1e6 ni ya aina gani ya data?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nSwali la 2:  \nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Hakuna kati ya hapo juu  \nSwali la 3:  \nNi kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?  \n    A. Maelezo ya jina la kigezo ni thamani za kushoto.  \n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.  \n    C. Maelezo ya kufuta pointer ni thamani za kushoto.  \n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.  \nSwali la 4:  \nNi kauli gani kuhusu kazi si sahihi?  \n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.  \n    B. Vigezo vya ndani vinapewa nafasi kwenye stack.  \n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.  \n    D. Kazi inaweza kujipa simu kutoka ndani ya mwili wake.  \nSwali la 5:  \nNi kauli gani kuhusu pointers si sahihi?  \n    A. Kuondoa pointers mbili ni sawa na tofauti ya thamani za anwani zao.  \n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.  \n    C. int *p[4], p ni safu ya pointers za int.  \n    D. Majina ya kazi yanaweza kupewa pointers za kazi.  \nUnapaswa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Sorulara A, B, C veya D seçeneklerini vererek cevap verin.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. İşaretçi çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içerisinden kendisini çağırabilir.\nSoru 5:\nİşaretçiler hakkında hangi ifade yanlıştır?\n    A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. İşaretçi çözme, işaretçinin türüne göre çözmeyi içerir.\n    C. int *p[4], p bir dizi int işaretçisidir.\n    D. Fonksiyon isimleri, fonksiyon işaretçilerine atanabilir.\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.  \nCâu hỏi 1:  \nCác hằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có cái nào ở trên  \nCâu hỏi 3:  \nCâu nào về giá trị trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị trái.  \n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị trái.  \n    D. Biểu thức phép toán tăng tiền tố là giá trị trái.  \nCâu hỏi 4:  \nCâu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu của hàm giống với kiểu giá trị trả về.  \n    D. Một hàm có thể tự gọi từ bên trong thân của nó.  \nCâu hỏi 5:  \nCâu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng các con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9617813297546961",
      "arb": "0.952626058232036",
      "sw": "0.896421009723261",
      "tr": "0.945502974137744",
      "vi": "0.947746702921914"
    }
  },
  {
    "task_id": "Go/20",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square determina si es posible ensamblar los cuadrados de madera de n cubos,\ndonde cada cubo contiene un número específico de cuadrados con una longitud de lado de 1, en un solo cuadrado más grande.\nLa función toma la longitud de la lista y un arreglo de números como entradas.\n\nEjemplos de uso:\n    IsSquare(1, []int{9})             // Salida: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على عدد محدد من المربعات بطول ضلع 1، في مربع أكبر واحد.\nتأخذ الدالة طول القائمة ومصفوفة من الأرقام كمدخلات.\n\nأمثلة الاستخدام:\n    IsSquare(1, []int{9})             // الناتج: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square huamua kama inawezekana kukusanya miraba ya mbao kutoka n ndoo,\nambapo kila ndoo ina idadi maalum ya miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\nKazi hii inachukua urefu wa orodha na safu ya namba kama ingizo.\n\nMifano ya matumizi:\n    IsSquare(1, []int{9})             // Matokeo: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square, her bir kovada 1 birim kenar uzunluğuna sahip belirli sayıda kare bulunan n kovadan\nahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\nFonksiyon, listenin uzunluğunu ve bir sayı dizisini girdi olarak alır.\n\nKullanım örnekleri:\n    IsSquare(1, []int{9})             // Çıktı: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square xác định xem có thể lắp ráp các hình vuông gỗ từ n xô,\ntrong đó mỗi xô chứa một số lượng hình vuông nhất định với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất.\nHàm nhận độ dài của danh sách và một mảng số làm đầu vào.\n\nVí dụ sử dụng:\n    IsSquare(1, []int{9})             // Ra: true\n*/\nfunc IsSquare(length int, squares []int) bool {"
    },
    "prompt_bertscore": {
      "es": "0.9875518340205436",
      "arb": "0.9830238558544723",
      "sw": "0.9851678721873628",
      "tr": "0.9596895532120178",
      "vi": "0.9765989575495178"
    },
    "canonical_solution": "sum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}",
    "instruction": {
      "es": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nAşağıdaki Go kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9025638528871459",
      "sw": "0.9150640600264335",
      "tr": "0.888797575699142",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestIsSquare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(IsSquare(1, []int{9}))\n\tassert.True(IsSquare(2, []int{14, 2}))\n\tassert.False(IsSquare(2, []int{7, 7}))\n\tassert.False(IsSquare(7, []int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.True(IsSquare(6, []int{1, 3, 5, 7, 9, 11}))\n\tassert.False(IsSquare(4, []int{2, 2, 2, 2}))\n\n\t// Additional test cases\n\tassert.False(IsSquare(3, []int{4, 5, 6}))\n\tassert.False(IsSquare(4, []int{16, 9, 4, 1}))\n\tassert.False(IsSquare(5, []int{1, 1, 1, 1, 1}))\n\tassert.False(IsSquare(2, []int{25, 25}))\n\tassert.True(IsSquare(3, []int{10, 10, 5}))\n}",
    "entry_point": "IsSquare",
    "signature": "func IsSquare(length int, squares []int) bool",
    "docstring": {
      "es": "Is_Square determina si es posible ensamblar los cuadrados de madera de n cubetas, donde cada cubeta contiene un número específico de cuadrados con una longitud de lado de 1, en un solo cuadrado más grande. La función toma la longitud de la lista y un arreglo de números como entradas.\n\nEjemplos de uso:\n    IsSquare(1, []int{9})             // Salida: true",
      "arb": "Is_Square يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء، حيث يحتوي كل دلو على عدد محدد من المربعات بطول جانب 1، في مربع أكبر واحد. تأخذ الدالة طول القائمة ومصفوفة من الأرقام كمدخلات.\n\nأمثلة الاستخدام:\n    IsSquare(1, []int{9})             // المخرجات: true",
      "sw": "Is_Square huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo, ambapo kila ndoo ina idadi maalum ya miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi. Kazi hii inachukua urefu wa orodha na safu ya namba kama pembejeo.\n\nMifano ya matumizi:\n    IsSquare(1, []int{9})             // Matokeo: true",
      "tr": "Is_Square, n kovadan ahşap karelerin monte edilip edilemeyeceğini belirler,\nburada her kova, kenar uzunluğu 1 olan belirli sayıda kare içerir ve bu kareler tek bir büyük kare oluşturmak için kullanılır.\nFonksiyon, listenin uzunluğunu ve bir sayı dizisini girdi olarak alır.\n\nKullanım örnekleri:\n    IsSquare(1, []int{9})             // Çıktı: true",
      "vi": "Is_Square xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng, trong đó mỗi thùng chứa một số lượng hình vuông nhất định với độ dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không. Hàm nhận độ dài của danh sách và một mảng số làm đầu vào.\n\nVí dụ sử dụng:\n    IsSquare(1, []int{9})             // Ra: true"
    },
    "docstring_bertscore": {
      "es": "0.9894801377596303",
      "arb": "0.985965969058361",
      "sw": "0.9654877726648071",
      "tr": "0.9345967758062613",
      "vi": "0.9633302494660062"
    }
  },
  {
    "task_id": "Go/21",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra\ny devuelve el posible valor de a donde a <= b. Si hay\nmúltiples grupos, muestra el grupo con el menor a. Si no\nexiste un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un posible valor de a, o -1 si no existen pares válidos.\n\nEjemplos:\n    findIntegers(7,11) // devuelve -1\n*/\nfunc findIntegers(c int, d int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى عددان صحيحان c و d، حيث a + b = c و a * b = d، ابحث\nوأعد القيمة الممكنة لـ a حيث a <= b. إذا كانت هناك\nمجموعات متعددة، أخرج المجموعة التي تحتوي على أصغر a. إذا لم\nتوجد زوج صالح، أعد -1.\n\nالمعطيات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالإرجاع:\n- int: قيمة ممكنة لـ a، أو -1 إذا لم توجد أزواج صالحة.\n\nأمثلة:\n    findIntegers(7,11) // يعيد -1\n*/\nfunc findIntegers(c int, d int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta\nna rudisha thamani inayowezekana ya a ambapo a <= b. Ikiwa kuna\nmakundi mengi, toa kundi lenye a ndogo zaidi. Ikiwa hakuna\njozi halali, rudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudi:\n- int: Thamani inayowezekana ya a, au -1 ikiwa hakuna jozi halali.\n\nMifano:\n    findIntegers(7,11) // inarudi -1\n*/\nfunc findIntegers(c int, d int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın\na <= b olduğu olası değerini bulun ve döndürün. Birden fazla grup\nvarsa, en küçük a'ya sahip olan grubu çıkartın. Geçerli bir çift\nyoksa, -1 döndürün.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürülenler:\n- int: a'nın olası bir değeri veya geçerli çift yoksa -1.\n\nÖrnekler:\n    findIntegers(7,11) // -1 döndürür\n*/\nfunc findIntegers(c int, d int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm\nvà trả về giá trị có thể của a sao cho a <= b. Nếu có nhiều nhóm,\nxuất nhóm có a nhỏ nhất. Nếu không tồn tại cặp hợp lệ, trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a, hoặc -1 nếu không tồn tại cặp hợp lệ.\n\nVí dụ:\n    findIntegers(7,11) // trả về -1\n*/\nfunc findIntegers(c int, d int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9873148679759689",
      "arb": "0.9850038034926281",
      "sw": "0.9758084086329989",
      "tr": "0.9820311012100599",
      "vi": "0.9923547166339671"
    },
    "canonical_solution": "for i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "es": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9164371918505277",
      "sw": "0.9102365472457616",
      "tr": "0.8457458310224972",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestFindIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, findIntegers(5, 6))\n\tassert.Equal(3, findIntegers(6, 9))\n\tassert.Equal(3, findIntegers(7, 12))\n\tassert.Equal(-1, findIntegers(7, 11))\n\tassert.Equal(1, findIntegers(9, 8))\n\tassert.Equal(5, findIntegers(10, 25))\n\tassert.Equal(-1, findIntegers(10000, 8765))\n}",
    "entry_point": "findIntegers",
    "signature": "func findIntegers(c int, d int) int",
    "docstring": {
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a donde a <= b. Si hay múltiples grupos, muestra el grupo con el menor a. Si no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a, o -1 si no existen pares válidos.\n\nEjemplos:\n    findIntegers(7,11) // devuelve -1",
      "arb": "إعطاء الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة المحتملة لـ a حيث a <= b. إذا كانت هناك مجموعات متعددة، أخرج المجموعة التي تحتوي على أصغر قيمة لـ a. إذا لم يكن هناك زوج صالح، أعد -1.\n\nالمعلمات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة محتملة لـ a، أو -1 إذا لم تكن هناك أزواج صالحة.\n\nأمثلة:\n    findIntegers(7,11) // يعيد -1",
      "sw": "Kwa kupewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a ambapo a <= b. Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi. Ikiwa hakuna jozi halali, rudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarudi:\n- int: Thamani inayowezekana ya a, au -1 ikiwa hakuna jozi halali.\n\nMifano:\n    findIntegers(7,11) // inarudisha -1",
      "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın mümkün olan değerini bulun ve döndürün, burada a <= b. Birden fazla grup varsa, en küçük a'ya sahip grubu çıktılayın. Geçerli bir çift yoksa, -1 döndürün.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürülenler:\n- int: a'nın olası bir değeri veya geçerli çift yoksa -1.\n\nÖrnekler:\n    findIntegers(7,11) // -1 döndürür",
      "vi": "Given integers c and d, nơi a + b = c và a * b = d, tìm và trả về giá trị có thể của a nơi a <= b. Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất. Nếu không có cặp hợp lệ nào tồn tại, trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể của a, hoặc -1 nếu không có cặp hợp lệ nào tồn tại.\n\nVí dụ:\n    findIntegers(7,11) // trả về -1"
    },
    "docstring_bertscore": {
      "es": "0.979207967604411",
      "arb": "0.9654073273604881",
      "sw": "0.9639408392573074",
      "tr": "0.9793851459042942",
      "vi": "0.9862730516274409"
    }
  },
  {
    "task_id": "Go/22",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado tres dígitos a, b, c donde dos son idénticos y el tercero es diferente,\nencuentra el valor único.\n\nEjemplos:\n    extraNumber(0, 0, 1) debería devolver 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى ثلاثة أرقام a، b، c حيث اثنان منهما متطابقان والثالث مختلف،\nابحث عن القيمة الفريدة.\n\nأمثلة:\n    extraNumber(0, 0, 1) يجب أن تعيد 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kuwa na tarakimu tatu a, b, c ambapo mbili zinafanana na ya tatu ni tofauti,\ntafuta thamani ya kipekee.\n\nMifano:\n    extraNumber(0, 0, 1) inapaswa kurudisha 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç basamaklı a, b, c verildiğinde, bunlardan ikisi aynı ve üçüncüsü farklıdır,\nbenzersiz değeri bulun.\n\nÖrnekler:\n    extraNumber(0, 0, 1) 1 döndürmelidir\n*/\nfunc extraNumber(a, b, c int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho ba chữ số a, b, c trong đó hai số giống nhau và số thứ ba khác,\ntìm giá trị duy nhất.\n\nVí dụ:\n    extraNumber(0, 0, 1) nên trả về 1\n*/\nfunc extraNumber(a, b, c int) int {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9841820696062866",
      "sw": "0.9914725991117912",
      "tr": "0.968441803691558",
      "vi": "0.9768700880196304"
    },
    "canonical_solution": "if a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}",
    "instruction": {
      "es": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8952355836092448",
      "sw": "0.9102365472457616",
      "tr": "0.8491257255861869",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestExtraNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7, extraNumber(2, 7, 2), \"Extra number should be 7\")\n\tassert.Equal(3, extraNumber(3, 2, 2), \"Extra number should be 3\")\n\tassert.Equal(1, extraNumber(5, 5, 1), \"Extra number should be 1\")\n\tassert.Equal(3, extraNumber(500000000, 3, 500000000), \"Extra number should be 3\")\n\tassert.Equal(3, extraNumber(500000000, 500000000, 3), \"Extra number should be 3\")\n}",
    "entry_point": "extraNumber",
    "signature": "func extraNumber(a, b, c int) int",
    "docstring": {
      "es": "Dado tres dígitos a, b, c donde dos son idénticos y el tercero es diferente, encuentra el valor único.\n\nEjemplos:\n    extraNumber(0, 0, 1) debería devolver 1",
      "arb": "المعطى ثلاثة أرقام a، b، c حيث أن اثنين منهما متطابقان والثالث مختلف، \nابحث عن القيمة الفريدة.\n\nأمثلة:\n    extraNumber(0, 0, 1) يجب أن تُرجع 1",
      "sw": "Kutolewa tarakimu tatu a, b, c ambapo mbili zinafanana na ya tatu ni tofauti, pata thamani ya kipekee.\n\nMifano:\n    extraNumber(0, 0, 1) inapaswa kurudisha 1",
      "tr": "Üç rakam a, b, c verildiğinde, bunlardan ikisi özdeş ve üçüncüsü farklıdır,\nbenzersiz değeri bulun.\n\nÖrnekler:\n    extraNumber(0, 0, 1) 1 döndürmelidir.",
      "vi": "Được cho ba chữ số a, b, c trong đó hai chữ số giống nhau và chữ số thứ ba khác biệt, tìm giá trị duy nhất.\n\nVí dụ:\n    extraNumber(0, 0, 1) sẽ trả về 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9715650678029506",
      "sw": "0.9779577879861774",
      "tr": "0.9664793355269333",
      "vi": "0.9488902180255319"
    }
  },
  {
    "task_id": "Go/23",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgumentos:\n- edges: Una porción de enteros que representa las longitudes de los lados.\n\nDevuelve:\nint: El conteo de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "arb": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nالمعطيات:\n- edges: قائمة من الأعداد الصحيحة تمثل أطوال الحواف.\n\nالإرجاع:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "sw": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHesabu idadi ya pembetatu kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 kutoka kwenye seti ya kingo zilizotolewa.\n\nHoja:\n- edges: Sehemu ya nambari nzima inayowakilisha urefu wa kingo.\n\nInarudi:\nint: Idadi ya pembetatu kali tofauti ambazo zinaweza kuundwa.\n\nMifano:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "tr": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges: Kenarların uzunluklarını temsil eden bir tamsayı dilimi.\n\nDöndürür:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "vi": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nTham số:\n- edges: Một slice của số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9664497396001591",
      "arb": "0.9699152438580748",
      "sw": "0.9694258185992048",
      "tr": "0.9664014724175676",
      "vi": "0.9601112455109548"
    },
    "canonical_solution": "sort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}",
    "instruction": {
      "es": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9231167343039689",
      "sw": "0.9425243129437447",
      "tr": "0.8758770666735846",
      "vi": "0.8987928551031986"
    },
    "level": "",
    "test": "func TestCountAcuteTriangles(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, countAcuteTriangles([]int{1, 1, 1, 1}))\n\tassert.Equal(0, countAcuteTriangles([]int{1, 2, 3}))\n\t// Additional tests to ensure correctness\n\tassert.Equal(0, countAcuteTriangles([]int{3, 4, 5, 7, 10}))\n\tassert.Equal(4, countAcuteTriangles([]int{6, 8, 10, 5, 5, 5}))\n}",
    "entry_point": "countAcuteTriangles",
    "signature": "func countAcuteTriangles(edges []int) int",
    "docstring": {
      "es": "Contar el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgumentos:\n- edges: Un segmento de enteros que representa las longitudes de los lados.\n\nDevuelve:\nint: El conteo de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "arb": "احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nالحجج:\n- edges: مجموعة من الأعداد الصحيحة تمثل أطوال الحواف.\n\nالإرجاع:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 kutoka kwenye seti iliyotolewa ya kingo.\n\nHoja:\n- edges: Sehemu ya nambari za mzima zinazowakilisha urefu wa kingo.\n\nInarudisha:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "tr": "Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayın.\n\nArgümanlar:\n- edges: Kenarların uzunluklarını temsil eden bir tamsayı dilimi.\n\nDöndürür:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges: Một mảng các số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4"
    },
    "docstring_bertscore": {
      "es": "0.9476048808298552",
      "arb": "0.9631097697430575",
      "sw": "0.9632639069187405",
      "tr": "0.9556124660108956",
      "vi": "0.927176540661941"
    }
  },
  {
    "task_id": "Go/24",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar lee un entero y un carácter, luego los devuelve\ncomo una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (rune): El carácter de entrada.\nDevuelve:\n- string: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplos:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Salida: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "arb": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما\nكسلسلة نصية منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (rune): الحرف المدخل.\nيعيد:\n- string: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nأمثلة:\n    fmt.Println(processIntegerAndChar(234, 'H')) // الناتج: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "sw": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar husoma nambari nzima na herufi, kisha inazirudisha\nkama string iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (rune): Herufi ya ingizo.\nInarudisha:\n- string: String inayojumuisha nambari nzima na herufi zikitenganishwa na koma.\n\nMifano:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Matokeo: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "tr": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar bir tam sayı ve bir karakter okur, ardından\nbunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Giriş tam sayısı.\n- char_value (rune): Giriş karakteri.\nDöndürür:\n- string: Tam sayı ve karakteri virgülle ayrılmış bir dize.\n\nÖrnekler:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Çıktı: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "vi": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar đọc một số nguyên và một ký tự, sau đó trả về chúng\nnhư một chuỗi định dạng được phân tách bằng dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (rune): Ký tự đầu vào.\nTrả về:\n- string: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ra: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {"
    },
    "prompt_bertscore": {
      "es": "0.9958510086009432",
      "arb": "1",
      "sw": "0.9845048439754683",
      "tr": "0.9862881475363996",
      "vi": "0.9988934301472546"
    },
    "canonical_solution": "return fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}",
    "instruction": {
      "es": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9102365472457616",
      "tr": "0.8563596454330965",
      "vi": "0.9181495843654295"
    },
    "level": "",
    "test": "func TestProcessIntegerAndChar(t *testing.T) {\n\tassert := assert.New(t)\n\n\t// Test 1\n\toutput1 := processIntegerAndChar(234, 'H')\n\tassert.Equal(\"234,H\", output1)\n\n\t// Additional tests can be added here with different input values\n\t// Test 2\n\toutput2 := processIntegerAndChar(123, 'A')\n\tassert.Equal(\"123,A\", output2)\n\n\t// Test 3\n\toutput3 := processIntegerAndChar(0, 'Z')\n\tassert.Equal(\"0,Z\", output3)\n}",
    "entry_point": "processIntegerAndChar",
    "signature": "func processIntegerAndChar(integerValue int, charValue rune) string",
    "docstring": {
      "es": "processIntegerAndChar lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.  \nParámetros:  \n- integer_value (int): El entero de entrada.  \n- char_value (rune): El carácter de entrada.  \nDevuelve:  \n- string: Una cadena que contiene el entero y el carácter separados por una coma.  \n\nEjemplos:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // Salida: \"234,H\"",
      "arb": "processIntegerAndChar يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (rune): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nأمثلة:\n    fmt.Println(processIntegerAndChar(234, 'H')) // الناتج: \"234,H\"",
      "sw": "processIntegerAndChar husoma nambari kamili na herufi, kisha inazirudisha kama mfuatano wa maandishi uliopangwa kwa koma.\n\nVigezo:\n- integer_value (int): Nambari kamili ya pembejeo.\n- char_value (rune): Herufi ya pembejeo.\n\nInarejesha:\n- string: Mfuatano wa maandishi unao na nambari kamili na herufi zilizotenganishwa na koma.\n\nMifano:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Matokeo: \"234,H\"",
      "tr": "processIntegerAndChar bir tamsayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tamsayısı.\n- char_value (rune): Girdi karakteri.\nDöndürülenler:\n- string: Tamsayı ve karakteri virgülle ayrılmış bir dize içeren bir string.\n\nÖrnekler:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Çıktı: \"234,H\"",
      "vi": "processIntegerAndChar đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.  \nTham số:  \n- integer_value (int): Số nguyên đầu vào.  \n- char_value (rune): Ký tự đầu vào.  \nTrả về:  \n- string: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.  \n\nVí dụ:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // Ra: \"234,H\"  "
    },
    "docstring_bertscore": {
      "es": "0.9960565910453144",
      "arb": "0.9934763823956712",
      "sw": "0.9699039219263558",
      "tr": "0.9773019104680002",
      "vi": "0.9859685512533145"
    }
  },
  {
    "task_id": "Go/25",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético.\nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (str): El texto de entrada a ser procesado.\n\nDevuelve:\nstr: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tdevuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nيقوم بتحويل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\nيتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعطيات:\ntext (str): النص المدخل الذي سيتم معالجته.\n\nالإرجاع:\nstr: النص المحول مع الأحرف التي تم تحويلها بمقدار 5 مواقع.\n\nمثال:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tيعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\nNi herufi pekee ndizo hubadilishwa, na herufi zote ni za herufi kubwa.\n\nVigezo:\ntext (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n\nInarejesha:\nstr: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\nMfano:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tinarejesha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTüm karakterleri alfabetik sırayla 5 pozisyon kaydırır.\nSadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (str): İşlenecek giriş metni.\n\nDöndürür:\nstr: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döner\n*/\nfunc shiftCharacters(text string) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái.\nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều là chữ hoa.\n\nTham số:\ntext (str): Văn bản đầu vào cần được xử lý.\n\nTrả về:\nstr: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\nVí dụ:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\ttrả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {"
    },
    "prompt_bertscore": {
      "es": "0.9820964506054204",
      "arb": "0.9870328128348994",
      "sw": "0.9783218774746144",
      "tr": "0.9708354984134094",
      "vi": "0.9807757572019193"
    },
    "canonical_solution": "runes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}",
    "instruction": {
      "es": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9156106908350415",
      "sw": "0.9425243129437447",
      "tr": "0.8457458310224972",
      "vi": "0.9181495843654295"
    },
    "level": "",
    "test": "func TestShiftCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\n\ttest1 := \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n\texpected1 := \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\tassert.Equal(expected1, shiftCharacters(test1), \"Test case 1 failed\")\n\n\ttest2 := \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n\texpected2 := \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\"\n\tassert.Equal(expected2, shiftCharacters(test2), \"Test case 2 failed\")\n\n\ttest3 := \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n\texpected3 := \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\"\n\tassert.Equal(expected3, shiftCharacters(test3), \"Test case 3 failed\")\n}",
    "entry_point": "shiftCharacters",
    "signature": "func shiftCharacters(text string) string",
    "docstring": {
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético.  \nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:  \ntext (str): El texto de entrada a ser procesado.\n\nDevuelve:  \nstr: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tdevuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. \nيتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\nمثال:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tيعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Inasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\nNi herufi pekee ndizo hubadilishwa, na herufi zote ni za herufi kubwa.\n\nVigezo:\ntext (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n\nInarejesha:\nstr: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\nMfano:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tinarejesha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. \nYalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (str): İşlenecek giriş metni.\n\nDöndürür:\nstr: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür.",
      "vi": "Dịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái.  \nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:  \ntext (str): Văn bản đầu vào cần được xử lý.\n\nTrả về:  \nstr: Văn bản đã được chuyển đổi với các ký tự được dịch chuyển 5 vị trí.\n\nVí dụ:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\ttrả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9749715788376989",
      "arb": "0.9920730587536597",
      "sw": "0.999999801369619",
      "tr": "0.9430975602234114",
      "vi": "0.9906860228028931"
    }
  },
  {
    "task_id": "Go/26",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\n    classifyInteger(\"24\") // devuelve 6\n*/\nfunc classifyInteger(x string) int {",
      "arb": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كـ string.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\n    classifyInteger(\"24\") // يعيد 6\n*/\nfunc classifyInteger(x string) int {",
      "sw": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari itakayotambuliwa kama kamba.\n\nInarudisha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\n    classifyInteger(\"24\") // inarudisha 6\n*/\nfunc classifyInteger(x string) int {",
      "tr": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAşağıdaki yönteme göre x tam sayısını sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı bir dize olarak.\n\nDöndürür:\nint: x tam sayısının ait olduğu sınıf.\n\nÖrnekler:\n    classifyInteger(\"24\") // 6 döndürür\n*/\nfunc classifyInteger(x string) int {",
      "vi": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tính tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (string): Số nguyên cần phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\n    classifyInteger(\"24\") // trả về 6\n*/\nfunc classifyInteger(x string) int {"
    },
    "prompt_bertscore": {
      "es": "0.9936243620295422",
      "arb": "0.9778779385730014",
      "sw": "0.9557066168115061",
      "tr": "0.9844758439398372",
      "vi": "0.973708488244698"
    },
    "canonical_solution": "var n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}",
    "instruction": {
      "es": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9081642364804247",
      "sw": "0.9338646242217667",
      "tr": "0.8699094155057724",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestClassifyInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, classifyInteger(\"24\"))\n\tassert.Equal(3, classifyInteger(\"39\"))\n\tassert.Equal(9, classifyInteger(\"123456789\"))\n\tassert.Equal(9, classifyInteger(\"123456789012345678901234567890\"))\n\tassert.Equal(6, classifyInteger(\"12345\"))\n\tassert.Equal(9, classifyInteger(\"999999999\"))\n}",
    "entry_point": "classifyInteger",
    "signature": "func classifyInteger(x string) int",
    "docstring": {
      "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\n    classifyInteger(\"24\") // devuelve 6",
      "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح المراد تصنيفه كسلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\n    classifyInteger(\"24\") // يعيد 6",
      "sw": "Tambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusishwa na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kuhesabiwa kama kamba.\n\nInarejesha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\n    classifyInteger(\"24\") // inarejesha 6",
      "tr": "Aşağıdaki yönteme göre x tam sayısını sınıflandırın: \nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir. \nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.  \nParametreler: \n- x (string): Sınıflandırılacak tamsayı bir dize olarak. \nDöndürülenler: \nint: x tamsayısının ait olduğu sınıf.  \nÖrnekler: \n    classifyInteger(\"24\") // 6 döndürür  ",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, nhận một x mới, và lặp lại cho đến khi lớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\n    classifyInteger(\"24\") // trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9925952580254004",
      "arb": "0.9691284689187956",
      "sw": "0.9489178276484957",
      "tr": "1",
      "vi": "0.986444271015893"
    }
  },
  {
    "task_id": "Go/27",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforma el caso de una letra dada.\n\nParámetros:\n- letter (rune): La letra de entrada que se va a transformar.\n\nDevuelve:\n- rune: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\n  y si la entrada es mayúscula, devuelve la versión en minúscula.\n\nEjemplos:\n\t- TransformLetterCase('b') devuelve 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase يقوم بتحويل حالة الحرف المعطى.\n\nالمعطيات:\n- letter (rune): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- rune: الحرف مع حالته معكوسة. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\n  وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n\nأمثلة:\n\t- TransformLetterCase('b') 'B' يعيد\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase hubadilisha herufi kubwa na ndogo ya herufi iliyotolewa.\n\nVigezo:\n- letter (rune): Herufi ya kuingiza inayopaswa kubadilishwa.\n\nInarudisha:\n- rune: Herufi iliyo na herufi kubwa na ndogo zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\n  na ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n\nMifano:\n\t- TransformLetterCase('b') inarudisha 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nParametreler:\n- letter (rune): Dönüştürülecek giriş harfi.\n\nDöndürür:\n- rune: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\n  ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\n\t- TransformLetterCase('b') 'B' döndürür\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase chuyển đổi kiểu chữ của một chữ cái cho trước.\n\nTham số:\n- letter (rune): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- rune: Chữ cái với kiểu chữ được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\n  và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\n\t- TransformLetterCase('b') trả về 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {"
    },
    "prompt_bertscore": {
      "es": "0.9976359012049227",
      "arb": "0.977169622634231",
      "sw": "0.9717706502473217",
      "tr": "0.9928109706192043",
      "vi": "0.9812653810911703"
    },
    "canonical_solution": "if letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}",
    "instruction": {
      "es": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9109893563898839",
      "sw": "0.9425243129437447",
      "tr": "0.8758770666735846",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestTransformLetterCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(rune('B'), TransformLetterCase('b'), \"Lowercase 'b' should transform to uppercase 'B'\")\n\tassert.Equal(rune('b'), TransformLetterCase('B'), \"Uppercase 'B' should transform to lowercase 'b'\")\n\n\t// Additional test cases\n\tassert.Equal(rune('Z'), TransformLetterCase('z'), \"Lowercase 'z' should transform to uppercase 'Z'\")\n\tassert.Equal(rune('z'), TransformLetterCase('Z'), \"Uppercase 'Z' should transform to lowercase 'z'\")\n\tassert.Equal(rune('M'), TransformLetterCase('m'), \"Lowercase 'm' should transform to uppercase 'M'\")\n\tassert.Equal(rune('m'), TransformLetterCase('M'), \"Uppercase 'M' should transform to lowercase 'm'\")\n\tassert.Equal(rune('1'), TransformLetterCase('1'), \"Non-alphabetic '1' should remain unchanged\")\n\tassert.Equal(rune('!'), TransformLetterCase('!'), \"Non-alphabetic '!' should remain unchanged\")\n}",
    "entry_point": "TransformLetterCase",
    "signature": "func TransformLetterCase(letter rune) rune",
    "docstring": {
      "es": "TransformLetterCase transforma el caso de una letra dada.\n\nParámetros:\n- letter (rune): La letra de entrada a ser transformada.\n\nDevuelve:\n- rune: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\n  y si la entrada es mayúscula, devuelve la versión en minúscula.\n\nEjemplos:\n\t- TransformLetterCase('b') devuelve 'B'",
      "arb": "TransformLetterCase يحول حالة الحرف المعطى.\n\nالمعلمات:\n- letter (rune): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- rune: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة بحروف كبيرة،\n  وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة بحروف صغيرة.\n\nأمثلة:\n\t- TransformLetterCase('b') 'B' يعيد",
      "sw": "TransformLetterCase hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n\nVigezo:\n- letter (rune): Herufi ya kuingiza itakayobadilishwa.\n\nInarejesha:\n- rune: Herufi yenye herufi kubwa au ndogo iliyobadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,\n  na ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n\nMifano:\n\t- TransformLetterCase('b') inarejesha 'B'",
      "tr": "TransformLetterCase verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nParametreler:\n- letter (rune): Dönüştürülecek giriş harfi.\n\nDöndürülenler:\n- rune: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\n  ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\n\t- TransformLetterCase('b') 'B' döndürür.",
      "vi": "TransformLetterCase chuyển đổi kiểu chữ của một chữ cái cho trước.\n\nTham số:\n- letter (rune): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- rune: Chữ cái với kiểu chữ được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\n  và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\n\t- TransformLetterCase('b') trả về 'B'"
    },
    "docstring_bertscore": {
      "es": "0.9966681739885208",
      "arb": "0.9794451322793667",
      "sw": "0.9237942625336789",
      "tr": "0.9875252175494849",
      "vi": "0.9758616415751162"
    }
  },
  {
    "task_id": "Go/28",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo devuelve el código ASCII para un carácter dado.\n\nParámetros:\n- character: El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n- El código ASCII correspondiente.\n\nEjemplos:\n\tDisplayASCIIInfo('A') // devuelve 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo يعيد الرمز ASCII لحرف معين.\n\nالمعلمات:\n- character: الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nيعيد:\n- الرمز ASCII المقابل.\n\nأمثلة:\n\tDisplayASCIIInfo('A') // يعيد 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo inarudisha msimbo wa ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character: Herufi ya ingizo ambayo taarifa ya ASCII itatolewa.\n\nInarudisha:\n- Msimbo wa ASCII unaolingana.\n\nMifano:\n\tDisplayASCIIInfo('A') // inarudisha 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo, verilen bir karakter için ASCII kodunu döndürür.\n\nParametreler:\n- character: ASCII bilgisinin gösterileceği giriş karakteri.\n\nDöndürür:\n- Karşılık gelen ASCII kodu.\n\nÖrnekler:\n\tDisplayASCIIInfo('A') // 65 döndürür\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo trả về mã ASCII cho một ký tự cho trước.\n\nTham số:\n- character: Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:\n- Mã ASCII tương ứng.\n\nVí dụ:\n\tDisplayASCIIInfo('A') // trả về 65\n*/\nfunc DisplayASCIIInfo(character rune) int {"
    },
    "prompt_bertscore": {
      "es": "0.9877746973080647",
      "arb": "0.9826434786747904",
      "sw": "0.9758248949546248",
      "tr": "0.9787511177280308",
      "vi": "0.9741871874629922"
    },
    "canonical_solution": "return int(character)\n}",
    "instruction": {
      "es": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nGo kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9025638528871459",
      "sw": "0.9338646242217667",
      "tr": "0.8829046095545989",
      "vi": "0.9290414813094776"
    },
    "level": "",
    "test": "func TestDisplayASCIIInfo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(65, DisplayASCIIInfo('A'), \"ASCII value for 'A' should be 65\")\n\tassert.Equal(66, DisplayASCIIInfo('B'), \"ASCII value for 'B' should be 66\") // Additional test case\n\tassert.Equal(48, DisplayASCIIInfo('0'), \"ASCII value for '0' should be 48\") // Additional test case\n\tassert.Equal(32, DisplayASCIIInfo(' '), \"ASCII value for ' ' should be 32\") // Additional test case\n}",
    "entry_point": "DisplayASCIIInfo",
    "signature": "func DisplayASCIIInfo(character rune) int",
    "docstring": {
      "es": "DisplayASCIIInfo devuelve el código ASCII para un carácter dado.\n\nParámetros:\n- character: El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n- El código ASCII correspondiente.\n\nEjemplos:\n\tDisplayASCIIInfo('A') // devuelve 65",
      "arb": "DisplayASCIIInfo يعيد رمز ASCII للحرف المعطى.\n\nالمعلمات:\n- character: الحرف المدخل الذي سيتم عرض معلومات ASCII الخاصة به.\n\nالقيم المعادة:\n- رمز ASCII المقابل.\n\nأمثلة:\n\tDisplayASCIIInfo('A') // يعيد 65",
      "sw": "DisplayASCIIInfo inarudisha msimbo wa ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character: Herufi ya ingizo ambayo taarifa ya ASCII inapaswa kuonyeshwa.\n\nInarudisha:\n- Msimbo wa ASCII unaolingana.\n\nMifano:\n\tDisplayASCIIInfo('A') // inarudisha 65",
      "tr": "DisplayASCIIInfo, verilen bir karakter için ASCII kodunu döndürür.\n\nParametreler:\n- character: ASCII bilgisinin görüntüleneceği giriş karakteri.\n\nDöndürülenler:\n- Karşılık gelen ASCII kodu.\n\nÖrnekler:\n\tDisplayASCIIInfo('A') // 65 döndürür",
      "vi": "DisplayASCIIInfo trả về mã ASCII cho một ký tự cho trước.\n\nTham số:\n- character: Ký tự đầu vào mà thông tin ASCII sẽ được hiển thị.\n\nTrả về:\n- Mã ASCII tương ứng.\n\nVí dụ:\n\tDisplayASCIIInfo('A') // trả về 65"
    },
    "docstring_bertscore": {
      "es": "0.972569541639844",
      "arb": "0.9580738936926799",
      "sw": "0.9790460838438676",
      "tr": "0.9647363539333521",
      "vi": "0.970343292329205"
    }
  },
  {
    "task_id": "Go/29",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvalúa la calificación para un entero de entrada.\nParámetros:\n- score (int): La puntuación entera a evaluar.\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n         De lo contrario, devuelve 'B'.\n\t Ejemplo:\n\t\tevaluateIntegerGrade(90) // Devuelve 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتقييم الدرجة لعدد صحيح مُدخل.\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\nالإرجاع:\n    char: الدرجة المقابلة للدرجة المدخلة.\n         إذا كانت الدرجة بين 90 و 100 (شاملة)، تُرجع 'A'.\n         خلاف ذلك، تُرجع 'B'.\n\t مثال:\n\t\tevaluateIntegerGrade(90) // 'A' يعيد\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua alama kwa nambari kamili ya pembejeo.\nVigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\nInarudisha:\n    char: Alama inayolingana na alama ya pembejeo.\n         Ikiwa alama iko kati ya 90 na 100 (ikijumuishwa), inarudisha 'A'.\n         Vinginevyo, inarudisha 'B'.\n\t Mfano:\n\t\tevaluateIntegerGrade(90) // Inarudisha 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir tamsayı notunu değerlendir.\nParametreler:\n- score (int): Değerlendirilecek tamsayı notu.\nDöndürülen:\n    char: Girdi notuna karşılık gelen harf notu.\n         Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n         Aksi takdirde, 'B' döner.\n\t Örnek:\n\t\tevaluateIntegerGrade(90) // 'A' döner\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nĐánh giá điểm cho một số nguyên đầu vào.\nTham số:\n- score (int): Điểm số nguyên cần được đánh giá.\nTrả về:\n    char: Điểm tương ứng với điểm số đầu vào.\n         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n         Ngược lại, trả về 'B'.\n\t Ví dụ:\n\t\tevaluateIntegerGrade(90) // Trả về 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {"
    },
    "prompt_bertscore": {
      "es": "0.9925916826785418",
      "arb": "1",
      "sw": "0.9852467284486337",
      "tr": "0.9781369525898709",
      "vi": "0.9689129549553728"
    },
    "canonical_solution": "if 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}",
    "instruction": {
      "es": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español usando un máximo de 500 caracteres.",
      "arb": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9047352802126194",
      "sw": "0.9338646242217667",
      "tr": "0.8561933918041703",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestEvaluateIntegerGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal('A', evaluateIntegerGrade(90))\n\tassert.Equal('B', evaluateIntegerGrade(89))\n\tassert.Equal('A', evaluateIntegerGrade(95))\n\tassert.Equal('A', evaluateIntegerGrade(100))\n\tassert.Equal('B', evaluateIntegerGrade(101))\n}",
    "entry_point": "evaluateIntegerGrade",
    "signature": "func evaluateIntegerGrade(score int) rune",
    "docstring": {
      "es": "Evaluar la calificación para un entero de entrada.  \nParámetros:  \n- score (int): La puntuación entera a evaluar.  \nDevuelve:  \n    char: La calificación correspondiente a la puntuación de entrada.  \n         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.  \n         De lo contrario, devuelve 'B'.  \n     Ejemplo:  \n        evaluateIntegerGrade(90) // Devuelve 'A'",
      "arb": "تقييم الدرجة لعدد صحيح مدخل.\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n  char: الدرجة المقابلة للدرجة المدخلة.\n         إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n         خلاف ذلك، تعيد 'B'.\n     مثال:\n        evaluateIntegerGrade(90) // 'A' يعيد",
      "sw": "Tambua alama kwa nambari kamili ya pembejeo.\n\nVigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\n\nInarejesha:\n    char: Alama inayolingana na alama ya pembejeo.\n         Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarejesha 'A'.\n         Vinginevyo, inarejesha 'B'.\n\n     Mfano:\n        evaluateIntegerGrade(90) // Inarejesha 'A'",
      "tr": "Bir tamsayı için notu değerlendirir.\nParametreler:\n- score (int): Değerlendirilecek tamsayı puanı.\nDöndürülen:\n    char: Girdi puanına karşılık gelen not.\n         Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n         Aksi takdirde, 'B' döner.\n     Örnek:\n        evaluateIntegerGrade(90) // 'A' döner",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.  \nTham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \nTrả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n         Ngược lại, trả về 'B'.  \n     Ví dụ:  \n        evaluateIntegerGrade(90) // Trả về 'A'  "
    },
    "docstring_bertscore": {
      "es": "0.9884049515070884",
      "arb": "0.9795923173917135",
      "sw": "0.9852908243932235",
      "tr": "0.9898237683188206",
      "vi": "0.9726738225898873"
    }
  },
  {
    "task_id": "Go/30",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n//\n// Argumentos::\n//\n//\ts (string): La cadena de tres caracteres que se va a verificar.\n//\n// Devuelve:\n//\n//\tstr: Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n//\tEjemplos:\n//\t    checkTwoEqualDigits(\"112\") // devuelve \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متشابهين بالضبط.\n//\n// يعيدالحجج:\n//\n//\ts (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n//\n// يعيد:\n//\n//\tstr: يعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n//\t امثله:\n//\t    checkTwoEqualDigits(\"112\") // يعيد \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits hukagua kama mfuatano wa herufi tatu una herufi mbili sawa kabisa.\n//\n// Hoja:\n//\n//\ts (string): Mfuatano wa herufi tatu wa kukaguliwa.\n//\n// Inarudisha:\n//\n//\tstr: Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa kabisa, vinginevyo \"No\".\n//\tMifano:\n//\t    checkTwoEqualDigits(\"112\") // inarudisha \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n//\n// Argümanlar:\n//\n//\ts (string): Kontrol edilecek üç karakterli dizge.\n//\n// Döndürür:\n//\n//\tstr: Girdi tam olarak iki eşit karaktere sahipse \"Yes\" döndürür, aksi takdirde \"No\".\n//\tÖrnekler:\n//\t    checkTwoEqualDigits(\"112\") // \"Yes\" döndürür\nfunc CheckTwoEqualDigits(s string) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n//\n// Tham số:\n//\n//\ts (string): Chuỗi ba ký tự cần được kiểm tra.\n//\n// Trả về:\n//\n//\tstr: Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, nếu không thì \"No\".\n//\tVí dụ:\n//\t    checkTwoEqualDigits(\"112\") // trả về \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {"
    },
    "prompt_bertscore": {
      "es": "0.985094776207142",
      "arb": "0.9742467765773026",
      "sw": "0.9615384047986905",
      "tr": "0.9800875029316335",
      "vi": "0.9671234938526294"
    },
    "canonical_solution": "if (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}",
    "instruction": {
      "es": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8981149296127265",
      "sw": "0.9338646242217667",
      "tr": "0.8457458310224972",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestCheckTwoEqualDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"112\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"123\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"232\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"444\")) // All three characters are equal, not two.\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"121\"))\n\n\t// Additional test cases to cover more scenarios\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"787\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"999\")) // All three characters are equal\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"890\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"556\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"353\")) // No two characters are equal\n}",
    "entry_point": "CheckTwoEqualDigits",
    "signature": "func CheckTwoEqualDigits(s string) string",
    "docstring": {
      "es": "CheckTwoEqualDigits verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgumentos:\n\n\ts (string): La cadena de tres caracteres a verificar.\n\nDevuelve:\n\n\tstr: Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // devuelve \"Yes\"",
      "arb": "CheckTwoEqualDigits يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nيعيدالحجج:\n\n\ts (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nيعيد:\n\n\tstr: يعيد \"Yes\" إذا كان الإدخال يحتوي على حرفين متطابقين بالضبط، وإلا يعيد \"No\".\n\tامثله:\n\t    checkTwoEqualDigits(\"112\") // يعيد \"Yes\"",
      "sw": "CheckTwoEqualDigits hukagua ikiwa kamba yenye herufi tatu ina herufi mbili sawa.\n\nHoja:\n\n\ts (string): Kamba yenye herufi tatu itakayokaguliwa.\n\nInarudisha:\n\n\tstr: Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n\tMifano:\n\t    checkTwoEqualDigits(\"112\") // inarudisha \"Yes\"",
      "tr": "CheckTwoEqualDigits, üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgümanlar:\n\n\ts (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n\n\tstr: Girdi tam olarak iki eşit karakter içeriyorsa \"Yes\" döner, aksi takdirde \"No\".\n\tÖrnekler:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" döner",
      "vi": "CheckTwoEqualDigits kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n\n\ts (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n\n\tstr: Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự giống nhau, nếu không thì \"No\".\n\tVí dụ:\n\t    checkTwoEqualDigits(\"112\") // trả về \"Yes\""
    },
    "docstring_bertscore": {
      "es": "0.9700842783123355",
      "arb": "0.9588819220827298",
      "sw": "0.9555367878357213",
      "tr": "0.9807978051742142",
      "vi": "0.9713547182294346"
    }
  },
  {
    "task_id": "Go/31",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una cadena que consiste en letras minúsculas del alfabeto inglés,\nen cada ronda, puedes cambiar uno de los caracteres por otro carácter.\nLa pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer\nque la cadena esté compuesta por el mismo carácter?\n\nPor ejemplo:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة،\nفي كل جولة، يمكنك تغيير أحد الأحرف إلى حرف آخر.\nالسؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل\nالسلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa kamba inayojumuisha herufi ndogo za Kiingereza,\nkatika kila raundi, unaweza kubadilisha moja ya herufi kuwa herufi nyingine.\nSwali ni: ni idadi gani ndogo ya raundi zinazohitajika kufanya\nkamba iwe na herufi sawa?\n\nKwa mfano:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKüçük İngiliz harflerinden oluşan bir dize verildiğinde,\nher turda karakterlerden birini başka bir karakterle değiştirebilirsiniz.\nSoru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için\ngerekli minimum tur sayısı nedir?\n\nÖrneğin:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường,\ntrong mỗi vòng, bạn có thể thay đổi một trong các ký tự thành ký tự khác.\nCâu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho\nchuỗi được tạo thành từ cùng một ký tự?\n\nVí dụ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {"
    },
    "prompt_bertscore": {
      "es": "0.9892117881148521",
      "arb": "0.9959245018419262",
      "sw": "0.9855820165318205",
      "tr": "0.990680063891462",
      "vi": "0.9934968413249178"
    },
    "canonical_solution": "var charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}",
    "instruction": {
      "es": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9338646242217667",
      "tr": "0.863991421933219",
      "vi": "0.9181495843654295"
    },
    "level": "",
    "test": "func TestMinRoundsToSameChar(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, minRoundsToSameChar(\"aab\"), \"They should be equal\")\n\tassert.Equal(2, minRoundsToSameChar(\"abc\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"aaa\"), \"They should be equal\")\n\tassert.Equal(1, minRoundsToSameChar(\"abab\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"zzzzz\"), \"They should be equal\")\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "func minRoundsToSameChar(s string) int",
    "docstring": {
      "es": "Dada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda, puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n\nPor ejemplo:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "arb": "بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة، يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "sw": "Kwa kupewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila mzunguko, unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ya chini ya mizunguko inayohitajika ili kufanya kamba iwe na herufi sawa?\n\nKwa mfano:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "tr": "Verilen bir küçük harflerden oluşan İngilizce karakter dizisinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\n\nÖrneğin:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt, bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số lượt tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n\nVí dụ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0"
    },
    "docstring_bertscore": {
      "es": "0.9851603242328835",
      "arb": "0.9947559593102979",
      "sw": "0.9770744786817153",
      "tr": "0.9798793382923089",
      "vi": "0.9764162175989657"
    }
  },
  {
    "task_id": "Go/32",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años,\nel problema es encontrar el año Y_n cuando ocurre el enésimo evento, bajo la\ncondición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año\ninmediatamente posterior a la ocurrencia del evento i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنوات،\nالمشكلة هي إيجاد السنة Y_n عندما يحدث الحدث nth، تحت\nالشرط بأن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة\nالتي تلي مباشرة حدوث الحدث i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i,\ntatizo ni kupata mwaka Y_n ambapo tukio la nth linatokea, chini ya\nhali kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka\nunaofuata mara baada ya tukio i kutokea.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn olaydan oluşan bir dizi verildiğinde, her biri a_i yıl periyoduyla meydana gelen,\nsorun, n. olayın meydana geldiği Y_n yılını bulmaktır. Bu, i+1 olayının geri sayımının\nyalnızca i olayının meydana gelmesinden hemen sonraki yılda başlayabileceği\nşartıyla yapılır.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm,\nvấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, dưới điều kiện\nrằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi\nsự kiện i xảy ra.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.999231697686157",
      "arb": "0.9769880744659651",
      "sw": "0.9636999006051121",
      "tr": "0.954601238741047",
      "vi": "0.9736824676647825"
    },
    "canonical_solution": "year := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}",
    "instruction": {
      "es": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9109893563898839",
      "sw": "0.9425243129437447",
      "tr": "0.8509986114489648",
      "vi": "0.9181495843654295"
    },
    "level": "",
    "test": "func TestApocalypseYear(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(36, apocalypseYear(6, []int{3, 2, 4, 5, 9, 18}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 1, 1, 1, 1}))\n\tassert.Equal(2012, apocalypseYear(6, []int{50, 30, 711, 200, 503, 1006}))\n\tassert.Equal(2, apocalypseYear(2, []int{1, 2}))\n\tassert.Equal(6, apocalypseYear(3, []int{3, 1, 2}))\n\tassert.Equal(4, apocalypseYear(3, []int{2, 3, 4}))\n\tassert.Equal(4, apocalypseYear(4, []int{1, 2, 3, 4}))\n\tassert.Equal(13, apocalypseYear(4, []int{5, 7, 11, 13}))\n\tassert.Equal(10, apocalypseYear(5, []int{2, 2, 2, 2, 2}))\n\tassert.Equal(15, apocalypseYear(3, []int{6, 10, 15}))\n\tassert.Equal(14, apocalypseYear(3, []int{4, 6, 14}))\n\tassert.Equal(800, apocalypseYear(4, []int{50, 30, 711, 200}))\n\tassert.Equal(6, apocalypseYear(6, []int{1, 1, 1, 1, 1, 1}))\n\tassert.Equal(1999998, apocalypseYear(2, []int{1000000, 999999}))\n}",
    "entry_point": "apocalypseYear",
    "signature": "func apocalypseYear(n int, signs []int) int",
    "docstring": {
      "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el enésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente siguiente a la ocurrencia del evento i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار دوري a_i سنوات، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث nth، بشرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "sw": "Ikizingatiwa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la nth linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza tu kuanza katika mwaka unaofuata mara tu baada ya tukio i kutokea.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen, problem n. olayın gerçekleştiği Y_n yılını bulmaktır. Bu, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen ardından başlayabileceği koşuluyla yapılır.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36"
    },
    "docstring_bertscore": {
      "es": "0.9988950191903029",
      "arb": "0.9731251108155986",
      "sw": "0.9577634344071224",
      "tr": "0.9338850831510134",
      "vi": "0.9610146164839014"
    }
  },
  {
    "task_id": "Go/33",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblema: Nueva Operación de Módulo \"⊕\".\nEn esta operación, para x ⊕ y:\n- Si x no es un múltiplo de y, el resultado es x % y.\n- Si x es un múltiplo de y, sigue dividiendo x por y (x = x / y) hasta que x ya no sea un múltiplo.\n  Sea el valor final x'. El resultado es x' % y.\n\nEjemplos:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDado un número primo p y un entero n, calcula el valor de n! ⊕ p,\ndonde n! es el factorial de n (producto de todos los enteros positivos ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nالمشكلة: عملية باقي جديدة \"⊕\".\nفي هذه العملية، لـ x ⊕ y:\n- إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.\n- إذا كان x مضاعفًا لـ y، استمر في تقسيم x على y (x = x / y) حتى لا يكون x مضاعفًا بعد الآن.\n  دع القيمة النهائية تكون x'. النتيجة هي x' % y.\n\nأمثلة:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nمعطى عدد أولي p وعدد صحيح n، احسب قيمة n! ⊕ p،\nحيث n! هو مضروب n (حاصل ضرب جميع الأعداد الصحيحة الموجبة ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTatizo: Operesheni Mpya ya Modulo \"⊕\".\nKatika operesheni hii, kwa x ⊕ y:\n- Ikiwa x si kigezo cha y, matokeo ni x % y.\n- Ikiwa x ni kigezo cha y, endelea kugawa x kwa y (x = x / y) hadi x isiwe tena kigezo.\n  Acha thamani ya mwisho iwe x'. Matokeo ni x' % y.\n\nMifano:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nUkipewa namba ya kwanza p na namba nzima n, hesabu thamani ya n! ⊕ p,\nambapo n! ni factorial ya n (bidhaa ya namba zote chanya ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: Yeni Modulo İşlemi \"⊕\".\nBu işlemde, x ⊕ y için:\n- Eğer x, y'nin katı değilse, sonuç x % y olur.\n- Eğer x, y'nin katıysa, x artık katı olmayana kadar x'i y'ye bölmeye devam edin (x = x / y).\n  Son değere x' diyelim. Sonuç x' % y olur.\n\nÖrnekler:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nVerilen bir asal sayı p ve bir tamsayı n için, n! ⊕ p değerini hesaplayın,\nburada n! n'nin faktöriyelidir (n'ye kadar olan tüm pozitif tamsayıların çarpımı).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVấn đề: Phép toán Modulo Mới \"⊕\".\nTrong phép toán này, đối với x ⊕ y:\n- Nếu x không phải là bội số của y, kết quả là x % y.\n- Nếu x là bội số của y, tiếp tục chia x cho y (x = x / y) cho đến khi x không còn là bội số.\n  Để giá trị cuối cùng là x'. Kết quả là x' % y.\n\nVí dụ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nCho một số nguyên tố p và một số nguyên n, tính giá trị của n! ⊕ p,\ntrong đó n! là giai thừa của n (tích của tất cả các số nguyên dương ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9914946470840861",
      "sw": "0.9781403293063485",
      "tr": "0.9749399966071144",
      "vi": "0.9964522627643358"
    },
    "canonical_solution": "pj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nAşağıdaki Go kodunun doğal dilde açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8962374752511848",
      "sw": "0.9425243129437447",
      "tr": "0.8286864607473159",
      "vi": "0.8796180712699957"
    },
    "level": "",
    "test": "func TestNewModuloFactorial(t *testing.T) {\n\t// Test cases\n\tassert.Equal(t, uint64(6), newModuloFactorial(3, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(10, 3))\n\tassert.Equal(t, uint64(4), newModuloFactorial(11, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(45, 7))\n\tassert.Equal(t, uint64(2), newModuloFactorial(14, 7))\n\tassert.Equal(t, uint64(3152), newModuloFactorial(1919, 10007))\n\tassert.Equal(t, uint64(3679), newModuloFactorial(810, 10007))\n\tassert.Equal(t, uint64(1), newModuloFactorial(1, 2))\n\tassert.Equal(t, uint64(10), newModuloFactorial(5, 11))\n\tassert.Equal(t, uint64(5), newModuloFactorial(6, 13))\n\tassert.Equal(t, uint64(13), newModuloFactorial(8, 17))\n\tassert.Equal(t, uint64(16), newModuloFactorial(15, 19))\n\tassert.Equal(t, uint64(1), newModuloFactorial(21, 23))\n\tassert.Equal(t, uint64(28), newModuloFactorial(30, 29))\n\tassert.Equal(t, uint64(100), newModuloFactorial(100, 101))\n}",
    "entry_point": "newModuloFactorial",
    "signature": "func newModuloFactorial(n, p uint64) uint64",
    "docstring": {
      "es": "Problema: Nueva Operación de Módulo \"⊕\".\nEn esta operación, para x ⊕ y:\n- Si x no es un múltiplo de y, el resultado es x % y.\n- Si x es un múltiplo de y, sigue dividiendo x por y (x = x / y) hasta que x ya no sea un múltiplo.\n  Sea el valor final x'. El resultado es x' % y.\n\nEjemplos:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDado un número primo p y un entero n, calcula el valor de n! ⊕ p,\ndonde n! es el factorial de n (producto de todos los enteros positivos ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "arb": "المشكلة: عملية باقي القسمة الجديدة \"⊕\".  \nفي هذه العملية، لـ x ⊕ y:  \n- إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.  \n- إذا كان x مضاعفًا لـ y، استمر في قسمة x على y (x = x / y) حتى لا يكون x مضاعفًا بعد الآن.  \n  دع القيمة النهائية تكون x'. النتيجة هي x' % y.  \n\nأمثلة:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nبالنظر إلى عدد أولي p وعدد صحيح n، احسب قيمة n! ⊕ p،  \nحيث n! هو مضروب n (حاصل ضرب جميع الأعداد الصحيحة الموجبة ≤ n).  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "sw": "Tatizo: Operesheni Mpya ya Modulo \"⊕\".  \nKatika operesheni hii, kwa x ⊕ y:  \n- Ikiwa x si kigezo cha y, matokeo ni x % y.  \n- Ikiwa x ni kigezo cha y, endelea kugawanya x kwa y (x = x / y) hadi x isiwe tena kigezo.  \n  Acha thamani ya mwisho iwe x'. Matokeo ni x' % y.  \n\nMifano:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nUkipatiwa nambari ya kwanza p na nambari nzima n, hesabu thamani ya n! ⊕ p,  \nambapo n! ni factorial ya n (bidhaa ya nambari zote chanya ≤ n).  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "tr": "Problem: Yeni Modulo Operasyonu \"⊕\".\nBu işlemde, x ⊕ y için:\n- Eğer x, y'nin katı değilse, sonuç x % y olur.\n- Eğer x, y'nin katı ise, x artık katı olmayana kadar x'i y'ye bölmeye devam edin (x = x / y).\n  Son değere x' diyelim. Sonuç x' % y olur.\n\nÖrnekler:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nVerilen bir asal sayı p ve bir tamsayı n için, n! ⊕ p değerini hesaplayın,\nburada n! n'nin faktöriyelidir (n'ye kadar olan tüm pozitif tamsayıların çarpımı).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "vi": "Vấn đề: Phép toán Modulo mới \"⊕\".\nTrong phép toán này, đối với x ⊕ y:\n- Nếu x không phải là bội số của y, kết quả là x % y.\n- Nếu x là bội số của y, tiếp tục chia x cho y (x = x / y) cho đến khi x không còn là bội số nữa.\n  Để giá trị cuối cùng là x'. Kết quả là x' % y.\n\nVí dụ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nCho một số nguyên tố p và một số nguyên n, tính giá trị của n! ⊕ p,\ntrong đó n! là giai thừa của n (tích của tất cả các số nguyên dương ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9898744190659845",
      "arb": "0.9829189790132858",
      "sw": "0.9793525705218044",
      "tr": "0.9699120657719782",
      "vi": "0.9947680757635411"
    }
  },
  {
    "task_id": "Go/34",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos de a[i] a a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nلديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nاعثر على الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUmepewa safu a ya n nambari kamili. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSize n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9910741465674352",
      "sw": "0.9876831287024076",
      "tr": "0.9741272010879196",
      "vi": "0.9821409438107722"
    },
    "canonical_solution": "p, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}",
    "instruction": {
      "es": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Go باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nGo kodunun işlevselliğini açıklayan doğal dilde kısa bir açıklama (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8749355586674792",
      "sw": "0.9338646242217667",
      "tr": "0.8436032051022739",
      "vi": "0.9080792226773416"
    },
    "level": "",
    "test": "func TestMakeEqualAgain(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, makeEqualAgain(3, []int{1, 2, 1}))\n\tassert.Equal(1, makeEqualAgain(5, []int{5, 5, 1, 5, 5}))\n\tassert.Equal(0, makeEqualAgain(4, []int{1, 1, 1, 1}))\n\tassert.Equal(1, makeEqualAgain(6, []int{2, 2, 2, 3, 2, 2}))\n\tassert.Equal(0, makeEqualAgain(1, []int{1}))\n\tassert.Equal(1, makeEqualAgain(2, []int{1, 2}))\n\tassert.Equal(2, makeEqualAgain(4, []int{1, 2, 2, 1}))\n\tassert.Equal(2, makeEqualAgain(7, []int{4, 4, 4, 3, 3, 4, 4}))\n\tassert.Equal(3, makeEqualAgain(6, []int{5, 4, 4, 4, 5, 5}))\n\tassert.Equal(5, makeEqualAgain(7, []int{1, 2, 1, 2, 1, 2, 1}))\n\tassert.Equal(4, makeEqualAgain(6, []int{1, 2, 3, 4, 5, 1}))\n\tassert.Equal(0, makeEqualAgain(7, []int{1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(2, makeEqualAgain(8, []int{8, 8, 8, 1, 2, 8, 8, 8}))\n\tassert.Equal(2, makeEqualAgain(3, []int{1, 2, 3}))\n\tassert.Equal(6, makeEqualAgain(7, []int{4, 3, 2, 7, 1, 1, 3}))\n\tassert.Equal(7, makeEqualAgain(9, []int{9, 9, 2, 9, 2, 5, 5, 5, 3}))\n}",
    "entry_point": "makeEqualAgain",
    "signature": "func makeEqualAgain(n int, a []int) int",
    "docstring": {
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "arb": "أنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "sw": "Umepewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Pata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "tr": "Size n olan bir tamsayı dizisi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde i, j, x (1 <= i <= j <= n) olmak üzere üç tamsayı seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9958861661783864",
      "sw": "0.9864575792514224",
      "tr": "0.9429964573594647",
      "vi": "0.9842213984217316"
    }
  },
  {
    "task_id": "Go/35",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras,\ndetermina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, turnándose con Dan para mover\nun número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador obligado\na mover piedras solo en la última pila pierde. Suponiendo un juego óptimo, averigua quién es el ganador.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، تحتوي كل منها على عدد موجب من الحجارة،\nحدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوب مع دان لتحريك عدد موجب من الحجارة\nمن الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي يُجبر على\nتحريك الحجارة في الكومة الأخيرة فقط يخسر. بافتراض اللعب الأمثل، اكتشف الفائز.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIkizingatiwa mlolongo wa mirundo N ya mawe iliyoorodheshwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe,\namua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha\nidadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji anayelazimika\nkuhamisha mawe tu kwenye rundo la mwisho anapoteza. Tukizingatia uchezaji bora, tafuta mshindi.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içerir,\nCharlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk olarak, Dan ile sırayla\nen soldaki boş olmayan yığından bitişik sağ yığına pozitif sayıda taş taşır. Sadece son yığındaki taşları\ntaşımak zorunda kalan oyuncu kaybeder. Optimal oyun varsayılarak, kazananı bulun.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương,\nxác định người chiến thắng của một trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, lần lượt với Dan để di chuyển\nmột số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi bị buộc phải\nchỉ di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi tối ưu, tìm ra người chiến thắng.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {"
    },
    "prompt_bertscore": {
      "es": "0.9696880107021709",
      "arb": "0.9719458422433944",
      "sw": "0.9636581882250947",
      "tr": "0.983369472717473",
      "vi": "0.9880192113071187"
    },
    "canonical_solution": "if n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}",
    "instruction": {
      "es": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nGo kodunun işlevini açıklayan özlü bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.907135728367426",
      "sw": "0.9102365472457616",
      "tr": "0.8834649458594983",
      "vi": "0.9386444657109903"
    },
    "level": "",
    "test": "func TestGameWinner(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Dan\", GameWinner(3, []int{1, 2, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(5, []int{5, 5, 5, 5, 5}))\n\tassert.Equal(\"Charlie\", GameWinner(3, []int{2, 1, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(4, []int{3, 3, 3, 3}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{2, 1}))\n\tassert.Equal(\"Dan\", GameWinner(11, []int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{2, 2, 2, 2, 2, 2, 2, 2, 2, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{10, 10, 10, 10, 10, 10, 10, 10, 10, 10}))\n\tassert.Equal(\"Dan\", GameWinner(10, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}",
    "entry_point": "GameWinner",
    "signature": "func GameWinner(n int, piles []int) string",
    "docstring": {
      "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determine el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, turnándose con Dan para mover un número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador obligado a mover piedras solo en la última pila pierde. Suponiendo un juego óptimo, determine el ganador.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، يحتوي كل منها على عدد إيجابي من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوب مع دان لتحريك عدد إيجابي من الحجارة من الكومة غير الفارغة اليسرى إلى الكومة المجاورة اليمنى. اللاعب الذي يُجبر على تحريك الحجارة في الكومة الأخيرة فقط يخسر. بافتراض اللعب الأمثل، اكتشف الفائز.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa mirundo N ya mawe iliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza, akibadilishana zamu na Dan kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji anayelazimishwa kuhamisha mawe tu kwenye rundo la mwisho anapoteza. Kwa kudhani uchezaji bora, tafuta mshindi.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "tr": "Verilen N taş yığınından oluşan bir dizide, her biri pozitif sayıda taş içeren ve 1'den N'ye kadar numaralandırılmış, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk olarak başlar ve Dan ile sırayla, soldaki dolu olmayan yığından sağdaki bitişik yığına pozitif sayıda taş taşır. Sadece son yığındaki taşları hareket ettirmek zorunda kalan oyuncu kaybeder. Optimal oyun varsayılarak, kazananı bulun.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, lần lượt với Dan để di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi bị buộc phải chỉ di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi tối ưu, tìm ra người chiến thắng.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9676349670837943",
      "arb": "0.9646741826240882",
      "sw": "0.9545760126826556",
      "tr": "0.935385934310113",
      "vi": "0.9808087298451712"
    }
  },
  {
    "task_id": "Go/36",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. 1 <= i < n için C_i >= C_{i+1} olduğu garanti edilmektedir.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho n cánh cửa sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9936561428905077",
      "arb": "0.9936561428905077",
      "sw": "0.9965287354610343",
      "tr": "0.9764968615336658",
      "vi": "0.9888657739910893"
    },
    "canonical_solution": "return int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}",
    "instruction": {
      "es": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9025638528871459",
      "sw": "0.8884098491953619",
      "tr": "0.8561933918041703",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestMinTotalCost(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(15), MinTotalCost(5, []int{4, 3, 3, 3, 3})) // Note the 0-indexed array for slice in Golang\n\tassert.Equal(int64(3), MinTotalCost(3, []int{1, 1, 1}))\n\tassert.Equal(int64(11), MinTotalCost(4, []int{5, 4, 3, 2}))\n\tassert.Equal(int64(391), MinTotalCost(4, []int{100, 99, 98, 97}))\n\tassert.Equal(int64(35), MinTotalCost(6, []int{10, 9, 8, 7, 6, 5}))\n\tassert.Equal(int64(14), MinTotalCost(7, []int{2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(56), MinTotalCost(8, []int{9, 7, 7, 7, 7, 7, 7, 7}))\n\tassert.Equal(int64(18), MinTotalCost(9, []int{3, 2, 2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(50), MinTotalCost(10, []int{6, 5, 5, 5, 5, 5, 5, 5, 5, 5}))\n\tassert.Equal(int64(11), MinTotalCost(11, []int{8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n}",
    "entry_point": "MinTotalCost",
    "signature": "func MinTotalCost(n int, C []int) int64",
    "docstring": {
      "es": "Dadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n. La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "sw": "Kwa kuzingatia milango n iliyopangwa kwa mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. \nKazi ni kubaini gharama ndogo kabisa ya jumla inayohitajika kufungua milango yote.\n\nMfano:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder. C_i >= C_{i+1} olduğu garanti edilmiştir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "vi": "Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9926687512663833",
      "arb": "0.9926687512663833",
      "sw": "0.9974475996037017",
      "tr": "0.9714190744728899",
      "vi": "0.9817484501778472"
    }
  },
  {
    "task_id": "Go/37",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una secuencia de IDs de estudiantes que entran a un aula, donde los IDs van de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante dará la mano a cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes entran al aula.\n\nEjemplos:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل برقم معرف أصغر. يمثل التسلسل الترتيب الذي يدخل به الطلاب إلى الفصل.\n\nأمثلة:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono inayoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani mwenye namba ya kitambulisho ndogo. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir sınıfa giren öğrenci kimliklerinin bir dizisi verildiğinde, kimliklerin 0'dan N-1'e kadar değiştiği, gerçekleşen toplam el sıkışma sayısını hesaplayın. Her öğrenci, sınıfa daha küçük kimlik numarasıyla zaten girmiş olan her öğrenciyle el sıkışacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một dãy số ID của sinh viên khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi sinh viên sẽ bắt tay với mọi sinh viên đã có mặt trong lớp với số ID nhỏ hơn. Dãy số này biểu thị thứ tự sinh viên vào lớp học.\n\nVí dụ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9948971855112138",
      "arb": "0.9959030497607744",
      "sw": "0.9900067068997538",
      "tr": "0.9673604598972041",
      "vi": "0.97960125575886"
    },
    "canonical_solution": "var ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nAşağıdaki Go kodunun doğal dilde özlü bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9025638528871459",
      "sw": "0.9150640600264335",
      "tr": "0.9089494223766555",
      "vi": "0.9385191299405573"
    },
    "level": "",
    "test": "func TestCountHandshakes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), CountHandshakes(4, []int{2, 1, 3, 0}))\n\tassert.Equal(int64(15), CountHandshakes(6, []int{0, 1, 2, 3, 4, 5}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{1, 2, 0}))\n\tassert.Equal(int64(0), CountHandshakes(4, []int{3, 2, 1, 0}))\n\tassert.Equal(int64(6), CountHandshakes(4, []int{0, 1, 2, 3}))\n\tassert.Equal(int64(0), CountHandshakes(6, []int{5, 4, 3, 2, 1, 0}))\n\tassert.Equal(int64(5), CountHandshakes(4, []int{0, 2, 1, 3}))\n\tassert.Equal(int64(3), CountHandshakes(5, []int{3, 1, 4, 2, 0}))\n\tassert.Equal(int64(4), CountHandshakes(4, []int{1, 0, 3, 2}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{2, 0, 1}))\n\tassert.Equal(int64(7), CountHandshakes(5, []int{1, 3, 0, 2, 4}))\n\tassert.Equal(int64(0), CountHandshakes(5, []int{4, 3, 2, 1, 0}))\n}\n\n// To run tests in Go, you can use the following command:\n// go test -v",
    "entry_point": "CountHandshakes",
    "signature": "func CountHandshakes(n int, order []int) int64",
    "docstring": {
      "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante dará la mano a cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "sw": "Ukipewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono inayoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani mwenye namba ya kitambulisho ndogo. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "tr": "Verilen bir sınıfa giren öğrenci kimlikleri dizisi için, kimliklerin 0'dan N-1'e kadar değiştiği durumda, gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük kimlik numarasına sahip her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "vi": "Cho một dãy số ID sinh viên khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1, tính tổng số cái bắt tay xảy ra. Mỗi sinh viên sẽ bắt tay với mọi sinh viên đã có mặt trong lớp với số ID nhỏ hơn. Dãy số này đại diện cho thứ tự mà các sinh viên vào lớp học.\n\nVí dụ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9961406116964922",
      "arb": "0.9856797426792897",
      "sw": "1",
      "tr": "0.9635668182498187",
      "vi": "0.9615842884167095"
    }
  },
  {
    "task_id": "Go/38",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado n enteros positivos que representan la cantidad de cada número del 1 al n,\nencuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. La moda es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع الوضع (العنصر الأكثر تكرارًا) لجميع البادئات\nلسلسلة مُنشأة من هذه الأرقام. الوضع هو أكبر عدد بين\nالعناصر الأكثر تكرارًا في سلسلة.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tالسلسلة التي تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachotokea mara nyingi zaidi) kwa viambishi vyote vya\nmlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\nvipengele vinavyotokea mara nyingi zaidi katika mfululizo.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMfululizo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman)\nmaksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số\ncác phần tử xuất hiện nhiều nhất trong một dãy.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMột dãy đạt giá trị tối đa của nó là (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9944540411311249",
      "arb": "0.9885864996753543",
      "sw": "0.9638607912137503",
      "tr": "0.9544858344896657",
      "vi": "0.9559340485977911"
    },
    "canonical_solution": "ans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nAşağıdaki Go kodunun doğal dilde özlü bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9231167343039689",
      "sw": "0.9425243129437447",
      "tr": "0.8959242351402927",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestMaxModeSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(17), MaxModeSum(3, []int{1, 3, 2}))\n\tassert.Equal(int64(37), MaxModeSum(4, []int{4, 1, 2, 3}))\n\tassert.Equal(int64(4), MaxModeSum(2, []int{1, 1}))\n\tassert.Equal(int64(75), MaxModeSum(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(int64(100000), MaxModeSum(1, []int{100000}))\n\tassert.Equal(int64(62), MaxModeSum(5, []int{5, 3, 2, 4, 1}))\n\tassert.Equal(int64(900000), MaxModeSum(3, []int{100000, 100000, 100000}))\n\tassert.Equal(int64(27), MaxModeSum(3, []int{2, 2, 5}))\n\tassert.Equal(int64(64), MaxModeSum(4, []int{4, 4, 4, 4}))\n\tassert.Equal(int64(126), MaxModeSum(6, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(int64(16), MaxModeSum(3, []int{3, 1, 2}))\n}",
    "entry_point": "MaxModeSum",
    "signature": "func MaxModeSum(n int, counts []int) int64",
    "docstring": {
      "es": "Dado n enteros positivos que representan el conteo de cada número de 1 a n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "إعطاء n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر رقم بين \nالعناصر الأكثر تكرارًا في سلسلة.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).",
      "sw": "Kutolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo ulioundwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya vipengele vinavyotokea mara nyingi zaidi katika mlolongo.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Verilen n pozitif tamsayı, 1'den n'ye kadar olan her bir sayının sayısını temsil eder, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tMột dãy đạt giá trị lớn nhất là (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9835319523691595",
      "sw": "0.9454207411599955",
      "tr": "0.9525221745427548",
      "vi": "0.96180317909661"
    }
  },
  {
    "task_id": "Go/39",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) devuelve 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للمصفوفة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع مجموعات XOR لجميع المصفوفات الفرعية الممكنة.\n\nأمثلة الحالات:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) يعيد 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) inarudisha 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çiftleri ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 döner\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của phép XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của phép XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) trả về 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9926310114939867",
      "arb": "0.9747068045397794",
      "sw": "0.9685752833076134",
      "tr": "0.967103630814526",
      "vi": "0.9935685468924713"
    },
    "canonical_solution": "n := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "es": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nGo kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9338646242217667",
      "tr": "0.8829046095545989",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestSumOfXorSubarrays(t *testing.T) {\n\tassert.Equal(t, int64(39), sumOfXorSubarrays([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(t, int64(4), sumOfXorSubarrays([]int{1, 1, 1}))\n\tassert.Equal(t, int64(9), sumOfXorSubarrays([]int{2, 3, 1}))\n\tassert.Equal(t, int64(74), sumOfXorSubarrays([]int{4, 5, 7, 9}))\n\tassert.Equal(t, int64(0), sumOfXorSubarrays([]int{0, 0, 0, 0}))\n\tassert.Equal(t, int64(72), sumOfXorSubarrays([]int{8, 8, 8, 8, 8}))\n\tassert.Equal(t, int64(125), sumOfXorSubarrays([]int{3, 6, 9, 12, 15}))\n\tassert.Equal(t, int64(390), sumOfXorSubarrays([]int{10, 20, 30, 40, 50}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{16, 16, 16, 16, 16, 16}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{1, 3, 5, 7, 9, 11, 13}))\n\tassert.Equal(t, int64(218), sumOfXorSubarrays([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "func sumOfXorSubarrays(A []int) int64",
    "docstring": {
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:  \n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) devuelve 39",
      "arb": "المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية لمصفوفة A من الأعداد الصحيحة. يتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة. مجموع XOR لمصفوفة فرعية هو نتيجة XOR لجميع العناصر من L إلى R. النتيجة النهائية هي مجموع قيم XOR لجميع المصفوفات الفرعية الممكنة.\n\nأمثلة الحالات:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) يعيد 39",
      "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR za sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) inarudisha 39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 döndürür",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng. \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) trả về 39"
    },
    "docstring_bertscore": {
      "es": "0.991328989346303",
      "arb": "0.9520597630157056",
      "sw": "0.9709252793456372",
      "tr": "0.9696852298768364",
      "vi": "0.9959856799992849"
    }
  },
  {
    "task_id": "Go/40",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n,\nque pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "arb": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n،\nالتي يمكن التعبير عنها كـ x = a^b حيث a و b عددان صحيحان موجبان و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "sw": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKwa kupewa nambari mbili kamili chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n,\nambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari kamili chanya na b >= k.\nUwakilishi tofauti wa kisheria wa nambari ile ile unahesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "tr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında olan ve x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun,\nburada a ve b pozitif tamsayılar ve b >= k. Aynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "vi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n,\nmà có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.\nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9966093793957345",
      "sw": "0.999999801369619",
      "tr": "0.965891190968689",
      "vi": "0.982202519228893"
    },
    "canonical_solution": "count := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}",
    "instruction": {
      "es": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nGo kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9351273175540055",
      "sw": "0.9150640600264335",
      "tr": "0.8829046095545989",
      "vi": "0.8854591948850886"
    },
    "level": "",
    "test": "func TestCountPowerNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(99, countPowerNumbers(99, 1))\n\tassert.Equal(7, countPowerNumbers(99, 3))\n\tassert.Equal(12, countPowerNumbers(99, 2))\n\tassert.Equal(10, countPowerNumbers(10, 1))\n\tassert.Equal(4, countPowerNumbers(10, 2))\n\tassert.Equal(500, countPowerNumbers(500, 1))\n\tassert.Equal(30, countPowerNumbers(500, 2))\n\tassert.Equal(13, countPowerNumbers(500, 3))\n\tassert.Equal(1000, countPowerNumbers(1000, 1))\n\tassert.Equal(41, countPowerNumbers(1000, 2))\n\tassert.Equal(17, countPowerNumbers(1000, 3))\n\tassert.Equal(1, countPowerNumbers(1000, 93))\n\tassert.Equal(10, countPowerNumbers(50, 2))\n\tassert.Equal(5, countPowerNumbers(50, 3))\n\tassert.Equal(1, countPowerNumbers(2, 3))\n}",
    "entry_point": "countPowerNumbers",
    "signature": "func countPowerNumbers(n int, k int) int",
    "docstring": {
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "معطى عددان صحيحان موجبان n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b حيث a و b هما عددان صحيحان موجبان و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Ukipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya na b >= k. Mwakilishi tofauti wa kisheria wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında olan ve x = a^b şeklinde ifade edilebilen pozitif tamsayı x'lerin sayısını bulun. Burada a ve b pozitif tamsayılar olup b >= k'dir. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9847428031719482",
      "sw": "0.9849001184337278",
      "tr": "0.9344337002634316",
      "vi": "0.9796111872779119"
    }
  },
  {
    "task_id": "Go/41",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe ser calculado\nmódulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات التي تتكون من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa nambari tatu n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')',\nambapo mlolongo mrefu zaidi ulio sawa ni wa urefu 2 * k. Matokeo yanapaswa kuhesabiwa\nkwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç, 1,000,000,007 (10^9 + 7) ile\nmod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính\ntheo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9977016478610453",
      "arb": "0.9986016421175143",
      "sw": "0.982868526896503",
      "tr": "0.978183432099033",
      "vi": "0.9855857905090603"
    },
    "canonical_solution": "const P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}",
    "instruction": {
      "es": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nAşağıdaki Go kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9132213659815729",
      "sw": "0.9425243129437447",
      "tr": "0.888797575699142",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestCountBalancedSubsequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), countBalancedSubsequences(2, 2, 2))\n\tassert.Equal(int64(0), countBalancedSubsequences(3, 2, 3))\n\tassert.Equal(int64(4), countBalancedSubsequences(3, 2, 1))\n\tassert.Equal(int64(14), countBalancedSubsequences(4, 3, 2))\n\tassert.Equal(int64(35), countBalancedSubsequences(5, 5, 2))\n\tassert.Equal(int64(6), countBalancedSubsequences(6, 1, 1))\n\tassert.Equal(int64(6), countBalancedSubsequences(1, 6, 1))\n\tassert.Equal(int64(27), countBalancedSubsequences(7, 2, 2))\n\tassert.Equal(int64(110), countBalancedSubsequences(8, 3, 3))\n\tassert.Equal(int64(10659), countBalancedSubsequences(10, 10, 5))\n\tassert.Equal(int64(574221648), countBalancedSubsequences(20, 20, 10))\n\tassert.Equal(int64(854104531), countBalancedSubsequences(2000, 2000, 1000))\n\tassert.Equal(int64(334874485), countBalancedSubsequences(2000, 1999, 1000))\n\tassert.Equal(int64(259428024), countBalancedSubsequences(2000, 2000, 1999))\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "func countBalancedSubsequences(n, m, k int64) int64",
    "docstring": {
      "es": "Dado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "بالنظر إلى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق الموديلو 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Kwa kupewa nambari tatu za mzima n, m, na k, pata idadi ya mfuatano inayojumuisha n '(' na m ')', \nkiasi kwamba mfuatano mrefu zaidi wenye usawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa \nkwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç, 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9964649751087221",
      "arb": "0.9866081410802469",
      "sw": "1",
      "tr": "0.9725582197081251",
      "vi": "0.9838467815230998"
    }
  },
  {
    "task_id": "Go/42",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda\nen (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para\ncortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que\nes paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0)\nوالزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية\nأقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة)\nالورقة. الجزء السفلي أو الأيمن من الورقة على طول هذا الخط يتم التخلص منه.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipewa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege\nikiwa na kona yake ya chini-kushoto kwenye (0,0) na kona ya juu-kulia kwenye (n,m), unahitaji kuhesabu idadi\nya shughuli zinazotarajiwa za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni,\nmstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari\nnzima, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu\nkisha hutupwa.\nJibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn x m boyutlarında bir dikdörtgen kağıt, (0,0) noktasında alt-sol köşesi ve (n,m) noktasında üst-sağ köşesi\nolan bir Kartezyen koordinat sistemine yerleştirilmiştir. Kalan alanın k'dan küçük olması için kağıdı kesmek\nüzere beklenen operasyon sayısını hesaplamanız gerekiyor. Her operasyonda, eksenlere paralel, tam sayı\nkoordinatlı noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu\nçizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınmış olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Đề-các với góc dưới bên trái\ntại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác dự kiến để\ncắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên\nsong song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh)\ntờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời phải được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {"
    },
    "prompt_bertscore": {
      "es": "0.9788351383792085",
      "arb": "0.9527424556353226",
      "sw": "0.9664300751924366",
      "tr": "0.9545110605480571",
      "vi": "0.9563178024939505"
    },
    "canonical_solution": "const MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "es": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nGo kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9081642364804247",
      "sw": "0.9150640600264335",
      "tr": "0.8699094155057724",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestExpectedCuts(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(int64(0), expectedCuts(2, 4, 10))\n\tassert.Equal(int64(1), expectedCuts(2, 4, 8))\n\tassert.Equal(int64(833333342), expectedCuts(2, 4, 2))\n\tassert.Equal(int64(250000003), expectedCuts(2, 4, 6))\n\tassert.Equal(int64(666666673), expectedCuts(3, 3, 4))\n\tassert.Equal(int64(666666673), expectedCuts(5, 5, 12))\n\tassert.Equal(int64(722222229), expectedCuts(6, 7, 20))\n\tassert.Equal(int64(72727275), expectedCuts(8, 8, 30))\n\tassert.Equal(int64(714285721), expectedCuts(10, 10, 50))\n\tassert.Equal(int64(945634929), expectedCuts(1, 10, 5))\n\tassert.Equal(int64(945634929), expectedCuts(10, 1, 5))\n}",
    "entry_point": "expectedCuts",
    "signature": "func expectedCuts(n int, m int, k int64) int64",
    "docstring": {
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "arb": "نظرًا لورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (ليس فقط يلمس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "sw": "Ukipata karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha inatupwa.\n\nJibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "tr": "Verilen n x m boyutunda bir dikdörtgen kağıt, düzlem Kartezyen koordinat sistemine (0,0) alt-sol köşesi ve (n,m) üst-sağ köşesi olacak şekilde yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tamsayı koordinatlara sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả phải được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9766164370230488",
      "arb": "0.9550366365362755",
      "sw": "0.9573008242496922",
      "tr": "0.9398573028175893",
      "vi": "0.929197604788971"
    }
  },
  {
    "task_id": "Go/43",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento. Esto implica elegir k-1 puntos de ruptura con 1 ≤ x1 < x2 < ... < x(k-1) < n, y dividir p en segmentos [1, x1], (x1, x2], ..., (x(k-1), n]. El resultado debe ser módulo 998244353.\nEjemplo:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى ترتيب q من n عنصر وعدد صحيح k، أوجد عدد الترتيبات p من n عنصر بحيث أن f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع. يتضمن ذلك اختيار k-1 نقاط تقاطع بحيث 1 ≤ x1 < x2 < ... < x(k-1) < n، وتقسيم p إلى مقاطع [1, x1]، (x1, x2]، ...، (x(k-1), n]. يجب أن تكون النتيجة موديولو 998244353.\nمثال:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu. Hii inahusisha kuchagua sehemu k-1 na 1 ≤ x1 < x2 < ... < x(k-1) < n, na kugawanya p katika sehemu [1, x1], (x1, x2], ..., (x(k-1), n]. Matokeo yanapaswa kuwa modulo 998244353.\nMfano:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı p permütasyonlarının sayısını bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur. Bu, 1 ≤ x1 < x2 < ... < x(k-1) < n ile k-1 kırılma noktası seçmeyi ve p'yi [1, x1], (x1, x2], ..., (x(k-1), n] segmentlerine bölmeyi içerir. Sonuç 998244353 ile mod alınmalıdır.\nÖrnek:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể đạt được bằng cách chia p thành đúng k đoạn liên tiếp không rỗng và sắp xếp từng đoạn. Điều này bao gồm việc chọn k-1 điểm ngắt với 1 ≤ x1 < x2 < ... < x(k-1) < n, và chia p thành các đoạn [1, x1], (x1, x2], ..., (x(k-1), n]. Kết quả nên được lấy modulo 998244353.\nVí dụ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9957489125850914",
      "arb": "0.9863554832355704",
      "sw": "0.9616710898932218",
      "tr": "0.9672959050233677",
      "vi": "0.9791448031432419"
    },
    "canonical_solution": "const N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "es": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nGo kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9156106908350415",
      "sw": "0.9338646242217667",
      "tr": "0.8679167555232304",
      "vi": "0.9349197488058241"
    },
    "level": "",
    "test": "func TestCountPermutations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, CountPermutations(2, 1, []int{1, 2}))\n\tassert.Equal(1, CountPermutations(3, 3, []int{3, 1, 2}))\n\tassert.Equal(13, CountPermutations(6, 3, []int{1, 2, 3, 6, 5, 4}))\n\tassert.Equal(720, CountPermutations(6, 1, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(0, CountPermutations(6, 3, []int{1, 2, 5, 3, 4, 5}))\n\tassert.Equal(1, CountPermutations(9, 9, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(29093, CountPermutations(9, 2, []int{1, 2, 3, 4, 5, 6, 7, 9, 8}))\n}",
    "entry_point": "CountPermutations",
    "signature": "func CountPermutations(n int, k int, qq []int) int",
    "docstring": {
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento. Esto implica elegir k-1 puntos de ruptura con 1 ≤ x1 < x2 < ... < x(k-1) < n, y dividir p en segmentos [1, x1], (x1, x2], ..., (x(k-1), n]. El resultado debe ser módulo 998244353.\nEjemplo:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "arb": "بالنظر إلى ترتيب q من n عنصرًا وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصرًا بحيث f(p) = q، حيث أن f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع. يتضمن ذلك اختيار k-1 نقاط توقف مع 1 ≤ x1 < x2 < ... < x(k-1) < n، وتقسيم p إلى مقاطع [1, x1]، (x1, x2]، ...، (x(k-1), n]. يجب أن تكون النتيجة موديولو 998244353.\nمثال:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "sw": "Ukipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu. Hii inahusisha kuchagua sehemu k-1 na 1 ≤ x1 < x2 < ... < x(k-1) < n, na kugawanya p katika sehemu [1, x1], (x1, x2], ..., (x(k-1), n]. Matokeo yanapaswa kuwa modulo 998244353.\nMfano:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k adet boş olmayan ardışık segmente bölüp her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur. Bu, 1 ≤ x1 < x2 < ... < x(k-1) < n olacak şekilde k-1 adet kırılma noktası seçmeyi ve p'yi [1, x1], (x1, x2], ..., (x(k-1), n] segmentlerine bölmeyi içerir. Sonuç 998244353 ile mod alınmalıdır.\nÖrnek:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "vi": "Cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn. Điều này bao gồm việc chọn k-1 điểm ngắt với 1 ≤ x1 < x2 < ... < x(k-1) < n, và chia p thành các đoạn [1, x1], (x1, x2], ..., (x(k-1), n]. Kết quả nên được lấy theo modulo 998244353.\nVí dụ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2"
    },
    "docstring_bertscore": {
      "es": "0.9949005622276913",
      "arb": "0.9902146729086972",
      "sw": "0.938255348794543",
      "tr": "0.9470306403982832",
      "vi": "0.989666850317803"
    }
  },
  {
    "task_id": "Go/44",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un array de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD)\nde los valores máximo y mínimo del triplete sea 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى مصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nلأكبر وأصغر القيم في الثلاثية هو 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipiwa safu ya n ya nambari tofauti zinazowakilisha urefu wa marafiki wa Kira,\ntafuta idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD)\nwa thamani za juu na za chini za tatu hiyo ni 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi verildiğinde,\nbir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin\nen büyük ortak böleni (GCD) 1 olsun.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách để chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9819452928854528",
      "sw": "0.9718433489667805",
      "tr": "0.9969283797876765",
      "vi": "1"
    },
    "canonical_solution": "count := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "es": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nGo kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.91584070481628",
      "sw": "0.9425243129437447",
      "tr": "0.8572800986188122",
      "vi": "0.9263474574515014"
    },
    "level": "",
    "test": "func TestCountTriplets(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, countTriplets([]int{1, 5, 7}, 3))\n\tassert.Equal(3, countTriplets([]int{1, 6, 2, 3}, 4))\n\tassert.Equal(0, countTriplets([]int{16, 4, 8, 2}, 4))\n\tassert.Equal(77, countTriplets([]int{10, 1, 6, 7, 9, 8, 4, 3, 5, 2}, 10))\n\tassert.Equal(7, countTriplets([]int{4, 5, 9, 11, 14}, 5))\n\tassert.Equal(104, countTriplets([]int{15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}, 11))\n\tassert.Equal(4, countTriplets([]int{3, 7, 11, 13}, 4))\n\tassert.Equal(10, countTriplets([]int{5, 12, 13, 17, 19}, 5))\n\tassert.Equal(87, countTriplets([]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 11))\n\tassert.Equal(122, countTriplets([]int{1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}, 11))\n}",
    "entry_point": "countTriplets",
    "signature": "func countTriplets(heights []int, n int) int",
    "docstring": {
      "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "arb": "نظرًا لمصفوفة تحتوي على n عدد صحيح مميز يمثل ارتفاعات أصدقاء كيرا، \nابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) \nللقيمتين العظمى والصغرى للثلاثية هو 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "sw": "Ukipewa safu ya n ya nambari tofauti zinazowakilisha urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) kama kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD) wa thamani za juu na za chini za tatu ni 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "tr": "Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "vi": "Cho một mảng gồm n số nguyên phân biệt đại diện cho chiều cao của bạn bè Kira, tìm số cách để chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.993600327753437",
      "sw": "0.9318799094544661",
      "tr": "0.957863742749545",
      "vi": "0.999999801369619"
    }
  },
  {
    "task_id": "Go/45",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero.\nPuedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo\ncolor al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color.\nEncuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nلديك صورة بحجم 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون ممثل بعدد صحيح.\nيمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار.\nيعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون.\nاعثر على الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari.\nUnaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa\nkuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa.\nPata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1'e n piksel boyutunda bir görüntü verilir, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir.\nBir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz.\nİki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir.\nTüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên.\nBạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng\nmàu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu.\nTìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9987821971338751",
      "arb": "0.9651936010704945",
      "sw": "0.9864132846764516",
      "tr": "0.9727794939525979",
      "vi": "0.9912854892928563"
    },
    "canonical_solution": "n := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "es": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8952355836092448",
      "sw": "0.9102365472457616",
      "tr": "0.8457458310224972",
      "vi": "0.9494080474288898"
    },
    "level": "",
    "test": "func TestMinOperations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, minOperations([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(1, minOperations([]int{1, 1, 2, 2}))\n\tassert.Equal(3, minOperations([]int{1, 2, 1, 4, 2}))\n\tassert.Equal(0, minOperations([]int{5, 5, 5, 5, 5}))\n\tassert.Equal(1, minOperations([]int{1, 1, 1, 2, 2, 2}))\n\tassert.Equal(2, minOperations([]int{1, 3, 3, 3, 2, 2, 2}))\n\tassert.Equal(1, minOperations([]int{4, 4, 4, 4, 3, 3, 3, 3}))\n\tassert.Equal(8, minOperations([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(5, minOperations([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}))\n\tassert.Equal(0, minOperations([]int{3, 3, 3}))\n\tassert.Equal(1, minOperations([]int{2, 1, 1, 2}))\n}",
    "entry_point": "minOperations",
    "signature": "func minOperations(pixels []int) int",
    "docstring": {
      "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "arb": "أنت تملك صورة بحجم 1 في n بكسل، حيث أن كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر بكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari kamili. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote kuwa na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "tr": "1'e n piksel boyutunda bir görüntü verilir ve her piksel bir tamsayı ile temsil edilen bir renge sahiptir. \nBir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. \nİki piksel, bitişik olduklarında ve aynı renge sahip olduklarında bağlı kabul edilir. \nTüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2"
    },
    "docstring_bertscore": {
      "es": "0.9983875185667588",
      "arb": "0.9658262388340906",
      "sw": "0.9871007444252133",
      "tr": "0.9474342573325462",
      "vi": "0.9874322585311606"
    }
  },
  {
    "task_id": "Go/46",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n\nque son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5,\ndebe contarse solo una vez.\n\nPor ejemplo:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nبالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأعداد من 1 إلى n\nالتي هي مضاعفات إما لـ 3 أو 5. إذا كان العدد مضاعفًا لكل من 3 و 5،\nفيجب أن يُحسب مرة واحدة فقط.\n\nعلى سبيل المثال:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUkipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n\nambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5,\ninapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların\ntoplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa,\nyalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n\nmà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5,\nnó chỉ nên được tính một lần.\n\nVí dụ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9939993761889361",
      "arb": "0.9978188397858558",
      "sw": "0.9939993761889361",
      "tr": "0.9652998683243481",
      "vi": "0.9907853379934105"
    },
    "canonical_solution": "sum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}",
    "instruction": {
      "es": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nGo kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9141193739342316",
      "sw": "0.9150640600264335",
      "tr": "0.8841142685751014",
      "vi": "0.9172098640327534"
    },
    "level": "",
    "test": "func TestSumOfMultiples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(33, sumOfMultiples(10))\n\tassert.Equal(60, sumOfMultiples(15))\n\tassert.Equal(98, sumOfMultiples(20))\n\tassert.Equal(8, sumOfMultiples(5))\n\tassert.Equal(3, sumOfMultiples(3))\n\tassert.Equal(14, sumOfMultiples(6))\n\tassert.Equal(23, sumOfMultiples(9))\n\tassert.Equal(45, sumOfMultiples(12))\n\tassert.Equal(60, sumOfMultiples(17))\n\tassert.Equal(119, sumOfMultiples(21))\n\tassert.Equal(168, sumOfMultiples(25))\n}",
    "entry_point": "sumOfMultiples",
    "signature": "func sumOfMultiples(n int) int",
    "docstring": {
      "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, debe contarse solo una vez.\n\nPor ejemplo:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "arb": "معطى عدد صحيح n، اكتب دالة لحساب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و5، فيجب أن يُحسب مرة واحدة فقط.\n\nعلى سبيل المثال:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "sw": "Kwa kupewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "tr": "Verilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\n\nVí dụ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "es": "0.9900521932570108",
      "arb": "0.9944242465739697",
      "sw": "0.9864921409377224",
      "tr": "0.9820630807014065",
      "vi": "0.9860144348713336"
    }
  },
  {
    "task_id": "Go/47",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee\nigual hacia adelante y hacia atrás (ignorando espacios, puntuación y capitalización).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "arb": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nتحديد ما إذا كانت سلسلة معينة هي كلمة متناظرة. الكلمة المتناظرة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف الذي يقرأ\nنفسه للأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "sw": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTambua kama string iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa\nsawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "tr": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "vi": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nXác định xem một chuỗi cho trước có phải là một palindrome hay không. Palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc giống nhau từ trái sang phải và từ phải sang trái (bỏ qua khoảng trắng, dấu câu, và chữ hoa chữ thường).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9991514510122189",
      "sw": "0.997807915114899",
      "tr": "0.9878358754654234",
      "vi": "0.9904405156519339"
    },
    "canonical_solution": "str = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}",
    "instruction": {
      "es": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español usando como máximo 500 caracteres.",
      "arb": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nGo kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8961943724585002",
      "sw": "0.9150640600264335",
      "tr": "0.8829046095545989",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.True(IsPalindrome(\"A man a plan a canal Panama\"))\n\tassert.True(IsPalindrome(\"No lemon, no melon\"))\n\tassert.True(IsPalindrome(\"Was it a car or a cat I saw\"))\n\tassert.True(IsPalindrome(\"Madam, in Eden, I'm Adam\"))\n\tassert.True(IsPalindrome(\"Never odd or even\"))\n\tassert.True(IsPalindrome(\"Eva, can I see bees in a cave\"))\n\tassert.False(IsPalindrome(\"hello\"))\n\tassert.False(IsPalindrome(\"GitHub\"))\n\tassert.False(IsPalindrome(\"programming\"))\n}",
    "entry_point": "IsPalindrome",
    "signature": "func IsPalindrome(str string) bool",
    "docstring": {
      "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y capitalización).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متجانسة. الكلمة المتجانسة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات وعلامات الترقيم وحالة الأحرف).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "sw": "Amua kama mfuatano uliotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi ambao unasoma sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "tr": "Verilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf duyarlılığı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi đối xứng hay không. Một chuỗi đối xứng là một từ, cụm từ, số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9980683195444358",
      "sw": "0.9838459870015757",
      "tr": "0.9770395197346531",
      "vi": "0.9980683195444358"
    }
  },
  {
    "task_id": "Go/48",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    addDigits(38) // devuelve 2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n*/\nfunc addDigits(num int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nمعطى عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    addDigits(38) // يعيد 2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.\n*/\nfunc addDigits(num int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIkizingatiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yatakapokuwa na tarakimu moja tu.\nKwa mfano:\n    addDigits(38) // inarudisha 2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndio matokeo.\n*/\nfunc addDigits(num int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerilen bir negatif olmayan tamsayı num için, sonucu tek bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    addDigits(38) // 2 döndürür\n    Çünkü 3 + 8 = 11, ve 1 + 1 = 2. 2 tek bir basamak olduğundan, sonuç 2'dir.\n*/\nfunc addDigits(num int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    addDigits(38) // trả về 2\n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n*/\nfunc addDigits(num int) int {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9750832091118405",
      "sw": "0.9933234370022743",
      "tr": "0.9824251838860331",
      "vi": "0.975644339938264"
    },
    "canonical_solution": "for num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}",
    "instruction": {
      "es": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Go باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nAşağıdaki Go kodunun işlevini açıklayan, en fazla 500 karakterlik bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8952355836092448",
      "sw": "0.9102365472457616",
      "tr": "0.8379515748706882",
      "vi": "0.9263474574515014"
    },
    "level": "",
    "test": "func TestAddDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, addDigits(38))\n\tassert.Equal(0, addDigits(0))\n\tassert.Equal(9, addDigits(9))\n\tassert.Equal(6, addDigits(123))\n\tassert.Equal(6, addDigits(456))\n\tassert.Equal(9, addDigits(9999))\n\tassert.Equal(1, addDigits(100))\n\tassert.Equal(2, addDigits(1010))\n\tassert.Equal(1, addDigits(1234))\n\tassert.Equal(3, addDigits(9876))\n\tassert.Equal(1, addDigits(199))\n}",
    "entry_point": "addDigits",
    "signature": "func addDigits(num int) int",
    "docstring": {
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    addDigits(38) // devuelve 2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "إعطاء عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    addDigits(38) // يعيد 2\n    لأن 3 + 8 = 11، و1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Kwa kupewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    addDigits(38) // inarudisha 2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Verilen bir negatif olmayan tam sayı num için, sonucu yalnızca bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    addDigits(38) // 2 döndürür\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    addDigits(38) // trả về 2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "docstring_bertscore": {
      "es": "0.9901229056726591",
      "arb": "0.9589601824528576",
      "sw": "0.9910379958380868",
      "tr": "0.9738000568503551",
      "vi": "0.9587142780411364"
    }
  },
  {
    "task_id": "Go/49",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras,\ny tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila.\nEl que quita la última piedra gana el juego.\nDado el número de piedras n, determina si puedes ganar el juego si tanto tú\ncomo tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة،\nوأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة.\nالشخص الذي يزيل الحجر الأخير يفوز باللعبة.\nبالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت\nوخصمك تلعبان بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nUnacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo la mawe n,\nna wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo.\nYule anayeondoa jiwe la mwisho anashinda mchezo.\nUkipatiwa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe\nna mpinzani wako mna cheza kwa umahiri. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız\nve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız.\nSon taşı alan oyunu kazanır.\nTaş sayısı n verildiğinde, hem sizin hem de rakibinizin en iyi şekilde oynadığı durumda oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá,\nvà bạn cùng đối thủ của mình lần lượt lấy đi từ 1 đến 3 viên đá từ đống.\nNgười lấy viên đá cuối cùng sẽ thắng trò chơi.\nCho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn\nvà đối thủ của bạn chơi tối ưu hay không. Lưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {"
    },
    "prompt_bertscore": {
      "es": "0.9973095514888825",
      "arb": "0.9919457366794163",
      "sw": "0.991135721985556",
      "tr": "0.9772478830043587",
      "vi": "0.9837101238209478"
    },
    "canonical_solution": "return n%4 != 0\n}",
    "instruction": {
      "es": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando un máximo de 500 caracteres.",
      "arb": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nAşağıdaki Go kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.8848247694480632",
      "sw": "0.9338646242217667",
      "tr": "0.8457458310224972",
      "vi": "0.9233882620348436"
    },
    "level": "",
    "test": "func TestCanWinNim(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, canWinNim(1))\n\tassert.Equal(true, canWinNim(2))\n\tassert.Equal(true, canWinNim(3))\n\tassert.Equal(false, canWinNim(4))\n\tassert.Equal(true, canWinNim(5))\n\tassert.Equal(true, canWinNim(6))\n\tassert.Equal(true, canWinNim(7))\n\tassert.Equal(false, canWinNim(8))\n\tassert.Equal(true, canWinNim(9))\n\tassert.Equal(true, canWinNim(10))\n\tassert.Equal(true, canWinNim(11))\n\tassert.Equal(false, canWinNim(12))\n\tassert.Equal(true, canWinNim(13))\n\tassert.Equal(true, canWinNim(14))\n\tassert.Equal(true, canWinNim(15))\n\tassert.Equal(false, canWinNim(16))\n\tassert.Equal(true, canWinNim(17))\n\tassert.Equal(true, canWinNim(18))\n\tassert.Equal(true, canWinNim(19))\n\tassert.Equal(false, canWinNim(20))\n}",
    "entry_point": "canWinNim",
    "signature": "func canWinNim(n int) bool",
    "docstring": {
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quita la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaweza kucheza kwa ustadi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşından oluşan bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem sizin hem de rakibinizin en iyi şekilde oynadığını varsayarak oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nBazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của mình lần lượt lấy từ 1 đến 3 viên đá ra khỏi đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. Lưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "es": "0.9948346169411877",
      "arb": "0.9816461555316143",
      "sw": "0.9926377649269419",
      "tr": "0.9602065880938515",
      "vi": "0.9762334776484135"
    }
  },
  {
    "task_id": "Go/50",
    "prompt": {
      "es": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct calcula la suma de dos enteros si la suma es par,\no el producto de los dos enteros si la suma es impar.\n\nEjemplos:\n\tEvenSumOrOddProduct(2, 3) // devuelve 6\n\tEvenSumOrOddProduct(5, 5) // devuelve 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "arb": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct تحسب مجموع عددين صحيحين إذا كان المجموع زوجيًا،\nأو حاصل ضرب العددين إذا كان المجموع فرديًا.\n\nأمثلة:\n\tEvenSumOrOddProduct(2, 3) // يعيد 6\n\tEvenSumOrOddProduct(5, 5) // يعيد 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "sw": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct huhesabu jumla ya namba mbili ikiwa jumla ni shufwa,\nau bidhaa ya namba mbili ikiwa jumla ni witiri.\n\nMifano:\n\tEvenSumOrOddProduct(2, 3) // inarejesha 6\n\tEvenSumOrOddProduct(5, 5) // inarejesha 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "tr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct iki tamsayının toplamı çift ise toplamı,\ntoplam tek ise iki tamsayının çarpımını hesaplar.\n\nÖrnekler:\n\tEvenSumOrOddProduct(2, 3) // 6 döndürür\n\tEvenSumOrOddProduct(5, 5) // 10 döndürür\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "vi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct tính tổng của hai số nguyên nếu tổng là số chẵn,\nhoặc tích của hai số nguyên nếu tổng là số lẻ.\n\nVí dụ:\n\tEvenSumOrOddProduct(2, 3) // trả về 6\n\tEvenSumOrOddProduct(5, 5) // trả về 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {"
    },
    "prompt_bertscore": {
      "es": "0.9946137399574769",
      "arb": "0.9898805766077966",
      "sw": "0.9751231338184285",
      "tr": "0.9674865901891613",
      "vi": "0.9930954093248463"
    },
    "canonical_solution": "sum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}",
    "instruction": {
      "es": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Go en español utilizando como máximo 500 caracteres.",
      "arb": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Go باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Go kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nGo kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Go bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9671195212450088",
      "arb": "0.9025638528871459",
      "sw": "0.9338646242217667",
      "tr": "0.8715266640681585",
      "vi": "0.9078436470454343"
    },
    "level": "",
    "test": "func TestEvenSumOrOddProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, EvenSumOrOddProduct(2, 3))\n\tassert.Equal(10, EvenSumOrOddProduct(5, 5))\n\tassert.Equal(2, EvenSumOrOddProduct(1, 1))\n\tassert.Equal(0, EvenSumOrOddProduct(0, 0))\n\tassert.Equal(-2, EvenSumOrOddProduct(-1, -1))\n\tassert.Equal(300, EvenSumOrOddProduct(100, 200))\n\tassert.Equal(12, EvenSumOrOddProduct(3, 4))\n\tassert.Equal(0, EvenSumOrOddProduct(-5, 5))\n\tassert.Equal(56, EvenSumOrOddProduct(7, 8))\n\tassert.Equal(90, EvenSumOrOddProduct(9, 10))\n\tassert.Equal(154, EvenSumOrOddProduct(11, 14))\n}",
    "entry_point": "EvenSumOrOddProduct",
    "signature": "func EvenSumOrOddProduct(a, b int) int",
    "docstring": {
      "es": "EvenSumOrOddProduct calcula la suma de dos enteros si la suma es par, o el producto de los dos enteros si la suma es impar.\n\nEjemplos:\n\tEvenSumOrOddProduct(2, 3) // devuelve 6\n\tEvenSumOrOddProduct(5, 5) // devuelve 10",
      "arb": "EvenSumOrOddProduct يحسب مجموع عددين صحيحين إذا كان المجموع زوجيًا، أو حاصل ضرب العددين إذا كان المجموع فرديًا.\n\nأمثلة:\n\tEvenSumOrOddProduct(2, 3) // يعيد 6\n\tEvenSumOrOddProduct(5, 5) // يعيد 10",
      "sw": "EvenSumOrOddProduct huhesabu jumla ya nambari mbili ikiwa jumla ni shufwa, au kuzidisha nambari hizo mbili ikiwa jumla ni witiri.\n\nMifano:\n\tEvenSumOrOddProduct(2, 3) // inarudisha 6\n\tEvenSumOrOddProduct(5, 5) // inarudisha 10",
      "tr": "EvenSumOrOddProduct, toplam çiftse iki tam sayının toplamını, toplam tekse iki tam sayının çarpımını hesaplar.\n\nÖrnekler:\n\tEvenSumOrOddProduct(2, 3) // 6 döndürür\n\tEvenSumOrOddProduct(5, 5) // 10 döndürür",
      "vi": "EvenSumOrOddProduct tính tổng của hai số nguyên nếu tổng là số chẵn, hoặc tích của hai số nguyên nếu tổng là số lẻ.\n\nVí dụ:\n\tEvenSumOrOddProduct(2, 3) // trả về 6\n\tEvenSumOrOddProduct(5, 5) // trả về 10"
    },
    "docstring_bertscore": {
      "es": "0.9921119903083425",
      "arb": "0.9838982267917878",
      "sw": "0.9470560650870558",
      "tr": "0.9835625414478388",
      "vi": "0.981479107381164"
    }
  }
]