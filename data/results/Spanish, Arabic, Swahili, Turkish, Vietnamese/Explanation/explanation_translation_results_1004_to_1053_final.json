[
  {
    "task_id": "Kotlin/1",
    "prompt": {
      "en": "/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "es": "/**\n    * Verificar si en la lista dada de números, hay dos números que estén más cerca uno del otro que\n    * el umbral dado.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "arb": "/**\n    * تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n    * العتبة المعطاة.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "sw": "/**\n    * Angalia kama katika orodha iliyotolewa ya nambari, nambari yoyote mbili ziko karibu zaidi na kila moja kuliko\n    * kizingiti kilichotolewa.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "tr": "/**\n    * Verilen sayı listesindeki herhangi iki sayının\n    * verilen eşikten daha yakın olup olmadığını kontrol edin.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "vi": "/**\n    * Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n    * ngưỡng đã cho hay không.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean"
    },
    "prompt_bertscore": {
      "es": "0.9687236602022465",
      "arb": "0.9879715400156702",
      "sw": "0.9879715400156702",
      "tr": "0.9456702209185753",
      "vi": "0.9527515926328501"
    },
    "canonical_solution": "{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}",
    "instruction": {
      "en": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8824183623818255",
      "sw": "0.912915077934017",
      "tr": "0.8945846718505934",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "// Test cases\nfun main() {\n    println(\"start\")\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n\n}",
    "entry_point": "hasCloseElements",
    "signature": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "es": "Verifica si en la lista dada de números, hay dos números que estén más cerca uno del otro que el umbral dado.",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9391279320584291",
      "arb": "0.9754973534562983",
      "sw": "0.9613544730658522",
      "tr": "0.892139730490435",
      "vi": "0.9516579337548721"
    }
  },
  {
    "task_id": "Kotlin/2",
    "prompt": {
      "en": "/**\n * Finds all Armstrong numbers within a specified range.\n * An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\n * For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "es": "/**\n * Encuentra todos los números de Armstrong dentro de un rango especificado.\n * Un número de Armstrong es un número que es igual a la suma de sus propios dígitos, cada uno elevado a la potencia del número de 3.\n * Por ejemplo, 153 es un número de Armstrong porque 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "arb": "/**\n * يجد جميع الأعداد أرمسترونغ ضمن نطاق محدد.\n * عدد أرمسترونغ هو عدد يساوي مجموع أرقامه كل منها مرفوع إلى قوة العدد 3.\n * على سبيل المثال، 153 هو عدد أرمسترونغ لأن 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "sw": "/**\n * Inapata namba zote za Armstrong ndani ya upeo maalum.\n * Namba ya Armstrong ni namba ambayo ni sawa na jumla ya tarakimu zake kila moja ikiwa imeinuliwa kwa nguvu ya namba ya 3.\n * Kwa mfano, 153 ni namba ya Armstrong kwa sababu 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "tr": "/**\n * Belirtilen aralıktaki tüm Armstrong sayılarını bulur.\n * Bir Armstrong sayısı, kendi basamaklarının her birinin 3 sayısının kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\n * Örneğin, 153 bir Armstrong sayısıdır çünkü 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "vi": "/**\n * Tìm tất cả các số Armstrong trong một phạm vi được chỉ định.\n * Một số Armstrong là một số mà bằng tổng của các chữ số của nó, mỗi chữ số được nâng lên lũy thừa của số 3.\n * Ví dụ, 153 là một số Armstrong vì 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9884675200771144",
      "arb": "0.9806889557254072",
      "sw": "0.9806889557254072",
      "tr": "0.9839204733944638",
      "vi": "0.9733374466929249"
    },
    "canonical_solution": "{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}",
    "instruction": {
      "en": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8925133542371616",
      "sw": "0.9437925679266526",
      "tr": "0.8984486286528651",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(findArmstrongNumbersInRange(1, 500) == listOf(1, 153, 370, 371, 407))\n    check(findArmstrongNumbersInRange(500, 1000) == emptyList<Int>())\n    check(findArmstrongNumbersInRange(1, 100) == listOf(1))\n    check(findArmstrongNumbersInRange(100, 200) == listOf(153))\n    check(findArmstrongNumbersInRange(100, 1000) == listOf(153, 370, 371, 407))\n}\n\n\nmain()",
    "entry_point": "findArmstrongNumbersInRange",
    "signature": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>",
    "docstring": {
      "en": "Finds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "es": "Encuentra todos los números de Armstrong dentro de un rango especificado.  \nUn número de Armstrong es un número que es igual a la suma de sus propios dígitos, cada uno elevado a la potencia del número de 3.  \nPor ejemplo, 153 es un número de Armstrong porque 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()",
      "arb": "يجد جميع أرقام أرمسترونغ ضمن نطاق محدد.  \nرقم أرمسترونغ هو رقم يساوي مجموع أرقامه الخاصة، كل منها مرفوع إلى قوة الرقم 3.  \nعلى سبيل المثال، 153 هو رقم أرمسترونغ لأن 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()",
      "sw": "Inapata nambari zote za Armstrong ndani ya safu maalum.  \nNambari ya Armstrong ni nambari ambayo ni sawa na jumla ya tarakimu zake kila moja ikiwa imeinuliwa kwa nguvu ya nambari ya 3.  \nKwa mfano, 153 ni nambari ya Armstrong kwa sababu 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "tr": "Belirtilen bir aralık içindeki tüm Armstrong sayılarını bulur.\nBir Armstrong sayısı, kendi basamaklarının her birinin 3. kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\nÖrneğin, 153 bir Armstrong sayısıdır çünkü 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "vi": "Tìm tất cả các số Armstrong trong một phạm vi xác định.\nMột số Armstrong là một số mà bằng tổng các chữ số của chính nó, mỗi chữ số được nâng lên lũy thừa của số 3.\nVí dụ, 153 là một số Armstrong vì 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()"
    },
    "docstring_bertscore": {
      "es": "0.9788440767463551",
      "arb": "0.9788440767463551",
      "sw": "0.9768379098979028",
      "tr": "0.9678296248572085",
      "vi": "0.9788440767463551"
    }
  },
  {
    "task_id": "Kotlin/3",
    "prompt": {
      "en": "/**\n * Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\n * to safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\n * so you need to ensure that no M consecutive test tubes contain chemicals.\n *\n * Write a function that calculates the total number of safe placement options.\n *\n * Example:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Constraints:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Note: The result can be a large number, so return it as a Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "es": "/**\n * Dado un laboratorio con N tubos de ensayo dispuestos en línea recta, necesitas encontrar el número de formas\n * de colocar de manera segura productos químicos en los tubos de ensayo. Colocar productos químicos en M tubos de ensayo consecutivos causará una explosión,\n * por lo que necesitas asegurarte de que no haya M tubos de ensayo consecutivos que contengan productos químicos.\n *\n * Escribe una función que calcule el número total de opciones de colocación segura.\n *\n * Ejemplo:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Restricciones:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Nota: El resultado puede ser un número grande, así que devuélvelo como un Long.\n */",
      "arb": "/**\n * بالنظر إلى مختبر يحتوي على N من أنابيب الاختبار مرتبة في خط مستقيم، تحتاج إلى إيجاد عدد الطرق\n * لوضع المواد الكيميائية بأمان في أنابيب الاختبار. وضع المواد الكيميائية في M من أنابيب الاختبار المتتالية سيسبب انفجارًا،\n * لذا تحتاج إلى التأكد من أن لا تحتوي M من أنابيب الاختبار المتتالية على مواد كيميائية.\n *\n * اكتب دالة تحسب العدد الإجمالي لخيارات الوضع الآمن.\n *\n * مثال:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * القيود:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * ملاحظة: يمكن أن تكون النتيجة عددًا كبيرًا، لذا أعدها كـ Long.\n */ \n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "sw": "/**\n * Ukiwa na maabara yenye mirija ya majaribio N iliyopangwa kwa mstari wa moja kwa moja, unahitaji kupata idadi ya njia\n * za kuweka kemikali kwa usalama kwenye mirija ya majaribio. Kuweka kemikali kwenye mirija ya majaribio M mfululizo kutasababisha mlipuko,\n * kwa hivyo unahitaji kuhakikisha kuwa hakuna mirija ya majaribio M mfululizo yenye kemikali.\n *\n * Andika kazi inayohesabu jumla ya chaguzi salama za uwekaji.\n *\n * Mfano:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Vikwazo:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Kumbuka: Matokeo yanaweza kuwa namba kubwa, hivyo yarudishe kama Long.\n */",
      "tr": "/**\n * Bir laboratuvarda düz bir çizgide düzenlenmiş N adet test tüpü verildiğinde, kimyasalları test tüplerine güvenli bir şekilde yerleştirmenin kaç yolu olduğunu bulmanız gerekiyor. M ardışık test tüpüne kimyasal yerleştirmek bir patlamaya neden olacak, bu yüzden hiçbir M ardışık test tüpünün kimyasal içermediğinden emin olmalısınız.\n *\n * Toplam güvenli yerleştirme seçeneği sayısını hesaplayan bir fonksiyon yazın.\n *\n * Örnek:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Kısıtlamalar:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Not: Sonuç büyük bir sayı olabilir, bu yüzden Long olarak döndürün.\n */",
      "vi": "/**\n * Cho một phòng thí nghiệm với N ống nghiệm được sắp xếp thành một hàng thẳng, bạn cần tìm số cách\n * để đặt hóa chất an toàn trong các ống nghiệm. Đặt hóa chất trong M ống nghiệm liên tiếp sẽ gây ra vụ nổ,\n * vì vậy bạn cần đảm bảo rằng không có M ống nghiệm liên tiếp nào chứa hóa chất.\n *\n * Viết một hàm tính tổng số tùy chọn đặt an toàn.\n *\n * Ví dụ:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Ràng buộc:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Lưu ý: Kết quả có thể là một số lớn, vì vậy hãy trả về nó dưới dạng Long.\n */ \n\nfun countSafePlacementOptions(N: Int, M: Int): Long"
    },
    "prompt_bertscore": {
      "es": "0.9603674787024898",
      "arb": "0.9955034054341322",
      "sw": "0.9586824971801708",
      "tr": "0.9451259736745398",
      "vi": "0.9988352314456114"
    },
    "canonical_solution": "{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}",
    "instruction": {
      "en": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.9437925679266526",
      "tr": "0.8951376588313946",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    // Test cases\n    check(countSafePlacementOptions(4, 3) == 13L)\n    check(countSafePlacementOptions(3, 2) == 5L)\n    check(countSafePlacementOptions(5, 2) == 13L)\n    check(countSafePlacementOptions(7, 3) == 81L)\n    check(countSafePlacementOptions(10, 4) == 773L)\n    check(countSafePlacementOptions(12, 5) == 3525L)\n}\n\nmain()",
    "entry_point": "countSafePlacementOptions",
    "signature": "fun countSafePlacementOptions(N: Int, M: Int): Long",
    "docstring": {
      "en": "Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.",
      "es": "Dado un laboratorio con N tubos de ensayo dispuestos en línea recta, necesitas encontrar el número de formas de colocar de manera segura productos químicos en los tubos de ensayo. Colocar productos químicos en M tubos de ensayo consecutivos causará una explosión, por lo que debes asegurarte de que no haya M tubos de ensayo consecutivos que contengan productos químicos.\n\nEscribe una función que calcule el número total de opciones de colocación segura.\n\nEjemplo:\n>>> countSafePlacementOptions(4, 3)\n13\n\nRestricciones:\n1 < N < 32\n2 <= M <= 5\n\nNota: El resultado puede ser un número grande, por lo que devuélvelo como un Long.",
      "arb": "نظرًا لوجود مختبر يحتوي على N من أنابيب الاختبار مرتبة في خط مستقيم، تحتاج إلى إيجاد عدد الطرق لوضع المواد الكيميائية بأمان في أنابيب الاختبار. وضع المواد الكيميائية في M من أنابيب الاختبار المتتالية سيتسبب في انفجار، لذا تحتاج إلى التأكد من أن لا تحتوي M من أنابيب الاختبار المتتالية على مواد كيميائية.\n\nاكتب دالة تحسب العدد الإجمالي لخيارات الوضع الآمن.\n\nمثال:\n>>> countSafePlacementOptions(4, 3)\n13\n\nالقيود:\n1 < N < 32\n2 <= M <= 5\n\nملاحظة: قد تكون النتيجة عددًا كبيرًا، لذا قم بإرجاعها كـ Long.",
      "sw": "Kwa kuzingatia maabara yenye mirija ya majaribio N iliyopangwa kwa mstari wa moja kwa moja, unahitaji kupata idadi ya njia za kuweka kemikali kwa usalama kwenye mirija ya majaribio. Kuweka kemikali kwenye mirija ya majaribio M mfululizo kutaweza kusababisha mlipuko, hivyo unahitaji kuhakikisha kuwa hakuna mirija ya majaribio M mfululizo yenye kemikali.\n\nAndika kazi inayohesabu jumla ya chaguo salama za uwekaji.\n\nMfano:\n>>> countSafePlacementOptions(4, 3)\n13\n\nVikwazo:\n1 < N < 32\n2 <= M <= 5\n\nKumbuka: Matokeo yanaweza kuwa namba kubwa, hivyo irudishe kama Long.",
      "tr": "Bir laboratuvarda düz bir çizgide düzenlenmiş N adet test tüpü verildiğinde, test tüplerine kimyasalları güvenli bir şekilde yerleştirmenin kaç yolu olduğunu bulmanız gerekiyor. M ardışık test tüpüne kimyasal yerleştirmek bir patlamaya neden olacaktır, bu yüzden hiçbir M ardışık test tüpünün kimyasal içermediğinden emin olmalısınız.\n\nGüvenli yerleştirme seçeneklerinin toplam sayısını hesaplayan bir fonksiyon yazın.\n\nÖrnek:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKısıtlamalar:\n1 < N < 32\n2 <= M <= 5\n\nNot: Sonuç büyük bir sayı olabilir, bu yüzden Long olarak döndürün.",
      "vi": "Cho một phòng thí nghiệm với N ống nghiệm được sắp xếp thành một hàng thẳng, bạn cần tìm số cách để đặt hóa chất an toàn vào các ống nghiệm. Đặt hóa chất vào M ống nghiệm liên tiếp sẽ gây ra vụ nổ, vì vậy bạn cần đảm bảo rằng không có M ống nghiệm liên tiếp nào chứa hóa chất.\n\nViết một hàm tính tổng số tùy chọn đặt hóa chất an toàn.\n\nVí dụ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nRàng buộc:\n1 < N < 32\n2 <= M <= 5\n\nLưu ý: Kết quả có thể là một số lớn, vì vậy hãy trả về nó dưới dạng Long."
    },
    "docstring_bertscore": {
      "es": "0.9928783063183751",
      "arb": "0.9957717550789104",
      "sw": "0.999926308128636",
      "tr": "0.9802833524873339",
      "vi": "0.9969184482686247"
    }
  },
  {
    "task_id": "Kotlin/4",
    "prompt": {
      "en": "/**\n * Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\n * that are both prime and palindrome.\n *\n * Example:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n *\n * Note:\n * - A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n * - A palindrome number is a number that reads the same forwards and backwards.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "es": "/**\n * Dado un entero 'n', encuentra y devuelve la cantidad de números entre 11 y 'n' (inclusive)\n * que son tanto primos como palíndromos.\n *\n * Ejemplo:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Porque hay dos números, 11 y 22, que son primos y palíndromos entre 11 y 50.\n *\n * Nota:\n * - Un número primo es un entero positivo mayor que 1 que no tiene divisores enteros positivos aparte de 1 y sí mismo.\n * - Un número palíndromo es un número que se lee igual de adelante hacia atrás y viceversa.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "arb": "/**\n * بالنظر إلى عدد صحيح 'n'، قم بإيجاد وإرجاع عدد الأرقام بين 11 و'n' (شاملاً)\n * التي تكون كلاً من أعداد أولية ومتطابقة عند قراءتها من الأمام والخلف.\n *\n * مثال:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // لأن هناك رقمين، 11 و22، هما عددان أوليان ومتطابقان عند قراءتهما من الأمام والخلف بين 11 و50.\n *\n * ملاحظة:\n * - العدد الأولي هو عدد صحيح موجب أكبر من 1 ولا يوجد له قواسم صحيحة موجبة أخرى غير 1 ونفسه.\n * - العدد المتطابق عند قراءته من الأمام والخلف هو عدد يقرأ بنفس الطريقة من الأمام والخلف.\n */",
      "sw": "/**\n * Ukipewa nambari 'n', tafuta na rudisha idadi ya nambari kati ya 11 na 'n' (pamoja na 11 na 'n')\n * ambazo ni zote mbili, nambari kuu na palindromu.\n *\n * Mfano:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Kwa sababu kuna nambari mbili, 11 na 22, ambazo ni nambari kuu na palindromu kati ya 11 na 50.\n *\n * Kumbuka:\n * - Nambari kuu ni nambari nzima chanya kubwa kuliko 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe.\n * - Nambari ya palindromu ni nambari inayosomwa sawa mbele na nyuma.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "tr": "/**\n * Bir tamsayı 'n' verildiğinde, 11 ile 'n' (dahil) arasında hem asal hem de palindrom olan sayıların sayısını bulun ve döndürün.\n *\n * Örnek:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Çünkü 11 ve 22, 11 ile 50 arasında hem asal hem de palindrom olan iki sayıdır.\n *\n * Not:\n * - Bir asal sayı, 1'den büyük ve kendisinden başka pozitif böleni olmayan pozitif bir tam sayıdır.\n * - Bir palindrom sayı, ileri ve geri okunduğunda aynı olan bir sayıdır.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "vi": "/**\n * Cho một số nguyên 'n', tìm và trả về số lượng các số giữa 11 và 'n' (bao gồm cả 11 và 'n')\n * mà vừa là số nguyên tố vừa là số đối xứng.\n *\n * Ví dụ:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Bởi vì có hai số, 11 và 22, vừa là số nguyên tố vừa là số đối xứng giữa 11 và 50.\n *\n * Lưu ý:\n * - Số nguyên tố là một số nguyên dương lớn hơn 1 mà không có ước số nguyên dương nào khác ngoài 1 và chính nó.\n * - Số đối xứng là một số mà đọc xuôi hay ngược đều giống nhau.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9861109692365165",
      "arb": "0.953149449286063",
      "sw": "0.9624743511541268",
      "tr": "0.9663700888173641",
      "vi": "0.955159588742136"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}",
    "instruction": {
      "en": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nAşağıdaki Kotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9203800049140702",
      "sw": "0.918038549982431",
      "tr": "0.8848116598429149",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(countPrimePalindromeNumbers(50) == 1) // There are two prime palindrome numbers between 11 and 50 (11).\n    check(countPrimePalindromeNumbers(150) == 3) // There are three prime palindrome numbers between 11 and 100 (11, 101, 131).\n    check(countPrimePalindromeNumbers(200) == 6) // There are four prime palindrome numbers between 11 and 200 (11, 101, 131, 151, 181, 191).\n    check(countPrimePalindromeNumbers(11) == 1)  // The only prime palindrome number between 11 and 11 is 11 itself.\n}\n\nmain()",
    "entry_point": "countPrimePalindromeNumbers",
    "signature": "fun countPrimePalindromeNumbers(n: Int): Int",
    "docstring": {
      "en": "Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.",
      "es": "Dado un entero 'n', encuentra y devuelve el conteo de números entre 11 y 'n' (inclusive) que son tanto primos como palíndromos.\n\nEjemplo:\n>>> countPrimePalindromeNumbers(50)\n2 // Porque hay dos números, 11 y 22, que son primos y palíndromos entre 11 y 50.\n\nNota:\n- Un número primo es un entero positivo mayor que 1 que no tiene divisores enteros positivos distintos de 1 y él mismo.\n- Un número palíndromo es un número que se lee igual hacia adelante y hacia atrás.",
      "arb": "إعطاء عدد صحيح 'n'، إيجاد وإرجاع عدد الأرقام بين 11 و 'n' (شاملاً) التي هي أعداد أولية و أعداد متناظرة.\n\nمثال:\n>>> countPrimePalindromeNumbers(50)\n2 // لأن هناك رقمين، 11 و 22، هما عددان أوليان و متناظران بين 11 و 50.\n\nملاحظة:\n- العدد الأولي هو عدد صحيح موجب أكبر من 1 ولا يحتوي على قواسم صحيحة موجبة أخرى غير 1 ونفسه.\n- العدد المتناظر هو عدد يقرأ بنفس الطريقة من الأمام والخلف.",
      "sw": "Kwa kupewa nambari kamili 'n', tafuta na rudisha idadi ya nambari kati ya 11 na 'n' (ikiwemo) ambazo ni zote mbili nambari za kwanza na palindrome.\n\nMfano:\n>>> countPrimePalindromeNumbers(50)\n2 // Kwa sababu kuna nambari mbili, 11 na 22, ambazo ni za kwanza na palindrome kati ya 11 na 50.\n\nKumbuka:\n- Nambari ya kwanza ni nambari kamili chanya zaidi ya 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe.\n- Nambari ya palindrome ni nambari inayosomwa sawa mbele na nyuma.",
      "tr": "Verilen bir tamsayı 'n' için, 11 ile 'n' (dahil) arasında hem asal hem de palindrom olan sayıların sayısını bulun ve döndürün.\n\nÖrnek:\n>>> countPrimePalindromeNumbers(50)\n2 // Çünkü 11 ve 22 olmak üzere, 11 ile 50 arasında asal ve palindrom olan iki sayı vardır.\n\nNot:\n- Asal sayı, 1 ve kendisi dışında pozitif tam böleni olmayan 1'den büyük pozitif bir tam sayıdır.\n- Palindrom sayı, ileri ve geri aynı şekilde okunan bir sayıdır.",
      "vi": "Đưa ra một số nguyên 'n', tìm và trả về số lượng các số giữa 11 và 'n' (bao gồm cả 11 và 'n') mà vừa là số nguyên tố vừa là số đối xứng.\n\nVí dụ:\n>>> countPrimePalindromeNumbers(50)\n2 // Bởi vì có hai số, 11 và 22, vừa là số nguyên tố vừa là số đối xứng giữa 11 và 50.\n\nLưu ý:\n- Một số nguyên tố là một số nguyên dương lớn hơn 1 mà không có ước số nguyên dương nào khác ngoài 1 và chính nó.\n- Một số đối xứng là một số mà khi đọc xuôi hay ngược đều giống nhau."
    },
    "docstring_bertscore": {
      "es": "0.9843731520328423",
      "arb": "0.9714929649746349",
      "sw": "0.9709538821205063",
      "tr": "0.9837121101247581",
      "vi": "0.9469432430306279"
    }
  },
  {
    "task_id": "Kotlin/5",
    "prompt": {
      "en": "\n/**\n    * Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\n    * A Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\n    * The function returns a list of triples (a, b, c) that satisfy the conditions.\n    *\n    * Example:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n    * (3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n    * (5, 12, 13) and (6, 8, 10) are other valid triplets.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "es": "/**\n    * Dado un límite, encuentra todos los tríos pitagóricos (a, b, c) tales que a < b < c y a + b + c <= límite.\n    * Un trío pitagórico es un conjunto de tres enteros positivos a, b y c, donde a^2 + b^2 = c^2.\n    * La función devuelve una lista de tríos (a, b, c) que satisfacen las condiciones.\n    *\n    * Ejemplo:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explicación: Para límite=30, la función encuentra tríos pitagóricos donde a + b + c es menor o igual a 30.\n    * (3, 4, 5) es el primer trío con a^2 + b^2 = c^2 y a + b + c = 12, que es menor que 30.\n    * (5, 12, 13) y (6, 8, 10) son otros tríos válidos.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "arb": "/**\n    * بالنظر إلى حد معين، ابحث عن جميع الثلاثيات البايثاغورية (a, b, c) بحيث a < b < c و a + b + c <= الحد.\n    * الثلاثية البايثاغورية هي مجموعة من ثلاثة أعداد صحيحة موجبة a، b، و c، حيث a^2 + b^2 = c^2.\n    * تُرجع الدالة قائمة من الثلاثيات (a, b, c) التي تفي بالشروط.\n    *\n    * مثال:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * تفسير: بالنسبة للحد=30، تجد الدالة الثلاثيات البايثاغورية حيث a + b + c أقل من أو يساوي 30.\n    * (3, 4, 5) هي الثلاثية الأولى حيث a^2 + b^2 = c^2 و a + b + c = 12، وهو أقل من 30.\n    * (5, 12, 13) و (6, 8, 10) هما ثلاثيات صحيحة أخرى.\n**/ \n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "sw": "/**\n    * Ukipewa kikomo, tafuta triplets zote za Pythagorean (a, b, c) ambapo a < b < c na a + b + c <= kikomo.\n    * Triplet ya Pythagorean ni seti ya namba tatu chanya a, b, na c, ambapo a^2 + b^2 = c^2.\n    * Kazi inarudisha orodha ya tatu (a, b, c) zinazokidhi masharti.\n    *\n    * Mfano:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Maelezo: Kwa kikomo=30, kazi inapata triplets za Pythagorean ambapo a + b + c ni ndogo au sawa na 30.\n    * (3, 4, 5) ni triplet ya kwanza yenye a^2 + b^2 = c^2 na a + b + c = 12, ambayo ni ndogo kuliko 30.\n    * (5, 12, 13) na (6, 8, 10) ni triplets zingine halali.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "tr": "/**\n    * Bir limit verildiğinde, a < b < c ve a + b + c <= limit olacak şekilde tüm Pisagor üçlülerini (a, b, c) bulun.\n    * Pisagor üçlüsü, a^2 + b^2 = c^2 olan üç pozitif tam sayı a, b ve c kümesidir.\n    * Fonksiyon, koşulları sağlayan üçlülerin bir listesini döndürür.\n    *\n    * Örnek:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Açıklama: limit=30 için, fonksiyon a + b + c'nin 30'a eşit veya daha küçük olduğu Pisagor üçlülerini bulur.\n    * (3, 4, 5), a^2 + b^2 = c^2 ve a + b + c = 12 olan ilk üçlüdür, bu 30'dan küçüktür.\n    * (5, 12, 13) ve (6, 8, 10) diğer geçerli üçlülerdir.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "vi": "/**\n    * Cho một giới hạn, tìm tất cả các bộ ba Pythagore (a, b, c) sao cho a < b < c và a + b + c <= giới hạn.\n    * Một bộ ba Pythagore là một tập hợp ba số nguyên dương a, b và c, trong đó a^2 + b^2 = c^2.\n    * Hàm trả về một danh sách các bộ ba (a, b, c) thỏa mãn các điều kiện.\n    *\n    * Ví dụ:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Giải thích: Với giới hạn=30, hàm tìm các bộ ba Pythagore mà a + b + c nhỏ hơn hoặc bằng 30.\n    * (3, 4, 5) là bộ ba đầu tiên với a^2 + b^2 = c^2 và a + b + c = 12, nhỏ hơn 30.\n    * (5, 12, 13) và (6, 8, 10) là các bộ ba hợp lệ khác.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> "
    },
    "prompt_bertscore": {
      "es": "0.9980583880253839",
      "arb": "0.9925156072426055",
      "sw": "0.9901197275865626",
      "tr": "0.9517246735628997",
      "vi": "0.9934330809726055"
    },
    "canonical_solution": "{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}",
    "instruction": {
      "en": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9217428079583506",
      "sw": "0.9437925679266526",
      "tr": "0.8945846718505934",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    val result1 = findPythagoreanTriplets(20)\n    val expected1 = listOf(Triple(3, 4, 5))\n    check(result1 == expected1) // Should print true\n\n    \n    val result2 = findPythagoreanTriplets(30)\n    val expected2 = listOf(Triple(3, 4, 5), Triple(5, 12, 13), Triple(6, 8, 10))\n    check(result2 == expected2) // Should print true\n \n}\n\n\nmain()",
    "entry_point": "findPythagoreanTriplets",
    "signature": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>",
    "docstring": {
      "en": "Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.",
      "es": "Dado un límite, encuentra todos los tríos pitagóricos (a, b, c) tales que a < b < c y a + b + c <= límite.\nUn trío pitagórico es un conjunto de tres enteros positivos a, b y c, donde a^2 + b^2 = c^2.\nLa función devuelve una lista de tríos (a, b, c) que satisfacen las condiciones.\n\nEjemplo:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplicación: Para límite=30, la función encuentra tríos pitagóricos donde a + b + c es menor o igual a 30.\n(3, 4, 5) es el primer trío con a^2 + b^2 = c^2 y a + b + c = 12, que es menor que 30.\n(5, 12, 13) y (6, 8, 10) son otros tríos válidos.",
      "arb": "معطى حد، ابحث عن جميع الثلاثيات البايثاغورية (a، b، c) بحيث a < b < c و a + b + c <= الحد.\nالثلاثية البايثاغورية هي مجموعة من ثلاثة أعداد صحيحة موجبة a، b، و c، حيث a^2 + b^2 = c^2.\nتُرجع الدالة قائمة من الثلاثيات (a، b، c) التي تفي بالشروط.\n\nمثال:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nتوضيح: للحد=30، تجد الدالة الثلاثيات البايثاغورية حيث a + b + c أقل من أو يساوي 30.\n(3، 4، 5) هي الثلاثية الأولى حيث a^2 + b^2 = c^2 و a + b + c = 12، وهو أقل من 30.\n(5، 12، 13) و (6، 8، 10) هي ثلاثيات صحيحة أخرى.",
      "sw": "Kwa kupewa kikomo, pata triplets zote za Pythagorean (a, b, c) ambapo a < b < c na a + b + c <= kikomo. \nTriplet ya Pythagorean ni seti ya namba tatu za mzima chanya a, b, na c, ambapo a^2 + b^2 = c^2. \nKazi inarudisha orodha ya tatu (a, b, c) zinazokidhi masharti.\n\nMfano:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nMaelezo: Kwa kikomo=30, kazi inapata triplets za Pythagorean ambapo a + b + c ni ndogo au sawa na 30.\n(3, 4, 5) ni triplet ya kwanza na a^2 + b^2 = c^2 na a + b + c = 12, ambayo ni ndogo kuliko 30.\n(5, 12, 13) na (6, 8, 10) ni triplets zingine halali.",
      "tr": "Verilen bir sınır için, a < b < c ve a + b + c <= sınır olacak şekilde tüm Pisagor üçlülerini (a, b, c) bulun. \nBir Pisagor üçlüsü, a^2 + b^2 = c^2 eşitliğini sağlayan üç pozitif tam sayı a, b ve c'den oluşan bir settir. \nFonksiyon, koşulları sağlayan üçlülerin (a, b, c) bir listesini döndürür.\n\nÖrnek:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nAçıklama: limit=30 için, fonksiyon a + b + c'nin 30'dan küçük veya eşit olduğu Pisagor üçlülerini bulur.\n(3, 4, 5) ilk üçlüdür ve a^2 + b^2 = c^2 ile a + b + c = 12 eşitliğini sağlar, bu da 30'dan küçüktür.\n(5, 12, 13) ve (6, 8, 10) diğer geçerli üçlülerdir.",
      "vi": "Cho một giới hạn, tìm tất cả các bộ ba Pythagore (a, b, c) sao cho a < b < c và a + b + c <= giới hạn.\nMột bộ ba Pythagore là một tập hợp gồm ba số nguyên dương a, b và c, trong đó a^2 + b^2 = c^2.\nHàm trả về một danh sách các bộ ba (a, b, c) thỏa mãn các điều kiện.\n\nVí dụ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nGiải thích: Với giới hạn=30, hàm tìm các bộ ba Pythagore mà a + b + c nhỏ hơn hoặc bằng 30.\n(3, 4, 5) là bộ ba đầu tiên với a^2 + b^2 = c^2 và a + b + c = 12, nhỏ hơn 30.\n(5, 12, 13) và (6, 8, 10) là các bộ ba hợp lệ khác."
    },
    "docstring_bertscore": {
      "es": "0.9977870589248903",
      "arb": "0.9935715263481869",
      "sw": "0.9924858126854502",
      "tr": "0.9723425071143211",
      "vi": "0.9966262629781224"
    }
  },
  {
    "task_id": "Kotlin/6",
    "prompt": {
      "en": "/**\n * Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\n * and counts the number of words in it. Words in the input string are separated by spaces.\n *\n * Example:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "es": "/**\n * Escribe una función en Kotlin que tome una cadena como entrada (longitud que no exceda los 80 caracteres)\n * y cuente el número de palabras en ella. Las palabras en la cadena de entrada están separadas por espacios.\n *\n * Ejemplo:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "arb": "/**\n * اكتب دالة بلغة كوتلن تأخذ سلسلة نصية كمدخل (بطول لا يتجاوز 80 حرفًا)\n * وتقوم بعد الكلمات فيها. الكلمات في السلسلة النصية المدخلة مفصولة بمسافات.\n *\n * مثال:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "sw": "/**\n * Andika kazi ya Kotlin inayochukua kamba kama ingizo (urefu usiozidi herufi 80)\n * na kuhesabu idadi ya maneno ndani yake. Maneno katika kamba ya ingizo yanatenganishwa na nafasi.\n *\n * Mfano:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "tr": "/**\n * Bir Kotlin fonksiyonu yazın, bu fonksiyon bir dizeyi girdi olarak alır (uzunluğu 80 karakteri geçmemeli)\n * ve içindeki kelimelerin sayısını sayar. Girdi dizesindeki kelimeler boşluklarla ayrılmıştır.\n *\n * Örnek:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "vi": "/**\n * Viết một hàm Kotlin nhận một chuỗi làm đầu vào (độ dài không vượt quá 80 ký tự)\n * và đếm số lượng từ trong đó. Các từ trong chuỗi đầu vào được phân tách bằng dấu cách.\n *\n * Ví dụ:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int"
    },
    "prompt_bertscore": {
      "es": "0.9881600402472723",
      "arb": "0.9805211130534327",
      "sw": "1",
      "tr": "0.9692244073928354",
      "vi": "0.9955772959358772"
    },
    "canonical_solution": "{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}",
    "instruction": {
      "en": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9032058262786508",
      "sw": "0.9437925679266526",
      "tr": "0.9518293517737051",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    // Test cases\n    check(countWords(\"This is a book\") == 4)\n    check(countWords(\"   Hello   World!  World World \") == 3)\n    check(countWords(\"A  string  with  multiple  spaces\") == 5)\n    check(countWords(\"\") == 0) // Edge case: Empty string should have 0 words\n    check(countWords(\"SingleWord\") == 1) // Edge case: String with a single word\n    check(countWords(\"a a a a a a a a a a a a\") == 1) \n    check(countWords(\"a a a ab ab c c c c c c b a c\") == 4) \n}\n\n\nmain()",
    "entry_point": "countWords",
    "signature": "fun countWords(inputString: String): Int",
    "docstring": {
      "en": "Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "es": "Escriba una función en Kotlin que tome una cadena como entrada (longitud que no exceda los 80 caracteres) y cuente el número de palabras en ella. Las palabras en la cadena de entrada están separadas por espacios.\n\nEjemplo:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "arb": "اكتب دالة Kotlin تأخذ سلسلة نصية كمدخل (طولها لا يتجاوز 80 حرفًا) وتحصي عدد الكلمات فيها. الكلمات في السلسلة النصية المدخلة مفصولة بمسافات.\n\nمثال:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "sw": "Andika kazi ya Kotlin inayopokea kamba kama ingizo (urefu usiozidi herufi 80) na kuhesabu idadi ya maneno ndani yake. Maneno katika kamba ya ingizo yanatenganishwa na nafasi.\n\nMfano:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "tr": "Bir Kotlin fonksiyonu yazın, bu fonksiyon bir dizeyi girdi olarak alır (uzunluğu 80 karakteri geçmemelidir) ve içindeki kelimelerin sayısını sayar. Girdi dizesindeki kelimeler boşluklarla ayrılmıştır.\n\nÖrnek:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "vi": "Viết một hàm Kotlin nhận một chuỗi làm đầu vào (độ dài không vượt quá 80 ký tự) và đếm số lượng từ trong đó. Các từ trong chuỗi đầu vào được ngăn cách bởi dấu cách.\n\nVí dụ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5"
    },
    "docstring_bertscore": {
      "es": "0.9864547984260879",
      "arb": "0.9830518627381981",
      "sw": "0.9999996027392379",
      "tr": "0.9545309235861607",
      "vi": "0.994158081863383"
    }
  },
  {
    "task_id": "Kotlin/7",
    "prompt": {
      "en": "\n\n/**\n  * Generates a Pascal's Triangle up to the specified number of rows.\n  * In Pascal's Triangle, each number is the sum of the two numbers directly above it.\n  * The function returns a list of lists, where each inner list represents a row in the triangle.\n  *\n  * Example:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "es": "/**\n  * Genera un Triángulo de Pascal hasta el número especificado de filas.\n  * En el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.\n  * La función devuelve una lista de listas, donde cada lista interna representa una fila en el triángulo.\n  *\n  * Ejemplo:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "arb": "/**\n  * يولد مثلث باسكال حتى العدد المحدد من الصفوف.\n  * في مثلث باسكال، كل رقم هو مجموع الرقمين الموجودين مباشرة فوقه.\n  * تُرجع الدالة قائمة من القوائم، حيث تمثل كل قائمة داخلية صفًا في المثلث.\n  *\n  * مثال:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/ \n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "sw": "/**\n  * Hutengeneza Pembetatu ya Pascal hadi idadi maalum ya mistari.\n  * Katika Pembetatu ya Pascal, kila namba ni jumla ya namba mbili zilizo juu yake moja kwa moja.\n  * Kazi inarudisha orodha ya orodha, ambapo kila orodha ya ndani inawakilisha mstari katika pembetatu.\n  *\n  * Mfano:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "tr": "/**\n  * Belirtilen satır sayısına kadar Pascal Üçgeni oluşturur.\n  * Pascal Üçgeni'nde, her sayı doğrudan üstündeki iki sayının toplamıdır.\n  * Fonksiyon, her bir iç listenin üçgendeki bir satırı temsil ettiği, listelerden oluşan bir liste döndürür.\n  *\n  * Örnek:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "vi": "/**\n  * Tạo ra một Tam giác Pascal đến số hàng được chỉ định.\n  * Trong Tam giác Pascal, mỗi số là tổng của hai số trực tiếp phía trên nó.\n  * Hàm trả về một danh sách các danh sách, trong đó mỗi danh sách con đại diện cho một hàng trong tam giác.\n  *\n  * Ví dụ:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9954422272767735",
      "sw": "0.9864049422004482",
      "tr": "0.9954422272767735",
      "vi": "0.9928181213129216"
    },
    "canonical_solution": "{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}",
    "instruction": {
      "en": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nAşağıdaki Kotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9274963355754072",
      "sw": "0.918038549982431",
      "tr": "0.8863419082984076",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    check(generatePascalsTriangle(1) == listOf(listOf(1)))\n    check(generatePascalsTriangle(2) == listOf(listOf(1), listOf(1, 1)))\n    check(generatePascalsTriangle(3) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1)))\n    check(generatePascalsTriangle(4) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1)))\n    check(generatePascalsTriangle(5) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1)))\n    check(generatePascalsTriangle(6) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1), listOf(1, 5, 10, 10, 5, 1)))\n\n}\n\nmain()",
    "entry_point": "generatePascalsTriangle",
    "signature": "fun generatePascalsTriangle(rows: Int): List<List<Int>>",
    "docstring": {
      "en": "Generates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "es": "Genera un Triángulo de Pascal hasta el número especificado de filas.  \nEn el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.  \nLa función devuelve una lista de listas, donde cada lista interna representa una fila en el triángulo.\n\nEjemplo:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "arb": "ينشئ مثلث باسكال حتى العدد المحدد من الصفوف. في مثلث باسكال، كل رقم هو مجموع الرقمين الموجودين مباشرة فوقه. تُرجع الدالة قائمة من القوائم، حيث تمثل كل قائمة داخلية صفًا في المثلث.\n\nمثال:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "sw": "Hutengeneza Pembetatu ya Pascal hadi idadi maalum ya safu.\nKatika Pembetatu ya Pascal, kila namba ni jumla ya namba mbili zilizo juu yake moja kwa moja.\nKazi inarudisha orodha ya orodha, ambapo kila orodha ya ndani inawakilisha safu katika pembetatu.\n\nMfano:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "tr": "Belirtilen satır sayısına kadar Pascal Üçgeni oluşturur.\nPascal Üçgeni'nde, her sayı doğrudan üstündeki iki sayının toplamıdır.\nFonksiyon, her bir iç listenin üçgendeki bir satırı temsil ettiği, listelerden oluşan bir liste döndürür.\n\nÖrnek:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "vi": "Tạo một Tam giác Pascal lên đến số hàng được chỉ định.  \nTrong Tam giác Pascal, mỗi số là tổng của hai số trực tiếp phía trên nó.  \nHàm trả về một danh sách các danh sách, trong đó mỗi danh sách con đại diện cho một hàng trong tam giác.  \n\nVí dụ:  \n>>> generatePascalsTriangle(3)  \n[[1], [1, 1], [1, 2, 1]]  \n>>> generatePascalsTriangle(5)  \n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]"
    },
    "docstring_bertscore": {
      "es": "0.9976104765161503",
      "arb": "0.9803647909435582",
      "sw": "0.9778268905650754",
      "tr": "0.9833952946670075",
      "vi": "0.9836533155319718"
    }
  },
  {
    "task_id": "Kotlin/8",
    "prompt": {
      "en": "/**\n * Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n * - For profit up to 100,000, the bonus is 10%.\n * - For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n * - For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n * - For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n * - For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n * - For profit above 1,000,000, it's 1% for the amount over 1,000,000. \n * The function returns the total bonus amount.\n * Example:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "es": "/**\n * Calcula el bono basado en la cantidad de ganancia dada. El bono se calcula en un sistema escalonado:\n * - Para ganancias hasta 100,000, el bono es del 10%.\n * - Para ganancias superiores a 100,000 y hasta 200,000, es del 10% para los primeros 100,000 y del 7.5% para el resto.\n * - Para ganancias entre 200,000 y 400,000, es del 5% para la cantidad superior a 200,000.\n * - Para ganancias entre 400,000 y 600,000, es del 3% para la cantidad superior a 400,000.\n * - Para ganancias entre 600,000 y 1,000,000, es del 1.5% para la cantidad superior a 600,000.\n * - Para ganancias superiores a 1,000,000, es del 1% para la cantidad superior a 1,000,000. \n * La función devuelve la cantidad total del bono.\n * Ejemplo:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "arb": "/**\n * يحسب المكافأة بناءً على مبلغ الربح المعطى. يتم حساب المكافأة على نظام متدرج:\n * - للربح حتى 100,000، تكون المكافأة 10%.\n * - للربح فوق 100,000 وحتى 200,000، تكون 10% لأول 100,000 و 7.5% للباقي.\n * - للربح بين 200,000 و 400,000، تكون 5% للمبلغ فوق 200,000.\n * - للربح بين 400,000 و 600,000، تكون 3% للمبلغ فوق 400,000.\n * - للربح بين 600,000 و 1,000,000، تكون 1.5% للمبلغ فوق 600,000.\n * - للربح فوق 1,000,000، تكون 1% للمبلغ فوق 1,000,000.\n * تعيد الدالة إجمالي مبلغ المكافأة.\n * مثال:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "sw": "/**\n * Inahesabu bonasi kulingana na kiasi cha faida kilichotolewa. Bonasi inahesabiwa kwa mfumo wa ngazi:\n * - Kwa faida hadi 100,000, bonasi ni 10%.\n * - Kwa faida zaidi ya 100,000 na hadi 200,000, ni 10% kwa 100,000 za kwanza na 7.5% kwa kiasi kilichobaki.\n * - Kwa faida kati ya 200,000 na 400,000, ni 5% kwa kiasi kilicho juu ya 200,000.\n * - Kwa faida kati ya 400,000 na 600,000, ni 3% kwa kiasi kilicho juu ya 400,000.\n * - Kwa faida kati ya 600,000 na 1,000,000, ni 1.5% kwa kiasi kilicho juu ya 600,000.\n * - Kwa faida zaidi ya 1,000,000, ni 1% kwa kiasi kilicho juu ya 1,000,000. \n * Kazi inarudisha jumla ya kiasi cha bonasi.\n * Mfano:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "tr": "/**\n * Verilen kar miktarına göre bonus hesaplar. Bonus, kademeli bir sistem üzerinden hesaplanır:\n * - 100.000'e kadar olan kar için bonus %10'dur.\n * - 100.000'in üzerinde ve 200.000'e kadar olan kar için, ilk 100.000 için %10 ve geri kalan için %7.5'tir.\n * - 200.000 ile 400.000 arasında olan kar için, 200.000'in üzerindeki miktar için %5'tir.\n * - 400.000 ile 600.000 arasında olan kar için, 400.000'in üzerindeki miktar için %3'tür.\n * - 600.000 ile 1.000.000 arasında olan kar için, 600.000'in üzerindeki miktar için %1.5'tir.\n * - 1.000.000'un üzerindeki kar için, 1.000.000'un üzerindeki miktar için %1'dir.\n * Fonksiyon toplam bonus miktarını döndürür.\n * Örnek:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "vi": "/**\n * Tính toán tiền thưởng dựa trên số lợi nhuận đã cho. Tiền thưởng được tính theo hệ thống bậc thang:\n * - Đối với lợi nhuận lên đến 100,000, tiền thưởng là 10%.\n * - Đối với lợi nhuận trên 100,000 và lên đến 200,000, là 10% cho 100,000 đầu tiên và 7.5% cho phần còn lại.\n * - Đối với lợi nhuận giữa 200,000 và 400,000, là 5% cho số tiền trên 200,000.\n * - Đối với lợi nhuận giữa 400,000 và 600,000, là 3% cho số tiền trên 400,000.\n * - Đối với lợi nhuận giữa 600,000 và 1,000,000, là 1.5% cho số tiền trên 600,000.\n * - Đối với lợi nhuận trên 1,000,000, là 1% cho số tiền trên 1,000,000. \n * Hàm trả về tổng số tiền thưởng.\n * Ví dụ:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double "
    },
    "prompt_bertscore": {
      "es": "0.9886206641008923",
      "arb": "0.9959878649334762",
      "sw": "0.9832717465700038",
      "tr": "0.9904301868721201",
      "vi": "0.9884260063274781"
    },
    "canonical_solution": "{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}",
    "instruction": {
      "en": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8984770327973531",
      "sw": "0.9437925679266526",
      "tr": "0.9349461666465017",
      "vi": "0.9053631508470706"
    },
    "level": "",
    "test": "fun main(){\n    check(calculateBonus(50_000.00) == 5000.00)\n    check(calculateBonus(210_000.00) == 18000.00)\n    check(calculateBonus(150_000.00) == 13750.00)\n    check(calculateBonus(250_000.00) == 20000.00)\n    check(calculateBonus(450_000.00) == 29000.00)\n    check(calculateBonus(650_000.00) == 34250.00)\n    check(calculateBonus(1_050_000.00) == 40000.00)\n    check(calculateBonus(2_000_000.00) == 49500.00)\n}\n\nmain()",
    "entry_point": "calculateBonus",
    "signature": "fun calculateBonus(profit: Double): Double",
    "docstring": {
      "en": "Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "es": "Calcula el bono basado en la cantidad de ganancia dada. El bono se calcula en un sistema escalonado:\n- Para ganancias de hasta 100,000, el bono es del 10%.\n- Para ganancias superiores a 100,000 y hasta 200,000, es del 10% para los primeros 100,000 y del 7.5% para el resto.\n- Para ganancias entre 200,000 y 400,000, es del 5% para la cantidad superior a 200,000.\n- Para ganancias entre 400,000 y 600,000, es del 3% para la cantidad superior a 400,000.\n- Para ganancias entre 600,000 y 1,000,000, es del 1.5% para la cantidad superior a 600,000.\n- Para ganancias superiores a 1,000,000, es del 1% para la cantidad superior a 1,000,000.\nLa función devuelve la cantidad total del bono.\nEjemplo:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "arb": "يحسب المكافأة بناءً على مبلغ الربح المعطى. يتم حساب المكافأة بنظام متدرج:\n- بالنسبة للربح حتى 100,000، تكون المكافأة 10%.\n- بالنسبة للربح الذي يزيد عن 100,000 وحتى 200,000، تكون 10% لأول 100,000 و 7.5% للباقي.\n- بالنسبة للربح بين 200,000 و 400,000، تكون 5% للمبلغ الذي يزيد عن 200,000.\n- بالنسبة للربح بين 400,000 و 600,000، تكون 3% للمبلغ الذي يزيد عن 400,000.\n- بالنسبة للربح بين 600,000 و 1,000,000، تكون 1.5% للمبلغ الذي يزيد عن 600,000.\n- بالنسبة للربح الذي يزيد عن 1,000,000، تكون 1% للمبلغ الذي يزيد عن 1,000,000.\nتعيد الدالة إجمالي مبلغ المكافأة.\nمثال:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "sw": "Hesabu bonasi kulingana na kiasi cha faida kilichotolewa. Bonasi inahesabiwa kwa mfumo wa viwango:\n- Kwa faida hadi 100,000, bonasi ni 10%.\n- Kwa faida zaidi ya 100,000 na hadi 200,000, ni 10% kwa 100,000 za kwanza na 7.5% kwa kiasi kinachobaki.\n- Kwa faida kati ya 200,000 na 400,000, ni 5% kwa kiasi zaidi ya 200,000.\n- Kwa faida kati ya 400,000 na 600,000, ni 3% kwa kiasi zaidi ya 400,000.\n- Kwa faida kati ya 600,000 na 1,000,000, ni 1.5% kwa kiasi zaidi ya 600,000.\n- Kwa faida zaidi ya 1,000,000, ni 1% kwa kiasi zaidi ya 1,000,000.\nKazi inarudisha jumla ya kiasi cha bonasi.\nMfano:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "tr": "Verilen kar miktarına göre primi hesaplar. Prim, kademeli bir sisteme göre hesaplanır:\n- 100.000'e kadar olan kar için prim %10'dur.\n- 100.000'in üzerinde ve 200.000'e kadar olan kar için, ilk 100.000 için %10 ve geri kalan için %7.5'tir.\n- 200.000 ile 400.000 arasında olan kar için, 200.000'in üzerindeki miktar için %5'tir.\n- 400.000 ile 600.000 arasında olan kar için, 400.000'in üzerindeki miktar için %3'tür.\n- 600.000 ile 1.000.000 arasında olan kar için, 600.000'in üzerindeki miktar için %1.5'tir.\n- 1.000.000'un üzerindeki kar için, 1.000.000'un üzerindeki miktar için %1'dir.\nFonksiyon toplam prim miktarını döndürür.\nÖrnek:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "vi": "Tính toán tiền thưởng dựa trên số lợi nhuận đã cho. Tiền thưởng được tính theo hệ thống phân tầng:\n- Đối với lợi nhuận lên đến 100,000, tiền thưởng là 10%.\n- Đối với lợi nhuận trên 100,000 và lên đến 200,000, là 10% cho 100,000 đầu tiên và 7.5% cho phần còn lại.\n- Đối với lợi nhuận từ 200,000 đến 400,000, là 5% cho số tiền trên 200,000.\n- Đối với lợi nhuận từ 400,000 đến 600,000, là 3% cho số tiền trên 400,000.\n- Đối với lợi nhuận từ 600,000 đến 1,000,000, là 1.5% cho số tiền trên 600,000.\n- Đối với lợi nhuận trên 1,000,000, là 1% cho số tiền trên 1,000,000.\nHàm trả về tổng số tiền thưởng.\nVí dụ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00"
    },
    "docstring_bertscore": {
      "es": "0.986871127704737",
      "arb": "0.987719279431756",
      "sw": "0.9757893401164196",
      "tr": "0.9860587294463043",
      "vi": "0.9790623715351124"
    }
  },
  {
    "task_id": "Kotlin/9",
    "prompt": {
      "en": "/**\n    * Returns the top ten highest scores from a given list of scores, sorted in descending order.\n    * If there are fewer than ten scores in the list, all scores are returned.\n    * Example:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "es": "/**\n    * Devuelve las diez puntuaciones más altas de una lista dada de puntuaciones, ordenadas en orden descendente.\n    * Si hay menos de diez puntuaciones en la lista, se devuelven todas las puntuaciones.\n    * Ejemplo:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "arb": "/**\n    * يعيد أعلى عشرة درجات من قائمة الدرجات المعطاة، مرتبة بترتيب تنازلي.\n    * إذا كان هناك أقل من عشر درجات في القائمة، يتم إرجاع جميع الدرجات.\n    * مثال:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "sw": "/**\n    * Inarudisha alama kumi za juu zaidi kutoka kwenye orodha iliyotolewa ya alama, zikiwa zimepangwa kwa mpangilio wa kushuka.\n    * Ikiwa kuna alama chache kuliko kumi kwenye orodha, alama zote zitarudishwa.\n    * Mfano:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "tr": "/**\n    * Verilen bir puan listesinden en yüksek on puanı, azalan sırayla döndürür.\n    * Listede ondan az puan varsa, tüm puanlar döndürülür.\n    * Örnek:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "vi": "/**\n    * Trả về mười điểm số cao nhất từ một danh sách điểm số cho trước, được sắp xếp theo thứ tự giảm dần.\n    * Nếu có ít hơn mười điểm số trong danh sách, tất cả các điểm số sẽ được trả về.\n    * Ví dụ:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> "
    },
    "prompt_bertscore": {
      "es": "0.9935300125985506",
      "arb": "0.9913277975640168",
      "sw": "0.9914394278381584",
      "tr": "0.984428967169913",
      "vi": "0.9971260170168063"
    },
    "canonical_solution": "{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}",
    "instruction": {
      "en": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nAşağıdaki Kotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.892902272523228",
      "sw": "0.918038549982431",
      "tr": "0.9031118741084212",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main(){\n    check(topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5)) == listOf(22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5))\n    check(topTenScores(listOf(5.0, 3.0, 4.0)) == listOf(5.0, 4.0, 3.0))\n    check(topTenScores(listOf(8.0, 7.5, 9.0, 10.0)) == listOf(10.0, 9.0, 8.0, 7.5))\n    check(topTenScores(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) == listOf(12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0))\n    check(topTenScores(listOf(32.0, 31.5, 33.0, 30.0)) == listOf(33.0, 32.0, 31.5, 30.0))\n}\n\nmain()",
    "entry_point": "topTenScores",
    "signature": "fun topTenScores(scores: List<Double>): List<Double>",
    "docstring": {
      "en": "Returns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "es": "Devuelve las diez puntuaciones más altas de una lista dada de puntuaciones, ordenadas en orden descendente.  \nSi hay menos de diez puntuaciones en la lista, se devuelven todas las puntuaciones.  \nEjemplo:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "arb": "يعيد أعلى عشر درجات من قائمة الدرجات المعطاة، مرتبة بترتيب تنازلي. إذا كان هناك أقل من عشر درجات في القائمة، يتم إرجاع جميع الدرجات.\n\nمثال:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "sw": "Inarejesha alama kumi za juu zaidi kutoka kwenye orodha iliyotolewa ya alama, zilizopangwa kwa mpangilio wa kushuka.\nIkiwa kuna alama chache kuliko kumi kwenye orodha, alama zote zitarudishwa.\nMfano:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "tr": "Verilen bir puan listesinden en yüksek on puanı, azalan sırada sıralanmış olarak döndürür. Listede ondan az puan varsa, tüm puanlar döndürülür.\nÖrnek:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "vi": "Trả về mười điểm số cao nhất từ danh sách điểm số đã cho, được sắp xếp theo thứ tự giảm dần. Nếu có ít hơn mười điểm số trong danh sách, tất cả các điểm số sẽ được trả về. Ví dụ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]"
    },
    "docstring_bertscore": {
      "es": "0.9937931978534218",
      "arb": "0.9899872411224123",
      "sw": "0.9913242222171581",
      "tr": "0.9929905324836599",
      "vi": "0.987303744674631"
    }
  },
  {
    "task_id": "Kotlin/10",
    "prompt": {
      "en": "/**\n * Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\n * If multiple elements have the same absolute value, the one with the smallest row index is returned,\n * and if there is still a tie, the one with the smallest column index is chosen.\n *\n * Example:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolute value 12 at row 2, column 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "es": "/**\n * Encuentra el elemento con el valor absoluto más grande en una matriz de 3x4 y devuelve su valor absoluto e índices.\n * Si múltiples elementos tienen el mismo valor absoluto, se devuelve el que tiene el índice de fila más pequeño,\n * y si todavía hay un empate, se elige el que tiene el índice de columna más pequeño.\n *\n * Ejemplo:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Valor absoluto 12 en la fila 2, columna 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Valor absoluto 4 en la fila 0, columna 0 (primera ocurrencia)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "arb": "/**\n * يجد العنصر ذو القيمة المطلقة الأكبر في مصفوفة 3x4 ويعيد قيمته المطلقة وفهارسه.\n * إذا كانت هناك عناصر متعددة لها نفس القيمة المطلقة، يتم إرجاع العنصر ذو فهرس الصف الأصغر،\n * وإذا كان هناك تعادل، يتم اختيار العنصر ذو فهرس العمود الأصغر.\n *\n * مثال:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // القيمة المطلقة 12 عند الصف 2، العمود 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // القيمة المطلقة 4 عند الصف 0، العمود 0 (الظهور الأول)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "sw": "/**\n * Inapata kipengele chenye thamani kubwa kabisa katika matrix ya 3x4 na kurudisha thamani yake kamili na fahirisi zake.\n * Ikiwa vipengele vingi vina thamani sawa kabisa, kile chenye fahirisi ndogo zaidi ya safu kitarudishwa,\n * na ikiwa bado kuna usawa, kile chenye fahirisi ndogo zaidi ya safu wima kitachaguliwa.\n *\n * Mfano:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Thamani kamili 12 katika safu 2, safu wima 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Thamani kamili 4 katika safu 0, safu wima 0 (kutokea kwa kwanza)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "tr": "/**\n * 3x4 bir matris içinde en büyük mutlak değere sahip elemanı bulur ve bu elemanın mutlak değerini ve indekslerini döndürür.\n * Birden fazla eleman aynı mutlak değere sahipse, satır indeksi en küçük olan döndürülür,\n * ve hala eşitlik varsa, sütun indeksi en küçük olan seçilir.\n *\n * Örnek:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Satır 2, sütun 3'te mutlak değer 12\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Satır 0, sütun 0'da mutlak değer 4 (ilk oluşum)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "vi": "/**\n * Tìm phần tử có giá trị tuyệt đối lớn nhất trong ma trận 3x4 và trả về giá trị tuyệt đối cùng với chỉ số của nó.\n * Nếu nhiều phần tử có cùng giá trị tuyệt đối, phần tử có chỉ số hàng nhỏ nhất sẽ được trả về,\n * và nếu vẫn còn hòa, phần tử có chỉ số cột nhỏ nhất sẽ được chọn.\n *\n * Ví dụ:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Giá trị tuyệt đối 12 tại hàng 2, cột 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Giá trị tuyệt đối 4 tại hàng 0, cột 0 (xuất hiện đầu tiên)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.998724395692994",
      "arb": "0.9835504249945958",
      "sw": "0.9712512318009154",
      "tr": "0.9822074849884188",
      "vi": "0.9791293099735212"
    },
    "canonical_solution": "{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}",
    "instruction": {
      "en": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9217428079583506",
      "sw": "0.918038549982431",
      "tr": "0.8945846718505934",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(1, -2, 3, -4), arrayOf(0, 6, -7, 8), arrayOf(9, -10, -11, -12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(4, 4, -3, -2), arrayOf(-1, 0, 4, 4), arrayOf(-2, -3, 4, -4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0))) == Triple(0, 0, 0))\n}\nmain()",
    "entry_point": "findMaxAbsElement",
    "signature": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)",
      "es": "Encuentra el elemento con el valor absoluto más grande en una matriz de 3x4 y devuelve su valor absoluto e índices. Si varios elementos tienen el mismo valor absoluto, se devuelve el que tiene el índice de fila más pequeño, y si todavía hay un empate, se elige el que tiene el índice de columna más pequeño.\n\nEjemplo:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Valor absoluto 12 en la fila 2, columna 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Valor absoluto 4 en la fila 0, columna 0 (primera ocurrencia)",
      "arb": "يجد العنصر ذو القيمة المطلقة الأكبر في مصفوفة 3x4 ويعيد قيمته المطلقة وفهارسه.\nإذا كانت هناك عناصر متعددة لها نفس القيمة المطلقة، يتم إرجاع العنصر ذو فهرس الصف الأصغر،\nوإذا كان هناك تعادل، يتم اختيار العنصر ذو فهرس العمود الأصغر.\n\nمثال:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // القيمة المطلقة 12 في الصف 2، العمود 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // القيمة المطلقة 4 في الصف 0، العمود 0 (الظهور الأول)",
      "sw": "Inapata kipengele chenye thamani kubwa kabisa katika matrix ya 3x4 na kurudisha thamani yake kamili na fahirisi zake. \nIkiwa vipengele vingi vina thamani sawa kabisa, kile chenye fahirisi ndogo ya safu kitarudishwa, \nna ikiwa bado kuna sare, kile chenye fahirisi ndogo ya safu wima kitachaguliwa.\n\nMfano:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Thamani kamili 12 katika safu 2, safu wima 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Thamani kamili 4 katika safu 0, safu wima 0 (tukio la kwanza)",
      "tr": "3x4'lük bir matris içinde en büyük mutlak değere sahip elemanı bulur ve bu elemanın mutlak değerini ve indekslerini döndürür.\nBirden fazla eleman aynı mutlak değere sahipse, satır indeksi en küçük olan eleman döndürülür,\nve hala eşitlik varsa, sütun indeksi en küçük olan eleman seçilir.\n\nÖrnek:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Satır 2, sütun 3'te mutlak değer 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Satır 0, sütun 0'da mutlak değer 4 (ilk oluşum)",
      "vi": "Tìm phần tử có giá trị tuyệt đối lớn nhất trong ma trận 3x4 và trả về giá trị tuyệt đối của nó cùng với chỉ số hàng và cột.\nNếu nhiều phần tử có cùng giá trị tuyệt đối, phần tử có chỉ số hàng nhỏ nhất sẽ được trả về,\nvà nếu vẫn còn hòa, phần tử có chỉ số cột nhỏ nhất sẽ được chọn.\n\nVí dụ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Giá trị tuyệt đối 12 tại hàng 2, cột 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Giá trị tuyệt đối 4 tại hàng 0, cột 0 (xuất hiện đầu tiên)"
    },
    "docstring_bertscore": {
      "es": "0.992410333140657",
      "arb": "0.9825852799731473",
      "sw": "0.9724936648342887",
      "tr": "0.9776826849084441",
      "vi": "0.9593459226528274"
    }
  },
  {
    "task_id": "Kotlin/11",
    "prompt": {
      "en": "/**\n    * Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\n    * The interest is compounded monthly based on the total amount in the account at the end of each month.\n    Example:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "es": "/**\n    * Calcula el total de ahorros acumulados durante un período de meses con depósitos mensuales y una tasa de interés fija.\n    * El interés se capitaliza mensualmente basado en el monto total en la cuenta al final de cada mes.\n    Ejemplo:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depósito mensual, 1% de interés mensual, durante 6 meses\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depósito mensual, 2% de interés mensual, durante 12 meses\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "arb": "/**\n    * يحسب إجمالي المدخرات المتراكمة على مدى فترة من الأشهر مع الودائع الشهرية ومعدل فائدة ثابت.\n    * يتم تركيب الفائدة شهريًا بناءً على المبلغ الإجمالي في الحساب في نهاية كل شهر.\n    مثال:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // إيداع شهري 1000، فائدة شهرية 1%، على مدى 6 أشهر\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // إيداع شهري 500، فائدة شهرية 2%، على مدى 12 شهرًا\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "sw": "/**\n    * Inahesabu jumla ya akiba iliyokusanywa kwa kipindi cha miezi na amana za kila mwezi na kiwango cha riba kisichobadilika.\n    * Riba inazidishwa kila mwezi kulingana na jumla ya kiasi kilichopo kwenye akaunti mwishoni mwa kila mwezi.\n    Mfano:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 amana ya kila mwezi, 1% riba ya kila mwezi, kwa miezi 6\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 amana ya kila mwezi, 2% riba ya kila mwezi, kwa miezi 12\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "tr": "/**\n    * Aylık mevduatlar ve sabit faiz oranı ile aylar boyunca biriken toplam tasarrufları hesaplar.\n    * Faiz, her ayın sonunda hesaptaki toplam miktar üzerinden aylık olarak bileşik şekilde hesaplanır.\n    Örnek:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 aylık mevduat, %1 aylık faiz, 6 ay boyunca\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 aylık mevduat, %2 aylık faiz, 12 ay boyunca\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "vi": "/**\n    * Tính toán tổng số tiền tiết kiệm tích lũy trong một khoảng thời gian với các khoản tiền gửi hàng tháng và lãi suất cố định.\n    * Lãi suất được tính gộp hàng tháng dựa trên tổng số tiền trong tài khoản vào cuối mỗi tháng.\n    Ví dụ:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 tiền gửi hàng tháng, 1% lãi suất hàng tháng, trong 6 tháng\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 tiền gửi hàng tháng, 2% lãi suất hàng tháng, trong 12 tháng\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double "
    },
    "prompt_bertscore": {
      "es": "0.998843772551996",
      "arb": "0.9688480028207743",
      "sw": "0.989308123849654",
      "tr": "0.9755033123677294",
      "vi": "0.9847159880705084"
    },
    "canonical_solution": "{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}",
    "instruction": {
      "en": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8925133542371616",
      "sw": "0.9437925679266526",
      "tr": "0.9349461666465017",
      "vi": "0.9473347435116477"
    },
    "level": "",
    "test": "fun main(){\n    check(calculateSavingsInterest(1000.0, 0.01, 6) == 6213.54)\n    check(calculateSavingsInterest(500.0, 0.02, 12) == 6840.17)\n    check(calculateSavingsInterest(2000.0, 0.005, 3) == 6060.2)\n    check(calculateSavingsInterest(750.0, 0.01, 10) == 7925.13)\n}\nmain()",
    "entry_point": "calculateSavingsInterest",
    "signature": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double",
    "docstring": {
      "en": "Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17",
      "es": "Calcula los ahorros totales acumulados durante un período de meses con depósitos mensuales y una tasa de interés fija.\nEl interés se capitaliza mensualmente basado en el monto total en la cuenta al final de cada mes.\nEjemplo:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depósito mensual, 1% interés mensual, durante 6 meses\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depósito mensual, 2% interés mensual, durante 12 meses\n6840.17",
      "arb": "يحسب إجمالي المدخرات المتراكمة على مدى فترة من الأشهر مع الودائع الشهرية ومعدل فائدة ثابت.\nيتم تركيب الفائدة شهريًا بناءً على المبلغ الإجمالي في الحساب في نهاية كل شهر.\nمثال:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // إيداع شهري 1000، فائدة شهرية 1%، على مدى 6 أشهر\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // إيداع شهري 500، فائدة شهرية 2%، على مدى 12 شهرًا\n6840.17",
      "sw": "Hesabu akiba jumla iliyokusanywa kwa kipindi cha miezi na amana za kila mwezi na kiwango cha riba kisichobadilika. \nRiba inakokotolewa kila mwezi kulingana na jumla ya kiasi kilichopo kwenye akaunti mwishoni mwa kila mwezi.\nMfano:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 amana ya kila mwezi, 1% riba ya kila mwezi, kwa miezi 6\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 amana ya kila mwezi, 2% riba ya kila mwezi, kwa miezi 12\n6840.17",
      "tr": "Aylık mevduatlar ve sabit faiz oranı ile aylar boyunca biriken toplam tasarrufları hesaplar.\nFaiz, her ayın sonunda hesaptaki toplam tutara göre aylık olarak bileşiklenir.\nÖrnek:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 aylık mevduat, %1 aylık faiz, 6 ay boyunca\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 aylık mevduat, %2 aylık faiz, 12 ay boyunca\n6840.17",
      "vi": "Tính tổng số tiền tiết kiệm tích lũy trong một khoảng thời gian tính bằng tháng với các khoản tiền gửi hàng tháng và lãi suất cố định. Lãi suất được tính gộp hàng tháng dựa trên tổng số tiền trong tài khoản vào cuối mỗi tháng.\nVí dụ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // khoản tiền gửi hàng tháng 1000, lãi suất hàng tháng 1%, trong 6 tháng\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // khoản tiền gửi hàng tháng 500, lãi suất hàng tháng 2%, trong 12 tháng\n6840.17"
    },
    "docstring_bertscore": {
      "es": "0.9900805974014987",
      "arb": "0.969546188610112",
      "sw": "0.9802241606337855",
      "tr": "0.9798394135857209",
      "vi": "0.9547226019038593"
    }
  },
  {
    "task_id": "Kotlin/12",
    "prompt": {
      "en": "/**\n * Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n * \n * Example:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "es": "/**\n * Genera y devuelve una lista de enteros dentro de un rango especificado (inclusivo en ambos extremos) que son divisibles por un divisor dado.\n * \n * Ejemplo:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "arb": "/**\n * يولد ويعيد قائمة من الأعداد الصحيحة ضمن نطاق محدد (يشمل كلا الطرفين) التي تقبل القسمة على مقسوم معين.\n * \n * مثال:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "sw": "/**\n * Hutoa na kurudisha orodha ya nambari za mzima ndani ya safu maalum (ikiwemo mwisho wote) ambazo zinagawanyika kwa mgawanyiko uliotolewa.\n * \n * Mfano:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "tr": "/**\n * Belirtilen bir aralıkta (her iki uç dahil) verilen bir bölenle bölünebilen tamsayıların bir listesini oluşturur ve döndürür.\n * \n * Örnek:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "vi": "/**\n * Tạo và trả về một danh sách các số nguyên trong một phạm vi xác định (bao gồm cả hai đầu) mà có thể chia hết cho một số chia đã cho.\n * \n * Ví dụ:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9963944613234547",
      "arb": "0.9782195828283814",
      "sw": "0.9814616279076328",
      "tr": "0.9630261463526417",
      "vi": "0.9779826167838068"
    },
    "canonical_solution": "{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}",
    "instruction": {
      "en": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.918038549982431",
      "tr": "0.9095939779631137",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(printDivisibleNumbersInRange(1, 10, 2) == listOf(2, 4, 6, 8, 10))\n    check(printDivisibleNumbersInRange(3, 15, 3) == listOf(3, 6, 9, 12, 15))\n    check(printDivisibleNumbersInRange(5, 20, 5) == listOf(5, 10, 15, 20))\n    check(printDivisibleNumbersInRange(7, 21, 7) == listOf(7, 14, 21))\n    check(printDivisibleNumbersInRange(10, 30, 10) == listOf(10, 20, 30))\n}\n\nmain()",
    "entry_point": "printDivisibleNumbersInRange",
    "signature": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>",
    "docstring": {
      "en": "Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "es": "Genera y devuelve una lista de enteros dentro de un rango especificado (inclusivo en ambos extremos) que son divisibles por un divisor dado.\n\nEjemplo:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "arb": "ينشئ ويعيد قائمة من الأعداد الصحيحة ضمن نطاق محدد (بما في ذلك كلا الطرفين) التي تكون قابلة للقسمة على مقسوم معين.\n\nمثال:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "sw": "Hutengeneza na kurudisha orodha ya nambari za mzima ndani ya safu maalum (ikijumuisha ncha zote mbili) ambazo zinagawanyika kwa mgawanyiko uliotolewa.\n\nMfano:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "tr": "Belirtilen bir aralıkta (her iki uç dahil) verilen bir bölen ile bölünebilen tamsayıların bir listesini oluşturur ve döndürür.\n\nÖrnek:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "vi": "Tạo và trả về một danh sách các số nguyên trong một phạm vi xác định (bao gồm cả hai đầu) mà có thể chia hết cho một số chia cho trước.\n\nVí dụ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]"
    },
    "docstring_bertscore": {
      "es": "0.9898213847542482",
      "arb": "0.9802857360519063",
      "sw": "0.9713970265005951",
      "tr": "0.9584479147001687",
      "vi": "0.9623353098874025"
    }
  },
  {
    "task_id": "Kotlin/13",
    "prompt": {
      "en": "/**\n * Converts a given integer to its octal, decimal, and hexadecimal representations.\n * Args:\n *   number: An integer number to be converted.\n * Returns:\n *   A Triple containing the octal, decimal, and hexadecimal representations of the number.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "es": "/**\n * Convierte un número entero dado a sus representaciones en octal, decimal y hexadecimal.\n * Argumentos:\n *   number: Un número entero a ser convertido.\n * Devuelve:\n *   Un Triple que contiene las representaciones octal, decimal y hexadecimal del número.\n * Ejemplos:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "arb": "/**\n * يحول عددًا صحيحًا معينًا إلى تمثيلاته بالنظام الثماني والعشري والسداسي العشري.\n * يعيدالحجج:\n *   number: عدد صحيح ليتم تحويله.\n * يعيد:\n *   ثلاثي يحتوي على التمثيلات بالنظام الثماني والعشري والسداسي العشري للعدد.\n * امثله:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "sw": "/**\n * Hubadilisha nambari iliyotolewa kuwa uwakilishi wake wa octal, desimali, na hexadecimal.\n * Hoja:\n *   number: Nambari ya integer inayopaswa kubadilishwa.\n * Inarejesha:\n *   Triple inayoonyesha uwakilishi wa octal, desimali, na hexadecimal wa nambari hiyo.\n * Mifano:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "tr": "/**\n * Verilen bir tam sayıyı sekizlik, ondalık ve onaltılık gösterimlerine dönüştürür.\n * Argümanlar:\n *   number: Dönüştürülecek bir tam sayı.\n * Döndürür:\n *   Sayının sekizlik, ondalık ve onaltılık gösterimlerini içeren bir Üçlü döndürür.\n * Örnekler:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "vi": "/**\n * Chuyển đổi một số nguyên đã cho thành các biểu diễn ở hệ bát phân, thập phân và thập lục phân.\n * Tham số:\n *   number: Một số nguyên cần được chuyển đổi.\n * Trả về:\n *   Một Triple chứa các biểu diễn ở hệ bát phân, thập phân và thập lục phân của số đó.\n * Ví dụ:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> "
    },
    "prompt_bertscore": {
      "es": "0.996686845244338",
      "arb": "0.9957177276152689",
      "sw": "0.9774987531756058",
      "tr": "0.9948679868452016",
      "vi": "0.9770635540107584"
    },
    "canonical_solution": "{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}",
    "instruction": {
      "en": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9255475729070739",
      "sw": "0.9437925679266526",
      "tr": "0.9349461666465017",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(convertNumberToDifferentBases(10) == Triple(\"12\", \"10\", \"A\"))\n    check(convertNumberToDifferentBases(255) == Triple(\"377\", \"255\", \"FF\"))\n    check(convertNumberToDifferentBases(16) == Triple(\"20\", \"16\", \"10\"))\n    check(convertNumberToDifferentBases(1) == Triple(\"1\", \"1\", \"1\"))\n    check(convertNumberToDifferentBases(0) == Triple(\"0\", \"0\", \"0\"))\n    check(convertNumberToDifferentBases(100) == Triple(\"144\", \"100\", \"64\"))\n    check(convertNumberToDifferentBases(500) == Triple(\"764\", \"500\", \"1F4\"))\n}\n\nmain()",
    "entry_point": "convertNumberToDifferentBases",
    "signature": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>",
    "docstring": {
      "en": "Converts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "es": "Convierte un número entero dado a sus representaciones octal, decimal y hexadecimal.\nيعيدالحجج:\nnumber: Un número entero a ser convertido.\nDevuelve:\nUn Triple que contiene las representaciones octal, decimal y hexadecimal del número.\nEjemplos:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "arb": "يقوم بتحويل عدد صحيح معطى إلى تمثيلاته بالنظام الثماني والعشري والسداسي عشر.\nHoja:\nnumber: عدد صحيح ليتم تحويله.\nيعيد:\nثلاثي يحتوي على التمثيلات بالنظام الثماني والعشري والسداسي عشر للعدد.\nامثله:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "sw": "Hufanya ubadilishaji wa nambari nzima iliyotolewa kuwa uwakilishi wake wa oktali, desimali, na heksadesimali.  \nArgümanlar:  \nnumber: Nambari nzima itakayobadilishwa.  \nInarejesha:  \nA Triple yenye uwakilishi wa oktali, desimali, na heksadesimali wa nambari hiyo.  \nMifano:  \n>>> convertNumberToDifferentBases(10)  \nTriple(\"12\", \"10\", \"A\")  \n>>> convertNumberToDifferentBases(255)  \nTriple(\"377\", \"255\", \"FF\")  \n>>> convertNumberToDifferentBases(16)  \nTriple(\"20\", \"16\", \"10\")  ",
      "tr": "Verilen bir tam sayıyı sekizlik, ondalık ve onaltılık gösterimlerine dönüştürür.\nArgümanlar:\nnumber: Dönüştürülecek bir tam sayı.\nDöndürür:\nSayının sekizlik, ondalık ve onaltılık gösterimlerini içeren bir Üçlü.\nÖrnekler:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "vi": "Chuyển đổi một số nguyên đã cho sang các biểu diễn bát phân, thập phân và thập lục phân.\nTham số:\nnumber: Một số nguyên cần được chuyển đổi.\nTrả về:\nMột Triple chứa các biểu diễn bát phân, thập phân và thập lục phân của số đó.\nVí dụ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")"
    },
    "docstring_bertscore": {
      "es": "0.9961598788434525",
      "arb": "0.9949754458813415",
      "sw": "0.9757547784301195",
      "tr": "0.9961598788434525",
      "vi": "0.9840120420001208"
    }
  },
  {
    "task_id": "Kotlin/14",
    "prompt": {
      "en": "/**\n * Returns a list of all factors of the given number, excluding the number itself.\n * A factor is a number that divides the given number without leaving a remainder.\n * Examples:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "es": "/**\n * Devuelve una lista de todos los factores del número dado, excluyendo el propio número.\n * Un factor es un número que divide al número dado sin dejar un residuo.\n * Ejemplos:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "arb": "/**\n * يُرجع قائمة بجميع عوامل العدد المعطى، باستثناء العدد نفسه.\n * العامل هو عدد يقسم العدد المعطى دون ترك باقٍ.\n * أمثلة:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "sw": "/**\n * Inarudisha orodha ya vipengele vyote vya nambari iliyotolewa, isipokuwa nambari yenyewe.\n * Kipengele ni nambari inayogawanya nambari iliyotolewa bila kuacha baki.\n * Mifano:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "tr": "/**\n * Verilen sayının kendisi hariç tüm çarpanlarının bir listesini döndürür.\n * Bir çarpan, verilen sayıyı kalan bırakmadan bölen bir sayıdır.\n * Örnekler:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "vi": "/**\n * Trả về danh sách tất cả các ước số của số đã cho, ngoại trừ chính số đó.\n * Một ước số là một số chia hết cho số đã cho mà không để lại dư.\n * Ví dụ:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9968068179944831",
      "arb": "1",
      "sw": "0.9974901065052432",
      "tr": "1",
      "vi": "0.962566515650927"
    },
    "canonical_solution": "{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}",
    "instruction": {
      "en": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nAşağıdaki Kotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9074996192254818",
      "sw": "0.918038549982431",
      "tr": "0.8863419082984076",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main(){\n    check(listFactors(10) == listOf(1, 2, 5))\n    check(listFactors(15) == listOf(1, 3, 5))\n    check(listFactors(7) == listOf(1))\n    check(listFactors(12) == listOf(1, 2, 3, 4, 6))\n    check(listFactors(9) == listOf(1, 3))\n    check(listFactors(17) == listOf(1))\n    check(listFactors(20) == listOf(1, 2, 4, 5, 10))\n}\n\nmain()",
    "entry_point": "listFactors",
    "signature": "fun listFactors(number: Int): List<Int>",
    "docstring": {
      "en": "Returns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "es": "Devuelve una lista de todos los factores del número dado, excluyendo el propio número.\nUn factor es un número que divide al número dado sin dejar un residuo.\nEjemplos:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "arb": "يعيد قائمة بجميع عوامل الرقم المعطى، باستثناء الرقم نفسه. العامل هو رقم يقسم الرقم المعطى دون ترك باقي.\nأمثلة:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "sw": "Inarudisha orodha ya vipengele vyote vya nambari iliyotolewa, isipokuwa nambari yenyewe. Kipengele ni nambari inayogawanya nambari iliyotolewa bila kuacha baki.\nMifano:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "tr": "Verilen sayının kendisi hariç, tüm bölenlerinin bir listesini döndürür.\nBir bölen, verilen sayıyı kalan bırakmadan bölen bir sayıdır.\nÖrnekler:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "vi": "Trả về một danh sách tất cả các ước số của số đã cho, ngoại trừ chính số đó.  \nMột ước số là một số chia hết số đã cho mà không để lại dư.  \nVí dụ:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9931073271477083",
      "tr": "0.9572843379280662",
      "vi": "0.9481493267042718"
    }
  },
  {
    "task_id": "Kotlin/15",
    "prompt": {
      "en": "import java.util.LinkedList\n\n/**\n    * Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n    * \n    * The process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\n    * the current number is removed from the sequence. This process continues until only one number remains in the sequence.\n    *\n    * Examples:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "es": "import java.util.LinkedList\n\n/**\n    * Encuentra el último número restante en una secuencia de n números, donde los números se eliminan en un ciclo de cada tercer elemento.\n    * \n    * El proceso comienza con el primer elemento en una secuencia de 1 a n, contando hasta tres. Cada vez que la cuenta llega a tres,\n    * el número actual se elimina de la secuencia. Este proceso continúa hasta que solo queda un número en la secuencia.\n    *\n    * Ejemplos:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "arb": "import java.util.LinkedList\n\n/**\n    * يجد الرقم الأخير المتبقي في تسلسل من n أرقام، حيث يتم حذف الأرقام في دورة كل عنصر ثالث.\n    * \n    * تبدأ العملية بالعنصر الأول في تسلسل من 1 إلى n، مع العد حتى ثلاثة. في كل مرة يصل العد إلى ثلاثة،\n    * يتم إزالة الرقم الحالي من التسلسل. تستمر هذه العملية حتى يبقى رقم واحد فقط في التسلسل.\n    *\n    * أمثلة:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "sw": "import java.util.LinkedList\n\n/**\n    * Inapata nambari ya mwisho iliyobaki katika mlolongo wa nambari n, ambapo nambari zinaondolewa katika mzunguko wa kila kipengele cha tatu.\n    * \n    * Mchakato huanza na kipengele cha kwanza katika mlolongo kutoka 1 hadi n, ukihesabu hadi tatu. Kila wakati hesabu inapofikia tatu,\n    * nambari ya sasa inaondolewa kutoka kwenye mlolongo. Mchakato huu unaendelea hadi nambari moja tu ibaki katika mlolongo.\n    *\n    * Mifano:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "tr": "import java.util.LinkedList\n\n/**\n    * n sayısından oluşan bir dizide, her üçüncü elemanın bir döngü içinde elendiği bir dizide kalan son sayıyı bulur.\n    * \n    * İşlem, 1'den n'e kadar olan bir dizideki ilk elemanla başlar ve üçe kadar sayılır. Her seferinde sayı üçe ulaştığında,\n    * mevcut sayı diziden çıkarılır. Bu işlem, dizide yalnızca bir sayı kalana kadar devam eder.\n    *\n    * Örnekler:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "vi": "import java.util.LinkedList\n\n/**\n    * Tìm số cuối cùng còn lại trong một dãy số gồm n số, trong đó các số bị loại bỏ theo chu kỳ mỗi phần tử thứ ba.\n    * \n    * Quá trình bắt đầu với phần tử đầu tiên trong một dãy từ 1 đến n, đếm đến ba. Mỗi khi đếm đến ba,\n    * số hiện tại sẽ bị loại bỏ khỏi dãy. Quá trình này tiếp tục cho đến khi chỉ còn lại một số trong dãy.\n    *\n    * Ví dụ:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.992176942442941",
      "arb": "0.9894338568808492",
      "sw": "0.9899894260566037",
      "tr": "0.9461944064941263",
      "vi": "0.9599406220136458"
    },
    "canonical_solution": "{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}",
    "instruction": {
      "en": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9118605492411028",
      "sw": "0.8900509334034721",
      "tr": "0.9521221329553505",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main(){\n    check(findLastRemaining(5) == 4)\n    check(findLastRemaining(10) == 4)\n    check(findLastRemaining(6) == 1)\n    check(findLastRemaining(7) == 4)\n    check(findLastRemaining(15) == 5)\n    check(findLastRemaining(20) == 20)\n    check(findLastRemaining(1) == 1)\n}\nmain()",
    "entry_point": "findLastRemaining",
    "signature": "fun findLastRemaining(n: Int): Int",
    "docstring": {
      "en": "Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "es": "Encuentra el último número restante en una secuencia de n números, donde los números se eliminan en un ciclo de cada tercer elemento.\n\nEl proceso comienza con el primer elemento en una secuencia del 1 al n, contando hasta tres. Cada vez que la cuenta llega a tres, el número actual se elimina de la secuencia. Este proceso continúa hasta que solo queda un número en la secuencia.\n\nEjemplos:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "arb": "يجد الرقم الأخير المتبقي في تسلسل من n من الأرقام، حيث يتم التخلص من الأرقام في دورة كل عنصر ثالث.\n\nتبدأ العملية بالعنصر الأول في تسلسل من 1 إلى n، مع العد حتى ثلاثة. في كل مرة يصل العد إلى ثلاثة، يتم إزالة الرقم الحالي من التسلسل. تستمر هذه العملية حتى يبقى رقم واحد فقط في التسلسل.\n\nأمثلة:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "sw": "Inapata nambari ya mwisho iliyobaki katika mlolongo wa nambari n, ambapo nambari zinaondolewa katika mzunguko wa kila kipengele cha tatu.\n\nMchakato huanza na kipengele cha kwanza katika mlolongo kutoka 1 hadi n, kuhesabu hadi tatu. Kila wakati hesabu inapofikia tatu, nambari ya sasa inaondolewa kutoka kwenye mlolongo. Mchakato huu unaendelea hadi nambari moja tu ibaki katika mlolongo.\n\nMifano:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "tr": "Son kalan sayıyı, n sayısının olduğu bir dizide bulur; burada sayılar her üçüncü elemanın döngüsel olarak elenmesiyle çıkarılır.\n\nSüreç, 1'den n'e kadar olan bir dizideki ilk elemanla başlar ve üçe kadar sayılır. Her sayım üçe ulaştığında, mevcut sayı diziden çıkarılır. Bu süreç, dizide yalnızca bir sayı kalana kadar devam eder.\n\nÖrnekler:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "vi": "Tìm số cuối cùng còn lại trong một dãy gồm n số, trong đó các số bị loại bỏ theo chu kỳ mỗi phần tử thứ ba.\n\nQuá trình bắt đầu với phần tử đầu tiên trong một dãy từ 1 đến n, đếm đến ba. Mỗi khi đếm đến ba, số hiện tại sẽ bị loại khỏi dãy. Quá trình này tiếp tục cho đến khi chỉ còn lại một số trong dãy.\n\nVí dụ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9892060278338021",
      "arb": "0.9901749468324903",
      "sw": "0.9873730666776122",
      "tr": "0.9166241030390816",
      "vi": "0.947228277627413"
    }
  },
  {
    "task_id": "Kotlin/16",
    "prompt": {
      "en": "/**\n    * Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\n    * starting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\n    Examples:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "es": "/**\n    * Extrae una secuencia específica de 4 bits de la representación binaria de un número entero decimal positivo dado,\n    * comenzando desde el 4º bit hasta el 7º bit (contando desde 0 desde la derecha), y luego devuelve su valor decimal.\n    Ejemplos:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "arb": "/**\n    * يستخرج تسلسلًا محددًا مكونًا من 4 بتات من التمثيل الثنائي لعدد عشري موجب معين،\n    * بدءًا من البت الرابع إلى البت السابع (يتم العد من 0 من اليمين)، ثم يعيد قيمته العشرية.\n    أمثلة:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/ \n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "sw": "/**\n    * Hutoa mlolongo maalum wa biti 4 kutoka kwenye uwakilishi wa binary wa nambari ya desimali chanya iliyotolewa,\n    * kuanzia biti ya 4 hadi biti ya 7 (kuhesabu kutoka 0 kutoka kulia), na kisha inarudisha thamani yake ya desimali.\n    Mifano:\n    >>> extractAndConvertToDecimal(173) // Binary ya 173 ni 10101101, biti 4-7 ni 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary ya 59 ni 111011, biti 4-7 ni 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "tr": "/**\n    * Verilen pozitif ondalık tam sayının ikili gösteriminden belirli bir 4 bitlik diziyi çıkarır,\n    * sağdan 0'dan başlayarak 4. bitten 7. bite kadar olan kısmı alır ve ardından ondalık değerini döndürür.\n    Örnekler:\n    >>> extractAndConvertToDecimal(173) // 173'ün ikili gösterimi 10101101'dir, 4-7 bitleri 1010'dır\n        10\n    >>> extractAndConvertToDecimal(59) // 59'un ikili gösterimi 111011'dir, 4-7 bitleri 0011'dir\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "vi": "/**\n    * Trích xuất một chuỗi 4 bit cụ thể từ biểu diễn nhị phân của một số nguyên thập phân dương đã cho,\n    * bắt đầu từ bit thứ 4 đến bit thứ 7 (đếm từ 0 từ bên phải), và sau đó trả về giá trị thập phân của nó.\n    Ví dụ:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9941771503799622",
      "arb": "0.9716766980770922",
      "sw": "0.9643504151030013",
      "tr": "0.9382773967668379",
      "vi": "0.9880823757682877"
    },
    "canonical_solution": "{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}",
    "instruction": {
      "en": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nAşağıdaki Kotlin kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.912915077934017",
      "tr": "0.8548047668103553",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main(){\n    check(extractAndConvertToDecimal(217) == 13)  // 173 in binary is 10101101, bits 4-7 are 1101\n    check(extractAndConvertToDecimal(173) == 10)  // 173 in binary is 10101101, bits 4-7 are 1010\n    check(extractAndConvertToDecimal(59) == 3)    // 59 in binary is 111011, bits 4-7 are 0011\n    check(extractAndConvertToDecimal(32) == 2)    // 32 in binary is 100000, bits 4-7 are 0010\n    check(extractAndConvertToDecimal(255) == 15)  // 255 in binary is 11111111, bits 4-7 are 1111\n    check(extractAndConvertToDecimal(1) == 0)     // 1 in binary is 1, bits 4-7 are 0000\n\n}\n\nmain()",
    "entry_point": "extractAndConvertToDecimal",
    "signature": "fun extractAndConvertToDecimal(number: Int): Int",
    "docstring": {
      "en": "Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "es": "Extrae una secuencia específica de 4 bits de la representación binaria de un número entero decimal positivo dado, comenzando desde el cuarto bit hasta el séptimo bit (contando desde 0 desde la derecha), y luego devuelve su valor decimal.\nEjemplos:\n>>> extractAndConvertToDecimal(173) // Binario de 173 es 10101101, bits 4-7 son 1010\n10\n>>> extractAndConvertToDecimal(59) // Binario de 59 es 111011, bits 4-7 son 0011\n3",
      "arb": "يستخرج تسلسل 4 بت معين من التمثيل الثنائي لعدد عشري موجب معين، بدءًا من البت الرابع إلى البت السابع (يتم العد من 0 من اليمين)، ثم يعيد قيمته العشرية.  \nأمثلة:  \n>>> extractAndConvertToDecimal(173) // الثنائي للعدد 173 هو 10101101، البتات من 4-7 هي 1010  \n10  \n>>> extractAndConvertToDecimal(59) // الثنائي للعدد 59 هو 111011، البتات من 4-7 هي 0011  \n3  ",
      "sw": "Hutoa mlolongo maalum wa biti 4 kutoka kwenye uwakilishi wa binary wa nambari ya desimali chanya iliyotolewa, kuanzia biti ya 4 hadi biti ya 7 (kuhesabu kutoka 0 kutoka kulia), kisha inarudisha thamani yake ya desimali. \nMifano:\n>>> extractAndConvertToDecimal(173) // Binary ya 173 ni 10101101, biti 4-7 ni 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary ya 59 ni 111011, biti 4-7 ni 0011\n3",
      "tr": "Belirtilen pozitif ondalık tam sayının ikili gösteriminden belirli bir 4 bitlik diziyi çıkarır, sağdan 0'dan başlayarak 4. bitten 7. bite kadar sayar ve ardından ondalık değerini döndürür.\nÖrnekler:\n>>> extractAndConvertToDecimal(173) // 173'ün ikilisi 10101101'dir, 4-7 bitler 1010'dır\n10\n>>> extractAndConvertToDecimal(59) // 59'un ikilisi 111011'dir, 4-7 bitler 0011'dir\n3",
      "vi": "Trích xuất một dãy 4 bit cụ thể từ biểu diễn nhị phân của một số nguyên thập phân dương đã cho, bắt đầu từ bit thứ 4 đến bit thứ 7 (đếm từ 0 từ bên phải), và sau đó trả về giá trị thập phân của nó.\n\nVí dụ:\n>>> extractAndConvertToDecimal(173) // Nhị phân của 173 là 10101101, các bit 4-7 là 1010\n10\n>>> extractAndConvertToDecimal(59) // Nhị phân của 59 là 111011, các bit 4-7 là 0011\n3"
    },
    "docstring_bertscore": {
      "es": "0.9709518958166958",
      "arb": "0.9396769464316096",
      "sw": "0.9626765568820204",
      "tr": "0.9637265170761707",
      "vi": "0.991681955533402"
    }
  },
  {
    "task_id": "Kotlin/17",
    "prompt": {
      "en": "/**\n * Performs a right circular shift on a given unsigned 32-bit integer.\n * The function shifts the bits of the input number to the right by a specified number of positions.\n * The bits that are shifted out on the right are reinserted on the left side.\n * \n * Example:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "es": "/**\n * Realiza un desplazamiento circular a la derecha en un entero sin signo de 32 bits dado.\n * La función desplaza los bits del número de entrada hacia la derecha por un número especificado de posiciones.\n * Los bits que se desplazan hacia fuera por la derecha se reinserta en el lado izquierdo.\n * \n * Ejemplo:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */ \nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "arb": "/**\n * يقوم بإجراء إزاحة دائرية إلى اليمين على عدد صحيح غير موقع 32 بت.\n * تقوم الدالة بإزاحة بتات الرقم المدخل إلى اليمين بعدد محدد من المواضع.\n * يتم إعادة إدخال البتات التي تم إزاحتها على اليمين إلى الجانب الأيسر.\n * \n * مثال:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "sw": "/**\n * Inafanya mzunguko wa kulia kwenye namba iliyotolewa ya biti 32 isiyo na alama.\n * Kazi hii inasogeza biti za namba ya ingizo kwenda kulia kwa nafasi maalum.\n * Biti ambazo zinasogezwa nje upande wa kulia zinaingizwa tena upande wa kushoto.\n * \n * Mfano:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "tr": "/**\n * Verilen işaretsiz 32-bit tamsayı üzerinde sağa dairesel kaydırma işlemi gerçekleştirir.\n * Fonksiyon, giriş numarasının bitlerini belirtilen pozisyon sayısı kadar sağa kaydırır.\n * Sağdan dışarı kaydırılan bitler, sol tarafa yeniden eklenir.\n * \n * Örnek:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "vi": "/**\n * Thực hiện dịch vòng sang phải trên một số nguyên không dấu 32-bit đã cho.\n * Hàm này dịch các bit của số đầu vào sang phải theo số vị trí được chỉ định.\n * Các bit bị dịch ra bên phải sẽ được chèn lại vào phía bên trái.\n * \n * Ví dụ:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt "
    },
    "prompt_bertscore": {
      "es": "0.9975796888070899",
      "arb": "0.9847428031719482",
      "sw": "0.9709405738849769",
      "tr": "0.9739236049473589",
      "vi": "0.9723125139267849"
    },
    "canonical_solution": "{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}",
    "instruction": {
      "en": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nKotlin kodunun Türkçe dilinde, en fazla 500 karakter kullanarak, kısa ve öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9100361291912974",
      "sw": "0.8900509334034721",
      "tr": "0.9106651916080349",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    check(circularRightShift(1023u, 20) == 4190208u)\n    check(circularRightShift(15u, 2) == 3221225475u)\n    check(circularRightShift(256u, 8) == 1u)\n    check(circularRightShift(123u, 5) == 3623878659u)\n    check(circularRightShift(4294967295u, 1) == 4294967295u)\n    check(circularRightShift(1024u, 10) == 1u)\n    check(circularRightShift(0u, 15) == 0u)\n}\nmain()",
    "entry_point": "circularRightShift",
    "signature": "fun circularRightShift(num: UInt, shift: Int): UInt",
    "docstring": {
      "en": "Performs a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "es": "Realiza un desplazamiento circular a la derecha en un entero sin signo de 32 bits dado.  \nLa función desplaza los bits del número de entrada hacia la derecha por un número especificado de posiciones.  \nLos bits que se desplazan hacia afuera por la derecha se reintegran en el lado izquierdo.\n\nEjemplo:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "arb": "يقوم بإجراء إزاحة دائرية إلى اليمين على عدد صحيح غير موقع مكون من 32 بت.\nتقوم الدالة بإزاحة بتات الرقم المدخل إلى اليمين بعدد محدد من المواضع.\nيتم إعادة إدخال البتات التي تم إزاحتها إلى الخارج على اليمين إلى الجانب الأيسر.\n\nمثال:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "sw": "Hufanya mzunguko wa kulia kwenye nambari isiyo na ishara ya biti 32 iliyotolewa.  \nKazi inasogeza biti za nambari ya ingizo kwenda kulia kwa nafasi kadhaa maalum.  \nBiti ambazo zinasogezwa nje upande wa kulia zinaingizwa tena upande wa kushoto.  \n\nMfano:  \n>>> circularRightShift(1023u, 20)  \n4190208u  \n>>> circularRightShift(15u, 2)  \n3221225475u  \n>>> circularRightShift(256u, 8)  \n1u  ",
      "tr": "Verilen işaretsiz 32 bitlik bir tamsayı üzerinde sağa dairesel kaydırma işlemi gerçekleştirir.\nFonksiyon, giriş numarasının bitlerini belirtilen pozisyon sayısı kadar sağa kaydırır.\nSağdan dışarı kaydırılan bitler, sol tarafa yeniden eklenir.\n\nÖrnek:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "vi": "Thực hiện một phép dịch vòng sang phải trên một số nguyên không dấu 32-bit đã cho.  \nHàm này dịch các bit của số đầu vào sang phải theo số vị trí được chỉ định.  \nCác bit bị dịch ra ngoài bên phải sẽ được chèn lại vào phía bên trái.  \n\nVí dụ:  \n>>> circularRightShift(1023u, 20)  \n4190208u  \n>>> circularRightShift(15u, 2)  \n3221225475u  \n>>> circularRightShift(256u, 8)  \n1u  "
    },
    "docstring_bertscore": {
      "es": "0.9857317838391209",
      "arb": "0.9832314246026537",
      "sw": "0.9795126666089186",
      "tr": "0.9701681003331322",
      "vi": "0.958558551822405"
    }
  },
  {
    "task_id": "Kotlin/18",
    "prompt": {
      "en": "/**\n    * Determines if a given integer is a perfect number. A perfect number is one whose\n    * sum of all positive divisors (excluding itself) equals the number itself.\n    * \n    * Examples:\n    * - isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "es": "/**\n    * Determina si un número entero dado es un número perfecto. Un número perfecto es aquel cuya\n    * suma de todos los divisores positivos (excluyéndose a sí mismo) es igual al propio número.\n    * \n    * Ejemplos:\n    * - isPerfectNumber(6) devuelve true porque 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) devuelve true porque 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) devuelve false porque 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "arb": "/**\n    * يحدد ما إذا كان العدد الصحيح المعطى هو عدد مثالي. العدد المثالي هو الذي\n    * يساوي مجموع جميع القواسم الموجبة (باستثناء نفسه) العدد نفسه.\n    * \n    * أمثلة:\n    * - isPerfectNumber(6) يعيد true لأن 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) يعيد true لأن 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) يعيد false لأن 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "sw": "/**\n    * Huamua kama nambari iliyotolewa ni nambari kamilifu. Nambari kamilifu ni ile ambayo\n    * jumla ya wagawanyiko wote chanya (bila kujumuisha yenyewe) ni sawa na nambari yenyewe.\n    * \n    * Mifano:\n    * - isPerfectNumber(6) inarudisha kweli kwa sababu 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) inarudisha kweli kwa sababu 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) inarudisha uongo kwa sababu 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "tr": "/**\n    * Verilen bir tam sayının mükemmel sayı olup olmadığını belirler. Mükemmel sayı, \n    * tüm pozitif bölenlerinin (kendisi hariç) toplamı sayının kendisine eşit olan sayıdır.\n    * \n    * Örnekler:\n    * - isPerfectNumber(6) true döner çünkü 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) true döner çünkü 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) false döner çünkü 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "vi": "/**\n    * Xác định xem một số nguyên đã cho có phải là số hoàn hảo hay không. Một số hoàn hảo là số có \n    * tổng của tất cả các ước dương (không bao gồm chính nó) bằng chính số đó.\n    * \n    * Ví dụ:\n    * - isPerfectNumber(6) trả về true vì 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) trả về true vì 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) trả về false vì 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean "
    },
    "prompt_bertscore": {
      "es": "0.9891815962969348",
      "arb": "0.9712641427756827",
      "sw": "0.9869992443005045",
      "tr": "0.9717789927233251",
      "vi": "0.9898293299694896"
    },
    "canonical_solution": "{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}",
    "instruction": {
      "en": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9118605492411028",
      "sw": "0.9437925679266526",
      "tr": "0.9521221329553505",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main(){\n    check(isPerfectNumber(1) == false)  // 6 is a perfect number\n    check(isPerfectNumber(6) == true)  // 6 is a perfect number\n    check(isPerfectNumber(28) == true)  // 28 is a perfect number\n    check(isPerfectNumber(10) == false)  // 10 is not a perfect number\n    check(isPerfectNumber(496) == true)  // 496 is a perfect number\n    check(isPerfectNumber(8128) == true)  // 8128 is a perfect number\n    check(isPerfectNumber(15) == false)  // 15 is not a perfect number\n    check(isPerfectNumber(20) == false)  // 20 is not a perfect number\n\n\n}\nmain()",
    "entry_point": "isPerfectNumber",
    "signature": "fun isPerfectNumber(number: Int): Boolean",
    "docstring": {
      "en": "Determines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10",
      "es": "Determina si un número entero dado es un número perfecto. Un número perfecto es aquel cuya suma de todos los divisores positivos (excluyendo el mismo) es igual al número en sí.\n\nEjemplos:\n- isPerfectNumber(6) devuelve true porque 1 + 2 + 3 = 6\n- isPerfectNumber(28) devuelve true porque 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) devuelve false porque 1 + 2 + 5 ≠ 10",
      "arb": "يتحقق مما إذا كان عدد صحيح معين هو عدد مثالي. العدد المثالي هو العدد الذي يكون مجموع جميع القواسم الموجبة له (باستثناء نفسه) يساوي العدد نفسه.\n\nأمثلة:\n- isPerfectNumber(6) يعيد true لأن 1 + 2 + 3 = 6\n- isPerfectNumber(28) يعيد true لأن 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) يعيد false لأن 1 + 2 + 5 ≠ 10",
      "sw": "Inabainisha ikiwa nambari kamili ni kamili. Nambari kamili ni ile ambayo jumla ya wagawanyaji wote chanya (bila kujumuisha yenyewe) ni sawa na nambari yenyewe.\n\nMifano:\n- isPerfectNumber(6) inarudisha kweli kwa sababu 1 + 2 + 3 = 6\n- isPerfectNumber(28) inarudisha kweli kwa sababu 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) inarudisha uongo kwa sababu 1 + 2 + 5 ≠ 10",
      "tr": "Belirtilen bir tam sayının mükemmel bir sayı olup olmadığını belirler. Mükemmel sayı, tüm pozitif bölenlerinin toplamı (kendisi hariç) sayının kendisine eşit olan bir sayıdır.\n\nÖrnekler:\n- isPerfectNumber(6) true döndürür çünkü 1 + 2 + 3 = 6\n- isPerfectNumber(28) true döndürür çünkü 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false döndürür çünkü 1 + 2 + 5 ≠ 10",
      "vi": "Xác định xem một số nguyên cho trước có phải là số hoàn hảo hay không. Một số hoàn hảo là một số mà tổng của tất cả các ước số dương (không bao gồm chính nó) bằng chính số đó.\n\nVí dụ:\n- isPerfectNumber(6) trả về true vì 1 + 2 + 3 = 6\n- isPerfectNumber(28) trả về true vì 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) trả về false vì 1 + 2 + 5 ≠ 10"
    },
    "docstring_bertscore": {
      "es": "0.9875212449418642",
      "arb": "0.9792155155588903",
      "sw": "0.9850409473738815",
      "tr": "0.9690668935006748",
      "vi": "0.9605533967391384"
    }
  },
  {
    "task_id": "Kotlin/19",
    "prompt": {
      "en": "\n/**\n * Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\n * Example:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "es": "/**\n * El tiempo pasó rápidamente, y Wang Wang había alcanzado la edad de meses para la vacunación. Wang Wang llegó al hospital y quería darse una inyección de vacuna contra la rabia, pero no pudo resistir la tentación del médico. Necesita un total de 4 inyecciones. Primero recibió tres inyecciones de Miao Sanduo, y luego la vacuna contra la rabia. Una inyección de Miao Sanduo cuesta 120 yuanes, y una inyección de vacuna contra la rabia cuesta 100 yuanes. Sin embargo, Wang Wang solo tiene a yuanes de dinero y no puede recibir todas las inyecciones de una vez. En este momento, el médico dijo: \"¿Cómo podemos completar la inyección de una vez? Debe haber un intervalo de un mes entre cada dos inyecciones...\" Así que Wang Wang decidió ahorrar dinero mientras se daba las inyecciones (porque Wang Wang es un meow que ama las inyecciones), Wang Wang Si puedo ahorrar B yuanes cada mes, ¿cuántas vacunaciones puede recibir Wangwang a tiempo?\n * Ejemplo:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */ \n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "arb": "/**\n * مر الوقت بسرعة، ووصل وانغ وانغ إلى سن الأشهر للتطعيم. جاء وانغ وانغ إلى المستشفى وأراد أن يعطي نفسه جرعة من لقاح داء الكلب، لكنه لم يستطع مقاومة إغراء الطبيب. يحتاج إلى إجمالي 4 حقنات. تلقى أولاً ثلاث جرعات من مياو ساندو، ثم لقاح داء الكلب. تكلفة جرعة مياو ساندو 120 يوان، وتكلفة جرعة لقاح داء الكلب 100 يوان. ومع ذلك، فإن وانغ وانغ لديه فقط يوان من المال ولا يمكنه أخذ جميع الجرعات دفعة واحدة. في هذا الوقت، قال الطبيب: \"كيف يمكننا إكمال الحقن في وقت واحد؟ يجب أن يكون هناك شهر بين كل جرعتين...\" لذلك قرر وانغ وانغ توفير المال أثناء إعطاء نفسه الحقن (لأن وانغ وانغ هو مياو يحب الحقن)، إذا كان وانغ وانغ يمكنه توفير B يوان كل شهر، كم عدد التطعيمات التي يمكن أن يحصل عليها وانغ وانغ في الوقت المحدد؟\n * مثال:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */ \n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "sw": "/**\n * Muda ulipita haraka, na Wang Wang alikuwa amefikia umri wa miezi kwa ajili ya chanjo. Wang Wang alifika hospitalini na alitaka kujipiga sindano ya chanjo ya kichaa cha mbwa, lakini hakuweza kuzuia majaribu ya daktari. Anahitaji jumla ya sindano 4. Kwanza alipokea sindano tatu za Miao Sanduo, na kisha chanjo ya kichaa cha mbwa. Sindano moja ya Miao Sanduo inagharimu yuan 120, na sindano moja ya chanjo ya kichaa cha mbwa inagharimu yuan 100. Hata hivyo, Wang Wang ana yuan moja tu ya pesa na hawezi kuchukua sindano zote mara moja. Wakati huu, daktari alisema: \"Tunawezaje kukamilisha sindano kwa wakati mmoja? Inahitaji kuwa na muda wa mwezi mmoja kati ya kila sindano mbili...\" Kwa hiyo Wang Wang aliamua kuokoa pesa wakati akijipiga sindano (kwa sababu Wang Wang ni paka anayependa sindano), Wang Wang Ikiwa naweza kuokoa yuan B kila mwezi, ni chanjo ngapi Wangwang anaweza kupata kwa wakati?\n * Mfano:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "tr": "/**\n * Zaman hızla geçti ve Wang Wang aşı için aylık yaşına ulaştı. Wang Wang hastaneye geldi ve kendine kuduz aşısı yaptırmak istedi, ama doktorun cazibesine karşı koyamadı. Toplamda 4 enjeksiyon olması gerekiyor. Önce üç doz Miao Sanduo aldı, ardından kuduz aşısı. Bir doz Miao Sanduo 120 yuan, bir doz kuduz aşısı 100 yuan tutuyor. Ancak, Wang Wang'ın sadece bir yuan parası var ve tüm enjeksiyonları bir kerede alamıyor. Bu sırada doktor dedi ki: \"Enjeksiyonu bir kerede nasıl tamamlayabiliriz? Her iki enjeksiyon arasında bir aylık bir aralık olmalı...\" Bu yüzden Wang Wang, kendine enjeksiyon yaparken para biriktirmeye karar verdi (çünkü Wang Wang enjeksiyonları seven bir meow), Wang Wang her ay B yuan biriktirebilirse, Wang Wang zamanında kaç aşı alabilir?\n * Örnek:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */ \n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "vi": "/**\n * Thời gian trôi qua nhanh chóng, và Wang Wang đã đến tuổi cần tiêm phòng theo tháng. Wang Wang đến bệnh viện và muốn tự tiêm một mũi vắc xin dại, nhưng anh không thể cưỡng lại sự cám dỗ của bác sĩ. Anh cần tổng cộng 4 mũi tiêm. Đầu tiên anh nhận ba mũi tiêm Miao Sanduo, sau đó là vắc xin dại. Một mũi tiêm Miao Sanduo có giá 120 nhân dân tệ, và một mũi vắc xin dại có giá 100 nhân dân tệ. Tuy nhiên, Wang Wang chỉ có một số tiền nhân dân tệ và không thể tiêm tất cả các mũi cùng một lúc. Lúc này, bác sĩ nói: \"Làm thế nào để hoàn thành việc tiêm một lần? Cần có khoảng cách một tháng giữa mỗi hai mũi tiêm...\" Vì vậy, Wang Wang quyết định tiết kiệm tiền trong khi tự tiêm (vì Wang Wang là một chú mèo yêu thích tiêm), Wang Wang Nếu tôi có thể tiết kiệm B nhân dân tệ mỗi tháng, Wangwang có thể tiêm được bao nhiêu mũi đúng hạn?\n * Ví dụ:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */ \n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int "
    },
    "prompt_bertscore": {
      "es": "0.9517697626593946",
      "arb": "0.9494322803353761",
      "sw": "0.9100673141611199",
      "tr": "0.9357603525783637",
      "vi": "0.9392224801198018"
    },
    "canonical_solution": "{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}",
    "instruction": {
      "en": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى بما لا يتجاوز 500 حرف.",
      "sw": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nKotlin kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8824183623818255",
      "sw": "0.8900509334034721",
      "tr": "0.8806870999807255",
      "vi": "0.9053631508470706"
    },
    "level": "",
    "test": "fun main(){\n    check(calculateMaxVaccinations(10, 200) == 0)\n    check(calculateMaxVaccinations(150, 100) == 2)\n    check(calculateMaxVaccinations(500, 100) == 4)\n    check(calculateMaxVaccinations(300, 50) == 3)\n    check(calculateMaxVaccinations(0, 200) == 0)\n    check(calculateMaxVaccinations(100, 20) == 0)\n    check(calculateMaxVaccinations(120, 100) == 1)\n    check(calculateMaxVaccinations(400, 0) == 3)\n\n}\nmain()",
    "entry_point": "calculateMaxVaccinations",
    "signature": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int",
    "docstring": {
      "en": "Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "es": "El tiempo pasó rápidamente, y Wang Wang había alcanzado la edad de meses para la vacunación. Wang Wang fue al hospital y quería darse una inyección de vacuna contra la rabia, pero no pudo resistir la tentación del médico. Necesita un total de 4 inyecciones. Primero recibió tres inyecciones de Miao Sanduo, y luego la vacuna contra la rabia. Una inyección de Miao Sanduo cuesta 120 yuanes, y una inyección de vacuna contra la rabia cuesta 100 yuanes. Sin embargo, Wang Wang solo tiene un yuan de dinero y no puede recibir todas las inyecciones de una vez. En este momento, el médico dijo: \"¿Cómo podemos completar la inyección de una vez? Debe haber un intervalo de un mes entre cada dos inyecciones...\" Así que Wang Wang decidió ahorrar dinero mientras se daba las inyecciones (porque Wang Wang es un meow que ama las inyecciones), Wang Wang Si puedo ahorrar B yuanes cada mes, ¿cuántas vacunas puede recibir Wang Wang a tiempo?\nEjemplo:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "arb": "مر الوقت بسرعة، ووصل وانغ وانغ إلى سن الأشهر للتطعيم. جاء وانغ وانغ إلى المستشفى وأراد أن يعطي نفسه حقنة من لقاح داء الكلب، لكنه لم يستطع مقاومة إغراء الطبيب. يحتاج إلى إجمالي 4 حقنات. تلقى أولاً ثلاث حقنات من مياو ساندو، ثم لقاح داء الكلب. تكلفة حقنة مياو ساندو 120 يوان، وتكلفة حقنة لقاح داء الكلب 100 يوان. ومع ذلك، فإن وانغ وانغ لديه فقط يوان من المال ولا يمكنه أخذ جميع الحقنات مرة واحدة. في هذا الوقت، قال الطبيب: \"كيف يمكننا إكمال الحقن في وقت واحد؟ يجب أن يكون هناك شهر فاصل بين كل حقنتين...\" لذلك قرر وانغ وانغ توفير المال أثناء إعطاء نفسه الحقن (لأن وانغ وانغ هو مياو يحب الحقن)، إذا كان بإمكان وانغ وانغ توفير B يوان كل شهر، كم عدد التطعيمات التي يمكن لوانغ وانغ الحصول عليها في الوقت المحدد؟\nمثال:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "sw": "Wakati ulipita haraka, na Wang Wang alikuwa amefikia umri wa miezi kwa ajili ya chanjo. Wang Wang alifika hospitalini na alitaka kujidunga sindano ya chanjo ya kichaa cha mbwa, lakini hakuweza kuzuia kishawishi cha daktari. Anahitaji jumla ya sindano 4. Kwanza alipokea sindano tatu za Miao Sanduo, na kisha chanjo ya kichaa cha mbwa. Sindano moja ya Miao Sanduo inagharimu yuan 120, na sindano moja ya chanjo ya kichaa cha mbwa inagharimu yuan 100. Hata hivyo, Wang Wang ana yuan moja tu ya pesa na hawezi kuchukua sindano zote mara moja. Wakati huu, daktari alisema: \"Tunawezaje kukamilisha sindano kwa wakati mmoja? Kunahitaji kuwe na mwezi mmoja wa muda kati ya kila sindano mbili...\" Kwa hiyo Wang Wang aliamua kuokoa pesa wakati akijidunga sindano (kwa sababu Wang Wang ni paka anayeipenda sindano), Wang Wang Ikiwa naweza kuokoa yuan B kila mwezi, ni chanjo ngapi Wang Wang anaweza kupata kwa wakati?\nMfano:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "tr": "Zaman hızla geçti ve Wang Wang aşı yaşı olan aylara ulaştı. Wang Wang hastaneye geldi ve kendisine kuduz aşısı yaptırmak istedi, ancak doktorun cazibesine karşı koyamadı. Toplamda 4 enjeksiyona ihtiyacı var. Önce üç doz Miao Sanduo aldı ve ardından kuduz aşısını. Bir doz Miao Sanduo 120 yuan, bir doz kuduz aşısı ise 100 yuan tutuyor. Ancak, Wang Wang'ın sadece bir miktar parası var ve tüm aşıları bir kerede yaptıramıyor. Bu sırada doktor şöyle dedi: \"Enjeksiyonu bir kerede nasıl tamamlayabiliriz? Her iki enjeksiyon arasında bir ay ara olması gerekiyor...\" Bu yüzden Wang Wang, kendine enjeksiyon yaparken para biriktirmeye karar verdi (çünkü Wang Wang enjeksiyonları seven bir meow), Wang Wang her ay B yuan biriktirebilirse, Wang Wang zamanında kaç aşı yaptırabilir?\nÖrnek:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "vi": "Thời gian trôi qua nhanh chóng, và Wang Wang đã đến tuổi cần tiêm phòng. Wang Wang đến bệnh viện và muốn tiêm một mũi vắc-xin phòng dại, nhưng anh không thể cưỡng lại sự cám dỗ của bác sĩ. Anh cần tổng cộng 4 mũi tiêm. Đầu tiên anh nhận ba mũi tiêm Miao Sanduo, sau đó là vắc-xin phòng dại. Một mũi tiêm Miao Sanduo có giá 120 nhân dân tệ, và một mũi vắc-xin phòng dại có giá 100 nhân dân tệ. Tuy nhiên, Wang Wang chỉ có một số tiền nhân dân tệ và không thể tiêm tất cả các mũi cùng một lúc. Lúc này, bác sĩ nói: \"Làm thế nào để hoàn thành việc tiêm phòng một lần? Cần có khoảng cách một tháng giữa mỗi hai mũi tiêm...\" Vì vậy, Wang Wang quyết định tiết kiệm tiền trong khi tự tiêm phòng (vì Wang Wang là một chú mèo yêu thích tiêm phòng), Wang Wang Nếu tôi có thể tiết kiệm B nhân dân tệ mỗi tháng, Wang Wang có thể tiêm bao nhiêu mũi đúng hạn?\nVí dụ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9549969104600685",
      "arb": "0.9482696967151789",
      "sw": "0.9483179638977703",
      "tr": "0.936399942405296",
      "vi": "0.9263832109200877"
    }
  },
  {
    "task_id": "Kotlin/20",
    "prompt": {
      "en": "\n/**\n * Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\n * on two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n * \n * Example:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "es": "/**\n * Realiza operaciones aritméticas básicas (suma, resta, multiplicación, división y módulo)\n * en dos enteros basados en un carácter de operación especificado. Cálculo ilegal devuelve \"invalid calcu\"\n * \n * Ejemplo:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "arb": "/**\n * تنفيذ العمليات الحسابية الأساسية (الجمع، الطرح، الضرب، القسمة، والباقي)\n * على عددين صحيحين بناءً على حرف العملية المحدد. الحساب غير القانوني يعيد \"invalid calcu\"\n * \n * مثال:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "sw": "/**\n * Fanya shughuli za kimsingi za hesabu (kujumlisha, kutoa, kuzidisha, kugawanya, na modulus)\n * kwenye namba mbili za mzima kulingana na herufi ya operesheni iliyoainishwa. Hesabu isiyo halali inarudisha \"invalid calcu\"\n * \n * Mfano:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "tr": "/**\n * İki tam sayı üzerinde belirtilen bir işlem karakterine göre temel aritmetik işlemleri (toplama, çıkarma, çarpma, bölme ve modül) gerçekleştirin. Geçersiz hesaplama \"invalid calcu\" döndürür.\n * \n * Örnek:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "vi": "/**\n * Thực hiện các phép toán số học cơ bản (cộng, trừ, nhân, chia, và chia lấy dư)\n * trên hai số nguyên dựa trên ký tự phép toán được chỉ định. Phép tính không hợp lệ trả về \"invalid calcu\"\n * \n * Ví dụ:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any "
    },
    "prompt_bertscore": {
      "es": "0.9946097673498563",
      "arb": "0.9889990549767638",
      "sw": "0.9892300621099074",
      "tr": "0.9778775413122394",
      "vi": "0.9876374437147696"
    },
    "canonical_solution": "{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}",
    "instruction": {
      "en": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.912915077934017",
      "tr": "0.8951376588313946",
      "vi": "0.9392832610163985"
    },
    "level": "",
    "test": "fun main(){\n    check(simpleCalculator(10, 5, '+') == 15)\n    check(simpleCalculator(10, 5, '-') == 5)\n    check(simpleCalculator(10, 5, '*') == 50)\n    check(simpleCalculator(10, 5, '/') == 2)\n    check(simpleCalculator(10, 5, '%') == 0)\n    check(simpleCalculator(15, 4, '/') == 3)\n    check(simpleCalculator(15, 4, '%') == 3)\n    check(simpleCalculator(15, 0, '/') == \"invalid calc\")\n    check(simpleCalculator(15, 0, '%') == \"invalid calc\")\n\n}\nmain()",
    "entry_point": "simpleCalculator",
    "signature": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any",
    "docstring": {
      "en": "Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "es": "Realizar operaciones aritméticas básicas (suma, resta, multiplicación, división y módulo) en dos enteros basados en un carácter de operación especificado. Cálculo ilegal devuelve \"calcu inválido\"\n\nEjemplo:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "arb": "إجراء العمليات الحسابية الأساسية (الجمع، الطرح، الضرب، القسمة، والباقي) على عددين صحيحين بناءً على حرف العملية المحدد. العملية غير القانونية تعيد \"invalid calcu\"\n\nمثال:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "sw": "Fanya shughuli za kimsingi za hesabu (kujumlisha, kutoa, kuzidisha, kugawanya, na modulus) kwenye nambari mbili nzima kulingana na alama maalum ya operesheni. Hesabu isiyo halali inarejesha \"invalid calcu\"\n\nMfano:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "tr": "Belirtilen bir işlem karakterine göre iki tam sayı üzerinde temel aritmetik işlemler (toplama, çıkarma, çarpma, bölme ve modül) gerçekleştirin. Geçersiz bir hesaplama \"invalid calcu\" döndürür.\n\nÖrnek:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "vi": "Thực hiện các phép toán số học cơ bản (cộng, trừ, nhân, chia, và chia lấy dư)\ntrên hai số nguyên dựa trên ký tự phép toán được chỉ định. Phép tính không hợp lệ trả về \"invalid calcu\"\n\nVí dụ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2"
    },
    "docstring_bertscore": {
      "es": "0.9891998702919901",
      "arb": "0.9791535428800074",
      "sw": "0.9872415733653671",
      "tr": "0.9815674979007244",
      "vi": "0.9831998423720691"
    }
  },
  {
    "task_id": "Kotlin/21",
    "prompt": {
      "en": "\n/**\n * Calculates the number of passengers on a bus at a specific station.\n * \n * The bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off, \n * so the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers \n * that got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the \n * previous station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n *\n * @param a The number of passengers boarding at the first station.\n * @param n The total number of stations.\n * @param m The number of passengers who get off at the last station.\n * @param x The station number for which the passenger count is required.\n * @return The number of passengers on the bus as it leaves station 'x'.\n *\n * Example:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "es": "/**\n * Calcula el número de pasajeros en un autobús en una estación específica.\n * \n * El autobús comienza en la primera estación con 'a' pasajeros. En la segunda estación, un número igual de pasajeros sube y baja, \n * por lo que el conteo permanece en 'a'. Desde la tercera estación en adelante, el número de pasajeros que suben es la suma de los pasajeros \n * que subieron en las dos últimas estaciones, y el número de pasajeros que bajan es el mismo que el número que subió en la \n * estación anterior. El proceso continúa hasta la penúltima estación. En la última estación, todos los pasajeros ('m') bajan.\n *\n * @param a El número de pasajeros que suben en la primera estación.\n * @param n El número total de estaciones.\n * @param m El número de pasajeros que bajan en la última estación.\n * @param x El número de estación para el cual se requiere el conteo de pasajeros.\n * @return El número de pasajeros en el autobús al salir de la estación 'x'.\n *\n * Ejemplo:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "arb": "/**\n * يحسب عدد الركاب في الحافلة عند محطة معينة.\n * \n * تبدأ الحافلة في المحطة الأولى مع 'a' من الركاب. في المحطة الثانية، يصعد وينزل نفس العدد من الركاب،\n * لذا يبقى العدد 'a'. من المحطة الثالثة فصاعدًا، يكون عدد الركاب الذين يصعدون هو مجموع الركاب\n * الذين صعدوا في المحطتين السابقتين، وعدد الركاب الذين ينزلون هو نفس عدد الذين صعدوا في\n * المحطة السابقة. تستمر العملية حتى المحطة قبل الأخيرة. في المحطة الأخيرة ينزل جميع الركاب ('m').\n *\n * @param a عدد الركاب الذين يصعدون في المحطة الأولى.\n * @param n العدد الإجمالي للمحطات.\n * @param m عدد الركاب الذين ينزلون في المحطة الأخيرة.\n * @param x رقم المحطة التي يُطلب عدد الركاب عندها.\n * @return عدد الركاب في الحافلة عند مغادرتها المحطة 'x'.\n *\n * مثال:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */ \n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "sw": "/**\n * Hukokotoa idadi ya abiria kwenye basi katika kituo maalum.\n * \n * Basi linaanza kwenye kituo cha kwanza na abiria 'a'. Katika kituo cha pili, idadi sawa ya abiria wanapanda na kushuka, \n * hivyo idadi inabaki 'a'. Kuanzia kituo cha tatu na kuendelea, idadi ya abiria wanaopanda ni jumla ya abiria \n * waliopanda katika vituo viwili vilivyopita, na idadi ya abiria wanaoshuka ni sawa na idadi ya waliopanda katika \n * kituo kilichopita. Mchakato unaendelea hadi kituo cha pili kutoka mwisho. Kituo cha mwisho kinaona abiria wote ('m') wakishuka.\n *\n * @param a Idadi ya abiria wanaopanda katika kituo cha kwanza.\n * @param n Jumla ya idadi ya vituo.\n * @param m Idadi ya abiria wanaoshuka katika kituo cha mwisho.\n * @param x Nambari ya kituo ambacho idadi ya abiria inahitajika.\n * @return Idadi ya abiria kwenye basi wanapoondoka kituo 'x'.\n *\n * Mfano:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */ \n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int",
      "tr": "/**\n * Belirli bir istasyonda otobüsteki yolcu sayısını hesaplar.\n * \n * Otobüs, ilk istasyonda 'a' yolcu ile başlar. İkinci istasyonda, eşit sayıda yolcu biner ve iner, \n * bu yüzden sayı 'a' olarak kalır. Üçüncü istasyondan itibaren, binen yolcu sayısı, \n * son iki istasyonda binen yolcuların toplamıdır ve inen yolcu sayısı, \n * bir önceki istasyonda binen yolcu sayısı ile aynıdır. Süreç, sondan bir önceki istasyona kadar devam eder. \n * Son istasyonda tüm yolcular ('m') iner.\n *\n * @param a İlk istasyonda binen yolcu sayısı.\n * @param n Toplam istasyon sayısı.\n * @param m Son istasyonda inen yolcu sayısı.\n * @param x Yolcu sayısının gerektiği istasyon numarası.\n * @return Otobüsün 'x' istasyonundan ayrılırken içindeki yolcu sayısı.\n *\n * Örnek:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "vi": "/**\n * Tính số lượng hành khách trên xe buýt tại một trạm cụ thể.\n * \n * Xe buýt bắt đầu tại trạm đầu tiên với 'a' hành khách. Tại trạm thứ hai, một số lượng hành khách bằng nhau lên và xuống, \n * vì vậy số lượng vẫn là 'a'. Từ trạm thứ ba trở đi, số lượng hành khách lên xe là tổng số hành khách \n * đã lên xe tại hai trạm trước đó, và số lượng hành khách xuống xe bằng với số lượng đã lên xe tại \n * trạm trước đó. Quá trình này tiếp tục cho đến trạm áp chót. Trạm cuối cùng tất cả hành khách ('m') xuống xe.\n *\n * @param a Số lượng hành khách lên xe tại trạm đầu tiên.\n * @param n Tổng số trạm.\n * @param m Số lượng hành khách xuống xe tại trạm cuối cùng.\n * @param x Số trạm mà số lượng hành khách cần được tính.\n * @return Số lượng hành khách trên xe buýt khi rời khỏi trạm 'x'.\n *\n * Ví dụ:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9807989969565004",
      "arb": "0.9292651391185228",
      "sw": "0.9401782895133417",
      "tr": "0.9317523887498418",
      "vi": "0.9394012474627332"
    },
    "canonical_solution": "{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}",
    "instruction": {
      "en": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8824183623818255",
      "sw": "0.9163911096021277",
      "tr": "0.9109663152656838",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(busStationPassengers(5, 7, 32, 5) == 21)\n    check(busStationPassengers(5, 7, 32, 4) == 13)\n    check(busStationPassengers(5, 7, 32, 3) == 10)\n    check(busStationPassengers(5, 7, 32, 2) == 5)\n    \n\n}\nmain()",
    "entry_point": "busStationPassengers",
    "signature": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int",
    "docstring": {
      "en": "Calculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "es": "Calcula el número de pasajeros en un autobús en una estación específica.\n\nEl autobús comienza en la primera estación con 'a' pasajeros. En la segunda estación, un número igual de pasajeros sube y baja, por lo que el conteo permanece en 'a'. A partir de la tercera estación, el número de pasajeros que suben es la suma de los pasajeros que subieron en las dos últimas estaciones, y el número de pasajeros que bajan es el mismo que el número que subió en la estación anterior. El proceso continúa hasta la penúltima estación. En la última estación, todos los pasajeros ('m') bajan.\n\n@param a El número de pasajeros que suben en la primera estación.\n@param n El número total de estaciones.\n@param m El número de pasajeros que bajan en la última estación.\n@param x El número de estación para la cual se requiere el conteo de pasajeros.\n@return El número de pasajeros en el autobús al salir de la estación 'x'.\n\nEjemplo:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "arb": "يحسب عدد الركاب في الحافلة عند محطة معينة.\n\nتبدأ الحافلة في المحطة الأولى مع 'a' ركاب. في المحطة الثانية، يصعد وينزل نفس العدد من الركاب، لذا يبقى العدد 'a'. من المحطة الثالثة فصاعدًا، يكون عدد الركاب الذين يصعدون هو مجموع الركاب الذين صعدوا في المحطتين الأخيرتين، وعدد الركاب الذين ينزلون هو نفس عدد الذين صعدوا في المحطة السابقة. تستمر العملية حتى المحطة قبل الأخيرة. في المحطة الأخيرة ينزل جميع الركاب ('m').\n\n@param a عدد الركاب الذين يصعدون في المحطة الأولى.\n@param n العدد الإجمالي للمحطات.\n@param m عدد الركاب الذين ينزلون في المحطة الأخيرة.\n@param x رقم المحطة التي يُطلب حساب عدد الركاب فيها.\n@return عدد الركاب في الحافلة عند مغادرتها المحطة 'x'.\n\nمثال:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "sw": "Hesabu idadi ya abiria kwenye basi katika kituo maalum.\n\nBasi linaanza katika kituo cha kwanza na abiria 'a'. Katika kituo cha pili, idadi sawa ya abiria wanapanda na kushuka,\nkwa hivyo idadi inabaki 'a'. Kuanzia kituo cha tatu na kuendelea, idadi ya abiria wanaopanda ni jumla ya abiria\nwaliopanda katika vituo viwili vilivyopita, na idadi ya abiria wanaoshuka ni sawa na idadi ya waliopanda katika\nkituo kilichopita. Mchakato unaendelea hadi kituo cha pili kutoka mwisho. Kituo cha mwisho kinaona abiria wote ('m') wakishuka.\n\n@param a Idadi ya abiria wanaopanda katika kituo cha kwanza.\n@param n Jumla ya idadi ya vituo.\n@param m Idadi ya abiria wanaoshuka katika kituo cha mwisho.\n@param x Namba ya kituo ambacho idadi ya abiria inahitajika.\n@return Idadi ya abiria kwenye basi linapoondoka kituo 'x'.\n\nMfano:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "tr": "Belirli bir istasyonda otobüsteki yolcu sayısını hesaplar.\n\nOtobüs, ilk istasyonda 'a' yolcu ile başlar. İkinci istasyonda, eşit sayıda yolcu biner ve iner, bu yüzden sayı 'a' olarak kalır. Üçüncü istasyondan itibaren, binen yolcu sayısı son iki istasyonda binen yolcuların toplamıdır ve inen yolcu sayısı, bir önceki istasyonda binen yolcu sayısı ile aynıdır. Bu süreç sondan bir önceki istasyona kadar devam eder. Son istasyonda tüm yolcular ('m') iner.\n\n@param a İlk istasyonda binen yolcu sayısı.\n@param n Toplam istasyon sayısı.\n@param m Son istasyonda inen yolcu sayısı.\n@param x Yolcu sayısının gerekli olduğu istasyon numarası.\n@return İstasyon 'x'ten ayrılırken otobüsteki yolcu sayısı.\n\nÖrnek:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "vi": "Tính toán số lượng hành khách trên xe buýt tại một trạm cụ thể.\n\nXe buýt bắt đầu tại trạm đầu tiên với 'a' hành khách. Tại trạm thứ hai, một số lượng hành khách bằng nhau lên và xuống xe, vì vậy số lượng vẫn là 'a'. Từ trạm thứ ba trở đi, số lượng hành khách lên xe là tổng số hành khách đã lên tại hai trạm trước đó, và số lượng hành khách xuống xe bằng với số lượng đã lên tại trạm trước đó. Quá trình này tiếp tục cho đến trạm áp chót. Trạm cuối cùng tất cả hành khách ('m') xuống xe.\n\n@param a Số lượng hành khách lên xe tại trạm đầu tiên.\n@param n Tổng số trạm.\n@param m Số lượng hành khách xuống xe tại trạm cuối cùng.\n@param x Số trạm mà số lượng hành khách cần được xác định.\n@return Số lượng hành khách trên xe buýt khi rời khỏi trạm 'x'.\n\nVí dụ:\n>>> busStationPassengers(5, 7, 32, 4)\n13"
    },
    "docstring_bertscore": {
      "es": "0.9781063635111915",
      "arb": "0.9402857485494815",
      "sw": "0.9138534078540259",
      "tr": "0.923077604118905",
      "vi": "0.9273741778910707"
    }
  },
  {
    "task_id": "Kotlin/22",
    "prompt": {
      "en": "\n/**\n    * Calculate the number of ways a person can mistakenly put letters in envelopes\n    * such that each letter ends up in the wrong envelope.\n    *\n    * This is based on a derangement problem where each item (letter) must not be\n    * in its original position (envelope).\n    *\n    * Parameters:\n    * n - the number of letters and envelopes.\n    *\n    * Returns:\n    * The total number of ways to wrongly place all the letters.\n    *\n    * Examples:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "es": "/**\n    * Calcular el número de formas en que una persona puede colocar incorrectamente cartas en sobres\n    * de tal manera que cada carta termine en el sobre equivocado.\n    *\n    * Esto se basa en un problema de desarreglo donde cada elemento (carta) no debe estar\n    * en su posición original (sobre).\n    *\n    * Parámetros:\n    * n - el número de cartas y sobres.\n    *\n    * Devuelve:\n    * El número total de formas de colocar incorrectamente todas las cartas.\n    *\n    * Ejemplos:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "arb": "/**\n    * حساب عدد الطرق التي يمكن أن يضع بها شخص الرسائل في المظاريف بشكل خاطئ\n    * بحيث ينتهي كل خطاب في الظرف الخطأ.\n    *\n    * هذا يعتمد على مشكلة التبديل حيث يجب ألا يكون كل عنصر (رسالة) في\n    * موقعه الأصلي (الظرف).\n    *\n    * المعاملات:\n    * n - عدد الرسائل والمظاريف.\n    *\n    * يعيد:\n    * إجمالي عدد الطرق لوضع جميع الرسائل بشكل خاطئ.\n    *\n    * أمثلة:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "sw": "/**\n    * Hesabu idadi ya njia ambazo mtu anaweza kuweka barua kwenye bahasha kimakosa\n    * kiasi kwamba kila barua inaishia kwenye bahasha isiyo sahihi.\n    *\n    * Hii inatokana na tatizo la derangement ambapo kila kipengee (barua) hakipaswi kuwa\n    * katika nafasi yake ya asili (bahasha).\n    *\n    * Vigezo:\n    * n - idadi ya barua na bahasha.\n    *\n    * Inarudisha:\n    * Jumla ya idadi ya njia za kuweka barua zote vibaya.\n    *\n    * Mifano:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "tr": "/**\n    * Bir kişinin mektupları zarflara yanlış yerleştirme yollarının sayısını hesapla\n    * öyle ki her mektup yanlış zarfa girsin.\n    *\n    * Bu, her öğenin (mektup) orijinal konumunda (zarf) olmaması gereken bir bozulum problemine dayanmaktadır.\n    *\n    * Parametreler:\n    * n - mektup ve zarf sayısı.\n    *\n    * Döndürür:\n    * Tüm mektupları yanlış yerleştirme yollarının toplam sayısı.\n    *\n    * Örnekler:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "vi": "/**\n    * Tính số cách một người có thể đặt nhầm thư vào phong bì\n    * sao cho mỗi thư đều nằm trong phong bì sai.\n    *\n    * Đây là một bài toán hoán vị sai chỗ, trong đó mỗi mục (thư) không được\n    * nằm ở vị trí ban đầu của nó (phong bì).\n    *\n    * Tham số:\n    * n - số lượng thư và phong bì.\n    *\n    * Trả về:\n    * Tổng số cách để đặt sai tất cả các thư.\n    *\n    * Ví dụ:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long "
    },
    "prompt_bertscore": {
      "es": "0.9692246060232165",
      "arb": "0.9799905713056885",
      "sw": "0.9870107648626045",
      "tr": "0.9643182369812737",
      "vi": "0.9602274442838602"
    },
    "canonical_solution": "{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}",
    "instruction": {
      "en": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8796681261260164",
      "sw": "0.9437925679266526",
      "tr": "0.9518293517737051",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(countWrongEnvelopeCombinations(2) == 1L)\n    check(countWrongEnvelopeCombinations(3) == 2L)\n    check(countWrongEnvelopeCombinations(4) == 9L) // Additional test case for 4 letters\n    check(countWrongEnvelopeCombinations(5) == 44L) // Additional test case for 5 letters\n    check(countWrongEnvelopeCombinations(15) == 481066515734L) // Additional test case for 15 letters\n}\nmain()",
    "entry_point": "countWrongEnvelopeCombinations",
    "signature": "fun countWrongEnvelopeCombinations(n: Int): Long",
    "docstring": {
      "en": "Calculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "es": "Calcular el número de formas en que una persona puede colocar erróneamente cartas en sobres de manera que cada carta termine en el sobre incorrecto.\n\nEsto se basa en un problema de desarreglo donde cada elemento (carta) no debe estar en su posición original (sobre).\n\nParámetros:\nn - el número de cartas y sobres.\n\nDevuelve:\nEl número total de formas de colocar incorrectamente todas las cartas.\n\nEjemplos:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "arb": "احسب عدد الطرق التي يمكن أن يضع فيها الشخص الرسائل في المظاريف بشكل خاطئ بحيث ينتهي كل خطاب في الظرف الخطأ.\n\nهذا يعتمد على مشكلة التبديل حيث يجب ألا يكون كل عنصر (رسالة) في موضعه الأصلي (الظرف).\n\nالمعلمات:\nn - عدد الرسائل والمظاريف.\n\nيعيد:\nإجمالي عدد الطرق لوضع جميع الرسائل بشكل خاطئ.\n\nأمثلة:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "sw": "Hesabu idadi ya njia ambazo mtu anaweza kuweka barua kwenye bahasha kimakosa\nhivyo kwamba kila barua inamalizika kwenye bahasha isiyo sahihi.\n\nHii inatokana na tatizo la mpangilio mbaya ambapo kila kipengee (barua) hakipaswi kuwa\nkatika nafasi yake ya asili (bahasha).\n\nVigezo:\nn - idadi ya barua na bahasha.\n\nInarejesha:\nJumla ya idadi ya njia za kuweka barua zote vibaya.\n\nMifano:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "tr": "Zarf içine mektupların yanlış yerleştirilme sayısını hesaplayın\nöyle ki her mektup yanlış zarfta olsun.\n\nBu, her öğenin (mektubun) kendi orijinal konumunda (zarfında) olmaması gereken bir yer değiştirme problemine dayanmaktadır.\n\nParametreler:\nn - mektup ve zarf sayısı.\n\nDöndürür:\nTüm mektupları yanlış yerleştirmenin toplam yolu.\n\nÖrnekler:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "vi": "Tính số cách một người có thể đặt nhầm thư vào phong bì sao cho mỗi thư đều nằm trong phong bì sai.\n\nĐiều này dựa trên một vấn đề hoán vị sai, nơi mỗi mục (thư) không được ở vị trí gốc của nó (phong bì).\n\nTham số:\nn - số lượng thư và phong bì.\n\nTrả về:\nTổng số cách để đặt sai tất cả các thư.\n\nVí dụ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2"
    },
    "docstring_bertscore": {
      "es": "0.9587633397452521",
      "arb": "0.9754534561420896",
      "sw": "0.9708519847350353",
      "tr": "0.937714875527747",
      "vi": "0.9664656300306419"
    }
  },
  {
    "task_id": "Kotlin/23",
    "prompt": {
      "en": "/**\n * Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\n * It is required that all three denominations are used in the exchange.\n * Example:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "es": "/**\n * Calcula el número de formas de cambiar una cantidad dada de dinero (más de 10 unidades) en denominaciones de 5, 2 y 1 unidad.\n * Se requiere que las tres denominaciones sean utilizadas en el intercambio.\n * Ejemplo:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "arb": "/**\n * يحسب عدد الطرق لتبادل مبلغ معين من المال (أكثر من 10 وحدات) إلى فئات 5 و 2 و 1 وحدة.\n * من المطلوب استخدام جميع الفئات الثلاث في التبادل.\n * مثال:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "sw": "/**\n * Inahesabu idadi ya njia za kubadilisha kiasi fulani cha pesa (zaidi ya vitengo 10) kuwa sarafu za vitengo 5, 2, na 1.\n * Inahitajika kwamba sarafu zote tatu zitumike katika kubadilisha.\n * Mfano:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */ \n\nfun countExchangeWays(amount: Int): Int ",
      "tr": "/**\n * Belirli bir miktar parayı (10 birimden fazla) 5, 2 ve 1 birimlik para birimlerine çevirmenin yollarını hesaplar.\n * Değişimde tüm üç para biriminin kullanılması gerekmektedir.\n * Örnek:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "vi": "/**\n * Tính toán số cách để đổi một số tiền nhất định (hơn 10 đơn vị) thành các mệnh giá 5, 2 và 1 đơn vị.\n * Yêu cầu rằng tất cả ba mệnh giá đều được sử dụng trong việc đổi tiền.\n * Ví dụ:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9836086236962389",
      "arb": "0.9771581020721309",
      "sw": "0.9612178153637001",
      "tr": "0.9407372354055739",
      "vi": "0.9803737293107048"
    },
    "canonical_solution": "{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}",
    "instruction": {
      "en": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8984770327973531",
      "sw": "0.918038549982431",
      "tr": "0.9349461666465017",
      "vi": "0.909549484757762"
    },
    "level": "",
    "test": "fun main(){\n\n    check(countExchangeWays(50) == 106)\n    check(countExchangeWays(20) == 13)\n    check(countExchangeWays(15) == 6)\n    check(countExchangeWays(12) == 3)\n\n}\n\nmain()",
    "entry_point": "countExchangeWays",
    "signature": "fun countExchangeWays(amount: Int): Int",
    "docstring": {
      "en": "Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "es": "Calcula el número de formas de intercambiar una cantidad dada de dinero (más de 10 unidades) en denominaciones de 5, 2 y 1 unidad.  \nSe requiere que las tres denominaciones se utilicen en el intercambio.  \nEjemplo:  \n>>> countExchangeWays(50)  \n106  \n>>> countExchangeWays(20)  \n13",
      "arb": "يحسب عدد الطرق لتبادل مبلغ معين من المال (أكثر من 10 وحدات) إلى فئات 5 و 2 و 1 وحدة.\nمن المطلوب استخدام جميع الفئات الثلاث في التبادل.\nمثال:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "sw": "Hesabu idadi ya njia za kubadilisha kiasi fulani cha pesa (zaidi ya vitengo 10) kuwa katika madhehebu ya vitengo 5, 2, na 1. Inahitajika kwamba madhehebu yote matatu yatumiwe katika kubadilisha.\n\nMfano:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "tr": "Verilen miktarda parayı (10 birimden fazla) 5, 2 ve 1 birimlik para birimlerine çevirmenin yollarını hesaplar.\nTakas sırasında tüm üç para biriminin kullanılması gerekmektedir.\nÖrnek:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "vi": "Tính toán số cách để đổi một số tiền nhất định (nhiều hơn 10 đơn vị) thành các mệnh giá 5, 2 và 1 đơn vị. Yêu cầu là tất cả ba mệnh giá phải được sử dụng trong việc đổi tiền.\nVí dụ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13"
    },
    "docstring_bertscore": {
      "es": "0.9765181149844365",
      "arb": "0.9683998926811597",
      "sw": "0.9627661391838671",
      "tr": "0.9390113360247617",
      "vi": "0.9610992330262224"
    }
  },
  {
    "task_id": "Kotlin/24",
    "prompt": {
      "en": "/**\n    * Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\n    * Hours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n    * \n    * Example:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "es": "/**\n    * Suma dos tiempos juntos. Cada tiempo se representa como un Triple de horas, minutos y segundos.\n    * Las horas, minutos y segundos se normalizan para asegurar que los minutos y segundos estén dentro de 0 a 59.\n    * \n    * Ejemplo:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "arb": "/**\n    * يضيف وقتين معًا. يتم تمثيل كل وقت كثلاثية من الساعات والدقائق والثواني.\n    * يتم تطبيع الساعات والدقائق والثواني لضمان أن تكون الدقائق والثواني ضمن 0 إلى 59.\n    * \n    * مثال:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "sw": "/**\n    * Huongeza nyakati mbili pamoja. Kila wakati unawakilishwa kama Triple ya saa, dakika, na sekunde.\n    * Saa, dakika, na sekunde zimewekwa kawaida ili kuhakikisha dakika na sekunde ziko kati ya 0 hadi 59.\n    * \n    * Mfano:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "tr": "/**\n    * İki zamanı toplar. Her zaman, saat, dakika ve saniye üçlüsü olarak temsil edilir.\n    * Saatler, dakikalar ve saniyeler, dakikaların ve saniyelerin 0 ile 59 arasında olmasını sağlamak için normalize edilir.\n    * \n    * Örnek:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "vi": "/**\n    * Cộng hai thời gian lại với nhau. Mỗi thời gian được biểu diễn dưới dạng một Triple của giờ, phút và giây.\n    * Giờ, phút và giây được chuẩn hóa để đảm bảo phút và giây nằm trong khoảng từ 0 đến 59.\n    * \n    * Ví dụ:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.9963704270473495",
      "arb": "0.988830020522503",
      "sw": "0.9960023649512918",
      "tr": "0.9828989173448013",
      "vi": "0.9831120477436517"
    },
    "canonical_solution": "{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}",
    "instruction": {
      "en": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.918038549982431",
      "tr": "0.9349461666465017",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main(){\n\n\ncheck(addTimes(Triple(1, 2, 3), Triple(4, 5, 6)) == Triple(5, 7, 9))\ncheck(addTimes(Triple(23, 59, 59), Triple(0, 0, 1)) == Triple(24, 0, 0))\ncheck(addTimes(Triple(10, 30, 30), Triple(2, 35, 40)) == Triple(13, 6, 10))\ncheck(addTimes(Triple(0, 0, 0), Triple(0, 0, 0)) == Triple(0, 0, 0))\n\n}\n\nmain()",
    "entry_point": "addTimes",
    "signature": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "es": "Suma dos tiempos juntos. Cada tiempo se representa como un Triple de horas, minutos y segundos. Las horas, minutos y segundos se normalizan para asegurar que los minutos y segundos estén dentro de 0 a 59.\n\nEjemplo:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "arb": "يجمع وقتين معًا. يتم تمثيل كل وقت كثلاثية من الساعات والدقائق والثواني. يتم تطبيع الساعات والدقائق والثواني لضمان أن تكون الدقائق والثواني ضمن 0 إلى 59.\n\nمثال:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "sw": "Huongeza nyakati mbili pamoja. Kila wakati unawakilishwa kama Triple ya saa, dakika, na sekunde. Saa, dakika, na sekunde zimenormalishwa ili kuhakikisha dakika na sekunde ziko kati ya 0 hadi 59.\n\nMfano:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "tr": "İki zamanı toplar. Her zaman, saat, dakika ve saniyeden oluşan bir Üçlü olarak temsil edilir. Dakika ve saniyelerin 0 ile 59 arasında olması sağlanarak saat, dakika ve saniyeler normalize edilir.\n\nÖrnek:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "vi": "Cộng hai khoảng thời gian lại với nhau. Mỗi khoảng thời gian được biểu diễn dưới dạng một Triple của giờ, phút và giây. Giờ, phút và giây được chuẩn hóa để đảm bảo phút và giây nằm trong khoảng từ 0 đến 59.\n\nVí dụ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9796020502803843",
      "arb": "0.9859472978025438",
      "sw": "0.9942985135427745",
      "tr": "0.9723897811450074",
      "vi": "0.960260615557493"
    }
  },
  {
    "task_id": "Kotlin/25",
    "prompt": {
      "en": "/**\n    * Finds the mode (most frequent element) and its count in a given list of integers.\n    * If there are multiple modes, the smallest one is returned.\n    *\n    * Example:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 is the mode and it appears 3 times\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Both 1 and 3 are modes but 1 is smaller\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "es": "/**\n    * Encuentra la moda (elemento más frecuente) y su cuenta en una lista dada de enteros.\n    * Si hay múltiples modas, se devuelve la más pequeña.\n    *\n    * Ejemplo:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 es la moda y aparece 3 veces\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Tanto 1 como 3 son modas pero 1 es más pequeño\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "arb": "/**\n    * يجد النمط (العنصر الأكثر تكرارًا) وعدد مرات ظهوره في قائمة معينة من الأعداد الصحيحة.\n    * إذا كان هناك عدة أنماط، يتم إرجاع الأصغر منها.\n    *\n    * مثال:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 هو النمط ويظهر 3 مرات\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // كل من 1 و 3 هما الأنماط ولكن 1 أصغر\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "sw": "/**\n    * Inapata modi (kipengele kinachojitokeza mara nyingi zaidi) na idadi yake katika orodha iliyotolewa ya nambari za mzima.\n    * Ikiwa kuna modi nyingi, ndogo zaidi inarejeshwa.\n    *\n    * Mfano:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 ni modi na inajitokeza mara 3\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Zote 1 na 3 ni modi lakini 1 ni ndogo zaidi\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "tr": "/**\n    * Verilen bir tamsayı listesindeki modu (en sık görülen eleman) ve sayısını bulur.\n    * Birden fazla mod varsa, en küçük olanı döndürülür.\n    *\n    * Örnek:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 moddur ve 3 kez görünür\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Hem 1 hem de 3 moddur ama 1 daha küçüktür\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "vi": "/**\n    * Tìm mode (phần tử xuất hiện nhiều nhất) và số lần xuất hiện của nó trong một danh sách số nguyên cho trước.\n    * Nếu có nhiều mode, phần tử nhỏ nhất sẽ được trả về.\n    *\n    * Ví dụ:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 là mode và nó xuất hiện 3 lần\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Cả 1 và 3 đều là mode nhưng 1 nhỏ hơn\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.9909944957846403",
      "arb": "0.9745556468198119",
      "sw": "0.9759621485479198",
      "tr": "0.9941958216357796",
      "vi": "0.9755728330010915"
    },
    "canonical_solution": "{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}",
    "instruction": {
      "en": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9255475729070739",
      "sw": "0.918038549982431",
      "tr": "0.8945846718505934",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(findModeAndCount(listOf(1, 2, 2, 2, 3, 5)) == Pair(2, 3))\n    check(findModeAndCount(listOf(1, 1, 2, 3, 3)) == Pair(1, 2))\n    check(findModeAndCount(listOf(4, 4, 4, 5, 5, 6, 6, 6)) == Pair(4, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9)) == Pair(9, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9, 1, 1, 1, 1, 1)) == Pair(1, 5))\n}\n\nmain()",
    "entry_point": "findModeAndCount",
    "signature": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller",
      "es": "Encuentra la moda (elemento más frecuente) y su conteo en una lista dada de enteros. Si hay múltiples modas, se devuelve la más pequeña.\n\nEjemplo:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 es la moda y aparece 3 veces\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Tanto 1 como 3 son modas pero 1 es más pequeño",
      "arb": "يجد النمط (العنصر الأكثر تكرارًا) وعدد مرات ظهوره في قائمة معينة من الأعداد الصحيحة. إذا كان هناك عدة أنماط، يتم إرجاع الأصغر منها.\n\nمثال:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 هو النمط ويظهر 3 مرات\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // كل من 1 و 3 هما الأنماط ولكن 1 هو الأصغر",
      "sw": "Inapata modi (kipengele kinachojitokeza mara nyingi zaidi) na idadi yake katika orodha iliyotolewa ya nambari za mzima. Ikiwa kuna modi nyingi, ile ndogo zaidi inarejeshwa.\n\nMfano:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 ni modi na inajitokeza mara 3\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Zote 1 na 3 ni modi lakini 1 ni ndogo zaidi",
      "tr": "Verilen bir tamsayı listesindeki modu (en sık görülen eleman) ve sayısını bulur. Birden fazla mod varsa, en küçüğü döndürülür.\n\nÖrnek:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 moddur ve 3 kez görünür\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Hem 1 hem de 3 moddur ama 1 daha küçüktür",
      "vi": "Tìm mode (phần tử xuất hiện nhiều nhất) và số lần xuất hiện của nó trong một danh sách số nguyên đã cho. Nếu có nhiều mode, phần tử nhỏ nhất sẽ được trả về.\n\nVí dụ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 là mode và nó xuất hiện 3 lần\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Cả 1 và 3 đều là mode nhưng 1 nhỏ hơn"
    },
    "docstring_bertscore": {
      "es": "0.9899826726236485",
      "arb": "0.9570849130255072",
      "sw": "0.9716310130894542",
      "tr": "0.9927716418037594",
      "vi": "0.9700084015067801"
    }
  },
  {
    "task_id": "Kotlin/26",
    "prompt": {
      "en": "/**\n * Processes a given 2D array representing an image, applying a series of operations.\n * Each operation is represented by a character:\n * 'A' - Rotate the image 90 degrees clockwise.\n * 'B' - Rotate the image 90 degrees counterclockwise.\n * 'C' - Flip the image horizontally.\n * 'D' - Flip the image vertically.\n *\n * @param image A 2D array of integers representing the image's pixel grayscale values.\n * @param operations A string of characters representing the operations to be applied in sequence.\n * @return A 2D array of integers representing the processed image.\n *\n * Example:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "es": "/**\n * Procesa una matriz 2D dada que representa una imagen, aplicando una serie de operaciones.\n * Cada operación está representada por un carácter:\n * 'A' - Rota la imagen 90 grados en el sentido de las agujas del reloj.\n * 'B' - Rota la imagen 90 grados en sentido contrario a las agujas del reloj.\n * 'C' - Voltea la imagen horizontalmente.\n * 'D' - Voltea la imagen verticalmente.\n *\n * @param image Una matriz 2D de enteros que representa los valores de escala de grises de los píxeles de la imagen.\n * @param operations Una cadena de caracteres que representa las operaciones a aplicar en secuencia.\n * @return Una matriz 2D de enteros que representa la imagen procesada.\n *\n * Ejemplo:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "arb": "/**\n * يعالج مصفوفة ثنائية الأبعاد تمثل صورة، بتطبيق سلسلة من العمليات.\n * كل عملية تمثل بحرف:\n * 'A' - تدوير الصورة 90 درجة في اتجاه عقارب الساعة.\n * 'B' - تدوير الصورة 90 درجة عكس اتجاه عقارب الساعة.\n * 'C' - قلب الصورة أفقيًا.\n * 'D' - قلب الصورة عموديًا.\n *\n * @param image مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل قيم تدرج الرمادي لبكسلات الصورة.\n * @param operations سلسلة من الأحرف تمثل العمليات التي سيتم تطبيقها بالتسلسل.\n * @return مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل الصورة المعالجة.\n *\n * مثال:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "sw": "/**\n * Inachakata safu mbili za mwelekeo zinazowakilisha picha, ikitumia mfululizo wa operesheni.\n * Kila operesheni inawakilishwa na herufi:\n * 'A' - Geuza picha kwa nyuzi 90 kwa saa.\n * 'B' - Geuza picha kwa nyuzi 90 kinyume na saa.\n * 'C' - Pindua picha kwa usawa.\n * 'D' - Pindua picha kwa wima.\n *\n * @param image Safu mbili za nambari za mzima zinazowakilisha thamani za kijivu za pikseli za picha.\n * @param operations Mfuatano wa herufi zinazowakilisha operesheni zitakazotumika kwa mpangilio.\n * @return Safu mbili za nambari za mzima zinazowakilisha picha iliyochakatwa.\n *\n * Mfano:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "tr": "/**\n * Bir görüntüyü temsil eden verilen 2D diziyi işler, bir dizi işlem uygular.\n * Her işlem bir karakterle temsil edilir:\n * 'A' - Görüntüyü saat yönünde 90 derece döndür.\n * 'B' - Görüntüyü saat yönünün tersine 90 derece döndür.\n * 'C' - Görüntüyü yatay olarak çevir.\n * 'D' - Görüntüyü dikey olarak çevir.\n *\n * @param image Görüntünün piksel gri tonlama değerlerini temsil eden bir 2D tamsayı dizisi.\n * @param operations Sırasıyla uygulanacak işlemleri temsil eden bir karakter dizisi.\n * @return İşlenmiş görüntüyü temsil eden bir 2D tamsayı dizisi.\n *\n * Örnek:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "vi": "/**\n * Xử lý một mảng 2D đại diện cho một hình ảnh, áp dụng một loạt các thao tác.\n * Mỗi thao tác được đại diện bởi một ký tự:\n * 'A' - Xoay hình ảnh 90 độ theo chiều kim đồng hồ.\n * 'B' - Xoay hình ảnh 90 độ ngược chiều kim đồng hồ.\n * 'C' - Lật hình ảnh theo chiều ngang.\n * 'D' - Lật hình ảnh theo chiều dọc.\n *\n * @param image Một mảng 2D các số nguyên đại diện cho giá trị thang độ xám của pixel hình ảnh.\n * @param operations Một chuỗi ký tự đại diện cho các thao tác sẽ được áp dụng theo thứ tự.\n * @return Một mảng 2D các số nguyên đại diện cho hình ảnh đã được xử lý.\n *\n * Ví dụ:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> "
    },
    "prompt_bertscore": {
      "es": "0.9840622954865227",
      "arb": "0.9751245242310957",
      "sw": "0.9617040625364736",
      "tr": "0.9883280815496279",
      "vi": "0.9866842165161832"
    },
    "canonical_solution": "{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}",
    "instruction": {
      "en": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nKotlin kodunun Türkçe açıklamasını (docstring) en fazla 500 karakter kullanarak sağlayın.",
      "vi": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8900610635529049",
      "sw": "0.9437925679266526",
      "tr": "0.8722921855566669",
      "vi": "0.9249709489109296"
    },
    "level": "",
    "test": "fun main() {\n    val image1 = arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10))\n    val result1 = processImage(image1, \"AC\")\n    check(result1.contentDeepEquals(arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))))\n\n    val image2 = arrayOf(arrayOf(1, 2), arrayOf(3, 4))\n    val result2 = processImage(image2, \"A\")\n    check(result2.contentDeepEquals(arrayOf(arrayOf(3, 1), arrayOf(4, 2))))\n\n    val result3 = processImage(image2, \"B\")\n    check(result3.contentDeepEquals(arrayOf(arrayOf(2, 4), arrayOf(1, 3))))\n\n    val result4 = processImage(image2, \"BD\")\n    check(result4.contentDeepEquals(arrayOf(arrayOf(1, 3), arrayOf(2, 4))))\n\n}\n\nmain()",
    "entry_point": "processImage",
    "signature": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>",
    "docstring": {
      "en": "Processes a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "es": "Procesa una matriz 2D dada que representa una imagen, aplicando una serie de operaciones.  \nCada operación está representada por un carácter:  \n'A' - Rota la imagen 90 grados en el sentido de las agujas del reloj.  \n'B' - Rota la imagen 90 grados en sentido contrario a las agujas del reloj.  \n'C' - Voltea la imagen horizontalmente.  \n'D' - Voltea la imagen verticalmente.  \n\n@param image Una matriz 2D de enteros que representa los valores de escala de grises de los píxeles de la imagen.  \n@param operations Una cadena de caracteres que representa las operaciones a aplicar en secuencia.  \n@return Una matriz 2D de enteros que representa la imagen procesada.  \n\nEjemplo:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "arb": "يعالج مصفوفة ثنائية الأبعاد تمثل صورة، ويطبق سلسلة من العمليات.\nكل عملية تمثل بواسطة حرف:\n'A' - تدوير الصورة 90 درجة في اتجاه عقارب الساعة.\n'B' - تدوير الصورة 90 درجة عكس اتجاه عقارب الساعة.\n'C' - قلب الصورة أفقيًا.\n'D' - قلب الصورة عموديًا.\n\n@param image مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل قيم تدرج الرمادي لبكسلات الصورة.\n@param operations سلسلة من الأحرف تمثل العمليات التي سيتم تطبيقها بالتسلسل.\n@return مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل الصورة المعالجة.\n\nمثال:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "sw": "Inachakata safu mbili za vipimo zinazowakilisha picha, ikitumia mfululizo wa operesheni. \nKila operesheni inawakilishwa na herufi: \n'A' - Geuza picha kwa nyuzi 90 kwa mwelekeo wa saa. \n'B' - Geuza picha kwa nyuzi 90 kinyume na mwelekeo wa saa. \n'C' - Geuza picha upande wa usawa. \n'D' - Geuza picha wima.\n\n@param image Safu mbili za vipimo za namba zinazoonyesha thamani za kijivu za pikseli za picha. \n@param operations Mfuatano wa herufi zinazoonyesha operesheni zitakazotumika kwa mpangilio. \n@return Safu mbili za vipimo za namba zinazoonyesha picha iliyochakatwa.\n\nMfano:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "tr": "Verilen bir görüntüyü temsil eden 2D diziyi işleyerek bir dizi işlem uygular.\nHer işlem bir karakter ile temsil edilir:\n'A' - Görüntüyü saat yönünde 90 derece döndür.\n'B' - Görüntüyü saat yönünün tersine 90 derece döndür.\n'C' - Görüntüyü yatay olarak çevir.\n'D' - Görüntüyü dikey olarak çevir.\n\n@param image Görüntünün piksel gri tonlamalı değerlerini temsil eden bir tamsayı 2D dizisi.\n@param operations Sırasıyla uygulanacak işlemleri temsil eden bir karakter dizisi.\n@return İşlenmiş görüntüyü temsil eden bir tamsayı 2D dizisi.\n\nÖrnek:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "vi": "Xử lý một mảng 2D cho trước đại diện cho một hình ảnh, áp dụng một loạt các thao tác.  \nMỗi thao tác được đại diện bởi một ký tự:  \n'A' - Xoay hình ảnh 90 độ theo chiều kim đồng hồ.  \n'B' - Xoay hình ảnh 90 độ ngược chiều kim đồng hồ.  \n'C' - Lật hình ảnh theo chiều ngang.  \n'D' - Lật hình ảnh theo chiều dọc.  \n\n@param image Một mảng 2D của các số nguyên đại diện cho giá trị thang độ xám của điểm ảnh của hình ảnh.  \n@param operations Một chuỗi ký tự đại diện cho các thao tác sẽ được áp dụng theo thứ tự.  \n@return Một mảng 2D của các số nguyên đại diện cho hình ảnh đã được xử lý.  \n\nVí dụ:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  "
    },
    "docstring_bertscore": {
      "es": "0.981058408234132",
      "arb": "0.9679110633134328",
      "sw": "0.9461387899874366",
      "tr": "0.9855369274353256",
      "vi": "0.986631579465209"
    }
  },
  {
    "task_id": "Kotlin/27",
    "prompt": {
      "en": "/**\n    * Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\n    * A prime pair is defined as two prime numbers where the difference between them is exactly 2.\n    * Example:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "es": "/**\n    * Encuentra todos los pares de primos donde cada primo es menor o igual a un número dado y el par difiere en 2.\n    * Un par de primos se define como dos números primos donde la diferencia entre ellos es exactamente 2.\n    * Ejemplo:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "arb": "/**\n    * يجد جميع الأزواج الأولية حيث يكون كل عدد أولي أقل من أو يساوي رقمًا معينًا ويختلف الزوج بمقدار 2.\n    * يُعرّف الزوج الأولي على أنه عددان أوليان حيث يكون الفرق بينهما بالضبط 2.\n    * مثال:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/ \n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "sw": "/**\n    * Inapata jozi zote za nambari kuu ambapo kila nambari kuu ni ndogo au sawa na nambari iliyotolewa na jozi inatofautiana kwa 2.\n    * Jozi ya nambari kuu inafafanuliwa kama nambari mbili kuu ambapo tofauti kati yao ni haswa 2.\n    * Mfano:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/ \n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "tr": "/**\n    * Her asal sayı, verilen bir sayıdan küçük veya eşit olduğunda ve çiftler arasındaki fark 2 olduğunda tüm asal çiftleri bulur.\n    * Bir asal çifti, aralarındaki fark tam olarak 2 olan iki asal sayı olarak tanımlanır.\n    * Örnek:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "vi": "/**\n    * Tìm tất cả các cặp số nguyên tố mà mỗi số nguyên tố nhỏ hơn hoặc bằng một số cho trước và cặp số khác nhau 2 đơn vị.\n    * Một cặp số nguyên tố được định nghĩa là hai số nguyên tố mà hiệu giữa chúng chính xác là 2.\n    * Ví dụ:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/ \n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> "
    },
    "prompt_bertscore": {
      "es": "0.973497940040801",
      "arb": "0.9920098942924905",
      "sw": "0.9770909650033411",
      "tr": "0.9786494189729409",
      "vi": "0.9805717638005965"
    },
    "canonical_solution": "{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}",
    "instruction": {
      "en": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9135230855303649",
      "sw": "0.918038549982431",
      "tr": "0.9349461666465017",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main(){\n    check(findPrimePairs(10) == listOf(Pair(3, 5), Pair(5, 7)))\n    check(findPrimePairs(100) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13), Pair(17, 19), Pair(29, 31), Pair(41, 43), Pair(59, 61), Pair(71, 73)))\n    check(findPrimePairs(15) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13)))\n    check(findPrimePairs(1) == emptyList<Pair<Int, Int>>())\n}\n\n\nmain()",
    "entry_point": "findPrimePairs",
    "signature": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>",
    "docstring": {
      "en": "Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "es": "Encuentra todos los pares de primos donde cada primo es menor o igual a un número dado y el par difiere en 2.  \nUn par de primos se define como dos números primos donde la diferencia entre ellos es exactamente 2.  \nEjemplo:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]  ",
      "arb": "يعثر على جميع أزواج الأعداد الأولية حيث يكون كل عدد أولي أقل من أو يساوي عددًا معينًا ويختلف الزوج بمقدار 2.  \nيُعرّف زوج الأعداد الأولية على أنه عددان أوليان حيث يكون الفرق بينهما بالضبط 2.  \nمثال:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "sw": "Inapata jozi zote za nambari za kwanza ambapo kila nambari ya kwanza ni ndogo au sawa na nambari iliyotolewa na jozi hiyo inatofautiana kwa 2. \nJozi ya nambari za kwanza inafafanuliwa kama nambari mbili za kwanza ambapo tofauti kati yao ni haswa 2. \nMfano:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "tr": "Verilen bir sayıdan küçük veya eşit olan tüm asal çiftleri bulur ve çiftler 2 farkla ayrılır.  \nBir asal çifti, aralarındaki fark tam olarak 2 olan iki asal sayı olarak tanımlanır.  \nÖrnek:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]  ",
      "vi": "Tìm tất cả các cặp số nguyên tố mà mỗi số nguyên tố nhỏ hơn hoặc bằng một số cho trước và cặp số đó chênh lệch nhau 2 đơn vị.  \nMột cặp số nguyên tố được định nghĩa là hai số nguyên tố mà sự chênh lệch giữa chúng là chính xác 2 đơn vị.  \nVí dụ:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]  "
    },
    "docstring_bertscore": {
      "es": "0.9692540033196096",
      "arb": "0.9682928309057819",
      "sw": "0.9646084359679656",
      "tr": "0.9437580062403524",
      "vi": "0.9543348754000792"
    }
  },
  {
    "task_id": "Kotlin/28",
    "prompt": {
      "en": "/**\n * Converts a number from one base to another.\n * The function takes an input number as a string (which can include digits and letters),\n * the base of this number, and the target base for conversion. The bases can range from 2 to 16.\n * The output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n *\n * Examples:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "es": "/**\n * Convierte un número de una base a otra.\n * La función toma un número de entrada como una cadena (que puede incluir dígitos y letras),\n * la base de este número y la base objetivo para la conversión. Las bases pueden variar de 2 a 16.\n * La salida es el número convertido como una cadena en la base objetivo, usando letras mayúsculas para bases superiores a 10.\n *\n * Ejemplos:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */ \n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "arb": "/**\n * يحول رقمًا من قاعدة إلى أخرى.\n * تأخذ الدالة رقم الإدخال كسلسلة (يمكن أن تتضمن أرقامًا وحروفًا)،\n * قاعدة هذا الرقم، والقاعدة المستهدفة للتحويل. يمكن أن تتراوح القواعد من 2 إلى 16.\n * الناتج هو الرقم المحول كسلسلة في القاعدة المستهدفة، باستخدام حروف كبيرة للقواعد فوق 10.\n *\n * أمثلة:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "sw": "/**\n * Hubadilisha nambari kutoka msingi mmoja hadi mwingine.\n * Kazi inachukua nambari ya ingizo kama kamba (ambayo inaweza kujumuisha tarakimu na herufi),\n * msingi wa nambari hii, na msingi lengwa kwa ubadilishaji. Misingi inaweza kuwa kati ya 2 hadi 16.\n * Matokeo ni nambari iliyobadilishwa kama kamba katika msingi lengwa, ikitumia herufi kubwa kwa misingi zaidi ya 10.\n *\n * Mifano:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "tr": "/**\n * Bir sayıyı bir tabandan diğerine dönüştürür.\n * Fonksiyon, bir giriş sayısını string olarak alır (rakamlar ve harfler içerebilir),\n * bu sayının tabanı ve dönüştürme için hedef tabanı alır. Tabanlar 2 ile 16 arasında olabilir.\n * Çıktı, hedef tabanda büyük harfler kullanılarak dönüştürülmüş sayının string olarak gösterimidir.\n *\n * Örnekler:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */ \n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "vi": "/**\n * Chuyển đổi một số từ một cơ số sang cơ số khác.\n * Hàm nhận một số đầu vào dưới dạng chuỗi (có thể bao gồm chữ số và chữ cái),\n * cơ số của số này, và cơ số đích để chuyển đổi. Các cơ số có thể từ 2 đến 16.\n * Đầu ra là số đã được chuyển đổi dưới dạng chuỗi trong cơ số đích, sử dụng chữ cái in hoa cho các cơ số lớn hơn 10.\n *\n * Ví dụ:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */"
    },
    "prompt_bertscore": {
      "es": "0.9926218744964591",
      "arb": "0.9926747101778144",
      "sw": "0.9499433563057789",
      "tr": "0.9605474378277074",
      "vi": "0.9541424025608564"
    },
    "canonical_solution": "{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}",
    "instruction": {
      "en": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nKotlin kodunun Türkçe açıklamasını (docstring) en fazla 500 karakter kullanarak sağlayın.",
      "vi": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9163905137109846",
      "sw": "0.9437925679266526",
      "tr": "0.8722921855566669",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(convertBase(\"Aab3\", 15, 7) == \"210306\")\n    check(convertBase(\"101\", 2, 10) == \"5\")\n    check(convertBase(\"FF\", 16, 2) == \"11111111\")\n    check(convertBase(\"123\", 10, 16) == \"7B\")\n}\n\nmain()",
    "entry_point": "convertBase",
    "signature": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String",
    "docstring": {
      "en": "Converts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "es": "Convierte un número de una base a otra.  \nLa función toma un número de entrada como una cadena (que puede incluir dígitos y letras),  \nla base de este número y la base objetivo para la conversión. Las bases pueden variar de 2 a 16.  \nLa salida es el número convertido como una cadena en la base objetivo, usando letras mayúsculas para bases superiores a 10.  \n\nEjemplos:  \n>>> convertBase(\"Aab3\", 15, 7)  \n\"210306\"  \n>>> convertBase(\"101\", 2, 10)  \n\"5\"  \n>>> convertBase(\"FF\", 16, 2)  \n\"11111111\"  ",
      "arb": "تحويل رقم من قاعدة إلى أخرى.  \nتأخذ الدالة رقم الإدخال كسلسلة (يمكن أن تتضمن أرقامًا وحروفًا)،  \nقاعدة هذا الرقم، والقاعدة المستهدفة للتحويل. يمكن أن تتراوح القواعد من 2 إلى 16.  \nالناتج هو الرقم المحول كسلسلة في القاعدة المستهدفة، باستخدام حروف كبيرة للقواعد التي تزيد عن 10.\n\nأمثلة:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "sw": "Inabadilisha nambari kutoka msingi mmoja hadi mwingine.  \nKazi hii inachukua nambari ya ingizo kama kamba (ambayo inaweza kujumuisha tarakimu na herufi),  \nmsingi wa nambari hii, na msingi lengwa kwa ubadilishaji. Misingi inaweza kuwa kati ya 2 hadi 16.  \nPato ni nambari iliyobadilishwa kama kamba katika msingi lengwa, ikitumia herufi kubwa kwa misingi zaidi ya 10.\n\nMifano:  \n>>> convertBase(\"Aab3\", 15, 7)  \n\"210306\"  \n>>> convertBase(\"101\", 2, 10)  \n\"5\"  \n>>> convertBase(\"FF\", 16, 2)  \n\"11111111\"  ",
      "tr": "Bir sayıyı bir tabandan diğerine dönüştürür.\nFonksiyon, bir sayıyı string olarak alır (rakamlar ve harfler içerebilir),\nbu sayının tabanını ve dönüştürme için hedef tabanı alır. Tabanlar 2 ile 16 arasında olabilir.\nÇıktı, hedef tabanda büyük harfler kullanılarak dönüştürülmüş sayıyı string olarak verir.\n\nÖrnekler:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "vi": "Chuyển đổi một số từ một cơ số này sang cơ số khác.  \nHàm nhận một số đầu vào dưới dạng chuỗi (có thể bao gồm chữ số và chữ cái),  \ncơ số của số này, và cơ số đích để chuyển đổi. Các cơ số có thể từ 2 đến 16.  \nĐầu ra là số đã được chuyển đổi dưới dạng chuỗi trong cơ số đích, sử dụng chữ cái in hoa cho các cơ số lớn hơn 10.\n\nVí dụ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\""
    },
    "docstring_bertscore": {
      "es": "0.990116152239704",
      "arb": "0.9867747919699351",
      "sw": "0.9882690883264605",
      "tr": "0.9512465702357488",
      "vi": "0.9916187910722329"
    }
  },
  {
    "task_id": "Kotlin/29",
    "prompt": {
      "en": "/**\n * Determines whether a given number string is a cyclic number.\n * A cyclic number is one where multiplying it by any number from 1 to its length,\n * results in a permutation of the original number.\n *\n * Examples:\n * >>> isCyclicNumber(\"142857\")\n *     1 // since 142857 is a cyclic number\n * >>> isCyclicNumber(\"123456\")\n *     0 // since 123456 is not a cyclic number\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "es": "/**\n * Determina si una cadena de números dada es un número cíclico.\n * Un número cíclico es aquel que al multiplicarlo por cualquier número del 1 a su longitud,\n * resulta en una permutación del número original.\n *\n * Ejemplos:\n * >>> isCyclicNumber(\"142857\")\n *     1 // ya que 142857 es un número cíclico\n * >>> isCyclicNumber(\"123456\")\n *     0 // ya que 123456 no es un número cíclico\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "arb": "/**\n * يحدد ما إذا كانت سلسلة الأرقام المعطاة هي رقم دوري.\n * الرقم الدوري هو الرقم الذي عند ضربه بأي رقم من 1 إلى طوله،\n * ينتج عنه ترتيب مختلف للرقم الأصلي.\n *\n * أمثلة:\n * >>> isCyclicNumber(\"142857\")\n *     1 // لأن 142857 هو رقم دوري\n * >>> isCyclicNumber(\"123456\")\n *     0 // لأن 123456 ليس رقمًا دوريًا\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "sw": "/**\n * Huamua kama namba iliyotolewa kwa njia ya maandishi ni namba ya mzunguko.\n * Namba ya mzunguko ni ile ambapo kuizidisha na namba yoyote kutoka 1 hadi urefu wake,\n * husababisha mpangilio mpya wa namba ya awali.\n *\n * Mifano:\n * >>> isCyclicNumber(\"142857\")\n *     1 // kwa kuwa 142857 ni namba ya mzunguko\n * >>> isCyclicNumber(\"123456\")\n *     0 // kwa kuwa 123456 si namba ya mzunguko\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "tr": "/**\n * Verilen bir sayı dizisinin döngüsel bir sayı olup olmadığını belirler.\n * Döngüsel bir sayı, 1'den uzunluğuna kadar herhangi bir sayı ile çarpıldığında,\n * orijinal sayının bir permütasyonunu veren bir sayıdır.\n *\n * Örnekler:\n * >>> isCyclicNumber(\"142857\")\n *     1 // çünkü 142857 döngüsel bir sayıdır\n * >>> isCyclicNumber(\"123456\")\n *     0 // çünkü 123456 döngüsel bir sayı değildir\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "vi": "/**\n * Xác định xem một chuỗi số cho trước có phải là một số tuần hoàn hay không.\n * Một số tuần hoàn là số mà khi nhân nó với bất kỳ số nào từ 1 đến độ dài của nó,\n * kết quả là một hoán vị của số gốc.\n *\n * Ví dụ:\n * >>> isCyclicNumber(\"142857\")\n *     1 // vì 142857 là một số tuần hoàn\n * >>> isCyclicNumber(\"123456\")\n *     0 // vì 123456 không phải là một số tuần hoàn\n */\n\nfun isCyclicNumber(numberString: String): Int "
    },
    "prompt_bertscore": {
      "es": "0.9798388176945778",
      "arb": "0.9572225638795644",
      "sw": "0.9695521475215431",
      "tr": "0.9666416165482388",
      "vi": "0.9627152898063221"
    },
    "canonical_solution": "{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}",
    "instruction": {
      "en": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9074996192254818",
      "sw": "0.918038549982431",
      "tr": "0.9518293517737051",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main(){\n    check(isCyclicNumber(\"142857\") == 1)\n    check(isCyclicNumber(\"123456\") == 0)\n    check(isCyclicNumber(\"076923\") == 0)\n    check(isCyclicNumber(\"1\") == 1)\n    check(isCyclicNumber(\"0\") == 1)\n\n}\n\nmain()",
    "entry_point": "isCyclicNumber",
    "signature": "fun isCyclicNumber(numberString: String): Int",
    "docstring": {
      "en": "Determines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number",
      "es": "Determina si una cadena de números dada es un número cíclico.  \nUn número cíclico es aquel donde al multiplicarlo por cualquier número desde 1 hasta su longitud,  \nresulta en una permutación del número original.\n\nEjemplos:\n>>> isCyclicNumber(\"142857\")\n1 // ya que 142857 es un número cíclico\n>>> isCyclicNumber(\"123456\")\n0 // ya que 123456 no es un número cíclico",
      "arb": "يحدد ما إذا كانت سلسلة الأرقام المعطاة هي رقم دوري.\nالرقم الدوري هو الذي يؤدي ضربه بأي رقم من 1 إلى طوله إلى ترتيب مختلف للرقم الأصلي.\n\nأمثلة:\n>>> isCyclicNumber(\"142857\")\n1 // لأن 142857 هو رقم دوري\n>>> isCyclicNumber(\"123456\")\n0 // لأن 123456 ليس رقمًا دوريًا",
      "sw": "Inabainisha ikiwa namba iliyotolewa kwa njia ya maandishi ni namba ya mzunguko.  \nNamba ya mzunguko ni ile ambapo kuizidisha na namba yoyote kutoka 1 hadi urefu wake,  \ninatoa mpangilio mpya wa namba ya awali.  \n\nMifano:  \n>>> isCyclicNumber(\"142857\")  \n1 // kwa kuwa 142857 ni namba ya mzunguko  \n>>> isCyclicNumber(\"123456\")  \n0 // kwa kuwa 123456 si namba ya mzunguko  ",
      "tr": "Verilen bir sayı dizisinin döngüsel bir sayı olup olmadığını belirler. Döngüsel bir sayı, 1'den uzunluğuna kadar herhangi bir sayı ile çarpıldığında, orijinal sayının bir permütasyonu olan bir sonuç verir.\n\nÖrnekler:\n>>> isCyclicNumber(\"142857\")\n1 // çünkü 142857 bir döngüsel sayıdır\n>>> isCyclicNumber(\"123456\")\n0 // çünkü 123456 bir döngüsel sayı değildir",
      "vi": "Xác định xem một chuỗi số cho trước có phải là số tuần hoàn hay không.  \nMột số tuần hoàn là số mà khi nhân nó với bất kỳ số nào từ 1 đến độ dài của nó,  \nkết quả là một hoán vị của số gốc.\n\nVí dụ:\n>>> isCyclicNumber(\"142857\")\n1 // vì 142857 là một số tuần hoàn\n>>> isCyclicNumber(\"123456\")\n0 // vì 123456 không phải là một số tuần hoàn"
    },
    "docstring_bertscore": {
      "es": "0.9784923023415423",
      "arb": "0.9537900322649006",
      "sw": "0.9557719662068667",
      "tr": "0.9449092679288307",
      "vi": "0.9490675949557961"
    }
  },
  {
    "task_id": "Kotlin/30",
    "prompt": {
      "en": "/**\n    * Sum the given list of fractions and simplify the resulting fraction.\n    * The simplification process involves finding the greatest common divisor (GCD)\n    * of the numerator and the denominator and dividing both by this GCD. \n    * If the denominator after simplification is 1, only the numerator is returned.\n    *\n    * Example:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "es": "/**\n    * Sumar la lista dada de fracciones y simplificar la fracción resultante.\n    * El proceso de simplificación implica encontrar el máximo común divisor (MCD)\n    * del numerador y el denominador y dividir ambos por este MCD.\n    * Si el denominador después de la simplificación es 1, solo se devuelve el numerador.\n    *\n    * Ejemplo:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "arb": "/**\n    * جمع قائمة الكسور المعطاة وتبسيط الكسر الناتج.\n    * تتضمن عملية التبسيط إيجاد القاسم المشترك الأكبر (GCD)\n    * للبسط والمقام وقسمة كليهما على هذا القاسم المشترك الأكبر.\n    * إذا كان المقام بعد التبسيط يساوي 1، يتم إرجاع البسط فقط.\n    *\n    * مثال:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "sw": "/**\n    * Jumlisha orodha iliyotolewa ya sehemu na rahisisha sehemu inayopatikana.\n    * Mchakato wa kurahisisha unahusisha kutafuta mgawanyiko mkubwa zaidi wa kawaida (GCD)\n    * wa numerator na denominator na kugawanya zote mbili kwa GCD hii.\n    * Ikiwa denominator baada ya kurahisisha ni 1, ni numerator pekee inayorejeshwa.\n    *\n    * Mfano:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "tr": "/**\n    * Verilen kesirler listesini topla ve ortaya çıkan kesiri basitleştir.\n    * Basitleştirme süreci, pay ve paydanın en büyük ortak bölenini (EBOB)\n    * bulmayı ve her ikisini de bu EBOB ile bölmeyi içerir.\n    * Basitleştirmeden sonra payda 1 ise, sadece pay döndürülür.\n    *\n    * Örnek:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "vi": "/**\n    * Tính tổng danh sách các phân số đã cho và rút gọn phân số kết quả.\n    * Quá trình rút gọn bao gồm việc tìm ước chung lớn nhất (GCD)\n    * của tử số và mẫu số và chia cả hai cho GCD này.\n    * Nếu mẫu số sau khi rút gọn là 1, chỉ trả về tử số.\n    *\n    * Ví dụ:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String"
    },
    "prompt_bertscore": {
      "es": "0.9942635545957125",
      "arb": "0.9829714174338791",
      "sw": "0.9906280227316309",
      "tr": "0.9946546578159702",
      "vi": "0.977317800898483"
    },
    "canonical_solution": "{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b",
    "instruction": {
      "en": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8900610635529049",
      "sw": "0.9437925679266526",
      "tr": "0.9518293517737051",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\")) == \"5/6\")\n    check(sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\")) == \"3/4\")\n    check(sumAndSimplifyFractions(listOf(\"1/8\", \"3/8\")) == \"1/2\")\n    check(sumAndSimplifyFractions(listOf(\"2/3\", \"1/3\")) == \"1\")\n}\n\n\nmain()",
    "entry_point": "sumAndSimplifyFractions",
    "signature": "fun sumAndSimplifyFractions(fractions: List<String>): String",
    "docstring": {
      "en": "Sum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "es": "Suma la lista dada de fracciones y simplifica la fracción resultante. El proceso de simplificación implica encontrar el máximo común divisor (MCD) del numerador y el denominador y dividir ambos por este MCD. Si el denominador después de la simplificación es 1, solo se devuelve el numerador.\n\nEjemplo:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "arb": "جمع قائمة الكسور المعطاة وتبسيط الكسر الناتج. تتضمن عملية التبسيط إيجاد القاسم المشترك الأكبر (GCD) للبسط والمقام وقسمة كليهما على هذا القاسم المشترك. إذا كان المقام بعد التبسيط هو 1، يتم إرجاع البسط فقط.\n\nمثال:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "sw": "Jumlisha orodha iliyotolewa ya sehemu na rahisisha sehemu inayotokana.\nMchakato wa kurahisisha unahusisha kutafuta mgawanyiko mkubwa zaidi (GCD)\nwa numerator na denominator na kugawanya zote mbili kwa GCD hii.\nIkiwa denominator baada ya kurahisishwa ni 1, ni numerator pekee inayorejeshwa.\n\nMfano:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "tr": "Verilen kesirler listesini toplayın ve ortaya çıkan kesiri sadeleştirin. Sadeleştirme işlemi, pay ve paydanın en büyük ortak bölenini (EBOB) bulmayı ve her ikisini de bu EBOB ile bölmeyi içerir. Sadeleştirme sonrası payda 1 ise, yalnızca pay döndürülür.\n\nÖrnek:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "vi": "Tính tổng danh sách các phân số đã cho và rút gọn phân số kết quả. Quá trình rút gọn bao gồm việc tìm ước chung lớn nhất (GCD) của tử số và mẫu số và chia cả hai cho GCD này. Nếu mẫu số sau khi rút gọn là 1, chỉ trả về tử số.\n\nVí dụ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9869787853712579",
      "sw": "0.9897369668423084",
      "tr": "0.9806063254868966",
      "vi": "0.9749008664220505"
    }
  },
  {
    "task_id": "Kotlin/31",
    "prompt": {
      "en": "/**\n    * Calculate the number of various denominations of currency required to make up a given amount.\n    * The function takes an integer representing the total amount and returns a list of integers.\n    * The list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\n    * The goal is to minimize the total number of notes by using larger denominations where possible.\n    *\n    * Example:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "es": "/**\n    * Calcular el número de varias denominaciones de moneda necesarias para componer una cantidad dada.\n    * La función toma un entero que representa la cantidad total y devuelve una lista de enteros.\n    * La lista contiene el número de billetes de 100, 50, 20, 10, 5 y 1 yuan necesarios, en ese orden.\n    * El objetivo es minimizar el número total de billetes utilizando denominaciones más grandes cuando sea posible.\n    *\n    * Ejemplo:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "arb": "/**\n    * حساب عدد الفئات المختلفة من العملة المطلوبة لتكوين مبلغ معين.\n    * تأخذ الدالة عددًا صحيحًا يمثل المبلغ الإجمالي وتعيد قائمة من الأعداد الصحيحة.\n    * تحتوي القائمة على عدد الأوراق النقدية من فئات 100، 50، 20، 10، 5، و1 يوان المطلوبة، بهذا الترتيب.\n    * الهدف هو تقليل العدد الإجمالي للأوراق النقدية باستخدام الفئات الأكبر حيثما أمكن.\n    *\n    * مثال:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "sw": "/**\n    * Hesabu idadi ya aina mbalimbali za noti zinazohitajika kutengeneza kiasi kilichopewa.\n    * Kazi inachukua nambari nzima inayowakilisha jumla ya kiasi na inarudisha orodha ya nambari nzima.\n    * Orodha ina idadi ya noti za yuan 100, 50, 20, 10, 5, na 1 zinazohitajika, kwa mpangilio huo.\n    * Lengo ni kupunguza jumla ya idadi ya noti kwa kutumia noti kubwa zaidi inapowezekana.\n    *\n    * Mfano:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "tr": "/**\n    * Belirli bir miktarı oluşturmak için gereken çeşitli para birimlerinin sayısını hesaplayın.\n    * Fonksiyon, toplam miktarı temsil eden bir tamsayı alır ve bir tamsayı listesi döndürür.\n    * Liste, sırasıyla ihtiyaç duyulan 100, 50, 20, 10, 5 ve 1 yuan banknotlarının sayısını içerir.\n    * Amaç, mümkün olduğunca büyük banknotlar kullanarak toplam banknot sayısını en aza indirmektir.\n    *\n    * Örnek:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "vi": "/**\n    * Tính số lượng các mệnh giá tiền khác nhau cần thiết để tạo thành một số tiền cho trước.\n    * Hàm nhận vào một số nguyên đại diện cho tổng số tiền và trả về một danh sách các số nguyên.\n    * Danh sách chứa số lượng tờ tiền 100, 50, 20, 10, 5, và 1 nhân dân tệ cần thiết, theo thứ tự đó.\n    * Mục tiêu là giảm thiểu tổng số tờ tiền bằng cách sử dụng các mệnh giá lớn hơn khi có thể.\n    *\n    * Ví dụ:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9905857144604704",
      "arb": "0.9707858408181507",
      "sw": "0.9718685750251719",
      "tr": "0.9517653927910119",
      "vi": "0.9791253373659005"
    },
    "canonical_solution": "{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}",
    "instruction": {
      "en": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nKotlin kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9119840973381066",
      "sw": "0.9437925679266526",
      "tr": "0.8809137372454863",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(calculateCurrency(735) == listOf(7, 0, 1, 1, 1, 0))\n    check(calculateCurrency(123) == listOf(1, 0, 1, 0, 0, 3))\n    check(calculateCurrency(980) == listOf(9, 1, 1, 1, 0, 0))\n    check(calculateCurrency(50) == listOf(0, 1, 0, 0, 0, 0))\n}\n\nmain()",
    "entry_point": "calculateCurrency",
    "signature": "fun calculateCurrency(amount: Int): List<Int>",
    "docstring": {
      "en": "Calculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "es": "Calcular el número de varias denominaciones de moneda necesarias para componer una cantidad dada.  \nLa función toma un entero que representa la cantidad total y devuelve una lista de enteros.  \nLa lista contiene el número de billetes de 100, 50, 20, 10, 5 y 1 yuan necesarios, en ese orden.  \nEl objetivo es minimizar el número total de billetes utilizando denominaciones más grandes cuando sea posible.\n\nEjemplo:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "arb": "احسب عدد الفئات المختلفة من العملة المطلوبة لتكوين مبلغ معين.\nتأخذ الدالة عددًا صحيحًا يمثل المبلغ الإجمالي وتعيد قائمة من الأعداد الصحيحة.\nتحتوي القائمة على عدد الأوراق النقدية من فئات 100، 50، 20، 10، 5، و1 يوان المطلوبة، بهذا الترتيب.\nالهدف هو تقليل العدد الإجمالي للأوراق النقدية باستخدام الفئات الأكبر حيثما أمكن.\n\nمثال:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "sw": "Hesabu idadi ya noti za sarafu mbalimbali zinazohitajika kutengeneza kiasi kilichopewa.\nKazi inachukua nambari nzima inayowakilisha jumla ya kiasi na inarudisha orodha ya nambari nzima.\nOrodha ina idadi ya noti za yuan 100, 50, 20, 10, 5, na 1 zinazohitajika, kwa mpangilio huo.\nLengo ni kupunguza jumla ya idadi ya noti kwa kutumia noti kubwa zaidi inapowezekana.\n\nMfano:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "tr": "Verilen bir miktarı oluşturmak için gereken çeşitli para birimlerinin sayısını hesaplayın.\nFonksiyon, toplam miktarı temsil eden bir tam sayı alır ve bir tam sayı listesi döndürür.\nListe, sırasıyla 100, 50, 20, 10, 5 ve 1 yuan banknotlarının sayısını içerir.\nAmaç, mümkün olduğunca büyük para birimlerini kullanarak toplam banknot sayısını en aza indirmektir.\n\nÖrnek:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "vi": "Tính số lượng của các mệnh giá tiền khác nhau cần thiết để tạo thành một số tiền cho trước. Hàm nhận vào một số nguyên đại diện cho tổng số tiền và trả về một danh sách các số nguyên. Danh sách chứa số lượng tờ tiền 100, 50, 20, 10, 5, và 1 nhân dân tệ cần thiết, theo thứ tự đó. Mục tiêu là giảm thiểu tổng số lượng tờ tiền bằng cách sử dụng các mệnh giá lớn hơn nếu có thể.\n\nVí dụ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123"
    },
    "docstring_bertscore": {
      "es": "0.9798741739024021",
      "arb": "0.9692359279549355",
      "sw": "0.962458460723644",
      "tr": "0.9483606694296929",
      "vi": "0.976771368720256"
    }
  },
  {
    "task_id": "Kotlin/32",
    "prompt": {
      "en": "\n/**\n * Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\n * The search is conducted in ascending order.\n *\n * Example:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "es": "/**\n * Encuentra el n-ésimo número de tres dígitos que es un cuadrado perfecto y tiene al menos dos dígitos idénticos.\n * La búsqueda se realiza en orden ascendente.\n *\n * Ejemplo:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "arb": "/**\n * يجد الرقم ذو الثلاثة أرقام الذي هو مربع كامل وله على الأقل رقمين متطابقين في الترتيب n.\n * يتم إجراء البحث بترتيب تصاعدي.\n *\n * مثال:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "sw": "/**\n * Inapata nambari ya tatu ya tarakimu tatu ambayo ni mraba kamili na ina angalau tarakimu mbili zinazofanana.\n * Utafutaji unafanywa kwa mpangilio wa kupanda.\n *\n * Mfano:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "tr": "/**\n * En az iki aynı rakama sahip olan n'inci üç basamaklı mükemmel kare sayısını bulur.\n * Arama artan sırayla yapılır.\n *\n * Örnek:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "vi": "/**\n * Tìm số có ba chữ số thứ n là số chính phương và có ít nhất hai chữ số giống nhau.\n * Việc tìm kiếm được thực hiện theo thứ tự tăng dần.\n *\n * Ví dụ:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9784893228858268",
      "sw": "0.9788265972728241",
      "tr": "0.9697348874720951",
      "vi": "0.985436221832141"
    },
    "canonical_solution": "{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}",
    "instruction": {
      "en": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة كوتلن باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nKotlin kodunun Türkçe açıklaması için en fazla 500 karakter kullanarak kısa bir doğal dil tanımı sağlayın.",
      "vi": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9217428079583506",
      "sw": "0.918038549982431",
      "tr": "0.8737348380141233",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    check(findNthSquareNumberWithDuplicateDigits(1) == 100)\n    check(findNthSquareNumberWithDuplicateDigits(2) == 121)\n    check(findNthSquareNumberWithDuplicateDigits(3) == 144)  // Example of another test case\n    check(findNthSquareNumberWithDuplicateDigits(4) == 225)  // Example of another test case\n}\n\n\nmain()",
    "entry_point": "findNthSquareNumberWithDuplicateDigits",
    "signature": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
    "docstring": {
      "en": "Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "es": "Encuentra el n-ésimo número de tres dígitos que es un cuadrado perfecto y tiene al menos dos dígitos idénticos. La búsqueda se realiza en orden ascendente.\n\nEjemplo:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "arb": "يجد الرقم ذو الثلاثة أرقام الذي هو مربع كامل وله على الأقل رقمين متطابقين.\n\nيتم البحث بترتيب تصاعدي.\n\nمثال:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "sw": "Inapata nambari ya tatu ya tarakimu tatu ambayo ni mraba kamili na ina angalau tarakimu mbili zinazofanana. Utafutaji unafanywa kwa mpangilio wa kupanda.\n\nMfano:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "tr": "n. üç basamaklı, mükemmel kare olan ve en az iki aynı rakama sahip sayıyı bulur.\nArama artan sırayla yapılır.\n\nÖrnek:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "vi": "Tìm số có ba chữ số thứ n là số chính phương và có ít nhất hai chữ số giống nhau. Việc tìm kiếm được thực hiện theo thứ tự tăng dần.\n\nVí dụ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121"
    },
    "docstring_bertscore": {
      "es": "0.9893051443939385",
      "arb": "0.964900621258468",
      "sw": "0.9651187174168443",
      "tr": "0.9316008337691121",
      "vi": "0.9776139587966061"
    }
  },
  {
    "task_id": "Kotlin/33",
    "prompt": {
      "en": "/**\n    * Finds the longest word in a given simple English sentence. The sentence ends with a period,\n    * and words are separated by spaces. It assumes no abbreviations or special forms are present.\n    * If there are multiple longest words of the same length, the first one is returned.\n    *\n    * Example:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "es": "/**\n    * Encuentra la palabra más larga en una oración simple en inglés dada. La oración termina con un punto,\n    * y las palabras están separadas por espacios. Se asume que no hay abreviaturas o formas especiales presentes.\n    * Si hay múltiples palabras más largas de la misma longitud, se devuelve la primera.\n    *\n    * Ejemplo:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "arb": "/**\n    * يجد أطول كلمة في جملة إنجليزية بسيطة معطاة. تنتهي الجملة بنقطة،\n    * والكلمات مفصولة بمسافات. يفترض عدم وجود اختصارات أو أشكال خاصة.\n    * إذا كانت هناك عدة كلمات طويلة بنفس الطول، يتم إرجاع الأولى.\n    *\n    * مثال:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String ",
      "sw": "/**\n    * Inapata neno refu zaidi katika sentensi rahisi ya Kiingereza iliyotolewa. Sentensi inaishia na nukta,\n    * na maneno yanatenganishwa kwa nafasi. Inadhani hakuna vifupisho au aina maalum zilizopo.\n    * Ikiwa kuna maneno marefu zaidi ya moja yenye urefu sawa, la kwanza litarudishwa.\n    *\n    * Mfano:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "tr": "/**\n    * Verilen basit bir İngilizce cümledeki en uzun kelimeyi bulur. Cümle bir nokta ile biter\n    * ve kelimeler boşluklarla ayrılır. Kısaltmalar veya özel biçimler olmadığı varsayılır.\n    * Aynı uzunlukta birden fazla en uzun kelime varsa, ilki döndürülür.\n    *\n    * Örnek:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String ",
      "vi": "/**\n    * Tìm từ dài nhất trong một câu tiếng Anh đơn giản đã cho. Câu kết thúc bằng dấu chấm,\n    * và các từ được ngăn cách bằng khoảng trắng. Giả định rằng không có viết tắt hoặc dạng đặc biệt nào.\n    * Nếu có nhiều từ dài nhất có cùng độ dài, từ đầu tiên sẽ được trả về.\n    *\n    * Ví dụ:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String "
    },
    "prompt_bertscore": {
      "es": "0.9761260186122737",
      "arb": "0.9782007129421831",
      "sw": "0.9850673652145592",
      "tr": "0.9782160074815228",
      "vi": "0.982014614888434"
    },
    "canonical_solution": "{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}",
    "instruction": {
      "en": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9074996192254818",
      "sw": "0.912915077934017",
      "tr": "0.8945846718505934",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(findLongestWord(\"I am a student of Peking University.\") == \"University\")\n    check(findLongestWord(\"Hello world.\") == \"Hello\")\n    check(findLongestWord(\"Short sentences are sweet.\") == \"sentences\")\n    check(findLongestWord(\"Each word has its own length.\") == \"length\")\n}\n\n\nmain()",
    "entry_point": "findLongestWord",
    "signature": "fun findLongestWord(sentence: String): String",
    "docstring": {
      "en": "Finds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "es": "Encuentra la palabra más larga en una oración simple en inglés dada. La oración termina con un punto, y las palabras están separadas por espacios. Se asume que no hay abreviaturas o formas especiales presentes. Si hay múltiples palabras más largas de la misma longitud, se devuelve la primera.\n\nEjemplo:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "arb": "يجد أطول كلمة في جملة إنجليزية بسيطة معينة. تنتهي الجملة بنقطة، والكلمات مفصولة بمسافات. يفترض عدم وجود اختصارات أو أشكال خاصة. إذا كانت هناك عدة كلمات طويلة بنفس الطول، يتم إرجاع الأولى.\n\nمثال:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "sw": "Inapata neno refu zaidi katika sentensi rahisi ya Kiingereza iliyopewa. Sentensi inaishia na nukta, na maneno yanatenganishwa na nafasi. Inadhani hakuna vifupisho au aina maalum zilizopo. Ikiwa kuna maneno marefu zaidi ya moja ya urefu sawa, la kwanza ndilo linalorejeshwa.\n\nMfano:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "tr": "Verilen basit bir İngilizce cümledeki en uzun kelimeyi bulur. Cümle bir nokta ile biter ve kelimeler boşluklarla ayrılır. Kısaltmalar veya özel formlar olmadığı varsayılır. Aynı uzunlukta birden fazla en uzun kelime varsa, ilki döndürülür.\n\nÖrnek:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "vi": "Tìm từ dài nhất trong một câu tiếng Anh đơn giản cho trước. Câu kết thúc bằng dấu chấm, và các từ được ngăn cách bởi dấu cách. Giả định rằng không có viết tắt hay hình thức đặc biệt nào có mặt. Nếu có nhiều từ dài nhất có cùng độ dài, từ đầu tiên sẽ được trả về.\n\nVí dụ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\""
    },
    "docstring_bertscore": {
      "es": "0.9713273072368518",
      "arb": "0.9675485628680441",
      "sw": "0.9826714855585164",
      "tr": "0.9796052283664808",
      "vi": "0.9622769125553782"
    }
  },
  {
    "task_id": "Kotlin/34",
    "prompt": {
      "en": "/**\n    * Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\n    * Assumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n    *\n    * Example:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // For a leap year\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // For end of the year\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "es": "/**\n    * Calcula la fecha del día siguiente basada en una fecha dada en el formato yyyy-mm-dd.\n    * Supone fechas de entrada válidas que van desde 1600-01-01 hasta 2999-12-30.\n    *\n    * Ejemplo:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Para un año bisiesto\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Para fin de año\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "arb": "/**\n    * يحسب تاريخ اليوم التالي بناءً على تاريخ معين بالتنسيق yyyy-mm-dd.\n    * يفترض تواريخ إدخال صحيحة تتراوح من 1600-01-01 إلى 2999-12-30.\n    *\n    * مثال:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // لسنة كبيسة\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // لنهاية السنة\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "sw": "/**\n    * Hukokotoa tarehe ya siku inayofuata kulingana na tarehe iliyotolewa katika muundo wa yyyy-mm-dd.\n    * Inadhani tarehe za pembejeo halali zinazoanzia 1600-01-01 hadi 2999-12-30.\n    *\n    * Mfano:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Kwa mwaka wa kisasa\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Kwa mwisho wa mwaka\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "tr": "/**\n    * Verilen bir tarihe göre yyyy-aa-gg formatında bir sonraki günün tarihini hesaplar.\n    * 1600-01-01 ile 2999-12-30 arasında geçerli giriş tarihlerini varsayar.\n    *\n    * Örnek:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Artık yıl için\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Yıl sonu için\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "vi": "/**\n    * Tính toán ngày của ngày tiếp theo dựa trên một ngày cho trước theo định dạng yyyy-mm-dd.\n    * Giả định các ngày đầu vào hợp lệ trong khoảng từ 1600-01-01 đến 2999-12-30.\n    *\n    * Ví dụ:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Đối với năm nhuận\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Đối với cuối năm\n**/\n\nfun getNextDayDate(currentDate: String): String "
    },
    "prompt_bertscore": {
      "es": "0.9977354150258212",
      "arb": "0.9973268323320325",
      "sw": "0.9926461074029453",
      "tr": "0.9760257102698511",
      "vi": "0.9739750502160469"
    },
    "canonical_solution": "{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}",
    "instruction": {
      "en": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.918602461634189",
      "sw": "0.9437925679266526",
      "tr": "0.9394266721515057",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(getNextDayDate(\"2010-07-05\") == \"2010-07-06\")\n    check(getNextDayDate(\"2020-02-28\") == \"2020-02-29\") // Leap year case\n    check(getNextDayDate(\"2020-12-31\") == \"2021-01-01\") // End of the year case\n    check(getNextDayDate(\"2019-02-28\") == \"2019-03-01\") // Non-leap year February case\n}\n\nmain()",
    "entry_point": "getNextDayDate",
    "signature": "fun getNextDayDate(currentDate: String): String",
    "docstring": {
      "en": "Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year",
      "es": "Calcula la fecha del día siguiente basada en una fecha dada en el formato aaaa-mm-dd. Supone fechas de entrada válidas que van desde 1600-01-01 hasta 2999-12-30.\n\nEjemplo:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Para un año bisiesto\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Para fin de año",
      "arb": "يحسب تاريخ اليوم التالي بناءً على تاريخ معين بالتنسيق yyyy-mm-dd. يفترض تواريخ إدخال صالحة تتراوح من 1600-01-01 إلى 2999-12-30.\n\nمثال:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // لسنة كبيسة\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // لنهاية العام",
      "sw": "Hesabu tarehe ya siku inayofuata kulingana na tarehe iliyotolewa katika muundo wa yyyy-mm-dd. Inadhani tarehe za pembejeo halali zinazotoka 1600-01-01 hadi 2999-12-30.\n\nMfano:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Kwa mwaka wa kisasa\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Kwa mwisho wa mwaka",
      "tr": "Verilen tarihe göre yyyy-aa-gg formatında bir sonraki günün tarihini hesaplar.\nGeçerli giriş tarihlerini 1600-01-01 ile 2999-12-30 arasında varsayar.\n\nÖrnek:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Artık yıl için\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Yıl sonu için",
      "vi": "Tính toán ngày của ngày tiếp theo dựa trên một ngày cho trước theo định dạng yyyy-mm-dd. Giả định các ngày đầu vào hợp lệ trong khoảng từ 1600-01-01 đến 2999-12-30.\n\nVí dụ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Đối với năm nhuận\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Đối với cuối năm"
    },
    "docstring_bertscore": {
      "es": "0.9943795547382368",
      "arb": "0.998503121448521",
      "sw": "0.9915484759173465",
      "tr": "0.9657984305807457",
      "vi": "0.9885455818168611"
    }
  },
  {
    "task_id": "Kotlin/35",
    "prompt": {
      "en": "/**\n    * Calculates the number of days between two given dates.\n    * The dates are provided as year, month, and day.\n    * Accounts for leap years in the calculation.\n    *\n    * Example:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "es": "/**\n    * Calcula el número de días entre dos fechas dadas.\n    * Las fechas se proporcionan como año, mes y día.\n    * Tiene en cuenta los años bisiestos en el cálculo.\n    *\n    * Ejemplo:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "arb": "/**\n    * يحسب عدد الأيام بين تاريخين محددين.\n    * يتم تقديم التواريخ كسنة وشهر ويوم.\n    * يأخذ في الاعتبار السنوات الكبيسة في الحساب.\n    *\n    * مثال:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "sw": "/**\n    * Inahesabu idadi ya siku kati ya tarehe mbili zilizotolewa.\n    * Tarehe zinatolewa kama mwaka, mwezi, na siku.\n    * Inazingatia miaka ya kuruka katika hesabu.\n    *\n    * Mfano:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "tr": "/**\n    * İki verilen tarih arasındaki gün sayısını hesaplar.\n    * Tarihler yıl, ay ve gün olarak verilir.\n    * Hesaplamada artık yılları dikkate alır.\n    *\n    * Örnek:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "vi": "/**\n    * Tính số ngày giữa hai ngày đã cho.\n    * Các ngày được cung cấp dưới dạng năm, tháng và ngày.\n    * Tính toán bao gồm cả năm nhuận.\n    *\n    * Ví dụ:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int"
    },
    "prompt_bertscore": {
      "es": "0.9909633108148178",
      "arb": "0.9868131276334748",
      "sw": "0.9913712976174635",
      "tr": "0.9900686795786366",
      "vi": "0.9837901718645048"
    },
    "canonical_solution": "{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}",
    "instruction": {
      "en": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8984770327973531",
      "sw": "0.9437925679266526",
      "tr": "0.9193461337807837",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(daysBetweenDates(2008, 1, 1, 2009, 1, 1) == 366)\n    check(daysBetweenDates(2010, 1, 1, 2010, 1, 3) == 2)\n    check(daysBetweenDates(2020, 5, 15, 2020, 5, 20) == 5)\n    check(daysBetweenDates(2019, 12, 31, 2020, 1, 1) == 1)\n}\n\n\nmain()",
    "entry_point": "daysBetweenDates",
    "signature": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
    "docstring": {
      "en": "Calculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "es": "Calcula el número de días entre dos fechas dadas.  \nLas fechas se proporcionan como año, mes y día.  \nTiene en cuenta los años bisiestos en el cálculo.\n\nEjemplo:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "arb": "يحسب عدد الأيام بين تاريخين محددين.\nيتم تقديم التواريخ كسنة وشهر ويوم.\nيأخذ في الاعتبار السنوات الكبيسة في الحساب.\n\nمثال:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "sw": "Hesabu idadi ya siku kati ya tarehe mbili zilizotolewa.  \nTarehe zinatolewa kama mwaka, mwezi, na siku.  \nInazingatia miaka ya kuruka katika hesabu.  \n\nMfano:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2  ",
      "tr": "İki verilen tarih arasındaki gün sayısını hesaplar.  \nTarihler yıl, ay ve gün olarak verilir.  \nHesaplamada artık yılları dikkate alır.  \n\nÖrnek:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2  ",
      "vi": "Tính toán số ngày giữa hai ngày đã cho.  \nCác ngày được cung cấp dưới dạng năm, tháng và ngày.  \nTính đến năm nhuận trong phép tính.  \n\nVí dụ:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2  "
    },
    "docstring_bertscore": {
      "es": "0.9704509499957259",
      "arb": "0.9802539551909407",
      "sw": "0.9746108660657395",
      "tr": "0.9801796674284337",
      "vi": "0.975882696395506"
    }
  },
  {
    "task_id": "Kotlin/36",
    "prompt": {
      "en": "\n/**\n * Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\n * An n-gram is a contiguous sequence of n characters from the text.\n * \n * Args:\n * n (Int): The length of each n-gram.\n * text (String): The text to analyze for n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\n * and the second element is a list of n-grams with that frequency, in the order they first appear in the text.\n * If the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "es": "/**\n * Encuentra los n-gramas más frecuentes (subcadenas de longitud n) en el texto dado y su frecuencia.\n * Un n-grama es una secuencia continua de n caracteres del texto.\n * \n * Argumentos:\n * n (Int): La longitud de cada n-grama.\n * text (String): El texto a analizar para n-gramas.\n * \n * Devuelve:\n * Pair<Int, List<String>>: Un par donde el primer elemento es la frecuencia más alta de cualquier n-grama,\n * y el segundo elemento es una lista de n-gramas con esa frecuencia, en el orden en que aparecen por primera vez en el texto.\n * Si la frecuencia más alta no es mayor que 1, devuelve \"NO\" como el único elemento en la lista.\n * \n * Ejemplos:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "arb": "/**\n * يجد n-grams الأكثر تكرارًا (سلاسل فرعية بطول n) في النص المعطى وتكرارها.\n * n-gram هو تسلسل متتابع من n أحرف من النص.\n * \n * المعاملات:\n * n (Int): طول كل n-gram.\n * text (String): النص لتحليله بحثًا عن n-grams.\n * \n * يعيد:\n * Pair<Int, List<String>>: زوج حيث العنصر الأول هو أعلى تكرار لأي n-gram،\n * والعنصر الثاني هو قائمة n-grams مع هذا التكرار، بترتيب ظهورها الأول في النص.\n * إذا لم يكن التكرار الأعلى أكبر من 1، يعيد \"NO\" كالعنصر الوحيد في القائمة.\n * \n * أمثلة:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */ \n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "sw": "/**\n * Inapata n-gramu (vipande vya maandishi vya urefu n) zinazojitokeza mara nyingi zaidi katika maandishi yaliyotolewa na marudio yao.\n * N-gramu ni mlolongo wa herufi n kutoka kwenye maandishi.\n * \n * Hoja:\n * n (Int): Urefu wa kila n-gramu.\n * text (String): Maandishi ya kuchanganua kwa n-gramu.\n * \n * Inarejeshas:\n * Pair<Int, List<String>>: Jozi ambapo kipengele cha kwanza ni marudio ya juu zaidi ya n-gramu yoyote,\n * na kipengele cha pili ni orodha ya n-gramu zenye marudio hayo, kwa mpangilio wa jinsi zinavyojitokeza kwanza kwenye maandishi.\n * Ikiwa marudio ya juu zaidi si zaidi ya 1, inarudisha \"NO\" kama kipengele pekee kwenye orodha.\n * \n * Mifano:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "tr": "/**\n * Verilen metindeki en sık n-gramları (n uzunluğundaki alt diziler) ve bunların sıklığını bulur.\n * Bir n-gram, metinden ardışık n karakterlik bir dizidir.\n * \n * Argümanlar:\n * n (Int): Her n-gramın uzunluğu.\n * text (String): n-gramlar için analiz edilecek metin.\n * \n * Döndürür:\n * Pair<Int, List<String>>: İlk elemanı herhangi bir n-gramın en yüksek sıklığı olan bir çift,\n * ve ikinci elemanı bu sıklığa sahip n-gramların, metinde ilk göründükleri sırayla bir listesi.\n * Eğer en yüksek sıklık 1'den büyük değilse, listede yalnızca \"NO\" elemanını döndürür.\n * \n * Örnekler:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "vi": "/**\n * Tìm các n-gram (chuỗi con có độ dài n) xuất hiện nhiều nhất trong văn bản đã cho và tần suất của chúng.\n * Một n-gram là một dãy liên tiếp gồm n ký tự từ văn bản.\n * \n * Tham số:\n * n (Int): Độ dài của mỗi n-gram.\n * text (String): Văn bản để phân tích n-gram.\n * \n * Trả về:\n * Pair<Int, List<String>>: Một cặp mà phần tử đầu tiên là tần suất cao nhất của bất kỳ n-gram nào,\n * và phần tử thứ hai là danh sách các n-gram với tần suất đó, theo thứ tự chúng xuất hiện đầu tiên trong văn bản.\n * Nếu tần suất cao nhất không lớn hơn 1, trả về \"NO\" là phần tử duy nhất trong danh sách.\n * \n * Ví dụ:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> "
    },
    "prompt_bertscore": {
      "es": "0.9980921551901599",
      "arb": "0.9916978459638848",
      "sw": "0.9798002834006571",
      "tr": "0.9761550186479048",
      "vi": "0.9820108409111943"
    },
    "canonical_solution": "{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}",
    "instruction": {
      "en": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9074996192254818",
      "sw": "0.918038549982431",
      "tr": "0.9349461666465017",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(findMostFrequentNGrams(3, \"abcdefabcd\") == Pair(2, listOf(\"abc\", \"bcd\")))\n    check(findMostFrequentNGrams(2, \"abcabc\") == Pair(2, listOf(\"ab\", \"bc\")))\n    check(findMostFrequentNGrams(4, \"abcdefg\") == Pair(1, listOf(\"NO\")))\n    check(findMostFrequentNGrams(2, \"abcdabcd\") == Pair(2, listOf(\"ab\", \"bc\", \"cd\")))\n}\n\n\nmain()",
    "entry_point": "findMostFrequentNGrams",
    "signature": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>",
    "docstring": {
      "en": "Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "es": "Encuentra los n-gramas más frecuentes (subcadenas de longitud n) en el texto dado y su frecuencia. Un n-grama es una secuencia contigua de n caracteres del texto.\n\nArgumentos:\nn (Int): La longitud de cada n-grama.\ntext (String): El texto a analizar para n-gramas.\n\nDevuelve:\nPair<Int, List<String>>: Un par donde el primer elemento es la frecuencia más alta de cualquier n-grama, y el segundo elemento es una lista de n-gramas con esa frecuencia, en el orden en que aparecen por primera vez en el texto. Si la frecuencia más alta no es mayor que 1, devuelve \"NO\" como el único elemento en la lista.\n\nEjemplos:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "arb": "يجد أكثر n-grams تكرارًا (سلاسل فرعية بطول n) في النص المعطى وتكرارها. \nn-gram هو تسلسل متواصل من n حروف من النص.\n\nالمعطيات:\nn (عدد صحيح): طول كل n-gram.\ntext (سلسلة نصية): النص لتحليله من أجل n-grams.\n\nالقيم المعادة:\nPair<Int, List<String>>: زوج حيث العنصر الأول هو أعلى تكرار لأي n-gram، \nوالعنصر الثاني هو قائمة من n-grams مع هذا التكرار، بترتيب ظهورها الأول في النص. \nإذا لم يكن التكرار الأعلى أكبر من 1، يعيد \"NO\" كالعنصر الوحيد في القائمة.\n\nأمثلة:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "sw": "Inapata n-grams zinazojirudia mara nyingi zaidi (vifungu vya herufi zenye urefu n) katika maandishi yaliyotolewa na marudio yao.\nN-gram ni mlolongo unaoendelea wa herufi n kutoka kwa maandishi.\n\nHoja:\nn (Int): Urefu wa kila n-gram.\ntext (String): Maandishi ya kuchambua kwa n-grams.\n\nInarejesha:\nPair<Int, List<String>>: Jozi ambapo kipengele cha kwanza ni marudio ya juu zaidi ya n-gram yoyote,\nna kipengele cha pili ni orodha ya n-grams zenye marudio hayo, kwa mpangilio wa jinsi zinavyoonekana kwanza katika maandishi.\nIkiwa marudio ya juu zaidi si zaidi ya 1, inarudisha \"NO\" kama kipengele pekee katika orodha.\n\nMifano:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "tr": "Verilen metindeki en sık n-gramları (n uzunluğundaki alt diziler) ve bunların sıklığını bulur. Bir n-gram, metinden ardışık n karakterlik bir dizidir.\n\nArgümanlar:\nn (Int): Her n-gramın uzunluğu.\ntext (String): n-gramlar için analiz edilecek metin.\n\nDöndürür:\nPair<Int, List<String>>: İlk elemanı herhangi bir n-gramın en yüksek sıklığı olan ve ikinci elemanı bu sıklığa sahip n-gramların, metinde ilk göründükleri sırayla listesi olan bir çift. En yüksek sıklık 1'den büyük değilse, listede tek eleman olarak \"NO\" döner.\n\nÖrnekler:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "vi": "Tìm các n-gram (chuỗi con có độ dài n) xuất hiện nhiều nhất trong văn bản cho trước và tần suất của chúng. Một n-gram là một dãy liên tiếp gồm n ký tự từ văn bản.\n\nTham số:\nn (Int): Độ dài của mỗi n-gram.\ntext (String): Văn bản cần phân tích để tìm n-gram.\n\nTrả về:\nPair<Int, List<String>>: Một cặp mà phần tử đầu tiên là tần suất cao nhất của bất kỳ n-gram nào, và phần tử thứ hai là danh sách các n-gram có tần suất đó, theo thứ tự chúng xuất hiện đầu tiên trong văn bản. Nếu tần suất cao nhất không lớn hơn 1, trả về \"NO\" như là phần tử duy nhất trong danh sách.\n\nVí dụ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))"
    },
    "docstring_bertscore": {
      "es": "0.9940353282879033",
      "arb": "0.9688652836639243",
      "sw": "0.9715485814813247",
      "tr": "0.9789592823673553",
      "vi": "0.9764664710853674"
    }
  },
  {
    "task_id": "Kotlin/37",
    "prompt": {
      "en": "/**\n * Divide a large number (as a string) by 13 and return the quotient and remainder.\n * The input number can be up to 100 digits long.\n *\n * Example:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "es": "/**\n * Divide un número grande (como una cadena) por 13 y devuelve el cociente y el resto.\n * El número de entrada puede tener hasta 100 dígitos.\n *\n * Ejemplo:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "arb": "/**\n * قسّم عددًا كبيرًا (كسلسلة نصية) على 13 وأعد خارج القسمة والباقي.\n * يمكن أن يصل طول الرقم المدخل إلى 100 رقم.\n *\n * مثال:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "sw": "/**\n * Gawa nambari kubwa (kama kamba) kwa 13 na rudisha sehemu ya mgawo na bakio.\n * Nambari ya ingizo inaweza kuwa na urefu wa hadi tarakimu 100.\n *\n * Mfano:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "tr": "/**\n * Büyük bir sayıyı (string olarak) 13'e böl ve bölümü ve kalanı döndür.\n * Girdi numarası 100 basamağa kadar uzun olabilir.\n *\n * Örnek:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "vi": "/**\n * Chia một số lớn (dưới dạng chuỗi) cho 13 và trả về thương và số dư.\n * Số đầu vào có thể dài tới 100 chữ số.\n *\n * Ví dụ:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> "
    },
    "prompt_bertscore": {
      "es": "0.9909696669870108",
      "arb": "1",
      "sw": "0.9885060543710351",
      "tr": "1",
      "vi": "0.9943694245888041"
    },
    "canonical_solution": "{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}",
    "instruction": {
      "en": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nKotlin kodunun Türkçe açıklamasını (docstring) en fazla 500 karakter kullanarak sağlayın.",
      "vi": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8953293371490932",
      "sw": "0.912915077934017",
      "tr": "0.8722921855566669",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(divideByThirteen(\"2132104848488485\") == Pair(\"164008065268345\", \"0\"))\n    check(divideByThirteen(\"169\") == Pair(\"13\", \"0\"))\n    check(divideByThirteen(\"20\") == Pair(\"1\", \"7\"))\n    check(divideByThirteen(\"130\") == Pair(\"10\", \"0\"))\n    check(divideByThirteen(\"0\") == Pair(\"0\", \"0\"))\n}\n\n\nmain()",
    "entry_point": "divideByThirteen",
    "signature": "fun divideByThirteen(number: String): Pair<String, String>",
    "docstring": {
      "en": "Divide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "es": "Dividir un número grande (como una cadena) por 13 y devolver el cociente y el resto.  \nEl número de entrada puede tener hasta 100 dígitos.\n\nEjemplo:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "arb": "قسّم عددًا كبيرًا (كسلسلة نصية) على 13 وأعد خارج القسمة والباقي. يمكن أن يصل طول الرقم المدخل إلى 100 رقم.\n\nمثال:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "sw": "Gawanya nambari kubwa (kama kamba) kwa 13 na rudisha sehemu ya mgawo na baki. Nambari ya ingizo inaweza kuwa na urefu wa tarakimu 100.\n\nMfano:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "tr": "On üç ile bölünecek büyük bir sayıyı (string olarak) böl ve bölüm ile kalanı döndür.\nGirdi sayısı en fazla 100 basamak uzunluğunda olabilir.\n\nÖrnek:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "vi": "Chia một số lớn (dưới dạng chuỗi) cho 13 và trả về thương và số dư.  \nSố đầu vào có thể dài tới 100 chữ số.\n\nVí dụ:  \n>>> divideByThirteen(\"2132104848488485\")  \n(\"164008065268345\", \"0\")  \n>>> divideByThirteen(\"169\")  \n(\"13\", \"0\")  \n>>> divideByThirteen(\"20\")  \n(\"1\", \"7\")  "
    },
    "docstring_bertscore": {
      "es": "0.9930127790863358",
      "arb": "1",
      "sw": "0.9867680385369799",
      "tr": "0.9986362038038145",
      "vi": "0.9919489147655128"
    }
  },
  {
    "task_id": "Kotlin/38",
    "prompt": {
      "en": "/**\n    * Extracts all integer numbers from a given string and returns them as a sorted list.\n    * The integers in the string are assumed to be non-negative and separated by non-digit characters.\n    * If no integers are found, returns a list containing only zero.\n    *\n    * Example:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "es": "/**\n    * Extrae todos los números enteros de una cadena dada y los devuelve como una lista ordenada.\n    * Se asume que los enteros en la cadena son no negativos y están separados por caracteres no numéricos.\n    * Si no se encuentran enteros, devuelve una lista que contiene solo cero.\n    *\n    * Ejemplo:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "arb": "/**\n    * يستخرج جميع الأعداد الصحيحة من سلسلة معينة ويعيدها كقائمة مرتبة.\n    * يُفترض أن الأعداد الصحيحة في السلسلة غير سالبة ومفصولة بأحرف غير رقمية.\n    * إذا لم يتم العثور على أعداد صحيحة، يعيد قائمة تحتوي فقط على صفر.\n    *\n    * مثال:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/ \n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "sw": "/**\n    * Hutoa namba zote za integer kutoka kwa string iliyotolewa na kuzirejesha kama orodha iliyopangwa.\n    * Namba za integer katika string zinadhaniwa kuwa zisizo na alama hasi na zimetenganishwa na herufi zisizo za namba.\n    * Ikiwa hakuna namba za integer zinazopatikana, inarejesha orodha iliyo na sifuri pekee.\n    *\n    * Mfano:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/ \n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "tr": "/**\n    * Verilen bir string içinden tüm tam sayılarını çıkarır ve bunları sıralı bir liste olarak döndürür.\n    * String içindeki tam sayıların negatif olmadığı ve rakam olmayan karakterlerle ayrıldığı varsayılır.\n    * Eğer tam sayı bulunamazsa, sadece sıfır içeren bir liste döndürür.\n    *\n    * Örnek:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "vi": "/**\n    * Trích xuất tất cả các số nguyên từ một chuỗi cho trước và trả về chúng dưới dạng danh sách đã sắp xếp.\n    * Các số nguyên trong chuỗi được giả định là không âm và được ngăn cách bởi các ký tự không phải số.\n    * Nếu không tìm thấy số nguyên nào, trả về danh sách chỉ chứa số không.\n    *\n    * Ví dụ:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/ \n\nfun extractAndSortIntegers(input: String): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9747574552869434",
      "arb": "0.9892830964216437",
      "sw": "0.9849140225604003",
      "tr": "0.9629458996787037",
      "vi": "0.986518161517638"
    },
    "canonical_solution": "{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}",
    "instruction": {
      "en": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9055365551697141",
      "sw": "0.918038549982431",
      "tr": "0.9349461666465017",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "check(extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\") == listOf(9, 9, 81, 88, 345, 1234, 6781, 11101))\ncheck(extractAndSortIntegers(\"no numbers\") == listOf(0))\ncheck(extractAndSortIntegers(\"123&456*789\") == listOf(123, 456, 789))\ncheck(extractAndSortIntegers(\"abc\") == listOf(0))",
    "entry_point": "extractAndSortIntegers",
    "signature": "fun extractAndSortIntegers(input: String): List<Int>",
    "docstring": {
      "en": "Extracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "es": "Extrae todos los números enteros de una cadena dada y los devuelve como una lista ordenada.  \nSe asume que los enteros en la cadena son no negativos y están separados por caracteres no numéricos.  \nSi no se encuentran enteros, devuelve una lista que contiene solo cero.\n\nEjemplo:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "arb": "يستخرج جميع الأعداد الصحيحة من سلسلة نصية معينة ويعيدها كقائمة مرتبة.\nيُفترض أن الأعداد الصحيحة في السلسلة غير سالبة ومفصولة بأحرف غير رقمية.\nإذا لم يتم العثور على أي أعداد صحيحة، يعيد قائمة تحتوي على الصفر فقط.\n\nمثال:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "sw": "Hutoa namba zote za mzima kutoka kwenye kamba iliyotolewa na kuzirejesha kama orodha iliyopangwa.\nNamba za mzima kwenye kamba zinadhaniwa kuwa zisizo na alama hasi na zimetenganishwa na herufi zisizo za namba.\nKama hakuna namba za mzima zilizopatikana, inarejesha orodha yenye sifuri pekee.\n\nMfano:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "tr": "Verilen bir string içindeki tüm tamsayıları çıkarır ve bunları sıralı bir liste olarak döndürür.\nString içindeki tamsayıların negatif olmadığı ve rakam olmayan karakterlerle ayrıldığı varsayılır.\nEğer hiçbir tamsayı bulunamazsa, sadece sıfır içeren bir liste döndürür.\n\nÖrnek:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "vi": "Trích xuất tất cả các số nguyên từ một chuỗi đã cho và trả về chúng dưới dạng một danh sách đã sắp xếp. Các số nguyên trong chuỗi được giả định là không âm và được phân tách bằng các ký tự không phải là chữ số. Nếu không tìm thấy số nguyên nào, trả về một danh sách chỉ chứa số không.\n\nVí dụ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]"
    },
    "docstring_bertscore": {
      "es": "0.9742642560508337",
      "arb": "0.9748059210999158",
      "sw": "0.975416312260836",
      "tr": "0.9842386792648816",
      "vi": "0.9873104981075862"
    }
  },
  {
    "task_id": "Kotlin/39",
    "prompt": {
      "en": "/**\n * Determines whether a given number x is an element of a set M generated from a starting number k.\n * The set M is generated as follows:\n *   (1) k is an element of M.\n *   (2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n *   (3) No other elements are in M except those generated by the above rules.\n * \n * Example:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "es": "/**\n * Determina si un número dado x es un elemento de un conjunto M generado a partir de un número inicial k.\n * El conjunto M se genera de la siguiente manera:\n *   (1) k es un elemento de M.\n *   (2) Si y es un elemento de M, entonces tanto (2y + 1) como (3y + 1) son elementos de M.\n *   (3) No hay otros elementos en M excepto los generados por las reglas anteriores.\n * \n * Ejemplo:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "arb": "/**\n * يحدد ما إذا كان الرقم المعطى x هو عنصر في مجموعة M التي تم إنشاؤها من رقم بداية k.\n * يتم إنشاء المجموعة M كما يلي:\n *   (1) k هو عنصر في M.\n *   (2) إذا كان y عنصرًا في M، فإن كلا من (2y + 1) و (3y + 1) هما عنصران في M.\n *   (3) لا توجد عناصر أخرى في M باستثناء تلك التي تم إنشاؤها بواسطة القواعد المذكورة أعلاه.\n * \n * مثال:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "sw": "/**\n * Huamua kama nambari fulani x ni kipengele cha seti M inayozalishwa kutoka kwa nambari ya kuanzia k.\n * Seti M inazalishwa kama ifuatavyo:\n *   (1) k ni kipengele cha M.\n *   (2) Ikiwa y ni kipengele cha M, basi zote mbili (2y + 1) na (3y + 1) ni vipengele vya M.\n *   (3) Hakuna vipengele vingine katika M isipokuwa vile vilivyozalishwa na sheria zilizo hapo juu.\n * \n * Mfano:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "tr": "/**\n * Verilen bir sayı x'in, başlangıç sayısı k'dan üretilen bir küme M'nin elemanı olup olmadığını belirler.\n * Küme M şu şekilde üretilir:\n *   (1) k, M'nin bir elemanıdır.\n *   (2) Eğer y, M'nin bir elemanıysa, o zaman hem (2y + 1) hem de (3y + 1) M'nin elemanıdır.\n *   (3) Yukarıdaki kurallarla üretilenler dışında M'de başka eleman yoktur.\n * \n * Örnek:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "vi": "/**\n * Xác định liệu một số x cho trước có phải là một phần tử của tập hợp M được tạo ra từ một số bắt đầu k hay không.\n * Tập hợp M được tạo ra như sau:\n *   (1) k là một phần tử của M.\n *   (2) Nếu y là một phần tử của M, thì cả (2y + 1) và (3y + 1) đều là phần tử của M.\n *   (3) Không có phần tử nào khác trong M ngoại trừ những phần tử được tạo ra bởi các quy tắc trên.\n * \n * Ví dụ:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String "
    },
    "prompt_bertscore": {
      "es": "0.9840458091648967",
      "arb": "0.9866186684904417",
      "sw": "0.9896539393430358",
      "tr": "0.9910290574709403",
      "vi": "0.9896646653836116"
    },
    "canonical_solution": "{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}",
    "instruction": {
      "en": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Kotlin en español usando un máximo de 500 caracteres.",
      "arb": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9255475729070739",
      "sw": "0.912915077934017",
      "tr": "0.9349461666465017",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(isElementOfGeneratedSet(0, 22) == \"YES\")\n    check(isElementOfGeneratedSet(1, 10) == \"YES\")\n    check(isElementOfGeneratedSet(2, 13) == \"NO\")\n    check(isElementOfGeneratedSet(3, 30) == \"NO\")\n}\n\n\nmain()",
    "entry_point": "isElementOfGeneratedSet",
    "signature": "fun isElementOfGeneratedSet(k: Int, x: Int): String",
    "docstring": {
      "en": "Determines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "es": "Determina si un número dado x es un elemento de un conjunto M generado a partir de un número inicial k.  \nEl conjunto M se genera de la siguiente manera:  \n(1) k es un elemento de M.  \n(2) Si y es un elemento de M, entonces tanto (2y + 1) como (3y + 1) son elementos de M.  \n(3) No hay otros elementos en M excepto aquellos generados por las reglas anteriores.  \n\nEjemplo:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "arb": "يحدد ما إذا كان الرقم المعطى x عنصرًا في المجموعة M المولدة من رقم بداية k.  \nيتم توليد المجموعة M كما يلي:  \n(1) k هو عنصر في M.  \n(2) إذا كان y عنصرًا في M، فإن كلا من (2y + 1) و (3y + 1) هما عنصران في M.  \n(3) لا توجد عناصر أخرى في M باستثناء تلك التي تم توليدها بواسطة القواعد المذكورة أعلاه.\n\nمثال:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "sw": "Inabainisha kama nambari fulani x ni kipengele cha seti M inayozalishwa kutoka kwa nambari ya kuanzia k.  \nSeti M inazalishwa kama ifuatavyo:  \n(1) k ni kipengele cha M.  \n(2) Ikiwa y ni kipengele cha M, basi (2y + 1) na (3y + 1) zote ni vipengele vya M.  \n(3) Hakuna vipengele vingine katika M isipokuwa vile vilivyozalishwa na sheria zilizo hapo juu.  \n\nMfano:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "tr": "Verilen bir sayı x'in, k başlangıç sayısından üretilen bir M kümesinin elemanı olup olmadığını belirler.\nKüme M şu şekilde üretilir:\n(1) k, M'nin bir elemanıdır.\n(2) Eğer y, M'nin bir elemanı ise, o zaman hem (2y + 1) hem de (3y + 1) M'nin elemanlarıdır.\n(3) Yukarıdaki kurallarla üretilenler dışında M'de başka eleman yoktur.\n\nÖrnek:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "vi": "Xác định liệu một số x cho trước có phải là một phần tử của tập hợp M được tạo ra từ một số bắt đầu k hay không.  \nTập hợp M được tạo ra như sau:  \n(1) k là một phần tử của M.  \n(2) Nếu y là một phần tử của M, thì cả (2y + 1) và (3y + 1) đều là phần tử của M.  \n(3) Không có phần tử nào khác trong M ngoại trừ những phần tử được tạo ra bởi các quy tắc trên.  \n\nVí dụ:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  "
    },
    "docstring_bertscore": {
      "es": "0.9838153979228963",
      "arb": "0.9790518441249176",
      "sw": "0.983085034011831",
      "tr": "0.987821375447608",
      "vi": "0.9857774688267589"
    }
  },
  {
    "task_id": "Kotlin/40",
    "prompt": {
      "en": "/**\n    * Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\n    * The input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\n    * The function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\n    Example:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "es": "/**\n    * Encuentra el autor que ha publicado más libros y devuelve la inicial del autor junto con los IDs de los libros a los que ha contribuido.\n    * La entrada es una lista de pares, donde cada par consiste en un ID de libro (Int) y una cadena de letras mayúsculas únicas que representan a los autores.\n    * La función devuelve un par con la inicial del autor más publicado (Char) y una lista de IDs de libros (List<Int>) a los que ha contribuido.\n    Ejemplo:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "arb": "/**\n    * العثور على المؤلف الذي نشر أكبر عدد من الكتب وإرجاع الحرف الأول من اسم المؤلف مع معرفات الكتب التي ساهم فيها.\n    * المدخل هو قائمة من الأزواج، حيث يتكون كل زوج من معرف كتاب (Int) وسلسلة من الأحرف الكبيرة الفريدة التي تمثل المؤلفين.\n    * تُرجع الدالة زوجًا مع الحرف الأول للمؤلف الأكثر نشرًا (Char) وقائمة بمعرفات الكتب (List<Int>) التي ساهم فيها.\n    مثال:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "sw": "/**\n    * Pata mwandishi ambaye amechapisha vitabu vingi zaidi na urejeshe herufi ya kwanza ya mwandishi pamoja na vitambulisho vya vitabu walivyoshiriki.\n    * Ingizo ni orodha ya jozi, ambapo kila jozi inajumuisha kitambulisho cha kitabu (Int) na mfuatano wa herufi kubwa za kipekee zinazowakilisha waandishi.\n    * Kazi inarejesha jozi yenye herufi ya kwanza ya mwandishi aliyechapisha zaidi (Char) na orodha ya vitambulisho vya vitabu (List<Int>) walivyoshiriki.\n    Mfano:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "tr": "/**\n    * En çok kitap yayımlamış olan yazarı bulun ve yazarın baş harfi ile katkıda bulunduğu kitapların kimliklerini döndürün.\n    * Girdi, her biri bir kitap kimliği (Int) ve yazarları temsil eden benzersiz büyük harflerden oluşan bir dize içeren çiftlerden oluşan bir listedir.\n    * Fonksiyon, en çok yayımlanmış yazarın baş harfi (Char) ve katkıda bulunduğu kitap kimliklerinin bir listesini (List<Int>) içeren bir çift döndürür.\n    Örnek:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "vi": "/**\n    * Tìm tác giả đã xuất bản nhiều sách nhất và trả về chữ cái đầu của tác giả cùng với các ID của sách mà họ đã đóng góp.\n    * Đầu vào là một danh sách các cặp, trong đó mỗi cặp bao gồm một ID sách (Int) và một chuỗi các chữ cái in hoa duy nhất đại diện cho các tác giả.\n    * Hàm trả về một cặp với chữ cái đầu của tác giả xuất bản nhiều nhất (Char) và một danh sách các ID sách (List<Int>) mà họ đã đóng góp.\n    Ví dụ:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> "
    },
    "prompt_bertscore": {
      "es": "0.9797673107574053",
      "arb": "0.9627194610443239",
      "sw": "0.9698298327942299",
      "tr": "0.9792272347513714",
      "vi": "0.9836958224335133"
    },
    "canonical_solution": "{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}",
    "instruction": {
      "en": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود Kotlin باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9217428079583506",
      "sw": "0.9437925679266526",
      "tr": "0.8945846718505934",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"HF\"))) == Pair('F', listOf(307,895)))\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"H\"), Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\"), Pair(834, \"BXPRD\"), Pair(872, \"LJU\"), Pair(791, \"BPJWIA\"), Pair(580, \"AGMVY\"), Pair(619, \"NAFL\"), Pair(233, \"PDJWXK\"))) == Pair('P', listOf(410,567,822,834,791,233)))\n\n \n}\nmain()",
    "entry_point": "findMostPublishedAuthor",
    "signature": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>",
    "docstring": {
      "en": "Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "es": "Encuentra al autor que ha publicado más libros y devuelve la inicial del autor junto con los IDs de los libros a los que ha contribuido.\nLa entrada es una lista de pares, donde cada par consta de un ID de libro (Int) y una cadena de letras mayúsculas únicas que representan a los autores.\nLa función devuelve un par con la inicial del autor más publicado (Char) y una lista de IDs de libros (List<Int>) a los que ha contribuido.\nEjemplo:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "arb": "ابحث عن المؤلف الذي نشر أكبر عدد من الكتب وأعد الأحرف الأولى للمؤلف مع معرفات الكتب التي ساهموا فيها.  \nالإدخال هو قائمة من الأزواج، حيث يتكون كل زوج من معرف كتاب (Int) وسلسلة من الأحرف الكبيرة الفريدة التي تمثل المؤلفين.  \nتعيد الدالة زوجًا مع الحرف الأول للمؤلف الأكثر نشرًا (Char) وقائمة بمعرفات الكتب (List<Int>) التي ساهموا فيها.  \nمثال:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "sw": "Tafuta mwandishi ambaye amechapisha vitabu vingi zaidi na urejeshe herufi ya kwanza ya mwandishi huyo pamoja na vitambulisho vya vitabu walivyoshiriki.\nIngizo ni orodha ya jozi, ambapo kila jozi inajumuisha kitambulisho cha kitabu (Int) na mfuatano wa herufi kubwa za kipekee zinazowakilisha waandishi.\nKazi inarejesha jozi yenye herufi ya kwanza ya mwandishi aliyechapisha zaidi (Char) na orodha ya vitambulisho vya vitabu (List<Int>) walivyoshiriki.\nMfano:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "tr": "En çok kitap yayımlayan yazarı bulun ve yazarın baş harfi ile katkıda bulundukları kitapların kimliklerini döndürün.\nGirdi, her biri bir kitap kimliği (Int) ve yazarları temsil eden benzersiz büyük harflerden oluşan bir dize içeren çiftlerden oluşan bir listedir.\nFonksiyon, en çok yayımlanan yazarın baş harfi (Char) ve katkıda bulundukları kitap kimliklerinin bir listesini (List<Int>) içeren bir çift döndürür.\nÖrnek:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "vi": "Tìm tác giả đã xuất bản nhiều sách nhất và trả về ký tự đầu của tác giả cùng với các ID của sách mà họ đã đóng góp.\nĐầu vào là một danh sách các cặp, trong đó mỗi cặp bao gồm một ID sách (Int) và một chuỗi các chữ cái viết hoa duy nhất đại diện cho các tác giả.\nHàm trả về một cặp với ký tự đầu của tác giả xuất bản nhiều nhất (Char) và một danh sách các ID sách (List<Int>) mà họ đã đóng góp.\nVí dụ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))"
    },
    "docstring_bertscore": {
      "es": "0.9794143445703063",
      "arb": "0.97081642989683",
      "sw": "0.964046709250399",
      "tr": "0.9754751068536224",
      "vi": "0.9794497007781304"
    }
  },
  {
    "task_id": "Kotlin/41",
    "prompt": {
      "en": "/**\n * Counts the number of pairs of students who are considered \"equal competitors\".\n * Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n * is not greater than 5, and the difference in their total scores is not greater than 10.\n * \n * @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n * @return The number of pairs of students who are considered equal competitors.\n * \n * Example:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "es": "/**\n * Cuenta el número de pares de estudiantes que se consideran \"competidores iguales\".\n * Se considera que dos estudiantes son competidores iguales si la diferencia en sus puntuaciones para cada materia (Matemáticas, Inglés y Chino)\n * no es mayor que 5, y la diferencia en sus puntuaciones totales no es mayor que 10.\n * \n * @param scores Una lista de tríos, cada uno representando las puntuaciones de Matemáticas, Inglés y Chino de un estudiante.\n * @return El número de pares de estudiantes que se consideran competidores iguales.\n * \n * Ejemplo:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "arb": "/**\n * يحسب عدد أزواج الطلاب الذين يُعتبرون \"متنافسين متساوين\".\n * يُعتبر طالبان متنافسين متساوين إذا كان الفرق في درجاتهم لكل مادة (الرياضيات، الإنجليزية، والصينية)\n * لا يزيد عن 5، والفرق في مجموع درجاتهم لا يزيد عن 10.\n * \n * @param scores قائمة من الثلاثيات، كل منها تمثل درجات الرياضيات، الإنجليزية، والصينية لطالب.\n * @return عدد أزواج الطلاب الذين يُعتبرون متنافسين متساوين.\n * \n * مثال:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */ \n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "sw": "/**\n * Inahesabu idadi ya wanandoa wa wanafunzi ambao wanachukuliwa kama \"washindani sawa\".\n * Wanafunzi wawili wanachukuliwa kuwa washindani sawa ikiwa tofauti katika alama zao kwa kila somo (Hisabati, Kiingereza, na Kichina)\n * sio kubwa zaidi ya 5, na tofauti katika jumla ya alama zao sio kubwa zaidi ya 10.\n * \n * @param scores Orodha ya matatu, kila moja ikiwakilisha alama za Hisabati, Kiingereza, na Kichina za mwanafunzi.\n * @return Idadi ya wanandoa wa wanafunzi ambao wanachukuliwa kuwa washindani sawa.\n * \n * Mfano:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "tr": "/**\n * \"Eşit rakipler\" olarak kabul edilen öğrenci çiftlerinin sayısını sayar.\n * İki öğrenci, her bir ders (Matematik, İngilizce ve Çince) için puanlarındaki fark 5'ten büyük değilse\n * ve toplam puanlarındaki fark 10'dan büyük değilse eşit rakipler olarak kabul edilir.\n * \n * @param scores Her biri bir öğrencinin Matematik, İngilizce ve Çince puanlarını temsil eden üçlülerin bir listesi.\n * @return Eşit rakipler olarak kabul edilen öğrenci çiftlerinin sayısı.\n * \n * Örnek:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */ \n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "vi": "/**\n * Đếm số cặp học sinh được coi là \"đối thủ ngang tài\".\n * Hai học sinh được coi là đối thủ ngang tài nếu chênh lệch điểm số của họ cho mỗi môn học (Toán, Anh, và Trung)\n * không lớn hơn 5, và chênh lệch tổng điểm của họ không lớn hơn 10.\n * \n * @param scores Một danh sách các bộ ba, mỗi bộ đại diện cho điểm Toán, Anh, và Trung của một học sinh.\n * @return Số cặp học sinh được coi là đối thủ ngang tài.\n * \n * Ví dụ:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */ \n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int "
    },
    "prompt_bertscore": {
      "es": "0.9862492159817168",
      "arb": "0.9872723610744275",
      "sw": "0.9802855374215252",
      "tr": "0.9733710152273198",
      "vi": "0.9836924457170357"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}",
    "instruction": {
      "en": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nKotlin kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9074996192254818",
      "sw": "0.9437925679266526",
      "tr": "0.8650487314514677",
      "vi": "0.9053631508470706"
    },
    "level": "",
    "test": "fun main() {\n    check(countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91))) == 2)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(92, 93, 95), Triple(101, 102, 103))) == 1)\n    check(countEqualCompetitors(listOf(Triple(90, 91, 92), Triple(86, 87, 88), Triple(93, 94, 95))) == 1)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(105, 105, 105), Triple(100, 100, 100))) == 1)\n}\n\n\nmain()",
    "entry_point": "countEqualCompetitors",
    "signature": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "es": "Cuenta el número de pares de estudiantes que se consideran \"competidores iguales\".\n  Se considera que dos estudiantes son competidores iguales si la diferencia en sus puntuaciones para cada materia (Matemáticas, Inglés y Chino)\n  no es mayor que 5, y la diferencia en sus puntuaciones totales no es mayor que 10.\n  \n  @param scores Una lista de tríos, cada uno representando las puntuaciones de Matemáticas, Inglés y Chino de un estudiante.\n  @return El número de pares de estudiantes que se consideran competidores iguales.\n  \n  Ejemplo:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "arb": "يحسب عدد أزواج الطلاب الذين يعتبرون \"متنافسين متساوين\".\nيعتبر طالبان متنافسين متساوين إذا كان الفرق في درجاتهم لكل مادة (الرياضيات، الإنجليزية، والصينية)\nلا يزيد عن 5، والفرق في مجموع درجاتهم لا يزيد عن 10.\n\n@param scores قائمة من الثلاثيات، كل منها يمثل درجات الرياضيات، الإنجليزية، والصينية لطالب.\n@return عدد أزواج الطلاب الذين يعتبرون متنافسين متساوين.\n\nمثال:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "sw": "Hesabu idadi ya wanandoa wa wanafunzi wanaochukuliwa kuwa \"washindani sawa\".\n  Wanafunzi wawili wanachukuliwa kuwa washindani sawa ikiwa tofauti katika alama zao kwa kila somo (Hisabati, Kiingereza, na Kichina)\n  sio kubwa kuliko 5, na tofauti katika jumla ya alama zao sio kubwa kuliko 10.\n  \n  @param scores Orodha ya tatu, kila moja ikiwakilisha alama za Hisabati, Kiingereza, na Kichina za mwanafunzi.\n  @return Idadi ya wanandoa wa wanafunzi wanaochukuliwa kuwa washindani sawa.\n  \n  Mfano:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "tr": "Öğrencilerin \"eşit rakip\" olarak kabul edildiği çiftlerin sayısını sayar.\n  İki öğrenci, her bir ders (Matematik, İngilizce ve Çince) için puanlarındaki fark 5'ten büyük değilse\n  ve toplam puanlarındaki fark 10'dan büyük değilse eşit rakip olarak kabul edilir.\n  \n  @param scores Her biri bir öğrencinin Matematik, İngilizce ve Çince puanlarını temsil eden üçlülerin listesi.\n  @return Eşit rakip olarak kabul edilen öğrenci çiftlerinin sayısı.\n  \n  Örnek:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "vi": "Đếm số cặp học sinh được coi là \"đối thủ ngang tài ngang sức\".  \nHai học sinh được coi là đối thủ ngang tài ngang sức nếu chênh lệch điểm số của họ cho mỗi môn học (Toán, Tiếng Anh và Tiếng Trung) không lớn hơn 5, và chênh lệch tổng điểm của họ không lớn hơn 10.\n\n@param scores Một danh sách các bộ ba, mỗi bộ đại diện cho điểm Toán, Tiếng Anh và Tiếng Trung của một học sinh.\n@return Số cặp học sinh được coi là đối thủ ngang tài ngang sức.\n\nVí dụ:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9801111399469766",
      "arb": "0.974721105927214",
      "sw": "0.9727850556032669",
      "tr": "0.9777458493696132",
      "vi": "0.973178542388097"
    }
  },
  {
    "task_id": "Kotlin/42",
    "prompt": {
      "en": "/**\n * Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n * Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n * \n * Example:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "es": "/**\n * Calcular el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una proporción de colillas de cigarrillos por cigarrillos nuevos.\n * Peter guarda las colillas de los cigarrillos fumados y las intercambia por nuevos a una tasa dada.\n * \n * Ejemplo:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "arb": "/**\n * حساب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى عدد السجائر الأولي ونسبة أعقاب السجائر إلى السجائر الجديدة.\n * يقوم بيتر بحفظ أعقاب السجائر المدخنة ويستبدلها بأخرى جديدة بمعدل معين.\n * \n * مثال:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "sw": "/**\n * Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali ya sigara na uwiano wa vipande vya sigara kwa sigara mpya.\n * Peter huokoa vipande vya sigara zilizovutwa na kubadilisha kwa sigara mpya kwa kiwango kilichopewa.\n * \n * Mfano:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int",
      "tr": "/**\n * Peter'in, başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara oranı verildiğinde, toplam kaç sigara içebileceğini hesapla.\n * Peter, içilen sigaralardan izmaritleri biriktirir ve bunları belirli bir oranda yenileriyle değiştirir.\n * \n * Örnek:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "vi": "/**\n * Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng điếu thuốc ban đầu và tỷ lệ đầu mẩu thuốc đổi lấy điếu thuốc mới.\n * Peter giữ lại đầu mẩu từ những điếu thuốc đã hút và đổi chúng lấy những điếu mới theo tỷ lệ cho trước.\n * \n * Ví dụ:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9832010341543553",
      "arb": "0.9831370751716622",
      "sw": "0.9661917187351948",
      "tr": "0.970070175555282",
      "vi": "0.9471520035610956"
    },
    "canonical_solution": "{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}",
    "instruction": {
      "en": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8953293371490932",
      "sw": "0.9437925679266526",
      "tr": "0.9349461666465017",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    check(totalCigarettesSmoked(4, 3) == 5)\n    check(totalCigarettesSmoked(10, 3) == 14)\n    check(totalCigarettesSmoked(1, 2) == 1) // Edge case: Not enough cigarettes to exchange\n    check(totalCigarettesSmoked(20, 5) == 24) // More cigarettes, different exchange rate\n}\n\nmain()",
    "entry_point": "totalCigarettesSmoked",
    "signature": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int",
    "docstring": {
      "en": "Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "es": "Calcular el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una proporción de colillas de cigarrillos a cigarrillos nuevos. \n  Peter guarda las colillas de los cigarrillos fumados y las intercambia por nuevos a una tasa dada.\n  \n  Ejemplo:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "arb": "احسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى عدد أولي من السجائر ونسبة أعقاب السجائر إلى السجائر الجديدة.  \n  يحتفظ بيتر بأعقاب السجائر المدخنة ويستبدلها بأخرى جديدة بمعدل معين.\n  \n  مثال:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali ya sigara na uwiano wa vipande vya sigara hadi sigara mpya. \n  Peter huokoa vipande vya sigara alizovuta na kuzibadilisha kwa sigara mpya kwa kiwango kilichopewa.\n  \n  Mfano:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "tr": "Peter'in başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara dönüşme oranı verildiğinde, toplam kaç sigara içebileceğini hesaplayın. \nPeter, içilen sigaralardan kalan izmaritleri biriktirir ve bunları belirli bir oranda yeni sigaralarla değiştirir.\n\nÖrnek:\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng thuốc ban đầu và tỷ lệ đổi đầu lọc thuốc lá thành thuốc mới. \n  Peter giữ lại đầu lọc từ các điếu thuốc đã hút và đổi chúng lấy thuốc mới theo một tỷ lệ nhất định.\n  \n  Ví dụ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14"
    },
    "docstring_bertscore": {
      "es": "0.9840402475142278",
      "arb": "0.9552934656189536",
      "sw": "0.9538023473485246",
      "tr": "0.8834883842444604",
      "vi": "0.9301013730226797"
    }
  },
  {
    "task_id": "Kotlin/43",
    "prompt": {
      "en": "/**\n * Finds the length of the longest consecutive sequence in a given list of integers.\n * Consecutive sequence means numbers that come sequentially without any gap.\n * \n * Example:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "es": "/**\n * Encuentra la longitud de la secuencia consecutiva más larga en una lista dada de enteros.\n * Secuencia consecutiva significa números que vienen secuencialmente sin ningún hueco.\n * \n * Ejemplo:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "arb": "/**\n * يجد طول أطول تسلسل متتالي في قائمة معينة من الأعداد الصحيحة.\n * التسلسل المتتالي يعني الأرقام التي تأتي بشكل متتابع بدون أي فجوة.\n * \n * مثال:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "sw": "/**\n * Inapata urefu wa mlolongo mrefu zaidi wa namba mfululizo katika orodha iliyotolewa ya namba za mzima.\n * Mlolongo mfululizo unamaanisha namba zinazokuja mfululizo bila pengo lolote.\n * \n * Mfano:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "tr": "/**\n * Verilen bir tamsayı listesindeki en uzun ardışık dizinin uzunluğunu bulur.\n * Ardışık dizi, arada boşluk olmadan sıralı gelen sayılar anlamına gelir.\n * \n * Örnek:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "vi": "/**\n * Tìm độ dài của dãy số liên tiếp dài nhất trong một danh sách số nguyên cho trước.\n * Dãy số liên tiếp có nghĩa là các số đến liên tiếp mà không có khoảng cách.\n * \n * Ví dụ:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int "
    },
    "prompt_bertscore": {
      "es": "0.9944876096655197",
      "arb": "0.9920440587180286",
      "sw": "0.983836055482524",
      "tr": "0.975233969571046",
      "vi": "0.9620075697586948"
    },
    "canonical_solution": "{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}",
    "instruction": {
      "en": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nAşağıdaki Kotlin kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9274963355754072",
      "sw": "0.918038549982431",
      "tr": "0.8454687416409535",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9)) == 6)\n    check(longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2)) == 4)\n    check(longestConsecutiveSequence(listOf(1, 2, 3, 4, 5, 6)) == 6)\n    check(longestConsecutiveSequence(listOf(100, 4, 200, 1, 3, 2)) == 4)\n}\n\n\nmain()",
    "entry_point": "longestConsecutiveSequence",
    "signature": "fun longestConsecutiveSequence(numbers: List<Int>): Int",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga en una lista dada de enteros.\n  Secuencia consecutiva significa números que vienen secuencialmente sin ningún hueco.\n  \n  Ejemplo:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "arb": "يجد طول أطول تسلسل متتابع في قائمة الأعداد الصحيحة المعطاة.\n  التسلسل المتتابع يعني الأرقام التي تأتي بشكل متسلسل دون أي فجوة.\n  \n  مثال:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa namba zinazofuatana katika orodha iliyotolewa ya namba nzima.\n  Mlolongo wa namba zinazofuatana unamaanisha namba zinazokuja mfululizo bila pengo lolote.\n  \n  Mfano:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "tr": "Verilen bir tamsayı listesindeki en uzun ardışık dizinin uzunluğunu bulur.  \nArdışık dizi, arada boşluk olmadan sıralı gelen sayılar anlamına gelir.\n\nÖrnek:\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong một danh sách số nguyên cho trước.  \nDãy số liên tiếp có nghĩa là các số đến liên tục mà không có khoảng cách nào.\n\nVí dụ:\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4"
    },
    "docstring_bertscore": {
      "es": "0.9925922785696849",
      "arb": "0.9869221757126629",
      "sw": "0.9563253504484298",
      "tr": "0.91008459500427",
      "vi": "0.9574283449543165"
    }
  },
  {
    "task_id": "Kotlin/44",
    "prompt": {
      "en": "/**\n * Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n * Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n * \n * Example:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "es": "/**\n * Compara el área de un cuadrado con lado de longitud 'a' con el área de un rectángulo con lados 'b' y 'c'.\n * Devuelve \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n * \n * Ejemplo:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "arb": "/**\n * يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.\n * يعيد \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n * \n * مثال:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "sw": "/**\n * Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n * Inarudisha \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n * \n * Mfano:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "tr": "/**\n * 'a' kenar uzunluğuna sahip bir karenin alanını, 'b' ve 'c' kenarlarına sahip bir dikdörtgenin alanı ile karşılaştırır.\n * Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" döner.\n * \n * Örnek:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "vi": "/**\n * So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'.\n * Trả về \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n * \n * Ví dụ:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String "
    },
    "prompt_bertscore": {
      "es": "0.9957632139725259",
      "arb": "0.9992646703294088",
      "sw": "1",
      "tr": "0.9966405643655569",
      "vi": "0.9922329562103928"
    },
    "canonical_solution": "{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}",
    "instruction": {
      "en": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nAşağıdaki Kotlin kodunun Türkçe dilinde, en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8796681261260164",
      "sw": "0.918038549982431",
      "tr": "0.8803680995887834",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(compareAreas(5, 4, 6) == \"Alice\")\n    check(compareAreas(7, 5, 10) == \"Bob\")\n    // Additional test cases for edge cases\n    check(compareAreas(1, 1, 1) == \"Bob\") // Edge case where all sides are equal\n    check(compareAreas(10, 5, 20) == \"Bob\") // Test case where rectangle is clearly larger\n}\n\n\nmain()",
    "entry_point": "compareAreas",
    "signature": "fun compareAreas(a: Int, b: Int, c: Int): String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "es": "Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'. Devuelve \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n\n  Ejemplo:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "arb": "يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.  \nيعيد \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n\nمثال:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "sw": "Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'. \nInarejesha \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n\nMfano:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "tr": "Karenin kenar uzunluğu 'a' olan bir karenin alanını, kenarları 'b' ve 'c' olan bir dikdörtgenin alanı ile karşılaştırır. Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" döner.\n\nÖrnek:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "vi": "So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật có các cạnh 'b' và 'c'. Trả về \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n\n  Ví dụ:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9799381328850952",
      "arb": "0.9984945803421366",
      "sw": "1",
      "tr": "0.9337712679426803",
      "vi": "0.9848826389601967"
    }
  },
  {
    "task_id": "Kotlin/45",
    "prompt": {
      "en": "\n/**\n    * Finds M positive integers whose sum is N and their product is as large as possible.\n    * Outputs the lexicographically smallest sequence of these M integers.\n    * \n    * Example:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "es": "/**\n    * Encuentra M enteros positivos cuya suma es N y cuyo producto es lo más grande posible.\n    * Devuelve la secuencia lexicográficamente más pequeña de estos M enteros.\n    * \n    * Ejemplo:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "arb": "/**\n    * يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ويكون حاصل ضربها أكبر ما يمكن.\n    * يُخرج التسلسل الأصغر لغويًا لهذه الأعداد M.\n    * \n    * مثال:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "sw": "/**\n    * Inapata nambari M zisizo hasi ambazo jumla yake ni N na bidhaa yao ni kubwa iwezekanavyo.\n    * Inatoa mlolongo mdogo zaidi wa leksikografia wa hizi nambari M.\n    * \n    * Mfano:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "tr": "/**\n    * Toplamı N olan ve çarpımları mümkün olduğunca büyük olan M pozitif tam sayı bulur.\n    * Bu M tam sayının sözlük sıralamasına göre en küçük dizisini çıktılar.\n    * \n    * Örnek:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "vi": "/**\n    * Tìm M số nguyên dương có tổng là N và tích của chúng là lớn nhất có thể.\n    * Xuất ra dãy số nhỏ nhất theo thứ tự từ điển của M số nguyên này.\n    * \n    * Ví dụ:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9792429265514732",
      "arb": "0.9668688497041428",
      "sw": "0.964809449913573",
      "tr": "0.9792568306781456",
      "vi": "0.9690815921488714"
    },
    "canonical_solution": "{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}",
    "instruction": {
      "en": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9255475729070739",
      "sw": "0.9437925679266526",
      "tr": "0.9349461666465017",
      "vi": "0.9422627167319219"
    },
    "level": "",
    "test": "fun main() {\n    check(maxProductPartition(6, 3) == listOf(2, 2, 2))\n    check(maxProductPartition(8, 3) == listOf(2, 3, 3))\n    check(maxProductPartition(10, 2) == listOf(5, 5))\n    check(maxProductPartition(7, 3) == listOf(2, 2, 3))\n}\n\nmain()",
    "entry_point": "maxProductPartition",
    "signature": "fun maxProductPartition(N: Int, M: Int): List<Int>",
    "docstring": {
      "en": "Finds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "es": "Encuentra M enteros positivos cuya suma es N y cuyo producto es lo más grande posible.     \n     Devuelve la secuencia lexicográficamente más pequeña de estos M enteros.\n     \n     Ejemplo:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "arb": "يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ويكون حاصل ضربها كبيرًا قدر الإمكان.  \n     يُخرج التسلسل الأصغر لغويًا لهذه الأعداد M.\n     \n     مثال:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "sw": "Inapata nambari kamili za M ambazo jumla yake ni N na bidhaa yao ni kubwa iwezekanavyo. \n     Inatoa mlolongo mdogo zaidi wa leksikografia wa nambari hizi M.\n     \n     Mfano:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "tr": "M pozitif tamsayısının toplamı N olan ve çarpımları mümkün olduğunca büyük olan sayıları bulur.\n     Bu M tamsayısının leksikografik olarak en küçük dizisini çıktılar.\n     \n     Örnek:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "vi": "Tìm M số nguyên dương có tổng là N và tích của chúng là lớn nhất có thể. \n     Xuất ra dãy số nhỏ nhất theo thứ tự từ điển của M số nguyên này.\n     \n     Ví dụ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9681224060388539",
      "arb": "0.9761472720630444",
      "sw": "0.939149582769962",
      "tr": "0.9471130720064127",
      "vi": "0.9504665487294247"
    }
  },
  {
    "task_id": "Kotlin/46",
    "prompt": {
      "en": "/**\n * Calculates the number of characters in the essay title, excluding spaces and newline characters.\n * \n * Example:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.\n */\nfun countTitleCharacters(title: String): Int ",
      "es": "/**\n * Calcula el número de caracteres en el título del ensayo, excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * La función cuenta letras mayúsculas y minúsculas en inglés, dígitos, pero ignora espacios y caracteres de nueva línea.\n */\nfun countTitleCharacters(title: String): Int ",
      "arb": "/**\n * يحسب عدد الأحرف في عنوان المقالة، باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * تقوم الدالة بحساب الأحرف الإنجليزية الكبيرة والصغيرة، والأرقام، لكنها تتجاهل المسافات وأحرف السطر الجديد.\n */\nfun countTitleCharacters(title: String): Int ",
      "sw": "/**\n * Inahesabu idadi ya herufi katika kichwa cha insha, bila kujumuisha nafasi na herufi mpya.\n * \n * Mfano:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Kazi hii inahesabu herufi kubwa na ndogo za Kiingereza, tarakimu, lakini inapuuzia nafasi na herufi mpya.\n */\nfun countTitleCharacters(title: String): Int ",
      "tr": "/**\n * Makale başlığındaki karakter sayısını, boşluk ve yeni satır karakterleri hariç, hesaplar.\n * \n * Örnek:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Fonksiyon büyük ve küçük harf İngilizce harfleri, rakamları sayar, ancak boşluk ve yeni satır karakterlerini görmezden gelir.\n */\nfun countTitleCharacters(title: String): Int ",
      "vi": "/**\n * Tính số ký tự trong tiêu đề bài luận, không bao gồm khoảng trắng và ký tự xuống dòng.\n * \n * Ví dụ:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Hàm đếm các chữ cái tiếng Anh viết hoa và viết thường, chữ số, nhưng bỏ qua khoảng trắng và ký tự xuống dòng.\n */\nfun countTitleCharacters(title: String): Int "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.982390423569352",
      "sw": "0.9769835059672013",
      "tr": "0.982390423569352",
      "vi": "0.998673149054687"
    },
    "canonical_solution": "{\n    return title.count { it != ' ' && it != '\\n' }\n}",
    "instruction": {
      "en": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.912915077934017",
      "tr": "0.9518293517737051",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(countTitleCharacters(\"234\") == 3)\n    check(countTitleCharacters(\"Ca\\n45\") == 4)\n    check(countTitleCharacters(\"Hello, World!\") == 12) // Assuming \",\" is considered a valid character\n    check(countTitleCharacters(\"A B C D E\") == 5)\n    check(countTitleCharacters(\"\\n\\n\\n\\n\") == 0)\n}\n\n\nmain()",
    "entry_point": "countTitleCharacters",
    "signature": "fun countTitleCharacters(title: String): Int",
    "docstring": {
      "en": "Calculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.",
      "es": "Calcula el número de caracteres en el título del ensayo, excluyendo espacios y caracteres de nueva línea.\n\n  Ejemplo:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  La función cuenta letras inglesas mayúsculas y minúsculas, dígitos, pero ignora espacios y caracteres de nueva línea.",
      "arb": "يحسب عدد الأحرف في عنوان المقال، باستثناء المسافات وأحرف السطر الجديد.\n\nمثال:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nتقوم الدالة بحساب الأحرف الإنجليزية الكبيرة والصغيرة، والأرقام، لكنها تتجاهل المسافات وأحرف السطر الجديد.",
      "sw": "Hesabu idadi ya herufi katika kichwa cha insha, ukiondoa nafasi na herufi mpya.\n\nMfano:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nKazi hii inahesabu herufi kubwa na ndogo za Kiingereza, nambari, lakini inapuuzia nafasi na herufi mpya.",
      "tr": "Karakter sayısını boşluklar ve yeni satır karakterleri hariç tutarak deneme başlığında hesaplar.\n\n  Örnek:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n\n  Fonksiyon büyük ve küçük İngilizce harfleri, rakamları sayar, ancak boşlukları ve yeni satır karakterlerini görmezden gelir.",
      "vi": "Tính số ký tự trong tiêu đề bài luận, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Hàm này đếm các chữ cái tiếng Anh viết hoa và viết thường, chữ số, nhưng bỏ qua khoảng trắng và ký tự xuống dòng."
    },
    "docstring_bertscore": {
      "es": "0.9956404603970462",
      "arb": "0.975797483962042",
      "sw": "0.9446111237268973",
      "tr": "0.9536382786537898",
      "vi": "0.9823089851131277"
    }
  },
  {
    "task_id": "Kotlin/47",
    "prompt": {
      "en": "/**\n * Counts the number of students who have enrolled in both courses A and B.\n * The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n * and the second list contains the IDs of students enrolled in course B.\n * \n * Example:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "es": "/**\n * Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n * La función toma dos listas como argumentos: la primera lista contiene los IDs de los estudiantes inscritos en el curso A,\n * y la segunda lista contiene los IDs de los estudiantes inscritos en el curso B.\n * \n * Ejemplo:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "arb": "/**\n * يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.\n * تأخذ الدالة قائمتين كوسيطات: تحتوي القائمة الأولى على معرفات الطلاب المسجلين في الدورة A،\n * وتحتوي القائمة الثانية على معرفات الطلاب المسجلين في الدورة B.\n * \n * مثال:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "sw": "/**\n * Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B.\n * Kazi hii inachukua orodha mbili kama hoja: orodha ya kwanza ina vitambulisho vya wanafunzi waliojiandikisha katika kozi A,\n * na orodha ya pili ina vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n * \n * Mfano:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "tr": "/**\n * Hem A hem de B derslerine kaydolmuş olan öğrencilerin sayısını sayar.\n * Fonksiyon iki listeyi argüman olarak alır: ilk liste A dersine kayıtlı öğrencilerin kimliklerini içerir,\n * ve ikinci liste B dersine kayıtlı öğrencilerin kimliklerini içerir.\n * \n * Örnek:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "vi": "/**\n * Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.\n * Hàm nhận hai danh sách làm đối số: danh sách đầu tiên chứa ID của sinh viên đã đăng ký khóa học A,\n * và danh sách thứ hai chứa ID của sinh viên đã đăng ký khóa học B.\n * \n * Ví dụ:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int "
    },
    "prompt_bertscore": {
      "es": "0.9935449098771282",
      "arb": "0.9849076663882071",
      "sw": "0.9924542304548656",
      "tr": "0.9910801054788663",
      "vi": "0.9750085240885714"
    },
    "canonical_solution": "{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}",
    "instruction": {
      "en": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9255475729070739",
      "sw": "0.9437925679266526",
      "tr": "0.9455540221456699",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    check(countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6)) == 4)\n    check(countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14)) == 1)\n    check(countCommonStudents(listOf(1, 2, 3), listOf(4, 5, 6)) == 0)\n    check(countCommonStudents(listOf(1, 2, 3, 4), listOf(2, 4)) == 2)\n}\n\n\nmain()",
    "entry_point": "countCommonStudents",
    "signature": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "es": "Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.  \nLa función toma dos listas como argumentos: la primera lista contiene los IDs de los estudiantes inscritos en el curso A,  \ny la segunda lista contiene los IDs de los estudiantes inscritos en el curso B.\n\nEjemplo:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "arb": "يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.  \nتأخذ الدالة قائمتين كوسيطين: تحتوي القائمة الأولى على معرفات الطلاب المسجلين في الدورة A،  \nوتحتوي القائمة الثانية على معرفات الطلاب المسجلين في الدورة B.\n\nمثال:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "sw": "Hesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B. \nKazi hii inachukua orodha mbili kama hoja: orodha ya kwanza ina vitambulisho vya wanafunzi waliojiandikisha katika kozi A, \nna orodha ya pili ina vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n\nMfano:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "tr": "Her iki kursa da (A ve B) kayıtlı olan öğrencilerin sayısını sayar. \n  Fonksiyon iki listeyi argüman olarak alır: ilk liste kurs A'ya kayıtlı öğrencilerin kimliklerini içerir, \n  ve ikinci liste kurs B'ye kayıtlı öğrencilerin kimliklerini içerir.\n  \n  Örnek:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "vi": "Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B. \nHàm này nhận hai danh sách làm đối số: danh sách đầu tiên chứa ID của sinh viên đã đăng ký khóa học A, \nvà danh sách thứ hai chứa ID của sinh viên đã đăng ký khóa học B.\n\nVí dụ:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.987042148462808",
      "sw": "0.9813551620233981",
      "tr": "0.9856199549345982",
      "vi": "0.9829324858791962"
    }
  },
  {
    "task_id": "Kotlin/48",
    "prompt": {
      "en": "/**\n * Calculates the number of whole apples left after a given time has passed, \n * assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n * \n * @param appleCount The total number of apples initially available.\n * @param timePerApple The time in minutes it takes to eat a single apple.\n * @param timePassed The time in minutes that has elapsed.\n * @return The number of whole apples remaining.\n * \n * Example:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "es": "/**\n * Calcula el número de manzanas enteras que quedan después de que ha pasado un cierto tiempo,\n * asumiendo que cada manzana se come una tras otra y cada una toma una cierta cantidad de tiempo para comer.\n * \n * @param appleCount El número total de manzanas disponibles inicialmente.\n * @param timePerApple El tiempo en minutos que toma comer una sola manzana.\n * @param timePassed El tiempo en minutos que ha transcurrido.\n * @return El número de manzanas enteras restantes.\n * \n * Ejemplo:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "arb": "/**\n * يحسب عدد التفاح الكامل المتبقي بعد مرور وقت معين، \n * بافتراض أن كل تفاحة تؤكل واحدة تلو الأخرى وكل واحدة تستغرق وقتًا معينًا للأكل.\n * \n * @param appleCount العدد الإجمالي للتفاح المتاح في البداية.\n * @param timePerApple الوقت بالدقائق الذي يستغرقه أكل تفاحة واحدة.\n * @param timePassed الوقت بالدقائق الذي انقضى.\n * @return عدد التفاح الكامل المتبقي.\n * \n * مثال:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "sw": "/**\n * Hukokotoa idadi ya maapulo mazima yaliyobaki baada ya muda fulani kupita, \n * ikizingatiwa kila tunda la apple linaliwa moja baada ya lingine na kila moja linachukua muda fulani kuliwa.\n * \n * @param appleCount Jumla ya idadi ya maapulo yaliyopo mwanzoni.\n * @param timePerApple Muda kwa dakika unaochukua kula tunda moja la apple.\n * @param timePassed Muda kwa dakika ambao umepita.\n * @return Idadi ya maapulo mazima yaliyobaki.\n * \n * Mfano:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "tr": "/**\n * Belirli bir süre geçtikten sonra kalan bütün elmaların sayısını hesaplar,\n * her elmanın art arda yendiği ve her birinin yenmesinin belirli bir süre aldığı varsayılır.\n * \n * @param appleCount Başlangıçta mevcut olan toplam elma sayısı.\n * @param timePerApple Bir elmayı yemek için geçen süre (dakika cinsinden).\n * @param timePassed Geçen süre (dakika cinsinden).\n * @return Kalan bütün elmaların sayısı.\n * \n * Örnek:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "vi": "/**\n * Tính số lượng táo nguyên còn lại sau khi một khoảng thời gian nhất định đã trôi qua,\n * giả sử mỗi quả táo được ăn lần lượt và mỗi quả mất một khoảng thời gian nhất định để ăn.\n * \n * @param appleCount Tổng số lượng táo ban đầu có sẵn.\n * @param timePerApple Thời gian tính bằng phút để ăn một quả táo.\n * @param timePassed Thời gian tính bằng phút đã trôi qua.\n * @return Số lượng táo nguyên còn lại.\n * \n * Ví dụ:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9893007745255558",
      "arb": "0.9808498463340454",
      "sw": "0.9465569069395151",
      "tr": "0.9458170087701601",
      "vi": "0.9702320593158255"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}",
    "instruction": {
      "en": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nAşağıdaki Kotlin kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9074996192254818",
      "sw": "0.918038549982431",
      "tr": "0.8848116598429149",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(remainingApples(50, 10, 200) == 30) // Test case based on example 1\n    check(remainingApples(5, 5, 3) == 4) // Test case based on example 2\n    check(remainingApples(10, 0, 100) == 0) // Test for edge case where timePerApple is 0\n    check(remainingApples(100, 1, 10000) == 0) // Test for case where all apples can be eaten\n}\n\n\nmain()",
    "entry_point": "remainingApples",
    "signature": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int",
    "docstring": {
      "en": "Calculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "es": "Calcula el número de manzanas enteras que quedan después de que ha pasado un tiempo determinado, \n  asumiendo que cada manzana se come una tras otra y cada una toma una cierta cantidad de tiempo para comer.\n  \n  @param appleCount El número total de manzanas disponibles inicialmente.\n  @param timePerApple El tiempo en minutos que se tarda en comer una sola manzana.\n  @param timePassed El tiempo en minutos que ha transcurrido.\n  @return El número de manzanas enteras restantes.\n  \n  Ejemplo:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "arb": "يحسب عدد التفاحات الكاملة المتبقية بعد مرور فترة زمنية معينة، \n  بافتراض أن كل تفاحة تؤكل واحدة تلو الأخرى وكل منها يستغرق وقتًا معينًا للأكل.\n  \n  @param appleCount العدد الإجمالي للتفاحات المتاحة في البداية.\n  @param timePerApple الوقت بالدقائق الذي يستغرقه أكل تفاحة واحدة.\n  @param timePassed الوقت بالدقائق الذي انقضى.\n  @return عدد التفاحات الكاملة المتبقية.\n  \n  مثال:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "sw": "Hesabu idadi ya tufaha nzima zilizobaki baada ya muda fulani kupita, \n  ukizingatia kila tufaha inaliwa moja baada ya nyingine na kila moja inachukua muda fulani kuliwa.\n  \n  @param appleCount Jumla ya idadi ya tufaha zilizopo mwanzoni.\n  @param timePerApple Muda kwa dakika unaochukua kula tufaha moja.\n  @param timePassed Muda kwa dakika ambao umepita.\n  @return Idadi ya tufaha nzima zilizobaki.\n  \n  Mfano:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "tr": "Belli bir süre geçtikten sonra kalan bütün elmaların sayısını hesaplar, \n  her bir elmanın art arda yendiği ve her birinin yenmesinin belirli bir süre aldığı varsayılır.\n  \n  @param appleCount Başlangıçta mevcut olan toplam elma sayısı.\n  @param timePerApple Bir elmayı yemek için geçen süre (dakika cinsinden).\n  @param timePassed Geçen süre (dakika cinsinden).\n  @return Kalan bütün elmaların sayısı.\n  \n  Örnek:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "vi": "Tính toán số lượng táo nguyên còn lại sau một khoảng thời gian đã trôi qua, \n  giả sử mỗi quả táo được ăn lần lượt và mỗi quả mất một khoảng thời gian nhất định để ăn.\n  \n  @param appleCount Tổng số lượng táo ban đầu có sẵn.\n  @param timePerApple Thời gian tính bằng phút để ăn một quả táo.\n  @param timePassed Thời gian tính bằng phút đã trôi qua.\n  @return Số lượng táo nguyên còn lại.\n  \n  Ví dụ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4"
    },
    "docstring_bertscore": {
      "es": "0.9773847393368917",
      "arb": "0.962395097632094",
      "sw": "0.9324122388756396",
      "tr": "0.9227198708026613",
      "vi": "0.9665792466085938"
    }
  },
  {
    "task_id": "Kotlin/49",
    "prompt": {
      "en": "/**\n * Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n * IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n * \n * Example:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Note:\n * - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n * - The discontinuous ID cannot be the minimum or maximum of the entire ID set.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "es": "/**\n * Encuentra los números de identificación faltantes (discontinuos) y duplicados de una lista de listas de números de identificación.\n * Se espera que los IDs sean continuos, pero debido a un error, falta uno y otro está duplicado.\n * \n * Ejemplo:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Nota:\n * - La función asume que los números de identificación son enteros positivos y que la lista contiene al menos un duplicado y un ID faltante.\n * - El ID discontinuo no puede ser el mínimo o máximo de todo el conjunto de IDs.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "arb": "/**\n * يعثر على أرقام الهوية المفقودة (غير المتتابعة) والمكررة من قائمة قوائم أرقام الهوية.\n * من المتوقع أن تكون أرقام الهوية متتابعة ولكن بسبب خطأ، هناك رقم مفقود وآخر مكرر.\n * \n * مثال:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * ملاحظة:\n * - تفترض الدالة أن أرقام الهوية هي أعداد صحيحة موجبة وأن القائمة تحتوي على الأقل على رقم مكرر ورقم مفقود.\n * - لا يمكن أن يكون رقم الهوية غير المتتابع هو الحد الأدنى أو الأقصى لمجموعة الأرقام الكاملة.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "sw": "/**\n * Inapata namba za ID zilizopotea (zisizoendelea) na zilizorudiwa kutoka kwenye orodha ya orodha za namba za ID.\n * ID zinatarajiwa kuwa endelevu lakini kutokana na hitilafu, moja imepotea na nyingine imerudiwa.\n * \n * Mfano:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Kumbuka:\n * - Kazi inadhani namba za ID ni namba kamili chanya na orodha ina angalau ID moja iliyorudiwa na moja iliyopotea.\n * - ID isiyoendelea haiwezi kuwa ya chini au ya juu ya seti nzima ya ID.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "tr": "/**\n * Bir ID numaraları listesinden eksik (devamsız) ve yinelenen ID numaralarını bulur.\n * ID'lerin sürekli olması beklenir ancak bir hata nedeniyle biri eksik ve diğeri yinelenmiştir.\n * \n * Örnek:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Not:\n * - Fonksiyon, ID numaralarının pozitif tamsayılar olduğunu ve listenin en az bir yinelenen ve bir eksik ID içerdiğini varsayar.\n * - Devamsız ID, tüm ID kümesinin minimumu veya maksimumu olamaz.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "vi": "/**\n * Tìm số ID bị thiếu (không liên tục) và số ID trùng lặp từ một danh sách các danh sách số ID.\n * Các ID được kỳ vọng là liên tục nhưng do lỗi, một ID bị thiếu và một ID khác bị trùng lặp.\n * \n * Ví dụ:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Lưu ý:\n * - Hàm giả định rằng các số ID là số nguyên dương và danh sách chứa ít nhất một ID trùng lặp và một ID bị thiếu.\n * - ID không liên tục không thể là giá trị nhỏ nhất hoặc lớn nhất của toàn bộ tập hợp ID.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.9739851803654797",
      "arb": "0.9418316888050761",
      "sw": "0.9633890440587926",
      "tr": "0.9662425681127397",
      "vi": "0.9433827934505775"
    },
    "canonical_solution": "{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}",
    "instruction": {
      "en": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando un máximo de 500 caracteres.",
      "arb": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nKotlin kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.9255475729070739",
      "sw": "0.918038549982431",
      "tr": "0.9521221329553505",
      "vi": "0.9283619667759573"
    },
    "level": "",
    "test": "fun main() {\n    check(findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9))) == Pair(7, 9))\n    // Add more tests to ensure robustness\n    check(findMissingAndDuplicateIds(listOf(listOf(1, 2, 4,7), listOf(3, 5, 5))) == Pair(6, 5))\n    check(findMissingAndDuplicateIds(listOf(listOf(10, 11,17, 12, 14), listOf(13, 15, 12))) == Pair(16, 12))\n}\n\n\nmain()",
    "entry_point": "findMissingAndDuplicateIds",
    "signature": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.",
      "es": "Encuentra los números de identificación faltantes (discontinuos) y duplicados de una lista de listas de números de identificación. \n  Se espera que los ID sean continuos, pero debido a un error, falta uno y otro está duplicado.\n\n  Ejemplo:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n\n  Nota:\n  - La función asume que los números de identificación son enteros positivos y que la lista contiene al menos un ID duplicado y uno faltante.\n  - El ID discontinuo no puede ser el mínimo o el máximo de todo el conjunto de ID.",
      "arb": "يجد أرقام الهوية المفقودة (غير المتصلة) والمكررة من قائمة من قوائم أرقام الهوية.\nمن المتوقع أن تكون الأرقام متصلة ولكن بسبب خطأ، هناك رقم مفقود وآخر مكرر.\n\nمثال:\n>>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n    Pair(7, 9)\n\nملاحظة:\n- تفترض الدالة أن أرقام الهوية هي أعداد صحيحة موجبة وأن القائمة تحتوي على الأقل على رقم مكرر ورقم مفقود.\n- لا يمكن أن يكون رقم الهوية غير المتصل هو الحد الأدنى أو الأقصى لمجموعة الأرقام الكاملة.",
      "sw": "Inapata namba za ID zilizopotea (zisizoendelea) na zilizorudiwa kutoka kwenye orodha ya orodha za namba za ID. \n  ID zinatarajiwa kuwa endelevu lakini kutokana na kosa, moja imepotea na nyingine imerudiwa.\n  \n  Mfano:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Kumbuka:\n  - Kazi inadhani namba za ID ni namba kamili chanya na orodha ina angalau moja iliyorudiwa na moja iliyopotea.\n  - ID isiyoendelea haiwezi kuwa ndogo zaidi au kubwa zaidi ya seti nzima ya ID.",
      "tr": "Eksik (kesintili) ve yinelenen kimlik numaralarını bir kimlik numaraları listesinden bulur.  \n  Kimlik numaralarının sürekli olması beklenir, ancak bir hata nedeniyle biri eksik ve diğeri yinelenmiştir.\n  \n  Örnek:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Not:\n  - Fonksiyon, kimlik numaralarının pozitif tamsayılar olduğunu ve listenin en az bir yinelenen ve bir eksik kimlik numarası içerdiğini varsayar.\n  - Kesintili kimlik numarası, tüm kimlik numarası kümesinin minimumu veya maksimumu olamaz.",
      "vi": "Tìm số ID bị thiếu (không liên tục) và số ID trùng lặp từ một danh sách các danh sách số ID. \n  Các ID được kỳ vọng là liên tục nhưng do lỗi, một ID bị thiếu và một ID khác bị trùng lặp.\n  \n  Ví dụ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Lưu ý:\n  - Hàm giả định rằng các số ID là số nguyên dương và danh sách chứa ít nhất một ID trùng lặp và một ID bị thiếu.\n  - ID không liên tục không thể là giá trị nhỏ nhất hoặc lớn nhất của toàn bộ tập hợp ID."
    },
    "docstring_bertscore": {
      "es": "0.9754053875898792",
      "arb": "0.9213268759404636",
      "sw": "0.92885576190321",
      "tr": "0.9628668447870518",
      "vi": "0.9331511438930894"
    }
  },
  {
    "task_id": "Kotlin/50",
    "prompt": {
      "en": "/**\n * Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n * \n * @param s The input string of length 8.\n * @return A Triple of integers where the first element is the count of digits,\n * the second element is the count of lowercase letters, and the third element\n * is the count of uppercase letters in the string.\n * \n * Example:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "es": "/**\n * Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n * \n * @param s La cadena de entrada de longitud 8.\n * @return Un Triple de enteros donde el primer elemento es el conteo de dígitos,\n * el segundo elemento es el conteo de letras minúsculas, y el tercer elemento\n * es el conteo de letras mayúsculas en la cadena.\n * \n * Ejemplo:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "arb": "/**\n * يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n * \n * @param s السلسلة المدخلة بطول 8.\n * @return ثلاثية من الأعداد الصحيحة حيث أن العنصر الأول هو عدد الأرقام،\n * العنصر الثاني هو عدد الأحرف الصغيرة، والعنصر الثالث هو عدد الأحرف الكبيرة في السلسلة.\n * \n * مثال:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */ \nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "sw": "/**\n * Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa ya urefu wa 8.\n * \n * @param s Kamba ya ingizo ya urefu wa 8.\n * @return Triple ya nambari ambapo kipengele cha kwanza ni hesabu ya tarakimu,\n * kipengele cha pili ni hesabu ya herufi ndogo, na kipengele cha tatu\n * ni hesabu ya herufi kubwa katika kamba.\n * \n * Mfano:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "tr": "/**\n * Verilen 8 karakter uzunluğundaki bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n * \n * @param s Uzunluğu 8 olan giriş stringi.\n * @return İlk elemanı rakamların sayısını, ikinci elemanı küçük harflerin sayısını ve üçüncü elemanı\n * büyük harflerin sayısını içeren bir Triple döndürür.\n * \n * Örnek:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "vi": "/**\n * Đếm số chữ số, chữ thường, và chữ hoa trong một chuỗi có độ dài 8.\n * \n * @param s Chuỗi đầu vào có độ dài 8.\n * @return Một Triple của các số nguyên, trong đó phần tử đầu tiên là số chữ số,\n * phần tử thứ hai là số chữ thường, và phần tử thứ ba là số chữ hoa trong chuỗi.\n * \n * Ví dụ:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.982549526504561",
      "sw": "0.9765479095415918",
      "tr": "0.9437077527539506",
      "vi": "0.9695769763191724"
    },
    "canonical_solution": "{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}",
    "instruction": {
      "en": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "es": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Kotlin en español utilizando como máximo 500 caracteres.",
      "arb": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة كوتلن باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Kotlin kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nKotlin kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Kotlin bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9692426813878907",
      "arb": "0.8990331978642508",
      "sw": "0.9437925679266526",
      "tr": "0.9349461666465017",
      "vi": "0.9109835961088338"
    },
    "level": "",
    "test": "fun main() {\n    check(countCharacters(\"yLOI2022\") == Triple(4, 1, 3))\n    check(countCharacters(\"IAKIOIOI\") == Triple(0, 0, 8))\n    check(countCharacters(\"1n2s0e1s\") == Triple(4, 4, 0))\n}\n\n\nmain()",
    "entry_point": "countCharacters",
    "signature": "fun countCharacters(s: String): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "es": "Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n  \n  @param s La cadena de entrada de longitud 8.\n  @return Un Triple de enteros donde el primer elemento es el conteo de dígitos,\n  el segundo elemento es el conteo de letras minúsculas, y el tercer elemento\n  es el conteo de letras mayúsculas en la cadena.\n  \n  Ejemplo:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "arb": "يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة نصية معينة بطول 8.\n\n@param s السلسلة النصية المدخلة بطول 8.\n@return ثلاثية من الأعداد الصحيحة حيث أن العنصر الأول هو عدد الأرقام،\nالعنصر الثاني هو عدد الأحرف الصغيرة، والعنصر الثالث\nهو عدد الأحرف الكبيرة في السلسلة.\n\nمثال:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "sw": "Hesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano wa herufi uliotolewa wa urefu wa 8.\n\n  @param s Mfuatano wa herufi wa urefu wa 8.\n  @return Triple ya nambari ambapo kipengele cha kwanza ni hesabu ya tarakimu,\n  kipengele cha pili ni hesabu ya herufi ndogo, na kipengele cha tatu\n  ni hesabu ya herufi kubwa katika mfuatano wa herufi.\n\n  Mfano:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "tr": "Verilen uzunluğu 8 olan bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  @param s Uzunluğu 8 olan giriş stringi.\n  @return İlk elemanı rakamların sayısını, ikinci elemanı küçük harflerin sayısını ve üçüncü elemanı büyük harflerin sayısını içeren bir Tamsayı Üçlüsü.\n\n  Örnek:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "vi": "Đếm số chữ số, chữ cái thường và chữ cái hoa trong một chuỗi có độ dài 8.\n\n  @param s Chuỗi đầu vào có độ dài 8.\n  @return Một bộ ba số nguyên mà phần tử đầu tiên là số lượng chữ số,\n  phần tử thứ hai là số lượng chữ cái thường, và phần tử thứ ba\n  là số lượng chữ cái hoa trong chuỗi.\n\n  Ví dụ:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9791183853025642",
      "sw": "0.9448532541613788",
      "tr": "0.9471843803132043",
      "vi": "0.9667089522474096"
    }
  }
]