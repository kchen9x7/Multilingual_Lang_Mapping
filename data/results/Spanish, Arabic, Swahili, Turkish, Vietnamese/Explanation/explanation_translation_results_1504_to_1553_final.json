[
  {
    "task_id": "Ruby/1",
    "prompt": {
      "en": "# Check if in given list of numbers, any two numbers are closer to each other than\n# given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "es": "# Verificar si en la lista dada de números, hay dos números más cercanos entre sí que el\n# umbral dado.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "arb": "# التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n# العتبة المعطاة.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "sw": "# Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili ambazo ziko karibu zaidi kuliko\n# kizingiti kilichotolewa.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "tr": "# Verilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol et.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "vi": "# Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n# ngưỡng đã cho hay không.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)"
    },
    "prompt_bertscore": {
      "es": "0.9809646546942835",
      "arb": "0.9874189502956312",
      "sw": "0.9704731965984018",
      "tr": "0.9757402784123039",
      "vi": "0.9808573942885247"
    },
    "canonical_solution": "numbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end",
    "instruction": {
      "en": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8848849544535168",
      "sw": "0.9151651628903803",
      "tr": "0.9105424380325553",
      "vi": "0.906469522069435"
    },
    "level": "",
    "test": "  # Test cases\n  def check(has_close_elements)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n    raise 'Test failed' unless has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0)\n    raise 'Test failed' if has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\n  \n    puts 'All tests passed!'\n  end\n  \n  check(method(:has_close_elements))",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers, threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Verifica si en la lista dada de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia kama katika orodha iliyotolewa ya nambari, nambari yoyote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "es": "0.969819901275178",
      "arb": "0.9859016128149057",
      "sw": "0.9818292927429284",
      "tr": "0.9517046118944152",
      "vi": "0.9763492791605569"
    }
  },
  {
    "task_id": "Ruby/2",
    "prompt": {
      "en": "# Counts the number of times the digit '1' appears in all numbers from 1 to n.\n# The function takes a single argument, n, which is a positive integer, and \n# returns the total count of the digit '1' appearing in all numbers from 1 to n.\n#\n# Example:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "es": "# Cuenta el número de veces que el dígito '1' aparece en todos los números del 1 al n.\n# La función toma un solo argumento, n, que es un entero positivo, y\n# devuelve el conteo total del dígito '1' que aparece en todos los números del 1 al n.\n#\n# Ejemplo:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "arb": "# يحسب عدد المرات التي يظهر فيها الرقم '1' في جميع الأرقام من 1 إلى n.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد العدد الإجمالي لظهور الرقم '1' في جميع الأرقام من 1 إلى n.\n#\n# مثال:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "sw": "# Inahesabu idadi ya mara ambazo tarakimu '1' inavyojitokeza katika namba zote kutoka 1 hadi n.\n# Kazi hii inachukua hoja moja, n, ambayo ni nambari nzima chanya, na \n# inarudisha jumla ya idadi ya tarakimu '1' inavyojitokeza katika namba zote kutoka 1 hadi n.\n#\n# Mfano:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "tr": "# 1'den n'e kadar olan tüm sayılarda '1' rakamının kaç kez göründüğünü sayar.\n# Fonksiyon, pozitif bir tam sayı olan n'i tek bir argüman olarak alır ve\n# 1'den n'e kadar olan tüm sayılarda '1' rakamının toplam sayısını döndürür.\n#\n# Örnek:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "vi": "# Đếm số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và\n# trả về tổng số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n#\n# Ví dụ:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)"
    },
    "prompt_bertscore": {
      "es": "0.9931778409329757",
      "arb": "0.9807985996957383",
      "sw": "0.9814362032188604",
      "tr": "0.969444291224641",
      "vi": "0.9859963595066593"
    },
    "canonical_solution": "  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n",
    "instruction": {
      "en": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9428772791308437",
      "tr": "0.8567819336231767",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_ones_in_range(15) == 8\nraise 'Test failed' unless count_ones_in_range(20) == 12\nraise 'Test failed' unless count_ones_in_range(100) == 21\nraise 'Test failed' unless count_ones_in_range(5) == 1\nraise 'Test failed' unless count_ones_in_range(55) == 16\nraise 'Test failed' unless count_ones_in_range(0) == 0\n\nputs 'All tests passed!'",
    "entry_point": "count_ones_in_range",
    "signature": "def count_ones_in_range(n)",
    "docstring": {
      "en": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n\nExample:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "es": "Cuenta el número de veces que aparece el dígito '1' en todos los números del 1 al n.  \nLa función toma un solo argumento, n, que es un entero positivo, y  \ndevuelve el conteo total del dígito '1' que aparece en todos los números del 1 al n.\n\nEjemplo:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "arb": "يحسب عدد المرات التي يظهر فيها الرقم '1' في جميع الأرقام من 1 إلى n. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد العدد الإجمالي لظهور الرقم '1' في جميع الأرقام من 1 إلى n.\n\nمثال:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "sw": "Hesabu idadi ya mara ambazo tarakimu '1' inaonekana katika namba zote kutoka 1 hadi n. \nKazi inachukua hoja moja, n, ambayo ni nambari kamili chanya, na \ninarudisha jumla ya idadi ya tarakimu '1' inayoonekana katika namba zote kutoka 1 hadi n.\n\nMfano:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "tr": "1'den n'e kadar olan tüm sayılarda '1' rakamının kaç kez göründüğünü sayar.\nFonksiyon, pozitif bir tam sayı olan n adlı tek bir argüman alır ve\n1'den n'e kadar olan tüm sayılarda '1' rakamının toplam sayısını döndürür.\n\nÖrnek:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "vi": "Đếm số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n. Hàm này nhận một đối số duy nhất, n, là một số nguyên dương, và trả về tổng số lần chữ số '1' xuất hiện trong tất cả các số từ 1 đến n.\n\nVí dụ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12"
    },
    "docstring_bertscore": {
      "es": "0.9887322943750338",
      "arb": "0.9831241641968949",
      "sw": "0.9803308251484012",
      "tr": "0.9804658938075049",
      "vi": "0.9787685972015618"
    }
  },
  {
    "task_id": "Ruby/3",
    "prompt": {
      "en": "# Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\n# The function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum \n# of all '1's in the binary representation of each number in the range [l, r].\n#\n# Examples:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "es": "# Calcula el conteo total del dígito '1' en la representación binaria de todos los números en un rango dado [l, r].\n# La función toma dos argumentos, l y r, donde l <= r y ambos son enteros no negativos. Devuelve la suma \n# de todos los '1's en la representación binaria de cada número en el rango [l, r].\n#\n# Ejemplos:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "arb": "# يحسب العدد الإجمالي للرقم '1' في التمثيل الثنائي لجميع الأرقام في نطاق معين [l, r].\n# تأخذ الدالة وسيطين، l و r، حيث l <= r وكلاهما عددان صحيحان غير سالبين. تقوم بإرجاع مجموع \n# جميع الأرقام '1' في التمثيل الثنائي لكل رقم في النطاق [l, r].\n#\n# أمثلة:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "sw": "# Inahesabu jumla ya idadi ya tarakimu '1' katika uwakilishi wa binary wa nambari zote katika safu iliyotolewa [l, r].\n# Kazi inachukua hoja mbili, l na r, ambapo l <= r na zote ni nambari zisizo hasi. Inarudisha jumla \n# ya '1's zote katika uwakilishi wa binary wa kila nambari katika safu [l, r].\n#\n# Mifano:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "tr": "# Verilen bir aralıktaki [l, r] tüm sayıların ikili gösteriminde '1' rakamının toplam sayısını hesaplar.\n# Fonksiyon iki argüman alır, l ve r, burada l <= r ve her ikisi de negatif olmayan tam sayılardır. \n# Aralıktaki [l, r] her sayının ikili gösterimindeki tüm '1'lerin toplamını döndürür.\n#\n# Örnekler:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "vi": "# Tính tổng số lượng chữ số '1' trong biểu diễn nhị phân của tất cả các số trong một khoảng cho trước [l, r].\n# Hàm nhận hai đối số, l và r, trong đó l <= r và cả hai đều là số nguyên không âm. Nó trả về tổng \n# của tất cả các chữ số '1' trong biểu diễn nhị phân của mỗi số trong khoảng [l, r].\n#\n# Ví dụ:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)"
    },
    "prompt_bertscore": {
      "es": "0.9992134236911019",
      "arb": "0.9770480608410377",
      "sw": "0.9683979063773492",
      "tr": "0.965162614731053",
      "vi": "0.9774639928589247"
    },
    "canonical_solution": "  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend",
    "instruction": {
      "en": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nAşağıdaki Ruby kodunun işlevini açıklayan doğal dilde bir açıklama (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9151651628903803",
      "tr": "0.8366741828902529",
      "vi": "0.9513240360843523"
    },
    "level": "",
    "test": "raise 'Test failed' unless sum_of_binary_ones(2, 3) == 3\nraise 'Test failed' unless sum_of_binary_ones(5, 5) == 2\nraise 'Test failed' unless sum_of_binary_ones(0, 4) == 5\nraise 'Test failed' unless sum_of_binary_ones(10, 15) == 17\nraise 'Test failed' unless sum_of_binary_ones(0, 0) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sum_of_binary_ones",
    "signature": "def sum_of_binary_ones(l, r)",
    "docstring": {
      "en": "Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\nThe function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum\nof all '1's in the binary representation of each number in the range [l, r].\n\nExamples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "es": "Calcula el conteo total del dígito '1' en la representación binaria de todos los números en un rango dado [l, r].  \nLa función toma dos argumentos, l y r, donde l <= r y ambos son enteros no negativos. Devuelve la suma  \nde todos los '1's en la representación binaria de cada número en el rango [l, r].\n\nEjemplos:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "arb": "يحسب العدد الإجمالي للرقم '1' في التمثيل الثنائي لجميع الأرقام في نطاق معين [l, r]. تأخذ الدالة معاملين، l و r، حيث l <= r وكلاهما عددان صحيحان غير سالبين. تُرجع مجموع جميع '1's في التمثيل الثنائي لكل رقم في النطاق [l, r].\n\nأمثلة:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "sw": "Hesabu jumla ya idadi ya tarakimu '1' katika uwakilishi wa binary wa nambari zote katika safu iliyotolewa [l, r]. \nKazi inachukua hoja mbili, l na r, ambapo l <= r na zote ni nambari zisizo hasi. Inarudisha jumla \nya '1' zote katika uwakilishi wa binary wa kila nambari katika safu [l, r].\n\nMifano:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "tr": "Belirtilen aralık [l, r] içindeki tüm sayıların ikili gösteriminde '1' rakamının toplam sayısını hesaplar.\nFonksiyon iki argüman alır, l ve r, burada l <= r ve her ikisi de negatif olmayan tam sayılardır. Aralık [l, r] içindeki her sayının ikili gösterimindeki tüm '1'lerin toplamını döndürür.\n\nÖrnekler:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "vi": "Tính tổng số lượng chữ số '1' trong biểu diễn nhị phân của tất cả các số trong một phạm vi cho trước [l, r]. Hàm nhận hai đối số, l và r, trong đó l <= r và cả hai đều là số nguyên không âm. Nó trả về tổng số '1' trong biểu diễn nhị phân của mỗi số trong phạm vi [l, r].\n\nVí dụ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5"
    },
    "docstring_bertscore": {
      "es": "0.9984014226934312",
      "arb": "0.971812362627339",
      "sw": "0.9641368874433889",
      "tr": "0.9758064223291886",
      "vi": "0.9702658264806013"
    }
  },
  {
    "task_id": "Ruby/4",
    "prompt": {
      "en": "# Converts a positive integer into a unique binary power representation.\n# The function takes a single argument, n, which is a positive integer, and\n# returns a string representing n as a sum of powers of 2, with the powers \n# themselves also represented as sums of powers of 2 when applicable.\n#\n# The representation is formatted as '2(b)' where 'b' is the power. If 'b' itself \n# is a power of 2, it's represented in a similar nested format. Spaces are not \n# used in the representation.\n#\n# Example:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "es": "# Convierte un entero positivo en una representación única de potencias binarias.\n# La función toma un solo argumento, n, que es un entero positivo, y\n# devuelve una cadena que representa n como una suma de potencias de 2, con las potencias\n# ellas mismas también representadas como sumas de potencias de 2 cuando sea aplicable.\n#\n# La representación está formateada como '2(b)' donde 'b' es la potencia. Si 'b' en sí mismo\n# es una potencia de 2, se representa en un formato anidado similar. No se usan\n# espacios en la representación.\n#\n# Ejemplo:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "arb": "# يحول عددًا صحيحًا موجبًا إلى تمثيل فريد لقوة ثنائية.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد\n# سلسلة تمثل n كمجموع لقوى 2، مع تمثيل القوى\n# نفسها أيضًا كمجموع لقوى 2 عند الاقتضاء.\n#\n# يتم تنسيق التمثيل كـ '2(b)' حيث 'b' هي القوة. إذا كانت 'b' نفسها\n# قوة لـ 2، يتم تمثيلها بتنسيق متداخل مشابه. لا تُستخدم\n# المسافات في التمثيل.\n#\n# مثال:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sw": "# Hubadilisha nambari nzima chanya kuwa uwakilishi wa kipekee wa nguvu za binary.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na\n# inarudisha kamba inayowakilisha n kama jumla ya nguvu za 2, na nguvu \n# zenyewe pia zinawakilishwa kama jumla ya nguvu za 2 inapowezekana.\n#\n# Uwakilishi umeundwa kama '2(b)' ambapo 'b' ni nguvu. Ikiwa 'b' yenyewe \n# ni nguvu ya 2, inawakilishwa kwa muundo sawa wa ndani. Nafasi hazitumiki \n# katika uwakilishi.\n#\n# Mfano:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "tr": "# Pozitif bir tam sayıyı benzersiz bir ikili kuvvet temsilimine dönüştürür.\n# Fonksiyon, pozitif bir tam sayı olan n adlı tek bir argüman alır ve\n# n'yi 2'nin kuvvetlerinin toplamı olarak temsil eden bir dize döndürür,\n# burada kuvvetler de uygulanabilir olduğunda 2'nin kuvvetlerinin toplamı olarak temsil edilir.\n#\n# Temsil '2(b)' şeklinde biçimlendirilmiştir, burada 'b' kuvvettir. Eğer 'b' \n# kendisi 2'nin bir kuvveti ise, benzer şekilde iç içe bir formatta temsil edilir. \n# Temsilde boşluk kullanılmaz.\n#\n# Örnek:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "vi": "```python\n# Chuyển đổi một số nguyên dương thành một biểu diễn lũy thừa nhị phân duy nhất.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và\n# trả về một chuỗi biểu diễn n dưới dạng tổng của các lũy thừa của 2, với các lũy thừa\n# cũng được biểu diễn dưới dạng tổng của các lũy thừa của 2 khi có thể.\n#\n# Biểu diễn được định dạng dưới dạng '2(b)' trong đó 'b' là lũy thừa. Nếu 'b' tự nó\n# là một lũy thừa của 2, nó được biểu diễn trong một định dạng lồng tương tự. Không sử dụng\n# khoảng trắng trong biểu diễn.\n#\n# Ví dụ:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)\n```"
    },
    "prompt_bertscore": {
      "es": "0.991687517184071",
      "arb": "0.9789431933064915",
      "sw": "0.9737976732857827",
      "tr": "0.9755190041678311",
      "vi": "0.9686771806930844"
    },
    "canonical_solution": "    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end",
    "instruction": {
      "en": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8894786792757107",
      "sw": "0.9151651628903803",
      "tr": "0.842630909387108",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless binary_power_representation(137) == \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\nraise 'Test failed' unless binary_power_representation(1315) == \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\nraise 'Test failed' unless binary_power_representation(1) == \"2(0)\"\nraise 'Test failed' unless binary_power_representation(3) == \"2+2(0)\"\nraise 'Test failed' unless binary_power_representation(10) == \"2(2+2(0))+2\"\n\n\nputs 'All tests passed!'",
    "entry_point": "binary_power_representation",
    "signature": "def binary_power_representation(n)",
    "docstring": {
      "en": "Converts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n\nExample:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "es": "Convierte un número entero positivo en una representación única de potencias binarias. La función toma un solo argumento, n, que es un número entero positivo, y devuelve una cadena que representa n como una suma de potencias de 2, con las potencias también representadas como sumas de potencias de 2 cuando sea aplicable.\n\nLa representación está formateada como '2(b)' donde 'b' es la potencia. Si 'b' en sí mismo es una potencia de 2, se representa en un formato anidado similar. No se utilizan espacios en la representación.\n\nEjemplo:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "arb": "تحول عددًا صحيحًا موجبًا إلى تمثيل فريد لقوة ثنائية. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد سلسلة تمثل n كمجموع لقوى 2، مع تمثيل القوى نفسها أيضًا كمجموع لقوى 2 عند الاقتضاء.\n\nيتم تنسيق التمثيل كـ '2(b)' حيث 'b' هو القوة. إذا كانت 'b' نفسها قوة لـ 2، يتم تمثيلها بتنسيق متداخل مشابه. لا تُستخدم المسافات في التمثيل.\n\nمثال:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sw": "Inabadilisha nambari kamili chanya kuwa uwakilishi wa kipekee wa nguvu za binary. \nKazi inachukua hoja moja, n, ambayo ni nambari kamili chanya, na \ninarudisha kamba inayowakilisha n kama jumla ya nguvu za 2, na nguvu zenyewe \npia zinawakilishwa kama jumla ya nguvu za 2 inapowezekana.\n\nUwakilishi umeundwa kama '2(b)' ambapo 'b' ni nguvu. Ikiwa 'b' yenyewe \nni nguvu ya 2, inawakilishwa kwa muundo sawa wa ndani. Nafasi hazitumiki \nkatika uwakilishi.\n\nMfano:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "tr": "Pozitif bir tam sayıyı benzersiz bir ikili kuvvet temsil biçimine dönüştürür.\nFonksiyon, n adlı tek bir argüman alır, bu pozitif bir tam sayıdır ve n'yi\nkuvvetler toplamı olarak temsil eden bir dize döndürür, burada kuvvetler\nuygulanabilir olduğunda yine kuvvetler toplamı olarak temsil edilir.\n\nTemsil biçimi '2(b)' olarak biçimlendirilmiştir, burada 'b' kuvvettir. Eğer 'b'\nkendisinin de bir 2'nin kuvveti ise, benzer bir iç içe geçmiş formatta temsil edilir.\nTemsil biçiminde boşluk kullanılmaz.\n\nÖrnek:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "vi": "Chuyển đổi một số nguyên dương thành một biểu diễn lũy thừa nhị phân duy nhất.  \nHàm nhận một đối số duy nhất, n, là một số nguyên dương và trả về một chuỗi biểu diễn n dưới dạng tổng các lũy thừa của 2, với các lũy thừa cũng được biểu diễn dưới dạng tổng các lũy thừa của 2 khi có thể.\n\nBiểu diễn được định dạng dưới dạng '2(b)' trong đó 'b' là lũy thừa. Nếu 'b' bản thân nó là một lũy thừa của 2, nó được biểu diễn dưới dạng lồng nhau tương tự. Không sử dụng khoảng trắng trong biểu diễn.\n\nVí dụ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\""
    },
    "docstring_bertscore": {
      "es": "0.9894126034300784",
      "arb": "0.983380993279573",
      "sw": "0.9726366787086338",
      "tr": "0.9699321274404628",
      "vi": "0.9729264804345638"
    }
  },
  {
    "task_id": "Ruby/5",
    "prompt": {
      "en": "# Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\n# The function takes a single argument, n, which is a positive integer, and returns the highest LCM\n# attainable by any combination of three distinct numbers from 1 to n.\n#\n# Example:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "es": "# Encuentra el Máximo Común Múltiplo (MCM) posible más alto de cualquier tres números elegidos entre 1 y n.\n# La función toma un solo argumento, n, que es un entero positivo, y devuelve el MCM más alto\n# alcanzable por cualquier combinación de tres números distintos del 1 al n.\n#\n# Ejemplo:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "arb": "# يجد أكبر مضاعف مشترك أصغر (LCM) ممكن لأي ثلاثة أرقام مختارة بين 1 و n.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد أعلى LCM\n# يمكن تحقيقه بواسطة أي مجموعة من ثلاثة أرقام مميزة من 1 إلى n.\n#\n# مثال:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "sw": "# Inapata Kiwango cha Juu cha Kawaida (LCM) kinachowezekana cha nambari yoyote tatu zilizochaguliwa kati ya 1 na n.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarudisha LCM ya juu zaidi\n# inayoweza kupatikana kwa mchanganyiko wowote wa nambari tatu tofauti kutoka 1 hadi n.\n#\n# Mfano:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "tr": "# 1 ile n arasından seçilen herhangi üç sayının mümkün olan en büyük Ortak Katı (LCM) bulur.\n# Fonksiyon, pozitif bir tamsayı olan n'i tek bir argüman olarak alır ve\n# 1'den n'e kadar olan üç farklı sayının herhangi bir kombinasyonu ile elde edilebilecek en yüksek LCM'yi döndürür.\n#\n# Örnek:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "vi": "# Tìm Bội số chung nhỏ nhất (LCM) lớn nhất có thể của bất kỳ ba số nào được chọn trong khoảng từ 1 đến n.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về LCM cao nhất\n# có thể đạt được bởi bất kỳ tổ hợp nào của ba số khác nhau từ 1 đến n.\n#\n# Ví dụ:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)"
    },
    "prompt_bertscore": {
      "es": "0.9875689162333126",
      "arb": "0.9724900894874301",
      "sw": "0.9781472813696847",
      "tr": "0.9682838925386352",
      "vi": "0.9662346228974983"
    },
    "canonical_solution": "    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end",
    "instruction": {
      "en": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nRuby kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde özlü bir şekilde sağlayın.",
      "vi": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.8887721510103695",
      "tr": "0.8465238662250109",
      "vi": "0.9409585096500467"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_lcm_of_three(9) == 504\nraise 'Test failed' unless max_lcm_of_three(10) == 630\nraise 'Test failed' unless max_lcm_of_three(3) == 6\nraise 'Test failed' unless max_lcm_of_three(5) == 60\nraise 'Test failed' unless max_lcm_of_three(1) == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_lcm_of_three",
    "signature": "def max_lcm_of_three(n)",
    "docstring": {
      "en": "Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\nThe function takes a single argument, n, which is a positive integer, and returns the highest LCM\nattainable by any combination of three distinct numbers from 1 to n.\n\nExample:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "es": "Encuentra el Máximo Común Múltiplo (MCM) posible más alto de cualquier combinación de tres números elegidos entre 1 y n.  \nLa función toma un único argumento, n, que es un número entero positivo, y devuelve el MCM más alto alcanzable por cualquier combinación de tres números distintos del 1 al n.\n\nEjemplo:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "arb": "يجد أكبر مضاعف مشترك أصغر (LCM) ممكن لأي ثلاثة أرقام مختارة بين 1 و n. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد أعلى LCM يمكن تحقيقه بواسطة أي مجموعة من ثلاثة أرقام مميزة من 1 إلى n.\n\nمثال:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "sw": "Inapata Kiwango cha Juu cha Kawaida (LCM) kinachowezekana cha nambari tatu zozote zilizochaguliwa kati ya 1 na n. \nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya, na inarudisha LCM ya juu inayoweza kupatikana na mchanganyiko wowote wa nambari tatu tofauti kutoka 1 hadi n.\n\nMfano:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "tr": "1 ile n arasında seçilen herhangi üç sayının mümkün olan en büyük Ortak Katını (LCM) bulur. \nFonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve 1'den n'e kadar olan üç farklı sayının herhangi bir kombinasyonu ile elde edilebilecek en yüksek LCM'yi döndürür.\n\nÖrnek:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "vi": "Tìm Bội số chung nhỏ nhất (LCM) lớn nhất có thể của bất kỳ ba số nào được chọn từ 1 đến n. Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về LCM cao nhất có thể đạt được bởi bất kỳ tổ hợp nào của ba số khác nhau từ 1 đến n.\n\nVí dụ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630"
    },
    "docstring_bertscore": {
      "es": "0.9742952423902751",
      "arb": "0.9666233425531836",
      "sw": "0.9594551693623965",
      "tr": "0.9701565797710322",
      "vi": "0.9659632937970046"
    }
  },
  {
    "task_id": "Ruby/6",
    "prompt": {
      "en": "# Swaps the case of each letter in a given string.\n# The function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters. \n# It returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n#\n# Example:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "es": "# Intercambia la mayúscula y minúscula de cada letra en una cadena dada.\n# La función toma un único argumento, input_string, que es una cadena que contiene solo alfabetos en inglés sin espacios u otros tipos de caracteres.\n# Devuelve una nueva cadena donde cada letra minúscula se convierte en mayúscula y cada letra mayúscula se convierte en minúscula.\n#\n# Ejemplo:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "arb": "# يبدل حالة كل حرف في سلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة تحتوي فقط على الحروف الإنجليزية بدون أي مسافات أو أنواع أخرى من الأحرف.\n# تعيد سلسلة جديدة حيث يتم تحويل كل حرف صغير إلى كبير وكل حرف كبير إلى صغير.\n#\n# مثال:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "sw": "# Hubadilisha herufi kubwa na ndogo za kila herufi katika kamba iliyotolewa.\n# Kazi inachukua hoja moja, input_string, ambayo ni kamba inayo na alfabeti za Kiingereza pekee bila nafasi au aina nyingine za herufi.\n# Inarudisha kamba mpya ambapo kila herufi ndogo inabadilishwa kuwa herufi kubwa na kila herufi kubwa inabadilishwa kuwa herufi ndogo.\n#\n# Mfano:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "tr": "# Verilen bir stringdeki her harfin büyük/küçük harf durumunu değiştirir.\n# Fonksiyon, yalnızca İngilizce alfabeler içeren, boşluk veya başka türde karakter içermeyen bir string olan input_string adlı tek bir argüman alır.\n# Her küçük harfin büyük harfe ve her büyük harfin küçük harfe dönüştürüldüğü yeni bir string döndürür.\n#\n# Örnek:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "vi": "# Hoán đổi chữ hoa và chữ thường của mỗi chữ cái trong một chuỗi đã cho.\n# Hàm nhận một đối số duy nhất, input_string, là một chuỗi chỉ chứa các chữ cái tiếng Anh mà không có khoảng trắng hoặc các loại ký tự khác.\n# Nó trả về một chuỗi mới trong đó mọi chữ cái thường được chuyển thành chữ hoa và mọi chữ cái hoa được chuyển thành chữ thường.\n#\n# Ví dụ:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)"
    },
    "prompt_bertscore": {
      "es": "0.9716788830112836",
      "arb": "0.9673846928036903",
      "sw": "0.9734337824277268",
      "tr": "0.9780447880930707",
      "vi": "0.9717774036802769"
    },
    "canonical_solution": "    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9428772791308437",
      "tr": "0.8553954935635532",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless swap_case(\"HelloWorld\") == \"hELLOwORLD\"\nraise 'Test failed' unless swap_case(\"Ruby\") == \"rUBY\"\nraise 'Test failed' unless swap_case(\"AeDb\") == \"aEdB\"\nraise 'Test failed' unless swap_case(\"JAVA\") == \"java\"\nraise 'Test failed' unless swap_case(\"python\") == \"PYTHON\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "swap_case",
    "signature": "def swap_case(input_string)",
    "docstring": {
      "en": "Swaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n\nExample:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "es": "Intercambia el caso de cada letra en una cadena dada.  \nLa función toma un solo argumento, input_string, que es una cadena que contiene solo alfabetos ingleses sin espacios ni otros tipos de caracteres.  \nDevuelve una nueva cadena donde cada letra minúscula se convierte en mayúscula y cada letra mayúscula se convierte en minúscula.  \n\nEjemplo:  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "arb": "يقوم بتبديل حالة كل حرف في سلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة تحتوي على حروف إنجليزية فقط دون أي مسافات أو أنواع أخرى من الأحرف.\nتُرجع سلسلة جديدة حيث يتم تحويل كل حرف صغير إلى حرف كبير وكل حرف كبير إلى حرف صغير.\n\nمثال:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "sw": "Hubadilisha herufi kubwa na ndogo za kila herufi katika kamba iliyotolewa.\nKazi inachukua hoja moja, input_string, ambayo ni kamba inayojumuisha alfabeti za Kiingereza pekee bila nafasi au aina nyingine za herufi.\nInarejesha kamba mpya ambapo kila herufi ndogo inabadilishwa kuwa herufi kubwa na kila herufi kubwa inabadilishwa kuwa herufi ndogo.\n\nMfano:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "tr": "Her harfin büyük/küçük harf durumunu değiştiren bir dize döndürür.\nFonksiyon, yalnızca İngilizce alfabeler içeren ve boşluk veya diğer karakter türlerini içermeyen bir dize olan input_string adlı tek bir argüman alır.\nHer küçük harfin büyük harfe ve her büyük harfin küçük harfe dönüştürüldüğü yeni bir dize döndürür.\n\nÖrnek:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "vi": "Hoán đổi chữ hoa và chữ thường của mỗi chữ cái trong một chuỗi cho trước. Hàm nhận một đối số duy nhất, input_string, là một chuỗi chỉ chứa các chữ cái tiếng Anh mà không có khoảng trắng hoặc các loại ký tự khác. Nó trả về một chuỗi mới trong đó mọi chữ cái thường được chuyển thành chữ hoa và mọi chữ cái hoa được chuyển thành chữ thường.\n\nVí dụ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\""
    },
    "docstring_bertscore": {
      "es": "0.9775275545808558",
      "arb": "0.9627180706316567",
      "sw": "0.9664413971241557",
      "tr": "0.9566091932629287",
      "vi": "0.9631850506574697"
    }
  },
  {
    "task_id": "Ruby/7",
    "prompt": {
      "en": "# Finds the maximum value in an array and returns its value along with its index.\n# The function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\n# It returns an array containing the maximum value and its index in the format [max_value, index].\n#\n# Example:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "es": "# Encuentra el valor máximo en un arreglo y devuelve su valor junto con su índice.\n# La función toma un solo argumento, arr, que es un arreglo de enteros. El tamaño del arreglo debe estar entre 1 y 100.\n# Devuelve un arreglo que contiene el valor máximo y su índice en el formato [max_value, index].\n#\n# Ejemplo:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "arb": "# يجد القيمة القصوى في مصفوفة ويعيد قيمتها مع مؤشرها.\n# تأخذ الدالة وسيطًا واحدًا، arr، وهو مصفوفة من الأعداد الصحيحة. يجب أن يكون حجم المصفوفة بين 1 و 100.\n# تعيد مصفوفة تحتوي على القيمة القصوى ومؤشرها في الشكل [max_value, index].\n#\n# مثال:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "sw": "# Inapata thamani ya juu zaidi katika safu na inarejesha thamani yake pamoja na faharasa yake.\n# Kazi inachukua hoja moja, arr, ambayo ni safu ya nambari za mzima. Ukubwa wa safu unapaswa kuwa kati ya 1 na 100.\n# Inarejesha safu inayojumuisha thamani ya juu zaidi na faharasa yake katika muundo [max_value, index].\n#\n# Mfano:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "tr": "# Bir dizideki maksimum değeri bulur ve bu değeri ile dizinini döndürür.\n# Fonksiyon, bir adet argüman alır: arr, bu bir tamsayı dizisidir. Dizi boyutu 1 ile 100 arasında olmalıdır.\n# Maksimum değeri ve dizindeki yerini [max_value, index] formatında döndüren bir dizi döndürür.\n#\n# Örnek:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "vi": "# Tìm giá trị lớn nhất trong một mảng và trả về giá trị đó cùng với chỉ số của nó.\n# Hàm nhận một đối số duy nhất, arr, là một mảng các số nguyên. Kích thước mảng nên nằm trong khoảng từ 1 đến 100.\n# Nó trả về một mảng chứa giá trị lớn nhất và chỉ số của nó theo định dạng [max_value, index].\n#\n# Ví dụ:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)"
    },
    "prompt_bertscore": {
      "es": "0.9885320749509507",
      "arb": "0.980466291068267",
      "sw": "0.9801895989474855",
      "tr": "0.9611832536774001",
      "vi": "0.9824788140889125"
    },
    "canonical_solution": "    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end",
    "instruction": {
      "en": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة روبي باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9471186336570817",
      "arb": "0.9031176343894712",
      "sw": "0.9151651628903803",
      "tr": "0.8372267726102919",
      "vi": "0.9273999998406053"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_max_with_index([3, 2, 1]) == [3, 0]\nraise 'Test failed' unless find_max_with_index([10, 20, 30, 40]) == [40, 3]\nraise 'Test failed' unless find_max_with_index([5]) == [5, 0]\nraise 'Test failed' unless find_max_with_index([-3, -2, -1, -4]) == [-1, 2]\nraise 'Test failed' unless find_max_with_index([100, 200, 100, 50]) == [200, 1]\n  \nputs 'All tests passed!'",
    "entry_point": "find_max_with_index",
    "signature": "def find_max_with_index(arr)",
    "docstring": {
      "en": "Finds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n\nExample:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "es": "Encuentra el valor máximo en un arreglo y devuelve su valor junto con su índice.  \nLa función toma un solo argumento, arr, que es un arreglo de enteros. El tamaño del arreglo debe estar entre 1 y 100.  \nDevuelve un arreglo que contiene el valor máximo y su índice en el formato [max_value, index].  \n\nEjemplo:  \n>>> find_max_with_index([3, 2, 1])  \n[3, 0]  \n>>> find_max_with_index([10, 20, 30, 40])  \n[40, 3]  ",
      "arb": "يعثر على القيمة القصوى في مصفوفة ويعيد قيمتها مع مؤشرها.\nتأخذ الدالة وسيطًا واحدًا، arr، وهو مصفوفة من الأعداد الصحيحة. يجب أن يكون حجم المصفوفة بين 1 و100.\nتعيد مصفوفة تحتوي على القيمة القصوى ومؤشرها في الشكل [max_value, index].\n\nمثال:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "sw": "Inapata thamani ya juu zaidi katika safu na kurudisha thamani yake pamoja na faharasa yake. \nKazi inachukua hoja moja, arr, ambayo ni safu ya nambari nzima. Ukubwa wa safu unapaswa kuwa kati ya 1 na 100. \nInarudisha safu inayojumuisha thamani ya juu zaidi na faharasa yake katika muundo [max_value, index].\n\nMfano:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "tr": "Maksimum değeri bir dizide bulur ve değerini dizinle birlikte döndürür.\nFonksiyon, bir tamsayı dizisi olan arr adlı tek bir argüman alır. Dizi boyutu 1 ile 100 arasında olmalıdır.\n[max_value, index] formatında maksimum değeri ve dizinini içeren bir dizi döndürür.\n\nÖrnek:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "vi": "Tìm giá trị lớn nhất trong một mảng và trả về giá trị của nó cùng với chỉ số của nó. Hàm nhận một đối số duy nhất, arr, là một mảng các số nguyên. Kích thước mảng nên nằm trong khoảng từ 1 đến 100. Nó trả về một mảng chứa giá trị lớn nhất và chỉ số của nó theo định dạng [max_value, index].\n\nVí dụ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9822565466925345",
      "arb": "0.9745135371790324",
      "sw": "0.9717799858752303",
      "tr": "0.9893236170193748",
      "vi": "0.9928413610675026"
    }
  },
  {
    "task_id": "Ruby/8",
    "prompt": {
      "en": "# Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\n# The character can move up one or two floors at a time, but cannot use the two-floor jump consecutively. \n# Moving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n#\n# Args:\n# - floor_heights (Array): An array of integers representing the height of each floor.\n#\n# Returns:\n# - Integer: The minimum time required to reach the top of the building.\n#\n# Example:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "es": "# Calcula el tiempo mínimo requerido para que un personaje llegue a la cima de un edificio con alturas de piso variables.\n# El personaje puede subir uno o dos pisos a la vez, pero no puede usar el salto de dos pisos consecutivamente.\n# Subir un piso toma una unidad de tiempo, mientras que saltar dos pisos es instantáneo.\n#\n# Argumentos:\n# - floor_heights (Array): Un arreglo de enteros que representa la altura de cada piso.\n#\n# Retorna:\n# - Entero: El tiempo mínimo requerido para llegar a la cima del edificio.\n#\n# Ejemplo:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "arb": "# يحسب الحد الأدنى من الوقت المطلوب لشخصية للوصول إلى قمة مبنى بارتفاعات طوابق متغيرة.\n# يمكن للشخصية التحرك لأعلى طابق واحد أو طابقين في كل مرة، ولكن لا يمكنها استخدام القفزة ذات الطابقين بشكل متتالي.\n# التحرك لأعلى طابق واحد يستغرق وحدة زمنية واحدة، بينما القفز لأعلى طابقين يكون فورياً.\n#\n# الوسائط:\n# - floor_heights (مصفوفة): مصفوفة من الأعداد الصحيحة تمثل ارتفاع كل طابق.\n#\n# يعيد:\n# - عدد صحيح: الحد الأدنى من الوقت المطلوب للوصول إلى قمة المبنى.\n#\n# مثال:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "sw": "# Inahesabu muda wa chini kabisa unaohitajika kwa mhusika kufika juu ya jengo lenye urefu tofauti wa sakafu.\n# Mhusika anaweza kupanda sakafu moja au mbili kwa wakati mmoja, lakini hawezi kutumia kuruka sakafu mbili mfululizo.\n# Kupanda sakafu moja kunachukua kitengo kimoja cha muda, wakati kuruka sakafu mbili ni papo hapo.\n#\n# Hoja:\n# - floor_heights (Array): Kundi la namba za mzima linalowakilisha urefu wa kila sakafu.\n#\n# Inarudisha:\n# - Namba: Muda wa chini kabisa unaohitajika kufika juu ya jengo.\n#\n# Mfano:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "tr": "# Bir karakterin farklı kat yüksekliklerine sahip bir binanın tepesine ulaşması için gereken minimum zamanı hesaplar.\n# Karakter bir seferde bir veya iki kat yukarı çıkabilir, ancak iki kat sıçramayı ardışık olarak kullanamaz.\n# Bir kat yukarı çıkmak bir birim zaman alırken, iki kat yukarı sıçramak anlıktır.\n#\n# Argümanlar:\n# - floor_heights (Dizi): Her katın yüksekliğini temsil eden bir tamsayı dizisi.\n#\n# Döndürür:\n# - Tamsayı: Binanın tepesine ulaşmak için gereken minimum zaman.\n#\n# Örnek:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "vi": "# Tính toán thời gian tối thiểu cần thiết để một nhân vật đạt đến đỉnh của tòa nhà với độ cao các tầng khác nhau.\n# Nhân vật có thể di chuyển lên một hoặc hai tầng mỗi lần, nhưng không thể sử dụng cú nhảy hai tầng liên tiếp.\n# Di chuyển lên một tầng mất một đơn vị thời gian, trong khi nhảy lên hai tầng là tức thời.\n#\n# Tham số:\n# - floor_heights (Mảng): Một mảng các số nguyên đại diện cho độ cao của mỗi tầng.\n#\n# Trả về:\n# - Số nguyên: Thời gian tối thiểu cần thiết để đạt đến đỉnh của tòa nhà.\n#\n# Ví dụ:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)"
    },
    "prompt_bertscore": {
      "es": "0.9735170085573804",
      "arb": "0.9772701296070346",
      "sw": "0.9564103642515127",
      "tr": "0.9859691471444576",
      "vi": "0.9771167869528757"
    },
    "canonical_solution": "    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end",
    "instruction": {
      "en": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nAşağıdaki Ruby kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9428772791308437",
      "tr": "0.8829131506609834",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless minimum_time_to_top([3, 5, 1, 8, 4]) == 1\nraise 'Test failed' unless minimum_time_to_top([2, 2, 2, 2, 2]) == 2\nraise 'Test failed' unless minimum_time_to_top([1, 1, 1, 1, 1]) == 1\nraise 'Test failed' unless minimum_time_to_top([10]) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_time_to_top",
    "signature": "def minimum_time_to_top(heights)",
    "docstring": {
      "en": "Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "es": "Calcula el tiempo mínimo requerido para que un personaje alcance la cima de un edificio con alturas de piso variables. El personaje puede subir uno o dos pisos a la vez, pero no puede usar el salto de dos pisos consecutivamente. Subir un piso toma una unidad de tiempo, mientras que saltar dos pisos es instantáneo.\n\nArgumentos:\n- floor_heights (Array): Un arreglo de enteros que representa la altura de cada piso.\n\nDevuelve:\n- Integer: El tiempo mínimo requerido para alcanzar la cima del edificio.\n\nEjemplos:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "arb": "يحسب الحد الأدنى من الوقت المطلوب للشخصية للوصول إلى قمة مبنى بارتفاعات طوابق متغيرة.\nيمكن للشخصية التحرك لأعلى طابق واحد أو طابقين في المرة الواحدة، ولكن لا يمكنها استخدام القفزة ذات الطابقين بشكل متتالي.\nالتحرك لأعلى طابق واحد يستغرق وحدة واحدة من الوقت، بينما القفز لأعلى طابقين يكون فورياً.\n\nالمعطيات:\n- floor_heights (Array): مصفوفة من الأعداد الصحيحة تمثل ارتفاع كل طابق.\n\nالقيم المعادة:\n- Integer: الحد الأدنى من الوقت المطلوب للوصول إلى قمة المبنى.\n\nمثال:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "sw": "Hesabu muda wa chini unaohitajika kwa mhusika kufika juu ya jengo lenye urefu tofauti wa sakafu. Mhusika anaweza kupanda sakafu moja au mbili kwa wakati mmoja, lakini hawezi kutumia kuruka sakafu mbili mfululizo. Kupanda sakafu moja kunachukua kitengo kimoja cha muda, wakati kuruka sakafu mbili ni papo hapo.\n\nHoja:\n- floor_heights (Array): Mfululizo wa namba za mzima unaowakilisha urefu wa kila sakafu.\n\nInarejesha:\n- Integer: Muda wa chini unaohitajika kufika juu ya jengo.\n\nMfano:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "tr": "Binanın tepesine ulaşmak için bir karakterin ihtiyaç duyduğu minimum zamanı hesaplar, kat yükseklikleri değişkendir.\nKarakter bir seferde bir veya iki kat yukarı çıkabilir, ancak iki kat zıplamayı ardışık olarak kullanamaz.\nBir kat yukarı çıkmak bir zaman birimi alırken, iki kat zıplamak anlıktır.\n\nArgümanlar:\n- floor_heights (Dizi): Her katın yüksekliğini temsil eden tamsayıların dizisi.\n\nDöndürür:\n- Tamsayı: Binanın tepesine ulaşmak için gereken minimum zaman.\n\nÖrnek:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "vi": "Tính toán thời gian tối thiểu cần thiết để một nhân vật đạt đến đỉnh của một tòa nhà với độ cao các tầng khác nhau. Nhân vật có thể di chuyển lên một hoặc hai tầng mỗi lần, nhưng không thể sử dụng cú nhảy hai tầng liên tiếp. Di chuyển lên một tầng mất một đơn vị thời gian, trong khi nhảy lên hai tầng là ngay lập tức.\n\nTham số:\n- floor_heights (Array): Một mảng các số nguyên đại diện cho độ cao của mỗi tầng.\n\nTrả về:\n- Integer: Thời gian tối thiểu cần thiết để đạt đến đỉnh của tòa nhà.\n\nVí dụ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9774576366867316",
      "arb": "0.9762056693950687",
      "sw": "0.9501576784869155",
      "tr": "0.9668148222405012",
      "vi": "0.973013480541457"
    }
  },
  {
    "task_id": "Ruby/9",
    "prompt": {
      "en": "# Transposes a given n x m matrix.\n# The function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\n# The matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\n# The function returns a new matrix which is the transpose of the input matrix.\n#\n# Example:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "es": "# Transpone una matriz dada de n x m.\n# La función toma un solo argumento, matrix, que es un array de arrays que representa la matriz de n x m.\n# La matriz tiene n filas y m columnas, donde 1 ≤ n ≤ 20 y 1 ≤ m ≤ 20. Cada elemento en la matriz es un entero.\n# La función devuelve una nueva matriz que es la transpuesta de la matriz de entrada.\n#\n# Ejemplo:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "arb": "# يقوم بعملية تبديل لمصفوفة n x m معطاة.\n# تأخذ الدالة وسيطًا واحدًا، matrix، وهو مصفوفة من المصفوفات التي تمثل المصفوفة n x m.\n# تحتوي المصفوفة على n صفوف و m أعمدة، حيث 1 ≤ n ≤ 20 و 1 ≤ m ≤ 20. كل عنصر في المصفوفة هو عدد صحيح.\n# تعيد الدالة مصفوفة جديدة وهي تبديل للمصفوفة المدخلة.\n#\n# مثال:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "sw": "# Inabadilisha nafasi ya jedwali lililopewa la n x m.\n# Kazi inachukua hoja moja, matrix, ambayo ni safu ya safu zinazowakilisha jedwali la n x m.\n# Jedwali lina safu n na safu m, ambapo 1 ≤ n ≤ 20 na 1 ≤ m ≤ 20. Kila kipengele katika jedwali ni nambari kamili.\n# Kazi inarudisha jedwali jipya ambalo ni badiliko la jedwali la ingizo.\n#\n# Mfano:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "tr": "# Verilen n x m matrisini transpoze eder.\n# Fonksiyon, n x m matrisini temsil eden dizi dizileri olan tek bir argüman, matrix, alır.\n# Matris n satır ve m sütun içerir, burada 1 ≤ n ≤ 20 ve 1 ≤ m ≤ 20. Matristeki her bir eleman bir tam sayıdır.\n# Fonksiyon, giriş matrisinin transpozesini olan yeni bir matris döndürür.\n#\n# Örnek:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "vi": "# Hoán vị một ma trận n x m đã cho.\n# Hàm nhận một đối số duy nhất, matrix, là một mảng các mảng đại diện cho ma trận n x m.\n# Ma trận có n hàng và m cột, với 1 ≤ n ≤ 20 và 1 ≤ m ≤ 20. Mỗi phần tử trong ma trận là một số nguyên.\n# Hàm trả về một ma trận mới là ma trận chuyển vị của ma trận đầu vào.\n#\n# Ví dụ:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)"
    },
    "prompt_bertscore": {
      "es": "0.9976615245240763",
      "arb": "0.9695767776887914",
      "sw": "0.9558613498783323",
      "tr": "0.9957856592055828",
      "vi": "0.9966054067881137"
    },
    "canonical_solution": "    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end",
    "instruction": {
      "en": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8894786792757107",
      "sw": "0.9151651628903803",
      "tr": "0.864885854539019",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]]) == [[34, -4], [76, 5], [-54, 23], [7, 9]]\nraise 'Test failed' unless transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]\nraise 'Test failed' unless transpose_matrix([[10]]) == [[10]]\nraise 'Test failed' unless transpose_matrix([]) == []\nraise 'Test failed' unless transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]]\n\n\nputs 'All tests passed!'",
    "entry_point": "transpose_matrix",
    "signature": "def transpose_matrix(matrix)",
    "docstring": {
      "en": "Transposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n\nExample:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "es": "Transpone una matriz n x m dada.  \nLa función toma un solo argumento, matrix, que es un array de arrays que representa la matriz n x m.  \nLa matriz tiene n filas y m columnas, donde 1 ≤ n ≤ 20 y 1 ≤ m ≤ 20. Cada elemento en la matriz es un entero.  \nLa función devuelve una nueva matriz que es la transpuesta de la matriz de entrada.\n\nEjemplo:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "arb": "ينقل مصفوفة n x m معطاة.  \nتأخذ الدالة وسيطًا واحدًا، matrix، وهو مصفوفة من المصفوفات التي تمثل المصفوفة n x m.  \nتحتوي المصفوفة على n صفوف و m أعمدة، حيث 1 ≤ n ≤ 20 و 1 ≤ m ≤ 20. كل عنصر في المصفوفة هو عدد صحيح.  \nتعيد الدالة مصفوفة جديدة وهي مصفوفة النقل للمصفوفة المدخلة.  \n\nمثال:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "sw": "Inabadilisha nafasi ya matriki ya n x m iliyotolewa.  \nKazi inachukua hoja moja, matrix, ambayo ni safu ya safu zinazowakilisha matriki ya n x m.  \nMatrix ina safu n na safu m, ambapo 1 ≤ n ≤ 20 na 1 ≤ m ≤ 20. Kila kipengele katika matrix ni nambari kamili.  \nKazi inarudisha matrix mpya ambayo ni mabadiliko ya nafasi ya matrix ya pembejeo.  \n\nMfano:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "tr": "Verilen n x m matrisini transpoze eder. \nFonksiyon, n x m matrisini temsil eden diziler dizisi olan tek bir argüman, matrix, alır. \nMatris n satır ve m sütuna sahiptir, burada 1 ≤ n ≤ 20 ve 1 ≤ m ≤ 20. Matristeki her bir eleman bir tam sayıdır. \nFonksiyon, giriş matrisinin transpozu olan yeni bir matris döndürür.\n\nÖrnek:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "vi": "Chuyển vị một ma trận n x m cho trước.  \nHàm nhận một đối số duy nhất, matrix, là một mảng các mảng đại diện cho ma trận n x m.  \nMa trận có n hàng và m cột, với 1 ≤ n ≤ 20 và 1 ≤ m ≤ 20. Mỗi phần tử trong ma trận là một số nguyên.  \nHàm trả về một ma trận mới là chuyển vị của ma trận đầu vào.  \n\nVí dụ:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]"
    },
    "docstring_bertscore": {
      "es": "0.9967285576243554",
      "arb": "0.9927716418037594",
      "sw": "0.9708573477553233",
      "tr": "0.9858958525338557",
      "vi": "0.9954656656617356"
    }
  },
  {
    "task_id": "Ruby/10",
    "prompt": {
      "en": "# Sorts a list of students by their scores in descending order. If two students have the same score,\n# they are sorted alphabetically by their names. The function takes an array of arrays as an argument,\n# where each sub-array contains a student's name and their score. The function returns an array of \n# student names sorted as per the mentioned criteria.\n#\n# Example:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "es": "# Ordena una lista de estudiantes por sus puntuaciones en orden descendente. Si dos estudiantes tienen la misma puntuación,\n# se ordenan alfabéticamente por sus nombres. La función toma un arreglo de arreglos como argumento,\n# donde cada sub-arreglo contiene el nombre de un estudiante y su puntuación. La función devuelve un arreglo de\n# nombres de estudiantes ordenados según los criterios mencionados.\n#\n# Ejemplo:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "arb": "# يقوم بفرز قائمة الطلاب حسب درجاتهم بترتيب تنازلي. إذا كان لدى طالبين نفس الدرجة،\n# يتم فرزهم أبجدياً حسب أسمائهم. تأخذ الدالة مصفوفة من المصفوفات كمعامل،\n# حيث تحتوي كل مصفوفة فرعية على اسم الطالب ودرجته. تعيد الدالة مصفوفة من\n# أسماء الطلاب مرتبة حسب المعايير المذكورة.\n#\n# مثال:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "sw": "# Hupanga orodha ya wanafunzi kwa alama zao kwa mpangilio wa kushuka. Ikiwa wanafunzi wawili wana alama sawa,\n# wanapangwa kwa alfabeti kwa majina yao. Kazi inachukua safu ya safu kama hoja,\n# ambapo kila safu ndogo ina jina la mwanafunzi na alama zao. Kazi inarejesha safu ya\n# majina ya wanafunzi yaliyopangwa kulingana na vigezo vilivyotajwa.\n#\n# Mfano:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "tr": "# Öğrencileri puanlarına göre azalan sırayla sıralar. Eğer iki öğrenci aynı puana sahipse,\n# isimlerine göre alfabetik olarak sıralanırlar. Fonksiyon, bir dizi diziyi argüman olarak alır,\n# her alt dizi bir öğrencinin ismini ve puanını içerir. Fonksiyon, belirtilen kriterlere göre\n# sıralanmış öğrenci isimlerinin bir dizisini döndürür.\n#\n# Örnek:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "vi": "# Sắp xếp danh sách học sinh theo điểm số của họ theo thứ tự giảm dần. Nếu hai học sinh có cùng điểm số,\n# họ sẽ được sắp xếp theo thứ tự bảng chữ cái của tên. Hàm nhận một mảng các mảng làm đối số,\n# trong đó mỗi mảng con chứa tên của học sinh và điểm số của họ. Hàm trả về một mảng các \n# tên học sinh được sắp xếp theo tiêu chí đã đề cập.\n#\n# Ví dụ:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)"
    },
    "prompt_bertscore": {
      "es": "0.9943026847807763",
      "arb": "0.9943092395833505",
      "sw": "0.990104830307985",
      "tr": "0.9714740950884366",
      "vi": "0.9893557951411024"
    },
    "canonical_solution": "    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end",
    "instruction": {
      "en": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9151651628903803",
      "tr": "0.8566170704069177",
      "vi": "0.9273999998406053"
    },
    "level": "",
    "test": "raise 'Test failed' unless sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]]) == [\"bbb\", \"ccc\", \"aaa\"]\nraise 'Test failed' unless sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]]) == [\"charlie\", \"alice\", \"bob\"]\nraise 'Test failed' unless sort_students_by_score([[\"zoe\", 95], [\"adam\", 95], [\"mia\", 88]]) == [\"adam\", \"zoe\", \"mia\"]\nraise 'Test failed' unless sort_students_by_score([[\"lara\", 70], [\"max\", 70], [\"sam\", 70]]) == [\"lara\", \"max\", \"sam\"]\nraise 'Test failed' unless sort_students_by_score([[\"john\", 100]]) == [\"john\"]\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_students_by_score",
    "signature": "def sort_students_by_score(student_scores)",
    "docstring": {
      "en": "Sorts a list of students by their scores in descending order. If two students have the same score,\nthey are sorted alphabetically by their names. The function takes an array of arrays as an argument,\nwhere each sub-array contains a student's name and their score. The function returns an array of\nstudent names sorted as per the mentioned criteria.\n\nExample:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "es": "Ordena una lista de estudiantes por sus puntajes en orden descendente. Si dos estudiantes tienen el mismo puntaje, se ordenan alfabéticamente por sus nombres. La función toma un arreglo de arreglos como argumento, donde cada sub-arreglo contiene el nombre de un estudiante y su puntaje. La función devuelve un arreglo de nombres de estudiantes ordenados según los criterios mencionados.\n\nEjemplo:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "arb": "يقوم بفرز قائمة الطلاب حسب درجاتهم بترتيب تنازلي. إذا كان لدى طالبين نفس الدرجة، يتم فرزهم أبجدياً حسب أسمائهم. تأخذ الدالة مصفوفة من المصفوفات كوسيطة، حيث تحتوي كل مصفوفة فرعية على اسم الطالب ودرجته. تُرجع الدالة مصفوفة من أسماء الطلاب مرتبة وفقاً للمعايير المذكورة.\n\nمثال:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "sw": "Hupanga orodha ya wanafunzi kwa alama zao kwa mpangilio wa kushuka. Ikiwa wanafunzi wawili wana alama sawa, wanapangwa kwa mpangilio wa alfabeti kwa majina yao. Kazi inachukua safu ya safu kama hoja, ambapo kila safu ndogo ina jina la mwanafunzi na alama zao. Kazi inarejesha safu ya majina ya wanafunzi yaliyopangwa kulingana na vigezo vilivyotajwa.\n\nMfano:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "tr": "Öğrencilerin bir listesini puanlarına göre azalan sırayla sıralar. İki öğrenci aynı puana sahipse, adlarına göre alfabetik olarak sıralanırlar. Fonksiyon, bir dizi diziyi argüman olarak alır, burada her alt dizi bir öğrencinin adını ve puanını içerir. Fonksiyon, belirtilen kriterlere göre sıralanmış öğrenci adlarının bir dizisini döndürür.\n\nÖrnek:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "vi": "Sắp xếp danh sách sinh viên theo điểm số của họ theo thứ tự giảm dần. Nếu hai sinh viên có cùng điểm số, họ sẽ được sắp xếp theo thứ tự bảng chữ cái của tên. Hàm nhận một mảng các mảng làm đối số, trong đó mỗi mảng con chứa tên sinh viên và điểm số của họ. Hàm trả về một mảng tên sinh viên được sắp xếp theo tiêu chí đã đề cập.\n\nVí dụ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]"
    },
    "docstring_bertscore": {
      "es": "0.9905231458904444",
      "arb": "0.9935856291052404",
      "sw": "0.9857297975353105",
      "tr": "0.9884512323858695",
      "vi": "0.9791612894648678"
    }
  },
  {
    "task_id": "Ruby/11",
    "prompt": {
      "en": "# Calculates the total number of drinks a customer can enjoy under a promotional offer.\n# Under this offer, for every 3 bottle caps, the customer can get 1 additional drink.\n# The promotion continues as long as the customer has enough caps for exchange.\n#\n# The function takes a single integer argument, n, which represents the initial number\n# of drinks purchased. It returns an integer representing the total number of drinks\n# the customer can enjoy, including those received through the promotion.\n#\n# Examples:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "es": "# Calcula el número total de bebidas que un cliente puede disfrutar bajo una oferta promocional.\n# Bajo esta oferta, por cada 3 tapas de botella, el cliente puede obtener 1 bebida adicional.\n# La promoción continúa mientras el cliente tenga suficientes tapas para el intercambio.\n#\n# La función toma un solo argumento entero, n, que representa el número inicial\n# de bebidas compradas. Devuelve un entero que representa el número total de bebidas\n# que el cliente puede disfrutar, incluidas las recibidas a través de la promoción.\n#\n# Ejemplos:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "arb": "# يحسب العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها تحت عرض ترويجي.\n# بموجب هذا العرض، لكل 3 أغطية زجاجات، يمكن للعميل الحصول على مشروب إضافي واحد.\n# يستمر العرض طالما أن العميل لديه أغطية كافية للتبادل.\n#\n# تأخذ الدالة وسيطًا واحدًا من نوع عدد صحيح، n، والذي يمثل العدد الأولي\n# للمشروبات المشتراة. تُرجع عددًا صحيحًا يمثل العدد الإجمالي للمشروبات\n# التي يمكن للعميل الاستمتاع بها، بما في ذلك تلك التي تم الحصول عليها من خلال العرض الترويجي.\n#\n# أمثلة:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "sw": "# Inahesabu jumla ya vinywaji ambavyo mteja anaweza kufurahia chini ya ofa ya matangazo.\n# Chini ya ofa hii, kwa kila kofia 3 za chupa, mteja anaweza kupata kinywaji 1 cha ziada.\n# Ofa inaendelea mradi mteja ana kofia za kutosha kwa kubadilishana.\n#\n# Kazi inapokea hoja moja ya nambari nzima, n, ambayo inawakilisha idadi ya awali\n# ya vinywaji vilivyonunuliwa. Inarudisha nambari nzima inayowakilisha jumla ya vinywaji\n# mteja anaweza kufurahia, ikiwa ni pamoja na vile vilivyopatikana kupitia ofa.\n#\n# Mifano:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "tr": "# Bir müşterinin bir promosyon teklifi kapsamında tadını çıkarabileceği toplam içecek sayısını hesaplar.\n# Bu teklif kapsamında, her 3 şişe kapağı için müşteri 1 ek içecek alabilir.\n# Müşterinin değişim için yeterli kapağı olduğu sürece promosyon devam eder.\n#\n# Fonksiyon, satın alınan ilk içecek sayısını temsil eden tek bir tam sayı argümanı n alır.\n# Müşterinin promosyon yoluyla aldığı içecekler de dahil olmak üzere tadını çıkarabileceği toplam içecek sayısını\n# temsil eden bir tam sayı döndürür.\n#\n# Örnekler:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "vi": "# Tính tổng số đồ uống mà khách hàng có thể thưởng thức theo một chương trình khuyến mãi.\n# Theo chương trình này, cứ mỗi 3 nắp chai, khách hàng có thể nhận thêm 1 đồ uống.\n# Chương trình khuyến mãi tiếp tục miễn là khách hàng có đủ nắp chai để đổi.\n#\n# Hàm nhận một tham số nguyên duy nhất, n, đại diện cho số lượng đồ uống ban đầu\n# đã mua. Nó trả về một số nguyên đại diện cho tổng số đồ uống\n# mà khách hàng có thể thưởng thức, bao gồm cả những đồ uống nhận được qua chương trình khuyến mãi.\n#\n# Ví dụ:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)"
    },
    "prompt_bertscore": {
      "es": "0.9944238493132076",
      "arb": "0.9903251114005527",
      "sw": "0.9873514159660793",
      "tr": "0.9834233015507334",
      "vi": "0.9613542744354712"
    },
    "canonical_solution": "    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end",
    "instruction": {
      "en": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9151651628903803",
      "tr": "0.8889821033231234",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless total_drinks_with_promo(100) == 149\nraise 'Test failed' unless total_drinks_with_promo(3) == 4\nraise 'Test failed' unless total_drinks_with_promo(9) == 13\nraise 'Test failed' unless total_drinks_with_promo(10) == 14\nraise 'Test failed' unless total_drinks_with_promo(1) == 1\n  \nputs 'All tests passed!'",
    "entry_point": "total_drinks_with_promo",
    "signature": "def total_drinks_with_promo(n)",
    "docstring": {
      "en": "Calculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n\nExamples:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "es": "Calcula el número total de bebidas que un cliente puede disfrutar bajo una oferta promocional.  \nBajo esta oferta, por cada 3 tapas de botella, el cliente puede obtener 1 bebida adicional.  \nLa promoción continúa mientras el cliente tenga suficientes tapas para el intercambio.  \n\nLa función toma un solo argumento entero, n, que representa el número inicial  \nde bebidas compradas. Devuelve un entero que representa el número total de bebidas  \nque el cliente puede disfrutar, incluidas las recibidas a través de la promoción.  \n\nEjemplos:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4",
      "arb": "يحسب العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها تحت عرض ترويجي.  \nتحت هذا العرض، لكل 3 أغطية زجاجات، يمكن للعميل الحصول على مشروب إضافي واحد.  \nيستمر العرض طالما أن العميل لديه أغطية كافية للتبادل.\n\nيعيدالحجج:  \n    n (int): يمثل العدد الأولي للمشروبات المشتراة.  \n\nيعيد:  \n    int: يمثل العدد الإجمالي للمشروبات التي يمكن للعميل الاستمتاع بها، بما في ذلك تلك التي تم الحصول عليها من خلال العرض الترويجي.\n\nأمثلة:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4  ",
      "sw": "Hesabu jumla ya vinywaji ambavyo mteja anaweza kufurahia chini ya ofa ya matangazo. Chini ya ofa hii, kwa kila kofia 3 za chupa, mteja anaweza kupata kinywaji 1 cha ziada. Matangazo yanaendelea mradi mteja ana kofia za kutosha kwa kubadilisha.\n\nKazi inachukua hoja moja ya nambari nzima, n, ambayo inawakilisha idadi ya awali ya vinywaji vilivyonunuliwa. Inarudisha nambari nzima inayowakilisha jumla ya vinywaji ambavyo mteja anaweza kufurahia, ikiwa ni pamoja na vile vilivyopatikana kupitia matangazo.\n\nMifano:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "tr": "İçinde bulunduğu promosyon teklifi kapsamında bir müşterinin toplamda kaç içecek alabileceğini hesaplar.\nBu teklif kapsamında, her 3 şişe kapağı için müşteri 1 ek içecek alabilir.\nMüşterinin değişim için yeterli kapağı olduğu sürece promosyon devam eder.\n\nFonksiyon, n adlı tek bir tamsayı argümanı alır ve bu, satın alınan başlangıçtaki içecek sayısını temsil eder. Fonksiyon, müşteri tarafından promosyon yoluyla alınanlar da dahil olmak üzere, toplamda kaç içecek alınabileceğini temsil eden bir tamsayı döndürür.\n\nÖrnekler:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "vi": "Tính tổng số đồ uống mà khách hàng có thể thưởng thức theo một chương trình khuyến mãi.  \nTheo chương trình này, cứ mỗi 3 nắp chai, khách hàng có thể nhận thêm 1 đồ uống.  \nChương trình khuyến mãi tiếp tục miễn là khách hàng có đủ nắp để đổi.\n\nHàm nhận một đối số kiểu số nguyên, n, đại diện cho số lượng đồ uống ban đầu đã mua. Nó trả về một số nguyên đại diện cho tổng số đồ uống mà khách hàng có thể thưởng thức, bao gồm cả những đồ uống nhận được thông qua chương trình khuyến mãi.\n\nVí dụ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9933456836049502",
      "arb": "0.920196073181232",
      "sw": "0.9857937565180037",
      "tr": "0.9475729013385085",
      "vi": "0.9575648040260876"
    }
  },
  {
    "task_id": "Ruby/12",
    "prompt": {
      "en": "# Determines the maximum length of a string that can be accepted by a simplified regular expression.\n# The function takes a single argument, regex, which is a string representing a regular expression \n# composed only of 'x', '(', ')', and '|'. The function returns the length of the longest string \n# that can be accepted by this regular expression.\n#\n# Example:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "es": "# Determina la longitud máxima de una cadena que puede ser aceptada por una expresión regular simplificada.\n# La función toma un solo argumento, regex, que es una cadena que representa una expresión regular \n# compuesta solo de 'x', '(', ')', y '|'. La función devuelve la longitud de la cadena más larga \n# que puede ser aceptada por esta expresión regular.\n#\n# Ejemplo:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "arb": "# يحدد الطول الأقصى لسلسلة يمكن قبولها بواسطة تعبير منتظم مبسط.\n# تأخذ الدالة وسيطًا واحدًا، regex، وهو سلسلة تمثل تعبيرًا منتظمًا \n# يتكون فقط من 'x'، '('، ')'، و '|'. تُرجع الدالة طول أطول سلسلة \n# يمكن قبولها بواسطة هذا التعبير المنتظم.\n#\n# مثال:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "sw": "# Huamua urefu wa juu wa kamba ambayo inaweza kukubaliwa na usemi wa kawaida uliorahisishwa.\n# Kazi inachukua hoja moja, regex, ambayo ni kamba inayowakilisha usemi wa kawaida \n# unaojumuisha tu 'x', '(', ')', na '|'. Kazi inarudisha urefu wa kamba ndefu zaidi \n# ambayo inaweza kukubaliwa na usemi huu wa kawaida.\n#\n# Mfano:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "tr": "# Basitleştirilmiş bir düzenli ifade tarafından kabul edilebilecek bir dizgenin maksimum uzunluğunu belirler.\n# Fonksiyon, yalnızca 'x', '(', ')', ve '|' karakterlerinden oluşan bir düzenli ifadeyi temsil eden bir dize olan \n# regex adlı tek bir argüman alır. Fonksiyon, bu düzenli ifade tarafından kabul edilebilecek en uzun dizgenin \n# uzunluğunu döndürür.\n#\n# Örnek:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "vi": "# Xác định độ dài tối đa của một chuỗi có thể được chấp nhận bởi một biểu thức chính quy đơn giản.\n# Hàm nhận một đối số duy nhất, regex, là một chuỗi đại diện cho một biểu thức chính quy \n# chỉ bao gồm 'x', '(', ')', và '|'. Hàm trả về độ dài của chuỗi dài nhất \n# có thể được chấp nhận bởi biểu thức chính quy này.\n#\n# Ví dụ:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)"
    },
    "prompt_bertscore": {
      "es": "0.9940828009489707",
      "arb": "0.9938617253348788",
      "sw": "0.9860579349247801",
      "tr": "0.984941036292221",
      "vi": "0.9888395547807928"
    },
    "canonical_solution": "    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end",
    "instruction": {
      "en": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9141690315294904",
      "tr": "0.852195160864319",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\") == 6\nraise 'Test failed' unless max_regex_string_length(\"x(xx|x)x\") == 4\nraise 'Test failed' unless max_regex_string_length(\"xx|x\") == 2\nraise 'Test failed' unless max_regex_string_length(\"(xx|x)(x|xx)\") == 4\nraise 'Test failed' unless max_regex_string_length(\"x\") == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_regex_string_length",
    "signature": "def max_regex_string_length(regex)",
    "docstring": {
      "en": "Determines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n\nExample:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "es": "Determina la longitud máxima de una cadena que puede ser aceptada por una expresión regular simplificada.  \nLa función toma un solo argumento, regex, que es una cadena que representa una expresión regular compuesta solo de 'x', '(', ')', y '|'. La función devuelve la longitud de la cadena más larga que puede ser aceptada por esta expresión regular.\n\nEjemplo:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "arb": "يحدد الحد الأقصى لطول سلسلة يمكن قبولها بواسطة تعبير منتظم مبسط. تأخذ الدالة وسيطًا واحدًا، regex، وهو سلسلة تمثل تعبيرًا منتظمًا يتكون فقط من 'x'، '('، ')'، و '|'. تُرجع الدالة طول أطول سلسلة يمكن قبولها بواسطة هذا التعبير المنتظم.\n\nمثال:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "sw": "Inabainisha urefu wa juu wa kamba ambayo inaweza kukubaliwa na usemi wa kawaida uliorahisishwa.\nKazi inachukua hoja moja, regex, ambayo ni kamba inayowakilisha usemi wa kawaida\nulio na 'x', '(', ')', na '|'. Kazi inarudisha urefu wa kamba ndefu zaidi\nambayo inaweza kukubaliwa na usemi huu wa kawaida.\n\nMfano:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "tr": "Bir basitleştirilmiş düzenli ifade tarafından kabul edilebilecek maksimum dize uzunluğunu belirler. \nFonksiyon, yalnızca 'x', '(', ')', ve '|' karakterlerinden oluşan bir düzenli ifadeyi temsil eden bir dize olan regex adlı tek bir argüman alır. \nFonksiyon, bu düzenli ifade tarafından kabul edilebilecek en uzun dizenin uzunluğunu döndürür.\n\nÖrnek:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "vi": "Xác định độ dài tối đa của một chuỗi có thể được chấp nhận bởi một biểu thức chính quy đơn giản.  \nHàm nhận một đối số duy nhất, regex, là một chuỗi đại diện cho một biểu thức chính quy  \nchỉ bao gồm 'x', '(', ')', và '|'. Hàm trả về độ dài của chuỗi dài nhất  \ncó thể được chấp nhận bởi biểu thức chính quy này.\n\nVí dụ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4"
    },
    "docstring_bertscore": {
      "es": "0.9909938998934972",
      "arb": "0.992410531771038",
      "sw": "0.9660872391547705",
      "tr": "0.9823532796880985",
      "vi": "0.9846760633639204"
    }
  },
  {
    "task_id": "Ruby/13",
    "prompt": {
      "en": "# Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\n# This function takes an array of numbers and an integer k as arguments. It returns the maximum sum \n# of any three numbers from the array such that this sum is divisible by k. It's guaranteed that there \n# are at least three numbers in the array and that a solution exists.\n#\n# Example:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "es": "# Encuentra la suma máxima de cualquier tres números de un arreglo dado que sea divisible por un número especificado k.\n# Esta función toma un arreglo de números y un entero k como argumentos. Devuelve la suma máxima \n# de cualquier tres números del arreglo tal que esta suma sea divisible por k. Se garantiza que hay \n# al menos tres números en el arreglo y que existe una solución.\n#\n# Ejemplo:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "arb": "# يجد أكبر مجموع لأي ثلاثة أرقام من مصفوفة معينة يكون قابلاً للقسمة على عدد محدد k.\n# تأخذ هذه الدالة مصفوفة من الأرقام وعددًا صحيحًا k كوسيطات. تُرجع أكبر مجموع \n# لأي ثلاثة أرقام من المصفوفة بحيث يكون هذا المجموع قابلاً للقسمة على k. من المضمون أن هناك \n# على الأقل ثلاثة أرقام في المصفوفة وأن هناك حلًا موجودًا.\n#\n# مثال:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "sw": "# Inapata jumla ya juu zaidi ya nambari yoyote tatu kutoka kwenye safu iliyotolewa ambayo inagawanyika kwa nambari maalum k.\n# Kazi hii inachukua safu ya nambari na nambari nzima k kama hoja. Inarudisha jumla ya juu zaidi \n# ya nambari yoyote tatu kutoka kwenye safu hiyo ambapo jumla hii inagawanyika kwa k. Inahakikishwa kwamba kuna \n# angalau nambari tatu kwenye safu na kwamba suluhisho lipo.\n#\n# Mfano:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "tr": "# Belirtilen bir k sayısına tam bölünebilen, verilen bir dizideki herhangi üç sayının maksimum toplamını bulur.\n# Bu fonksiyon, bir dizi sayı ve bir tamsayı k'yi argüman olarak alır. Dizideki herhangi üç sayının toplamının \n# k'ye tam bölünebildiği maksimum toplamı döndürür. Dizide en az üç sayının olduğu ve bir çözümün mevcut olduğu garanti edilir.\n#\n# Örnek:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "vi": "# Tìm tổng lớn nhất của bất kỳ ba số nào từ một mảng cho trước mà chia hết cho một số k xác định.\n# Hàm này nhận một mảng số và một số nguyên k làm tham số. Nó trả về tổng lớn nhất \n# của bất kỳ ba số nào từ mảng sao cho tổng này chia hết cho k. Đảm bảo rằng có ít nhất ba số trong mảng và rằng có tồn tại một giải pháp.\n#\n# Ví dụ:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)"
    },
    "prompt_bertscore": {
      "es": "0.9931373203352446",
      "arb": "0.9895117199902148",
      "sw": "0.9789602755192605",
      "tr": "0.9716715336871853",
      "vi": "0.9680614265118762"
    },
    "canonical_solution": "    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end",
    "instruction": {
      "en": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nRuby kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9428772791308437",
      "tr": "0.8648777106933966",
      "vi": "0.9273999998406053"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_sum_divisible_by_k([1, 2, 3, 4], 3) == 9\nraise 'Test failed' unless max_sum_divisible_by_k([4, 5, 10, 20], 5) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([6, 12, 17, 23, 29], 7) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([7, 14, 21, 28], 7) == 63\nraise 'Test failed' unless max_sum_divisible_by_k([10, 15, 25, 30, 40], 10) == 80\n\n\nputs 'All tests passed!'",
    "entry_point": "max_sum_divisible_by_k",
    "signature": "def max_sum_divisible_by_k(numbers, k)",
    "docstring": {
      "en": "Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n\nExample:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "es": "Encuentra la suma máxima de cualquier tres números de un arreglo dado que sea divisible por un número especificado k.\nEsta función toma un arreglo de números y un entero k como argumentos. Devuelve la suma máxima\nde cualquier tres números del arreglo tal que esta suma sea divisible por k. Se garantiza que hay al menos\ntres números en el arreglo y que existe una solución.\n\nEjemplo:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "arb": "يعثر على أكبر مجموع لأي ثلاثة أرقام من مصفوفة معينة يكون قابلاً للقسمة على عدد محدد k.\nتأخذ هذه الدالة مصفوفة من الأرقام وعددًا صحيحًا k كوسائط. تُرجع أكبر مجموع لأي ثلاثة أرقام من المصفوفة بحيث يكون هذا المجموع قابلاً للقسمة على k. من المضمون أن هناك على الأقل ثلاثة أرقام في المصفوفة وأن هناك حلاً موجودًا.\n\nمثال:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "sw": "Inapata jumla ya juu zaidi ya nambari tatu zozote kutoka kwenye safu iliyotolewa ambayo inagawanyika kwa nambari maalum k. \nKazi hii inachukua safu ya nambari na nambari kamili k kama hoja. Inarejesha jumla ya juu zaidi ya nambari tatu zozote kutoka kwenye safu hiyo ili kwamba jumla hii inagawanyika kwa k. Inahakikishwa kwamba kuna angalau nambari tatu kwenye safu na kwamba suluhisho lipo.\n\nMfano:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "tr": "Verilen bir diziden belirli bir k sayısına bölünebilen herhangi üç sayının maksimum toplamını bulur.\nBu fonksiyon, bir dizi sayı ve bir tamsayı k'yi argüman olarak alır. Dizideki herhangi üç sayının toplamının k'ye bölünebildiği maksimum toplamı döndürür. Dizide en az üç sayı olduğu ve bir çözümün mevcut olduğu garanti edilir.\n\nÖrnek:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "vi": "Tìm tổng lớn nhất của bất kỳ ba số nào từ một mảng cho trước mà chia hết cho một số k được chỉ định.\nHàm này nhận một mảng số và một số nguyên k làm đối số. Nó trả về tổng lớn nhất\ncủa bất kỳ ba số nào từ mảng sao cho tổng này chia hết cho k. Đảm bảo rằng có ít nhất ba số trong mảng và rằng một giải pháp tồn tại.\n\nVí dụ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35"
    },
    "docstring_bertscore": {
      "es": "0.9919932093404836",
      "arb": "0.99001365896309",
      "sw": "0.9763512654643672",
      "tr": "0.9618464805196756",
      "vi": "0.9691113867060266"
    }
  },
  {
    "task_id": "Ruby/14",
    "prompt": {
      "en": "# Calculates the difference in the number of victories between the most and least successful teams.\n# This function takes a string, team_sequence, representing the sequence of winning teams, where each team\n# is identified by a lowercase letter. It returns an integer representing the difference in the number\n# of victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n#\n# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "es": "# Calcula la diferencia en el número de victorias entre los equipos más y menos exitosos.\n# Esta función toma una cadena, team_sequence, que representa la secuencia de equipos ganadores, donde cada equipo\n# está identificado por una letra minúscula. Devuelve un entero que representa la diferencia en el número\n# de victorias entre el equipo que ganó más y el equipo que ganó menos (excluyendo equipos con cero victorias).\n#\n# Ejemplo:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "arb": "# يحسب الفرق في عدد الانتصارات بين الفرق الأكثر والأقل نجاحًا.\n# تأخذ هذه الدالة سلسلة نصية، team_sequence، تمثل تسلسل الفرق الفائزة، حيث يتم تحديد كل فريق بحرف صغير.\n# تعيد عددًا صحيحًا يمثل الفرق في عدد الانتصارات بين الفريق الذي فاز بأكبر عدد والفريق الذي فاز بأقل عدد (باستثناء الفرق التي لم تحقق أي انتصارات).\n#\n# مثال:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "sw": "# Inahesabu tofauti ya idadi ya ushindi kati ya timu zilizofanikiwa zaidi na zile zilizofanikiwa kidogo.\n# Kazi hii inachukua kamba, team_sequence, inayowakilisha mlolongo wa timu zilizoshinda, ambapo kila timu\n# inatambulishwa na herufi ndogo. Inarudisha nambari ya integer inayowakilisha tofauti ya idadi\n# ya ushindi kati ya timu iliyoshinda zaidi na timu iliyoshinda kidogo (ikiondoa timu ambazo hazijashinda kabisa).\n#\n# Mfano:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "tr": "# En başarılı ve en az başarılı takımlar arasındaki galibiyet sayısı farkını hesaplar.\n# Bu fonksiyon, kazanan takımların dizisini temsil eden bir string, team_sequence, alır, burada her takım\n# küçük bir harfle tanımlanır. En çok kazanan takım ile en az kazanan takım arasındaki galibiyet sayısı farkını\n# temsil eden bir tamsayı döndürür (galibiyeti olmayan takımlar hariç).\n#\n# Örnek:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "vi": "# Tính toán sự chênh lệch về số chiến thắng giữa các đội thành công nhất và ít thành công nhất.\n# Hàm này nhận một chuỗi, team_sequence, đại diện cho chuỗi các đội chiến thắng, trong đó mỗi đội\n# được xác định bằng một chữ cái thường. Nó trả về một số nguyên đại diện cho sự chênh lệch về số\n# chiến thắng giữa đội thắng nhiều nhất và đội thắng ít nhất (không bao gồm các đội không có chiến thắng nào).\n#\n# Ví dụ:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)"
    },
    "prompt_bertscore": {
      "es": "0.9914068524556686",
      "arb": "0.9793342965267492",
      "sw": "0.9705836350902572",
      "tr": "0.969523544746674",
      "vi": "0.9830371640900016"
    },
    "canonical_solution": "    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end",
    "instruction": {
      "en": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nAşağıdaki Ruby kodunun kısa bir doğal dil açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8955577620872833",
      "sw": "0.9141690315294904",
      "tr": "0.9162697464393154",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'",
    "entry_point": "victory_gap_in_teams",
    "signature": "def victory_gap_in_teams(team_sequence)",
    "docstring": {
      "en": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n\nExample:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "es": "Calcula la diferencia en el número de victorias entre los equipos más y menos exitosos.  \nEsta función toma una cadena, team_sequence, que representa la secuencia de equipos ganadores, donde cada equipo  \nestá identificado por una letra minúscula. Devuelve un entero que representa la diferencia en el número  \nde victorias entre el equipo que ganó más y el equipo que ganó menos (excluyendo equipos con cero victorias).\n\nEjemplo:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "arb": "يحسب الفرق في عدد الانتصارات بين الفرق الأكثر والأقل نجاحًا.  \nتأخذ هذه الدالة سلسلة نصية، team_sequence، تمثل تسلسل الفرق الفائزة، حيث يتم تحديد كل فريق بحرف صغير. تعيد عددًا صحيحًا يمثل الفرق في عدد الانتصارات بين الفريق الذي فاز بأكبر عدد والفريق الذي فاز بأقل عدد (باستثناء الفرق التي لم تحقق أي انتصارات).\n\nمثال:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "sw": "Hesabu tofauti ya idadi ya ushindi kati ya timu zilizofanikiwa zaidi na zile zisizofanikiwa zaidi. \nKazi hii inachukua kamba, team_sequence, inayowakilisha mlolongo wa timu zilizoshinda, ambapo kila timu \ninatambulishwa na herufi ndogo. Inarudisha nambari kamili inayowakilisha tofauti ya idadi \nya ushindi kati ya timu iliyoshinda zaidi na timu iliyoshinda kidogo zaidi (ikiondoa timu ambazo hazijashinda kabisa).\n\nMfano:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "tr": "En başarılı ve en az başarılı takımlar arasındaki zafer sayısı farkını hesaplar.\nBu fonksiyon, her takımın küçük harfle tanımlandığı kazanan takımların dizisini temsil eden bir string, team_sequence, alır. En çok kazanan takım ile en az kazanan takım arasındaki zafer sayısı farkını temsil eden bir tamsayı döndürür (zaferi olmayan takımlar hariç).\n\nÖrnek:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "vi": "Tính toán sự khác biệt về số lượng chiến thắng giữa các đội thành công nhất và ít thành công nhất.  \nHàm này nhận vào một chuỗi, team_sequence, đại diện cho chuỗi các đội chiến thắng, trong đó mỗi đội  \nđược xác định bằng một chữ cái thường. Nó trả về một số nguyên đại diện cho sự khác biệt về số lượng  \nchiến thắng giữa đội thắng nhiều nhất và đội thắng ít nhất (không bao gồm các đội không có chiến thắng nào).  \n\nVí dụ:  \n>>> victory_gap_in_teams(\"abaabcaa\")  \n4  \n>>> victory_gap_in_teams(\"abcd\")  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.986534846469645",
      "arb": "0.9827954309162821",
      "sw": "0.9519832903190072",
      "tr": "0.9439800750063494",
      "vi": "0.9739104953422105"
    }
  },
  {
    "task_id": "Ruby/15",
    "prompt": {
      "en": "# Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\n# The function takes a single argument, n, which is the height of the building (number of floors).\n# It returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n#\n# The problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n#\n# Example:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "es": "# Determina el número máximo de pruebas de caída necesarias para encontrar la altura de tolerancia de caída de un dispositivo desde un edificio con una altura dada.\n# La función toma un solo argumento, n, que es la altura del edificio (número de pisos).\n# Devuelve el número máximo de pruebas necesarias para encontrar el piso exacto desde el cual, si el dispositivo se deja caer, se romperá.\n#\n# El problema asume el peor de los casos, donde el resultado de cada prueba es el menos favorable, requiriendo así el número máximo de pruebas.\n#\n# Ejemplo:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "arb": "# يحدد الحد الأقصى لعدد اختبارات الإسقاط اللازمة للعثور على ارتفاع تحمل الإسقاط لجهاز من مبنى بارتفاع معين.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو ارتفاع المبنى (عدد الطوابق).\n# تُرجع الحد الأقصى لعدد الاختبارات اللازمة للعثور على الطابق الدقيق الذي إذا أسقط الجهاز منه، سيتحطم.\n#\n# تفترض المشكلة أسوأ سيناريو، حيث تكون نتيجة كل اختبار هي الأقل تفضيلًا، مما يتطلب الحد الأقصى من الاختبارات.\n#\n# مثال:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "sw": "# Huamua idadi kubwa zaidi ya majaribio ya kuacha kifaa ili kupata urefu wa uvumilivu wa kuacha kifaa kutoka kwenye jengo lenye urefu uliotolewa.\n# Kazi inachukua hoja moja, n, ambayo ni urefu wa jengo (idadi ya sakafu).\n# Inarejesha idadi kubwa zaidi ya majaribio yanayohitajika kupata sakafu halisi ambayo kifaa kikidondoshwa, kitavunjika.\n#\n# Shida inadhani hali mbaya zaidi, ambapo matokeo ya kila jaribio ni yasiyofaa zaidi, hivyo kuhitaji idadi kubwa zaidi ya majaribio.\n#\n# Mfano:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "tr": "# Bir cihazın bir binadan düşme toleransı yüksekliğini bulmak için gereken maksimum düşme testi sayısını belirler.\n# Fonksiyon, bina yüksekliği (kat sayısı) olan n adlı tek bir argüman alır.\n# Cihazın bırakıldığında kırılacağı kesin katı bulmak için gereken maksimum test sayısını döndürür.\n#\n# Problem, her testin sonucunun en az elverişli olduğu en kötü senaryoyu varsayar, bu nedenle maksimum test sayısı gereklidir.\n#\n# Örnek:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "vi": "# Xác định số lần thử nghiệm thả tối đa cần thiết để tìm độ cao chịu đựng của thiết bị khi thả từ một tòa nhà với chiều cao cho trước.\n# Hàm nhận một đối số duy nhất, n, là chiều cao của tòa nhà (số tầng).\n# Nó trả về số lần thử nghiệm tối đa cần thiết để tìm tầng chính xác mà nếu thiết bị bị thả từ đó, nó sẽ bị vỡ.\n#\n# Vấn đề giả định kịch bản xấu nhất, nơi kết quả của mỗi thử nghiệm là ít thuận lợi nhất, do đó yêu cầu số lần thử nghiệm tối đa.\n#\n# Ví dụ:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)"
    },
    "prompt_bertscore": {
      "es": "0.9865207437125915",
      "arb": "0.9803572429890789",
      "sw": "0.9418763806408089",
      "tr": "0.9588330590089953",
      "vi": "0.9808039627160263"
    },
    "canonical_solution": "    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end",
    "instruction": {
      "en": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9063986110234055",
      "sw": "0.9428772791308437",
      "tr": "0.8500624664631474",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_drop_test_height(3) == 2\nraise 'Test failed' unless max_drop_test_height(10) == 4\nraise 'Test failed' unless max_drop_test_height(15) == 5\nraise 'Test failed' unless max_drop_test_height(6) == 3\nraise 'Test failed' unless max_drop_test_height(100) == 9\n\n\nputs 'All tests passed!'",
    "entry_point": "max_drop_test_height",
    "signature": "def max_drop_test_height(n)",
    "docstring": {
      "en": "Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\nThe function takes a single argument, n, which is the height of the building (number of floors).\nIt returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n\nThe problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n\nExample:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "es": "Determina el número máximo de pruebas de caída necesarias para encontrar la altura de tolerancia de caída de un dispositivo desde un edificio con una altura dada.  \nLa función toma un solo argumento, n, que es la altura del edificio (número de pisos).  \nDevuelve el número máximo de pruebas necesarias para encontrar el piso exacto desde el cual, si el dispositivo se deja caer, se romperá.\n\nEl problema asume el peor de los casos, donde el resultado de cada prueba es el menos favorable, requiriendo así el número máximo de pruebas.\n\nEjemplo:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "arb": "يحدد الحد الأقصى لعدد اختبارات الإسقاط اللازمة للعثور على ارتفاع تحمل الإسقاط لجهاز من مبنى بارتفاع معين.  \nتأخذ الدالة وسيطًا واحدًا، n، وهو ارتفاع المبنى (عدد الطوابق).  \nتعيد الدالة الحد الأقصى لعدد الاختبارات اللازمة للعثور على الطابق الدقيق الذي إذا أسقط منه الجهاز، فسوف ينكسر.  \n\nتفترض المشكلة أسوأ سيناريو، حيث تكون نتيجة كل اختبار هي الأقل تفضيلاً، مما يتطلب الحد الأقصى لعدد الاختبارات.  \n\nمثال:  \n>>> max_drop_test_height(3)  \n2  \n>>> max_drop_test_height(10)  \n4  ",
      "sw": "Inabainisha idadi kubwa zaidi ya majaribio ya kudondosha yanayohitajika ili kupata urefu wa uvumilivu wa kudondosha kifaa kutoka kwenye jengo lenye urefu uliotolewa.\nKazi inachukua hoja moja, n, ambayo ni urefu wa jengo (idadi ya sakafu).\nInarudisha idadi kubwa zaidi ya majaribio yanayohitajika ili kupata sakafu halisi ambayo kifaa kikidondoshwa, kitavunjika.\n\nTatizo linadhani hali mbaya zaidi, ambapo matokeo ya kila jaribio ni yasiyofaa zaidi, hivyo kuhitaji idadi kubwa zaidi ya majaribio.\n\nMfano:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "tr": "Bir cihazın bir binadan düşme tolerans yüksekliğini bulmak için gereken maksimum düşme testi sayısını belirler.\nFonksiyon, bina yüksekliğini (kat sayısı) temsil eden tek bir argüman, n, alır.\nCihazın bırakıldığında kırılacağı kesin katı bulmak için gereken maksimum test sayısını döndürür.\n\nProblem, her testin sonucunun en az elverişli olduğu en kötü senaryoyu varsayar, bu nedenle maksimum test sayısını gerektirir.\n\nÖrnek:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "vi": "Xác định số lần thử nghiệm thả tối đa cần thiết để tìm độ cao chịu đựng của một thiết bị khi thả từ một tòa nhà với chiều cao cho trước. \nHàm này nhận một đối số duy nhất, n, là chiều cao của tòa nhà (số tầng). \nNó trả về số lần thử nghiệm tối đa cần thiết để tìm ra chính xác tầng mà nếu thiết bị bị thả từ đó, nó sẽ bị vỡ.\n\nVấn đề giả định kịch bản xấu nhất, nơi kết quả của mỗi thử nghiệm là ít thuận lợi nhất, do đó yêu cầu số lần thử nghiệm tối đa.\n\nVí dụ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9813420524182499",
      "arb": "0.9736411525455272",
      "sw": "0.9725085621128663",
      "tr": "0.9560832200139483",
      "vi": "0.9750786406130767"
    }
  },
  {
    "task_id": "Ruby/16",
    "prompt": {
      "en": "# Computes the repeated sum of digits of a given number string until it reduces to a single digit.\n# The function takes a single argument, `input_string`, which is a string representing a non-negative number.\n# It repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n#\n# Example:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "es": "# Calcula la suma repetida de los dígitos de una cadena de número dada hasta que se reduce a un solo dígito.\n# La función toma un solo argumento, `input_string`, que es una cadena que representa un número no negativo.\n# Suma repetidamente los dígitos del número hasta que la suma sea un solo dígito, luego devuelve este único dígito.\n#\n# Ejemplo:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "arb": "# يحسب مجموع الأرقام المتكرر لسلسلة رقمية معطاة حتى يتم تقليصها إلى رقم واحد.\n# تأخذ الدالة وسيطًا واحدًا، `input_string`، وهو سلسلة تمثل رقمًا غير سالب.\n# تقوم بجمع الأرقام في الرقم بشكل متكرر حتى يصبح المجموع رقمًا واحدًا، ثم تعيد هذا الرقم الواحد.\n#\n# مثال:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "sw": "# Inahesabu jumla ya kurudiwa ya tarakimu za mfuatano wa namba uliyopewa hadi inapopungua kuwa tarakimu moja.\n# Kazi inachukua hoja moja, `input_string`, ambayo ni mfuatano unaowakilisha namba isiyo hasi.\n# Inarudia kujumlisha tarakimu za namba hadi jumla iwe tarakimu moja, kisha inarudisha tarakimu hii moja.\n#\n# Mfano:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "tr": "# Verilen bir sayı dizisinin rakamlarının tekrar eden toplamını tek bir rakama indirgenene kadar hesaplar.\n# Fonksiyon, `input_string` adlı tek bir argüman alır, bu argüman negatif olmayan bir sayıyı temsil eden bir dizgidir.\n# Sayının rakamlarını tekrar tekrar toplar, toplam tek bir rakam olana kadar devam eder ve bu tek rakamı döndürür.\n#\n# Örnek:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "vi": "# Tính tổng lặp lại của các chữ số của một chuỗi số cho trước cho đến khi nó giảm xuống còn một chữ số.\n# Hàm nhận một đối số duy nhất, `input_string`, là một chuỗi đại diện cho một số không âm.\n# Nó liên tục cộng các chữ số của số cho đến khi tổng là một chữ số duy nhất, sau đó trả về chữ số này.\n#\n# Ví dụ:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)"
    },
    "prompt_bertscore": {
      "es": "0.9758695867903576",
      "arb": "0.9774598216209229",
      "sw": "0.9814407717176242",
      "tr": "0.9682260910977541",
      "vi": "0.9817556008715644"
    },
    "canonical_solution": "    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end",
    "instruction": {
      "en": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9151651628903803",
      "tr": "0.864885854539019",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless digit_sum_to_single(\"35379\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"24815\") == 2\nraise 'Test failed' unless digit_sum_to_single(\"9999\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"12345\") == 6\nraise 'Test failed' unless digit_sum_to_single(\"0\") == 0\n  \n\nputs 'All tests passed!'",
    "entry_point": "digit_sum_to_single",
    "signature": "def digit_sum_to_single(input_string)",
    "docstring": {
      "en": "Computes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n\nExample:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "es": "Calcula la suma repetida de los dígitos de una cadena de número dada hasta que se reduzca a un solo dígito.\nLa función toma un único argumento, `input_string`, que es una cadena que representa un número no negativo.\nSuma repetidamente los dígitos del número hasta que la suma sea un solo dígito, luego devuelve este único dígito.\n\nEjemplo:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "arb": "تحسب مجموع الأرقام المتكرر لسلسلة رقم معطاة حتى يتم تقليصها إلى رقم واحد.\n\nتأخذ الدالة وسيطًا واحدًا، `input_string`، وهو سلسلة تمثل رقمًا غير سالب. تقوم بجمع أرقام الرقم بشكل متكرر حتى يصبح المجموع رقمًا واحدًا، ثم تعيد هذا الرقم الواحد.\n\nمثال:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "sw": "Hesabu jumla ya kurudiwa ya tarakimu za mfuatano wa namba uliyopewa hadi inapopunguzwa kuwa tarakimu moja.\nKazi hii inachukua hoja moja, `input_string`, ambayo ni mfuatano wa herufi unaowakilisha namba isiyo hasi.\nInajumlisha mara kwa mara tarakimu za namba hadi jumla ni tarakimu moja, kisha inarudisha tarakimu hii moja.\n\nMfano:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "tr": "Verilen bir sayı dizisinin rakamlarının tekrarlı toplamını tek bir rakama indirgenene kadar hesaplar.\nFonksiyon, `input_string` adlı tek bir argüman alır; bu, negatif olmayan bir sayıyı temsil eden bir dizgedir.\nRakamların toplamı tek bir rakam olana kadar sayının rakamlarını tekrar tekrar toplar ve ardından bu tek rakamı döndürür.\n\nÖrnek:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "vi": "Tính tổng lặp lại của các chữ số của một chuỗi số đã cho cho đến khi nó giảm xuống còn một chữ số. Hàm này nhận một đối số duy nhất, `input_string`, là một chuỗi đại diện cho một số không âm. Nó liên tục tính tổng các chữ số của số đó cho đến khi tổng là một chữ số, sau đó trả về chữ số này.\n\nVí dụ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3"
    },
    "docstring_bertscore": {
      "es": "0.9656512454683989",
      "arb": "0.9694204555789169",
      "sw": "0.9215374241443606",
      "tr": "0.9615817062217561",
      "vi": "0.9664699998990247"
    }
  },
  {
    "task_id": "Ruby/17",
    "prompt": {
      "en": "# Calculates the minimum number of seat swaps required to group representatives of the same company together.\n# Given a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\n# the function returns the minimum number of swaps needed so that all representatives of each company are seated together.\n# The input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n#\n# Examples:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "es": "# Calcula el número mínimo de intercambios de asientos necesarios para agrupar a los representantes de la misma empresa juntos.\n# Dada una cadena que representa una secuencia de asientos ocupados por representantes de tres empresas, A, B y T,\n# la función devuelve el número mínimo de intercambios necesarios para que todos los representantes de cada empresa estén sentados juntos.\n# La cadena de entrada contiene solo los caracteres 'A', 'B' y 'T', y cada carácter representa un asiento ocupado por un representante de las respectivas empresas.\n#\n# Ejemplos:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "arb": "# يحسب الحد الأدنى لعدد تبادلات المقاعد المطلوبة لتجميع ممثلي نفس الشركة معًا.\n# بالنظر إلى سلسلة تمثل تسلسل المقاعد التي يشغلها ممثلو ثلاث شركات، A وB وT،\n# تعيد الدالة الحد الأدنى لعدد التبادلات اللازمة بحيث يجلس جميع ممثلي كل شركة معًا.\n# تحتوي سلسلة الإدخال فقط على الأحرف 'A' و'B' و'T'، وكل حرف يمثل مقعدًا يشغله ممثل من الشركات المعنية.\n#\n# أمثلة:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "sw": "# Inahesabu idadi ndogo ya kubadilisha viti inayohitajika ili kuwakusanya wawakilishi wa kampuni moja pamoja.\n# Ukipewa kamba inayowakilisha mlolongo wa viti vilivyokaliwa na wawakilishi wa kampuni tatu, A, B, na T,\n# kazi inarudisha idadi ndogo ya mabadilishano yanayohitajika ili wawakilishi wote wa kila kampuni waketi pamoja.\n# Kamba ya ingizo ina herufi 'A', 'B', na 'T' pekee, na kila herufi inawakilisha kiti kilichochukuliwa na mwakilishi kutoka kampuni husika.\n#\n# Mifano:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "tr": "# Aynı şirketin temsilcilerini bir araya getirmek için gereken minimum koltuk değişimi sayısını hesaplar.\n# Üç şirketin temsilcileri tarafından işgal edilen koltukların bir dizisini temsil eden bir dize verildiğinde, A, B ve T,\n# fonksiyon, her şirketin tüm temsilcilerinin bir arada oturması için gereken minimum değişim sayısını döndürür.\n# Girdi dizesi yalnızca 'A', 'B' ve 'T' karakterlerini içerir ve her karakter, ilgili şirketlerden bir temsilci tarafından alınan bir koltuğu temsil eder.\n#\n# Örnekler:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "vi": "# Tính toán số lần đổi chỗ tối thiểu cần thiết để nhóm các đại diện của cùng một công ty lại với nhau.\n# Cho một chuỗi đại diện cho một dãy ghế được chiếm bởi các đại diện của ba công ty, A, B và T,\n# hàm trả về số lần đổi chỗ tối thiểu cần thiết để tất cả các đại diện của mỗi công ty được ngồi cùng nhau.\n# Chuỗi đầu vào chỉ chứa các ký tự 'A', 'B', và 'T', và mỗi ký tự đại diện cho một ghế được chiếm bởi một đại diện từ các công ty tương ứng.\n#\n# Ví dụ:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)"
    },
    "prompt_bertscore": {
      "es": "0.9774622051854954",
      "arb": "0.9643226068496565",
      "sw": "0.9702415935741151",
      "tr": "0.9670968773815708",
      "vi": "0.9665959315606008"
    },
    "canonical_solution": "    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end",
    "instruction": {
      "en": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، على أن لا يتجاوز 500 حرف.",
      "sw": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yapılmalıdır.",
      "vi": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9151651628903803",
      "tr": "0.864885854539019",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless minimum_swaps_to_group_companies(\"TABTABBTTTT\") == 3\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"BBTAAT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"AABBBTTT\") == 0\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"ATBT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"TTABAB\") == 1\n  \n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_swaps_to_group_companies",
    "signature": "def minimum_swaps_to_group_companies(s)",
    "docstring": {
      "en": "Calculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n\nExamples:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "es": "Calcula el número mínimo de intercambios de asientos necesarios para agrupar a los representantes de la misma empresa juntos. Dada una cadena que representa una secuencia de asientos ocupados por representantes de tres empresas, A, B y T, la función devuelve el número mínimo de intercambios necesarios para que todos los representantes de cada empresa estén sentados juntos. La cadena de entrada contiene solo los caracteres 'A', 'B' y 'T', y cada carácter representa un asiento ocupado por un representante de las respectivas empresas.\n\nEjemplos:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "arb": "يحسب الحد الأدنى لعدد تبديلات المقاعد المطلوبة لتجميع ممثلي نفس الشركة معًا.\nبالنظر إلى سلسلة تمثل تسلسل المقاعد التي يشغلها ممثلو ثلاث شركات، A، B، وT،\nتعيد الدالة الحد الأدنى لعدد التبديلات اللازمة بحيث يجلس جميع ممثلي كل شركة معًا.\nتحتوي سلسلة الإدخال فقط على الأحرف 'A'، 'B'، و'T'، ويمثل كل حرف مقعدًا يشغله ممثل من الشركات المعنية.\n\nأمثلة:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "sw": "Hesabu idadi ndogo ya ubadilishaji wa viti inayohitajika ili kuwakusanya wawakilishi wa kampuni moja pamoja. \nUkipatiwa mfuatano wa viti vinavyokaliwa na wawakilishi wa kampuni tatu, A, B, na T, \nkazi inarudisha idadi ndogo ya ubadilishaji unaohitajika ili wawakilishi wote wa kila kampuni wakae pamoja. \nMfuatano wa ingizo unajumuisha tu herufi 'A', 'B', na 'T', na kila herufi inawakilisha kiti kilichochukuliwa na mwakilishi kutoka kampuni husika.\n\nMifano:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "tr": "Aynı şirketin temsilcilerini bir araya toplamak için gereken minimum koltuk değiştirme sayısını hesaplar.\nÜç şirketin temsilcileri tarafından işgal edilen koltukların bir dizisini temsil eden bir dize verildiğinde, \nher şirketin tüm temsilcilerinin bir araya oturması için gereken minimum değiştirme sayısını döndürür.\nGirdi dizisi yalnızca 'A', 'B' ve 'T' karakterlerini içerir ve her karakter ilgili şirketlerden bir temsilci tarafından alınan bir koltuğu temsil eder.\n\nÖrnekler:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "vi": "Tính toán số lần hoán đổi ghế tối thiểu cần thiết để nhóm các đại diện của cùng một công ty lại với nhau.  \nCho một chuỗi đại diện cho một dãy ghế được chiếm bởi các đại diện của ba công ty, A, B, và T,  \nhàm trả về số lần hoán đổi tối thiểu cần thiết để tất cả các đại diện của mỗi công ty được ngồi cùng nhau.  \nChuỗi đầu vào chỉ chứa các ký tự 'A', 'B', và 'T', và mỗi ký tự đại diện cho một ghế được chiếm bởi một đại diện từ các công ty tương ứng.\n\nVí dụ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1"
    },
    "docstring_bertscore": {
      "es": "0.9690694756956283",
      "arb": "0.9672692885523091",
      "sw": "0.946215064053754",
      "tr": "0.9417293941588432",
      "vi": "0.9582093596125457"
    }
  },
  {
    "task_id": "Ruby/18",
    "prompt": {
      "en": "# Calculates the final minimum weight of fish in a simulated feeding game.\n# In this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\n# The game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\n# and its weight becomes the sum of both. The function returns the weight of the lightest fish\n# after 'm' rounds.\n#\n# Arguments:\n# n (Integer) -- The number of fish.\n# m (Integer) -- The number of rounds the game will be played.\n# weights (Array of Integers) -- An array representing the weights of each fish.\n#\n# Example:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "es": "# Calcula el peso mínimo final de los peces en un juego de alimentación simulado.\n# En este juego, hay 'n' peces, cada uno con un peso inicial dado en el arreglo 'weights'.\n# El juego procede por 'm' rondas. En cada ronda, el pez más ligero se come al segundo más ligero,\n# y su peso se convierte en la suma de ambos. La función devuelve el peso del pez más ligero\n# después de 'm' rondas.\n#\n# Argumentos:\n# n (Integer) -- El número de peces.\n# m (Integer) -- El número de rondas que se jugará el juego.\n# weights (Array de Enteros) -- Un arreglo que representa los pesos de cada pez.\n#\n# Ejemplo:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "arb": "# يحسب الوزن النهائي الأدنى للأسماك في لعبة تغذية محاكاة.\n# في هذه اللعبة، هناك 'n' سمكة، كل منها بوزن ابتدائي معطى في مصفوفة 'weights'.\n# تستمر اللعبة لعدد 'm' من الجولات. في كل جولة، تأكل السمكة الأخف وزناً السمكة الثانية الأخف،\n# ويصبح وزنها هو مجموع الاثنين. تُرجع الدالة وزن السمكة الأخف بعد 'm' جولات.\n#\n# الوسائط:\n# n (عدد صحيح) -- عدد الأسماك.\n# m (عدد صحيح) -- عدد الجولات التي ستلعبها اللعبة.\n# weights (مصفوفة من الأعداد الصحيحة) -- مصفوفة تمثل أوزان كل سمكة.\n#\n# مثال:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "sw": "# Inakokotoa uzito wa mwisho wa chini kabisa wa samaki katika mchezo wa kulisha uliosimuliwa.\n# Katika mchezo huu, kuna 'n' samaki, kila mmoja akiwa na uzito wa awali uliotolewa katika safu ya 'weights'.\n# Mchezo unaendelea kwa raundi 'm'. Katika kila raundi, samaki mwepesi zaidi anakula wa pili mwepesi,\n# na uzito wake unakuwa jumla ya wote wawili. Kazi inarejesha uzito wa samaki mwepesi zaidi\n# baada ya raundi 'm'.\n#\n# Hoja:\n# n (Integer) -- Idadi ya samaki.\n# m (Integer) -- Idadi ya raundi ambazo mchezo utachezwa.\n# weights (Array of Integers) -- Safu inayowakilisha uzito wa kila samaki.\n#\n# Mfano:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "tr": "# Bir simülasyon besleme oyununda balıkların nihai minimum ağırlığını hesaplar.\n# Bu oyunda, her biri 'weights' dizisinde verilen başlangıç ağırlığına sahip 'n' balık vardır.\n# Oyun 'm' tur boyunca devam eder. Her turda, en hafif balık ikinci en hafif balığı yer ve\n# ağırlığı her ikisinin toplamı olur. Fonksiyon, 'm' turdan sonra en hafif balığın ağırlığını döndürür.\n#\n# Argümanlar:\n# n (Integer) -- Balık sayısı.\n# m (Integer) -- Oyunun oynanacağı tur sayısı.\n# weights (Array of Integers) -- Her bir balığın ağırlığını temsil eden bir dizi.\n#\n# Örnek:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "vi": "# Tính trọng lượng tối thiểu cuối cùng của cá trong một trò chơi cho ăn mô phỏng.\n# Trong trò chơi này, có 'n' con cá, mỗi con có trọng lượng ban đầu được cho trong mảng 'weights'.\n# Trò chơi diễn ra trong 'm' vòng. Trong mỗi vòng, con cá nhẹ nhất ăn con cá nhẹ thứ hai,\n# và trọng lượng của nó trở thành tổng của cả hai. Hàm trả về trọng lượng của con cá nhẹ nhất\n# sau 'm' vòng.\n#\n# Tham số:\n# n (Integer) -- Số lượng cá.\n# m (Integer) -- Số vòng trò chơi sẽ được chơi.\n# weights (Array of Integers) -- Một mảng đại diện cho trọng lượng của mỗi con cá.\n#\n# Ví dụ:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)"
    },
    "prompt_bertscore": {
      "es": "0.9948058155359377",
      "arb": "0.9677477891402221",
      "sw": "0.9860261540638146",
      "tr": "0.9791018989809384",
      "vi": "0.9733447960170232"
    },
    "canonical_solution": "  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend",
    "instruction": {
      "en": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nAşağıdaki Ruby kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9428772791308437",
      "tr": "0.8568462898666319",
      "vi": "0.906469522069435"
    },
    "level": "",
    "test": "raise 'Test failed' unless final_min_weight_fish(1, [1, 2, 3]) == 3\nraise 'Test failed' unless final_min_weight_fish(2, [4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [5, 4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [3, 2, 1]) == 6\nraise 'Test failed' unless final_min_weight_fish(3, [1, 2, 3, 4]) == 10\n  \nputs 'All tests passed!'",
    "entry_point": "final_min_weight_fish",
    "signature": "def final_min_weight_fish(m, weights)",
    "docstring": {
      "en": "Calculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "es": "Calcula el peso mínimo final de los peces en un juego de alimentación simulado. En este juego, hay 'n' peces, cada uno con un peso inicial dado en el arreglo 'weights'. El juego se desarrolla durante 'm' rondas. En cada ronda, el pez más ligero se come al segundo más ligero, y su peso se convierte en la suma de ambos. La función devuelve el peso del pez más ligero después de 'm' rondas.\n\nArgumentos:\nn (Integer) -- El número de peces.\nm (Integer) -- El número de rondas que se jugará el juego.\nweights (Array of Integers) -- Un arreglo que representa los pesos de cada pez.\n\nEjemplo:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "arb": "يحسب الوزن النهائي الأدنى للأسماك في لعبة تغذية محاكاة.\nفي هذه اللعبة، هناك 'n' من الأسماك، كل منها بوزن ابتدائي معطى في مصفوفة 'weights'.\nتستمر اللعبة لعدد 'm' من الجولات. في كل جولة، تأكل السمكة الأخف وزناً السمكة الثانية الأخف،\nويصبح وزنها مجموع الاثنين. تُرجع الدالة وزن السمكة الأخف بعد 'm' من الجولات.\n\nالأوساط:\nn (عدد صحيح) -- عدد الأسماك.\nm (عدد صحيح) -- عدد الجولات التي ستُلعب في اللعبة.\nweights (مصفوفة من الأعداد الصحيحة) -- مصفوفة تمثل أوزان كل سمكة.\n\nمثال:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "sw": "Hesabu uzito wa mwisho wa chini wa samaki katika mchezo wa kulisha uliosimuliwa.\nKatika mchezo huu, kuna 'n' samaki, kila mmoja akiwa na uzito wa awali uliotolewa katika safu ya 'weights'.\nMchezo unaendelea kwa raundi 'm'. Katika kila raundi, samaki mwepesi zaidi anakula wa pili mwepesi,\nna uzito wake unakuwa jumla ya wote wawili. Kazi inarejesha uzito wa samaki mwepesi zaidi\nbaada ya raundi 'm'.\n\nHoja:\nn (Integer) -- Idadi ya samaki.\nm (Integer) -- Idadi ya raundi ambazo mchezo utachezwa.\nweights (Array ya Integer) -- Safu inayowakilisha uzito wa kila samaki.\n\nMfano:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "tr": "Balıkların simüle edilmiş bir beslenme oyununda nihai minimum ağırlığını hesaplar.\nBu oyunda, her birinin başlangıç ağırlığı 'weights' dizisinde verilen 'n' balık vardır.\nOyun 'm' tur boyunca devam eder. Her turda, en hafif balık ikinci en hafif balığı yer\nve ağırlığı her ikisinin toplamı olur. Fonksiyon, 'm' turdan sonra en hafif balığın ağırlığını döndürür.\n\nArgümanlar:\nn (Integer) -- Balık sayısı.\nm (Integer) -- Oyunun oynanacağı tur sayısı.\nweights (Array of Integers) -- Her bir balığın ağırlığını temsil eden bir dizi.\n\nÖrnek:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "vi": "Tính toán trọng lượng tối thiểu cuối cùng của cá trong một trò chơi cho ăn mô phỏng. Trong trò chơi này, có 'n' con cá, mỗi con có trọng lượng ban đầu được cho trong mảng 'weights'. Trò chơi diễn ra trong 'm' vòng. Trong mỗi vòng, con cá nhẹ nhất ăn con nhẹ thứ hai, và trọng lượng của nó trở thành tổng của cả hai. Hàm trả về trọng lượng của con cá nhẹ nhất sau 'm' vòng.\n\nTham số:\nn (Integer) -- Số lượng cá.\nm (Integer) -- Số vòng mà trò chơi sẽ được chơi.\nweights (Array of Integers) -- Một mảng đại diện cho trọng lượng của mỗi con cá.\n\nVí dụ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4"
    },
    "docstring_bertscore": {
      "es": "0.9866101273840572",
      "arb": "0.9553401437584967",
      "sw": "0.9790719057934021",
      "tr": "0.9795873516321877",
      "vi": "0.9759291759046681"
    }
  },
  {
    "task_id": "Ruby/19",
    "prompt": {
      "en": "# Sorts a list of patient information based on their age and registration order.\n# The function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\n# The sorting criteria are as follows:\n# 1. Patients aged 60 and above are given priority over younger patients.\n# 2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n# 3. Younger patients (below 60) are sorted based on their registration order.\n#\n# Example:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "es": "# Ordena una lista de información de pacientes basada en su edad y orden de registro.\n# La función toma un array de arrays, donde cada sub-array contiene la ID de un paciente (una cadena) y la edad (un entero).\n# Los criterios de ordenación son los siguientes:\n# 1. Los pacientes de 60 años o más tienen prioridad sobre los pacientes más jóvenes.\n# 2. Los pacientes ancianos (de 60 años o más) se ordenan en orden descendente de edad. Si las edades son iguales, se ordenan por su orden de registro.\n# 3. Los pacientes más jóvenes (menores de 60 años) se ordenan según su orden de registro.\n#\n# Ejemplo:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "arb": "# يقوم بترتيب قائمة بمعلومات المرضى بناءً على أعمارهم وترتيب تسجيلهم.\n# تأخذ الدالة مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على معرف المريض (سلسلة نصية) والعمر (عدد صحيح).\n# معايير الترتيب كالتالي:\n# 1. يتم إعطاء الأولوية للمرضى الذين تبلغ أعمارهم 60 عامًا فأكثر على المرضى الأصغر سنًا.\n# 2. يتم ترتيب المرضى المسنين (الذين تبلغ أعمارهم 60 عامًا فأكثر) بترتيب تنازلي حسب العمر. إذا كانت الأعمار متساوية، يتم ترتيبهم حسب ترتيب تسجيلهم.\n# 3. يتم ترتيب المرضى الأصغر سنًا (أقل من 60 عامًا) بناءً على ترتيب تسجيلهم.\n#\n# مثال:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "sw": "# Hupanga orodha ya taarifa za wagonjwa kulingana na umri wao na mpangilio wa usajili.\n# Kazi inachukua safu ya safu, ambapo kila safu ndogo ina kitambulisho cha mgonjwa (kamba) na umri (nambari kamili).\n# Vigezo vya upangaji ni kama ifuatavyo:\n# 1. Wagonjwa wenye umri wa miaka 60 na zaidi wanapewa kipaumbele kuliko wagonjwa wadogo.\n# 2. Wagonjwa wazee (wenye umri wa miaka 60+) wanapangwa kwa mpangilio wa kushuka kwa umri. Ikiwa umri ni sawa, wanapangwa kwa mpangilio wa usajili wao.\n# 3. Wagonjwa wadogo (chini ya miaka 60) wanapangwa kulingana na mpangilio wa usajili wao.\n#\n# Mfano:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "tr": "# Hasta bilgilerini yaşlarına ve kayıt sıralarına göre sıralar.\n# Fonksiyon, her alt dizinin bir hastanın kimliğini (bir string) ve yaşını (bir tamsayı) içerdiği bir dizi dizisi alır.\n# Sıralama kriterleri aşağıdaki gibidir:\n# 1. 60 yaş ve üzeri hastalar, daha genç hastalara göre önceliklidir.\n# 2. Yaşlı hastalar (60+ yaş) yaşlarına göre azalan sırada sıralanır. Eğer yaşlar eşitse, kayıt sıralarına göre sıralanırlar.\n# 3. Daha genç hastalar (60 yaş altı) kayıt sıralarına göre sıralanır.\n#\n# Örnek:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "vi": "# Sắp xếp danh sách thông tin bệnh nhân dựa trên tuổi và thứ tự đăng ký của họ.\n# Hàm nhận một mảng các mảng, trong đó mỗi mảng con chứa ID của bệnh nhân (một chuỗi) và tuổi (một số nguyên).\n# Tiêu chí sắp xếp như sau:\n# 1. Bệnh nhân từ 60 tuổi trở lên được ưu tiên hơn bệnh nhân trẻ hơn.\n# 2. Bệnh nhân cao tuổi (từ 60 tuổi trở lên) được sắp xếp theo thứ tự giảm dần của tuổi. Nếu tuổi bằng nhau, họ được sắp xếp theo thứ tự đăng ký.\n# 3. Bệnh nhân trẻ hơn (dưới 60 tuổi) được sắp xếp dựa trên thứ tự đăng ký của họ.\n#\n# Ví dụ:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)"
    },
    "prompt_bertscore": {
      "es": "0.9902903510838715",
      "arb": "0.9805540856966845",
      "sw": "0.9697086682617985",
      "tr": "0.9655169713308193",
      "vi": "0.9867297028734402"
    },
    "canonical_solution": "    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end",
    "instruction": {
      "en": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8894786792757107",
      "sw": "0.9428772791308437",
      "tr": "0.8568462898666319",
      "vi": "0.9513240360843523"
    },
    "level": "",
    "test": "raise 'Test failed' unless sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]]) == [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\nraise 'Test failed' unless sort_patients([[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]) == [[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]\nraise 'Test failed' unless sort_patients([[\"987654\", 45], [\"123456\", 65], [\"543210\", 55]]) == [[\"123456\", 65], [\"987654\", 45], [\"543210\", 55]]\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_patients",
    "signature": "def sort_patients(patient_info)",
    "docstring": {
      "en": "Sorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "es": "Ordena una lista de información de pacientes basada en su edad y orden de registro.  \nLa función toma un array de arrays, donde cada sub-array contiene el ID de un paciente (una cadena) y la edad (un entero).  \nLos criterios de ordenación son los siguientes:  \n1. A los pacientes de 60 años o más se les da prioridad sobre los pacientes más jóvenes.  \n2. Los pacientes ancianos (de 60 años o más) se ordenan en orden descendente de edad. Si las edades son iguales, se ordenan por su orden de registro.  \n3. Los pacientes más jóvenes (menores de 60 años) se ordenan según su orden de registro.  \n\nEjemplo:  \n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])  \n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "arb": "يقوم بفرز قائمة بمعلومات المرضى بناءً على أعمارهم وترتيب تسجيلهم. تأخذ الدالة مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على معرف المريض (سلسلة نصية) والعمر (عدد صحيح). معايير الفرز هي كما يلي:\n1. يُعطى المرضى الذين تبلغ أعمارهم 60 عامًا فأكثر أولوية على المرضى الأصغر سنًا.\n2. يتم فرز المرضى المسنين (الذين تبلغ أعمارهم 60 عامًا فأكثر) بترتيب تنازلي حسب العمر. إذا كانت الأعمار متساوية، يتم فرزهم حسب ترتيب تسجيلهم.\n3. يتم فرز المرضى الأصغر سنًا (أقل من 60 عامًا) بناءً على ترتيب تسجيلهم.\n\nمثال:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "sw": "Hupanga orodha ya taarifa za wagonjwa kulingana na umri wao na mpangilio wa usajili.\nKazi inachukua safu ya safu, ambapo kila safu ndogo ina kitambulisho cha mgonjwa (kamba) na umri (nambari kamili).\nVigezo vya upangaji ni kama ifuatavyo:\n1. Wagonjwa wenye umri wa miaka 60 na zaidi wanapewa kipaumbele juu ya wagonjwa wadogo.\n2. Wagonjwa wazee (wenye umri wa miaka 60+) wanapangwa kwa mpangilio wa kushuka wa umri. Ikiwa umri ni sawa, wanapangwa kwa mpangilio wa usajili wao.\n3. Wagonjwa wadogo (chini ya miaka 60) wanapangwa kulingana na mpangilio wa usajili wao.\n\nMfano:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "tr": "Hasta bilgilerini yaşlarına ve kayıt sıralarına göre sıralar. \nFonksiyon, her alt dizinin bir hastanın kimliğini (bir dize) ve yaşını (bir tamsayı) içerdiği bir dizi dizisi alır. \nSıralama kriterleri aşağıdaki gibidir: \n1. 60 yaş ve üzeri hastalar, daha genç hastalara göre önceliklidir. \n2. Yaşlı hastalar (60+ yaş) yaşlarına göre azalan sırayla sıralanır. Eğer yaşlar eşitse, kayıt sıralarına göre sıralanırlar. \n3. Daha genç hastalar (60 yaş altı) kayıt sıralarına göre sıralanır.\n\nÖrnek:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "vi": "Sắp xếp danh sách thông tin bệnh nhân dựa trên tuổi và thứ tự đăng ký của họ.  \nHàm nhận một mảng các mảng, trong đó mỗi mảng con chứa ID bệnh nhân (một chuỗi) và tuổi (một số nguyên).  \nTiêu chí sắp xếp như sau:  \n1. Bệnh nhân từ 60 tuổi trở lên được ưu tiên hơn bệnh nhân trẻ hơn.  \n2. Bệnh nhân cao tuổi (từ 60 tuổi trở lên) được sắp xếp theo thứ tự giảm dần của tuổi. Nếu tuổi bằng nhau, họ được sắp xếp theo thứ tự đăng ký.  \n3. Bệnh nhân trẻ hơn (dưới 60 tuổi) được sắp xếp dựa trên thứ tự đăng ký của họ.  \n\nVí dụ:  \n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])  \n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]"
    },
    "docstring_bertscore": {
      "es": "0.9828415131646823",
      "arb": "0.9733813440071336",
      "sw": "0.9676399328433202",
      "tr": "0.9627621665762464",
      "vi": "0.9766678822917368"
    }
  },
  {
    "task_id": "Ruby/20",
    "prompt": {
      "en": "# Finds the intersection point of two linear functions.\n# This function takes four arguments: slope1, intercept1, slope2, intercept2.\n# slope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\n# The function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\n# The coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n#\n# Example:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Parallel lines with no intersection\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "es": "# Encuentra el punto de intersección de dos funciones lineales.\n# Esta función toma cuatro argumentos: slope1, intercept1, slope2, intercept2.\n# slope1 y slope2 son las pendientes de las dos líneas, mientras que intercept1 e intercept2 son sus intersecciones con el eje y.\n# La función calcula y devuelve las coordenadas del punto de intersección de estas dos líneas, si existe.\n# Las coordenadas se devuelven como un arreglo de dos elementos [x, y], redondeado a dos decimales.\n#\n# Ejemplo:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Líneas paralelas sin intersección\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "arb": "# يجد نقطة التقاطع بين دالتين خطيتين.\n# تأخذ هذه الدالة أربعة معطيات: slope1, intercept1, slope2, intercept2.\n# slope1 و slope2 هما ميل الخطين، بينما intercept1 و intercept2 هما تقاطعهما مع محور y.\n# تقوم الدالة بحساب وإرجاع إحداثيات نقطة التقاطع بين هذين الخطين، إذا كانت موجودة.\n# يتم إرجاع الإحداثيات كمصفوفة مكونة من عنصرين [x, y]، مقربة إلى منزلتين عشريتين.\n#\n# مثال:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # خطوط متوازية بدون تقاطع\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "sw": "# Inapata sehemu ya makutano ya kazi mbili za mstari.\n# Kazi hii inachukua hoja nne: slope1, intercept1, slope2, intercept2.\n# slope1 na slope2 ni miteremko ya mistari miwili, wakati intercept1 na intercept2 ni sehemu zao za kukatiza y.\n# Kazi hii inahesabu na kurudisha kuratibu za sehemu ya makutano ya mistari hii miwili, ikiwa ipo.\n# Kuratibu zinarudishwa kama safu ya vipengele viwili [x, y], vikiwa vimepunguzwa hadi sehemu mbili za desimali.\n#\n# Mfano:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Mistari sambamba bila makutano\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "tr": "# İki doğrusal fonksiyonun kesişim noktasını bulur.\n# Bu fonksiyon dört argüman alır: slope1, intercept1, slope2, intercept2.\n# slope1 ve slope2, iki doğrunun eğimleri iken, intercept1 ve intercept2 onların y-kesim noktalarıdır.\n# Fonksiyon, bu iki doğrunun kesişim noktasının koordinatlarını hesaplar ve döndürür, eğer mevcutsa.\n# Koordinatlar, iki elemanlı bir dizi [x, y] olarak döndürülür ve iki ondalık basamağa yuvarlanır.\n#\n# Örnek:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Kesişim noktası olmayan paralel doğrular",
      "vi": "# Tìm điểm giao nhau của hai hàm số tuyến tính.\n# Hàm này nhận bốn tham số: slope1, intercept1, slope2, intercept2.\n# slope1 và slope2 là độ dốc của hai đường thẳng, trong khi intercept1 và intercept2 là các giao điểm với trục y của chúng.\n# Hàm tính toán và trả về tọa độ của điểm giao nhau của hai đường thẳng này, nếu có tồn tại.\n# Tọa độ được trả về dưới dạng một mảng hai phần tử [x, y], làm tròn đến hai chữ số thập phân.\n#\n# Ví dụ:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Các đường thẳng song song không có điểm giao nhau\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)"
    },
    "prompt_bertscore": {
      "es": "0.9954424259071545",
      "arb": "0.9853081052363735",
      "sw": "0.994056184477912",
      "tr": "0.9715444102433229",
      "vi": "0.9808585860708109"
    },
    "canonical_solution": "    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end",
    "instruction": {
      "en": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan en fazla 500 karakterlik bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.",
      "vi": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9100232182165301",
      "tr": "0.8617613986453403",
      "vi": "0.9194637229663563"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_intersection(1.0, 0.0, -1.0, 2.0) == [1.00, 1.00]\nraise 'Test failed' unless find_intersection(2.0, 3.0, 2.0, -1.0).nil?\nraise 'Test failed' unless find_intersection(0.5, 1.0, -0.5, -1.0) == [-2.00, 0.00]\nraise 'Test failed' unless find_intersection(3.0, 2.0, -1.0, 4.0) == [0.50, 3.50]\nraise 'Test failed' unless find_intersection(2.0, 0.0, 0.0, 2.0) == [1.0, 2.0]\n  \n\nputs 'All tests passed!'",
    "entry_point": "find_intersection",
    "signature": "def find_intersection(slope1, intercept1, slope2, intercept2)",
    "docstring": {
      "en": "Finds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\nExample:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection",
      "es": "Encuentra el punto de intersección de dos funciones lineales.  \nEsta función toma cuatro argumentos: slope1, intercept1, slope2, intercept2.  \nslope1 y slope2 son las pendientes de las dos líneas, mientras que intercept1 e intercept2 son sus intersecciones en y.  \nLa función calcula y devuelve las coordenadas del punto de intersección de estas dos líneas, si existe.  \nLas coordenadas se devuelven como un arreglo de dos elementos [x, y], redondeado a dos decimales.\n\nEjemplo:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Líneas paralelas sin intersección",
      "arb": "يجد نقطة تقاطع دالتين خطيتين.  \nتأخذ هذه الدالة أربعة معطيات: slope1، intercept1، slope2، intercept2.  \nslope1 و slope2 هما ميل الخطين، بينما intercept1 و intercept2 هما تقاطعهما مع المحور y.  \nتحسب الدالة وتعيد إحداثيات نقطة تقاطع هذين الخطين، إذا كانت موجودة.  \nتُعاد الإحداثيات كمصفوفة مكونة من عنصرين [x, y]، مقربة إلى منزلتين عشريتين.\n\nمثال:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  خطوط متوازية بدون تقاطع  ",
      "sw": "Inapata sehemu ya makutano ya kazi mbili za mstari.\nKazi hii inachukua hoja nne: slope1, intercept1, slope2, intercept2.\nslope1 na slope2 ni miteremko ya mistari miwili, wakati intercept1 na intercept2 ni sehemu zao za kukatiza kwenye mhimili wa y.\nKazi hii inahesabu na kurudisha kuratibu za sehemu ya makutano ya mistari hii miwili, ikiwa ipo.\nKuratibu zinarudishwa kama safu ya vipengele viwili [x, y], iliyokadiriwa hadi sehemu mbili za desimali.\n\nMfano:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Mistari sambamba bila makutano",
      "tr": "İki doğrusal fonksiyonun kesişim noktasını bulur.  \nBu fonksiyon dört argüman alır: slope1, intercept1, slope2, intercept2.  \nslope1 ve slope2, iki doğrunun eğimleri iken, intercept1 ve intercept2 onların y-kesim noktalarıdır.  \nFonksiyon, bu iki doğrunun kesişim noktasının koordinatlarını hesaplar ve döndürür, eğer varsa.  \nKoordinatlar, iki elemanlı bir dizi [x, y] olarak döndürülür ve iki ondalık basamağa yuvarlanır.  \n\nÖrnek:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Kesişim noktası olmayan paralel doğrular  ",
      "vi": "Tìm điểm giao nhau của hai hàm số tuyến tính.  \nHàm này nhận bốn đối số: slope1, intercept1, slope2, intercept2.  \nslope1 và slope2 là độ dốc của hai đường thẳng, trong khi intercept1 và intercept2 là các giao điểm y của chúng.  \nHàm tính toán và trả về tọa độ của điểm giao nhau của hai đường thẳng này, nếu nó tồn tại.  \nTọa độ được trả về dưới dạng một mảng hai phần tử [x, y], được làm tròn đến hai chữ số thập phân.  \n\nVí dụ:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Các đường thẳng song song không có điểm giao nhau  "
    },
    "docstring_bertscore": {
      "es": "0.991192331644151",
      "arb": "0.9863515106279497",
      "sw": "0.9784712475211526",
      "tr": "0.9844724672233597",
      "vi": "0.9780298908144931"
    }
  },
  {
    "task_id": "Ruby/21",
    "prompt": {
      "en": "# This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\n# The function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n#\n# Examples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "es": "# Este método calcula el número mínimo de pasos necesarios para transformar un número dado en un palíndromo invirtiendo repetidamente sus dígitos y sumando el resultado al número original. El proceso se detiene cuando se obtiene un palíndromo. Si el palíndromo no se obtiene dentro de 8 pasos, el método devuelve 0.\n# La función toma un solo argumento, m, que es un número entero positivo entre 12 y 100, y devuelve el número de pasos necesarios para alcanzar un palíndromo. El número de entrada m en sí mismo no es un palíndromo.\n#\n# Ejemplos:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "arb": "# تقوم هذه الطريقة بحساب الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم معين إلى عدد متناظر عن طريق عكس أرقامه بشكل متكرر وإضافة النتيجة إلى الرقم الأصلي. يتم إيقاف العملية عند الحصول على عدد متناظر. إذا لم يتم الحصول على العدد المتناظر في غضون 8 خطوات، فإن الطريقة تعيد 0.\n# تأخذ الدالة وسيطًا واحدًا، m، وهو عدد صحيح موجب بين 12 و100، وتعيد عدد الخطوات المتخذة للوصول إلى عدد متناظر. الرقم المدخل m نفسه ليس عددًا متناظرًا.\n#\n# أمثلة:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "sw": "# Njia hii inahesabu idadi ndogo ya hatua zinazohitajika kubadilisha nambari fulani kuwa palindromu kwa kugeuza tarakimu zake mara kwa mara na kuongeza matokeo kwenye nambari ya awali. Mchakato unakoma palindromu inapopatikana. Ikiwa palindromu haipatikani ndani ya hatua 8, njia inarudisha 0.\n# Kazi inachukua hoja moja, m, ambayo ni nambari kamili chanya kati ya 12 na 100, na inarudisha idadi ya hatua zilizochukuliwa kufikia palindromu. Nambari ya ingizo m yenyewe si palindromu.\n#\n# Mifano:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "tr": "# Bu yöntem, verilen bir sayıyı, rakamlarını ters çevirip sonucu orijinal sayıya ekleyerek bir palindroma dönüştürmek için gereken minimum adım sayısını hesaplar. İşlem, bir palindrom elde edildiğinde durdurulur. Eğer 8 adım içinde palindrom elde edilmezse, yöntem 0 döndürür.\n# Fonksiyon, 12 ile 100 arasında pozitif bir tamsayı olan m adlı tek bir argüman alır ve bir palindroma ulaşmak için alınan adım sayısını döndürür. Girdi sayısı m'nin kendisi bir palindrom değildir.\n#\n# Örnekler:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "vi": "# Phương thức này tính toán số bước tối thiểu cần thiết để biến đổi một số đã cho thành một số palindrome bằng cách liên tục đảo ngược các chữ số của nó và cộng kết quả vào số ban đầu. Quá trình dừng lại khi đạt được một số palindrome. Nếu không đạt được số palindrome trong vòng 8 bước, phương thức trả về 0.\n# Hàm nhận một đối số duy nhất, m, là một số nguyên dương từ 12 đến 100, và trả về số bước cần thiết để đạt được một số palindrome. Số đầu vào m bản thân nó không phải là một số palindrome.\n#\n# Ví dụ:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)"
    },
    "prompt_bertscore": {
      "es": "0.9937310265441579",
      "arb": "0.9901119810017023",
      "sw": "0.9891859661653176",
      "tr": "0.9872604432515654",
      "vi": "0.9704819363351673"
    },
    "canonical_solution": "  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend",
    "instruction": {
      "en": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9039824710684972",
      "sw": "0.9151651628903803",
      "tr": "0.8708167590863398",
      "vi": "0.906469522069435"
    },
    "level": "",
    "test": "raise 'Test failed' unless palindrome_sum_steps(12) == 1\nraise 'Test failed' unless palindrome_sum_steps(87) == 4\nraise 'Test failed' unless palindrome_sum_steps(89) == 0\nraise 'Test failed' unless palindrome_sum_steps(56) == 1\nraise 'Test failed' unless palindrome_sum_steps(95) == 3\n\nputs 'All tests passed!'",
    "entry_point": "palindrome_sum_steps",
    "signature": "def palindrome_sum_steps(m)",
    "docstring": {
      "en": "This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "es": "Este método calcula el número mínimo de pasos necesarios para transformar un número dado en un palíndromo invirtiendo repetidamente sus dígitos y sumando el resultado al número original. El proceso se detiene cuando se obtiene un palíndromo. Si el palíndromo no se obtiene dentro de 8 pasos, el método devuelve 0.  \nLa función toma un solo argumento, m, que es un número entero positivo entre 12 y 100, y devuelve el número de pasos necesarios para alcanzar un palíndromo. El número de entrada m en sí mismo no es un palíndromo.\n\nEjemplos:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "arb": "هذه الطريقة تحسب الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم معين إلى عدد متناظر عن طريق عكس أرقامه بشكل متكرر وإضافة النتيجة إلى الرقم الأصلي. يتم إيقاف العملية عند الحصول على عدد متناظر. إذا لم يتم الحصول على عدد متناظر في غضون 8 خطوات، فإن الطريقة تعيد 0. \n\nيعيدالحجج:\n    m: عدد صحيح موجب بين 12 و 100.\n\nيعيد:\n    عدد الخطوات المتخذة للوصول إلى عدد متناظر.\n\nامثله:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "sw": "Njia hii inahesabu idadi ndogo ya hatua zinazohitajika kubadilisha nambari fulani kuwa palindromu kwa kugeuza tarakimu zake mara kwa mara na kuongeza matokeo kwenye nambari ya awali. Mchakato unakoma palindromu inapopatikana. Ikiwa palindromu haipatikani ndani ya hatua 8, njia inarudisha 0.\n\n Kazi inachukua hoja moja, m, ambayo ni nambari kamili chanya kati ya 12 na 100, na inarudisha idadi ya hatua zilizochukuliwa kufikia palindromu. Nambari ya ingizo m yenyewe si palindromu.\n\nHoja:\n    m: Nambari nzima chanya kati ya 12 na 100.\n\nInarejesha:\n    Idadi ya hatua zilizochukuliwa kufikia palindromu. Nambari ya ingizo m yenyewe si palindromu.\n\nMifano:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "tr": "Bu yöntem, bir sayıyı ters çevirip elde edilen sonucu orijinal sayıya ekleyerek bir palindroma dönüştürmek için gereken minimum adım sayısını hesaplar. İşlem, bir palindrom elde edildiğinde durdurulur. Eğer palindrom 8 adım içinde elde edilmezse, yöntem 0 döndürür.\nFonksiyon, 12 ile 100 arasında pozitif bir tamsayı olan m adlı tek bir argüman alır ve bir palindroma ulaşmak için alınan adım sayısını döndürür. Girdi sayısı m'nin kendisi bir palindrom değildir.\n\nÖrnekler:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "vi": "Phương thức này tính toán số bước tối thiểu cần thiết để biến đổi một số đã cho thành một số palindrome bằng cách liên tục đảo ngược các chữ số của nó và cộng kết quả vào số ban đầu. Quá trình dừng lại khi đạt được một số palindrome. Nếu không đạt được số palindrome trong vòng 8 bước, phương thức trả về 0. \n\nHàm nhận một đối số duy nhất, m, là một số nguyên dương nằm trong khoảng từ 12 đến 100, và trả về số bước đã thực hiện để đạt được một số palindrome. Bản thân số đầu vào m không phải là một số palindrome.\n\nVí dụ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0"
    },
    "docstring_bertscore": {
      "es": "0.9922840042183187",
      "arb": "0.9323685401918119",
      "sw": "0.9546491086628764",
      "tr": "0.9778374179752702",
      "vi": "0.9637400239420811"
    }
  },
  {
    "task_id": "Ruby/22",
    "prompt": {
      "en": "# This function calculates the number of different prime pairs whose sum equals a given even number.\n# The function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\n# It returns the count of distinct prime pairs whose sum equals the given even number.\n# A prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n#\n# Example:\n# >>> count_prime_pairs(10)\n# 2 (since 10 can be expressed as 3+7 and 5+5)\n# >>> count_prime_pairs(14)\n# 2 (since 14 can be expressed as 3+11 and 7+7)\n \ndef count_prime_pairs(even_number)",
      "es": "# Esta función calcula el número de diferentes pares de primos cuya suma es igual a un número par dado.\n# La función acepta un único argumento, even_number, que es un número par mayor que 6 y menor que 32767.\n# Devuelve el conteo de pares de primos distintos cuya suma es igual al número par dado.\n# Un par de primos se considera distinto si los primos en el par son diferentes, independientemente de su orden.\n#\n# Ejemplo:\n# >>> count_prime_pairs(10)\n# 2 (ya que 10 se puede expresar como 3+7 y 5+5)\n# >>> count_prime_pairs(14)\n# 2 (ya que 14 se puede expresar como 3+11 y 7+7)\n\ndef count_prime_pairs(even_number)",
      "arb": "# هذه الدالة تحسب عدد الأزواج المختلفة من الأعداد الأولية التي يكون مجموعها مساوياً لعدد زوجي معين.\n# تقبل الدالة وسيطاً واحداً، even_number، وهو عدد زوجي أكبر من 6 وأقل من 32767.\n# تُرجع عدد الأزواج المميزة من الأعداد الأولية التي يكون مجموعها مساوياً للعدد الزوجي المعطى.\n# يُعتبر الزوج الأولي مميزاً إذا كانت الأعداد الأولية في الزوج مختلفة، بغض النظر عن ترتيبها.\n#\n# مثال:\n# >>> count_prime_pairs(10)\n# 2 (لأن 10 يمكن التعبير عنه كـ 3+7 و 5+5)\n# >>> count_prime_pairs(14)\n# 2 (لأن 14 يمكن التعبير عنه كـ 3+11 و 7+7)\n\ndef count_prime_pairs(even_number)",
      "sw": "# Kazi ya hii kazi ni kuhesabu idadi ya jozi tofauti za nambari za msingi ambazo jumla yao ni sawa na nambari fulani ya jozi.\n# Kazi hii inakubali hoja moja, even_number, ambayo ni nambari ya jozi kubwa kuliko 6 na ndogo kuliko 32767.\n# Inarudisha hesabu ya jozi tofauti za msingi ambazo jumla yao ni sawa na nambari ya jozi iliyotolewa.\n# Jozi ya msingi inachukuliwa kuwa tofauti ikiwa nambari za msingi katika jozi ni tofauti, bila kujali mpangilio wao.\n#\n# Mfano:\n# >>> count_prime_pairs(10)\n# 2 (kwa kuwa 10 inaweza kuonyeshwa kama 3+7 na 5+5)\n# >>> count_prime_pairs(14)\n# 2 (kwa kuwa 14 inaweza kuonyeshwa kama 3+11 na 7+7)\n\ndef count_prime_pairs(even_number)",
      "tr": "# Bu fonksiyon, toplamı verilen bir çift sayıya eşit olan farklı asal çiftlerin sayısını hesaplar.\n# Fonksiyon, 6'dan büyük ve 32767'den küçük bir çift sayı olan even_number adlı tek bir argüman alır.\n# Verilen çift sayıya eşit toplamı olan farklı asal çiftlerin sayısını döndürür.\n# Bir asal çift, çiftteki asal sayılar farklıysa, sıralarına bakılmaksızın farklı kabul edilir.\n#\n# Örnek:\n# >>> count_prime_pairs(10)\n# 2 (çünkü 10, 3+7 ve 5+5 olarak ifade edilebilir)\n# >>> count_prime_pairs(14)\n# 2 (çünkü 14, 3+11 ve 7+7 olarak ifade edilebilir)\n\ndef count_prime_pairs(even_number)",
      "vi": "# Hàm này tính toán số cặp số nguyên tố khác nhau có tổng bằng một số chẵn cho trước.\n# Hàm chấp nhận một đối số, even_number, là một số chẵn lớn hơn 6 và nhỏ hơn 32767.\n# Nó trả về số lượng cặp số nguyên tố khác nhau có tổng bằng số chẵn cho trước.\n# Một cặp số nguyên tố được coi là khác nhau nếu các số nguyên tố trong cặp là khác nhau, không phân biệt thứ tự.\n#\n# Ví dụ:\n# >>> count_prime_pairs(10)\n# 2 (vì 10 có thể được biểu diễn dưới dạng 3+7 và 5+5)\n# >>> count_prime_pairs(14)\n# 2 (vì 14 có thể được biểu diễn dưới dạng 3+11 và 7+7)\n\ndef count_prime_pairs(even_number)"
    },
    "prompt_bertscore": {
      "es": "0.9776467328094768",
      "arb": "0.9706763954782005",
      "sw": "0.9663857806174658",
      "tr": "0.9691235031592698",
      "vi": "0.9776441506145234"
    },
    "canonical_solution": "    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n",
    "instruction": {
      "en": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8619570495706597",
      "sw": "0.9151651628903803",
      "tr": "0.8527000792929097",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_prime_pairs(10) == 2\nraise 'Test failed' unless count_prime_pairs(14) == 2\nraise 'Test failed' unless count_prime_pairs(20) == 2\nraise 'Test failed' unless count_prime_pairs(26) == 3\nraise 'Test failed' unless count_prime_pairs(100) == 6\nraise 'Test failed' unless count_prime_pairs(1234) == 25\n\n\nputs 'All tests passed!'",
    "entry_point": "count_prime_pairs",
    "signature": "def count_prime_pairs(even_number)",
    "docstring": {
      "en": "This function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n\nExample:\n>>> count_prime_pairs(10)\n2 (since 10 can be expressed as 3+7 and 5+5)\n>>> count_prime_pairs(14)\n2 (since 14 can be expressed as 3+11 and 7+7)",
      "es": "Esta función calcula el número de diferentes pares de primos cuya suma es igual a un número par dado.  \nLa función acepta un único argumento, even_number, que es un número par mayor que 6 y menor que 32767.  \nDevuelve el conteo de pares de primos distintos cuya suma es igual al número par dado.  \nSe considera que un par de primos es distinto si los primos en el par son diferentes, independientemente de su orden.  \n\nEjemplo:  \n>>> count_prime_pairs(10)  \n2 (ya que 10 se puede expresar como 3+7 y 5+5)  \n>>> count_prime_pairs(14)  \n2 (ya que 14 se puede expresar como 3+11 y 7+7)",
      "arb": "هذه الدالة تحسب عدد الأزواج المختلفة من الأعداد الأولية التي يكون مجموعها مساوياً لعدد زوجي معين.\nتقبل الدالة وسيطاً واحداً، even_number، وهو عدد زوجي أكبر من 6 وأقل من 32767.\nتُرجع عدد الأزواج المميزة من الأعداد الأولية التي يكون مجموعها مساوياً للعدد الزوجي المعطى.\nيعتبر الزوج الأولي مميزاً إذا كانت الأعداد الأولية في الزوج مختلفة، بغض النظر عن ترتيبها.\n\nمثال:\n>>> count_prime_pairs(10)\n2 (لأن 10 يمكن التعبير عنه كـ 3+7 و 5+5)\n>>> count_prime_pairs(14)\n2 (لأن 14 يمكن التعبير عنه كـ 3+11 و 7+7)",
      "sw": "Kazi ya hii kazi ni kuhesabu idadi ya jozi tofauti za namba za kwanza ambazo jumla yao ni sawa na namba fulani ya jozi.\nKazi hii inakubali hoja moja, even_number, ambayo ni namba ya jozi iliyo kubwa kuliko 6 na chini ya 32767.\nInarudisha idadi ya jozi tofauti za namba za kwanza ambazo jumla yao ni sawa na namba ya jozi iliyotolewa.\nJozi ya namba za kwanza inachukuliwa kuwa tofauti ikiwa namba za kwanza katika jozi ni tofauti, bila kujali mpangilio wao.\n\nMfano:\n>>> count_prime_pairs(10)\n2 (kwa kuwa 10 inaweza kuonyeshwa kama 3+7 na 5+5)\n>>> count_prime_pairs(14)\n2 (kwa kuwa 14 inaweza kuonyeshwa kama 3+11 na 7+7)",
      "tr": "Bu fonksiyon, toplamı verilen bir çift sayıya eşit olan farklı asal çiftlerin sayısını hesaplar.\nFonksiyon, 6'dan büyük ve 32767'den küçük bir çift sayı olan even_number adlı tek bir argüman alır.\nVerilen çift sayıya eşit olan farklı asal çiftlerin sayısını döndürür.\nBir asal çift, çifti oluşturan asal sayılar farklı olduğu sürece, sıralarına bakılmaksızın farklı kabul edilir.\n\nÖrnek:\n>>> count_prime_pairs(10)\n2 (çünkü 10, 3+7 ve 5+5 olarak ifade edilebilir)\n>>> count_prime_pairs(14)\n2 (çünkü 14, 3+11 ve 7+7 olarak ifade edilebilir)",
      "vi": "Hàm này tính toán số lượng cặp số nguyên tố khác nhau có tổng bằng một số chẵn cho trước. Hàm chấp nhận một đối số duy nhất, even_number, là một số chẵn lớn hơn 6 và nhỏ hơn 32767. Nó trả về số lượng cặp số nguyên tố khác nhau có tổng bằng số chẵn cho trước. Một cặp số nguyên tố được coi là khác nhau nếu các số nguyên tố trong cặp là khác nhau, bất kể thứ tự của chúng.\n\nVí dụ:\n>>> count_prime_pairs(10)\n2 (vì 10 có thể được biểu diễn dưới dạng 3+7 và 5+5)\n>>> count_prime_pairs(14)\n2 (vì 14 có thể được biểu diễn dưới dạng 3+11 và 7+7)"
    },
    "docstring_bertscore": {
      "es": "0.9759154704083767",
      "arb": "0.9574323175619373",
      "sw": "0.8600339102214798",
      "tr": "0.966989418345431",
      "vi": "0.9843743438151284"
    }
  },
  {
    "task_id": "Ruby/23",
    "prompt": {
      "en": "# Calculates the minimum number of character operations needed to transform one string into another.\n# The function takes two string arguments, str_a and str_b. The operations allowed are:\n# 1. Delete a character;\n# 2. Insert a character;\n# 3. Replace a character with another.\n# It returns an integer representing the minimum number of operations required to transform str_a into str_b.\n# Both strings should have a length less than 200.\n#\n# Example:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "es": "# Calcula el número mínimo de operaciones de caracteres necesarias para transformar una cadena en otra.\n# La función toma dos argumentos de cadena, str_a y str_b. Las operaciones permitidas son:\n# 1. Eliminar un carácter;\n# 2. Insertar un carácter;\n# 3. Reemplazar un carácter por otro.\n# Devuelve un entero que representa el número mínimo de operaciones requeridas para transformar str_a en str_b.\n# Ambas cadenas deben tener una longitud menor a 200.\n#\n# Ejemplo:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "arb": "# يحسب الحد الأدنى لعدد العمليات على الأحرف اللازمة لتحويل سلسلة نصية إلى أخرى.\n# تأخذ الدالة وسيطين من نوع سلسلة نصية، str_a و str_b. العمليات المسموح بها هي:\n# 1. حذف حرف؛\n# 2. إدراج حرف؛\n# 3. استبدال حرف بآخر.\n# تُرجع عددًا صحيحًا يمثل الحد الأدنى لعدد العمليات المطلوبة لتحويل str_a إلى str_b.\n# يجب أن يكون طول كلا السلسلتين أقل من 200.\n#\n# مثال:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "sw": "# Inakokotoa idadi ndogo ya operesheni za herufi zinazohitajika kubadilisha kamba moja kuwa nyingine.\n# Kazi inachukua hoja mbili za kamba, str_a na str_b. Operesheni zinazokubalika ni:\n# 1. Kufuta herufi;\n# 2. Kuongeza herufi;\n# 3. Kubadilisha herufi moja na nyingine.\n# Inarudisha namba kamili inayowakilisha idadi ndogo ya operesheni zinazohitajika kubadilisha str_a kuwa str_b.\n# Kamba zote mbili zinapaswa kuwa na urefu chini ya 200.\n#\n# Mfano:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "tr": "# Bir dizeyi başka bir dizeye dönüştürmek için gereken minimum karakter işlemi sayısını hesaplar.\n# Fonksiyon iki dize argümanı alır, str_a ve str_b. İzin verilen işlemler şunlardır:\n# 1. Bir karakteri sil;\n# 2. Bir karakter ekle;\n# 3. Bir karakteri başka bir karakterle değiştir.\n# Bu, str_a'yı str_b'ye dönüştürmek için gereken minimum işlem sayısını temsil eden bir tamsayı döndürür.\n# Her iki dize de 200'den kısa bir uzunluğa sahip olmalıdır.\n#\n# Örnek:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "vi": "# Tính toán số lượng tối thiểu các thao tác ký tự cần thiết để biến đổi một chuỗi thành chuỗi khác.\n# Hàm nhận hai đối số chuỗi, str_a và str_b. Các thao tác được phép là:\n# 1. Xóa một ký tự;\n# 2. Chèn một ký tự;\n# 3. Thay thế một ký tự bằng ký tự khác.\n# Nó trả về một số nguyên đại diện cho số lượng tối thiểu các thao tác cần thiết để biến đổi str_a thành str_b.\n# Cả hai chuỗi nên có độ dài nhỏ hơn 200.\n#\n# Ví dụ:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)"
    },
    "prompt_bertscore": {
      "es": "0.990628618622774",
      "arb": "0.9844085082406665",
      "sw": "0.9777591576051425",
      "tr": "0.9911345302032698",
      "vi": "0.9953216586354853"
    },
    "canonical_solution": "    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end",
    "instruction": {
      "en": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan özlü bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9471186336570817",
      "arb": "0.8857362842666323",
      "sw": "0.9151651628903803",
      "tr": "0.8620724538220409",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless min_operations_to_transform(\"apple\", \"aple\") == 1\nraise 'Test failed' unless min_operations_to_transform(\"kitten\", \"sitting\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"sfdxbqw\", \"gfdgw\") == 4\nraise 'Test failed' unless min_operations_to_transform(\"horse\", \"ros\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"\", \"abc\") == 3\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_operations_to_transform",
    "signature": "def min_operations_to_transform(str_a, str_b)",
    "docstring": {
      "en": "Calculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\nExample:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "es": "Calcula el número mínimo de operaciones de caracteres necesarias para transformar una cadena en otra. La función toma dos argumentos de cadena, str_a y str_b. Las operaciones permitidas son:\n1. Eliminar un carácter;\n2. Insertar un carácter;\n3. Reemplazar un carácter por otro.\nDevuelve un entero que representa el número mínimo de operaciones requeridas para transformar str_a en str_b. Ambas cadenas deben tener una longitud menor a 200.\n\nEjemplo:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "arb": "يحسب الحد الأدنى لعدد العمليات على الأحرف اللازمة لتحويل سلسلة نصية إلى أخرى.  \nتأخذ الدالة وسيطين من نوع سلسلة نصية، str_a و str_b. العمليات المسموح بها هي:  \n1. حذف حرف؛  \n2. إدراج حرف؛  \n3. استبدال حرف بآخر.  \nتعيد عددًا صحيحًا يمثل الحد الأدنى لعدد العمليات المطلوبة لتحويل str_a إلى str_b.  \nيجب أن يكون طول كلتا السلسلتين أقل من 200.  \n\nمثال:  \n>>> min_operations_to_transform(\"apple\", \"aple\")  \n1  \n>>> min_operations_to_transform(\"kitten\", \"sitting\")  \n3  ",
      "sw": "Hesabu idadi ndogo ya operesheni za herufi zinazohitajika kubadilisha kamba moja kuwa nyingine. \nKazi hii inachukua hoja mbili za kamba, str_a na str_b. Operesheni zinazokubalika ni: \n1. Futa herufi; \n2. Ingiza herufi; \n3. Badilisha herufi moja na nyingine. \nInarudisha nambari kamili inayowakilisha idadi ndogo ya operesheni zinazohitajika kubadilisha str_a kuwa str_b. \nKamba zote mbili zinapaswa kuwa na urefu chini ya 200.\n\nMfano:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "tr": "Bir dizeyi başka bir dizeye dönüştürmek için gereken minimum karakter işlemi sayısını hesaplar.\nFonksiyon iki dize argümanı alır, str_a ve str_b. İzin verilen işlemler şunlardır:\n1. Bir karakteri sil;\n2. Bir karakter ekle;\n3. Bir karakteri başka bir karakterle değiştir.\nBu, str_a'yı str_b'ye dönüştürmek için gereken minimum işlem sayısını temsil eden bir tamsayı döndürür.\nHer iki dizenin uzunluğu 200'den az olmalıdır.\n\nÖrnek:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "vi": "Tính toán số lượng tối thiểu các thao tác ký tự cần thiết để biến đổi một chuỗi thành một chuỗi khác. Hàm nhận hai đối số chuỗi, str_a và str_b. Các thao tác được phép là:\n1. Xóa một ký tự;\n2. Chèn một ký tự;\n3. Thay thế một ký tự bằng ký tự khác.\nHàm trả về một số nguyên đại diện cho số lượng tối thiểu các thao tác cần thiết để biến đổi str_a thành str_b. Cả hai chuỗi nên có độ dài nhỏ hơn 200.\n\nVí dụ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3"
    },
    "docstring_bertscore": {
      "es": "0.9885356502978093",
      "arb": "0.9645981071881519",
      "sw": "0.987577258709316",
      "tr": "0.9777796165343892",
      "vi": "0.9834685892776094"
    }
  },
  {
    "task_id": "Ruby/24",
    "prompt": {
      "en": "# Reverses the order of words in a given sentence and reverses each word itself.\n# The function takes a single argument, 'sentence', which is a string. It returns \n# a new string with each word in the sentence reversed and the order of words also reversed.\n# Punctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words \n# and is removed in the returned string.\n#\n# Example:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "es": "# Invierte el orden de las palabras en una oración dada y también invierte cada palabra en sí misma.\n# La función toma un solo argumento, 'sentence', que es una cadena de texto. Devuelve\n# una nueva cadena con cada palabra en la oración invertida y el orden de las palabras también invertido.\n# La puntuación (espacios, comas, puntos, signos de exclamación, signos de interrogación) se utiliza para identificar palabras\n# y se elimina en la cadena devuelta.\n#\n# Ejemplo:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "arb": "# يعكس ترتيب الكلمات في جملة معينة ويعكس كل كلمة بحد ذاتها.\n# تأخذ الدالة وسيطًا واحدًا، 'sentence'، وهو عبارة عن سلسلة نصية. تُرجع\n# سلسلة نصية جديدة مع كل كلمة في الجملة معكوسة وترتيب الكلمات أيضًا معكوس.\n# يتم استخدام علامات الترقيم (المسافات، الفواصل، النقاط، علامات التعجب، علامات الاستفهام) لتحديد الكلمات\n# ويتم إزالتها في السلسلة النصية المُرجعة.\n#\n# مثال:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "sw": "# Inarudisha mpangilio wa maneno katika sentensi iliyotolewa na kubadilisha kila neno lenyewe.\n# Kazi inachukua hoja moja, 'sentence', ambayo ni kamba. Inarudisha \n# kamba mpya na kila neno katika sentensi limebadilishwa na mpangilio wa maneno pia umebadilishwa.\n# Alama za uakifishaji (nafasi, koma, nukta, alama za mshangao, alama za kuuliza) zinatumika kutambua maneno \n# na zinaondolewa katika kamba inayorejeshwa.\n#\n# Mfano:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "tr": "# Verilen bir cümledeki kelimelerin sırasını tersine çevirir ve her kelimenin kendisini de tersine çevirir.\n# Fonksiyon, bir dize olan 'sentence' adlı tek bir argüman alır. Cümledeki her kelimenin tersine çevrilmiş \n# haliyle ve kelimelerin sırasının da tersine çevrilmiş haliyle yeni bir dize döndürür.\n# Noktalama işaretleri (boşluklar, virgüller, noktalar, ünlem işaretleri, soru işaretleri) kelimeleri \n# tanımlamak için kullanılır ve döndürülen dizide kaldırılır.\n#\n# Örnek:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "vi": "# Đảo ngược thứ tự của các từ trong một câu cho trước và đảo ngược từng từ.\n# Hàm nhận một đối số duy nhất, 'sentence', là một chuỗi. Nó trả về\n# một chuỗi mới với mỗi từ trong câu được đảo ngược và thứ tự của các từ cũng bị đảo ngược.\n# Dấu câu (khoảng trắng, dấu phẩy, dấu chấm, dấu chấm than, dấu chấm hỏi) được sử dụng để xác định từ\n# và bị loại bỏ trong chuỗi trả về.\n#\n# Ví dụ:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)"
    },
    "prompt_bertscore": {
      "es": "0.9891639181930227",
      "arb": "0.9937898211369443",
      "sw": "0.9790075495499468",
      "tr": "0.9820954574535152",
      "vi": "0.9738304472986535"
    },
    "canonical_solution": "    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end",
    "instruction": {
      "en": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9428772791308437",
      "tr": "0.850025918473037",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless reverse_words_in_sentence(\"hello world!\") == \"dlrow olleh\"\nraise 'Test failed' unless reverse_words_in_sentence(\"This is, a test.\") == \"tset a si sihT\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Ruby, programming!\") == \"gnimmargorp ybuR\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Keep calm and code on.\") == \"no edoc dna mlac peeK\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Simple sentence.\") == \"ecnetnes elpmiS\"\n\n\n\nputs 'All tests passed!'",
    "entry_point": "reverse_words_in_sentence",
    "signature": "def reverse_words_in_sentence(sentence)",
    "docstring": {
      "en": "Reverses the order of words in a given sentence and reverses each word itself.\nThe function takes a single argument, 'sentence', which is a string. It returns\na new string with each word in the sentence reversed and the order of words also reversed.\nPunctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words\nand is removed in the returned string.\n\nExample:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "es": "Invierte el orden de las palabras en una oración dada e invierte cada palabra en sí misma.  \nLa función toma un solo argumento, 'sentence', que es una cadena. Devuelve una nueva cadena con cada palabra en la oración invertida y el orden de las palabras también invertido.  \nLa puntuación (espacios, comas, puntos, signos de exclamación, signos de interrogación) se utiliza para identificar palabras y se elimina en la cadena devuelta.\n\nEjemplo:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "arb": "يعكس ترتيب الكلمات في جملة معينة ويعكس كل كلمة بحد ذاتها.  \nتأخذ الدالة وسيطًا واحدًا، 'sentence'، وهو سلسلة نصية. تُرجع سلسلة نصية جديدة مع كل كلمة في الجملة معكوسة وترتيب الكلمات أيضًا معكوس.  \nتُستخدم علامات الترقيم (المسافات، الفواصل، النقاط، علامات التعجب، علامات الاستفهام) لتحديد الكلمات ويتم إزالتها في السلسلة النصية المُعادة.  \n\nمثال:  \n>>> reverse_words_in_sentence(\"hello world!\")  \n\"dlrow olleh\"  \n>>> reverse_words_in_sentence(\"This is, a test.\")  \n\"tset a si sihT\"  ",
      "sw": "Inarudisha mpangilio wa maneno katika sentensi iliyotolewa na kugeuza kila neno lenyewe.\nKazi hii inachukua hoja moja, 'sentence', ambayo ni kamba. Inarudisha\nkamba mpya na kila neno katika sentensi limegeuzwa na mpangilio wa maneno pia umegeuzwa.\nAlama za uakifishaji (nafasi, koma, nukta, alama za mshangao, alama za kuuliza) zinatumika kutambua maneno\nna zinaondolewa katika kamba inayorudishwa.\n\nMfano:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "tr": "Verilen bir cümledeki kelimelerin sırasını tersine çevirir ve her kelimenin kendisini de tersine çevirir. \nFonksiyon, 'sentence' adında bir dize olan tek bir argüman alır. Cümledeki her kelimenin tersine çevrildiği ve kelimelerin sırasının da tersine çevrildiği yeni bir dize döndürür. \nNoktalama işaretleri (boşluklar, virgüller, noktalar, ünlem işaretleri, soru işaretleri) kelimeleri tanımlamak için kullanılır ve döndürülen dizede kaldırılır.\n\nÖrnek:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "vi": "Đảo ngược thứ tự của các từ trong một câu cho trước và đảo ngược từng từ.  \nHàm nhận một đối số duy nhất, 'sentence', là một chuỗi. Nó trả về  \nmột chuỗi mới với mỗi từ trong câu được đảo ngược và thứ tự của các từ cũng được đảo ngược.  \nDấu câu (khoảng trắng, dấu phẩy, dấu chấm, dấu chấm than, dấu chấm hỏi) được sử dụng để xác định từ  \nvà bị loại bỏ trong chuỗi trả về.\n\nVí dụ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\""
    },
    "docstring_bertscore": {
      "es": "0.9855941329850637",
      "arb": "0.9869640867230614",
      "sw": "0.9732939466394782",
      "tr": "0.9686593039587912",
      "vi": "0.9790419126058658"
    }
  },
  {
    "task_id": "Ruby/25",
    "prompt": {
      "en": "# Calculates the number of unique permutations of a given string.\n# The function takes a single argument, str, which is a string consisting of\n# lowercase letters. It returns the total number of unique permutations that\n# can be formed with the characters in str.\n#\n# Example:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "es": "# Calcula el número de permutaciones únicas de una cadena dada.\n# La función toma un solo argumento, str, que es una cadena compuesta de\n# letras minúsculas. Devuelve el número total de permutaciones únicas que\n# se pueden formar con los caracteres en str.\n#\n# Ejemplo:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "arb": "# يحسب عدد التباديل الفريدة لسلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة تتكون من\n# حروف صغيرة. تُرجع العدد الإجمالي للتباديل الفريدة التي\n# يمكن تشكيلها بالحروف في str.\n#\n# مثال:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "sw": "# Inahesabu idadi ya mpangilio wa kipekee wa herufi katika kamba fulani.\n# Kazi inachukua hoja moja, str, ambayo ni kamba inayojumuisha\n# herufi ndogo. Inarudisha jumla ya idadi ya mpangilio wa kipekee ambao\n# unaweza kuundwa na herufi katika str.\n#\n# Mfano:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "tr": "# Verilen bir stringin benzersiz permütasyonlarının sayısını hesaplar.\n# Fonksiyon, küçük harflerden oluşan bir string olan str adlı tek bir argüman alır.\n# str içindeki karakterlerle oluşturulabilecek toplam benzersiz permütasyon sayısını döndürür.\n#\n# Örnek:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "vi": "# Tính toán số lượng hoán vị duy nhất của một chuỗi cho trước.\n# Hàm nhận một đối số, str, là một chuỗi bao gồm các chữ cái thường.\n# Nó trả về tổng số hoán vị duy nhất có thể được tạo ra với các ký tự trong str.\n#\n# Ví dụ:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)"
    },
    "prompt_bertscore": {
      "es": "0.9975967710198589",
      "arb": "0.9906159062783877",
      "sw": "0.9598722931625698",
      "tr": "0.9819031832446734",
      "vi": "0.9803892224804255"
    },
    "canonical_solution": "    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end",
    "instruction": {
      "en": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olacak şekilde olmalıdır.",
      "vi": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.888433088949943",
      "sw": "0.9428772791308437",
      "tr": "0.8557601789431332",
      "vi": "0.9513240360843523"
    },
    "level": "",
    "test": "raise 'Test failed' unless unique_permutations_count(\"aacc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abcd\") == 24\nraise 'Test failed' unless unique_permutations_count(\"aaa\") == 1\nraise 'Test failed' unless unique_permutations_count(\"ab\") == 2\nraise 'Test failed' unless unique_permutations_count(\"aacdarwqea\") == 151200\n\n  \n\nputs 'All tests passed!'",
    "entry_point": "unique_permutations_count",
    "signature": "def unique_permutations_count(str)",
    "docstring": {
      "en": "Calculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n\nExample:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "es": "Calcula el número de permutaciones únicas de una cadena dada.  \nLa función toma un solo argumento, str, que es una cadena que consiste en  \nletras minúsculas. Devuelve el número total de permutaciones únicas que  \nse pueden formar con los caracteres en str.\n\nEjemplo:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "arb": "يحسب عدد التباديل الفريدة لسلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة تتكون من أحرف صغيرة. تُرجع العدد الإجمالي للتباديل الفريدة التي يمكن تشكيلها باستخدام الأحرف في str.\n\nمثال:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "sw": "Hesabu idadi ya mpangilio wa kipekee wa herufi katika kamba fulani.  \nKazi hii inachukua hoja moja, str, ambayo ni kamba inayojumuisha herufi ndogo. Inarejesha jumla ya idadi ya mpangilio wa kipekee ambao unaweza kuundwa na herufi katika str.\n\nMfano:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "tr": "Verilen bir dizgenin benzersiz permütasyonlarının sayısını hesaplar. \nFonksiyon, küçük harflerden oluşan bir dizge olan str adlı tek bir argüman alır. \nBu dizgedeki karakterlerle oluşturulabilecek benzersiz permütasyonların toplam sayısını döndürür.\n\nÖrnek:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "vi": "Tính toán số lượng hoán vị duy nhất của một chuỗi cho trước. Hàm này nhận một đối số, str, là một chuỗi bao gồm các chữ cái thường. Nó trả về tổng số hoán vị duy nhất có thể được tạo thành từ các ký tự trong str.\n\nVí dụ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6"
    },
    "docstring_bertscore": {
      "es": "0.9969561880410214",
      "arb": "0.987053271764146",
      "sw": "0.9654510260443157",
      "tr": "0.983432438548261",
      "vi": "0.981006962965444"
    }
  },
  {
    "task_id": "Ruby/26",
    "prompt": {
      "en": "# Finds the longest palindrome within a given string.\n# The function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\n# It returns the length of the longest palindrome that can be found within the string.\n# Palindromes are sequences that read the same backward as forward.\n# Note: The function is case-sensitive and considers each character.\n#\n# Example:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "es": "# Encuentra el palíndromo más largo dentro de una cadena dada.\n# La función toma un solo argumento, str, que es una cadena que puede incluir letras, números y símbolos.\n# Devuelve la longitud del palíndromo más largo que se puede encontrar dentro de la cadena.\n# Los palíndromos son secuencias que se leen igual de adelante hacia atrás que de atrás hacia adelante.\n# Nota: La función distingue entre mayúsculas y minúsculas y considera cada carácter.\n#\n# Ejemplo:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "arb": "# يجد أطول جملة متناظرة داخل سلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، وهو str، وهو سلسلة قد تحتوي على حروف وأرقام ورموز.\n# تُعيد طول أطول جملة متناظرة يمكن العثور عليها داخل السلسلة.\n# الجمل المتناظرة هي تسلسلات تقرأ بنفس الطريقة من الأمام والخلف.\n# ملاحظة: الدالة حساسة لحالة الأحرف وتعتبر كل حرف.\n#\n# مثال:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "sw": "# Inapata palindrome ndefu zaidi ndani ya mfuatano uliotolewa.\n# Kazi hii inachukua hoja moja, str, ambayo ni mfuatano unaoweza kujumuisha herufi, nambari, na alama.\n# Inarudisha urefu wa palindrome ndefu zaidi inayoweza kupatikana ndani ya mfuatano huo.\n# Palindrome ni mfuatano unaosomwa sawa mbele na nyuma.\n# Kumbuka: Kazi hii inazingatia ukubwa wa herufi na inachukulia kila herufi.\n#\n# Mfano:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "tr": "# Verilen bir string içinde en uzun palindromu bulur.\n# Fonksiyon, harfler, sayılar ve semboller içerebilen bir string olan tek bir argüman alır, str.\n# String içinde bulunabilecek en uzun palindromun uzunluğunu döndürür.\n# Palindromlar, tersten okunduğunda da aynı olan dizilerdir.\n# Not: Fonksiyon büyük/küçük harf duyarlıdır ve her karakteri dikkate alır.\n#\n# Örnek:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "vi": "# Tìm chuỗi palindrome dài nhất trong một chuỗi cho trước.\n# Hàm nhận một đối số, str, là một chuỗi có thể bao gồm chữ cái, số và ký hiệu.\n# Nó trả về độ dài của chuỗi palindrome dài nhất có thể tìm thấy trong chuỗi.\n# Palindrome là các chuỗi đọc giống nhau khi đảo ngược.\n# Lưu ý: Hàm phân biệt chữ hoa chữ thường và xem xét từng ký tự.\n#\n# Ví dụ:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)"
    },
    "prompt_bertscore": {
      "es": "0.9889444316219792",
      "arb": "0.9533454974721445",
      "sw": "0.9754814630258155",
      "tr": "0.9925312990427072",
      "vi": "0.9711431768736325"
    },
    "canonical_solution": "    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end",
    "instruction": {
      "en": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nAşağıdaki Ruby kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9151651628903803",
      "tr": "0.8776325619811709",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_longest_palindrome(\"ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"12ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"A\") == 1\nraise 'Test failed' unless find_longest_palindrome(\"ABAKK\") == 3\nraise 'Test failed' unless find_longest_palindrome(\"51233214\") == 6\nraise 'Test failed' unless find_longest_palindrome(\"abaaab\") == 5\n\n\nputs 'All tests passed!'",
    "entry_point": "find_longest_palindrome",
    "signature": "def find_longest_palindrome(str)",
    "docstring": {
      "en": "Finds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n\nExample:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "es": "Encuentra el palíndromo más largo dentro de una cadena dada.\nLa función toma un único argumento, str, que es una cadena que puede incluir letras, números y símbolos.\nDevuelve la longitud del palíndromo más largo que se puede encontrar dentro de la cadena.\nLos palíndromos son secuencias que se leen igual hacia adelante que hacia atrás.\nNota: La función distingue entre mayúsculas y minúsculas y considera cada carácter.\n\nEjemplo:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "arb": "يجد أطول جملة مقلوبة داخل سلسلة معينة.\nتأخذ الدالة وسيطًا واحدًا، str، وهو سلسلة قد تحتوي على حروف وأرقام ورموز.\nتعيد طول أطول جملة مقلوبة يمكن العثور عليها داخل السلسلة.\nالجمل المقلوبة هي تسلسلات تقرأ بنفس الطريقة من الأمام إلى الخلف والعكس.\nملاحظة: الدالة حساسة لحالة الأحرف وتعتبر كل حرف.\n\nمثال:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "sw": "Inapata palindrome ndefu zaidi ndani ya kamba iliyotolewa.\nKazi inachukua hoja moja, str, ambayo ni kamba inayoweza kujumuisha herufi, nambari, na alama.\nInarudisha urefu wa palindrome ndefu zaidi inayoweza kupatikana ndani ya kamba.\nPalindromes ni mfuatano unaosomwa sawa nyuma kama mbele.\nKumbuka: Kazi ni nyeti kwa herufi kubwa na inazingatia kila herufi.\n\nMfano:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "tr": "Verilen bir dizede en uzun palindromu bulur.\nFonksiyon, harfler, sayılar ve semboller içerebilen bir dize olan tek bir argüman, str, alır.\nDizede bulunabilecek en uzun palindromun uzunluğunu döndürür.\nPalindromlar, tersten de aynı şekilde okunan dizilerdir.\nNot: Fonksiyon büyük/küçük harfe duyarlıdır ve her karakteri dikkate alır.\n\nÖrnek:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "vi": "Tìm chuỗi palindrome dài nhất trong một chuỗi cho trước.  \nHàm nhận một đối số duy nhất, str, là một chuỗi có thể bao gồm chữ cái, số và ký hiệu.  \nNó trả về độ dài của chuỗi palindrome dài nhất có thể tìm thấy trong chuỗi.  \nPalindromes là các chuỗi mà khi đọc ngược lại cũng giống như khi đọc xuôi.  \nLưu ý: Hàm phân biệt chữ hoa chữ thường và xem xét từng ký tự.\n\nVí dụ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5"
    },
    "docstring_bertscore": {
      "es": "0.9864047435700671",
      "arb": "0.9804360992503497",
      "sw": "0.9889819727639948",
      "tr": "0.9883453623927779",
      "vi": "0.968140481403528"
    }
  },
  {
    "task_id": "Ruby/27",
    "prompt": {
      "en": "# Calculates the sum of two integers as perceived by Xiao Ming, a child who \n# simplifies numbers larger than 99 to their last two digits before addition, \n# and also keeps only the last two digits of the result if it exceeds 99.\n#\n# The function takes two arguments, a and b, which are non-negative integers, and \n# returns the final sum according to Xiao Ming's calculation method.\n#\n# Examples:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "es": "```python\n# Calcula la suma de dos enteros según lo percibe Xiao Ming, un niño que\n# simplifica los números mayores de 99 a sus dos últimos dígitos antes de la suma,\n# y también mantiene solo los dos últimos dígitos del resultado si excede 99.\n#\n# La función toma dos argumentos, a y b, que son enteros no negativos, y\n# devuelve la suma final según el método de cálculo de Xiao Ming.\n#\n# Ejemplos:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)\n```",
      "arb": "# يحسب مجموع عددين صحيحين كما يراه شياو مينغ، وهو طفل يقوم بتبسيط الأرقام \n# الأكبر من 99 إلى آخر رقمين قبل الجمع، ويحتفظ أيضًا بآخر رقمين فقط من \n# النتيجة إذا تجاوزت 99.\n#\n# تأخذ الدالة وسيطين، a و b، وهما عددان صحيحان غير سالبين، وتعيد \n# المجموع النهائي وفقًا لطريقة حساب شياو مينغ.\n#\n# أمثلة:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "sw": "# Inahesabu jumla ya namba mbili kama inavyoonekana na Xiao Ming, mtoto ambaye \n# anarahisisha namba kubwa kuliko 99 kwa kuchukua tarakimu mbili za mwisho kabla ya kujumlisha, \n# na pia anachukua tu tarakimu mbili za mwisho za matokeo ikiwa inazidi 99.\n#\n# Kazi inachukua hoja mbili, a na b, ambazo ni namba zisizo na alama hasi, na \n# inarudisha jumla ya mwisho kulingana na njia ya hesabu ya Xiao Ming.\n#\n# Mifano:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "tr": "# Xiao Ming tarafından algılandığı şekliyle iki tam sayının toplamını hesaplar, \n# 99'dan büyük sayıları toplama işleminden önce son iki basamağına indirger \n# ve sonuç 99'u aşarsa yalnızca son iki basamağını korur.\n#\n# Fonksiyon, a ve b olmak üzere iki argüman alır, bunlar negatif olmayan tam sayılardır, \n# ve Xiao Ming'in hesaplama yöntemine göre nihai toplamı döndürür.\n#\n# Örnekler:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "vi": "# Tính tổng của hai số nguyên như cách mà Tiểu Minh, một đứa trẻ, \n# đơn giản hóa các số lớn hơn 99 thành hai chữ số cuối trước khi cộng, \n# và cũng chỉ giữ lại hai chữ số cuối của kết quả nếu nó vượt quá 99.\n#\n# Hàm nhận hai tham số, a và b, là các số nguyên không âm, và \n# trả về tổng cuối cùng theo phương pháp tính toán của Tiểu Minh.\n#\n# Ví dụ:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)"
    },
    "prompt_bertscore": {
      "es": "0.9638590035403211",
      "arb": "0.9709818890042321",
      "sw": "0.9636677224833845",
      "tr": "0.9518651052422914",
      "vi": "0.9536309293296915"
    },
    "canonical_solution": "    a %= 100\n    b %= 100\n    (a + b) % 100\n  end",
    "instruction": {
      "en": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9428772791308437",
      "tr": "0.8900143854133618",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless ming_sum(35, 80) == 15\nraise 'Test failed' unless ming_sum(15, 1152) == 67\nraise 'Test failed' unless ming_sum(1234, 5678) == 12\nraise 'Test failed' unless ming_sum(0, 99) == 99\nraise 'Test failed' unless ming_sum(50, 50) == 0\n\n\n\n\nputs 'All tests passed!'",
    "entry_point": "ming_sum",
    "signature": "def ming_sum(a, b)",
    "docstring": {
      "en": "Calculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "es": "Calcula la suma de dos enteros según lo percibe Xiao Ming, un niño que simplifica los números mayores de 99 a sus dos últimos dígitos antes de la suma, y también conserva solo los dos últimos dígitos del resultado si supera 99.\n\nLa función toma dos argumentos, a y b, que son enteros no negativos, y devuelve la suma final según el método de cálculo de Xiao Ming.\n\nEjemplos:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "arb": "يحسب مجموع عددين صحيحين كما يراه شياو مينغ، وهو طفل يبسط الأرقام الأكبر من 99 إلى آخر رقمين قبل الجمع، ويحتفظ أيضًا بآخر رقمين فقط من النتيجة إذا تجاوزت 99.\n\nتأخذ الدالة معاملين، a و b، وهما عددان صحيحان غير سالبين، وتعيد المجموع النهائي وفقًا لطريقة حساب شياو مينغ.\n\nأمثلة:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "sw": "Hesabu jumla ya nambari mbili kama inavyoeleweka na Xiao Ming, mtoto ambaye\nhurahisisha nambari kubwa kuliko 99 kwa kuchukua tarakimu mbili za mwisho kabla ya kuongeza,\nna pia huhifadhi tu tarakimu mbili za mwisho za matokeo ikiwa yanazidi 99.\n\nKazi hii inachukua hoja mbili, a na b, ambazo ni nambari zisizo na alama hasi, na\ninarudisha jumla ya mwisho kulingana na mbinu ya hesabu ya Xiao Ming.\n\nMifano:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "tr": "İki tam sayının toplamını Xiao Ming'in algıladığı şekilde hesaplar. Xiao Ming, 99'dan büyük sayıları toplama işleminden önce son iki basamağına indirger ve sonuç 99'u aşarsa yine sadece son iki basamağı tutar.\n\nFonksiyon, a ve b olmak üzere iki argüman alır; bunlar negatif olmayan tam sayılardır ve Xiao Ming'in hesaplama yöntemine göre nihai toplamı döndürür.\n\nÖrnekler:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "vi": "Tính tổng của hai số nguyên theo cách hiểu của Tiểu Minh, một đứa trẻ mà đơn giản hóa các số lớn hơn 99 thành hai chữ số cuối cùng của chúng trước khi cộng, và cũng chỉ giữ lại hai chữ số cuối của kết quả nếu nó vượt quá 99.\n\nHàm nhận hai tham số, a và b, là các số nguyên không âm, và trả về tổng cuối cùng theo phương pháp tính toán của Tiểu Minh.\n\nVí dụ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67"
    },
    "docstring_bertscore": {
      "es": "0.9821921904490791",
      "arb": "0.983830692462236",
      "sw": "0.9594476214079172",
      "tr": "0.9379001976732526",
      "vi": "0.9313138128685167"
    }
  },
  {
    "task_id": "Ruby/28",
    "prompt": {
      "en": "# Finds the longest word in a given sentence.\n# The function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\n# Each word is composed only of lowercase letters. The function returns the longest word found in the sentence.\n# If there are multiple words of the same longest length, it returns the first one encountered.\n#\n# Example:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "es": "# Encuentra la palabra más larga en una oración dada.\n# La función toma un solo argumento, sentence, que es una cadena que contiene múltiples palabras separadas por espacios.\n# Cada palabra está compuesta solo por letras minúsculas. La función devuelve la palabra más larga encontrada en la oración.\n# Si hay múltiples palabras de la misma longitud más larga, devuelve la primera que se encuentra.\n#\n# Ejemplo:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "arb": "# يجد أطول كلمة في جملة معينة.\n# تأخذ الدالة وسيطًا واحدًا، الجملة، وهي سلسلة تحتوي على كلمات متعددة مفصولة بمسافات.\n# كل كلمة تتكون فقط من حروف صغيرة. تعيد الدالة أطول كلمة موجودة في الجملة.\n# إذا كانت هناك عدة كلمات بنفس الطول الأطول، فإنها تعيد أول واحدة تم العثور عليها.\n#\n# مثال:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "sw": "# Inapata neno refu zaidi katika sentensi iliyotolewa.\n# Kazi inachukua hoja moja, sentence, ambayo ni kamba inayojumuisha maneno mengi yaliyotenganishwa na nafasi.\n# Kila neno lina herufi ndogo pekee. Kazi inarudisha neno refu zaidi lililopatikana katika sentensi.\n# Ikiwa kuna maneno mengi yenye urefu sawa, inarudisha la kwanza lililokutana.\n#\n# Mfano:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "tr": "# Verilen bir cümledeki en uzun kelimeyi bulur.\n# Fonksiyon, boşluklarla ayrılmış birden fazla kelime içeren bir string olan sentence adlı tek bir argüman alır.\n# Her kelime yalnızca küçük harflerden oluşur. Fonksiyon, cümlede bulunan en uzun kelimeyi döndürür.\n# Eğer aynı uzunlukta birden fazla kelime varsa, karşılaşılan ilkini döndürür.\n#\n# Örnek:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "vi": "# Tìm từ dài nhất trong một câu cho trước.\n# Hàm nhận một đối số duy nhất, sentence, là một chuỗi chứa nhiều từ được ngăn cách bởi dấu cách.\n# Mỗi từ chỉ bao gồm các chữ cái thường. Hàm trả về từ dài nhất tìm thấy trong câu.\n# Nếu có nhiều từ có cùng độ dài dài nhất, nó trả về từ đầu tiên gặp phải.\n#\n# Ví dụ:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)"
    },
    "prompt_bertscore": {
      "es": "0.9937763142710339",
      "arb": "0.9835436715616406",
      "sw": "0.9785270626582234",
      "tr": "0.9869527647913423",
      "vi": "0.989666651687422"
    },
    "canonical_solution": "  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend",
    "instruction": {
      "en": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة روبي باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nAşağıdaki Ruby kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9031176343894712",
      "sw": "0.9151651628903803",
      "tr": "0.8568462898666319",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_longest_word(\"I am a student\") == \"student\"\nraise 'Test failed' unless find_longest_word(\"The quick brown fox jumps over the lazy dog\") == \"quick\"\nraise 'Test failed' unless find_longest_word(\"Hello world\") == \"Hello\"\nraise 'Test failed' unless find_longest_word(\"A B C D EFG HI\") == \"EFG\"\nraise 'Test failed' unless find_longest_word(\"Ruby Python Java\") == \"Python\"",
    "entry_point": "find_longest_word",
    "signature": "def find_longest_word(sentence)",
    "docstring": {
      "en": "Finds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n\nExample:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "es": "Encuentra la palabra más larga en una oración dada.\nLa función toma un solo argumento, sentence, que es una cadena que contiene múltiples palabras separadas por espacios.\nCada palabra está compuesta solo por letras minúsculas. La función devuelve la palabra más larga encontrada en la oración.\nSi hay múltiples palabras de la misma longitud más larga, devuelve la primera que se encuentra.\n\nEjemplo:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "arb": "يجد أطول كلمة في جملة معينة.\nتأخذ الدالة وسيطًا واحدًا، sentence، وهو سلسلة تحتوي على كلمات متعددة مفصولة بمسافات.\nكل كلمة تتكون فقط من حروف صغيرة. تعيد الدالة أطول كلمة موجودة في الجملة.\nإذا كانت هناك كلمات متعددة بنفس الطول الأطول، فإنها تعيد أول واحدة تم العثور عليها.\n\nمثال:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "sw": "Inapata neno refu zaidi katika sentensi iliyotolewa.  \nKazi inachukua hoja moja, sentensi, ambayo ni kamba inayojumuisha maneno mengi yaliyotenganishwa na nafasi.  \nKila neno linaundwa tu na herufi ndogo. Kazi inarudisha neno refu zaidi lililopatikana katika sentensi.  \nIkiwa kuna maneno mengi ya urefu sawa mrefu zaidi, inarudisha la kwanza lililokutana nalo.  \n\nMfano:  \n>>> find_longest_word(\"I am a student\")  \n\"student\"  \n>>> find_longest_word(\"The quick brown fox\")  \n\"quick\"  ",
      "tr": "Verilen bir cümledeki en uzun kelimeyi bulur. \nFonksiyon, boşluklarla ayrılmış birden fazla kelime içeren bir dize olan sentence adlı tek bir argüman alır. \nHer kelime yalnızca küçük harflerden oluşur. Fonksiyon, cümlede bulunan en uzun kelimeyi döndürür. \nEğer aynı uzunlukta birden fazla kelime varsa, karşılaşılan ilkini döndürür.\n\nÖrnek:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "vi": "Tìm từ dài nhất trong một câu cho trước.  \nHàm nhận một đối số duy nhất, sentence, là một chuỗi chứa nhiều từ được ngăn cách bởi khoảng trắng.  \nMỗi từ chỉ bao gồm các chữ cái thường. Hàm trả về từ dài nhất được tìm thấy trong câu.  \nNếu có nhiều từ có cùng độ dài dài nhất, nó trả về từ đầu tiên được gặp.\n\nVí dụ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\""
    },
    "docstring_bertscore": {
      "es": "0.9885872941968784",
      "arb": "0.9829195749044289",
      "sw": "0.9817049501244006",
      "tr": "0.9798950300924106",
      "vi": "0.984604755057129"
    }
  },
  {
    "task_id": "Ruby/29",
    "prompt": {
      "en": "# Decrypts a message encrypted with Caesar's cipher.\n# The cipher shifts each letter in the message 5 positions to the right in the alphabet.\n# Non-letter characters are left unchanged. All letters are in uppercase.\n#\n# Example:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "es": "# Descifra un mensaje encriptado con el cifrado de César.\n# El cifrado desplaza cada letra del mensaje 5 posiciones a la derecha en el alfabeto.\n# Los caracteres que no son letras se dejan sin cambios. Todas las letras están en mayúsculas.\n#\n# Ejemplo:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "arb": "# يفك تشفير رسالة مشفرة بشيفرة قيصر.\n# تقوم الشيفرة بتحريك كل حرف في الرسالة 5 مواقع إلى اليمين في الأبجدية.\n# تظل الأحرف غير الحروف دون تغيير. جميع الحروف تكون بأحرف كبيرة.\n#\n# مثال:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "sw": "# Inafungua ujumbe uliosimbwa kwa kanuni ya Caesar.\n# Kanuni inasogeza kila herufi katika ujumbe nafasi 5 kulia katika alfabeti.\n# Herufi zisizo za herufi hazibadiliki. Herufi zote ziko katika herufi kubwa.\n#\n# Mfano:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "tr": "# Caesar şifrelemesiyle şifrelenmiş bir mesajı çözer.\n# Şifre, mesajdaki her harfi alfabede 5 pozisyon sağa kaydırır.\n# Harf olmayan karakterler değişmeden bırakılır. Tüm harfler büyük harfle yazılmıştır.\n#\n# Örnek:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "vi": "# Giải mã một thông điệp được mã hóa bằng mật mã Caesar.\n# Mật mã này dịch chuyển mỗi chữ cái trong thông điệp 5 vị trí sang phải trong bảng chữ cái.\n# Các ký tự không phải chữ cái được giữ nguyên. Tất cả các chữ cái đều ở dạng chữ hoa.\n#\n# Ví dụ:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)"
    },
    "prompt_bertscore": {
      "es": "0.9880448346262721",
      "arb": "0.9784281447284681",
      "sw": "0.982857403595165",
      "tr": "0.9930092037394771",
      "vi": "0.9891593496942589"
    },
    "canonical_solution": "    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9428772791308437",
      "tr": "0.8889821033231234",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX') == 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\nraise 'Test failed' unless decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ') == 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\nraise 'Test failed' unless decrypt_caesar_cipher('IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ') == 'DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE'\nraise 'Test failed' unless decrypt_caesar_cipher('ABCDEF') == 'VWXYZA'\nraise 'Test failed' unless decrypt_caesar_cipher('XYZ') == 'STU'\n\n  \n\n\nputs 'All tests passed!'",
    "entry_point": "decrypt_caesar_cipher",
    "signature": "def decrypt_caesar_cipher(message)",
    "docstring": {
      "en": "Decrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n\nExample:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "es": "Desencripta un mensaje cifrado con el cifrado de César.  \nEl cifrado desplaza cada letra en el mensaje 5 posiciones a la derecha en el alfabeto.  \nLos caracteres que no son letras se dejan sin cambios. Todas las letras están en mayúsculas.\n\nEjemplo:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "arb": "يفك تشفير رسالة مشفرة بشيفرة قيصر. \nتقوم الشيفرة بتحريك كل حرف في الرسالة 5 مواضع إلى اليمين في الأبجدية. \nتُترك الأحرف غير الحرفية دون تغيير. جميع الأحرف تكون بحروف كبيرة.\n\nمثال:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "sw": "Inafungua ujumbe uliosimbwa kwa kanuni ya Kaisari.\nKanuni hii inasogeza kila herufi katika ujumbe nafasi 5 kwenda kulia katika alfabeti.\nHerufi zisizo za alfabeti hazibadiliki. Herufi zote ziko katika herufi kubwa.\n\nMfano:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "tr": "Caesar şifrelemesiyle şifrelenmiş bir mesajı çözer.  \nŞifre, mesajdaki her harfi alfabede 5 pozisyon sağa kaydırır.  \nHarf olmayan karakterler değişmeden kalır. Tüm harfler büyük harfle yazılmıştır.\n\nÖrnek:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "vi": "Giải mã một thông điệp được mã hóa bằng mật mã Caesar.  \nMật mã dịch chuyển mỗi chữ cái trong thông điệp 5 vị trí sang phải trong bảng chữ cái.  \nCác ký tự không phải chữ cái được giữ nguyên. Tất cả các chữ cái đều ở dạng chữ hoa.\n\nVí dụ:  \n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'  \n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')  \n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'  "
    },
    "docstring_bertscore": {
      "es": "0.9899546657399226",
      "arb": "0.9884007802690866",
      "sw": "0.9784114597764612",
      "tr": "0.9912300714165476",
      "vi": "0.9883541021295434"
    }
  },
  {
    "task_id": "Ruby/30",
    "prompt": {
      "en": "# Calculates the number of possible photo arrangements for a group of people.\n# In this arrangement, people are lined up in such a way that the age difference\n# between any two adjacent persons is no more than two years.\n# The function takes a single integer argument, n, representing the number of people\n# in the group, where each person has a distinct age from 1 to n years.\n#\n# Example:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "es": "# Calcula el número de posibles arreglos de fotos para un grupo de personas.\n# En este arreglo, las personas están alineadas de tal manera que la diferencia de edad\n# entre dos personas adyacentes no es mayor de dos años.\n# La función toma un único argumento entero, n, que representa el número de personas\n# en el grupo, donde cada persona tiene una edad distinta de 1 a n años.\n#\n# Ejemplo:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "arb": "# يحسب عدد الترتيبات الممكنة للصور لمجموعة من الأشخاص.\n# في هذا الترتيب، يتم ترتيب الأشخاص بحيث لا يزيد فرق العمر\n# بين أي شخصين متجاورين عن سنتين.\n# تأخذ الدالة وسيطًا واحدًا من نوع عدد صحيح، n، يمثل عدد الأشخاص\n# في المجموعة، حيث يكون لكل شخص عمر مميز من 1 إلى n سنة.\n#\n# مثال:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "sw": "# Inahesabu idadi ya mipangilio ya picha inayowezekana kwa kundi la watu.\n# Katika mpangilio huu, watu wamepangwa kwa namna ambayo tofauti ya umri\n# kati ya mtu yeyote aliye karibu ni miaka isiyozidi miwili.\n# Kazi hii inachukua hoja moja ya nambari nzima, n, inayowakilisha idadi ya watu\n# katika kundi, ambapo kila mtu ana umri tofauti kutoka mwaka 1 hadi n.\n#\n# Mfano:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "tr": "# Bir grup insan için olası fotoğraf düzenlemelerinin sayısını hesaplar.\n# Bu düzenlemede, insanlar öyle bir sıraya dizilir ki, \n# bitişik iki kişi arasındaki yaş farkı iki yıldan fazla olmaz.\n# Fonksiyon, gruptaki kişi sayısını temsil eden tek bir tamsayı argümanı alır,\n# burada her kişinin yaşı 1'den n'e kadar benzersizdir.\n#\n# Örnek:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "vi": "# Tính toán số lượng cách sắp xếp ảnh có thể cho một nhóm người.\n# Trong cách sắp xếp này, mọi người được xếp hàng sao cho chênh lệch tuổi\n# giữa hai người liền kề không quá hai năm.\n# Hàm nhận một đối số nguyên, n, đại diện cho số người\n# trong nhóm, mỗi người có một độ tuổi khác nhau từ 1 đến n năm.\n#\n# Ví dụ:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)"
    },
    "prompt_bertscore": {
      "es": "0.9922134904330513",
      "arb": "0.9603388759276208",
      "sw": "0.9718880408025133",
      "tr": "0.9658045881225578",
      "vi": "0.9699315315493197"
    },
    "canonical_solution": "    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end",
    "instruction": {
      "en": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9151651628903803",
      "tr": "0.850025918473037",
      "vi": "0.9273999998406053"
    },
    "level": "",
    "test": "  \nraise 'Test failed' unless photo_arrangements_count(4) == 4\nraise 'Test failed' unless photo_arrangements_count(5) == 6\nraise 'Test failed' unless photo_arrangements_count(6) == 9\nraise 'Test failed' unless photo_arrangements_count(7) == 14\nraise 'Test failed' unless photo_arrangements_count(8) == 21\n  \n\nputs 'All tests passed!'",
    "entry_point": "photo_arrangements_count",
    "signature": "def photo_arrangements_count(n)",
    "docstring": {
      "en": "Calculates the number of possible photo arrangements for a group of people.\nIn this arrangement, people are lined up in such a way that the age difference\nbetween any two adjacent persons is no more than two years.\nThe function takes a single integer argument, n, representing the number of people\nin the group, where each person has a distinct age from 1 to n years.\n\nExample:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "es": "Calcula el número de posibles arreglos fotográficos para un grupo de personas. En este arreglo, las personas están alineadas de tal manera que la diferencia de edad entre cualquier dos personas adyacentes no es mayor de dos años. La función toma un único argumento entero, n, que representa el número de personas en el grupo, donde cada persona tiene una edad distinta de 1 a n años.\n\nEjemplo:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "arb": "يحسب عدد الترتيبات الممكنة للصور لمجموعة من الأشخاص.\nفي هذا الترتيب، يتم ترتيب الأشخاص بحيث لا يزيد فرق العمر\nبين أي شخصين متجاورين عن سنتين.\nتأخذ الدالة عددًا صحيحًا واحدًا، n، يمثل عدد الأشخاص\nفي المجموعة، حيث يكون لكل شخص عمر مميز من 1 إلى n سنة.\n\nمثال:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "sw": "Hesabu idadi ya mipangilio ya picha inayowezekana kwa kundi la watu.  \nKatika mpangilio huu, watu wamepangwa kwa njia ambayo tofauti ya umri  \nkati ya mtu yeyote aliye karibu ni miaka isiyozidi miwili.  \nKazi inachukua hoja moja ya nambari nzima, n, inayowakilisha idadi ya watu  \nkatika kundi, ambapo kila mtu ana umri tofauti kutoka mwaka 1 hadi n.\n\nMfano:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "tr": "Bir grup insan için olası fotoğraf düzenlemelerinin sayısını hesaplar.\nBu düzenlemede, insanlar öyle bir şekilde sıralanır ki, herhangi iki bitişik kişi arasındaki yaş farkı\niki yıldan fazla değildir.\nFonksiyon, gruptaki kişi sayısını temsil eden tek bir tamsayı argümanı alır, burada her kişinin yaşı 1'den n'ye kadar farklıdır.\n\nÖrnek:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "vi": "Tính toán số lượng sắp xếp ảnh có thể có cho một nhóm người. Trong sắp xếp này, mọi người được xếp hàng sao cho sự chênh lệch tuổi tác giữa bất kỳ hai người liền kề nào không quá hai năm. Hàm nhận một đối số nguyên duy nhất, n, đại diện cho số người trong nhóm, trong đó mỗi người có một độ tuổi khác biệt từ 1 đến n năm.\n\nVí dụ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6"
    },
    "docstring_bertscore": {
      "es": "0.9818747791001854",
      "arb": "0.9588648398699608",
      "sw": "0.9631594273383162",
      "tr": "0.9605873625342954",
      "vi": "0.9860253595422904"
    }
  },
  {
    "task_id": "Ruby/31",
    "prompt": {
      "en": "# Converts a numerical score into a corresponding letter grade based on predefined ranges.\n# The function takes a single argument, score, which is an integer representing the score.\n# It returns a string representing the letter grade, or an error message for invalid scores.\n#\n# Grade Conversion:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Any other score: 'Score is error!'\n#\n# Examples:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "es": "# Convierte una puntuación numérica en una calificación de letra correspondiente basada en rangos predefinidos.\n# La función toma un solo argumento, score, que es un entero que representa la puntuación.\n# Devuelve una cadena que representa la calificación con letra, o un mensaje de error para puntuaciones no válidas.\n#\n# Conversión de Calificaciones:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Cualquier otra puntuación: 'Score is error!'\n#\n# Ejemplos:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "arb": "# يحول درجة رقمية إلى درجة حرفية مقابلة بناءً على نطاقات محددة مسبقًا.\n# تأخذ الدالة وسيطًا واحدًا، score، وهو عدد صحيح يمثل الدرجة.\n# تعيد سلسلة نصية تمثل الدرجة الحرفية، أو رسالة خطأ للدرجات غير الصالحة.\n#\n# تحويل الدرجات:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# أي درجة أخرى: 'Score is error!'\n#\n# أمثلة:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "sw": "# Hubadilisha alama ya nambari kuwa daraja la herufi linalolingana kulingana na viwango vilivyowekwa awali.\n# Kazi inachukua hoja moja, score, ambayo ni nambari inayowakilisha alama.\n# Inarudisha kamba inayowakilisha daraja la herufi, au ujumbe wa kosa kwa alama zisizo sahihi.\n#\n# Ubadilishaji wa Daraja:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Alama nyingine yoyote: 'Score is error!'\n#\n# Mifano:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "tr": "# Sayısal bir puanı, önceden tanımlanmış aralıklara göre karşılık gelen bir harf notuna dönüştürür.\n# Fonksiyon, puanı temsil eden bir tamsayı olan tek bir argüman, score, alır.\n# Bir harf notunu temsil eden bir dize veya geçersiz puanlar için bir hata mesajı döndürür.\n#\n# Not Dönüşümü:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Diğer herhangi bir puan: 'Score is error!'\n#\n# Örnekler:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "vi": "# Chuyển đổi một điểm số thành một điểm chữ tương ứng dựa trên các khoảng giá trị đã định trước.\n# Hàm nhận một đối số duy nhất, score, là một số nguyên đại diện cho điểm số.\n# Nó trả về một chuỗi đại diện cho điểm chữ, hoặc một thông báo lỗi cho các điểm số không hợp lệ.\n#\n# Chuyển đổi Điểm:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Bất kỳ điểm nào khác: 'Score is error!'\n#\n# Ví dụ:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)"
    },
    "prompt_bertscore": {
      "es": "0.996897393448235",
      "arb": "0.9899201040536225",
      "sw": "0.979231207358992",
      "tr": "0.9892483361049625",
      "vi": "0.9878257453159907"
    },
    "canonical_solution": "    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end",
    "instruction": {
      "en": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9151651628903803",
      "tr": "0.8617262410678971",
      "vi": "0.906469522069435"
    },
    "level": "",
    "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'",
    "entry_point": "convert_score_to_grade",
    "signature": "def convert_score_to_grade(score)",
    "docstring": {
      "en": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\nExamples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "es": "Convierte una puntuación numérica en una calificación de letra correspondiente basada en rangos predefinidos.\nLa función toma un único argumento, score, que es un entero que representa la puntuación.\nDevuelve una cadena que representa la calificación de letra, o un mensaje de error para puntuaciones no válidas.\n\nConversión de Calificaciones:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nCualquier otra puntuación: '¡La puntuación es un error!'\n\nEjemplos:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'¡La puntuación es un error!'",
      "arb": "يحوّل درجة رقمية إلى درجة حرفية مقابلة بناءً على نطاقات محددة مسبقًا. \nتأخذ الدالة وسيطًا واحدًا، score، وهو عدد صحيح يمثل الدرجة. \nتُرجع سلسلة نصية تمثل الدرجة الحرفية، أو رسالة خطأ للدرجات غير الصالحة.\n\nتحويل الدرجات:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nأي درجة أخرى: 'Score is error!'\n\nأمثلة:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "sw": "Inabadilisha alama ya nambari kuwa daraja la herufi linalolingana kulingana na viwango vilivyowekwa awali.\nKazi inachukua hoja moja, score, ambayo ni nambari nzima inayowakilisha alama.\nInarudisha kamba inayowakilisha daraja la herufi, au ujumbe wa kosa kwa alama zisizo sahihi.\n\nUbadilishaji wa Daraja:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAlama nyingine yoyote: 'Score is error!'\n\nMifano:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "tr": "Sayısal bir puanı, önceden tanımlanmış aralıklara göre karşılık gelen bir harf notuna dönüştürür.\nFonksiyon, puanı temsil eden bir tamsayı olan tek bir argüman, score, alır.\nBir harf notunu temsil eden bir dize veya geçersiz puanlar için bir hata mesajı döndürür.\n\nNot Dönüşümü:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nDiğer puanlar: 'Score is error!'\n\nÖrnekler:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "vi": "Chuyển đổi một điểm số thành một điểm chữ tương ứng dựa trên các khoảng giá trị được xác định trước. Hàm này nhận một đối số duy nhất, score, là một số nguyên đại diện cho điểm số. Nó trả về một chuỗi đại diện cho điểm chữ, hoặc một thông báo lỗi cho các điểm không hợp lệ.\n\nChuyển đổi điểm:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nBất kỳ điểm nào khác: 'Score is error!'\n\nVí dụ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'"
    },
    "docstring_bertscore": {
      "es": "0.9890808906937502",
      "arb": "0.9934404302967038",
      "sw": "0.9908784956421158",
      "tr": "0.9833770206719523",
      "vi": "0.9815323403232813"
    }
  },
  {
    "task_id": "Ruby/32",
    "prompt": {
      "en": "# Calculates the minimum time required to reverse the order of M people standing in a circle.\n# In each minute, only a pair of adjacent people can swap places. The function returns the \n# minimum number of minutes required to reverse the order of the people, such that each person's \n# left neighbor becomes their right neighbor and vice versa.\n#\n# Args:\n# - m: A positive integer representing the number of people in the circle.\n#\n# Returns:\n# - An integer representing the minimum number of minutes required to achieve the reversed order.\n#\n# Examples:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "es": "# Calcula el tiempo mínimo requerido para invertir el orden de M personas paradas en un círculo.\n# En cada minuto, solo un par de personas adyacentes puede intercambiar lugares. La función devuelve el\n# número mínimo de minutos necesarios para invertir el orden de las personas, de modo que el vecino\n# izquierdo de cada persona se convierta en su vecino derecho y viceversa.\n#\n# Argumentos:\n# - m: Un entero positivo que representa el número de personas en el círculo.\n#\n# Devuelve:\n# - Un entero que representa el número mínimo de minutos necesarios para lograr el orden invertido.\n#\n# Ejemplos:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "arb": "# يحسب الحد الأدنى من الوقت المطلوب لعكس ترتيب M شخصًا يقفون في دائرة.\n# في كل دقيقة، يمكن فقط لزوج من الأشخاص المتجاورين تبديل الأماكن. تُرجع الدالة\n# الحد الأدنى لعدد الدقائق المطلوبة لعكس ترتيب الأشخاص، بحيث يصبح جار كل شخص\n# على اليسار هو جاره على اليمين والعكس صحيح.\n#\n# الوسائط:\n# - m: عدد صحيح موجب يمثل عدد الأشخاص في الدائرة.\n#\n# الإرجاع:\n# - عدد صحيح يمثل الحد الأدنى لعدد الدقائق المطلوبة لتحقيق الترتيب المعكوس.\n#\n# أمثلة:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "sw": "# Inakokotoa muda wa chini unaohitajika kubadilisha mpangilio wa watu M waliokuwa wamesimama katika mduara.\n# Kila dakika, ni jozi moja tu ya watu walio karibu wanaweza kubadilishana nafasi. Kazi inarudisha \n# idadi ya chini ya dakika zinazohitajika kubadilisha mpangilio wa watu, ili jirani wa kushoto wa kila mtu \n# awe jirani wa kulia na kinyume chake.\n#\n# Vipengele:\n# - m: Nambari kamili chanya inayowakilisha idadi ya watu katika mduara.\n#\n# Inarudisha:\n# - Nambari kamili inayowakilisha idadi ya chini ya dakika zinazohitajika kufanikisha mpangilio uliobadilishwa.\n#\n# Mifano:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "tr": "# Bir dairede duran M kişinin sırasını tersine çevirmek için gereken minimum zamanı hesaplar.\n# Her dakikada, yalnızca bitişik iki kişi yer değiştirebilir. Fonksiyon, insanların sırasını\n# tersine çevirmek için gereken minimum dakika sayısını döndürür, böylece her kişinin\n# sol komşusu sağ komşusu olur ve tersi de geçerlidir.\n#\n# Argümanlar:\n# - m: Dairedeki kişi sayısını temsil eden pozitif bir tam sayı.\n#\n# Döndürür:\n# - Ters sırayı elde etmek için gereken minimum dakika sayısını temsil eden bir tam sayı.\n#\n# Örnekler:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "vi": "# Tính thời gian tối thiểu cần thiết để đảo ngược thứ tự của M người đứng trong một vòng tròn.\n# Mỗi phút, chỉ một cặp người liền kề có thể đổi chỗ cho nhau. Hàm trả về số phút tối thiểu \n# cần thiết để đảo ngược thứ tự của những người đó, sao cho người bên trái của mỗi người trở thành \n# người bên phải của họ và ngược lại.\n#\n# Tham số:\n# - m: Một số nguyên dương đại diện cho số người trong vòng tròn.\n#\n# Trả về:\n# - Một số nguyên đại diện cho số phút tối thiểu cần thiết để đạt được thứ tự đảo ngược.\n#\n# Ví dụ:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)"
    },
    "prompt_bertscore": {
      "es": "0.9858902908831867",
      "arb": "0.9808913600836817",
      "sw": "0.9528894421172883",
      "tr": "0.9695102365111447",
      "vi": "0.9588602713711971"
    },
    "canonical_solution": "    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end",
    "instruction": {
      "en": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nAşağıdaki Ruby kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9063986110234055",
      "sw": "0.9428772791308437",
      "tr": "0.8515323312828056",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless min_time_to_reverse_order(4) == 2\nraise 'Test failed' unless min_time_to_reverse_order(5) == 4\nraise 'Test failed' unless min_time_to_reverse_order(6) == 6\nraise 'Test failed' unless min_time_to_reverse_order(7) == 9\nraise 'Test failed' unless min_time_to_reverse_order(10) == 20\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_time_to_reverse_order",
    "signature": "def min_time_to_reverse_order(m)",
    "docstring": {
      "en": "Calculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "es": "Calcula el tiempo mínimo necesario para invertir el orden de M personas paradas en un círculo. En cada minuto, solo un par de personas adyacentes puede intercambiar lugares. La función devuelve el número mínimo de minutos necesarios para invertir el orden de las personas, de modo que el vecino de la izquierda de cada persona se convierta en su vecino de la derecha y viceversa.\n\nArgumentos:\n- m: Un entero positivo que representa el número de personas en el círculo.\n\nDevuelve:\n- Un entero que representa el número mínimo de minutos necesarios para lograr el orden invertido.\n\nEjemplos:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "arb": "يحسب الحد الأدنى من الوقت المطلوب لعكس ترتيب M شخصًا يقفون في دائرة. في كل دقيقة، يمكن لزوج واحد فقط من الأشخاص المتجاورين تبديل الأماكن. تُرجع الدالة الحد الأدنى لعدد الدقائق المطلوبة لعكس ترتيب الأشخاص، بحيث يصبح الجار الأيسر لكل شخص هو الجار الأيمن والعكس صحيح.\n\nالمعطيات:\n- m: عدد صحيح موجب يمثل عدد الأشخاص في الدائرة.\n\nالقيم المعادة:\n- عدد صحيح يمثل الحد الأدنى لعدد الدقائق المطلوبة لتحقيق الترتيب المعكوس.\n\nأمثلة:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "sw": "Inakokotoa muda wa chini unaohitajika kubadilisha mpangilio wa watu M wanaosimama kwenye mduara. Katika kila dakika, ni jozi moja tu ya watu wa karibu wanaoweza kubadilishana nafasi. Kazi inarejesha idadi ya chini ya dakika zinazohitajika kubadilisha mpangilio wa watu, ili jirani wa kushoto wa kila mtu awe jirani wa kulia na kinyume chake.\n\nHoja:\n- m: Nambari chanya inayowakilisha idadi ya watu kwenye mduara.\n\nInarejesha:\n- Nambari kamili inayowakilisha idadi ya chini ya dakika zinazohitajika kufanikisha mpangilio uliobadilishwa.\n\nMifano:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "tr": "M kişinin bir çemberde durduğu sırayı tersine çevirmek için gereken minimum zamanı hesaplar. Her dakikada, yalnızca bitişik bir çift kişi yer değiştirebilir. Fonksiyon, her kişinin sol komşusunun sağ komşusu ve sağ komşusunun sol komşusu olacak şekilde, kişilerin sırasını tersine çevirmek için gereken minimum dakika sayısını döndürür.\n\nArgümanlar:\n- m: Çemberdeki kişi sayısını temsil eden pozitif bir tamsayı.\n\nDöndürür:\n- Ters sırayı elde etmek için gereken minimum dakika sayısını temsil eden bir tamsayı.\n\nÖrnekler:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "vi": "Tính toán thời gian tối thiểu cần thiết để đảo ngược thứ tự của M người đứng trong một vòng tròn. Trong mỗi phút, chỉ một cặp người liền kề có thể đổi chỗ cho nhau. Hàm trả về số phút tối thiểu cần thiết để đảo ngược thứ tự của những người này, sao cho hàng xóm bên trái của mỗi người trở thành hàng xóm bên phải của họ và ngược lại.\n\nTham số:\n- m: Một số nguyên dương đại diện cho số người trong vòng tròn.\n\nTrả về:\n- Một số nguyên đại diện cho số phút tối thiểu cần thiết để đạt được thứ tự đảo ngược.\n\nVí dụ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6"
    },
    "docstring_bertscore": {
      "es": "0.9897554394677446",
      "arb": "0.975991545844313",
      "sw": "0.962782426875112",
      "tr": "0.9656621701393557",
      "vi": "0.9801057769266887"
    }
  },
  {
    "task_id": "Ruby/33",
    "prompt": {
      "en": "# Generates all unique four-digit permutations using the given four digits.\n# Each digit is used exactly once in each permutation. The function accepts\n# four integers as arguments and returns an array of strings, each representing\n# a unique permutation. The permutations are sorted in ascending order.\n#\n# Example:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "es": "# Genera todas las permutaciones únicas de cuatro dígitos usando los cuatro dígitos dados.\n# Cada dígito se usa exactamente una vez en cada permutación. La función acepta\n# cuatro enteros como argumentos y devuelve un arreglo de cadenas, cada una representando\n# una permutación única. Las permutaciones están ordenadas en orden ascendente.\n#\n# Ejemplo:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "arb": "# يولد جميع التباديل الفريدة المكونة من أربعة أرقام باستخدام الأرقام الأربعة المعطاة.\n# يتم استخدام كل رقم مرة واحدة بالضبط في كل تبادل. تقبل الدالة\n# أربعة أعداد صحيحة كوسائط وتعيد مصفوفة من السلاسل، كل منها تمثل\n# تبادلًا فريدًا. يتم ترتيب التباديل بترتيب تصاعدي.\n#\n# مثال:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...] \n\ndef generate_four_digit_permutations(*digits)",
      "sw": "# Hutoa mchanganyiko wa kipekee wa tarakimu nne kwa kutumia tarakimu nne zilizotolewa.\n# Kila tarakimu inatumika mara moja tu katika kila mchanganyiko. Kazi inakubali\n# namba nne kama hoja na inarejesha safu ya mistari, kila moja ikiwakilisha\n# mchanganyiko wa kipekee. Mchanganyiko umewekwa katika mpangilio wa kupanda.\n#\n# Mfano:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "tr": "# Verilen dört rakamı kullanarak tüm benzersiz dört basamaklı permütasyonları oluşturur.\n# Her rakam her permütasyonda tam olarak bir kez kullanılır. Fonksiyon\n# dört tam sayı argüman olarak alır ve her biri benzersiz bir permütasyonu\n# temsil eden bir dizi string döndürür. Permütasyonlar artan sırayla sıralanır.\n#\n# Örnek:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "vi": "# Tạo tất cả các hoán vị bốn chữ số duy nhất sử dụng bốn chữ số đã cho.\n# Mỗi chữ số được sử dụng chính xác một lần trong mỗi hoán vị. Hàm chấp nhận\n# bốn số nguyên làm đối số và trả về một mảng chuỗi, mỗi chuỗi đại diện cho\n# một hoán vị duy nhất. Các hoán vị được sắp xếp theo thứ tự tăng dần.\n#\n# Ví dụ:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)"
    },
    "prompt_bertscore": {
      "es": "0.9970729827050698",
      "arb": "0.9850657761715109",
      "sw": "0.9541267107607546",
      "tr": "0.9904901732471927",
      "vi": "0.991021509516461"
    },
    "canonical_solution": "    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end",
    "instruction": {
      "en": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9151651628903803",
      "tr": "0.8544035334406649",
      "vi": "0.9196657300638688"
    },
    "level": "",
    "test": "raise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 4) == [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", \"2134\", \"2143\", \"2314\", \"2341\", \"2413\", \"2431\", \"3124\", \"3142\", \"3214\", \"3241\", \"3412\", \"3421\", \"4123\", \"4132\", \"4213\", \"4231\", \"4312\", \"4321\"]\n\nraise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 5) == [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", \"2135\", \"2153\", \"2315\", \"2351\", \"2513\", \"2531\", \"3125\", \"3152\", \"3215\", \"3251\", \"3512\", \"3521\", \"5123\", \"5132\", \"5213\", \"5231\", \"5312\", \"5321\"]\n   \n\n\nputs 'All tests passed!'",
    "entry_point": "generate_four_digit_permutations",
    "signature": "def generate_four_digit_permutations(*digits)",
    "docstring": {
      "en": "Generates all unique four-digit permutations using the given four digits.\nEach digit is used exactly once in each permutation. The function accepts\nfour integers as arguments and returns an array of strings, each representing\na unique permutation. The permutations are sorted in ascending order.\n\nExample:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "es": "Genera todas las permutaciones únicas de cuatro dígitos utilizando los cuatro dígitos dados. Cada dígito se usa exactamente una vez en cada permutación. La función acepta cuatro enteros como argumentos y devuelve un array de cadenas, cada una representando una permutación única. Las permutaciones están ordenadas en orden ascendente.\n\nEjemplo:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "arb": "ينشئ جميع التباديل الفريدة المكونة من أربعة أرقام باستخدام الأرقام الأربعة المعطاة. يتم استخدام كل رقم مرة واحدة بالضبط في كل تبديل. تقبل الدالة أربعة أعداد صحيحة كمدخلات وتعيد مصفوفة من السلاسل النصية، كل منها يمثل تبديلًا فريدًا. يتم ترتيب التباديل بترتيب تصاعدي.\n\nمثال:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "sw": "Hutengeneza mchanganyiko wa kipekee wa tarakimu nne kwa kutumia tarakimu nne zilizotolewa. Kila tarakimu inatumika mara moja tu katika kila mchanganyiko. Kazi inakubali namba nne za mzima kama hoja na inarudisha safu ya mistari, kila moja ikiwakilisha mchanganyiko wa kipekee. Mchanganyiko umewekwa katika mpangilio wa kupanda.\n\nMfano:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "tr": "Verilen dört basamağı kullanarak tüm benzersiz dört basamaklı permütasyonları oluşturur. Her basamak her permütasyonda tam olarak bir kez kullanılır. Fonksiyon, argüman olarak dört tamsayı alır ve her biri benzersiz bir permütasyonu temsil eden bir dizi string döndürür. Permütasyonlar artan sırayla sıralanır.\n\nÖrnek:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "vi": "Tạo tất cả các hoán vị bốn chữ số duy nhất sử dụng bốn chữ số đã cho. Mỗi chữ số được sử dụng chính xác một lần trong mỗi hoán vị. Hàm chấp nhận bốn số nguyên làm đối số và trả về một mảng các chuỗi, mỗi chuỗi đại diện cho một hoán vị duy nhất. Các hoán vị được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]"
    },
    "docstring_bertscore": {
      "es": "0.997933052254951",
      "arb": "0.9860207910435267",
      "sw": "0.9391170073874723",
      "tr": "0.9756649974978917",
      "vi": "0.9928473199789337"
    }
  },
  {
    "task_id": "Ruby/34",
    "prompt": {
      "en": "# Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\n# The function takes a single argument, n, which is a positive integer, and returns the count of numbers \n# that are related to 7 as per the criteria.\n#\n# Example:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "es": "# Cuenta la cantidad de números menores o iguales a n que son múltiplos de 7 o contienen el dígito '7'.\n# La función toma un solo argumento, n, que es un entero positivo, y devuelve la cuenta de números\n# que están relacionados con el 7 según los criterios.\n#\n# Ejemplo:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "arb": "# يحسب عدد الأرقام الأقل من أو تساوي n التي إما أن تكون مضاعفات للعدد 7 أو تحتوي على الرقم '7'.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد عدد الأرقام \n# المرتبطة بالرقم 7 وفقًا للمعايير.\n#\n# مثال:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "sw": "# Inahesabu idadi ya namba zilizo chini au sawa na n ambazo ni ama vizidisho vya 7 au zina namba '7'.\n# Kazi hii inapokea hoja moja, n, ambayo ni nambari chanya, na inarudisha idadi ya namba \n# zinazohusiana na 7 kulingana na vigezo vilivyotolewa.\n#\n# Mfano:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "tr": "# 7'nin katı olan veya '7' rakamını içeren, n'den küçük veya n'ye eşit sayıların sayısını sayar.\n# Fonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve belirtilen kriterlere göre\n# 7 ile ilgili sayıların sayısını döndürür.\n#\n# Örnek:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "vi": "# Đếm số lượng số nhỏ hơn hoặc bằng n mà là bội số của 7 hoặc chứa chữ số '7'.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về số lượng \n# số liên quan đến 7 theo tiêu chí đã cho.\n#\n# Ví dụ:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)"
    },
    "prompt_bertscore": {
      "es": "0.9936603141285095",
      "arb": "0.9656629646608799",
      "sw": "0.9653356217929344",
      "tr": "0.956998111548995",
      "vi": "0.9750869830890802"
    },
    "canonical_solution": "    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end",
    "instruction": {
      "en": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español usando un máximo de 500 caracteres.",
      "arb": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9151651628903803",
      "tr": "0.8568462898666319",
      "vi": "0.8841786248185567"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_seven_related_numbers(20) == 3\nraise 'Test failed' unless count_seven_related_numbers(15) == 2\nraise 'Test failed' unless count_seven_related_numbers(50) == 11\nraise 'Test failed' unless count_seven_related_numbers(28) == 6\nraise 'Test failed' unless count_seven_related_numbers(100) == 30\n  \n\nputs 'All tests passed!'",
    "entry_point": "count_seven_related_numbers",
    "signature": "def count_seven_related_numbers(n)",
    "docstring": {
      "en": "Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n\nExample:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "es": "Cuenta la cantidad de números menores o iguales a n que son múltiplos de 7 o contienen el dígito '7'.  \nLa función toma un solo argumento, n, que es un número entero positivo, y devuelve la cantidad de números  \nque están relacionados con 7 según los criterios.\n\nEjemplo:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "arb": "يحسب عدد الأرقام الأقل من أو تساوي n التي تكون إما مضاعفات للعدد 7 أو تحتوي على الرقم '7'. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب، وتعيد عدد الأرقام المرتبطة بالعدد 7 وفقًا للمعايير.\n\nمثال:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "sw": "Hesabu idadi ya nambari zilizo chini au sawa na n ambazo ni ama maradufu ya 7 au zina namba '7'. \nKazi hii inachukua hoja moja, n, ambayo ni nambari kamili chanya, na inarudisha hesabu ya nambari \nzinazohusiana na 7 kulingana na vigezo.\n\nMfano:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "tr": "7'nin katları olan veya '7' rakamını içeren, n'den küçük veya n'ye eşit sayıların sayısını sayar. \nFonksiyon, pozitif bir tamsayı olan n adlı tek bir argüman alır ve kriterlere göre 7 ile ilişkili sayıların sayısını döndürür.\n\nÖrnek:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "vi": "Đếm số lượng các số nhỏ hơn hoặc bằng n mà là bội số của 7 hoặc chứa chữ số '7'. Hàm nhận một đối số duy nhất, n, là một số nguyên dương, và trả về số lượng các số liên quan đến 7 theo tiêu chí.\n\nVí dụ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2"
    },
    "docstring_bertscore": {
      "es": "0.9807135858926554",
      "arb": "0.9555183152102851",
      "sw": "0.9725717265740353",
      "tr": "0.9504355623899833",
      "vi": "0.9748649143230832"
    }
  },
  {
    "task_id": "Ruby/35",
    "prompt": {
      "en": "# Finds all possible last two digits of a number that, when added to the number 'a',\n# makes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is \n# a positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\n# The function returns an array of strings representing the possible two-digit suffixes.\n#\n# Example:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "es": "# Encuentra todos los posibles últimos dos dígitos de un número que, al sumarse al número 'a',\n# lo hace divisible por 'b'. La función toma dos argumentos, 'a' y 'b', donde 'a' es \n# un entero positivo menor que 10000, y 'b' es un entero positivo entre 10 y 100.\n# La función devuelve un arreglo de cadenas que representan los posibles sufijos de dos dígitos.\n#\n# Ejemplo:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "arb": "# يجد جميع الأرقام الممكنة لآخر رقمين من عدد، والتي عند إضافتها إلى العدد 'a',\n# تجعلها قابلة للقسمة على 'b'. تأخذ الدالة وسيطين، 'a' و'b'، حيث أن 'a' هو عدد صحيح موجب\n# أقل من 10000، و'b' هو عدد صحيح موجب بين 10 و100.\n# تعيد الدالة مصفوفة من السلاسل النصية التي تمثل الأرقام الممكنة لآخر رقمين.\n#\n# مثال:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "sw": "# Inapata tarakimu mbili za mwisho zinazowezekana za nambari ambayo, ikiongezwa kwa nambari 'a',\n# inafanya iweze kugawanyika na 'b'. Kazi inachukua hoja mbili, 'a' na 'b', ambapo 'a' ni\n# nambari kamili chanya chini ya 10000, na 'b' ni nambari kamili chanya kati ya 10 na 100.\n# Kazi inarudisha safu ya mistari inayoonyesha viambishi vya tarakimu mbili vinavyowezekana.\n#\n# Mfano:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "tr": "# 'a' sayısına eklendiğinde 'b' ile bölünebilir hale getiren bir sayının\n# alabileceği tüm olası son iki basamağı bulur. Fonksiyon iki argüman alır, \n# 'a' ve 'b', burada 'a' 10000'den küçük pozitif bir tam sayı ve 'b' 10 ile 100 arasında \n# bir pozitif tam sayıdır. Fonksiyon, olası iki basamaklı eklerin temsil edildiği bir dizi döndürür.\n#\n# Örnek:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "vi": "# Tìm tất cả các chữ số cuối có thể có của một số mà khi cộng vào số 'a',\n# làm cho nó chia hết cho 'b'. Hàm nhận hai tham số, 'a' và 'b', trong đó 'a' là\n# một số nguyên dương nhỏ hơn 10000, và 'b' là một số nguyên dương từ 10 đến 100.\n# Hàm trả về một mảng các chuỗi đại diện cho các hậu tố hai chữ số có thể có.\n#\n# Ví dụ:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)"
    },
    "prompt_bertscore": {
      "es": "0.9940478420019085",
      "arb": "0.9679490017162105",
      "sw": "0.9920897437056666",
      "tr": "0.9690982771008783",
      "vi": "0.984661960606867"
    },
    "canonical_solution": "    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end",
    "instruction": {
      "en": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9151651628903803",
      "tr": "0.8527000792929097",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'",
    "entry_point": "find_possible_last_digits",
    "signature": "def find_possible_last_digits(a, b)",
    "docstring": {
      "en": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n\nExample:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "es": "Encuentra todos los posibles últimos dos dígitos de un número que, al sumarse al número 'a', lo hace divisible por 'b'. La función toma dos argumentos, 'a' y 'b', donde 'a' es un entero positivo menor que 10000, y 'b' es un entero positivo entre 10 y 100. La función devuelve un arreglo de cadenas que representan los posibles sufijos de dos dígitos.\n\nEjemplo:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "arb": "يجد جميع الأرقام المحتملة لآخر رقمين لعدد، والتي عند إضافتها إلى العدد 'a'، تجعله قابلاً للقسمة على 'b'. تأخذ الدالة وسيطين، 'a' و 'b'، حيث أن 'a' هو عدد صحيح موجب أقل من 10000، و 'b' هو عدد صحيح موجب بين 10 و 100. تُرجع الدالة مصفوفة من السلاسل النصية التي تمثل الأرقام المحتملة لآخر رقمين.\n\nمثال:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "sw": "Inapata tarakimu mbili za mwisho zinazowezekana za nambari ambayo, ikiongezwa kwa nambari 'a', inafanya igawanyike kwa 'b'. Kazi inachukua hoja mbili, 'a' na 'b', ambapo 'a' ni nambari kamili chanya chini ya 10000, na 'b' ni nambari kamili chanya kati ya 10 na 100. Kazi inarudisha safu ya mistari inayowakilisha viambishi vya tarakimu mbili vinavyowezekana.\n\nMfano:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "tr": "Bir sayıya eklendiğinde sayıyı 'b' ile bölünebilir yapan tüm olası son iki basamağı bulur. Fonksiyon, 'a' ve 'b' olmak üzere iki argüman alır; burada 'a', 10000'den küçük pozitif bir tam sayı ve 'b', 10 ile 100 arasında pozitif bir tam sayıdır. Fonksiyon, olası iki basamaklı ekleri temsil eden bir dizi döndürür.\n\nÖrnek:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "vi": "Tìm tất cả các chữ số cuối có thể có của một số mà khi cộng vào số 'a', làm cho nó chia hết cho 'b'. Hàm nhận hai đối số, 'a' và 'b', trong đó 'a' là một số nguyên dương nhỏ hơn 10000, và 'b' là một số nguyên dương nằm trong khoảng từ 10 đến 100. Hàm trả về một mảng các chuỗi đại diện cho các hậu tố hai chữ số có thể có.\n\nVí dụ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]"
    },
    "docstring_bertscore": {
      "es": "0.9935997318622938",
      "arb": "0.9649002239977059",
      "sw": "0.9934277179523177",
      "tr": "0.9565221931560354",
      "vi": "0.9860424417550594"
    }
  },
  {
    "task_id": "Ruby/36",
    "prompt": {
      "en": "# Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\n# The tiles used must be smaller than n x n and can be of varying sizes. \n# The function takes a single argument, n, which is a positive integer representing the size of the room, \n# and returns the minimum number of tiles required.\n#\n# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "es": "# Calcula el número mínimo de baldosas cuadradas necesarias para cubrir completamente una habitación cuadrada de tamaño n x n.\n# Las baldosas utilizadas deben ser más pequeñas que n x n y pueden ser de tamaños variados.\n# La función toma un solo argumento, n, que es un entero positivo que representa el tamaño de la habitación,\n# y devuelve el número mínimo de baldosas necesarias.\n#\n# Ejemplo:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "arb": "# يحسب الحد الأدنى لعدد البلاط المربع المطلوب لتغطية غرفة مربعة بحجم n x n بالكامل.\n# يجب أن تكون البلاط المستخدمة أصغر من n x n ويمكن أن تكون بأحجام مختلفة.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل حجم الغرفة،\n# وتعيد الحد الأدنى لعدد البلاط المطلوب.\n#\n# مثال:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "sw": "# Inahesabu idadi ndogo ya vigae vya mraba vinavyohitajika kufunika kabisa chumba cha mraba cha ukubwa wa n x n.\n# Vigae vinavyotumika lazima viwe vidogo kuliko n x n na vinaweza kuwa na ukubwa tofauti.\n# Kazi inachukua hoja moja, n, ambayo ni nambari chanya inayoashiria ukubwa wa chumba,\n# na inarudisha idadi ndogo ya vigae vinavyohitajika.\n#\n# Mfano:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "tr": "# n x n boyutundaki kare bir odayı tamamen kaplamak için gereken minimum kare karo sayısını hesaplar.\n# Kullanılan karolar n x n'den küçük olmalı ve farklı boyutlarda olabilir.\n# Fonksiyon, odanın boyutunu temsil eden pozitif bir tamsayı olan n adlı tek bir argüman alır\n# ve gereken minimum karo sayısını döndürür.\n#\n# Örnek:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "vi": "# Tính toán số lượng gạch vuông tối thiểu cần thiết để phủ kín hoàn toàn một phòng vuông có kích thước n x n.\n# Các viên gạch được sử dụng phải nhỏ hơn n x n và có thể có kích thước khác nhau.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho kích thước của phòng,\n# và trả về số lượng gạch tối thiểu cần thiết.\n#\n# Ví dụ:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)"
    },
    "prompt_bertscore": {
      "es": "0.9942021778079726",
      "arb": "0.9925320935642313",
      "sw": "0.9892948156141247",
      "tr": "0.9928499021738871",
      "vi": "0.9848524471422794"
    },
    "canonical_solution": "    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end",
    "instruction": {
      "en": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8857362842666323",
      "sw": "0.9428772791308437",
      "tr": "0.8527000792929097",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ",
    "entry_point": "min_tiles_required",
    "signature": "def min_tiles_required(n)",
    "docstring": {
      "en": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n\nExample:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "es": "Calcula el número mínimo de baldosas cuadradas necesarias para cubrir completamente una habitación cuadrada de tamaño n x n. Las baldosas utilizadas deben ser más pequeñas que n x n y pueden ser de tamaños variados. La función toma un solo argumento, n, que es un entero positivo que representa el tamaño de la habitación, y devuelve el número mínimo de baldosas necesarias.\n\nEjemplo:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "arb": "يحسب الحد الأدنى لعدد البلاط المربع المطلوب لتغطية غرفة مربعة بحجم n x n بالكامل. يجب أن يكون البلاط المستخدم أصغر من n x n ويمكن أن يكون بأحجام مختلفة. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل حجم الغرفة، وتعيد الحد الأدنى لعدد البلاط المطلوب.\n\nمثال:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "sw": "Hesabu idadi ndogo ya vigae vya mraba vinavyohitajika kufunika kabisa chumba cha mraba cha ukubwa n x n. Vigae vinavyotumika lazima viwe vidogo kuliko n x n na vinaweza kuwa na ukubwa tofauti. Kazi inachukua hoja moja, n, ambayo ni nambari kamili chanya inayowakilisha ukubwa wa chumba, na inarudisha idadi ndogo ya vigae vinavyohitajika.\n\nMfano:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "tr": "Kare şeklindeki bir odayı tamamen kaplamak için gereken minimum kare karo sayısını hesaplar. Kullanılan karolar n x n'den küçük olmalı ve farklı boyutlarda olabilir. Fonksiyon, odanın boyutunu temsil eden pozitif bir tamsayı olan n adlı tek bir argüman alır ve gereken minimum karo sayısını döndürür.\n\nÖrnek:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "vi": "Tính toán số lượng ô vuông tối thiểu cần thiết để phủ kín hoàn toàn một căn phòng hình vuông có kích thước n x n. Các ô vuông được sử dụng phải nhỏ hơn n x n và có thể có kích thước khác nhau. Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho kích thước của phòng, và trả về số lượng ô vuông tối thiểu cần thiết.\n\nVí dụ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8"
    },
    "docstring_bertscore": {
      "es": "0.9925096483311744",
      "arb": "0.9925261346528003",
      "sw": "0.9880501976465601",
      "tr": "0.9685097352818719",
      "vi": "0.9904568033431788"
    }
  },
  {
    "task_id": "Ruby/37",
    "prompt": {
      "en": "# Sorts a list of dates in the format 'MM/DD/YYYY'.\n# The function takes an array of string dates and returns an array of dates sorted in ascending order.\n# The sorting is done based on the chronological order of the dates.\n#\n# Examples:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "es": "# Ordena una lista de fechas en el formato 'MM/DD/YYYY'.\n# La función toma un arreglo de fechas en formato de cadena y devuelve un arreglo de fechas ordenadas en orden ascendente.\n# La ordenación se realiza en base al orden cronológico de las fechas.\n#\n# Ejemplos:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "arb": "# يقوم بترتيب قائمة من التواريخ بالصيغة 'MM/DD/YYYY'.\n# تأخذ الدالة مصفوفة من تواريخ السلسلة وتعيد مصفوفة من التواريخ مرتبة بترتيب تصاعدي.\n# يتم الترتيب بناءً على الترتيب الزمني للتواريخ.\n#\n# أمثلة:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "sw": "# Hupanga orodha ya tarehe katika muundo 'MM/DD/YYYY'.\n# Kazi inachukua safu ya tarehe za kamba na kurudisha safu ya tarehe zilizopangwa kwa mpangilio wa kupanda.\n# Upangaji unafanywa kulingana na mpangilio wa kinyume wa tarehe.\n#\n# Mifano:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "tr": "# Tarihleri 'MM/DD/YYYY' formatında sıralar.\n# Fonksiyon, bir dizi tarih stringi alır ve tarihleri artan sırayla sıralanmış bir dizi döndürür.\n# Sıralama, tarihlerin kronolojik sırasına göre yapılır.\n#\n# Örnekler:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "vi": "# Sắp xếp một danh sách các ngày theo định dạng 'MM/DD/YYYY'.\n# Hàm nhận một mảng các chuỗi ngày và trả về một mảng các ngày được sắp xếp theo thứ tự tăng dần.\n# Việc sắp xếp được thực hiện dựa trên thứ tự thời gian của các ngày.\n#\n# Ví dụ:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)"
    },
    "prompt_bertscore": {
      "es": "0.9936644853665112",
      "arb": "0.9951178638645435",
      "sw": "0.9800074548880764",
      "tr": "0.975028585757056",
      "vi": "0.9892681991430661"
    },
    "canonical_solution": "    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end",
    "instruction": {
      "en": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة روبي باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olmalıdır.",
      "vi": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9031176343894712",
      "sw": "0.9151651628903803",
      "tr": "0.8612674048877065",
      "vi": "0.9513240360843523"
    },
    "level": "",
    "test": "raise 'Test failed' unless sort_dates([\"10/21/2003\", \"15/12/1999\",  \"02/12/2004\"]) == [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\nraise 'Test failed' unless sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"]) == [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\nraise 'Test failed' unless sort_dates([\"01/01/2000\", \"12/31/1999\"]) == [\"12/31/1999\", \"01/01/2000\"]\n  \n\nputs 'All tests passed!'",
    "entry_point": "sort_dates",
    "signature": "def sort_dates(dates)",
    "docstring": {
      "en": "Sorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\nExamples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "es": "Ordena una lista de fechas en el formato 'MM/DD/YYYY'.  \nLa función toma un array de fechas en formato de cadena y devuelve un array de fechas ordenadas en orden ascendente.  \nLa ordenación se realiza en base al orden cronológico de las fechas.\n\nEjemplos:  \n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])  \n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]  \n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])  \n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "arb": "يقوم بترتيب قائمة من التواريخ بالتنسيق 'MM/DD/YYYY'. تأخذ الدالة مصفوفة من تواريخ السلسلة وتعيد مصفوفة من التواريخ مرتبة بترتيب تصاعدي. يتم الترتيب بناءً على الترتيب الزمني للتواريخ.\n\nأمثلة:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "sw": "Hupanga orodha ya tarehe katika muundo 'MM/DD/YYYY'.  \nKazi hii inachukua safu ya tarehe za kamba na kurudisha safu ya tarehe zilizopangwa kwa mpangilio wa kupanda.  \nUpangaji unafanywa kulingana na mpangilio wa tarehe kwa wakati.\n\nMifano:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "tr": "Tarihleri 'MM/DD/YYYY' formatında sıralar. \nFonksiyon, bir dizi string tarih alır ve tarihlerden oluşan bir diziyi artan sırada sıralanmış olarak döndürür. \nSıralama, tarihlerin kronolojik sırasına göre yapılır.\n\nÖrnekler:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "vi": "Sắp xếp một danh sách các ngày theo định dạng 'MM/DD/YYYY'.  \nHàm này nhận một mảng các ngày dưới dạng chuỗi và trả về một mảng các ngày được sắp xếp theo thứ tự tăng dần.  \nViệc sắp xếp được thực hiện dựa trên thứ tự thời gian của các ngày.\n\nVí dụ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]"
    },
    "docstring_bertscore": {
      "es": "0.9895492611322304",
      "arb": "0.9950088157853554",
      "sw": "0.9716171089627818",
      "tr": "0.9809622711297111",
      "vi": "0.9858430168525004"
    }
  },
  {
    "task_id": "Ruby/38",
    "prompt": {
      "en": "# Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\n# The function takes one argument, input_string, which is a string of letters and possibly digits.\n# Returns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n#\n# Examples:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "es": "# Encuentra la(s) letra(s) más grande(s) en la cadena de entrada (considerando 'A' y 'a' como la misma letra) e inserta \"(max)\" después de cada una de sus ocurrencias.\n# La función toma un argumento, input_string, que es una cadena de letras y posiblemente dígitos.\n# Devuelve una nueva cadena con \"(max)\" insertado después de cada ocurrencia de la(s) letra(s) más grande(s).\n#\n# Ejemplos:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "arb": "# يجد أكبر حرف (أو حروف) في سلسلة الإدخال (مع اعتبار 'A' و 'a' نفس الحرف) ويضيف \"(max)\" بعد كل ظهور له.\n# تأخذ الدالة وسيطًا واحدًا، input_string، وهو سلسلة من الحروف وربما الأرقام.\n# تُرجع سلسلة جديدة مع إضافة \"(max)\" بعد كل ظهور لأكبر حرف (أو حروف).\n#\n# أمثلة:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"",
      "sw": "# Inapata herufi kubwa zaidi katika mfuatano wa herufi uliotolewa (ikizingatia 'A' na 'a' kama herufi sawa) na inaingiza \"(max)\" baada ya kila tukio lake.\n# Kazi inachukua hoja moja, input_string, ambayo ni mfuatano wa herufi na labda tarakimu.\n# Inarudisha mfuatano mpya wa herufi na \"(max)\" imeingizwa baada ya kila tukio la herufi kubwa zaidi.\n#\n# Mifano:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "tr": "# Girdi dizesindeki en büyük harf(ler)i bulur ('A' ve 'a' aynı harf olarak kabul edilir) ve her birinin ardına \"(max)\" ekler.\n# Fonksiyon bir argüman alır, input_string, bu harflerden ve muhtemelen rakamlardan oluşan bir dizedir.\n# En büyük harf(ler)in her birinin ardına \"(max)\" eklenmiş yeni bir dize döndürür.\n#\n# Örnekler:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "vi": "# Tìm chữ cái lớn nhất trong chuỗi đầu vào (xem 'A' và 'a' là cùng một chữ cái) và chèn \"(max)\" sau mỗi lần xuất hiện của nó.\n# Hàm nhận một đối số, input_string, là một chuỗi các chữ cái và có thể có chữ số.\n# Trả về một chuỗi mới với \"(max)\" được chèn sau mỗi lần xuất hiện của chữ cái lớn nhất.\n#\n# Ví dụ:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)"
    },
    "prompt_bertscore": {
      "es": "0.9928524843688405",
      "arb": "0.9691822977520561",
      "sw": "0.9654629438671778",
      "tr": "0.956184322877895",
      "vi": "0.9559876788006705"
    },
    "canonical_solution": "    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end",
    "instruction": {
      "en": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8977611689041034",
      "sw": "0.9428772791308437",
      "tr": "0.8566170704069177",
      "vi": "0.9077628044803531"
    },
    "level": "",
    "test": "raise 'Test failed' unless insert_max_after_largest_letters(\"abcdefgfedcba\") == \"abcdefg(max)fedcba\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"xxxxx\") == \"x(max)x(max)x(max)x(max)x(max)\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Hello World!\") == \"Hello W(max)orld!\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Ruby123\") == \"Ruby(max)123\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"\") == \"\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"aAbBcC\") == \"aAbBc(max)C(max)\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "insert_max_after_largest_letters",
    "signature": "def insert_max_after_largest_letters(input_string)",
    "docstring": {
      "en": "Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n\nExamples:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "es": "Encuentra la(s) letra(s) más grande(s) en la cadena de entrada (considerando 'A' y 'a' como la misma letra) e inserta \"(max)\" después de cada una de sus ocurrencias.  \nLa función toma un argumento, input_string, que es una cadena de letras y posiblemente dígitos.  \nDevuelve una nueva cadena con \"(max)\" insertado después de cada ocurrencia de la(s) letra(s) más grande(s).\n\nEjemplos:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "arb": "يعثر على الحرف (الحروف) الأكبر في سلسلة الإدخال (مع اعتبار 'A' و 'a' كحرف واحد) ويضيف \"(max)\" بعد كل ظهور له.\n\nيعيدالحجج:\n    input_string: وهي سلسلة من الحروف وربما الأرقام.\n\nيعيد:\n    سلسلة جديدة مع إضافة \"(max)\" بعد كل ظهور للحرف (الحروف) الأكبر.\n\nأمثلة:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "sw": "Inapata herufi kubwa zaidi katika mfuatano wa herufi uliowekwa (ikizingatiwa 'A' na 'a' kama herufi sawa) na inaingiza \"(max)\" baada ya kila tukio lake.\nKazi hii inachukua hoja moja, input_string, ambayo ni mfuatano wa herufi na labda tarakimu.\nInarudisha mfuatano mpya wa herufi na \"(max)\" limeingizwa baada ya kila tukio la herufi kubwa zaidi.\n\nMifano:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "tr": "Girdi dizesindeki en büyük harf(ler)i bulur ('A' ve 'a' aynı harf olarak kabul edilir) ve her birinin ardından \"(max)\" ekler.\nFonksiyon, harflerden ve muhtemelen rakamlardan oluşan bir dize olan input_string adlı bir argüman alır.\nEn büyük harf(ler)in her birinin ardından \"(max)\" eklenmiş yeni bir dize döndürür.nÖrnekler:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "vi": "Tìm chữ cái lớn nhất trong chuỗi đầu vào (xem 'A' và 'a' như cùng một chữ cái) và chèn \"(max)\" sau mỗi lần xuất hiện của nó. \nHàm nhận một đối số, input_string, là một chuỗi các chữ cái và có thể có chữ số. \nTrả về một chuỗi mới với \"(max)\" được chèn sau mỗi lần xuất hiện của chữ cái lớn nhất.\n\nVí dụ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\""
    },
    "docstring_bertscore": {
      "es": "0.9942707052894297",
      "arb": "0.9258194978987107",
      "sw": "0.957704242553574",
      "tr": "0.9999996027392379",
      "vi": "0.951697262570317"
    }
  },
  {
    "task_id": "Ruby/39",
    "prompt": {
      "en": "# Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\n# such that no three consecutive pits contain nuclear materials, avoiding an explosion.\n# The function takes a single argument, n, which is a positive integer representing the number of pits,\n# and returns the total count of safe placement combinations for the given number of pits.\n#\n# Example:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "es": "# Calcula el número total de formas de colocar de manera segura materiales nucleares en N fosas dispuestas en línea\n# de tal manera que no haya tres fosas consecutivas que contengan materiales nucleares, evitando una explosión.\n# La función toma un solo argumento, n, que es un entero positivo que representa el número de fosas,\n# y devuelve el conteo total de combinaciones de colocación segura para el número dado de fosas.\n#\n# Ejemplo:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "arb": "# يحسب العدد الإجمالي للطرق لوضع المواد النووية بأمان في N حفر مرتبة في خط\n# بحيث لا تحتوي أي ثلاث حفر متتالية على مواد نووية، لتجنب الانفجار.\n# تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل عدد الحفر،\n# وتعيد العدد الإجمالي لتركيبات الوضع الآمن لعدد الحفر المعطى.\n#\n# مثال:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "sw": "# Inahesabu jumla ya njia za kuweka vifaa vya nyuklia kwa usalama katika mashimo N yaliyopangwa kwa mstari\n# kwa njia ambayo hakuna mashimo matatu mfululizo yenye vifaa vya nyuklia, kuepuka mlipuko.\n# Kazi inachukua hoja moja, n, ambayo ni nambari nzima chanya inayowakilisha idadi ya mashimo,\n# na inarudisha hesabu ya jumla ya mchanganyiko wa uwekaji salama kwa idadi iliyotolewa ya mashimo.\n#\n# Mfano:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "tr": "# Nükleer malzemeleri bir sıra halinde düzenlenmiş N çukura güvenli bir şekilde yerleştirmenin toplam yollarını hesaplar\n# öyle ki, ardışık üç çukurda nükleer malzeme bulunmaması, bir patlamayı önler.\n# Fonksiyon, çukurların sayısını temsil eden pozitif bir tam sayı olan n adlı tek bir argüman alır\n# ve verilen çukur sayısı için güvenli yerleştirme kombinasyonlarının toplam sayısını döndürür.\n#\n# Örnek:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "vi": "# Tính tổng số cách để đặt vật liệu hạt nhân an toàn trong N hố được sắp xếp thành một hàng\n# sao cho không có ba hố liên tiếp nào chứa vật liệu hạt nhân, tránh gây nổ.\n# Hàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho số lượng hố,\n# và trả về tổng số lượng các tổ hợp đặt an toàn cho số lượng hố đã cho.\n#\n# Ví dụ:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)"
    },
    "prompt_bertscore": {
      "es": "0.9894366377061836",
      "arb": "0.9859324005239661",
      "sw": "0.9868317988892921",
      "tr": "0.9706342858374211",
      "vi": "0.9852244818459578"
    },
    "canonical_solution": "    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end",
    "instruction": {
      "en": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.872657069566628",
      "sw": "0.9428772791308437",
      "tr": "0.8708167590863398",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_safe_placements(1) == 2\nraise 'Test failed' unless count_safe_placements(4) == 13\nraise 'Test failed' unless count_safe_placements(10) == 504\nraise 'Test failed' unless count_safe_placements(3) == 7\nraise 'Test failed' unless count_safe_placements(2) == 4\n    \n\nputs 'All tests passed!'",
    "entry_point": "count_safe_placements",
    "signature": "def count_safe_placements(n)",
    "docstring": {
      "en": "Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\nsuch that no three consecutive pits contain nuclear materials, avoiding an explosion.\nThe function takes a single argument, n, which is a positive integer representing the number of pits,\nand returns the total count of safe placement combinations for the given number of pits.\n\nExample:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "es": "Calcula el número total de formas de colocar materiales nucleares de manera segura en N pozos dispuestos en una línea\nde tal manera que no haya tres pozos consecutivos que contengan materiales nucleares, evitando una explosión.\nLa función toma un solo argumento, n, que es un entero positivo que representa el número de pozos,\ny devuelve el conteo total de combinaciones de colocación segura para el número dado de pozos.\n\nEjemplo:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "arb": "يحسب العدد الإجمالي للطرق لوضع المواد النووية بأمان في N حفر مرتبة في خط بحيث لا تحتوي ثلاث حفر متتالية على مواد نووية، لتجنب الانفجار. تأخذ الدالة وسيطًا واحدًا، n، وهو عدد صحيح موجب يمثل عدد الحفر، وتعيد العدد الإجمالي لتركيبات الوضع الآمن لعدد الحفر المعطى.\n\nمثال:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "sw": "Hesabu jumla ya njia za kuweka vifaa vya nyuklia kwa usalama katika mashimo N yaliyopangwa kwa mstari\nili kwamba hakuna mashimo matatu mfululizo yanayokuwa na vifaa vya nyuklia, kuepuka mlipuko.\nKazi inachukua hoja moja, n, ambayo ni nambari nzima chanya inayowakilisha idadi ya mashimo,\nna inarejesha jumla ya hesabu ya mchanganyiko wa uwekaji salama kwa idadi iliyotolewa ya mashimo.\n\nMfano:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "tr": "Nükleer malzemeleri bir hat üzerinde düzenlenmiş N çukura güvenli bir şekilde yerleştirmenin toplam yollarını hesaplar, böylece ardışık üç çukurda nükleer malzeme bulunmaz ve bir patlamadan kaçınılır. \nFonksiyon, çukurların sayısını temsil eden pozitif bir tamsayı olan n adlı tek bir argüman alır ve verilen çukur sayısı için güvenli yerleştirme kombinasyonlarının toplam sayısını döndürür.\n\nÖrnek:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "vi": "Tính tổng số cách để đặt vật liệu hạt nhân an toàn trong N hố được sắp xếp theo một hàng\nsao cho không có ba hố liên tiếp nào chứa vật liệu hạt nhân, tránh một vụ nổ.\nHàm nhận một đối số duy nhất, n, là một số nguyên dương đại diện cho số lượng hố,\nvà trả về tổng số lượng tổ hợp đặt an toàn cho số hố đã cho.\n\nVí dụ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504"
    },
    "docstring_bertscore": {
      "es": "0.9717559515991251",
      "arb": "0.9846548099131497",
      "sw": "0.9576094958618204",
      "tr": "0.9641313257927199",
      "vi": "0.9868250454563369"
    }
  },
  {
    "task_id": "Ruby/40",
    "prompt": {
      "en": "# Calculates the time needed to hang a saline solution.\n#\n# The function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\n# and d, which is the volume of each drop in milliliters. The function assumes that each drop takes \n# one second to fall and there is a one-second pause after a certain number of drops, which increases \n# sequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\n# The function returns the total time in seconds required to hang the entire volume of saline solution.\n#\n# Examples:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "es": "# Calcula el tiempo necesario para colgar una solución salina.\n#\n# La función toma dos argumentos: vul, que es el volumen total de la solución salina en mililitros,\n# y d, que es el volumen de cada gota en mililitros. La función asume que cada gota tarda \n# un segundo en caer y hay una pausa de un segundo después de un cierto número de gotas, que aumenta \n# secuencialmente (1 gota, luego una pausa, 2 gotas, luego una pausa, y así sucesivamente).\n# La función devuelve el tiempo total en segundos requerido para colgar todo el volumen de la solución salina.\n#\n# Ejemplos:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "arb": "# يحسب الوقت اللازم لتعليق محلول ملحي.\n#\n# تأخذ الدالة وسيطين: vul، وهو الحجم الكلي للمحلول الملحي بالملليلتر،\n# و d، وهو حجم كل قطرة بالملليلتر. تفترض الدالة أن كل قطرة تستغرق \n# ثانية واحدة للسقوط وهناك توقف لمدة ثانية واحدة بعد عدد معين من القطرات، \n# والذي يزداد بشكل متتابع (قطرة واحدة، ثم توقف، قطرتان، ثم توقف، وهكذا).\n# تعيد الدالة الوقت الكلي بالثواني المطلوب لتعليق الحجم الكلي للمحلول الملحي.\n#\n# أمثلة:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "sw": "# Inakokotoa muda unaohitajika kunyanyua suluhisho la chumvi.\n#\n# Kazi inachukua hoja mbili: vul, ambayo ni jumla ya ujazo wa suluhisho la chumvi kwa mililita,\n# na d, ambayo ni ujazo wa kila tone kwa mililita. Kazi inadhani kwamba kila tone linachukua \n# sekunde moja kuanguka na kuna pause ya sekunde moja baada ya idadi fulani ya matone, ambayo inaongezeka \n# kwa mfuatano (tone 1, kisha pause, matone 2, kisha pause, na kadhalika).\n# Kazi inarudisha muda wote kwa sekunde unaohitajika kunyanyua ujazo wote wa suluhisho la chumvi.\n#\n# Mifano:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\ndef calculate_hanging_time(vul, d)",
      "tr": "# Bir serum çözeltisinin asılması için gereken zamanı hesaplar.\n#\n# Fonksiyon iki argüman alır: vul, mililitre cinsinden serum çözeltisinin toplam hacmi,\n# ve d, her damlanın mililitre cinsinden hacmi. Fonksiyon, her damlanın düşmesinin bir saniye sürdüğünü\n# ve belirli bir damla sayısından sonra bir saniyelik bir duraklama olduğunu varsayar, bu sayı sırasıyla artar\n# (1 damla, sonra bir duraklama, 2 damla, sonra bir duraklama, vb.).\n# Fonksiyon, serum çözeltisinin tüm hacminin asılması için gereken toplam süreyi saniye cinsinden döndürür.\n#\n# Örnekler:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "vi": "# Tính thời gian cần thiết để treo một dung dịch muối.\n#\n# Hàm nhận hai đối số: vul, là tổng thể tích của dung dịch muối tính bằng mililit,\n# và d, là thể tích của mỗi giọt tính bằng mililit. Hàm giả định rằng mỗi giọt mất \n# một giây để rơi và có một khoảng dừng một giây sau một số giọt nhất định, số giọt này tăng \n# tuần tự (1 giọt, sau đó dừng, 2 giọt, sau đó dừng, và cứ tiếp tục như vậy).\n# Hàm trả về tổng thời gian tính bằng giây cần thiết để treo toàn bộ thể tích của dung dịch muối.\n#\n# Ví dụ:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)"
    },
    "prompt_bertscore": {
      "es": "0.9971379348396683",
      "arb": "0.9863304558075601",
      "sw": "0.9863306544379411",
      "tr": "0.9572529543278627",
      "vi": "0.9908403586089571"
    },
    "canonical_solution": "    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end",
    "instruction": {
      "en": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nAşağıdaki Ruby kodunun işlevini Türkçe olarak en fazla 500 karakterle açıklayan kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8789033991590322",
      "sw": "0.9151651628903803",
      "tr": "0.8712142184787905",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless calculate_hanging_time(10, 1) == 13\nraise 'Test failed' unless calculate_hanging_time(20, 2) == 13\nraise 'Test failed' unless calculate_hanging_time(15, 3) == 7\nraise 'Test failed' unless calculate_hanging_time(50, 5) == 13\nraise 'Test failed' unless calculate_hanging_time(100, 10) == 13\n\n  \nputs 'All tests passed!'",
    "entry_point": "calculate_hanging_time",
    "signature": "def calculate_hanging_time(vul, d)",
    "docstring": {
      "en": "Calculates the time needed to hang a saline solution.\n\nThe function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\nand d, which is the volume of each drop in milliliters. The function assumes that each drop takes\none second to fall and there is a one-second pause after a certain number of drops, which increases\nsequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\nThe function returns the total time in seconds required to hang the entire volume of saline solution.\n\nExamples:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "es": "Calcula el tiempo necesario para colgar una solución salina.\n\nLa función toma dos argumentos: vul, que es el volumen total de la solución salina en mililitros, y d, que es el volumen de cada gota en mililitros. La función asume que cada gota tarda un segundo en caer y hay una pausa de un segundo después de un cierto número de gotas, que aumenta secuencialmente (1 gota, luego una pausa, 2 gotas, luego una pausa, y así sucesivamente). La función devuelve el tiempo total en segundos necesario para colgar todo el volumen de la solución salina.\n\nEjemplos:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "arb": "يحسب الوقت اللازم لتعليق محلول ملحي.\n\nتأخذ الدالة وسيطين: vul، وهو الحجم الكلي للمحلول الملحي بالمليلتر، و d، وهو حجم كل قطرة بالمليلتر. تفترض الدالة أن كل قطرة تستغرق ثانية واحدة للسقوط وهناك توقف لمدة ثانية واحدة بعد عدد معين من القطرات، والذي يزداد بشكل متسلسل (قطرة واحدة، ثم توقف، قطرتان، ثم توقف، وهكذا). تعيد الدالة الوقت الكلي بالثواني المطلوب لتعليق الحجم الكامل للمحلول الملحي.\n\nأمثلة:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "sw": "Inakokotoa muda unaohitajika kunyanyua suluhisho la chumvi.\n\nKazi inachukua hoja mbili: vul, ambayo ni kiasi cha jumla cha suluhisho la chumvi kwa mililita,\nna d, ambayo ni kiasi cha kila tone kwa mililita. Kazi inadhani kwamba kila tone linachukua\nsekunde moja kuanguka na kuna mapumziko ya sekunde moja baada ya idadi fulani ya matone, ambayo huongezeka\nmfululizo (tone 1, kisha mapumziko, matone 2, kisha mapumziko, na kadhalika).\nKazi inarudisha muda wa jumla kwa sekunde unaohitajika kunyanyua kiasi chote cha suluhisho la chumvi.\n\nMifano:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "tr": "Salin solüsyonunu asmak için gereken zamanı hesaplar.\n\nFonksiyon iki argüman alır: vul, mililitre cinsinden toplam salin solüsyonu hacmi ve d, her damlanın mililitre cinsinden hacmi. Fonksiyon, her damlanın düşmesinin bir saniye sürdüğünü ve belirli bir damla sayısından sonra bir saniyelik bir duraklama olduğunu varsayar, bu sayı sırasıyla artar (1 damla, sonra duraklama, 2 damla, sonra duraklama, vb.).\nFonksiyon, tüm salin solüsyonu hacmini asmak için gereken toplam zamanı saniye cinsinden döndürür.\n\nÖrnekler:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "vi": "Tính toán thời gian cần thiết để treo một dung dịch muối sinh lý.\n\nHàm này nhận hai tham số: vul, là tổng thể tích của dung dịch muối sinh lý tính bằng mililit,\nvà d, là thể tích của mỗi giọt tính bằng mililit. Hàm giả định rằng mỗi giọt mất\nmột giây để rơi và có một khoảng dừng một giây sau một số giọt nhất định, số giọt này tăng dần\n(1 giọt, sau đó dừng, 2 giọt, sau đó dừng, và cứ tiếp tục như vậy).\nHàm trả về tổng thời gian tính bằng giây cần thiết để treo toàn bộ thể tích dung dịch muối sinh lý.\n\nVí dụ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13"
    },
    "docstring_bertscore": {
      "es": "0.9945998358308045",
      "arb": "0.989421541797225",
      "sw": "0.9855264000251308",
      "tr": "0.9654581767380329",
      "vi": "0.9696711271197829"
    }
  },
  {
    "task_id": "Ruby/41",
    "prompt": {
      "en": "# Counts the number of pairs of students who are considered \"equally matched opponents\".\n# Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n# is no more than 5 points, and the total score difference is no more than 10 points.\n# The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n# and returns the total count of \"equally matched\" student pairs.\n#\n# Example:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "es": "# Cuenta el número de pares de estudiantes que se consideran \"oponentes igualmente emparejados\".\n# Dos estudiantes están \"igualmente emparejados\" si la diferencia en las puntuaciones de cada materia (Chino, Matemáticas, Inglés)\n# no es de más de 5 puntos, y la diferencia total de puntuación no es de más de 10 puntos.\n# La función toma un arreglo de arreglos, donde cada sub-arreglo representa las puntuaciones de un estudiante en las tres materias,\n# y devuelve el conteo total de pares de estudiantes \"igualmente emparejados\".\n#\n# Ejemplo:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "arb": "# يحسب عدد الأزواج من الطلاب الذين يعتبرون \"خصوماً متكافئين\".\n# يعتبر الطالبان \"متكافئين\" إذا كان الفرق في الدرجات لكل مادة (الصينية، الرياضيات، الإنجليزية)\n# لا يزيد عن 5 نقاط، وكان الفرق في المجموع الكلي للدرجات لا يزيد عن 10 نقاط.\n# تأخذ الدالة مصفوفة من المصفوفات، حيث تمثل كل مصفوفة فرعية درجات طالب في المواد الثلاث،\n# وتعيد العدد الإجمالي لأزواج الطلاب \"المتكافئين\".\n#\n# مثال:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "sw": "# Inahesabu idadi ya jozi za wanafunzi ambao wanachukuliwa kuwa \"wapinzani waliolingana sawa\".\n# Wanafunzi wawili wanachukuliwa kuwa \"wamefanana sawa\" ikiwa tofauti ya alama kwa kila somo (Kichina, Hisabati, Kiingereza)\n# si zaidi ya alama 5, na tofauti ya jumla ya alama si zaidi ya alama 10.\n# Kazi inachukua safu ya safu, ambapo kila safu-ndogo inawakilisha alama za mwanafunzi katika masomo matatu,\n# na inarudisha jumla ya idadi ya jozi za wanafunzi \"waliolingana sawa\".\n#\n# Mfano:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "tr": "# \"Eşit derecede eşleşmiş rakipler\" olarak kabul edilen öğrenci çiftlerinin sayısını sayar.\n# İki öğrenci \"eşit derecede eşleşmiş\" olarak kabul edilir, eğer her bir ders (Çince, Matematik, İngilizce) için puan farkı \n# 5 puandan fazla değilse ve toplam puan farkı 10 puandan fazla değilse.\n# Fonksiyon, her bir alt dizinin üç dersteki bir öğrencinin puanlarını temsil ettiği bir dizi dizisi alır\n# ve \"eşit derecede eşleşmiş\" öğrenci çiftlerinin toplam sayısını döndürür.\n#\n# Örnek:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "vi": "# Đếm số cặp học sinh được coi là \"đối thủ ngang tài ngang sức\".\n# Hai học sinh được coi là \"ngang tài ngang sức\" nếu chênh lệch điểm số cho mỗi môn học (Ngữ văn, Toán, Tiếng Anh)\n# không quá 5 điểm, và chênh lệch tổng điểm không quá 10 điểm.\n# Hàm nhận vào một mảng các mảng, trong đó mỗi mảng con đại diện cho điểm số của một học sinh trong ba môn học,\n# và trả về tổng số cặp học sinh \"ngang tài ngang sức\".\n#\n# Ví dụ:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)"
    },
    "prompt_bertscore": {
      "es": "0.9938744376792651",
      "arb": "0.9601495811744946",
      "sw": "0.9738882487395346",
      "tr": "0.9618321791322411",
      "vi": "0.9618800490540704"
    },
    "canonical_solution": "  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend",
    "instruction": {
      "en": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8786288919724419",
      "sw": "0.9428772791308437",
      "tr": "0.8553954935635532",
      "vi": "0.9513240360843523"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100], [100, 100, 105], [90, 90, 90]]) == 1\nraise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 80, 85], [80, 85, 80], [76, 81, 85]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100]]) == 0\nraise 'Test failed' unless count_matching_pairs([]) == 0",
    "entry_point": "count_matching_pairs",
    "signature": "def count_matching_pairs(students_scores)",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n\n Example:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "es": "Cuenta el número de pares de estudiantes que se consideran \"oponentes igualmente emparejados\".\n Dos estudiantes están \"igualmente emparejados\" si la diferencia en las puntuaciones de cada materia (Chino, Matemáticas, Inglés)\n no es de más de 5 puntos, y la diferencia total de puntuación no es de más de 10 puntos.\n La función toma un arreglo de arreglos, donde cada sub-arreglo representa las puntuaciones de un estudiante en las tres materias,\n y devuelve el conteo total de pares de estudiantes \"igualmente emparejados\".\n\n Ejemplo:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "arb": "يحسب عدد الأزواج من الطلاب الذين يُعتبرون \"خصوماً متكافئين\".\n يعتبر الطالبان \"متكافئين\" إذا كان الفرق في الدرجات لكل مادة (الصينية، الرياضيات، الإنجليزية)\n لا يزيد عن 5 نقاط، وكان الفرق في مجموع الدرجات لا يزيد عن 10 نقاط.\n تأخذ الدالة مصفوفة من المصفوفات، حيث تمثل كل مصفوفة فرعية درجات طالب في المواد الثلاث،\n وتعيد العدد الإجمالي لأزواج الطلاب \"المتكافئين\".\n\n مثال:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "sw": "Hesabu idadi ya wanandoa wa wanafunzi ambao wanachukuliwa kuwa \"wapinzani waliolingana sawa\".\n Wanafunzi wawili ni \"waliolingana sawa\" ikiwa tofauti ya alama kwa kila somo (Kichina, Hisabati, Kiingereza)\n haizidi pointi 5, na tofauti ya jumla ya alama haizidi pointi 10.\n Kazi inachukua safu ya safu, ambapo kila safu ndogo inawakilisha alama za mwanafunzi katika masomo matatu,\n na inarudisha jumla ya idadi ya wanandoa wa wanafunzi \"waliolingana sawa\".\n\n Mfano:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "tr": "Öğrencilerin \"eşit derecede eşleşmiş rakipler\" olarak kabul edilen çiftlerinin sayısını sayar.\n İki öğrenci, her bir konu (Çince, Matematik, İngilizce) için puan farkı en fazla 5 puan olduğunda ve toplam puan farkı en fazla 10 puan olduğunda \"eşit derecede eşleşmiş\" kabul edilir.\n Fonksiyon, her alt dizinin üç dersteki bir öğrencinin puanlarını temsil ettiği bir dizi diziyi alır ve \"eşit derecede eşleşmiş\" öğrenci çiftlerinin toplam sayısını döndürür.\n\n Örnek:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "vi": "Đếm số cặp học sinh được coi là \"đối thủ cân sức\". \nHai học sinh được coi là \"cân sức\" nếu sự khác biệt điểm số cho mỗi môn học (Ngữ văn, Toán, Tiếng Anh) \nkhông quá 5 điểm, và sự khác biệt tổng điểm không quá 10 điểm. \nHàm nhận một mảng các mảng, trong đó mỗi mảng con đại diện cho điểm số của một học sinh trong ba môn học,\nvà trả về tổng số cặp học sinh \"cân sức\".\n\nVí dụ:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2"
    },
    "docstring_bertscore": {
      "es": "0.9951168707126383",
      "arb": "0.967633576671127",
      "sw": "0.9703252169645308",
      "tr": "0.9603150402818966",
      "vi": "0.9376296630942831"
    }
  },
  {
    "task_id": "Ruby/42",
    "prompt": {
      "en": "# Calculates the total number of cigarettes Peter can smoke given an initial\n# amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n# Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n#\n# The function takes two arguments, n and k, where n is the initial number of\n# cigarettes and k is the number of butts required for a new cigarette. It\n# returns the total number of cigarettes Peter can smoke.\n#\n# Examples:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "es": "# Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial\n# de cigarrillos y una tasa de conversión de colillas de cigarrillo a nuevos cigarrillos.\n# Peter comienza con n cigarrillos y puede convertir cada k colillas en un nuevo cigarrillo.\n#\n# La función toma dos argumentos, n y k, donde n es el número inicial de\n# cigarrillos y k es el número de colillas requeridas para un nuevo cigarrillo. \n# Devuelve el número total de cigarrillos que Peter puede fumar.\n#\n# Ejemplos:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "arb": "# يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى كمية\n# السجائر الأولية ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n# يبدأ بيتر بـ n سجائر ويمكنه تحويل كل k من الأعقاب إلى سيجارة جديدة.\n#\n# تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر و k هو عدد\n# الأعقاب المطلوبة لسيجارة جديدة. تعيد الدالة العدد الإجمالي للسجائر\n# التي يمكن أن يدخنها بيتر.\n#\n# أمثلة:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "sw": "# Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali\n# ya sigara na kiwango cha ubadilishaji wa vishina vya sigara kuwa sigara mpya.\n# Peter anaanza na sigara n na anaweza kubadilisha kila vishina k kuwa sigara mpya.\n#\n# Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya\n# sigara na k ni idadi ya vishina vinavyohitajika kwa sigara mpya. Inarudisha\n# jumla ya sigara ambazo Peter anaweza kuvuta.\n#\n# Mifano:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "tr": "# Peter'ın başlangıçtaki sigara miktarı ve izmaritlerin yeni sigaralara dönüşüm oranı\n# verildiğinde toplam kaç sigara içebileceğini hesaplar.\n# Peter n sigara ile başlar ve her k izmariti yeni bir sigaraya dönüştürebilir.\n#\n# Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır\n# ve k yeni bir sigara için gereken izmarit sayısıdır. Bu,\n# Peter'ın toplamda içebileceği sigara sayısını döndürür.\n#\n# Örnekler:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "vi": "# Tính tổng số điếu thuốc mà Peter có thể hút được với một số lượng\n# thuốc ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá thành điếu thuốc mới.\n# Peter bắt đầu với n điếu thuốc và có thể biến mỗi k đầu lọc thành một điếu thuốc mới.\n#\n# Hàm nhận hai tham số, n và k, trong đó n là số lượng điếu thuốc ban đầu\n# và k là số đầu lọc cần thiết để tạo ra một điếu thuốc mới. Hàm trả về\n# tổng số điếu thuốc mà Peter có thể hút được.\n#\n# Ví dụ:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)"
    },
    "prompt_bertscore": {
      "es": "0.986637737007021",
      "arb": "0.9779998976269568",
      "sw": "0.9765576424302626",
      "tr": "0.9809243327269335",
      "vi": "0.9710168479512943"
    },
    "canonical_solution": "    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end",
    "instruction": {
      "en": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة المكتوبة بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nRuby kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9428772791308437",
      "tr": "0.8638982642845136",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless total_smoked_cigarettes(4, 3) == 5\nraise 'Test failed' unless total_smoked_cigarettes(10, 3) == 14\nraise 'Test failed' unless total_smoked_cigarettes(20, 4) == 26\nraise 'Test failed' unless total_smoked_cigarettes(1, 2) == 1\nraise 'Test failed' unless total_smoked_cigarettes(100, 5) == 124\n  ",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial\n amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n\n The function takes two arguments, n and k, where n is the initial number of\n cigarettes and k is the number of butts required for a new cigarette. It\n returns the total number of cigarettes Peter can smoke.\n\n Examples:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar dado un monto inicial de cigarrillos y una tasa de conversión de colillas de cigarrillo a nuevos cigarrillos. Peter comienza con n cigarrillos y puede convertir cada k colillas en un nuevo cigarrillo.\n\nLa función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos y k es el número de colillas requeridas para un nuevo cigarrillo. Devuelve el número total de cigarrillos que Peter puede fumar.\n\nEjemplos:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى كمية أولية من السجائر ومعدل تحويل أعقاب السجائر إلى سجائر جديدة. يبدأ بيتر بـ n سيجارة ويمكنه تحويل كل k من الأعقاب إلى سيجارة جديدة.\n\nتأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر و k هو عدد الأعقاب المطلوبة للحصول على سيجارة جديدة. تُرجع الدالة العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n\nأمثلة:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "sw": "Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali ya sigara na kiwango cha ubadilishaji wa vishina vya sigara kuwa sigara mpya. Peter anaanza na sigara n na anaweza kubadilisha kila vishina k kuwa sigara mpya.\n\nKazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara na k ni idadi ya vishina vinavyohitajika kwa sigara mpya. Inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\n\nMifano:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "tr": "Peter'ın başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde, toplam kaç sigara içebileceğini hesaplar. Peter, n sigara ile başlar ve her k izmariti yeni bir sigaraya dönüştürebilir.\n\nFonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır ve k yeni bir sigara için gereken izmarit sayısıdır. Peter'ın içebileceği toplam sigara sayısını döndürür.\n\nÖrnekler:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng thuốc lá ban đầu và tỷ lệ chuyển đổi từ đầu lọc thuốc lá thành thuốc lá mới. Peter bắt đầu với n điếu thuốc và có thể biến mỗi k đầu lọc thành một điếu thuốc mới.\n\nHàm này nhận hai đối số, n và k, trong đó n là số lượng thuốc lá ban đầu và k là số đầu lọc cần thiết cho một điếu thuốc mới. Nó trả về tổng số điếu thuốc mà Peter có thể hút.\n\nVí dụ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14"
    },
    "docstring_bertscore": {
      "es": "0.9900096863554693",
      "arb": "0.9806299625022398",
      "sw": "0.9790828304643591",
      "tr": "0.9503193636170779",
      "vi": "0.9492882733091258"
    }
  },
  {
    "task_id": "Ruby/43",
    "prompt": {
      "en": "# Finds the length of the longest consecutive sequence in an array of integers.\n# The function takes an array of integers as an argument and returns the length\n# of the longest consecutive sequence of numbers present in the array.\n#\n# Example:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Because the longest consecutive sequence is 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "es": "# Encuentra la longitud de la secuencia consecutiva más larga en un arreglo de enteros.\n# La función toma un arreglo de enteros como argumento y devuelve la longitud\n# de la secuencia consecutiva más larga de números presente en el arreglo.\n#\n# Ejemplo:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Porque la secuencia consecutiva más larga es 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Porque la secuencia consecutiva más larga es 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "arb": "# يجد طول أطول تسلسل متتالي في مصفوفة من الأعداد الصحيحة.\n# تأخذ الدالة مصفوفة من الأعداد الصحيحة كوسيطة وتعيد طول\n# أطول تسلسل متتالي من الأرقام الموجودة في المصفوفة.\n#\n# مثال:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # لأن أطول تسلسل متتالي هو 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # لأن أطول تسلسل متتالي هو 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "sw": "# Inapata urefu wa mlolongo mrefu zaidi wa namba mfululizo katika safu ya namba za mzima.\n# Kazi inachukua safu ya namba za mzima kama hoja na inarejesha urefu\n# wa mlolongo mrefu zaidi wa namba mfululizo uliopo katika safu.\n#\n# Mfano:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Kwa sababu mlolongo mrefu zaidi wa namba mfululizo ni 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "tr": "# Bir tamsayı dizisindeki en uzun ardışık dizinin uzunluğunu bulur.\n# Fonksiyon, bir tamsayı dizisini argüman olarak alır ve dizide bulunan\n# en uzun ardışık sayı dizisinin uzunluğunu döndürür.\n#\n# Örnek:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Çünkü en uzun ardışık dizi 1, 2, 3, 4, 5, 6'dır\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Çünkü en uzun ardışık dizi 1, 2, 3, 4'tür\ndef longest_consecutive_sequence(arr)",
      "vi": "# Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng số nguyên.\n# Hàm nhận một mảng số nguyên làm đối số và trả về độ dài\n# của dãy số liên tiếp dài nhất có mặt trong mảng.\n#\n# Ví dụ:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)"
    },
    "prompt_bertscore": {
      "es": "0.995621789141229",
      "arb": "1",
      "sw": "0.9880176222640704",
      "tr": "0.9748986814878591",
      "vi": "0.9809014902331145"
    },
    "canonical_solution": "    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end",
    "instruction": {
      "en": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9344517756281059",
      "tr": "0.850025918473037",
      "vi": "0.9196657300638688"
    },
    "level": "",
    "test": "raise 'Test failed' unless longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) ==6\nraise 'Test failed' unless longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([1, 2, 0, 1]) == 3\nraise 'Test failed' unless longest_consecutive_sequence([]) == 0\nraise 'Test failed' unless longest_consecutive_sequence([1]) == 1",
    "entry_point": "longest_consecutive_sequence",
    "signature": "def longest_consecutive_sequence(arr)",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n\n Example:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Because the longest consecutive sequence is 1, 2, 3, 4",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga en un array de enteros. La función toma un array de enteros como argumento y devuelve la longitud de la secuencia consecutiva más larga de números presente en el array.\n\nEjemplo:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Porque la secuencia consecutiva más larga es 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Porque la secuencia consecutiva más larga es 1, 2, 3, 4",
      "arb": "يجد طول أطول تسلسل متتابع في مصفوفة من الأعداد الصحيحة. تأخذ الدالة مصفوفة من الأعداد الصحيحة كوسيط وتعيد طول أطول تسلسل متتابع من الأرقام الموجودة في المصفوفة.\n\nمثال:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   لأن أطول تسلسل متتابع هو 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   لأن أطول تسلسل متتابع هو 1, 2, 3, 4",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa nambari mfululizo katika safu ya nambari nzima.\n Kazi inachukua safu ya nambari nzima kama hoja na inarudisha urefu\n wa mlolongo mrefu zaidi wa nambari mfululizo uliopo kwenye safu.\n\n Mfano:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Kwa sababu mlolongo mrefu zaidi wa nambari mfululizo ni 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Kwa sababu mlolongo mrefu zaidi wa nambari mfululizo ni 1, 2, 3, 4",
      "tr": "Dizideki en uzun ardışık sayı dizisinin uzunluğunu bulur. \nFonksiyon, bir tamsayı dizisini argüman olarak alır ve dizide bulunan en uzun ardışık sayı dizisinin uzunluğunu döndürür.\n\nÖrnek:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Çünkü en uzun ardışık dizi 1, 2, 3, 4, 5, 6'dır\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Çünkü en uzun ardışık dizi 1, 2, 3, 4'tür",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng số nguyên. Hàm này nhận một mảng số nguyên làm đối số và trả về độ dài của dãy số liên tiếp dài nhất có trong mảng.\n\nVí dụ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Bởi vì dãy số liên tiếp dài nhất là 1, 2, 3, 4"
    },
    "docstring_bertscore": {
      "es": "0.9930380051447272",
      "arb": "0.9945473974102113",
      "sw": "0.9703232306607205",
      "tr": "0.9554060890450004",
      "vi": "0.9747554689831329"
    }
  },
  {
    "task_id": "Ruby/44",
    "prompt": {
      "en": "# Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n# The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n# It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n#\n# Examples:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "es": "# Compara el área de un cuadrado con lado de longitud 'a' con el área de un rectángulo con lados 'b' y 'c'.\n# La función toma tres argumentos, a, b y c, que son enteros positivos que representan la longitud del lado del cuadrado y los lados del rectángulo, respectivamente.\n# Devuelve una cadena que indica cuál forma tiene el área mayor: \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n#\n# Ejemplos:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "arb": "# يقارن بين مساحة مربع بطول ضلع 'a' ومساحة مستطيل بأضلاع 'b' و 'c'.\n# تأخذ الدالة ثلاثة مدخلات، a و b و c، وهي أعداد صحيحة موجبة تمثل طول ضلع المربع وأضلاع المستطيل، على التوالي.\n# تُرجع الدالة سلسلة نصية تشير إلى الشكل الذي له مساحة أكبر: \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n#\n# أمثلة:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "sw": "# Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n# Kazi hii inachukua hoja tatu, a, b, na c, ambazo ni nambari kamili chanya zinazowakilisha urefu wa upande wa mraba na pande za mstatili, mtawalia.\n# Inarudisha kamba inayoonyesha ni umbo gani lina eneo kubwa zaidi: \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n#\n# Mifano:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "tr": "# 'a' kenar uzunluğuna sahip bir karenin alanını, 'b' ve 'c' kenarlarına sahip bir dikdörtgenin alanı ile karşılaştırır.\n# Fonksiyon, sırasıyla karenin kenar uzunluğunu ve dikdörtgenin kenarlarını temsil eden pozitif tamsayılar olan üç argüman alır: a, b ve c.\n# Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" belirten bir dize döndürür.\n#\n# Örnekler:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "vi": "# So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'.\n# Hàm nhận ba đối số, a, b, và c, là các số nguyên dương đại diện cho độ dài cạnh của hình vuông và các cạnh của hình chữ nhật, tương ứng.\n# Nó trả về một chuỗi chỉ ra hình dạng nào có diện tích lớn hơn: \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n#\n# Ví dụ:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)"
    },
    "prompt_bertscore": {
      "es": "0.9832183149975054",
      "arb": "0.9766766220285024",
      "sw": "0.9803908115234737",
      "tr": "0.9567827962159532",
      "vi": "0.9836634456814046"
    },
    "canonical_solution": "    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end",
    "instruction": {
      "en": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9002152472617895",
      "sw": "0.9151651628903803",
      "tr": "0.8566170704069177",
      "vi": "0.9196657300638688"
    },
    "level": "",
    "test": "raise 'Test failed' unless compare_area(5, 4, 6) == \"Alice\"\nraise 'Test failed' unless compare_area(7, 5, 10) == \"Bob\"\nraise 'Test failed' unless compare_area(6, 3, 12) == \"Bob\"\nraise 'Test failed' unless compare_area(10, 10, 1) == \"Alice\"\nraise 'Test failed' unless compare_area(8, 8, 8) == \"Bob\" # Case where areas are equal, but based on the problem statement, Bob wins in a tie.",
    "entry_point": "compare_area",
    "signature": "def compare_area(a, b, c)",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n\n Examples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "es": "Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'.\n La función toma tres argumentos, a, b y c, que son enteros positivos que representan la longitud del lado del cuadrado y los lados del rectángulo, respectivamente.\n Devuelve una cadena que indica cuál forma tiene el área mayor: \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n\n Ejemplos:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "arb": "يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'. \nتأخذ الدالة ثلاثة وسائط، a، b، و c، وهي أعداد صحيحة موجبة تمثل طول ضلع المربع وأضلاع المستطيل، على التوالي. \nتُرجع سلسلة نصية تشير إلى الشكل الذي له المساحة الأكبر: \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n\nأمثلة:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "sw": "Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n Kazi hii inachukua hoja tatu, a, b, na c, ambazo ni nambari nzima chanya zinazowakilisha urefu wa upande wa mraba na pande za mstatili, mtawalia.\n Inarudisha kamba inayoonyesha umbo gani lina eneo kubwa zaidi: \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n\n Mifano:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "tr": "Bir kenar uzunluğu 'a' olan bir karenin alanını, kenarları 'b' ve 'c' olan bir dikdörtgenin alanı ile karşılaştırır.\n Fonksiyon, sırasıyla karenin kenar uzunluğunu ve dikdörtgenin kenarlarını temsil eden pozitif tamsayılar olan a, b ve c olmak üzere üç argüman alır.\n Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" belirten bir dize döndürür.\n\n Örnekler:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "vi": "So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật có các cạnh 'b' và 'c'. \nHàm nhận ba đối số, a, b, và c, là các số nguyên dương đại diện cho độ dài cạnh của hình vuông và các cạnh của hình chữ nhật, tương ứng. \nNó trả về một chuỗi chỉ ra hình nào có diện tích lớn hơn: \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9754574287497102",
      "arb": "0.9965158244862671",
      "sw": "0.9850014199280556",
      "tr": "0.9629776805396693",
      "vi": "0.9778262946739323"
    }
  },
  {
    "task_id": "Ruby/45",
    "prompt": {
      "en": "# Finds M positive integers whose sum is N, such that their product is maximized.\n# The function returns an array of these integers in lexicographically smallest order.\n#\n# Args:\n#   n: A positive integer representing the sum of the integers to find.\n#   m: A positive integer representing the number of integers to find.\n#\n# Returns:\n#   An array of integers that are the lexicographically smallest set of integers\n#   whose sum is N and whose product is maximized.\n#\n# Examples:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "es": "# Encuentra M enteros positivos cuya suma es N, de tal manera que su producto sea maximizado.\n# La función devuelve un arreglo de estos enteros en el orden lexicográficamente más pequeño.\n#\n# Argumentos:\n#   n: Un entero positivo que representa la suma de los enteros a encontrar.\n#   m: Un entero positivo que representa el número de enteros a encontrar.\n#\n# Devuelve:\n#   Un arreglo de enteros que son el conjunto de enteros lexicográficamente más pequeño\n#   cuya suma es N y cuyo producto es maximizado.\n#\n# Ejemplos:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "arb": "# يجد M عددًا صحيحًا موجبًا يكون مجموعهم N، بحيث يتم تعظيم حاصل ضربهم.\n# تُرجع الدالة مصفوفة من هذه الأعداد بترتيب معجمي أصغر.\n#\n# الوسائط:\n#   n: عدد صحيح موجب يمثل مجموع الأعداد المراد إيجادها.\n#   m: عدد صحيح موجب يمثل عدد الأعداد المراد إيجادها.\n#\n# الإرجاع:\n#   مصفوفة من الأعداد الصحيحة التي تمثل أصغر مجموعة من الأعداد بترتيب معجمي\n#   يكون مجموعها N ويكون حاصل ضربها معظّمًا.\n#\n# أمثلة:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "sw": "# Inapata nambari M zisizo hasi ambazo jumla yake ni N, ili kwamba bidhaa yao iwe kubwa zaidi.\n# Kazi inarudisha safu ya nambari hizi katika mpangilio mdogo wa lexicographically.\n#\n# Hoja:\n#   n: Nambari chanya inayowakilisha jumla ya nambari za kupata.\n#   m: Nambari chanya inayowakilisha idadi ya nambari za kupata.\n#\n# Inarudisha:\n#   Safu ya nambari ambazo ni seti ndogo ya lexicographically ya nambari\n#   ambazo jumla yake ni N na bidhaa yao imewezeshwa.\n#\n# Mifano:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "tr": "# Toplamı N olan ve çarpımları maksimum olan M pozitif tam sayı bulur.\n# Fonksiyon, bu tam sayıların sözlükbilimsel olarak en küçük sıradaki dizisini döndürür.\n#\n# Argümanlar:\n#   n: Bulunacak tam sayıların toplamını temsil eden pozitif bir tam sayı.\n#   m: Bulunacak tam sayıların sayısını temsil eden pozitif bir tam sayı.\n#\n# Döndürür:\n#   Toplamı N olan ve çarpımları maksimum olan tam sayıların sözlükbilimsel olarak en küçük kümesini\n#   içeren bir dizi.\n#\n# Örnekler:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "vi": "# Tìm M số nguyên dương có tổng là N, sao cho tích của chúng được tối đa hóa.\n# Hàm trả về một mảng các số nguyên này theo thứ tự từ điển nhỏ nhất.\n#\n# Tham số:\n#   n: Một số nguyên dương đại diện cho tổng của các số nguyên cần tìm.\n#   m: Một số nguyên dương đại diện cho số lượng các số nguyên cần tìm.\n#\n# Trả về:\n#   Một mảng các số nguyên là tập hợp các số nguyên nhỏ nhất theo thứ tự từ điển\n#   có tổng là N và có tích được tối đa hóa.\n#\n# Ví dụ:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)"
    },
    "prompt_bertscore": {
      "es": "0.987326785798831",
      "arb": "0.9593487034781618",
      "sw": "0.9363435313770821",
      "tr": "0.9409034890345",
      "vi": "0.9591927786290495"
    },
    "canonical_solution": "    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end",
    "instruction": {
      "en": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nRuby kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde yapın.",
      "vi": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9428772791308437",
      "tr": "0.8475539633810578",
      "vi": "0.9196657300638688"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_product_partition(6, 3) == [2, 2, 2]\nraise 'Test failed' unless max_product_partition(8, 3) == [2, 3, 3]\nraise 'Test failed' unless max_product_partition(10, 2) == [5, 5]\nraise 'Test failed' unless max_product_partition(7, 3) == [2, 2, 3]\nraise 'Test failed' unless max_product_partition(20, 5) == [4, 4, 4, 4, 4]",
    "entry_point": "max_product_partition",
    "signature": "def max_product_partition(n, m)",
    "docstring": {
      "en": "Finds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "es": "Encuentra M enteros positivos cuya suma es N, de tal manera que su producto sea maximizado. La función devuelve un arreglo de estos enteros en el orden lexicográficamente más pequeño.\n\nArgumentos:\n  n: Un entero positivo que representa la suma de los enteros a encontrar.\n  m: Un entero positivo que representa el número de enteros a encontrar.\n\nDevuelve:\n  Un arreglo de enteros que es el conjunto de enteros lexicográficamente más pequeño\n  cuya suma es N y cuyo producto es maximizado.\n\nEjemplos:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "arb": "يجد M عددًا صحيحًا موجبًا مجموعها N، بحيث يتم تعظيم حاصل ضربها. تُرجع الدالة مصفوفة من هذه الأعداد بترتيب معجمي أصغر.\n\nيعيدالحجج:\n  n: عدد صحيح موجب يمثل مجموع الأعداد التي يجب إيجادها.\n  m: عدد صحيح موجب يمثل عدد الأعداد التي يجب إيجادها.\n\nيعيد:\n  مصفوفة من الأعداد الصحيحة التي تمثل مجموعة الأعداد بترتيب معجمي أصغر\n  مجموعها N وحاصل ضربها مُعظّم.\n\nامثله:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "sw": "Inapata nambari M zisizo hasi ambazo jumla yake ni N, ili kwamba bidhaa yao iwe kubwa zaidi.\nKazi ya kipengele hiki ni kurudisha safu ya namba hizi katika mpangilio mdogo wa lexicographically.\n\nHoja:\n   n: Nambari chanya inayowakilisha jumla ya nambari za kupata.\n   m: Nambari chanya inayowakilisha idadi ya nambari za kupata.\n\nInarejesha:\n   Safu ya nambari ambazo ni seti ndogo ya lexicographically ya nambari\n   ambazo jumla yao ni N na bidhaa yao imewezeshwa.\n\nMifano:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "tr": "M pozitif tam sayının toplamı N olacak şekilde bulunur ve bu sayılar arasındaki çarpım en büyük olacak şekilde düzenlenir. Fonksiyon, bu tam sayıların sözlük sırasına göre en küçük olanını içeren bir dizi döndürür.\n\nArgümanlar:\n   n: Bulunacak tam sayıların toplamını temsil eden pozitif bir tam sayı.\n   m: Bulunacak tam sayıların sayısını temsil eden pozitif bir tam sayı.\n\nDöndürür:\n   Toplamı N olan ve çarpımı en büyük olan tam sayıların sözlük sırasına göre en küçük kümesini içeren bir tam sayı dizisi.\n\nÖrnekler:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "vi": "Tìm M số nguyên dương có tổng là N, sao cho tích của chúng là lớn nhất. Hàm trả về một mảng các số nguyên này theo thứ tự từ điển nhỏ nhất.\n\nTham số:\n  n: Một số nguyên dương đại diện cho tổng của các số nguyên cần tìm.\n  m: Một số nguyên dương đại diện cho số lượng số nguyên cần tìm.\n\nTrả về:\n  Một mảng các số nguyên là tập hợp các số nguyên có thứ tự từ điển nhỏ nhất\n  có tổng là N và tích của chúng là lớn nhất.\n\nVí dụ:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9900414672164348",
      "arb": "0.9437665473467369",
      "sw": "0.9258435321748159",
      "tr": "0.897537312464677",
      "vi": "0.9303029828594301"
    }
  },
  {
    "task_id": "Ruby/46",
    "prompt": {
      "en": "# Counts the number of characters in a given title, excluding spaces and newline characters.\n# The function takes a single argument, title, which is a string representing the title of an essay.\n# It returns the count of characters in the title, excluding any spaces and newline characters.\n#\n# Examples:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "es": "# Cuenta el número de caracteres en un título dado, excluyendo espacios y caracteres de nueva línea.\n# La función toma un único argumento, title, que es una cadena que representa el título de un ensayo.\n# Devuelve el conteo de caracteres en el título, excluyendo cualquier espacio y caracteres de nueva línea.\n#\n# Ejemplos:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "arb": "# يحسب عدد الأحرف في العنوان المعطى، باستثناء المسافات وأحرف السطر الجديد.\n# تأخذ الدالة وسيطًا واحدًا، title، وهو سلسلة تمثل عنوان المقال.\n# تُرجع عدد الأحرف في العنوان، باستثناء أي مسافات وأحرف السطر الجديد.\n#\n# أمثلة:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "sw": "# Inahesabu idadi ya herufi katika kichwa kilichopewa, isipokuwa nafasi na herufi za kurudi mstari mpya.\n# Kazi inachukua hoja moja, title, ambayo ni kamba inayowakilisha kichwa cha insha.\n# Inarudisha hesabu ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.\n#\n# Mifano:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "tr": "# Verilen bir başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar.\n# Fonksiyon, bir makalenin başlığını temsil eden bir string olan title adlı tek bir argüman alır.\n# Boşluklar ve yeni satır karakterleri hariç olmak üzere, başlıktaki karakterlerin sayısını döndürür.\n#\n# Örnekler:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "vi": "# Đếm số ký tự trong một tiêu đề cho trước, không bao gồm khoảng trắng và ký tự xuống dòng.\n# Hàm nhận một đối số duy nhất, title, là một chuỗi đại diện cho tiêu đề của một bài luận.\n# Nó trả về số lượng ký tự trong tiêu đề, không bao gồm bất kỳ khoảng trắng và ký tự xuống dòng nào.\n#\n# Ví dụ:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)"
    },
    "prompt_bertscore": {
      "es": "0.9886808491063459",
      "arb": "0.9697259491049486",
      "sw": "0.9885523352498163",
      "tr": "0.9795680844852273",
      "vi": "0.9917399556046642"
    },
    "canonical_solution": "    title.count(\"^ \\n\")\n  end",
    "instruction": {
      "en": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nRuby kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde sağlayın.",
      "vi": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9428772791308437",
      "tr": "0.8351977632680205",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_chars_in_title(\"234\") == 3\nraise 'Test failed' unless count_chars_in_title(\"Ca 45\") == 4\nraise 'Test failed' unless count_chars_in_title(\"Hello World\\n\") == 10\nraise 'Test failed' unless count_chars_in_title(\"Ruby Programming 101 \") == 18\nraise 'Test failed' unless count_chars_in_title(\"\\nNew Line\\n\") == 7",
    "entry_point": "count_chars_in_title",
    "signature": "def count_chars_in_title(title)",
    "docstring": {
      "en": "Counts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n\n Examples:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "es": "Cuenta el número de caracteres en un título dado, excluyendo espacios y caracteres de nueva línea. \nLa función toma un solo argumento, title, que es una cadena que representa el título de un ensayo. \nDevuelve el conteo de caracteres en el título, excluyendo cualquier espacio y caracteres de nueva línea.\n\nEjemplos:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "arb": "يحسب عدد الأحرف في عنوان معين، باستثناء المسافات وأحرف السطر الجديد. تأخذ الدالة وسيطًا واحدًا، title، وهو سلسلة تمثل عنوان مقال. تُرجع عدد الأحرف في العنوان، باستثناء أي مسافات وأحرف السطر الجديد.\n\nأمثلة:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "sw": "Hesabu idadi ya herufi katika kichwa kilichopewa, ukiondoa nafasi na herufi za kurudi mpya.\n Kazi inachukua hoja moja, title, ambayo ni kamba inayowakilisha kichwa cha insha.\n Inarudisha hesabu ya herufi katika kichwa, ukiondoa nafasi zozote na herufi za kurudi mpya.\n\n Mifano:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "tr": "Verilen bir başlıktaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar. \nFonksiyon, bir makalenin başlığını temsil eden bir string olan tek bir argüman, title, alır. \nBoşluklar ve yeni satır karakterleri hariç, başlıktaki karakterlerin sayısını döndürür.\n\nÖrnekler:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "vi": "Đếm số ký tự trong một tiêu đề cho trước, không bao gồm các ký tự khoảng trắng và ký tự xuống dòng. Hàm này nhận một đối số duy nhất, title, là một chuỗi đại diện cho tiêu đề của một bài luận. Nó trả về số lượng ký tự trong tiêu đề, không bao gồm bất kỳ khoảng trắng và ký tự xuống dòng nào.\n\nVí dụ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10"
    },
    "docstring_bertscore": {
      "es": "0.9826893622928095",
      "arb": "0.9738167418023621",
      "sw": "0.9851672762962197",
      "tr": "0.9812093673237186",
      "vi": "0.9793942829018217"
    }
  },
  {
    "task_id": "Ruby/47",
    "prompt": {
      "en": "# Counts the number of students who have enrolled in both courses A and B.\n# This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n# a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n# The function returns the count of students who have enrolled in both courses.\n#\n# Example:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "es": "# Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n# Esta función toma cuatro argumentos: n y m son el número de estudiantes inscritos en los cursos A y B, respectivamente.\n# a_n es un arreglo de IDs de estudiantes inscritos en el curso A, y b_m es un arreglo de IDs de estudiantes inscritos en el curso B.\n# La función devuelve el conteo de estudiantes que se han inscrito en ambos cursos.\n#\n# Ejemplo:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "arb": "# يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.\n# تأخذ هذه الدالة أربعة معطيات: n و m هما عدد الطلاب المسجلين في الدورتين A و B على التوالي.\n# a_n هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة A، و b_m هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة B.\n# تعيد الدالة عدد الطلاب الذين سجلوا في كلا الدورتين.\n#\n# مثال:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "sw": "# Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B.\n# Kazi hii inachukua hoja nne: n na m ni idadi ya wanafunzi waliojiandikisha katika kozi A na B, mtawalia.\n# a_n ni safu ya nambari za utambulisho za wanafunzi waliojiandikisha katika kozi A, na b_m ni safu ya nambari za utambulisho za wanafunzi waliojiandikisha katika kozi B.\n# Kazi hii inarejesha idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n#\n# Mfano:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "tr": "# Hem A hem de B kurslarına kayıtlı olan öğrencilerin sayısını sayar.\n# Bu fonksiyon dört argüman alır: n ve m sırasıyla A ve B kurslarına kayıtlı öğrenci sayılarıdır.\n# a_n, A kursuna kayıtlı öğrenci kimliklerinin bir dizisidir ve b_m, B kursuna kayıtlı öğrenci kimliklerinin bir dizisidir.\n# Fonksiyon, her iki kursa da kayıtlı olan öğrencilerin sayısını döndürür.\n#\n# Örnek:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "vi": "# Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.\n# Hàm này nhận bốn tham số: n và m là số lượng sinh viên đăng ký trong các khóa học A và B, tương ứng.\n# a_n là một mảng chứa mã số sinh viên đã đăng ký khóa học A, và b_m là một mảng chứa mã số sinh viên đã đăng ký khóa học B.\n# Hàm trả về số lượng sinh viên đã đăng ký cả hai khóa học.\n#\n# Ví dụ:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9766496082966817",
      "sw": "0.981644169227804",
      "tr": "0.9753819492049169",
      "vi": "0.9631999479360474"
    },
    "canonical_solution": "    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end",
    "instruction": {
      "en": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.9057157197734076",
      "sw": "0.9428772791308437",
      "tr": "0.8566170704069177",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) == 4\nraise 'Test failed' unless count_common_students(3, 2, [1, 2, 3], [2, 4]) == 1\nraise 'Test failed' unless count_common_students(4, 4, [7, 8, 9, 10], [10, 11, 12, 13]) == 1\nraise 'Test failed' unless count_common_students(2, 3, [14, 15], [15, 16, 17]) == 1\nraise 'Test failed' unless count_common_students(6, 5, [18, 19, 20, 21, 22, 23], [20, 21, 24, 25, 26]) == 2",
    "entry_point": "count_common_students",
    "signature": "def count_common_students(n, m, a_n, b_m)",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n\n Example:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "es": "Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n Esta función toma cuatro argumentos: n y m son el número de estudiantes inscritos en los cursos A y B, respectivamente.\n a_n es un arreglo de IDs de estudiantes inscritos en el curso A, y b_m es un arreglo de IDs de estudiantes inscritos en el curso B.\n La función devuelve el conteo de estudiantes que se han inscrito en ambos cursos.\n\n Ejemplo:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "arb": "يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B. \nتأخذ هذه الدالة أربعة معطيات: n و m هما عدد الطلاب المسجلين في الدورتين A و B على التوالي. \na_n هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة A، و b_m هو مصفوفة تحتوي على معرفات الطلاب المسجلين في الدورة B. \nتعيد الدالة عدد الطلاب الذين سجلوا في كلا الدورتين.\n\nمثال:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "sw": "Hesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B. \nKazi hii inachukua hoja nne: n na m ni idadi ya wanafunzi waliojiandikisha katika kozi A na B, mtawalia. \na_n ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi A, na b_m ni safu ya vitambulisho vya wanafunzi waliojiandikisha katika kozi B. \nKazi hii inarejesha idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili.\n\nMfano:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "tr": "Her iki kursa da kaydolan öğrencilerin sayısını sayar.\n Bu fonksiyon dört argüman alır: n ve m, sırasıyla A ve B kurslarına kaydolan öğrenci sayılarıdır.\n a_n, A kursuna kaydolan öğrenci kimliklerinin bir dizisidir ve b_m, B kursuna kaydolan öğrenci kimliklerinin bir dizisidir.\n Fonksiyon, her iki kursa da kaydolan öğrencilerin sayısını döndürür.\n\n Örnek:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "vi": "Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B. \nHàm này nhận bốn đối số: n và m là số lượng sinh viên đăng ký các khóa học A và B, tương ứng. \na_n là một mảng chứa mã số sinh viên đăng ký khóa học A, và b_m là một mảng chứa mã số sinh viên đăng ký khóa học B. \nHàm trả về số lượng sinh viên đã đăng ký cả hai khóa học.\n\nVí dụ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9946506852083494",
      "arb": "0.9646120113148243",
      "sw": "0.9834856714903784",
      "tr": "0.9667486783236167",
      "vi": "0.9575981739301014"
    }
  },
  {
    "task_id": "Ruby/48",
    "prompt": {
      "en": "# Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n# and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n# and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n# greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n#\n# Arguments:\n# - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n# - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n#\n# Returns:\n# - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n#\n# Examples:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "es": "# Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas\n# y entregas fallidas. Por cada entrega exitosa, Deliv-e-droid gana 50 unidades de dinero,\n# y por cada entrega fallida, pierde 10 unidades. Si el número de entregas exitosas es\n# mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n#\n# Argumentos:\n# - delivered: Entero que representa el número de paquetes entregados exitosamente (0 <= delivered <= 100).\n# - failed: Entero que representa el número de entregas fallidas (0 <= failed <= 100).\n#\n# Retorna:\n# - Entero: Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n#\n# Ejemplos:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "arb": "# يحسب الأرباح الكلية لـ Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة.\n# لكل عملية تسليم ناجحة، يكسب Deliv-e-droid 50 وحدة من المال، ولكل عملية تسليم فاشلة، يخسر 10 وحدات.\n# إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n#\n# المعطيات:\n# - delivered: عدد صحيح يمثل عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n# - failed: عدد صحيح يمثل عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n#\n# يعيد:\n# - عدد صحيح: الأرباح الكلية لـ Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق الأرباح.\n#\n# أمثلة:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "sw": "# Inahesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa\n# na uwasilishaji ulioshindwa. Kwa kila uwasilishaji uliofanikiwa, Deliv-e-droid hupata vitengo 50 vya pesa,\n# na kwa kila uwasilishaji ulioshindwa, inapoteza vitengo 10. Ikiwa idadi ya uwasilishaji uliofanikiwa ni\n# kubwa kuliko ya uwasilishaji ulioshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n#\n# Hoja:\n# - delivered: Nambari inayowakilisha idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n# - failed: Nambari inayowakilisha idadi ya uwasilishaji ulioshindwa (0 <= failed <= 100).\n#\n# Inarudisha:\n# - Nambari: Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n#\n# Mifano:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "tr": "# Deliv-e-droid'un başarılı ve başarısız teslimat sayısına göre toplam kazancını hesaplar.\n# Her başarılı teslimat için, Deliv-e-droid 50 birim para kazanır,\n# ve her başarısız teslimat için 10 birim kaybeder. Eğer başarılı teslimat sayısı\n# başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n#\n# Argümanlar:\n# - delivered: Başarıyla teslim edilen paketlerin sayısını temsil eden tamsayı (0 <= delivered <= 100).\n# - failed: Başarısız teslimatların sayısını temsil eden tamsayı (0 <= failed <= 100).\n#\n# Döndürür:\n# - Tamsayı: Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla ise negatif olabilir.\n#\n# Örnekler:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "vi": "# Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công\n# và giao hàng thất bại. Với mỗi giao hàng thành công, Deliv-e-droid kiếm được 50 đơn vị tiền,\n# và với mỗi giao hàng thất bại, nó mất 10 đơn vị. Nếu số lượng giao hàng thành công\n# lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n#\n# Tham số:\n# - delivered: Số nguyên đại diện cho số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n# - failed: Số nguyên đại diện cho số lượng giao hàng thất bại (0 <= failed <= 100).\n#\n# Trả về:\n# - Số nguyên: Tổng thu nhập của Deliv-e-droid, có thể là âm nếu tổn thất lớn hơn lợi nhuận.\n#\n# Ví dụ:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)"
    },
    "prompt_bertscore": {
      "es": "0.9892449593884849",
      "arb": "0.9653568752437052",
      "sw": "0.9710752452833186",
      "tr": "0.965487176773664",
      "vi": "0.9739677008919486"
    },
    "canonical_solution": "    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end",
    "instruction": {
      "en": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nAşağıdaki Ruby kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8792176324218294",
      "sw": "0.9428772791308437",
      "tr": "0.8643833196750008",
      "vi": "0.923094686331674"
    },
    "level": "",
    "test": "raise 'Test failed' unless calculate_droid_earnings(5, 2) == 730\nraise 'Test failed' unless calculate_droid_earnings(0, 10) == -100\nraise 'Test failed' unless calculate_droid_earnings(10, 0) == 1000\nraise 'Test failed' unless calculate_droid_earnings(3, 5) == 100\nraise 'Test failed' unless calculate_droid_earnings(20, 20) == 800",
    "entry_point": "calculate_droid_earnings",
    "signature": "def calculate_droid_earnings(delivered, failed)",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "es": "Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas. Por cada entrega exitosa, Deliv-e-droid gana 50 unidades de dinero, y por cada entrega fallida, pierde 10 unidades. Si el número de entregas exitosas es mayor que el de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n\nArgumentos:\n- delivered: Entero que representa el número de paquetes entregados exitosamente (0 <= delivered <= 100).\n- failed: Entero que representa el número de entregas fallidas (0 <= failed <= 100).\n\nDevuelve:\n- Entero: Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n\nEjemplos:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "arb": "يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة. لكل عملية تسليم ناجحة، يكسب Deliv-e-droid 50 وحدة من المال، ولكل عملية تسليم فاشلة، يخسر 10 وحدات. إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\nالمعطيات:\n- delivered: عدد صحيح يمثل عدد الطرود التي تم تسليمها بنجاح (0 <= delivered <= 100).\n- failed: عدد صحيح يمثل عدد عمليات التسليم الفاشلة (0 <= failed <= 100).\n\nالقيم المعادة:\n- عدد صحيح: إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق الأرباح.\n\nأمثلة:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "sw": "Hesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uwasilishaji ulioshindwa. Kwa kila uwasilishaji uliofanikiwa, Deliv-e-droid hupata vitengo 50 vya pesa, na kwa kila uwasilishaji ulioshindwa, hupoteza vitengo 10. Ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n\nHoja:\n- delivered: Nambari inayoashiria idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= delivered <= 100).\n- failed: Nambari inayoashiria idadi ya uwasilishaji ulioshindwa (0 <= failed <= 100).\n\nRudisha:\n- Nambari: Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara ni kubwa kuliko faida.\n\nMifano:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "tr": "Deliv-e-droid'un başarılı ve başarısız teslimat sayısına göre toplam kazancını hesaplar. Her başarılı teslimat için Deliv-e-droid 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder. Başarılı teslimat sayısı başarısız olanlardan fazla ise, Deliv-e-droid 500 birim bonus alır.\n\nArgümanlar:\n- delivered: Başarıyla teslim edilen paketlerin sayısını temsil eden tamsayı (0 <= delivered <= 100).\n- failed: Başarısız teslimatların sayısını temsil eden tamsayı (0 <= failed <= 100).\n\nDöndürür:\n- Tamsayı: Deliv-e-droid'un toplam kazancı, kayıplar kazançları aştığında negatif olabilir.\n\nÖrnekler:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "vi": "Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. Đối với mỗi lần giao hàng thành công, Deliv-e-droid kiếm được 50 đơn vị tiền, và đối với mỗi lần giao hàng thất bại, nó mất 10 đơn vị. Nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\nTham số:\n- delivered: Số nguyên đại diện cho số lượng gói hàng được giao thành công (0 <= delivered <= 100).\n- failed: Số nguyên đại diện cho số lượng giao hàng thất bại (0 <= failed <= 100).\n\nTrả về:\n- Số nguyên: Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất vượt quá lợi nhuận.\n\nVí dụ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100"
    },
    "docstring_bertscore": {
      "es": "0.983705952582946",
      "arb": "0.9724765826215197",
      "sw": "0.9650557515860563",
      "tr": "0.9634794208821634",
      "vi": "0.9764654779334623"
    }
  },
  {
    "task_id": "Ruby/49",
    "prompt": {
      "en": "# Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n# The function takes a nested array (array of arrays) where each sub-array\n# contains ticket IDs for a particular batch. It returns an array with two elements:\n# the first is the missing ID, and the second is the duplicate ID.\n#\n# Example:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "es": "# Encuentra el ID faltante (roto) y el ID duplicado en una secuencia de IDs de boletos.\n# La función toma un array anidado (array de arrays) donde cada sub-array\n# contiene IDs de boletos para un lote particular. Devuelve un array con dos elementos:\n# el primero es el ID faltante, y el segundo es el ID duplicado.\n#\n# Ejemplo:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "arb": "# يعثر على المعرف المفقود (المعطل) والمكرر في تسلسل معرفات التذاكر.\n# تأخذ الدالة مصفوفة متداخلة (مصفوفة من المصفوفات) حيث تحتوي كل مصفوفة فرعية\n# على معرفات التذاكر لدفعة معينة. تُرجع مصفوفة بعنصرين:\n# الأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n#\n# مثال:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "sw": "# Inapata kitambulisho kilichokosekana (kilichovunjika) na kinachojirudia katika mlolongo wa vitambulisho vya tiketi.\n# Kazi hii inachukua safu iliyopachikwa (safu ya safu) ambapo kila safu ndogo\n# ina vitambulisho vya tiketi kwa kundi fulani. Inarejesha safu yenye vipengele viwili:\n# ya kwanza ni kitambulisho kilichokosekana, na ya pili ni kitambulisho kinachojirudia.\n#\n# Mfano:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "tr": "# Bir bilet ID'leri dizisinde eksik (bozuk) ve yinelenen ID'yi bulur.\n# Fonksiyon, her alt dizinin belirli bir parti için bilet ID'leri içerdiği\n# iç içe bir dizi (dizilerin dizisi) alır. İki elemanlı bir dizi döndürür:\n# birincisi eksik ID, ikincisi ise yinelenen ID'dir.\n#\n# Örnek:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "vi": "# Tìm ID bị thiếu (bị hỏng) và ID trùng lặp trong một dãy ID vé.\n# Hàm nhận vào một mảng lồng nhau (mảng của các mảng) mà mỗi mảng con\n# chứa các ID vé cho một lô cụ thể. Nó trả về một mảng với hai phần tử:\n# phần tử đầu tiên là ID bị thiếu, và phần tử thứ hai là ID trùng lặp.\n#\n# Ví dụ:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)"
    },
    "prompt_bertscore": {
      "es": "0.9917300240856124",
      "arb": "0.9889734316576102",
      "sw": "0.9823250741739915",
      "tr": "0.9805165445546689",
      "vi": "0.9854020574066029"
    },
    "canonical_solution": "    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end",
    "instruction": {
      "en": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando como máximo 500 caracteres.",
      "arb": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nAşağıdaki Ruby kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir açıklama (docstring) olarak sağlayın.",
      "vi": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9151651628903803",
      "tr": "0.8305508055037093",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]]) == [7, 9]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5, 7]]) == [6, 5]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[20, 21, 23], [22, 24, 24, 26]]) == [25, 24]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[100, 102, 106], [101, 103, 103, 105]]) == [104, 103]",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "def find_missing_and_duplicate_ids(ids)",
    "docstring": {
      "en": "Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n\n Example:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "es": "Encuentra el ID faltante (roto) y el ID duplicado en una secuencia de IDs de tickets. \nLa función toma un arreglo anidado (arreglo de arreglos) donde cada sub-arreglo \ncontiene IDs de tickets para un lote particular. Devuelve un arreglo con dos elementos: \nel primero es el ID faltante, y el segundo es el ID duplicado.\n\nEjemplo:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "arb": "يعثر على المعرف المفقود (المعطل) والمكرر في تسلسل معرفات التذاكر.\nتأخذ الدالة مصفوفة متداخلة (مصفوفة من المصفوفات) حيث يحتوي كل صفيف فرعي\nعلى معرفات التذاكر لدفعة معينة. تُرجع مصفوفة تحتوي على عنصرين:\nالأول هو المعرف المفقود، والثاني هو المعرف المكرر.\n\nمثال:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "sw": "Inapata kitambulisho kilichokosekana (kilichovunjika) na kitambulisho kilichorudiwa katika mlolongo wa vitambulisho vya tiketi. \nKazi hii inachukua safu iliyopachikwa (safu za safu) ambapo kila safu ndogo \nina vitambulisho vya tiketi kwa kundi fulani. Inarudisha safu yenye vipengele viwili: \ncha kwanza ni kitambulisho kilichokosekana, na cha pili ni kitambulisho kilichorudiwa.\n\nMfano:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "tr": "Eksik (bozuk) ve yinelenen kimliği bir bilet kimliği dizisinde bulur. \nFonksiyon, her alt dizinin belirli bir parti için bilet kimliklerini içerdiği iç içe bir dizi (dizi dizisi) alır. İki öğeden oluşan bir dizi döndürür: ilki eksik kimlik, ikincisi ise yinelenen kimliktir.\n\nÖrnek:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "vi": "Tìm ID bị thiếu (bị hỏng) và ID trùng lặp trong một dãy ID vé.\nHàm nhận một mảng lồng nhau (mảng của các mảng) trong đó mỗi mảng con\nchứa các ID vé cho một lô cụ thể. Nó trả về một mảng với hai phần tử:\nphần tử đầu tiên là ID bị thiếu, và phần tử thứ hai là ID trùng lặp.\n\nVí dụ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]"
    },
    "docstring_bertscore": {
      "es": "0.9892894525938367",
      "arb": "0.988311595228002",
      "sw": "0.9867130179214332",
      "tr": "0.9835031509639094",
      "vi": "0.9642443464795287"
    }
  },
  {
    "task_id": "Ruby/50",
    "prompt": {
      "en": "# Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n# The function takes a single argument, s, which is a string of length 8,\n# and returns an array with three integers representing the count of digits,\n# lowercase letters, and uppercase letters in the string, respectively.\n#\n# Examples:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "es": "# Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada.\n# La función toma un solo argumento, s, que es una cadena de longitud 8,\n# y devuelve un arreglo con tres enteros que representan el conteo de dígitos,\n# letras minúsculas y letras mayúsculas en la cadena, respectivamente.\n#\n# Ejemplos:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "arb": "# يحسب عدد الأرقام والحروف الصغيرة والحروف الكبيرة في سلسلة معينة.\n# تأخذ الدالة وسيطًا واحدًا، s، وهو سلسلة بطول 8،\n# وتعيد مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأرقام،\n# والحروف الصغيرة، والحروف الكبيرة في السلسلة، على التوالي.\n#\n# أمثلة:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "sw": "# Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa.\n# Kazi inachukua hoja moja, s, ambayo ni kamba ya urefu wa 8,\n# na inarejesha safu iliyo na nambari tatu zinazowakilisha idadi ya tarakimu,\n# herufi ndogo, na herufi kubwa katika kamba, mtawalia.\n#\n# Mifano:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "tr": "# Verilen bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n# Fonksiyon, s adında tek bir argüman alır, bu 8 uzunluğunda bir stringdir,\n# ve stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını temsil eden\n# üç tamsayı içeren bir dizi döndürür.\n#\n# Örnekler:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "vi": "# Đếm số chữ số, chữ cái thường và chữ cái hoa trong một chuỗi cho trước.\n# Hàm nhận một tham số, s, là một chuỗi có độ dài 8,\n# và trả về một mảng với ba số nguyên đại diện cho số lượng chữ số,\n# chữ cái thường, và chữ cái hoa trong chuỗi, tương ứng.\n#\n# Ví dụ:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)"
    },
    "prompt_bertscore": {
      "es": "0.9963765845891616",
      "arb": "0.9876503546895369",
      "sw": "0.9849839404545245",
      "tr": "0.9861050103250855",
      "vi": "0.9851966735926129"
    },
    "canonical_solution": "    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end",
    "instruction": {
      "en": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "es": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Ruby en español utilizando un máximo de 500 caracteres.",
      "arb": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة روبي باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Ruby kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nAşağıdaki Ruby kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Ruby bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.968965592006347",
      "arb": "0.8693351750742006",
      "sw": "0.9428772791308437",
      "tr": "0.850025918473037",
      "vi": "0.9021401742843985"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]",
    "entry_point": "count_chars_types",
    "signature": "def count_chars_types(s)",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "es": "Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada.\n La función toma un solo argumento, s, que es una cadena de longitud 8,\n y devuelve un arreglo con tres enteros que representan el conteo de dígitos,\n letras minúsculas y letras mayúsculas en la cadena, respectivamente.\n\n Ejemplos:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "arb": "يحسب عدد الأرقام والحروف الصغيرة والحروف الكبيرة في سلسلة معينة. تأخذ الدالة وسيطًا واحدًا، s، وهو سلسلة بطول 8، وتعيد مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأرقام والحروف الصغيرة والحروف الكبيرة في السلسلة، على التوالي.\n\nأمثلة:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "sw": "Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa. \nKazi hii inachukua hoja moja, s, ambayo ni kamba ya urefu wa 8, \nna inarejesha safu iliyo na nambari tatu zinazoashiria idadi ya tarakimu, \nherufi ndogo, na herufi kubwa katika kamba, mtawalia.\n\nMifano:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "tr": "Rakamların, küçük harflerin ve büyük harflerin sayısını verilen bir string içinde sayar.\nFonksiyon, s adlı tek bir argüman alır, bu argüman 8 uzunluğunda bir stringdir\nve sırasıyla string içindeki rakamların, küçük harflerin ve büyük harflerin sayısını temsil eden üç tam sayı içeren bir dizi döndürür.\n\nÖrnekler:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "vi": "Đếm số chữ số, chữ cái viết thường, và chữ cái viết hoa trong một chuỗi cho trước. \nHàm nhận một đối số duy nhất, s, là một chuỗi có độ dài 8, \nvà trả về một mảng với ba số nguyên đại diện cho số lượng chữ số, \nchữ cái viết thường, và chữ cái viết hoa trong chuỗi, theo thứ tự tương ứng.\n\nVí dụ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]"
    },
    "docstring_bertscore": {
      "es": "0.9944621849767473",
      "arb": "0.9813206003370981",
      "sw": "0.9796799133897499",
      "tr": "0.9935169029934023",
      "vi": "0.976811293426844"
    }
  }
]