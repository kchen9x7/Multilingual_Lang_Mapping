[
  {
    "task_id": "Common Lisp/1",
    "prompt": {
      "es": "(defun has-close-elements (numbers threshold)\n;;Verificar si en la lista dada de números, hay dos números más cercanos entre sí que\n;;el umbral dado.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "arb": "(defun has-close-elements (numbers threshold)\n;;تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "sw": "(defun has-close-elements (numbers threshold)\n;;Angalia kama katika orodha ya namba iliyotolewa, kuna namba zozote mbili zilizo karibu zaidi kuliko\n;;kizingiti kilichotolewa.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "tr": "(defun has-close-elements (numbers threshold)\n;; Verilen sayı listesindeki herhangi iki sayının birbirine\n;; verilen eşikten daha yakın olup olmadığını kontrol et.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "vi": "(defun has-close-elements (numbers threshold)\n;;Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n;;ngưỡng đã cho không.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t"
    },
    "prompt_bertscore": {
      "es": "0.9762890941551033",
      "arb": "0.9809348601371283",
      "sw": "0.9742235368227216",
      "tr": "0.9725031990925783",
      "vi": "0.9645935386893881"
    },
    "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun has-close-elements (numbers threshold)` para resolver el siguiente problema:\nVerifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "arb": "اكتب دالة Common Lisp `(defun has-close-elements (numbers threshold)` لحل المشكلة التالية:\nتحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمان أقرب إلى بعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "sw": "Andika kazi ya Common Lisp `(defun has-close-elements (numbers threshold)` kutatua tatizo lifuatalo:\nAngalia kama katika orodha ya namba iliyotolewa, kuna namba zozote mbili zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "tr": "Common Lisp fonksiyonu `(defun has-close-elements (numbers threshold)` yazın: \nVerilen sayı listesindeki herhangi iki sayının, verilen eşikten birbirine daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "vi": "Viết một hàm Common Lisp `(defun has-close-elements (numbers threshold)` để giải quyết vấn đề sau:\nKiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'"
    },
    "instruction_bertscore": {
      "es": "0.9805812980588863",
      "arb": "0.7820140814851672",
      "sw": "0.7765614788953784",
      "tr": "0.949664876511568",
      "vi": "0.9808506408555695"
    },
    "level": "middle",
    "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)",
    "entry_point": "has-close-elements",
    "signature": "(defun has-close-elements (numbers threshold)",
    "docstring": {
      "es": "Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "arb": "تحقق مما إذا كانت هناك أي رقمين في قائمة الأرقام المعطاة أقرب إلى بعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "sw": "Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'"
    },
    "docstring_bertscore": {
      "es": "0.9742169820201474",
      "arb": "0.9547224032734782",
      "sw": "0.9657481770943439",
      "tr": "0.9441947944482482",
      "vi": "0.9726468088580665"
    }
  },
  {
    "task_id": "Common Lisp/2",
    "prompt": {
      "es": "(defun bin-search (obj vec)\n;; Búsqueda binaria de 'obj' en el vector ordenado 'vec'.\n;; Devuelve 't' si se encuentra 'obj', 'nil' de lo contrario.\n;; Ejemplo:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "arb": "(defun bin-search (obj vec)\n;; البحث الثنائي عن 'obj' في المتجه المرتب 'vec'.\n;; يعيد 't' إذا تم العثور على 'obj'، 'nil' خلاف ذلك.\n;; مثال:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "sw": "(defun bin-search (obj vec)\n;; Utafutaji wa binary kwa 'obj' katika vekta iliyopangwa 'vec'.\n;; Inarudisha 't' ikiwa 'obj' imepatikana, 'nil' vinginevyo.\n;; Mfano:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "tr": "(defun bin-search (obj vec)\n;; Sıralı vektör 'vec' içinde 'obj' için ikili arama.\n;; 'obj' bulunursa 't', aksi takdirde 'nil' döner.\n;; Örnek:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "vi": "(defun bin-search (obj vec)\n;; Tìm kiếm nhị phân cho 'obj' trong vector đã sắp xếp 'vec'.\n;; Trả về 't' nếu 'obj' được tìm thấy, 'nil' nếu không.\n;; Ví dụ:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9954577204464942",
      "arb": "0.9954577204464942",
      "sw": "0.9954577204464942",
      "tr": "0.967047219786312",
      "vi": "0.9839631789263862"
    },
    "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))",
    "instruction": {
      "es": "Escribe una función en Common Lisp `(defun bin-search (obj vec)` para resolver el siguiente problema:\nBúsqueda binaria de 'obj' en el vector ordenado 'vec'.\nDevuelve 't' si 'obj' se encuentra, 'nil' en caso contrario.\nEjemplo:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "arb": "اكتب دالة Common Lisp `(defun bin-search (obj vec)` لحل المشكلة التالية:\nالبحث الثنائي عن 'obj' في المتجه المرتب 'vec'.\nيعيد 't' إذا تم العثور على 'obj'، و'nil' خلاف ذلك.\nمثال:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "sw": "Andika kazi ya Common Lisp `(defun bin-search (obj vec)` kutatua tatizo lifuatalo:  \nTafuta kwa kutumia binary 'obj' katika vector iliyopangwa 'vec'.  \nRudisha 't' ikiwa 'obj' imepatikana, 'nil' vinginevyo.  \nMfano:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "tr": "Bir Common Lisp fonksiyonu `(defun bin-search (obj vec)` yazın:\nSıralı vektör 'vec' içinde 'obj' için ikili arama.\n'obj' bulunursa 't' döner, aksi takdirde 'nil' döner.\nÖrnek:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "vi": "Viết một hàm Common Lisp `(defun bin-search (obj vec)` để giải quyết vấn đề sau:  \nTìm kiếm nhị phân cho 'obj' trong vector đã sắp xếp 'vec'.  \nTrả về 't' nếu 'obj' được tìm thấy, 'nil' nếu không.  \nVí dụ:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt"
    },
    "instruction_bertscore": {
      "es": "0.9873194364747327",
      "arb": "0.9913373318223064",
      "sw": "0.97633259420855",
      "tr": "0.9391577266155844",
      "vi": "0.9814008470110361"
    },
    "level": "middle",
    "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)",
    "entry_point": "bin-search",
    "signature": "(defun bin-search (obj vec)",
    "docstring": {
      "es": "Búsqueda binaria de 'obj' en el vector ordenado 'vec'.  \nDevuelve 't' si se encuentra 'obj', 'nil' de lo contrario.  \nEjemplo:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "arb": "البحث الثنائي عن 'obj' في المتجه المرتب 'vec'.  \nيعيد 't' إذا تم العثور على 'obj'، و'nil' خلاف ذلك.  \nمثال:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "sw": "Utafutaji wa binary kwa 'obj' katika vekta iliyopangwa 'vec'.  \nInarudisha 't' ikiwa 'obj' imepatikana, 'nil' vinginevyo.  \nMfano:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "tr": "Sıralı vektör 'vec' içinde 'obj' için ikili arama.\n'obj' bulunursa 't', aksi takdirde 'nil' döner.\nÖrnek:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "vi": "Tìm kiếm nhị phân cho 'obj' trong vector đã sắp xếp 'vec'.  \nTrả về 't' nếu 'obj' được tìm thấy, 'nil' nếu không.  \nVí dụ:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt"
    },
    "docstring_bertscore": {
      "es": "0.9936078757079163",
      "arb": "0.9856620645753776",
      "sw": "0.9936078757079163",
      "tr": "0.9631284409988747",
      "vi": "0.970058456362801"
    }
  },
  {
    "task_id": "Common Lisp/3",
    "prompt": {
      "es": "(defun parse-date (date-str)\n\"Analiza una cadena de fecha en el formato 'DD MMM YYYY' y devuelve una lista (día mes año).\"\n;; Ejemplo:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "arb": "(defun parse-date (date-str)\n\"تحليل سلسلة تاريخ بالتنسيق 'DD MMM YYYY' وإرجاع قائمة (اليوم الشهر السنة).\"\n;; مثال:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "sw": "(defun parse-date (date-str)\n\"Panga tarehe kutoka kwa kamba ya tarehe katika muundo 'DD MMM YYYY' na rudisha orodha (siku mwezi mwaka).\"\n;; Mfano:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "tr": "(defun parse-date (date-str)\n\"Tarihi 'GG AAA YYYY' formatında bir tarih dizesi olarak ayrıştır ve bir liste (gün ay yıl) döndür.\"\n;; Örnek:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "vi": "(defun parse-date (date-str)\n\"Phân tích một chuỗi ngày tháng theo định dạng 'DD MMM YYYY' và trả về một danh sách (ngày tháng năm).\"\n;; Ví dụ:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980"
    },
    "prompt_bertscore": {
      "es": "0.9794044130512545",
      "arb": "0.999999801369619",
      "sw": "0.9826538074546043",
      "tr": "0.9810413260213631",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun parse-date (date-str)` para resolver el siguiente problema:\n\"Analizar una cadena de fecha en el formato 'DD MMM YYYY' y devolver una lista (día mes año).\"\nEjemplo:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "arb": "اكتب دالة Common Lisp `(defun parse-date (date-str)` لحل المشكلة التالية:\n\"تحليل سلسلة تاريخ بالتنسيق 'DD MMM YYYY' وإرجاع قائمة (اليوم الشهر السنة).\"\nمثال:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "sw": "Andika kazi ya Common Lisp `(defun parse-date (date-str)` kutatua tatizo lifuatalo:  \n\"Changanua kamba ya tarehe katika muundo 'DD MMM YYYY' na rudisha orodha (siku mwezi mwaka).\"  \nMfano:  \n>>> parse-date \"16 Aug 1980\"  \n16 8 1980",
      "tr": "Bir Common Lisp fonksiyonu `(defun parse-date (date-str)` yazın:\n\"Bir tarih dizesini 'DD MMM YYYY' formatında ayrıştırın ve bir liste (gün ay yıl) döndürün.\"\nÖrnek:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "vi": "Viết một hàm Common Lisp `(defun parse-date (date-str)` để giải quyết vấn đề sau:\n\"Phân tích một chuỗi ngày tháng theo định dạng 'DD MMM YYYY' và trả về một danh sách (ngày tháng năm).\"\nVí dụ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9609693287570255",
      "vi": "1"
    },
    "level": "hard",
    "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)",
    "entry_point": "parse-date",
    "signature": "(defun parse-date (date-str)",
    "docstring": {
      "es": "\"Analizar una cadena de fecha en el formato 'DD MMM YYYY' y devolver una lista (día mes año).\"\nEjemplo:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "arb": "\"تحليل سلسلة تاريخ بالتنسيق 'DD MMM YYYY' وإرجاع قائمة (يوم شهر سنة).\"\nمثال:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "sw": "\"Pambanua kamba ya tarehe katika muundo 'DD MMM YYYY' na rudisha orodha (siku mwezi mwaka).\"\nMfano:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "tr": "\"Tarih dizesini 'GG AAA YYYY' formatında ayrıştır ve bir liste (gün ay yıl) olarak döndür.\"\nÖrnek:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "vi": "\"Phân tích một chuỗi ngày tháng theo định dạng 'DD MMM YYYY' và trả về một danh sách (ngày tháng năm).\"\nVí dụ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980"
    },
    "docstring_bertscore": {
      "es": "0.9749203321993919",
      "arb": "1",
      "sw": "0.8414979216936851",
      "tr": "0.9687236602022465",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/4",
    "prompt": {
      "es": "(defun fourth-element (lst)\n;; usar car y cdr para devolver el cuarto elemento en la lista\n;; Ejemplo:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "arb": "(defun fourth-element (lst)\n;; استخدم car و cdr لإرجاع العنصر الرابع في القائمة\n;; مثال:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "sw": "(defun fourth-element (lst)\n;; tumia car na cdr kurudisha kipengele cha nne katika orodha\n;; Mfano:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "tr": "(defun fourth-element (lst)\n;; car ve cdr kullanarak listedeki dördüncü öğeyi döndür\n;; Örnek:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "vi": "(defun fourth-element (lst)\n;; sử dụng car và cdr để trả về phần tử thứ tư trong danh sách\n;; Ví dụ:\n;; >>> fourth-element '(a b c d e f)\n;; 'd"
    },
    "prompt_bertscore": {
      "es": "0.9862631201083892",
      "arb": "0.9845106042565184",
      "sw": "0.9862631201083892",
      "tr": "0.9698395656829005",
      "vi": "0.9862631201083892"
    },
    "canonical_solution": "(car (cdr (cdr (cdr lst)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun fourth-element (lst)` para resolver el siguiente problema:  \nutiliza car y cdr para devolver el cuarto elemento en la lista  \nEjemplo:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "arb": "اكتب دالة Common Lisp `(defun fourth-element (lst)` لحل المشكلة التالية:  \nاستخدم car و cdr لإرجاع العنصر الرابع في القائمة  \nمثال:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "sw": "Andika kazi ya Common Lisp `(defun fourth-element (lst)` kutatua tatizo lifuatalo:  \ntumia car na cdr kurudisha kipengele cha nne katika orodha  \nMfano:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "tr": "Bir Common Lisp fonksiyonu `(defun fourth-element (lst)` yazın: \ncar ve cdr kullanarak listedeki dördüncü elemanı döndürün\nÖrnek:\n>>> fourth-element '(a b c d e f)\n'd",
      "vi": "Viết một hàm Common Lisp `(defun fourth-element (lst)` để giải quyết vấn đề sau:\nsử dụng car và cdr để trả về phần tử thứ tư trong danh sách\nVí dụ:\n>>> fourth-element '(a b c d e f)\n'd"
    },
    "instruction_bertscore": {
      "es": "0.9945640823622182",
      "arb": "0.992518983959083",
      "sw": "0.9945640823622182",
      "tr": "0.9481149636483527",
      "vi": "0.9945640823622182"
    },
    "level": "easy",
    "test": "(defun check-fourth-element ()\n(assert (equal (fourth-element '(a b c d e f)) 'd))\n(assert (equal (fourth-element '(1 2 3 4 5 6)) 4))\n(assert (equal (fourth-element '(\"one\" \"two\" \"three\" \"four\" \"five\")) \"four\")))\n\n(check-fourth-element)",
    "entry_point": "fourth-element",
    "signature": "(defun fourth-element (lst)",
    "docstring": {
      "es": "usar car y cdr para devolver el cuarto elemento en la lista  \nEjemplo:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "arb": "استخدم `car` و `cdr` لإرجاع العنصر الرابع في القائمة  \nمثال:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "sw": "tumia car na cdr kurudisha kipengele cha nne kwenye orodha  \nMfano:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "tr": "use car ve cdr kullanarak listedeki dördüncü öğeyi döndürün\nÖrnek:\n>>> fourth-element '(a b c d e f)\n'd",
      "vi": "sử dụng car và cdr để trả về phần tử thứ tư trong danh sách  \nVí dụ:  \n>>> fourth-element '(a b c d e f)  \n'd"
    },
    "docstring_bertscore": {
      "es": "0.9929210118502976",
      "arb": "0.9368182579877555",
      "sw": "0.9929210118502976",
      "tr": "0.9734794674153648",
      "vi": "0.9929210118502976"
    }
  },
  {
    "task_id": "Common Lisp/5",
    "prompt": {
      "es": "(defun count-a-in-list (lst)\n;; Calcular el número de veces que 'a' aparece en la lista.\n;; Ejemplo:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "arb": "(defun count-a-in-list (lst)\n;; حساب عدد المرات التي يظهر فيها 'a' في القائمة.\n;; مثال:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "sw": "(defun count-a-in-list (lst)\n;; Hesabu idadi ya mara 'a' inavyoonekana katika orodha.\n;; Mfano:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "tr": "(defun count-a-in-list (lst)\n;; Listede 'a' harfinin kaç kez göründüğünü hesapla.\n;; Örnek:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "vi": "(defun count-a-in-list (lst)\n;; Tính số lần 'a' xuất hiện trong danh sách.\n;; Ví dụ:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3"
    },
    "prompt_bertscore": {
      "es": "0.9692977020034373",
      "arb": "0.9586517094711104",
      "sw": "0.9586517094711104",
      "tr": "0.952278256434844",
      "vi": "0.9692977020034373"
    },
    "canonical_solution": "(loop for item in lst\ncounting (eql item 'a)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-a-in-list (lst)` para resolver el siguiente problema:  \nCalcular el número de veces que 'a' aparece en la lista.  \nEjemplo:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "arb": "اكتب دالة بلغة Common Lisp `(defun count-a-in-list (lst)` لحل المشكلة التالية:\nاحسب عدد المرات التي يظهر فيها 'a' في القائمة.\nمثال:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "sw": "Andika kazi ya Common Lisp `(defun count-a-in-list (lst)` kutatua tatizo lifuatalo:\nHesabu idadi ya mara 'a' inavyoonekana kwenye orodha.\nMfano:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "tr": "Bir Common Lisp fonksiyonu `(defun count-a-in-list (lst)` yazın: \nAşağıdaki problemi çözmek için: \nListedeki 'a' harfinin kaç kez göründüğünü hesaplayın. \nÖrnek: \n>>> count-a-in-list '(a b c d a e f a) \n3",
      "vi": "Viết một hàm Common Lisp `(defun count-a-in-list (lst)` để giải quyết vấn đề sau:\nTính số lần xuất hiện của 'a' trong danh sách.\nVí dụ:\n>>> count-a-in-list '(a b c d a e f a)\n3"
    },
    "instruction_bertscore": {
      "es": "0.9745115508752221",
      "arb": "0.9608964314071857",
      "sw": "0.9652500120987084",
      "tr": "0.9524576196689185",
      "vi": "0.9517926051532136"
    },
    "level": "easy",
    "test": "(defun check-count-a-in-list ()\n(assert (equal (count-a-in-list '(a b c d a e f a)) 3))\n(assert (equal (count-a-in-list '(1 2 3 4 5)) 0))\n(assert (equal (count-a-in-list '(a a a a)) 4))\n(assert (equal (count-a-in-list '(b c d)) 0)))\n\n(check-count-a-in-list)",
    "entry_point": "count-a-in-list",
    "signature": "(defun count-a-in-list (lst)",
    "docstring": {
      "es": "Calcular el número de veces que aparece 'a' en la lista.\nEjemplo:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "arb": "احسب عدد المرات التي يظهر فيها 'a' في القائمة.\nمثال:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "sw": "Hesabu idadi ya mara 'a' inavyoonekana kwenye orodha. Mfano:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "tr": "Listedeki 'a' harfinin kaç kez göründüğünü hesaplayın.\nÖrnek:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "vi": "Tính số lần 'a' xuất hiện trong danh sách.  \nVí dụ:  \n>>> count-a-in-list '(a b c d a e f a)  \n3"
    },
    "docstring_bertscore": {
      "es": "0.9596762449764884",
      "arb": "0.9596762449764884",
      "sw": "0.9374385806677275",
      "tr": "0.9075905919399959",
      "vi": "0.9374385806677275"
    }
  },
  {
    "task_id": "Common Lisp/6",
    "prompt": {
      "es": "(defun ordered-union (list1 list2)\n;; Escribe una versión de unión que preserve el orden de los elementos en las listas originales:\n;; Ejemplo:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "arb": "(defun ordered-union (list1 list2)\n;; اكتب نسخة من union تحافظ على ترتيب العناصر في القوائم الأصلية:\n;; مثال:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "sw": "(defun ordered-union (list1 list2)\n;; Andika toleo la union ambalo linahifadhi mpangilio wa vipengele katika orodha za asili:\n;; Mfano:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "tr": "(defun ordered-union (list1 list2)\n;; Orijinal listelerdeki elemanların sırasını koruyan bir birleşim versiyonu yazın:\n;; Örnek:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "vi": "(defun ordered-union (list1 list2)\n;; Viết một phiên bản của union mà bảo toàn thứ tự của các phần tử trong các danh sách gốc:\n;; Ví dụ:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6"
    },
    "prompt_bertscore": {
      "es": "0.9952356516804972",
      "arb": "0.9930527037929238",
      "sw": "0.9952356516804972",
      "tr": "0.9952356516804972",
      "vi": "0.9952356516804972"
    },
    "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun ordered-union (list1 list2)` para resolver el siguiente problema:\nEscribe una versión de unión que preserve el orden de los elementos en las listas originales:\nEjemplo:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "arb": "اكتب دالة Common Lisp `(defun ordered-union (list1 list2)` لحل المشكلة التالية:\nاكتب نسخة من union تحافظ على ترتيب العناصر في القوائم الأصلية:\nمثال:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "sw": "Andika kazi ya Common Lisp `(defun ordered-union (list1 list2)` kutatua tatizo lifuatalo:\nAndika toleo la union ambalo linahifadhi mpangilio wa vipengele katika orodha za asili:\nMfano:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "tr": "Bir Common Lisp fonksiyonu `(defun ordered-union (list1 list2)` yazın:\nOrijinal listelerdeki elemanların sırasını koruyan bir union versiyonu yazın:\nÖrnek:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "vi": "Viết một hàm Common Lisp `(defun ordered-union (list1 list2)` để giải quyết vấn đề sau:\nViết một phiên bản của union mà bảo toàn thứ tự của các phần tử trong các danh sách gốc:\nVí dụ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6"
    },
    "instruction_bertscore": {
      "es": "0.9958752415074296",
      "arb": "0.9958752415074296",
      "sw": "0.9958752415074296",
      "tr": "0.9622957824415765",
      "vi": "0.9958752415074296"
    },
    "level": "easy",
    "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)",
    "entry_point": "ordered-union",
    "signature": "(defun ordered-union (list1 list2)",
    "docstring": {
      "es": "Escribe una versión de unión que preserve el orden de los elementos en las listas originales:\nEjemplo:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "arb": "اكتب نسخة من union تحافظ على ترتيب العناصر في القوائم الأصلية:\nمثال:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "sw": "Andika toleo la union ambalo linahifadhi mpangilio wa vipengele katika orodha za awali:\nMfano:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "tr": "Orijinal listelerdeki elemanların sırasını koruyan bir union sürümü yazın:\nÖrnek:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "vi": "Viết một phiên bản của union mà bảo toàn thứ tự của các phần tử trong các danh sách gốc:\nVí dụ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6"
    },
    "docstring_bertscore": {
      "es": "0.9951206446898779",
      "arb": "0.9951206446898779",
      "sw": "0.9951206446898779",
      "tr": "0.9951206446898779",
      "vi": "0.9951206446898779"
    }
  },
  {
    "task_id": "Common Lisp/7",
    "prompt": {
      "es": "(defun occurrences (lst)\n;; toma una lista y devuelve una lista que indica el número de veces que aparece cada elemento (eql), ordenada desde el elemento más común hasta el menos común\n;; Ejemplo:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "arb": "(defun occurrences (lst)\n;; يأخذ قائمة ويعيد قائمة تشير إلى عدد المرات التي يظهر فيها كل عنصر (eql)، مرتبة من العنصر الأكثر شيوعًا إلى الأقل شيوعًا\n;; مثال:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "sw": "(defun occurrences (lst)\n;; inachukua orodha na kurudisha orodha inayoonyesha idadi ya mara kila kipengele (eql) kinavyoonekana, imepangwa kutoka kipengele kinachojitokeza zaidi hadi kile kinachojitokeza kidogo\n;; Mfano:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "tr": "(defun occurrences (lst)\n;; bir liste alır ve her bir (eql) elemanın kaç kez göründüğünü belirten bir liste döndürür, en yaygın elemandan en az yaygın olana doğru sıralanmış\n;; Örnek:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "vi": "(defun occurrences (lst)\n;; nhận một danh sách và trả về một danh sách cho biết số lần mỗi phần tử (eql) xuất hiện, được sắp xếp từ phần tử phổ biến nhất đến ít phổ biến nhất\n;; Ví dụ:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "prompt_bertscore": {
      "es": "0.9793996459221097",
      "arb": "0.9809821341678147",
      "sw": "0.9741411052145921",
      "tr": "0.9892411854112453",
      "vi": "0.9825733621502851"
    },
    "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun occurrences (lst)` para resolver el siguiente problema:  \ntoma una lista y devuelve una lista que indica el número de veces que aparece cada elemento (eql), ordenada desde el elemento más común hasta el menos común  \nEjemplo:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "arb": "اكتب دالة Common Lisp `(defun occurrences (lst)` لحل المشكلة التالية: تأخذ قائمة وتعيد قائمة تشير إلى عدد المرات التي يظهر فيها كل عنصر (eql)، مرتبة من العنصر الأكثر شيوعًا إلى الأقل شيوعًا\nمثال:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "sw": "Andika kazi ya Common Lisp `(defun occurrences (lst)` kutatua tatizo lifuatalo: inachukua orodha na kurudisha orodha inayoonyesha idadi ya mara kila kipengele (eql) kinavyoonekana, ikipangwa kutoka kipengele kinachotokea mara nyingi hadi kile kinachotokea mara chache zaidi.\nMfano:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "tr": "Bir Common Lisp fonksiyonu `(defun occurrences (lst)` yazın: aşağıdaki problemi çözmek için\nbir liste alır ve her bir (eql) elemanın kaç kez göründüğünü belirten bir liste döndürür, en yaygın elemandan en az yaygın elemana doğru sıralanmış olarak\nÖrnek:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "vi": "Viết một hàm Common Lisp `(defun occurrences (lst)` để giải quyết vấn đề sau:  \nnhận một danh sách và trả về một danh sách chỉ ra số lần mỗi phần tử (eql) xuất hiện, được sắp xếp từ phần tử phổ biến nhất đến ít phổ biến nhất  \nVí dụ:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "instruction_bertscore": {
      "es": "0.9828242323215322",
      "arb": "0.9674460695914301",
      "sw": "0.9506989462752355",
      "tr": "0.9778481440158462",
      "vi": "0.9730879669343451"
    },
    "level": "easy",
    "test": "(defun check-occurrences ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)",
    "entry_point": "occurrences",
    "signature": "(defun occurrences (lst)",
    "docstring": {
      "es": "toma una lista y devuelve una lista que indica el número de veces que aparece cada elemento (eql), ordenado del elemento más común al menos común  \nEjemplo:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "arb": "يأخذ قائمة ويعيد قائمة تشير إلى عدد المرات التي يظهر فيها كل عنصر (eql)، مرتبة من العنصر الأكثر شيوعًا إلى الأقل شيوعًا  \nمثال:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "sw": "huchukua orodha na kurudisha orodha inayoonyesha idadi ya mara kila kipengele (eql) kinavyoonekana, kimepangwa kutoka kipengele kinachotokea mara nyingi zaidi hadi kinachotokea mara chache zaidi\nMfano:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "tr": "bir liste alır ve her bir (eşit) öğenin kaç kez göründüğünü belirten bir liste döndürür, en yaygın öğeden en az yaygın olana doğru sıralanır\nÖrnek:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "vi": "nhận một danh sách và trả về một danh sách cho biết số lần mỗi phần tử (eql) xuất hiện, được sắp xếp từ phần tử phổ biến nhất đến ít phổ biến nhất  \nVí dụ:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)  "
    },
    "docstring_bertscore": {
      "es": "0.9827187595892026",
      "arb": "0.9817387172891765",
      "sw": "0.9570982212610366",
      "tr": "0.9445040619515195",
      "vi": "0.975103469410706"
    }
  },
  {
    "task_id": "Common Lisp/8",
    "prompt": {
      "es": "(defun list-to-dots (lst)\n;; toma una lista y la imprime en notación de puntos\n;; Ejemplo:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "arb": "(defun list-to-dots (lst)\n;; تأخذ قائمة وتطبعها بصيغة النقاط\n;; مثال:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "sw": "(defun list-to-dots (lst)\n;; inachukua orodha na kuichapisha katika noti ya nukta\n;; Mfano:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "tr": "(defun list-to-dots (lst)\n;; bir liste alır ve nokta gösterimiyle yazdırır\n;; Örnek:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "vi": "(defun list-to-dots (lst)\n;; nhận một danh sách và in nó dưới dạng ký hiệu dấu chấm\n;; Ví dụ:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))"
    },
    "prompt_bertscore": {
      "es": "0.9785060078378337",
      "arb": "0.9700725591198545",
      "sw": "0.9785060078378337",
      "tr": "0.9785060078378337",
      "vi": "0.9666443973735733"
    },
    "canonical_solution": "(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun list-to-dots (lst)` para resolver el siguiente problema:\ntoma una lista y la imprime en notación de puntos\nEjemplo:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "arb": "اكتب دالة Common Lisp `(defun list-to-dots (lst)` لحل المشكلة التالية:\nتأخذ قائمة وتطبعها بصيغة النقاط\nمثال:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "sw": "Andika kazi ya Common Lisp `(defun list-to-dots (lst)` kutatua tatizo lifuatalo:\ninachukua orodha na kuichapisha katika noti ya nukta\nMfano:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "tr": "Bir Common Lisp fonksiyonu `(defun list-to-dots (lst)` yazın:\nbir liste alır ve onu nokta gösteriminde yazdırır\nÖrnek:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "vi": "Viết một hàm Common Lisp `(defun list-to-dots (lst)` để giải quyết vấn đề sau:  \nnhận một danh sách và in nó theo ký hiệu dấu chấm  \nVí dụ:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))"
    },
    "instruction_bertscore": {
      "es": "0.9810206684617354",
      "arb": "0.9749276815234902",
      "sw": "0.9751851064973114",
      "tr": "0.9476366616908207",
      "vi": "0.9690776195412507"
    },
    "level": "easy",
    "test": "(defun check-list-to-dots ()\n;; 测试 'list-to-dots' 函数。\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check-list-to-dots)",
    "entry_point": "list-to-dots",
    "signature": "(defun list-to-dots (lst)",
    "docstring": {
      "es": "toma una lista y la imprime en notación de puntos  \nEjemplo:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "arb": "يأخذ قائمة ويطبعها بتدوين النقاط  \nمثال:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "sw": "inachukua orodha na kuichapisha katika noti ya nukta\nMfano:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "tr": "takes a list and prints it in dot natation  \nBir liste alır ve nokta gösteriminde yazdırır\n\nExample:  \nÖrnek:\n\n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "vi": "takes a list and prints it in dot natation  \nVí dụ:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))"
    },
    "docstring_bertscore": {
      "es": "0.9710319438602529",
      "arb": "0.9693000855680097",
      "sw": "0.9624103921714336",
      "tr": "0.9171468982019654",
      "vi": "0.9710319438602529"
    }
  },
  {
    "task_id": "Common Lisp/9",
    "prompt": {
      "es": "(defun contains-nil? (lst)\n;; Verifica si la lista contiene elementos nil\n;; Ejemplo:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "arb": "(defun contains-nil? (lst)\n;; تحقق مما إذا كانت القائمة تحتوي على عناصر nil\n;; مثال:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "sw": "(defun contains-nil? (lst)\n;; Angalia kama orodha ina vipengele vya nil\n;; Mfano:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "tr": "(defun contains-nil? (lst)\n;; Listenin nil öğeleri içerip içermediğini kontrol et\n;; Örnek:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "vi": "(defun contains-nil? (lst)\n;; Kiểm tra xem danh sách có chứa phần tử nil không\n;; Ví dụ:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9950767473756693",
      "arb": "0.9999996027392379",
      "sw": "0.9999996027392379",
      "tr": "0.9999996027392379",
      "vi": "0.9838267198546152"
    },
    "canonical_solution": "(loop for item in lst\nthereis (null item)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun contains-nil? (lst)` para resolver el siguiente problema:\nVerificar si la lista contiene elementos nil\nEjemplo:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "arb": "اكتب دالة بلغة Common Lisp `(defun contains-nil? (lst)` لحل المشكلة التالية:\nتحقق مما إذا كانت القائمة تحتوي على عناصر nil\nمثال:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "sw": "Andika kazi ya Common Lisp `(defun contains-nil? (lst)` kutatua tatizo lifuatalo:  \nAngalia kama orodha ina vipengele vya nil  \nMfano:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "tr": "Bir Common Lisp fonksiyonu `(defun contains-nil? (lst)` yazın:\nListenin nil elemanlar içerip içermediğini kontrol edin\nÖrnek:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "vi": "Viết một hàm Common Lisp `(defun contains-nil? (lst)` để giải quyết vấn đề sau:  \nKiểm tra xem danh sách có chứa các phần tử nil hay không  \nVí dụ:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt  "
    },
    "instruction_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9919161407526421",
      "sw": "0.9999996027392379",
      "tr": "0.9557642196220063",
      "vi": "0.9929194228072493"
    },
    "level": "easy",
    "test": "(defun check-contains-nil? ()\n(assert (equal (contains-nil? '(1 2 3 nil 4 5)) t))\n(assert (equal (contains-nil? '(1 2 3 4 5)) nil))\n(assert (equal (contains-nil? '(nil 1 2 3)) t))\n(assert (equal (contains-nil? '()) nil))\n(assert (equal (contains-nil? '(nil)) t)))\n\n(check-contains-nil?)",
    "entry_point": "contains-nil?",
    "signature": "(defun contains-nil? (lst)",
    "docstring": {
      "es": "Verificar si la lista contiene elementos nulos  \nEjemplo:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "arb": "تحقق مما إذا كانت القائمة تحتوي على عناصر nil  \nمثال:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "sw": "Angalia kama orodha ina vipengele vya nil  \nMfano:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "tr": "Nil öğeler içerip içermediğini kontrol et  \nÖrnek:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "vi": "Kiểm tra xem danh sách có chứa phần tử nil không  \nVí dụ:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt"
    },
    "docstring_bertscore": {
      "es": "0.9839991310253535",
      "arb": "0.9999996027392379",
      "sw": "0.9999996027392379",
      "tr": "0.9323451018068498",
      "vi": "0.9842603299764144"
    }
  },
  {
    "task_id": "Common Lisp/10",
    "prompt": {
      "es": "(defun index-of-element (element lst)\n;; Devuelve el índice del elemento en la lista, o nil si el elemento no está en la lista.\n;; Ejemplo:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "arb": "(defun index-of-element (element lst)\n;; يُعيد فهرس العنصر في القائمة، أو nil إذا لم يكن العنصر في القائمة.\n;; مثال:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "sw": "(defun index-of-element (element lst)\n;; Inarudisha fahirisi ya kipengele katika orodha, au nil ikiwa kipengele hakipo kwenye orodha.\n;; Mfano:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "tr": "(defun index-of-element (element lst)\n;; Listenin içindeki elemanın indeksini döndürür veya eleman listede yoksa nil döndürür.\n;; Örnek:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "vi": "(defun index-of-element (element lst)\n;; Trả về chỉ số của phần tử trong danh sách, hoặc nil nếu phần tử không có trong danh sách.\n;; Ví dụ:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9853704751760184",
      "vi": "1"
    },
    "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun index-of-element (element lst)` para resolver el siguiente problema:\nDevuelve el índice del elemento en la lista, o nil si el elemento no está en la lista.\nEjemplo:\n>>> index-of-element 'a '(a b c d e)\n0",
      "arb": "اكتب دالة بلغة Lisp العامة `(defun index-of-element (element lst)` لحل المشكلة التالية:\nإرجاع فهرس العنصر في القائمة، أو nil إذا لم يكن العنصر موجودًا في القائمة.\nمثال:\n>>> index-of-element 'a '(a b c d e)\n0",
      "sw": "Andika kazi ya Common Lisp `(defun index-of-element (element lst)` kutatua tatizo lifuatalo:\nRudisha fahirisi ya kipengele kwenye orodha, au nil ikiwa kipengele hakipo kwenye orodha.\nMfano:\n>>> index-of-element 'a '(a b c d e)\n0",
      "tr": "Common Lisp dilinde `(defun index-of-element (element lst)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\nListenin içindeki elemanın indeksini döndürür veya eleman listede yoksa nil döndürür.\nÖrnek:\n>>> index-of-element 'a '(a b c d e)\n0",
      "vi": "Viết một hàm Common Lisp `(defun index-of-element (element lst)` để giải quyết vấn đề sau:\nTrả về chỉ số của phần tử trong danh sách, hoặc nil nếu phần tử không có trong danh sách.\nVí dụ:\n>>> index-of-element 'a '(a b c d e)\n0"
    },
    "instruction_bertscore": {
      "es": "0.9972648596531496",
      "arb": "0.9812310180352514",
      "sw": "0.9972648596531496",
      "tr": "0.9815377033435693",
      "vi": "0.9972648596531496"
    },
    "level": "easy",
    "test": "(defun check-index-of-element ()\n;; 测试 'index-of-element' 函数。\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)",
    "entry_point": "index-of-element",
    "signature": "(defun index-of-element (element lst)",
    "docstring": {
      "es": "Devuelve el índice del elemento en la lista, o nil si el elemento no está en la lista.\nEjemplo:\n>>> index-of-element 'a '(a b c d e)\n0",
      "arb": "يعيد فهرس العنصر في القائمة، أو nil إذا لم يكن العنصر موجودًا في القائمة.\nمثال:\n>>> index-of-element 'a '(a b c d e)\n0",
      "sw": "Inarudisha faharasa ya kipengele katika orodha, au nil ikiwa kipengele hakipo katika orodha.\nMfano:\n>>> index-of-element 'a '(a b c d e)\n0",
      "tr": "Listenin içindeki öğenin indeksini döndürür veya öğe listede yoksa nil döndürür.\nÖrnek:\n>>> index-of-element 'a '(a b c d e)\n0",
      "vi": "Trả về chỉ số của phần tử trong danh sách, hoặc nil nếu phần tử không có trong danh sách.\nVí dụ:\n>>> index-of-element 'a '(a b c d e)\n0"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9904909677687168",
      "sw": "0.9801455030028957",
      "tr": "0.9649145253851404",
      "vi": "0.9940883625996396"
    }
  },
  {
    "task_id": "Common Lisp/11",
    "prompt": {
      "es": "(defun contains-list? (lst)\n;; Verificar si la lista contiene un elemento de lista.\n;; Ejemplo:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "arb": "(defun contains-list? (lst)\n;; تحقق مما إذا كانت القائمة تحتوي على عنصر قائمة.\n;; مثال:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "sw": "(defun contains-list? (lst)\n;; Angalia kama orodha ina kipengele cha orodha.\n;; Mfano:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "tr": "(defun contains-list? (lst)\n;; Listenin bir liste elemanı içerip içermediğini kontrol et.\n;; Örnek:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "vi": "(defun contains-list? (lst)\n;; Kiểm tra xem danh sách có chứa phần tử danh sách hay không.\n;; Ví dụ:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9707582311951869",
      "arb": "0.9707582311951869",
      "sw": "0.9707582311951869",
      "tr": "0.9690188249484644",
      "vi": "0.9707582311951869"
    },
    "canonical_solution": "(loop for item in lst\nthereis (listp item)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun contains-list? (lst)` para resolver el siguiente problema:\nVerifica si la lista contiene un elemento que es una lista.\nEjemplo:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "arb": "اكتب دالة بلغة Lisp الشائعة `(defun contains-list? (lst)` لحل المشكلة التالية:\nتحقق مما إذا كانت القائمة تحتوي على عنصر قائمة.\nمثال:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "sw": "Andika kazi ya Common Lisp `(defun contains-list? (lst)` kutatua tatizo lifuatalo:\nAngalia kama orodha ina kipengele cha orodha.\nMfano:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "tr": "Bir Common Lisp fonksiyonu `(defun contains-list? (lst)` yazın: \nAşağıdaki problemi çözmek için:\nListenin bir liste elemanı içerip içermediğini kontrol edin.\nÖrnek:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "vi": "Viết một hàm Common Lisp `(defun contains-list? (lst)` để giải quyết vấn đề sau:  \nKiểm tra xem danh sách có chứa phần tử là một danh sách không.  \nVí dụ:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt  "
    },
    "instruction_bertscore": {
      "es": "0.9594410666053431",
      "arb": "0.9684280981952665",
      "sw": "0.9741917559617559",
      "tr": "0.9664882738940799",
      "vi": "0.9594410666053431"
    },
    "level": "easy",
    "test": "(defun check-contains-list? ()\n;; 测试 'contains-list?' 函数。\n(assert (equal (contains-list? '(1 2 (3 4) 5)) t))\n(assert (equal (contains-list? '(1 2 3 4 5)) nil))\n(assert (equal (contains-list? '((1 2) 3 4 5)) t))\n(assert (equal (contains-list? '()) nil))\n(assert (equal (contains-list? '(\"string\" 123 (a b))) t)))\n\n(check-contains-list?)",
    "entry_point": "contains-list?",
    "signature": "(defun contains-list? (lst)",
    "docstring": {
      "es": "Verificar si la lista contiene un elemento de lista.  \nEjemplo:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt",
      "arb": "تحقق مما إذا كانت القائمة تحتوي على عنصر قائمة.\nمثال:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "sw": "Angalia kama orodha ina kipengele cha orodha.  \nMfano:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt",
      "tr": "Listenin bir liste öğesi içerip içermediğini kontrol edin.\nÖrnek:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "vi": "Kiểm tra xem danh sách có chứa một phần tử danh sách hay không.\nVí dụ:\n>>> contains-list? '(1 2 (3 4) 5)\nt"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9613834731014832",
      "tr": "0.9942943423047729",
      "vi": "0.9613834731014832"
    }
  },
  {
    "task_id": "Common Lisp/12",
    "prompt": {
      "es": "(defun sum-non-nil-elements (lst)\n;; Calcular la suma de todos los elementos no nulos en la lista.\n;; Ejemplo:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "arb": "(defun sum-non-nil-elements (lst)\n;; حساب مجموع جميع العناصر غير nil في القائمة.\n;; مثال:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "sw": "(defun sum-non-nil-elements (lst)\n;; Hesabu jumla ya vipengele vyote ambavyo si nil katika orodha.\n;; Mfano:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "tr": "(defun sum-non-nil-elements (lst)\n;; Listedeki nil olmayan tüm elemanların toplamını hesaplayın.\n;; Örnek:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "vi": "(defun sum-non-nil-elements (lst)\n;; Tính tổng của tất cả các phần tử không phải nil trong danh sách.\n;; Ví dụ:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12"
    },
    "prompt_bertscore": {
      "es": "0.9900829809660712",
      "arb": "0.9900829809660712",
      "sw": "0.9742531327494958",
      "tr": "0.9900829809660712",
      "vi": "0.9900829809660712"
    },
    "canonical_solution": "(loop for item in lst\nwhen (not (null item))\nsum item))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun sum-non-nil-elements (lst)` para resolver el siguiente problema:\nCalcular la suma de todos los elementos no nil en la lista.\nEjemplo:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "arb": "اكتب دالة بلغة Common Lisp `(defun sum-non-nil-elements (lst)` لحل المشكلة التالية:\nاحسب مجموع جميع العناصر غير nil في القائمة.\nمثال:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "sw": "Andika kazi ya Common Lisp `(defun sum-non-nil-elements (lst)` kutatua tatizo lifuatalo:  \nHesabu jumla ya vipengele vyote ambavyo si nil katika orodha.  \nMfano:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "tr": "Bir Common Lisp fonksiyonu `(defun sum-non-nil-elements (lst)` yazın:\nListedeki nil olmayan tüm elemanların toplamını hesaplayın.\nÖrnek:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "vi": "Viết một hàm Common Lisp `(defun sum-non-nil-elements (lst)` để giải quyết vấn đề sau:  \nTính tổng của tất cả các phần tử không phải nil trong danh sách.  \nVí dụ:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12"
    },
    "instruction_bertscore": {
      "es": "0.9924013947735103",
      "arb": "0.9821250533802893",
      "sw": "0.9785330215696545",
      "tr": "0.9593935939442757",
      "vi": "0.9924013947735103"
    },
    "level": "easy",
    "test": "(defun check-sum-non-nil-elements ()\n(assert (equal (sum-non-nil-elements '(1 2 nil 4 5)) 12))\n(assert (equal (sum-non-nil-elements '(nil nil nil)) 0))\n(assert (equal (sum-non-nil-elements '(3 4 nil 6)) 13))\n(assert (equal (sum-non-nil-elements '()) 0))\n(assert (equal (sum-non-nil-elements '(nil 7 8)) 15)))\n\n(check-sum-non-nil-elements)",
    "entry_point": "sum-non-nil-elements",
    "signature": "(defun sum-non-nil-elements (lst)",
    "docstring": {
      "es": "Calcular la suma de todos los elementos no nulos en la lista.\nEjemplo:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "arb": "احسب مجموع جميع العناصر غير الخالية في القائمة.\nمثال:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "sw": "Hesabu jumla ya vipengele vyote ambavyo si nil katika orodha. Mfano:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "tr": "Tüm nil olmayan elemanların listesindeki toplamını hesaplayın.\nÖrnek:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "vi": "Tính tổng của tất cả các phần tử không phải nil trong danh sách.  \nVí dụ:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12"
    },
    "docstring_bertscore": {
      "es": "0.9813462236562516",
      "arb": "0.9849612965910866",
      "sw": "0.9511005769056882",
      "tr": "0.9849612965910866",
      "vi": "0.9849612965910866"
    }
  },
  {
    "task_id": "Common Lisp/13",
    "prompt": {
      "es": "(defun conditional-square (x)\n;; Si x es un número entero positivo menor o igual a 5, devuelve x; de lo contrario, devuelve el cuadrado de x.\n;; Ejemplo:\n;; >>> conditional-square 3\n;; 3",
      "arb": "(defun conditional-square (x)\n;; إذا كان x عددًا صحيحًا موجبًا أقل من أو يساوي 5، أعد x؛ وإلا، أعد مربع x.\n;; مثال:\n;; >>> conditional-square 3\n;; 3",
      "sw": "(defun conditional-square (x)\n;; Ikiwa x ni nambari nzima chanya ndogo au sawa na 5, rudisha x; vinginevyo, rudisha mraba wa x.\n;; Mfano:\n;; >>> conditional-square 3\n;; 3",
      "tr": "(defun conditional-square (x)\n;; Eğer x 5'e eşit veya daha küçük pozitif bir tamsayı ise, x'i döndür; aksi takdirde, x'in karesini döndür.\n;; Örnek:\n;; >>> conditional-square 3\n;; 3",
      "vi": "(defun conditional-square (x)\n;; Nếu x là một số nguyên dương nhỏ hơn hoặc bằng 5, trả về x; ngược lại, trả về bình phương của x.\n;; Ví dụ:\n;; >>> conditional-square 3\n;; 3"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.9850538583486488",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun conditional-square (x)` para resolver el siguiente problema:\nSi x es un número entero positivo menor o igual a 5, devuelve x; de lo contrario, devuelve el cuadrado de x.\nEjemplo:\n>>> conditional-square 3\n3",
      "arb": "اكتب دالة Common Lisp `(defun conditional-square (x)` لحل المشكلة التالية:\nإذا كان x عددًا صحيحًا موجبًا أقل من أو يساوي 5، أعد x؛ وإلا، أعد مربع x.\nمثال:\n>>> conditional-square 3\n3",
      "sw": "Andika kazi ya Common Lisp `(defun conditional-square (x)` kutatua tatizo lifuatalo: Ikiwa x ni nambari nzima chanya ndogo au sawa na 5, rudisha x; vinginevyo, rudisha mraba wa x. Mfano: >>> conditional-square 3 3",
      "tr": "Bir Common Lisp fonksiyonu `(defun conditional-square (x)` yazın:\nEğer x, 5'e eşit veya daha küçük pozitif bir tam sayı ise, x'i döndürün; aksi takdirde, x'in karesini döndürün.\nÖrnek:\n>>> conditional-square 3\n3",
      "vi": "Viết một hàm Common Lisp `(defun conditional-square (x)` để giải quyết vấn đề sau:\nNếu x là một số nguyên dương nhỏ hơn hoặc bằng 5, trả về x; nếu không, trả về bình phương của x.\nVí dụ:\n>>> conditional-square 3\n3"
    },
    "instruction_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.9578752633116451",
      "vi": "0.999999801369619"
    },
    "level": "easy",
    "test": "(defun check-conditional-square ()\n;; 测试 'conditional-square' 函数。\n(assert (equal (conditional-square 3) 3))\n(assert (equal (conditional-square 5) 5))\n(assert (equal (conditional-square 6) 36))\n(assert (equal (conditional-square -3) 9))\n(assert (equal (conditional-square 2.5) 6.25)))\n\n(check-conditional-square)",
    "entry_point": "conditional-square",
    "signature": "(defun conditional-square (x)",
    "docstring": {
      "es": "Si x es un número entero positivo menor o igual a 5, devuelve x; de lo contrario, devuelve el cuadrado de x.\nEjemplo:\n>>> conditional-square 3\n3",
      "arb": "إذا كان x عددًا صحيحًا موجبًا أقل من أو يساوي 5، أعد x؛ وإلا، أعد مربع x.  \nمثال:  \n>>> conditional-square 3  \n3",
      "sw": "Ikiwa x ni nambari nzima chanya ndogo au sawa na 5, rudisha x; vinginevyo, rudisha mraba wa x.\nMfano:\n>>> conditional-square 3\n3",
      "tr": "Eğer x, 5'e eşit veya daha küçük pozitif bir tamsayı ise, x'i döndür; aksi takdirde, x'in karesini döndür.\nÖrnek:\n>>> conditional-square 3\n3",
      "vi": "Nếu x là một số nguyên dương nhỏ hơn hoặc bằng 5, trả về x; nếu không, trả về bình phương của x.  \nVí dụ:  \n>>> conditional-square 3  \n3  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9769618552556685",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/14",
    "prompt": {
      "es": "(defun lines-from-file (filename)\n;; Leer cada línea del archivo y devolverlas como una lista de cadenas.",
      "arb": "(defun lines-from-file (filename)\n;; قراءة كل سطر من الملف وإعادتها كقائمة من السلاسل النصية.",
      "sw": "(defun lines-from-file (filename)\n;; Soma kila mstari kutoka kwenye faili na urejeshe kama orodha ya mistari ya maandishi.",
      "tr": "(defun lines-from-file (filename)\n;; Dosyadan her satırı okuyun ve bunları bir dize listesi olarak döndürün.",
      "vi": "(defun lines-from-file (filename)\n;; Đọc từng dòng từ tệp và trả về chúng dưới dạng danh sách chuỗi."
    },
    "prompt_bertscore": {
      "es": "0.9849328924465985",
      "arb": "0.9798384204338157",
      "sw": "0.9425127923816448",
      "tr": "0.9849328924465985",
      "vi": "0.9849328924465985"
    },
    "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun lines-from-file (filename)` para resolver el siguiente problema:  \nLee cada línea del archivo y devuélvelas como una lista de cadenas.",
      "arb": "اكتب دالة Common Lisp `(defun lines-from-file (filename)` لحل المشكلة التالية:\nقراءة كل سطر من الملف وإعادتها كقائمة من السلاسل النصية.",
      "sw": "Andika kazi ya Common Lisp `(defun lines-from-file (filename)` kutatua tatizo lifuatalo: \nSoma kila mstari kutoka kwenye faili na urejeshe kama orodha ya mistari ya maandishi.",
      "tr": "Bir Common Lisp fonksiyonu `(defun lines-from-file (filename)` yazın: Aşağıdaki problemi çözmek için: Dosyadan her satırı okuyun ve bunları bir string listesi olarak döndürün.",
      "vi": "Viết một hàm Common Lisp `(defun lines-from-file (filename)` để giải quyết vấn đề sau:  \nĐọc từng dòng từ tệp và trả về chúng dưới dạng danh sách chuỗi."
    },
    "instruction_bertscore": {
      "es": "0.982230923373381",
      "arb": "0.9864349353879844",
      "sw": "0.9600037864748149",
      "tr": "0.9788009739536705",
      "vi": "0.9900059123782295"
    },
    "level": "easy",
    "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"../data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)",
    "entry_point": "lines-from-file",
    "signature": "(defun lines-from-file (filename)",
    "docstring": {
      "es": "Lee cada línea del archivo y devuélvelas como una lista de cadenas.",
      "arb": "اقرأ كل سطر من الملف وأعدها كقائمة من السلاسل النصية.",
      "sw": "Soma kila mstari kutoka kwenye faili na urejeshe kama orodha ya mistari ya maandishi.",
      "tr": "Dosyadan her satırı okuyun ve bunları bir string listesi olarak döndürün.",
      "vi": "Đọc từng dòng từ tệp và trả về chúng dưới dạng danh sách chuỗi."
    },
    "docstring_bertscore": {
      "es": "0.9548777322314476",
      "arb": "0.9465241329266443",
      "sw": "0.887038107783935",
      "tr": "0.9725441169510716",
      "vi": "0.9725441169510716"
    }
  },
  {
    "task_id": "Common Lisp/15",
    "prompt": {
      "es": "(defun nondecreasing? (numbers)\n;; Verificar si la lista de números reales está en orden no decreciente.\n;; Ejemplo:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "arb": "(defun nondecreasing? (numbers)\n;; التحقق مما إذا كانت قائمة الأعداد الحقيقية في ترتيب غير تنازلي.\n;; مثال:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "sw": "(defun nondecreasing? (numbers)\n;; Angalia kama orodha ya nambari halisi iko katika mpangilio usiopungua.\n;; Mfano:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "tr": "(defun nondecreasing? (numbers)\n;; Gerçek sayı listesinin azalmayan sırada olup olmadığını kontrol et.\n;; Örnek:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "vi": "(defun nondecreasing? (numbers)\n;; Kiểm tra xem danh sách số thực có theo thứ tự không giảm hay không.\n;; Ví dụ:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9662521023710294",
      "arb": "0.9662521023710294",
      "sw": "0.9662521023710294",
      "tr": "0.9662521023710294",
      "vi": "0.9662521023710294"
    },
    "canonical_solution": "(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun nondecreasing? (numbers)` para resolver el siguiente problema:\nVerificar si la lista de números reales está en orden no decreciente.\nEjemplo:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "arb": "اكتب دالة Common Lisp `(defun nondecreasing? (numbers)` لحل المشكلة التالية:\nتحقق مما إذا كانت قائمة الأعداد الحقيقية في ترتيب غير متناقص.\nمثال:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "sw": "Andika kazi ya Common Lisp `(defun nondecreasing? (numbers)` kutatua tatizo lifuatalo: Angalia kama orodha ya nambari halisi iko katika mpangilio usiopungua. Mfano: >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0) t",
      "tr": "Bir Common Lisp fonksiyonu `(defun nondecreasing? (numbers)` yazın:\nGerçek sayı listesinin azalmayan sırada olup olmadığını kontrol edin.\nÖrnek:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "vi": "Viết một hàm Common Lisp `(defun nondecreasing? (numbers)` để giải quyết vấn đề sau:  \nKiểm tra xem danh sách số thực có theo thứ tự không giảm hay không.  \nVí dụ:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt"
    },
    "instruction_bertscore": {
      "es": "0.9725645758803182",
      "arb": "0.9691721676026233",
      "sw": "0.9691721676026233",
      "tr": "0.9530942300401353",
      "vi": "0.9691721676026233"
    },
    "level": "easy",
    "test": "(defun check-nondecreasing? ()\n(assert (equal (nondecreasing? '(1.0 2.0 2.0 3.0 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 3.0 3.9 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 1.0 4.0 5.0)) nil))\n(assert (equal (nondecreasing? '(5.0 5.0 5.0 5.0)) t))\n(assert (equal (nondecreasing? '(1.0)) t))\n(assert (equal (nondecreasing? '()) t)))\n\n(check-nondecreasing?)",
    "entry_point": "nondecreasing?",
    "signature": "(defun nondecreasing? (numbers)",
    "docstring": {
      "es": "Verificar si la lista de números reales está en orden no decreciente.\nEjemplo:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "arb": "تحقق مما إذا كانت قائمة الأعداد الحقيقية في ترتيب غير متناقص.\nمثال:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "sw": "Angalia kama orodha ya nambari halisi iko katika mpangilio usiopungua.\nMfano:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "tr": "Gerçek sayı listesinin azalmayan sırada olup olmadığını kontrol edin.\nÖrnek:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "vi": "Kiểm tra xem danh sách số thực có theo thứ tự không giảm hay không.  \nVí dụ:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt  "
    },
    "docstring_bertscore": {
      "es": "0.957527660144834",
      "arb": "0.957527660144834",
      "sw": "0.9522458796827353",
      "tr": "0.957527660144834",
      "vi": "0.957527660144834"
    }
  },
  {
    "task_id": "Common Lisp/16",
    "prompt": {
      "es": "(defun make-change (cents)\n;; Definir una función que acepte un entero cents y devuelva cuatro valores, mostrando los números como 25-, 10-, 5-, 1-, usando el número mínimo de monedas. (Traducción: 25- es 25 centavos, y así sucesivamente)\n;; Ejemplo:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "arb": "(defun make-change (cents)\n;; تعريف دالة تقبل عدد صحيح يمثل السنتات وتعيد أربعة قيم، تعرض الأرقام كـ 25-، 10-، 5-، 1-، باستخدام الحد الأدنى من العملات المعدنية. (الترجمة: 25- تعني 25 سنتًا، وهكذا)\n;; مثال:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "sw": "(defun make-change (cents)\n;; Eleza kazi ambayo inakubali nambari kamili ya senti na inarudisha thamani nne, ikionyesha nambari kama 25-, 10-, 5-, 1-, kwa kutumia idadi ndogo ya sarafu. (Tafsiri: 25- ni senti 25, na kadhalika)\n;; Mfano:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "tr": "(defun make-change (cents)\n;; Bir tamsayı olan cents'i kabul eden ve dört değer döndüren bir fonksiyon tanımlayın, sayıları minimum sayıda madeni para kullanarak 25-, 10-, 5-, 1- olarak gösterin. (Çeviri: 25- 25 centtir, ve bu şekilde devam eder)\n;; Örnek:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "vi": "(defun make-change (cents)\n;; Định nghĩa một hàm chấp nhận một số nguyên cents và trả về bốn giá trị, hiển thị các số dưới dạng 25-, 10-, 5-, 1-, sử dụng số lượng đồng xu ít nhất. (Dịch: 25- là 25 cents, và cứ thế)\n;; Ví dụ:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3"
    },
    "prompt_bertscore": {
      "es": "0.9976454354632124",
      "arb": "0.9894308774251336",
      "sw": "0.9598794438562871",
      "tr": "0.9692059347673992",
      "vi": "0.9937230813289165"
    },
    "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun make-change (cents)` para resolver el siguiente problema:\nDefinir una función que acepte un entero cents y devuelva cuatro valores, mostrando los números como 25-, 10-, 5-, 1-, usando el número mínimo de monedas. (Traducción: 25- es 25 centavos, y así sucesivamente)\nEjemplo:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "arb": "اكتب دالة بلغة Common Lisp `(defun make-change (cents)` لحل المشكلة التالية:\nحدد دالة تقبل عددًا صحيحًا يمثل السنتات وتعيد أربعة قيم، تعرض الأرقام كـ 25-، 10-، 5-، 1-، باستخدام أقل عدد من العملات المعدنية. (الترجمة: 25- تعني 25 سنتًا، وهكذا)\nمثال:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "sw": "Andika kazi ya Common Lisp `(defun make-change (cents)` kutatua tatizo lifuatalo:\nTafsiri kazi inayokubali nambari nzima ya senti na kurudisha maadili manne, ikionyesha nambari kama 25-, 10-, 5-, 1-, kwa kutumia idadi ndogo ya sarafu. (Tafsiri: 25- ni senti 25, na kadhalika)\nMfano:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "tr": "Bir Common Lisp fonksiyonu `(defun make-change (cents)` yazın: Aşağıdaki problemi çözmek için bir fonksiyon tanımlayın: Bir tamsayı olan cents'i kabul eden ve dört değer döndüren, sayıları minimum sayıda madeni para kullanarak 25-, 10-, 5-, 1- olarak gösteren bir fonksiyon tanımlayın. (Çeviri: 25- 25 senttir, ve bu şekilde devam eder)\nÖrnek:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "vi": "Viết một hàm Common Lisp `(defun make-change (cents)` để giải quyết vấn đề sau:  \nĐịnh nghĩa một hàm nhận vào một số nguyên cents và trả về bốn giá trị, hiển thị các số dưới dạng 25-, 10-, 5-, 1-, sử dụng số lượng xu ít nhất. (Dịch: 25- là 25 cents, và cứ thế)  \nVí dụ:  \nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98  \nquarters 3  \ndimes 2  \nnickels 0  \npennies 3"
    },
    "instruction_bertscore": {
      "es": "0.997569161396895",
      "arb": "0.9714653553516711",
      "sw": "0.9473895654968133",
      "tr": "0.9610589110588722",
      "vi": "0.9850824611235178"
    },
    "level": "middle",
    "test": "(defun check-make-change ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)",
    "entry_point": "make-change",
    "signature": "(defun make-change (cents)",
    "docstring": {
      "es": "Definir una función que acepte un entero `cents` y devuelva cuatro valores, mostrando los números como 25-, 10-, 5-, 1-, utilizando el número mínimo de monedas. (Traducción: 25- son 25 centavos, y así sucesivamente)\n\nEjemplo:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "arb": "تعريف دالة تقبل عددًا صحيحًا يمثل السنتات وتعيد أربعة قيم، تعرض الأرقام كـ 25-، 10-، 5-، 1-، باستخدام أقل عدد من العملات المعدنية. (الترجمة: 25- تعني 25 سنتًا، وهكذا)\n\nمثال:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "sw": "Tafsiri kazi ya programu ifuatayo:\n\nTafsiri kazi ambayo inakubali senti kama nambari nzima na inarejesha thamani nne, ikionyesha nambari kama 25-, 10-, 5-, 1-, kwa kutumia idadi ndogo ya sarafu. (Tafsiri: 25- ni senti 25, na kadhalika)\n\nMfano:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "tr": "Bir fonksiyon tanımlayın, bu fonksiyon bir tamsayı olan cents'i kabul eder ve dört değer döndürür, sayıları minimum sayıda madeni para kullanarak 25-, 10-, 5-, 1- olarak gösterir. (Çeviri: 25- 25 kuruş, ve bu şekilde devam eder)\nÖrnek:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "vi": "Định nghĩa một hàm chấp nhận một số nguyên cents và trả về bốn giá trị, hiển thị các số dưới dạng 25-, 10-, 5-, 1-, sử dụng số lượng tiền xu ít nhất. (Dịch: 25- là 25 cents, và cứ thế)\n\nVí dụ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3"
    },
    "docstring_bertscore": {
      "es": "0.9699917165547732",
      "arb": "0.9778501303196565",
      "sw": "0.9145496073395531",
      "tr": "0.9747932087555295",
      "vi": "0.9884961228519834"
    }
  },
  {
    "task_id": "Common Lisp/17",
    "prompt": {
      "es": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Definir una función que acepta 8 números reales que representan los puntos finales de dos segmentos de línea en un espacio bidimensional. Si los segmentos de línea no se intersectan, devuelve falso, o devuelve dos valores que representan las coordenadas x e y del punto de intersección\n;; Ejemplo:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "arb": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; تعريف دالة تقبل 8 أرقام حقيقية تمثل نقاط النهاية لمقطعين خطيين في الفضاء ثنائي الأبعاد. إذا لم تتقاطع المقطعين الخطيين، أعد false، أو أعد قيمتين تمثلان إحداثيات x و y لنقطة التقاطع\n;; مثال:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "sw": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Fafanua kazi inayokubali namba halisi 8 zinazowakilisha ncha za mistari miwili katika nafasi ya vipimo viwili. Ikiwa mistari haikatani, rudisha false, au rudisha thamani mbili zinazowakilisha kuratibu za x na y za sehemu ya makutano\n;; Mfano:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "tr": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; İki boyutlu uzayda iki doğru parçasının uç noktalarını temsil eden 8 gerçek sayıyı kabul eden bir fonksiyon tanımlayın. Eğer doğru parçaları kesişmiyorsa, false döndürün, aksi takdirde kesişim noktasının x ve y koordinatlarını temsil eden iki değer döndürün\n;; Örnek:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "vi": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Định nghĩa một hàm chấp nhận 8 số thực đại diện cho các điểm cuối của hai đoạn thẳng trong không gian hai chiều. Nếu các đoạn thẳng không giao nhau, trả về false, hoặc trả về hai giá trị đại diện cho tọa độ x và y của điểm giao nhau\n;; Ví dụ:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5"
    },
    "prompt_bertscore": {
      "es": "0.9821326013347687",
      "arb": "0.992495942834883",
      "sw": "0.9890508975062139",
      "tr": "0.9802692497302804",
      "vi": "1"
    },
    "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` para resolver el siguiente problema:\nDefinir una función que acepte 8 números reales que representen los extremos de dos segmentos de línea en un espacio bidimensional. Si los segmentos de línea no se intersectan, devuelve falso, o devuelve dos valores que representan las coordenadas x e y del punto de intersección.\nEjemplo:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "arb": "اكتب دالة بلغة Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` لحل المشكلة التالية:\nحدد دالة تقبل 8 أرقام حقيقية تمثل نقاط النهاية لمقطعين خطيين في الفضاء ثنائي الأبعاد. إذا لم تتقاطع المقاطع الخطية، أعد false، أو أعد قيمتين تمثلان إحداثيات x و y لنقطة التقاطع\nمثال:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "sw": "Andika kazi ya Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` kutatua tatizo lifuatalo:\nTafsiri kazi inayokubali namba 8 halisi zinazowakilisha ncha za vipande viwili vya mstari katika nafasi ya vipimo viwili. Ikiwa vipande vya mstari havikatani, rudisha uongo, au rudisha maadili mawili yanayowakilisha kuratibu za x na y za sehemu ya makutano.\nMfano:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "tr": "Bir Common Lisp fonksiyonu `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` yazın ve aşağıdaki problemi çözün:\nİki boyutlu uzayda iki doğru parçasının uç noktalarını temsil eden 8 gerçek sayı kabul eden bir fonksiyon tanımlayın. Eğer doğru parçaları kesişmiyorsa, false döndürün veya kesişim noktasının x ve y koordinatlarını temsil eden iki değer döndürün.\nÖrnek:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "vi": "Viết một hàm Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` để giải quyết vấn đề sau:\nĐịnh nghĩa một hàm nhận 8 số thực đại diện cho các điểm cuối của hai đoạn thẳng trong không gian hai chiều. Nếu các đoạn thẳng không giao nhau, trả về false, hoặc trả về hai giá trị đại diện cho tọa độ x và y của điểm giao nhau\nVí dụ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5"
    },
    "instruction_bertscore": {
      "es": "0.9913830168099445",
      "arb": "0.9898299258606327",
      "sw": "0.9840539530105191",
      "tr": "0.9849569267227037",
      "vi": "0.9939040336060393"
    },
    "level": "hard",
    "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)",
    "entry_point": "segments-intersect?",
    "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)",
    "docstring": {
      "es": "Definir una función que acepte 8 números reales que representen los puntos extremos de dos segmentos de línea en un espacio bidimensional. Si los segmentos de línea no se intersectan, devuelve falso, o devuelve dos valores que representen las coordenadas x e y del punto de intersección.\n\nEjemplo:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "arb": "تعريف دالة تقبل 8 أرقام حقيقية تمثل نقاط النهاية لمقطعين خطيين في الفضاء ثنائي الأبعاد. إذا لم تتقاطع المقاطع الخطية، أعد false، أو أعد قيمتين تمثلان إحداثيات x و y لنقطة التقاطع.\n\nمثال:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "sw": "Tafsiri yafuatayo kwa kutumia maagizo yaliyotolewa:\n\nTafsiri kazi inayokubali nambari halisi 8 zinazowakilisha ncha za mistari miwili katika nafasi ya vipimo viwili. Ikiwa mistari haikatani, rudisha uongo, au rudisha maadili mawili yanayowakilisha kuratibu za x na y za sehemu ya makutano.\n\nMfano:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "tr": "Bir fonksiyon tanımlayın, bu fonksiyon iki boyutlu uzayda iki doğru parçasının uç noktalarını temsil eden 8 gerçek sayı kabul eder. Doğru parçaları kesişmiyorsa, false döndürün veya kesişim noktasının x ve y koordinatlarını temsil eden iki değer döndürün.\n\nÖrnek:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "vi": "Định nghĩa một hàm chấp nhận 8 số thực đại diện cho các điểm cuối của hai đoạn thẳng trong không gian hai chiều. Nếu các đoạn thẳng không giao nhau, trả về false, hoặc trả về hai giá trị đại diện cho tọa độ x và y của điểm giao nhau.\n\nVí dụ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5"
    },
    "docstring_bertscore": {
      "es": "0.9875502449774953",
      "arb": "0.9822454233911965",
      "sw": "0.9638939624873832",
      "tr": "0.99496174038505",
      "vi": "0.99496174038505"
    }
  },
  {
    "task_id": "Common Lisp/18",
    "prompt": {
      "es": "(defun quicksort (list)\n;; Ordenar rápidamente la lista\n;; Ejemplo:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "arb": "(defun quicksort (list)\n;; فرز القائمة بسرعة\n;; مثال:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "sw": "(defun quicksort (list)\n;; Haraka panga orodha\n;; Mfano:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "tr": "(defun quicksort (list)\n;; Listeyi hızlıca sırala\n;; Örnek:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "vi": "(defun quicksort (list)\n;; Nhanh chóng sắp xếp danh sách\n;; Ví dụ:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9"
    },
    "prompt_bertscore": {
      "es": "0.9859101539212902",
      "arb": "0.9817695049982369",
      "sw": "0.9859101539212902",
      "tr": "0.9859101539212902",
      "vi": "0.9859101539212902"
    },
    "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun quicksort (list)` para resolver el siguiente problema:  \nOrdenar rápidamente la lista  \nEjemplo:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "arb": "اكتب دالة Common Lisp `(defun quicksort (list)` لحل المشكلة التالية:\nفرز القائمة بسرعة\nمثال:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "sw": "Andika kazi ya Common Lisp `(defun quicksort (list)` kutatua tatizo lifuatalo: \nPanga haraka orodha \nMfano: \nquicksort '(3 1 4 1 5 9 2 6 5 3 5) \n1 1 2 3 3 4 5 5 5 6 9",
      "tr": "Bir Common Lisp fonksiyonu `(defun quicksort (list)` yazın:\nListeyi hızlıca sıralayın\nÖrnek:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "vi": "Viết một hàm Common Lisp `(defun quicksort (list)` để giải quyết vấn đề sau:\nNhanh chóng sắp xếp danh sách\nVí dụ:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9"
    },
    "instruction_bertscore": {
      "es": "0.9842565559991747",
      "arb": "0.9716260473299283",
      "sw": "0.9800839275847749",
      "tr": "0.9371722173267597",
      "vi": "0.9800839275847749"
    },
    "level": "middle",
    "test": "(defun check-quicksort ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)",
    "entry_point": "quicksort",
    "signature": "(defun quicksort (list)",
    "docstring": {
      "es": "Ordenar rápidamente la lista  \nEjemplo:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9",
      "arb": "فرز القائمة بسرعة  \nمثال:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "sw": "Panga haraka orodha  \nMfano:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "tr": "Hızlıca listeyi sırala  \nÖrnek:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "vi": "Nhanh chóng sắp xếp danh sách  \nVí dụ:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9"
    },
    "docstring_bertscore": {
      "es": "0.9831470066907139",
      "arb": "0.9572060775579385",
      "sw": "0.9572060775579385",
      "tr": "0.9773454105214469",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/19",
    "prompt": {
      "es": "(defun enqueue-front (object queue)\n;; Definir una función que acepte dos parámetros de entrada, object y queue, y pueda insertar el objeto al comienzo de la queue\n;; Ejemplo:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "arb": "(defun enqueue-front (object queue)\n;; تعريف دالة تقبل معلمين، الكائن والطابور، ويمكنها إدراج الكائن في بداية الطابور \n;; مثال:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "sw": "(defun enqueue-front (object queue)\n;; Eleza kazi ambayo inakubali vigezo viwili vya kuingiza, object na queue, na inaweza kuingiza object mwanzoni mwa queue\n;; Mfano:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "tr": "(defun enqueue-front (object queue)\n;; İki giriş parametresi, object ve queue, kabul eden ve object'i queue'nun başına ekleyebilen bir fonksiyon tanımlayın\n;; Örnek:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "vi": "(defun enqueue-front (object queue)\n;; Định nghĩa một hàm chấp nhận hai tham số đầu vào, object và queue, và có thể chèn object vào đầu queue\n;; Ví dụ:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4"
    },
    "prompt_bertscore": {
      "es": "0.993475587874147",
      "arb": "0.971487601954347",
      "sw": "0.9743717150869735",
      "tr": "0.9819429093208804",
      "vi": "0.9830695408421103"
    },
    "canonical_solution": "(cons object queue))",
    "instruction": {
      "es": "Escribe una función en Common Lisp `(defun enqueue-front (object queue)` para resolver el siguiente problema:  \nDefinir una función que acepte dos parámetros de entrada, object y queue, y pueda insertar el object al comienzo de la queue  \nEjemplo:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "arb": "اكتب دالة Common Lisp `(defun enqueue-front (object queue)` لحل المشكلة التالية:\nتعريف دالة تقبل معلمين، الكائن والطابور، ويمكنها إدراج الكائن في بداية الطابور \nمثال:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "sw": "Andika kazi ya Common Lisp `(defun enqueue-front (object queue)` kutatua tatizo lifuatalo:\nTafsiri kazi inayokubali vigezo viwili vya ingizo, object na queue, na inaweza kuingiza object mwanzoni mwa queue\nMfano:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "tr": "Bir Common Lisp fonksiyonu `(defun enqueue-front (object queue)` yazın ve aşağıdaki problemi çözün: İki giriş parametresi, object ve queue kabul eden ve object'i queue'nun başına ekleyebilen bir fonksiyon tanımlayın.  \nÖrnek:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "vi": "Viết một hàm Common Lisp `(defun enqueue-front (object queue)` để giải quyết vấn đề sau:\nĐịnh nghĩa một hàm chấp nhận hai tham số đầu vào, object và queue, và có thể chèn object vào đầu của queue\nVí dụ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4"
    },
    "instruction_bertscore": {
      "es": "0.9877383479483354",
      "arb": "0.9757958949189937",
      "sw": "0.975575812456807",
      "tr": "0.9681313444060005",
      "vi": "0.9857879962369538"
    },
    "level": "easy",
    "test": "(defun check-enqueue-front ()\n(let ((queue '(2 3 4)))\n(setq queue (enqueue-front 1 queue))\n(assert (equal queue '(1 2 3 4))))\n(let ((queue '()))\n(setq queue (enqueue-front 'a queue))\n(assert (equal queue '(a)))))\n\n(check-enqueue-front)",
    "entry_point": "enqueue-front",
    "signature": "(defun enqueue-front (object queue)",
    "docstring": {
      "es": "Definir una función que acepte dos parámetros de entrada, objeto y cola, y pueda insertar el objeto al principio de la cola\nEjemplo:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "arb": "تعريف دالة تقبل معلمين، الكائن والطابور، ويمكنها إدراج الكائن في بداية الطابور  \nمثال:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "sw": "Tafsiri kazi ifuatayo kwa kutumia maagizo yaliyotolewa:\n\nFafanua kazi inayokubali vigezo viwili vya pembejeo, kitu na foleni, na inaweza kuingiza kitu mwanzoni mwa foleni\n\nMfano:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "tr": "Bir nesne ve kuyruk olmak üzere iki giriş parametresi kabul eden ve nesneyi kuyruğun başına ekleyebilen bir fonksiyon tanımlayın  \nÖrnek:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "vi": "Định nghĩa một hàm chấp nhận hai tham số đầu vào, object và queue, và có thể chèn object vào đầu queue  \nVí dụ:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4"
    },
    "docstring_bertscore": {
      "es": "0.9918847571524386",
      "arb": "0.9578403043645829",
      "sw": "0.9493488555753414",
      "tr": "0.9620095560625053",
      "vi": "0.9787451588165997"
    }
  },
  {
    "task_id": "Common Lisp/20",
    "prompt": {
      "es": "(defun move-first-instance-to-front (object queue)\n;; Definir una función que toma dos parámetros de entrada, object y queue, y puede mover destructivamente la primera instancia de object (equivalentemente eql) al principio de la queue\n;; Ejemplo:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "arb": "(defun move-first-instance-to-front (object queue)\n;; تعريف دالة تأخذ مدخلين، الكائن والطابور، ويمكنها نقل أول ظهور للكائن (بما يعادل eql) بشكل مدمر إلى بداية الطابور\n;; مثال:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "sw": "(defun move-first-instance-to-front (object queue)\n;; Fafanua kazi inayochukua vigezo viwili vya ingizo, object na queue, na inaweza kusogeza kwa uharibifu tukio la kwanza la object (sawa na eql) hadi mwanzo wa queue\n;; Mfano:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "tr": "(defun move-first-instance-to-front (object queue)\n;; İki giriş parametresi alan bir fonksiyon tanımlayın: object ve queue, ve object'in (eql eşdeğerli) ilk örneğini yıkıcı bir şekilde kuyruğun başına taşıyabilir\n;; Örnek:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "vi": "(defun move-first-instance-to-front (object queue)\n;; Định nghĩa một hàm nhận hai tham số đầu vào, object và queue, và có thể di chuyển phá hủy instance đầu tiên của object (tương đương eql) đến đầu tiên của queue\n;; Ví dụ:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d"
    },
    "prompt_bertscore": {
      "es": "0.977482862745123",
      "arb": "0.9494249310112778",
      "sw": "0.9673908503455024",
      "tr": "0.971607376074111",
      "vi": "0.9659636910577667"
    },
    "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun move-first-instance-to-front (object queue)` para resolver el siguiente problema:\nDefinir una función que tome dos parámetros de entrada, object y queue, y pueda mover destructivamente la primera instancia de object (equivalente a eql) al principio de la queue.\nEjemplo:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "arb": "اكتب دالة في لغة Common Lisp `(defun move-first-instance-to-front (object queue)` لحل المشكلة التالية:\nتعريف دالة تأخذ مدخلين، الكائن والطابور، ويمكنها نقل أول ظهور للكائن (بما يعادل eql) بشكل مدمر إلى بداية الطابور\nمثال:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "sw": "Andika kazi ya Common Lisp `(defun move-first-instance-to-front (object queue)` kutatua tatizo lifuatalo:\nFafanua kazi inayochukua vigezo viwili vya ingizo, object na queue, na inaweza kusogeza kwa uharibifu mfano wa kwanza wa object (sawa na eql) hadi mwanzo wa queue\nMfano:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "tr": "Bir Common Lisp fonksiyonu `(defun move-first-instance-to-front (object queue)` yazın: Aşağıdaki problemi çözmek için bir fonksiyon tanımlayın:\nİki giriş parametresi alan, object ve queue, ve object'in ilk örneğini (eql eşdeğerinde) yıkıcı bir şekilde kuyruğun başına taşıyabilen bir fonksiyon tanımlayın.\nÖrnek:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "vi": "Viết một hàm Common Lisp `(defun move-first-instance-to-front (object queue)` để giải quyết vấn đề sau:  \nĐịnh nghĩa một hàm nhận hai tham số đầu vào, object và queue, và có thể di chuyển phá hủy phiên bản đầu tiên của object (tương đương eql) đến đầu của queue  \nVí dụ:  \n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d"
    },
    "instruction_bertscore": {
      "es": "0.963312571362094",
      "arb": "0.9552293080058794",
      "sw": "0.9656907729142248",
      "tr": "0.9469196060152848",
      "vi": "0.9669818703909516"
    },
    "level": "hard",
    "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)",
    "entry_point": "move-first-instance-to-front",
    "signature": "(defun move-first-instance-to-front (object queue)",
    "docstring": {
      "es": "Definir una función que tome dos parámetros de entrada, objeto y cola, y pueda mover destructivamente la primera instancia del objeto (equivalente a eql) al principio de la cola.  \nEjemplo:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "arb": "تعريف دالة تأخذ معلمين إدخال، كائن و قائمة انتظار، ويمكنها نقل أول مثيل للكائن (بشكل مكافئ) إلى بداية قائمة الانتظار بشكل مدمر.\n\nمثال:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "sw": "Tafsiri kazi\nFafanua kazi inayochukua vigezo viwili vya pembejeo, object na queue, na inaweza kusogeza kwa uharibifu mfano wa kwanza wa object (sawa na eql) hadi mwanzo wa queue\nMfano:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "tr": "Bir nesne ve bir kuyruk olmak üzere iki giriş parametresi alan ve nesnenin ilk örneğini (eşitlik açısından) yıkıcı bir şekilde kuyruğun başına taşıyabilen bir fonksiyon tanımlayın.\n\nÖrnek:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "vi": "Định nghĩa một hàm nhận hai tham số đầu vào, object và queue, và có thể di chuyển phá hủy phiên bản đầu tiên của object (tương đương eql) đến đầu của queue.  \nVí dụ:  \n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d"
    },
    "docstring_bertscore": {
      "es": "0.945327186250528",
      "arb": "0.9266823482739263",
      "sw": "0.9185158587880579",
      "tr": "0.9007575082020147",
      "vi": "0.9362301134295112"
    }
  },
  {
    "task_id": "Common Lisp/21",
    "prompt": {
      "es": "(defun find-substring-index (haystack needle)\n;; Encuentra la primera aparición de la subcadena 'needle' dentro de la cadena 'haystack'.\n;; Devuelve el índice del primer carácter de la primera aparición de 'needle'.\n;; Si 'needle' no es parte de 'haystack', devuelve -1.\n;; Ejemplo:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Devuelve 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Devuelve -1",
      "arb": "(defun find-substring-index (haystack needle)\n;; يجد أول ظهور للجزء الفرعي 'needle' داخل السلسلة 'haystack'.\n;; يعيد فهرس الحرف الأول من أول ظهور لـ 'needle'.\n;; إذا لم يكن 'needle' جزءًا من 'haystack'، يعيد -1.\n;; مثال:\n;; (find-substring-index \"apple pie\" \"pie\") ;; يعيد 6\n;; (find-substring-index \"hello world\" \"bye\") ;; يعيد -1",
      "sw": "(defun find-substring-index (haystack needle)\n;; Inapata tukio la kwanza la sehemu ndogo ya 'needle' ndani ya kamba 'haystack'.\n;; Inarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.\n;; Ikiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\n;; Mfano:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Inarudisha 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Inarudisha -1",
      "tr": "(defun find-substring-index (haystack needle)\n;; 'needle' alt dizisinin 'haystack' dizisi içinde ilk geçtiği yeri bulur.\n;; 'needle'in ilk geçtiği yerin ilk karakterinin indeksini döndürür.\n;; Eğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\n;; Örnek:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 6 döndürür\n;; (find-substring-index \"hello world\" \"bye\") ;; -1 döndürür",
      "vi": "(defun find-substring-index (haystack needle)\n;; Tìm vị trí xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\n;; Trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\n;; Nếu 'needle' không phải là một phần của 'haystack', trả về -1.\n;; Ví dụ:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Trả về 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Trả về -1"
    },
    "prompt_bertscore": {
      "es": "0.9965895163576309",
      "arb": "1",
      "sw": "0.9965895163576309",
      "tr": "0.9706100529309348",
      "vi": "0.9855321603061808"
    },
    "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun find-substring-index (haystack needle)` para resolver el siguiente problema:\nEncuentra la primera aparición de la subcadena 'needle' dentro de la cadena 'haystack'.\nDevuelve el índice del primer carácter de la primera aparición de 'needle'.\nSi 'needle' no es parte de 'haystack', devuelve -1.\nEjemplo:\n(find-substring-index \"apple pie\" \"pie\") Devuelve 6\n(find-substring-index \"hello world\" \"bye\") Devuelve -1",
      "arb": "اكتب دالة Common Lisp `(defun find-substring-index (haystack needle)` لحل المشكلة التالية:\nتجد أول ظهور للجزء النصي 'needle' داخل السلسلة النصية 'haystack'.\nتعيد فهرس الحرف الأول من أول ظهور لـ 'needle'.\nإذا لم يكن 'needle' جزءًا من 'haystack'، تعيد -1.\nمثال:\n(find-substring-index \"apple pie\" \"pie\") تعيد 6\n(find-substring-index \"hello world\" \"bye\") تعيد -1",
      "sw": "Andika kazi ya Common Lisp `(defun find-substring-index (haystack needle)` kutatua tatizo lifuatalo:\nInapata tukio la kwanza la sehemu ndogo ya 'needle' ndani ya kamba 'haystack'.\nInarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.\nIkiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\nMfano:\n(find-substring-index \"apple pie\" \"pie\") Inarudisha 6\n(find-substring-index \"hello world\" \"bye\") Inarudisha -1",
      "tr": "Bir Common Lisp fonksiyonu `(defun find-substring-index (haystack needle)` yazın:\nAşağıdaki problemi çözmek için:\n'needle' alt dizisinin 'haystack' dizesi içindeki ilk oluşumunu bulur.\n'needle' alt dizisinin ilk oluşumunun ilk karakterinin indeksini döndürür.\nEğer 'needle', 'haystack' parçası değilse, -1 döndürür.\nÖrnek:\n(find-substring-index \"apple pie\" \"pie\") 6 döndürür\n(find-substring-index \"hello world\" \"bye\") -1 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun find-substring-index (haystack needle)` để giải quyết vấn đề sau:\nTìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\nTrả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\nNếu 'needle' không phải là một phần của 'haystack', trả về -1.\nVí dụ:\n(find-substring-index \"apple pie\" \"pie\") Trả về 6\n(find-substring-index \"hello world\" \"bye\") Trả về -1"
    },
    "instruction_bertscore": {
      "es": "0.9898980560813276",
      "arb": "0.9859266402429161",
      "sw": "0.9952424051134524",
      "tr": "0.9582844418965769",
      "vi": "0.9890197125363914"
    },
    "level": "middle",
    "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)",
    "entry_point": "find-substring-index",
    "signature": "(defun find-substring-index (haystack needle)",
    "docstring": {
      "es": "Encuentra la primera aparición de la subcadena 'needle' dentro de la cadena 'haystack'.\nDevuelve el índice del primer carácter de la primera aparición de 'needle'.\nSi 'needle' no es parte de 'haystack', devuelve -1.\nEjemplo:\n(find-substring-index \"apple pie\" \"pie\") Devuelve 6\n(find-substring-index \"hello world\" \"bye\") Devuelve -1",
      "arb": "يعثر على أول ظهور للجزء الفرعي 'needle' داخل السلسلة 'haystack'.\nيعيد فهرس الحرف الأول من أول ظهور لـ 'needle'.\nإذا لم يكن 'needle' جزءًا من 'haystack'، يعيد -1.\nمثال:\n(find-substring-index \"apple pie\" \"pie\") يعيد 6\n(find-substring-index \"hello world\" \"bye\") يعيد -1",
      "sw": "Inapata tukio la kwanza la sehemu ndogo 'needle' ndani ya kamba 'haystack'.  \nInarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.  \nIkiwa 'needle' si sehemu ya 'haystack', inarudisha -1.  \nMfano:  \n(find-substring-index \"apple pie\" \"pie\") Inarudisha 6  \n(find-substring-index \"hello world\" \"bye\") Inarudisha -1  ",
      "tr": "\n'Needle' alt dizisinin 'haystack' dizisi içinde ilk geçtiği yeri bulur.  \n'Needle' alt dizisinin ilk geçtiği yerin ilk karakterinin indeksini döndürür.  \nEğer 'needle', 'haystack' dizisinin bir parçası değilse, -1 döner.   \nÖrnek:  \n(find-substring-index \"hello world\" \"bye\") -1 döndürür ",
      "vi": "Tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.  \nTrả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.  \nNếu 'needle' không phải là một phần của 'haystack', trả về -1.  \nVí dụ:  \n(find-substring-index \"apple pie\" \"pie\") Trả về 6  \n(find-substring-index \"hello world\" \"bye\") Trả về -1  "
    },
    "docstring_bertscore": {
      "es": "0.9764476011991692",
      "arb": "0.9896001105097754",
      "sw": "0.9957850633144397",
      "tr": "0.8677105771877162",
      "vi": "0.9786724600971409"
    }
  },
  {
    "task_id": "Common Lisp/22",
    "prompt": {
      "es": "(defun min-n-for-sum-greater-than-k (k)\n;; Calcula el entero más pequeño n tal que la suma S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; es mayor que un entero dado k.\n;; La función devuelve el menor n tal.\n;; Ejemplo:\n;; (min-n-for-sum-greater-than-k 2) ;; Devuelve 4\n;; (min-n-for-sum-greater-than-k 3) ;; Devuelve 11",
      "arb": "(defun min-n-for-sum-greater-than-k (k)\n;; يحسب أصغر عدد صحيح n بحيث يكون المجموع S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; أكبر من عدد صحيح معين k.\n;; تعيد الدالة أصغر قيمة لـ n تحقق ذلك.\n;; مثال:\n;; (min-n-for-sum-greater-than-k 2) ;; يعيد 4\n;; (min-n-for-sum-greater-than-k 3) ;; يعيد 11",
      "sw": "(defun min-n-for-sum-greater-than-k (k)\n;; Inahesabu namba ndogo kabisa n ambayo jumla S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; ni kubwa kuliko namba kamili k iliyotolewa.\n;; Kazi inarudisha n ndogo zaidi kama hiyo.\n;; Mfano:\n;; (min-n-for-sum-greater-than-k 2) ;; Inarudisha 4\n;; (min-n-for-sum-greater-than-k 3) ;; Inarudisha 11",
      "tr": "(defun min-n-for-sum-greater-than-k (k)\n;; S_n = 1 + 1/2 + 1/3 + ... + 1/n toplamının\n;; verilen bir tamsayı k'dan büyük olması için en küçük n tamsayısını hesaplar.\n;; Fonksiyon, bu koşulu sağlayan en küçük n değerini döndürür.\n;; Örnek:\n;; (min-n-for-sum-greater-than-k 2) ;; 4 döndürür\n;; (min-n-for-sum-greater-than-k 3) ;; 11 döndürür",
      "vi": "(defun min-n-for-sum-greater-than-k (k)\n;; Tính toán số nguyên nhỏ nhất n sao cho tổng S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; lớn hơn một số nguyên cho trước k.\n;; Hàm trả về n nhỏ nhất như vậy.\n;; Ví dụ:\n;; (min-n-for-sum-greater-than-k 2) ;; Trả về 4\n;; (min-n-for-sum-greater-than-k 3) ;; Trả về 11"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9688261534788605",
      "sw": "0.9860726335729767",
      "tr": "0.96144425399808",
      "vi": "0.9990000946618703"
    },
    "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun min-n-for-sum-greater-than-k (k)` para resolver el siguiente problema:\nCalcula el entero más pequeño n tal que la suma S_n = 1 + 1/2 + 1/3 + ... + 1/n\nes mayor que un entero dado k.\nLa función devuelve el menor n tal que cumple la condición.\nEjemplo:\n(min-n-for-sum-greater-than-k 2) Devuelve 4\n(min-n-for-sum-greater-than-k 3) Devuelve 11",
      "arb": "اكتب دالة Common Lisp `(defun min-n-for-sum-greater-than-k (k)` لحل المشكلة التالية:\nتحسب أصغر عدد صحيح n بحيث يكون المجموع S_n = 1 + 1/2 + 1/3 + ... + 1/n\nأكبر من عدد صحيح معين k.\nتعيد الدالة أصغر قيمة n تحقق ذلك.\nمثال:\n(min-n-for-sum-greater-than-k 2) يعيد 4\n(min-n-for-sum-greater-than-k 3) يعيد 11",
      "sw": "Andika kazi ya Common Lisp `(defun min-n-for-sum-greater-than-k (k)` kutatua tatizo lifuatalo:\nInahesabu n ndogo zaidi ambayo jumla S_n = 1 + 1/2 + 1/3 + ... + 1/n\nni kubwa kuliko nambari kamili iliyotolewa k.\nKazi inarudisha n ndogo zaidi kama hiyo.\nMfano:\n(min-n-for-sum-greater-than-k 2) Inarudisha 4\n(min-n-for-sum-greater-than-k 3) Inarudisha 11",
      "tr": "Bir Common Lisp fonksiyonu `(defun min-n-for-sum-greater-than-k (k)` yazın:\nAşağıdaki problemi çözmek için:\nS_n = 1 + 1/2 + 1/3 + ... + 1/n toplamının verilen bir tamsayı k'dan büyük olduğu en küçük n tamsayısını hesaplar.\nFonksiyon, bu koşulu sağlayan en küçük n değerini döndürür.\nÖrnek:\n(min-n-for-sum-greater-than-k 2) 4 döndürür\n(min-n-for-sum-greater-than-k 3) 11 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun min-n-for-sum-greater-than-k (k)` để giải quyết vấn đề sau:\nTính toán số nguyên nhỏ nhất n sao cho tổng S_n = 1 + 1/2 + 1/3 + ... + 1/n\nlớn hơn một số nguyên cho trước k.\nHàm trả về n nhỏ nhất như vậy.\nVí dụ:\n(min-n-for-sum-greater-than-k 2) Trả về 4\n(min-n-for-sum-greater-than-k 3) Trả về 11"
    },
    "instruction_bertscore": {
      "es": "0.9802052907475872",
      "arb": "0.9707675668230955",
      "sw": "0.9878376631388528",
      "tr": "0.9598643479473284",
      "vi": "0.998531326962628"
    },
    "level": "easy",
    "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)",
    "entry_point": "min-n-for-sum-greater-than-k",
    "signature": "(defun min-n-for-sum-greater-than-k (k)",
    "docstring": {
      "es": "Calcula el entero más pequeño n tal que la suma S_n = 1 + 1/2 + 1/3 + ... + 1/n\nes mayor que un entero dado k.\nLa función devuelve el menor n tal.\nEjemplo:\n(min-n-for-sum-greater-than-k 2) Devuelve 4\n(min-n-for-sum-greater-than-k 3) Devuelve 11",
      "arb": "يحسب أصغر عدد صحيح n بحيث يكون المجموع S_n = 1 + 1/2 + 1/3 + ... + 1/n أكبر من عدد صحيح معين k. تعيد الدالة أصغر n من هذا القبيل.\nمثال:\n(min-n-for-sum-greater-than-k 2) يعيد 4\n(min-n-for-sum-greater-than-k 3) يعيد 11",
      "sw": "Hesabu nambari ndogo zaidi n kama jumla S_n = 1 + 1/2 + 1/3 + ... + 1/n\nni kubwa kuliko nambari kamili k iliyotolewa.\nKazi inarudisha n ndogo zaidi kama hiyo.\nMfano:\n(min-n-for-sum-greater-than-k 2) Inarudisha 4\n(min-n-for-sum-greater-than-k 3) Inarudisha 11",
      "tr": "Verilen bir tamsayı k'dan büyük olacak şekilde S_n = 1 + 1/2 + 1/3 + ... + 1/n toplamı için en küçük n tamsayısını hesaplar. \nFonksiyon, bu koşulu sağlayan en küçük n değerini döndürür.\nÖrnek:\n(min-n-for-sum-greater-than-k 2) 4 döndürür\n(min-n-for-sum-greater-than-k 3) 11 döndürür",
      "vi": "Tính toán số nguyên nhỏ nhất n sao cho tổng S_n = 1 + 1/2 + 1/3 + ... + 1/n\nlớn hơn một số nguyên cho trước k.\nHàm trả về số n nhỏ nhất như vậy.\nVí dụ:\n(min-n-for-sum-greater-than-k 2) Trả về 4\n(min-n-for-sum-greater-than-k 3) Trả về 11"
    },
    "docstring_bertscore": {
      "es": "0.9977421684587764",
      "arb": "0.9933190671338915",
      "sw": "0.9786617340565651",
      "tr": "0.9427412173198348",
      "vi": "0.9882833897138951"
    }
  },
  {
    "task_id": "Common Lisp/23",
    "prompt": {
      "es": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Cuenta el número de manzanas que Fengfeng puede alcanzar.\n;; 'apple-heights' es una lista de enteros que representa las alturas de las manzanas.\n;; 'fengfeng-height' es un entero que representa la altura máxima que Fengfeng puede alcanzar.\n;; Fengfeng puede alcanzar manzanas en o por debajo de su altura máxima.\n;; Ejemplo:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Devuelve 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Devuelve 10",
      "arb": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; يحسب عدد التفاح الذي يمكن لفينغفينغ الوصول إليه.\n;; 'apple-heights' هو قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاح.\n;; 'fengfeng-height' هو عدد صحيح يمثل أقصى ارتفاع يمكن لفينغفينغ الوصول إليه.\n;; يمكن لفينغفينغ الوصول إلى التفاح عند أو تحت أقصى ارتفاع لها.\n;; مثال:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; يعيد 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; يعيد 10",
      "sw": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Inahesabu idadi ya maapulo ambayo Fengfeng anaweza kuyafikia.\n;; 'apple-heights' ni orodha ya namba zinazoashiria urefu wa maapulo.\n;; 'fengfeng-height' ni namba inayowakilisha urefu wa juu kabisa ambao Fengfeng anaweza kufikia.\n;; Fengfeng anaweza kufikia maapulo yaliyo kwenye au chini ya urefu wake wa juu kabisa.\n;; Mfano:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Inarudisha 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Inarudisha 10",
      "tr": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Fengfeng'in ulaşabileceği elma sayısını sayar.\n;; 'apple-heights', elmaların yüksekliklerini temsil eden bir tamsayı listesidir.\n;; 'fengfeng-height', Fengfeng'in maksimum ulaşma yüksekliğini temsil eden bir tamsayıdır.\n;; Fengfeng, maksimum yüksekliğine eşit veya daha düşük yükseklikteki elmalara ulaşabilir.\n;; Örnek:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 4 döndürür\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 10 döndürür",
      "vi": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Đếm số lượng táo mà Fengfeng có thể với tới.\n;; 'apple-heights' là một danh sách các số nguyên đại diện cho chiều cao của các quả táo.\n;; 'fengfeng-height' là một số nguyên đại diện cho chiều cao tối đa mà Fengfeng có thể với tới.\n;; Fengfeng có thể với tới các quả táo ở chiều cao bằng hoặc thấp hơn chiều cao tối đa của cô ấy.\n;; Ví dụ:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Trả về 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Trả về 10"
    },
    "prompt_bertscore": {
      "es": "0.981877758555901",
      "arb": "0.980386441655091",
      "sw": "0.9631546602091714",
      "tr": "0.9746623113344276",
      "vi": "0.9706207789715108"
    },
    "canonical_solution": "(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` para resolver el siguiente problema:\nCuenta el número de manzanas que Fengfeng puede alcanzar.\n'apple-heights' es una lista de enteros que representa las alturas de las manzanas.\n'fengfeng-height' es un entero que representa la altura máxima que Fengfeng puede alcanzar.\nFengfeng puede alcanzar manzanas en o por debajo de su altura máxima.\nEjemplo:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Devuelve 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Devuelve 10",
      "arb": "اكتب دالة Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` لحل المشكلة التالية:\nتحسب عدد التفاحات التي يمكن لفينجفينج الوصول إليها.\n'apple-heights' هي قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاحات.\n'fengfeng-height' هو عدد صحيح يمثل أقصى ارتفاع يمكن لفينجفينج الوصول إليه.\nيمكن لفينجفينج الوصول إلى التفاحات التي تكون عند أو تحت أقصى ارتفاع لها.\nمثال:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) يعيد 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) يعيد 10",
      "sw": "Andika kazi ya Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` kutatua tatizo lifuatalo:\nHesabu idadi ya maapulo ambayo Fengfeng anaweza kuyafikia.\n'apple-heights' ni orodha ya namba nzima inayowakilisha urefu wa maapulo.\n'fengfeng-height' ni namba nzima inayowakilisha urefu wa juu kabisa ambao Fengfeng anaweza kufikia.\nFengfeng anaweza kufikia maapulo yaliyo kwenye au chini ya urefu wake wa juu kabisa.\nMfano:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Inarudisha 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Inarudisha 10",
      "tr": "Bir Common Lisp fonksiyonu `(defun count-reachable-apples (apple-heights fengfeng-height)` yazın:\nFengfeng'in ulaşabileceği elma sayısını sayar.\n'apple-heights', elmaların yüksekliklerini temsil eden bir tamsayı listesidir.\n'fengfeng-height', Fengfeng'in maksimum ulaşabileceği yüksekliği temsil eden bir tamsayıdır.\nFengfeng, maksimum yüksekliğine eşit veya daha düşük yükseklikteki elmalara ulaşabilir.\nÖrnek:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4 döndürür\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` để giải quyết vấn đề sau:\nĐếm số lượng táo mà Fengfeng có thể với tới.\n'apple-heights' là một danh sách các số nguyên đại diện cho chiều cao của các quả táo.\n'fengfeng-height' là một số nguyên đại diện cho chiều cao tối đa mà Fengfeng có thể với tới.\nFengfeng có thể với tới các quả táo ở chiều cao bằng hoặc thấp hơn chiều cao tối đa của cô ấy.\nVí dụ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Trả về 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Trả về 10"
    },
    "instruction_bertscore": {
      "es": "0.9812449221619238",
      "arb": "0.9674291860090422",
      "sw": "0.9736351936340962",
      "tr": "0.9639759968347507",
      "vi": "0.9713300880621863"
    },
    "level": "easy",
    "test": "(defun test-count-reachable-apples ()\n(assert (equal (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4))\n(assert (equal (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10))\n(assert (equal (count-reachable-apples '(110 115 120 125 130 135 140 145 150 155) 120) 3))\n(assert (equal (count-reachable-apples '(200 199 198 197 196 195 194 193 192 191) 190) 0))\n(assert (equal (count-reachable-apples '(101 102 103 104 105 106 107 108 109 110) 105) 5)))\n\n(test-count-reachable-apples)",
    "entry_point": "count-reachable-apples",
    "signature": "(defun count-reachable-apples (apple-heights fengfeng-height)",
    "docstring": {
      "es": "Cuenta el número de manzanas que Fengfeng puede alcanzar.\n'apple-heights' es una lista de enteros que representa las alturas de las manzanas.\n'fengfeng-height' es un entero que representa la altura máxima que Fengfeng puede alcanzar.\nFengfeng puede alcanzar manzanas en o por debajo de su altura máxima.\nEjemplo:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Devuelve 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Devuelve 10",
      "arb": "يحسب عدد التفاح الذي يمكن لـ Fengfeng الوصول إليه.  \n'apple-heights' هي قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاح.  \n'fengfeng-height' هو عدد صحيح يمثل أقصى ارتفاع يمكن لـ Fengfeng الوصول إليه.  \nيمكن لـ Fengfeng الوصول إلى التفاح الذي يكون في أو تحت أقصى ارتفاع لها.  \nمثال:  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) يعيد 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) يعيد 10  ",
      "sw": "Hesabu idadi ya maapulo ambayo Fengfeng anaweza kufikia.\n'apple-heights' ni orodha ya nambari za mzima zinazoashiria urefu wa maapulo.\n'fengfeng-height' ni nambari inayowakilisha urefu wa juu ambao Fengfeng anaweza kufikia.\nFengfeng anaweza kufikia maapulo yaliyo kwenye au chini ya urefu wake wa juu.\nMfano:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Inarudisha 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Inarudisha 10",
      "tr": "Fengfeng'in ulaşabileceği elma sayısını sayar.\n'apple-heights', elmaların yüksekliklerini temsil eden bir tamsayı listesidir.\n'fengfeng-height', Fengfeng'in maksimum ulaşma yüksekliğini temsil eden bir tamsayıdır.\nFengfeng, maksimum yüksekliğine eşit veya daha düşük olan elmalara ulaşabilir.\nÖrnek:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4 döndürür\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10 döndürür",
      "vi": "Đếm số lượng táo mà Fengfeng có thể với tới.  \n'apple-heights' là một danh sách các số nguyên đại diện cho độ cao của các quả táo.  \n'fengfeng-height' là một số nguyên đại diện cho chiều cao tối đa mà Fengfeng có thể với tới.  \nFengfeng có thể với tới các quả táo ở độ cao bằng hoặc thấp hơn chiều cao tối đa của cô ấy.  \nVí dụ:  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Trả về 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Trả về 10"
    },
    "docstring_bertscore": {
      "es": "0.97563202485464",
      "arb": "0.9560774597328983",
      "sw": "0.9553874177891831",
      "tr": "0.9605200268351246",
      "vi": "0.9599044712842975"
    }
  },
  {
    "task_id": "Common Lisp/24",
    "prompt": {
      "es": "(defun count-remaining-trees (road-length regions)\n;; Cuenta el número de árboles restantes en una carretera de longitud 'road-length' después de remover árboles en las 'regions' especificadas.\n;; Cada región es una lista de dos enteros que representan los puntos de inicio y fin en la carretera.\n;; La función devuelve el número de árboles restantes después de la remoción.\n;; Ejemplo:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Devuelve 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Devuelve 7",
      "arb": "(defun count-remaining-trees (road-length regions)\n;; يحسب عدد الأشجار المتبقية على طريق بطول 'road-length' بعد إزالة الأشجار في 'regions' المحددة.\n;; كل منطقة هي قائمة تحتوي على عددين صحيحين يمثلان نقاط البداية والنهاية على الطريق.\n;; تعيد الدالة عدد الأشجار المتبقية بعد الإزالة.\n;; مثال:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; يعيد 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; يعيد 7",
      "sw": "(defun count-remaining-trees (road-length regions)\n;; Inahesabu idadi ya miti iliyobaki kwenye barabara yenye urefu wa 'road-length' baada ya kuondoa miti katika 'regions' zilizotajwa.\n;; Kila eneo ni orodha ya namba mbili zinazoashiria mwanzo na mwisho wa barabara.\n;; Kazi inarudisha idadi ya miti iliyobaki baada ya kuondolewa.\n;; Mfano:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Inarudisha 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Inarudisha 7",
      "tr": "(defun count-remaining-trees (road-length regions)\n;; Belirtilen 'regions' içindeki ağaçlar kaldırıldıktan sonra 'road-length' uzunluğundaki bir yolda kalan ağaçların sayısını sayar.\n;; Her bölge, yol üzerindeki başlangıç ve bitiş noktalarını temsil eden iki tam sayıdan oluşan bir listedir.\n;; Fonksiyon, kaldırma işleminden sonra kalan ağaçların sayısını döndürür.\n;; Örnek:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 4 döndürür\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 7 döndürür",
      "vi": "(defun count-remaining-trees (road-length regions)\n;; Đếm số cây còn lại trên một con đường có độ dài 'road-length' sau khi loại bỏ cây trong các 'regions' được chỉ định.\n;; Mỗi vùng là một danh sách gồm hai số nguyên đại diện cho điểm bắt đầu và điểm kết thúc trên đường.\n;; Hàm trả về số cây còn lại sau khi loại bỏ.\n;; Ví dụ:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Trả về 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Trả về 7"
    },
    "prompt_bertscore": {
      "es": "0.9934537385322332",
      "arb": "0.9812538605290704",
      "sw": "0.9787540971837463",
      "tr": "0.9789729878636467",
      "vi": "0.9908749202952573"
    },
    "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-remaining-trees (road-length regions)` para resolver el siguiente problema:\nCuenta el número de árboles restantes en una carretera de longitud 'road-length' después de eliminar árboles en las 'regions' especificadas.\nCada región es una lista de dos enteros que representan los puntos de inicio y fin en la carretera.\nLa función devuelve el número de árboles restantes después de la eliminación.\nEjemplo:\n(count-remaining-trees 10 '((2 5) (7 9))) Devuelve 4\n(count-remaining-trees 15 '((1 3) (5 10))) Devuelve 7",
      "arb": "اكتب دالة بلغة Common Lisp `(defun count-remaining-trees (road-length regions)` لحل المشكلة التالية:\nتحسب عدد الأشجار المتبقية على طريق بطول 'road-length' بعد إزالة الأشجار في 'regions' المحددة.\nكل منطقة هي قائمة تحتوي على عددين صحيحين يمثلان نقطتي البداية والنهاية على الطريق.\nتعيد الدالة عدد الأشجار المتبقية بعد الإزالة.\nمثال:\n(count-remaining-trees 10 '((2 5) (7 9))) يعيد 4\n(count-remaining-trees 15 '((1 3) (5 10))) يعيد 7",
      "sw": "Andika kazi ya Common Lisp `(defun count-remaining-trees (road-length regions)` kutatua tatizo lifuatalo:\nHesabu idadi ya miti iliyobaki kwenye barabara yenye urefu wa 'road-length' baada ya kuondoa miti katika 'regions' zilizobainishwa.\nKila eneo ni orodha ya nambari mbili zinazowakilisha mwanzo na mwisho wa barabara.\nKazi inarudisha idadi ya miti iliyobaki baada ya kuondolewa.\nMfano:\n(count-remaining-trees 10 '((2 5) (7 9))) Inarudisha 4\n(count-remaining-trees 15 '((1 3) (5 10))) Inarudisha 7",
      "tr": "Bir Common Lisp fonksiyonu `(defun count-remaining-trees (road-length regions)` yazın:\nBelirtilen 'regions' içindeki ağaçlar kaldırıldıktan sonra 'road-length' uzunluğundaki bir yolda kalan ağaçların sayısını sayar.\nHer bölge, yoldaki başlangıç ve bitiş noktalarını temsil eden iki tam sayıdan oluşan bir listedir.\nFonksiyon, kaldırma işleminden sonra kalan ağaçların sayısını döndürür.\nÖrnek:\n(count-remaining-trees 10 '((2 5) (7 9))) 4 döndürür\n(count-remaining-trees 15 '((1 3) (5 10))) 7 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun count-remaining-trees (road-length regions)` để giải quyết vấn đề sau:\nĐếm số cây còn lại trên một con đường có độ dài 'road-length' sau khi loại bỏ cây trong các 'regions' được chỉ định.\nMỗi vùng là một danh sách gồm hai số nguyên đại diện cho điểm bắt đầu và điểm kết thúc trên con đường.\nHàm trả về số cây còn lại sau khi loại bỏ.\nVí dụ:\n(count-remaining-trees 10 '((2 5) (7 9))) Trả về 4\n(count-remaining-trees 15 '((1 3) (5 10))) Trả về 7"
    },
    "instruction_bertscore": {
      "es": "0.9903233237271234",
      "arb": "0.9775049107174179",
      "sw": "0.980084324845537",
      "tr": "0.9168205484859251",
      "vi": "0.9878996358177357"
    },
    "level": "easy",
    "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)",
    "entry_point": "count-remaining-trees",
    "signature": "(defun count-remaining-trees (road-length regions)",
    "docstring": {
      "es": "Cuenta el número de árboles restantes en una carretera de longitud 'road-length' después de eliminar árboles en las 'regions' especificadas.  \nCada región es una lista de dos enteros que representan los puntos de inicio y fin en la carretera.  \nLa función devuelve el número de árboles restantes después de la eliminación.  \nEjemplo:  \n(count-remaining-trees 10 '((2 5) (7 9))) Devuelve 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Devuelve 7  ",
      "arb": "يحسب عدد الأشجار المتبقية على طريق بطول 'road-length' بعد إزالة الأشجار في 'regions' المحددة.\nكل منطقة هي قائمة من عددين صحيحين تمثل نقاط البداية والنهاية على الطريق.\nتعيد الدالة عدد الأشجار المتبقية بعد الإزالة.\nمثال:\n(count-remaining-trees 10 '((2 5) (7 9))) يعيد 4\n(count-remaining-trees 15 '((1 3) (5 10))) يعيد 7",
      "sw": "Hesabu idadi ya miti iliyobaki kwenye barabara yenye urefu wa 'road-length' baada ya kuondoa miti katika 'regions' zilizobainishwa. \nKila eneo ni orodha ya nambari mbili zinazoonyesha mwanzo na mwisho wa barabara. \nKazi inarudisha idadi ya miti iliyobaki baada ya kuondolewa. \nMfano:\n(count-remaining-trees 10 '((2 5) (7 9))) Inarudisha 4\n(count-remaining-trees 15 '((1 3) (5 10))) Inarudisha 7",
      "tr": "Yolun uzunluğu 'road-length' olan bir yolda belirtilen 'bölgelerde' ağaçlar kaldırıldıktan sonra kalan ağaçların sayısını sayar. Her bölge, yoldaki başlangıç ve bitiş noktalarını temsil eden iki tam sayıdan oluşan bir listedir. Fonksiyon, kaldırma işleminden sonra kalan ağaçların sayısını döndürür. Örnek: (count-remaining-trees 10 '((2 5) (7 9))) 4 döndürür (count-remaining-trees 15 '((1 3) (5 10))) 7 döndürür",
      "vi": "Đếm số cây còn lại trên một con đường có độ dài 'road-length' sau khi loại bỏ cây trong các 'regions' được chỉ định.  \nMỗi vùng là một danh sách gồm hai số nguyên đại diện cho điểm bắt đầu và điểm kết thúc trên đường.  \nHàm trả về số cây còn lại sau khi loại bỏ.  \nVí dụ:  \n(count-remaining-trees 10 '((2 5) (7 9))) Trả về 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Trả về 7  "
    },
    "docstring_bertscore": {
      "es": "0.9867237439620091",
      "arb": "0.9800408247920903",
      "sw": "0.9698016272801229",
      "tr": "0.9529287709327332",
      "vi": "0.9880086838969238"
    }
  },
  {
    "task_id": "Common Lisp/25",
    "prompt": {
      "es": "(defun larger-prime-factor (n)\n;; Encuentra el mayor factor primo de un entero positivo 'n', que se sabe es el producto de dos números primos distintos.\n;; La función devuelve el mayor de los dos factores primos.\n;; Ejemplo:\n;; (larger-prime-factor 15) ;; Devuelve 5\n;; (larger-prime-factor 33) ;; Devuelve 11",
      "arb": "(defun larger-prime-factor (n)\n;; يجد العامل الأولي الأكبر لعدد صحيح موجب 'n'، والذي يُعرف بأنه ناتج ضرب عددين أوليين مميزين.\n;; تُرجع الدالة الأكبر بين العاملين الأوليين.\n;; مثال:\n;; (larger-prime-factor 15) ;; تُرجع 5\n;; (larger-prime-factor 33) ;; تُرجع 11",
      "sw": "(defun larger-prime-factor (n)\n;; Inapata kipengele kikubwa zaidi cha nambari nzima chanya 'n', ambayo inajulikana kuwa ni bidhaa ya nambari mbili tofauti za kwanza.\n;; Kazi inarudisha kipengele kikubwa zaidi kati ya viwili vya kwanza.\n;; Mfano:\n;; (larger-prime-factor 15) ;; Inarudisha 5\n;; (larger-prime-factor 33) ;; Inarudisha 11",
      "tr": "(defun larger-prime-factor (n)\n;; Pozitif bir tamsayı 'n'nin daha büyük asal çarpanını bulur, bu sayı iki farklı asal sayının çarpımı olarak bilinir.\n;; Fonksiyon, iki asal çarpandan daha büyüğünü döndürür.\n;; Örnek:\n;; (larger-prime-factor 15) ;; 5 döndürür\n;; (larger-prime-factor 33) ;; 11 döndürür",
      "vi": "(defun larger-prime-factor (n)\n;; Tìm ước số nguyên tố lớn hơn của một số nguyên dương 'n', được biết là tích của hai số nguyên tố khác nhau.\n;; Hàm trả về ước số nguyên tố lớn hơn trong hai ước số.\n;; Ví dụ:\n;; (larger-prime-factor 15) ;; Trả về 5\n;; (larger-prime-factor 33) ;; Trả về 11"
    },
    "prompt_bertscore": {
      "es": "0.9951430899229349",
      "arb": "0.9805095924913326",
      "sw": "0.975199805145508",
      "tr": "0.9819228476523959",
      "vi": "0.9739992831225331"
    },
    "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun larger-prime-factor (n)` para resolver el siguiente problema:\nEncuentra el factor primo mayor de un entero positivo 'n', que se sabe que es el producto de dos números primos distintos.\nLa función devuelve el mayor de los dos factores primos.\nEjemplo:\n(larger-prime-factor 15) Devuelve 5\n(larger-prime-factor 33) Devuelve 11",
      "arb": "اكتب دالة Common Lisp `(defun larger-prime-factor (n)` لحل المشكلة التالية:\nتجد العامل الأولي الأكبر لعدد صحيح موجب 'n'، والذي يُعرف بأنه ناتج ضرب عددين أوليين متميزين.\nتُرجع الدالة الأكبر من العاملين الأوليين.\nمثال:\n(larger-prime-factor 15) يعيد 5\n(larger-prime-factor 33) يعيد 11",
      "sw": "Andika kazi ya Common Lisp `(defun larger-prime-factor (n)` kutatua tatizo lifuatalo:\nInapata kipengele kikubwa zaidi cha nambari ya kwanza ya nambari nzima chanya 'n', ambayo inajulikana kuwa ni bidhaa ya nambari mbili tofauti za kwanza.\nKazi inarudisha kipengele kikubwa zaidi kati ya viambatanishi viwili vya kwanza.\nMfano:\n(larger-prime-factor 15) Inarudisha 5\n(larger-prime-factor 33) Inarudisha 11",
      "tr": "Bir Common Lisp fonksiyonu `(defun larger-prime-factor (n)` yazın:\nPozitif bir tamsayı 'n'nin, iki farklı asal sayının çarpımı olduğu bilinen durumlarda, daha büyük asal çarpanını bulur.\nFonksiyon, iki asal çarpandan daha büyüğünü döndürür.\nÖrnek:\n(larger-prime-factor 15) 5 döndürür\n(larger-prime-factor 33) 11 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun larger-prime-factor (n)` để giải quyết vấn đề sau:\nTìm ước số nguyên tố lớn hơn của một số nguyên dương 'n', được biết là tích của hai số nguyên tố khác nhau.\nHàm trả về ước số nguyên tố lớn hơn trong hai ước số nguyên tố.\nVí dụ:\n(larger-prime-factor 15) Trả về 5\n(larger-prime-factor 33) Trả về 11"
    },
    "instruction_bertscore": {
      "es": "0.9909172285664176",
      "arb": "0.9909172285664176",
      "sw": "0.9809205587496939",
      "tr": "0.9544957660087174",
      "vi": "0.9768875674931614"
    },
    "level": "easy",
    "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)",
    "entry_point": "larger-prime-factor",
    "signature": "(defun larger-prime-factor (n)",
    "docstring": {
      "es": "Encuentra el factor primo más grande de un entero positivo 'n', que se sabe que es el producto de dos números primos distintos.\nLa función devuelve el mayor de los dos factores primos.\nEjemplo:\n(larger-prime-factor 15) Devuelve 5\n(larger-prime-factor 33) Devuelve 11",
      "arb": "يجد العامل الأولي الأكبر لعدد صحيح موجب 'n'، والذي يُعرف بأنه ناتج ضرب عددين أوليين متميزين.\nتعيد الدالة الأكبر بين العاملين الأوليين.\n\nمثال:\n(larger-prime-factor 15) يعيد 5\n(larger-prime-factor 33) يعيد 11",
      "sw": "Inapata kipengele kikubwa zaidi cha nambari ya kwanza ya nambari nzima chanya 'n', ambayo inajulikana kuwa ni zao la nambari mbili tofauti za kwanza. \nKazi inarudisha kipengele kikubwa zaidi kati ya viwili vya kwanza. \nMfano:\n(larger-prime-factor 15) Inarudisha 5\n(larger-prime-factor 33) Inarudisha 11",
      "tr": "İki farklı asal sayının çarpımı olduğu bilinen pozitif bir tamsayı 'n'nin daha büyük asal çarpanını bulur.\nFonksiyon, iki asal çarpandan daha büyüğünü döndürür.\nÖrnek:\n(larger-prime-factor 15) 5 döndürür\n(larger-prime-factor 33) 11 döndürür",
      "vi": "Tìm ước số nguyên tố lớn hơn của một số nguyên dương 'n', được biết là tích của hai số nguyên tố khác nhau. Hàm trả về ước số nguyên tố lớn hơn trong hai ước số nguyên tố.\n\nVí dụ:\n(larger-prime-factor 15) Trả về 5\n(larger-prime-factor 33) Trả về 11"
    },
    "docstring_bertscore": {
      "es": "0.9820660601571221",
      "arb": "0.9847124127236498",
      "sw": "0.9827843076149442",
      "tr": "0.9656208550201005",
      "vi": "0.9605236021819832"
    }
  },
  {
    "task_id": "Common Lisp/26",
    "prompt": {
      "es": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analiza un horario semanal para determinar el día en que Binbin estará más infeliz.\n;; 'weekly-schedule' es una lista de siete pares (uno para cada día) que representan las horas de escuela y las horas de clases extra.\n;; La función devuelve el día de la semana (1-7) en el que Binbin está más infeliz, o 0 si no está infeliz ningún día.\n;; Ejemplo:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Devuelve 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Devuelve 0",
      "arb": "(defun day-of-max-unhappiness (weekly-schedule)\n;; يحلل جدولاً أسبوعياً لمعرفة اليوم الذي ستكون فيه بينبين الأكثر تعاسة.\n;; 'weekly-schedule' هو قائمة من سبعة أزواج (واحد لكل يوم) تمثل ساعات المدرسة وساعات الدروس الإضافية.\n;; تعيد الدالة اليوم من الأسبوع (1-7) الذي تكون فيه بينبين الأكثر تعاسة، أو 0 إذا لم تكن تعيسة في أي يوم.\n;; مثال:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; يعيد 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; يعيد 0",
      "sw": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Inachambua ratiba ya kila wiki ili kupata siku ambayo Binbin atakuwa na huzuni zaidi.\n;; 'weekly-schedule' ni orodha ya jozi saba (moja kwa kila siku) inayowakilisha masaa ya shule na masaa ya ziada ya darasa.\n;; Kazi inarudisha siku ya wiki (1-7) ambayo Binbin ana huzuni zaidi, au 0 ikiwa hana huzuni siku yoyote.\n;; Mfano:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Inarudisha 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Inarudisha 0",
      "tr": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Binbin'in en mutsuz olacağı günü bulmak için haftalık bir programı analiz eder.\n;; 'weekly-schedule', okul saatlerini ve ekstra ders saatlerini temsil eden yedi çift (her gün için bir tane) içeren bir listedir.\n;; Fonksiyon, Binbin'in en mutsuz olduğu haftanın gününü (1-7) veya herhangi bir gün mutsuz değilse 0 döndürür.\n;; Örnek:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 3 döndürür\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 0 döndürür",
      "vi": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Phân tích một lịch trình hàng tuần để tìm ra ngày mà Binbin sẽ không vui nhất.\n;; 'weekly-schedule' là một danh sách gồm bảy cặp (một cho mỗi ngày) đại diện cho giờ học ở trường và giờ học thêm.\n;; Hàm trả về ngày trong tuần (1-7) mà Binbin không vui nhất, hoặc 0 nếu cô ấy không không vui vào bất kỳ ngày nào.\n;; Ví dụ:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Trả về 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Trả về 0"
    },
    "prompt_bertscore": {
      "es": "0.9945352809569682",
      "arb": "0.9742938519776079",
      "sw": "0.982982540735217",
      "tr": "0.9685425092947427",
      "vi": "0.9871645047775255"
    },
    "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` para resolver el siguiente problema:\nAnaliza un horario semanal para encontrar el día en que Binbin estará más infeliz.\n'weekly-schedule' es una lista de siete pares (uno para cada día) que representan las horas escolares y las horas de clases extra.\nLa función devuelve el día de la semana (1-7) en el que Binbin está más infeliz, o 0 si no está infeliz ningún día.\nEjemplo:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Devuelve 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Devuelve 0",
      "arb": "اكتب دالة Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` لحل المشكلة التالية:\nتحلل جدول أسبوعي لمعرفة اليوم الذي سيكون فيه بينبين الأكثر تعاسة.\n'weekly-schedule' هو قائمة تحتوي على سبعة أزواج (واحد لكل يوم) تمثل ساعات المدرسة وساعات الدروس الإضافية.\nتعيد الدالة اليوم من الأسبوع (1-7) الذي تكون فيه بينبين الأكثر تعاسة، أو 0 إذا لم تكن تعيسة في أي يوم.\nمثال:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) يعيد 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) يعيد 0",
      "sw": "Andika kazi ya Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` kutatua tatizo lifuatalo:\nInachambua ratiba ya kila wiki ili kujua ni siku gani Binbin atakuwa na huzuni zaidi.\n'weekly-schedule' ni orodha ya jozi saba (moja kwa kila siku) inayowakilisha saa za shule na saa za ziada za darasa.\nKazi inarudisha siku ya wiki (1-7) ambayo Binbin ana huzuni zaidi, au 0 ikiwa hana huzuni siku yoyote.\nMfano:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Inarudisha 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Inarudisha 0",
      "tr": "Bir Common Lisp fonksiyonu `(defun day-of-max-unhappiness (weekly-schedule)` yazarak aşağıdaki problemi çözün:\nBinbin'in en mutsuz olacağı günü bulmak için haftalık bir programı analiz eder.\n'weekly-schedule', okul saatlerini ve ek ders saatlerini temsil eden yedi çiftten (her gün için bir tane) oluşan bir listedir.\nFonksiyon, Binbin'in en mutsuz olduğu haftanın gününü (1-7) veya hiçbir gün mutsuz değilse 0'ı döndürür.\nÖrnek:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 3 döndürür\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 0 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` để giải quyết vấn đề sau:\nPhân tích một lịch trình hàng tuần để tìm ra ngày mà Binbin sẽ không vui nhất.\n'weekly-schedule' là một danh sách gồm bảy cặp (một cho mỗi ngày) đại diện cho giờ học ở trường và giờ học thêm.\nHàm trả về ngày trong tuần (1-7) mà Binbin không vui nhất, hoặc 0 nếu cô ấy không không vui vào bất kỳ ngày nào.\nVí dụ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Trả về 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.985618564521931",
      "arb": "0.975717833179247",
      "sw": "0.9787094053480134",
      "tr": "0.9694474693107377",
      "vi": "0.985555598691143"
    },
    "level": "middle",
    "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)",
    "entry_point": "day-of-max-unhappiness",
    "signature": "(defun day-of-max-unhappiness (weekly-schedule)",
    "docstring": {
      "es": "Analiza un horario semanal para averiguar el día en que Binbin estará más infeliz. \n'weekly-schedule' es una lista de siete pares (uno para cada día) que representan las horas escolares y las horas de clases extra. \nLa función devuelve el día de la semana (1-7) en el que Binbin está más infeliz, o 0 si no está infeliz ningún día. \nEjemplo: \n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Devuelve 3 \n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Devuelve 0",
      "arb": "يحلل جدولاً أسبوعيًا لمعرفة اليوم الذي ستكون فيه بينبين الأكثر تعاسة.  \n'weekly-schedule' هو قائمة تحتوي على سبعة أزواج (واحد لكل يوم) تمثل ساعات المدرسة وساعات الدروس الإضافية.  \nتعيد الدالة اليوم من الأسبوع (1-7) الذي تكون فيه بينبين الأكثر تعاسة، أو 0 إذا لم تكن تعيسة في أي يوم.  \nمثال:  \n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) يعيد 3  \n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) يعيد 0  ",
      "sw": "Huchambua ratiba ya kila wiki ili kupata siku ambayo Binbin atakuwa na huzuni zaidi.\n'weekly-schedule' ni orodha ya jozi saba (moja kwa kila siku) inayoonyesha saa za shule na saa za ziada za darasa.\nKazi inarudisha siku ya wiki (1-7) ambayo Binbin ana huzuni zaidi, au 0 ikiwa hana huzuni siku yoyote.\n\nMfano:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Inarudisha 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Inarudisha 0",
      "tr": "Haftalık bir programı analiz ederek Binbin'in en mutsuz olacağı günü bulur.\n'weekly-schedule', okul saatlerini ve ekstra ders saatlerini temsil eden yedi çift (her gün için bir tane) içeren bir listedir.\nFonksiyon, Binbin'in en mutsuz olduğu haftanın gününü (1-7) veya hiçbir gün mutsuz değilse 0 döndürür.\nÖrnek:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 3 döndürür\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 0 döndürür",
      "vi": "Phân tích lịch trình hàng tuần để tìm ra ngày mà Binbin sẽ không vui nhất. 'weekly-schedule' là một danh sách gồm bảy cặp (một cho mỗi ngày) đại diện cho giờ học ở trường và giờ học thêm. Hàm trả về ngày trong tuần (1-7) mà Binbin không vui nhất, hoặc 0 nếu cô ấy không không vui vào bất kỳ ngày nào.\n\nVí dụ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Trả về 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9751700105883527",
      "arb": "0.9755839563024294",
      "sw": "0.9707232722481247",
      "tr": "0.9526902158451104",
      "vi": "0.9829150064056651"
    }
  },
  {
    "task_id": "Common Lisp/27",
    "prompt": {
      "es": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calcula si Jinjin puede seguir su plan de ahorros sin quedarse sin dinero en ningún mes.\n;; 'monthly-budgets' es una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n;; Si tiene éxito, devuelve la cantidad total de dinero que Jinjin tendrá al final del año, incluyendo un 20% de interés sobre los ahorros.\n;; De lo contrario, devuelve -X, donde X es el primer mes en que Jinjin se queda sin dinero.\n;; Ejemplo:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Devuelve -7",
      "arb": "(defun calculate-year-end-amount (monthly-budgets)\n;; يحسب ما إذا كان بإمكان جينجين اتباع خطة التوفير الخاصة بها دون نفاد المال في أي شهر.\n;; 'monthly-budgets' هي قائمة تحتوي على 12 عدد صحيح تمثل ميزانية جينجين الشهرية.\n;; إذا نجحت، تعيد إجمالي المبلغ الذي ستحصل عليه جينجين بنهاية العام، بما في ذلك فائدة 20% على المدخرات.\n;; خلاف ذلك، تعيد -X، حيث X هو الشهر الأول الذي ينفد فيه المال من جينجين.\n;; مثال:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; يعيد -7",
      "sw": "(defun calculate-year-end-amount (monthly-budgets)\n;; Inahesabu kama Jinjin anaweza kufuata mpango wake wa akiba bila kumaliza pesa katika mwezi wowote.\n;; 'monthly-budgets' ni orodha ya namba 12 zinazoonyesha bajeti ya kila mwezi ya Jinjin.\n;; Ikiwa imefanikiwa, inarudisha jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka, ikiwa ni pamoja na riba ya 20% kwenye akiba.\n;; Vinginevyo, inarudisha -X, ambapo X ni mwezi wa kwanza ambao Jinjin anakosa pesa.\n;; Mfano:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Inarudisha -7",
      "tr": "(defun calculate-year-end-amount (monthly-budgets)\n;; Jinjin'in tasarruf planına herhangi bir ayda parasız kalmadan uyup uyamayacağını hesaplar.\n;; 'monthly-budgets', Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir listedir.\n;; Başarılı olursa, yıl sonunda Jinjin'in sahip olacağı toplam para miktarını, tasarruflar üzerindeki %20 faizi de dahil ederek döndürür.\n;; Aksi takdirde, Jinjin'in parasız kaldığı ilk ay olan X'i -X olarak döndürür.\n;; Örnek:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; -7 döndürür",
      "vi": "(defun calculate-year-end-amount (monthly-budgets)\n;; Tính toán liệu Jinjin có thể tuân theo kế hoạch tiết kiệm của mình mà không hết tiền trong bất kỳ tháng nào hay không.\n;; 'monthly-budgets' là một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n;; Nếu thành công, trả về tổng số tiền Jinjin sẽ có vào cuối năm, bao gồm 20% lãi suất trên số tiền tiết kiệm.\n;; Ngược lại, trả về -X, trong đó X là tháng đầu tiên Jinjin hết tiền.\n;; Ví dụ:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Trả về -7"
    },
    "prompt_bertscore": {
      "es": "0.9840714324840503",
      "arb": "0.9667601988857166",
      "sw": "0.9663766436199382",
      "tr": "0.9792375635311852",
      "vi": "0.9795919201309514"
    },
    "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest",
    "instruction": {
      "es": "Escribe una función Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` para resolver el siguiente problema:\nCalcula si Jinjin puede seguir su plan de ahorros sin quedarse sin dinero en ningún mes.\n'monthly-budgets' es una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\nSi tiene éxito, devuelve la cantidad total de dinero que Jinjin tendrá al final del año, incluyendo un 20% de interés sobre los ahorros.\nDe lo contrario, devuelve -X, donde X es el primer mes en que Jinjin se queda sin dinero.\nEjemplo:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Devuelve -7",
      "arb": "اكتب دالة Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` لحل المشكلة التالية:\nتحسب ما إذا كان بإمكان جينجين اتباع خطة التوفير الخاصة بها دون نفاد المال في أي شهر.\n'monthly-budgets' هي قائمة تحتوي على 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\nإذا نجحت، تعيد إجمالي المبلغ الذي سيكون لدى جينجين بحلول نهاية العام، بما في ذلك فائدة بنسبة 20% على المدخرات.\nوإلا، تعيد -X، حيث X هو الشهر الأول الذي تنفد فيه الأموال لدى جينجين.\nمثال:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) تعيد -7",
      "sw": "Andika kazi ya Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` kutatua tatizo lifuatalo:\nHesabu kama Jinjin anaweza kufuata mpango wake wa akiba bila kumaliza pesa katika mwezi wowote.\n'monthly-budgets' ni orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\nIkiwa imefanikiwa, inarudisha jumla ya kiasi cha pesa ambacho Jinjin atakuwa nacho mwishoni mwa mwaka, ikiwa ni pamoja na riba ya 20% kwenye akiba.\nVinginevyo, inarudisha -X, ambapo X ni mwezi wa kwanza ambao Jinjin anakosa pesa.\nMfano:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Inarudisha -7",
      "tr": "Bir Common Lisp fonksiyonu `(defun calculate-year-end-amount (monthly-budgets)` yazın. Aşağıdaki problemi çözmek için:\nJinjin'in tasarruf planını herhangi bir ayda parasız kalmadan takip edip edemeyeceğini hesaplar.\n'monthly-budgets', Jinjin'in aylık bütçesini temsil eden 12 tamsayıdan oluşan bir listedir.\nBaşarılı olursa, Jinjin'in yıl sonunda sahip olacağı toplam para miktarını, tasarruflar üzerindeki %20 faiz dahil olmak üzere döndürür.\nAksi takdirde, Jinjin'in parasız kaldığı ilk ay olan -X'i döndürür.\nÖrnek:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 döndürür.",
      "vi": "Viết một hàm Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` để giải quyết vấn đề sau:\nTính toán liệu Jinjin có thể tuân theo kế hoạch tiết kiệm của mình mà không hết tiền trong bất kỳ tháng nào không.\n'monthly-budgets' là một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\nNếu thành công, trả về tổng số tiền Jinjin sẽ có vào cuối năm, bao gồm lãi suất 20% trên số tiền tiết kiệm.\nNếu không, trả về -X, trong đó X là tháng đầu tiên Jinjin hết tiền.\nVí dụ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Trả về -7"
    },
    "instruction_bertscore": {
      "es": "0.9769898621393944",
      "arb": "0.9721287808243276",
      "sw": "0.9721317602800431",
      "tr": "0.9708960806796251",
      "vi": "0.9753467916274738"
    },
    "level": "hard",
    "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)",
    "entry_point": "calculate-year-end-amount",
    "signature": "(defun calculate-year-end-amount (monthly-budgets)",
    "docstring": {
      "es": "Calcula si Jinjin puede seguir su plan de ahorros sin quedarse sin dinero en ningún mes.\n'monthly-budgets' es una lista de 12 enteros que representa el presupuesto mensual de Jinjin.\nSi tiene éxito, devuelve la cantidad total de dinero que Jinjin tendrá al final del año, incluyendo un 20% de interés sobre los ahorros.\nDe lo contrario, devuelve -X, donde X es el primer mes en que Jinjin se queda sin dinero.\nEjemplo:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Devuelve -7",
      "arb": "يحسب ما إذا كانت جينجين تستطيع اتباع خطة التوفير الخاصة بها دون نفاد المال في أي شهر.\n'monthly-budgets' هي قائمة مكونة من 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\nإذا كانت ناجحة، تعيد إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام، بما في ذلك فائدة بنسبة 20% على المدخرات.\nوإلا، تعيد -X، حيث X هو الشهر الأول الذي تنفد فيه أموال جينجين.\nمثال:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) يعيد -7",
      "sw": "Hesabu kama Jinjin anaweza kufuata mpango wake wa akiba bila kumaliza pesa katika mwezi wowote.\n'monthly-budgets' ni orodha ya nambari 12 za mzima zinazoonyesha bajeti ya kila mwezi ya Jinjin.\nIkiwa imefanikiwa, inarudisha jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka, ikiwa ni pamoja na riba ya 20% kwenye akiba.\nVinginevyo, inarudisha -X, ambapo X ni mwezi wa kwanza ambao Jinjin anakosa pesa.\nMfano:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Inarudisha -7",
      "tr": "Jinjin'in herhangi bir ayda parasız kalmadan tasarruf planına uyup uyamayacağını hesaplar.\n'monthly-budgets', Jinjin'in aylık bütçesini temsil eden 12 tamsayıdan oluşan bir listedir.\nBaşarılı olursa, yıl sonunda Jinjin'in sahip olacağı toplam para miktarını, tasarruflar üzerindeki %20 faiz dahil olmak üzere döndürür.\nAksi takdirde, Jinjin'in parasız kaldığı ilk ay olan X'in negatif değeri olan -X'i döndürür.\nÖrnek:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 Döndürür",
      "vi": "Tính toán liệu Jinjin có thể tuân theo kế hoạch tiết kiệm của mình mà không hết tiền trong bất kỳ tháng nào hay không.\n'monthly-budgets' là một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\nNếu thành công, trả về tổng số tiền Jinjin sẽ có vào cuối năm, bao gồm 20% lãi suất trên khoản tiết kiệm.\nNgược lại, trả về -X, trong đó X là tháng đầu tiên Jinjin hết tiền.\nVí dụ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Trả về -7"
    },
    "docstring_bertscore": {
      "es": "0.9751420037046269",
      "arb": "0.9788252068601567",
      "sw": "0.9567482345296531",
      "tr": "0.9768536016980045",
      "vi": "0.9755144356690673"
    }
  },
  {
    "task_id": "Common Lisp/28",
    "prompt": {
      "es": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calcula el número total de cigarrillos que Peter puede fumar.\n;; 'initial-cigarettes' es el número inicial de cigarrillos.\n;; 'butt-to-cigarette-ratio' es el número de colillas de cigarrillo necesarias para obtener un nuevo cigarrillo.\n;; La función devuelve el número total de cigarrillos que Peter puede fumar.\n;; Ejemplo:\n;; (total-cigarettes-smoked 4 3) ;; Devuelve 5\n;; (total-cigarettes-smoked 10 4) ;; Devuelve 13",
      "arb": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n;; 'initial-cigarettes' هو العدد الأولي للسجائر.\n;; 'butt-to-cigarette-ratio' هو عدد أعقاب السجائر المطلوبة للحصول على سيجارة جديدة.\n;; تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n;; مثال:\n;; (total-cigarettes-smoked 4 3) ;; يعيد 5\n;; (total-cigarettes-smoked 10 4) ;; يعيد 13",
      "sw": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n;; 'initial-cigarettes' ni idadi ya awali ya sigara.\n;; 'butt-to-cigarette-ratio' ni idadi ya vipande vya sigara vinavyohitajika kupata sigara mpya.\n;; Kazi inarudisha jumla ya sigara ambazo Peter anaweza kuvuta.\n;; Mfano:\n;; (total-cigarettes-smoked 4 3) ;; Inarudisha 5\n;; (total-cigarettes-smoked 10 4) ;; Inarudisha 13",
      "tr": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Peter'ın içebileceği toplam sigara sayısını hesaplar.\n;; 'initial-cigarettes' başlangıçtaki sigara sayısıdır.\n;; 'butt-to-cigarette-ratio' yeni bir sigara elde etmek için gereken izmarit sayısıdır.\n;; Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n;; Örnek:\n;; (total-cigarettes-smoked 4 3) ;; 5 döndürür\n;; (total-cigarettes-smoked 10 4) ;; 13 döndürür",
      "vi": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Tính tổng số điếu thuốc mà Peter có thể hút.\n;; 'initial-cigarettes' là số lượng điếu thuốc ban đầu.\n;; 'butt-to-cigarette-ratio' là số đầu mẩu thuốc cần thiết để có được một điếu thuốc mới.\n;; Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n;; Ví dụ:\n;; (total-cigarettes-smoked 4 3) ;; Trả về 5\n;; (total-cigarettes-smoked 10 4) ;; Trả về 13"
    },
    "prompt_bertscore": {
      "es": "0.9875293887874866",
      "arb": "0.9871293472000824",
      "sw": "0.9934084508053572",
      "tr": "0.9902520154203318",
      "vi": "0.9877103410646094"
    },
    "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` para resolver el siguiente problema:\nCalcula el número total de cigarrillos que Peter puede fumar.\n'initial-cigarettes' es el número inicial de cigarrillos.\n'butt-to-cigarette-ratio' es el número de colillas de cigarrillo necesarias para obtener un nuevo cigarrillo.\nLa función devuelve el número total de cigarrillos que Peter puede fumar.\nEjemplo:\n(total-cigarettes-smoked 4 3) Devuelve 5\n(total-cigarettes-smoked 10 4) Devuelve 13",
      "arb": "اكتب دالة بلغة Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` لحل المشكلة التالية:\nتحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n'initial-cigarettes' هو العدد الابتدائي للسجائر.\n'butt-to-cigarette-ratio' هو عدد أعقاب السجائر المطلوبة للحصول على سيجارة جديدة.\nتعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\nمثال:\n(total-cigarettes-smoked 4 3) يعيد 5\n(total-cigarettes-smoked 10 4) يعيد 13",
      "sw": "Andika kazi ya Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` kutatua tatizo lifuatalo:\nInahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n'initial-cigarettes' ni idadi ya awali ya sigara.\n'butt-to-cigarette-ratio' ni idadi ya vishina vya sigara vinavyohitajika kupata sigara mpya.\nKazi inarudisha jumla ya sigara ambazo Peter anaweza kuvuta.\nMfano:\n(total-cigarettes-smoked 4 3) Inarudisha 5\n(total-cigarettes-smoked 10 4) Inarudisha 13",
      "tr": "Bir Common Lisp fonksiyonu `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` yazın:\nPeter'ın içebileceği toplam sigara sayısını hesaplar.\n'initial-cigarettes', başlangıçtaki sigara sayısıdır.\n'butt-to-cigarette-ratio', yeni bir sigara elde etmek için gereken izmarit sayısıdır.\nFonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\nÖrnek:\n(total-cigarettes-smoked 4 3) 5 döndürür\n(total-cigarettes-smoked 10 4) 13 döndürür",
      "vi": "Viết một hàm Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` để giải quyết vấn đề sau:\nTính tổng số điếu thuốc mà Peter có thể hút.\n'initial-cigarettes' là số điếu thuốc ban đầu.\n'butt-to-cigarette-ratio' là số đầu lọc cần thiết để có được một điếu thuốc mới.\nHàm trả về tổng số điếu thuốc mà Peter có thể hút.\nVí dụ:\n(total-cigarettes-smoked 4 3) Trả về 5\n(total-cigarettes-smoked 10 4) Trả về 13"
    },
    "instruction_bertscore": {
      "es": "0.9864601614463758",
      "arb": "0.9805377980054396",
      "sw": "0.9817212378156455",
      "tr": "0.924688099248336",
      "vi": "0.9866951411871401"
    },
    "level": "middle",
    "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)",
    "entry_point": "total-cigarettes-smoked",
    "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)",
    "docstring": {
      "es": "Calcula el número total de cigarrillos que Peter puede fumar.\n'initial-cigarettes' es el número inicial de cigarrillos.\n'butt-to-cigarette-ratio' es el número de colillas de cigarrillo necesarias para obtener un nuevo cigarrillo.\nLa función devuelve el número total de cigarrillos que Peter puede fumar.\nEjemplo:\n(total-cigarettes-smoked 4 3) Devuelve 5\n(total-cigarettes-smoked 10 4) Devuelve 13",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n'initial-cigarettes' هو العدد الأولي للسجائر.\n'butt-to-cigarette-ratio' هو عدد أعقاب السجائر المطلوبة للحصول على سيجارة جديدة.\nتعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\nمثال:\n(total-cigarettes-smoked 4 3) يعيد 5\n(total-cigarettes-smoked 10 4) يعيد 13",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n'initial-cigarettes' ni idadi ya sigara za kuanzia.\n'butt-to-cigarette-ratio' ni idadi ya vipande vya sigara vinavyohitajika kupata sigara mpya.\nKazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\nMfano:\n(total-cigarettes-smoked 4 3) Inarejesha 5\n(total-cigarettes-smoked 10 4) Inarejesha 13",
      "tr": "Peter'ın içebileceği toplam sigara sayısını hesaplar.\n'initial-cigarettes', başlangıçtaki sigara sayısıdır.\n'butt-to-cigarette-ratio', yeni bir sigara elde etmek için gereken izmarit sayısıdır.\nFonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\nÖrnek:\n(total-cigarettes-smoked 4 3) 5 döndürür\n(total-cigarettes-smoked 10 4) 13 döndürür",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút.\n'initial-cigarettes' là số lượng điếu thuốc ban đầu.\n'butt-to-cigarette-ratio' là số lượng đầu mẩu thuốc cần thiết để có được một điếu thuốc mới.\nHàm trả về tổng số điếu thuốc mà Peter có thể hút.\nVí dụ:\n(total-cigarettes-smoked 4 3) Trả về 5\n(total-cigarettes-smoked 10 4) Trả về 13"
    },
    "docstring_bertscore": {
      "es": "0.9814441484341018",
      "arb": "0.9825010606915884",
      "sw": "0.9870433402450942",
      "tr": "0.9824867593041539",
      "vi": "0.9814441484341018"
    }
  },
  {
    "task_id": "Common Lisp/29",
    "prompt": {
      "es": "(defun divisible-five-digit-numbers (k)\n;; Encuentra todos los números de cinco dígitos entre 10000 y 30000 donde tres subnúmeros\n;; (formados por dígitos consecutivos) son divisibles por 'k'.\n;; Cada subnúmero consiste en tres dígitos consecutivos del número original.\n;; La función devuelve una lista de dichos números de cinco dígitos.\n;; Ejemplo:\n;; (divisible-five-digit-numbers 15) ;; Devuelve (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Devuelve una lista de números o 'No' si no existen tales números",
      "arb": "(defun divisible-five-digit-numbers (k)\n;; يجد جميع الأرقام المكونة من خمسة أرقام بين 10000 و 30000 حيث يمكن تقسيم ثلاثة أرقام فرعية\n;; (المكونة من أرقام متتالية) على 'k'.\n;; كل رقم فرعي يتكون من ثلاثة أرقام متتالية من الرقم الأصلي.\n;; تُرجع الدالة قائمة بالأرقام المكونة من خمسة أرقام.\n;; مثال:\n;; (divisible-five-digit-numbers 15) ;; يُرجع (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; يُرجع قائمة بالأرقام أو 'لا' إذا لم توجد مثل هذه الأرقام",
      "sw": "(defun divisible-five-digit-numbers (k)\n;; Inapata namba zote za tarakimu tano kati ya 10000 na 30000 ambapo namba ndogo tatu \n;; (zilizoundwa na tarakimu mfululizo) zinagawanyika kwa 'k'.\n;; Kila namba ndogo inajumuisha tarakimu tatu mfululizo kutoka kwa namba ya awali.\n;; Kazi inarudisha orodha ya namba hizo za tarakimu tano.\n;; Mfano:\n;; (divisible-five-digit-numbers 15) ;; Inarudisha (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Inarudisha orodha ya namba au 'No' ikiwa hakuna namba kama hizo zilizopo",
      "tr": "(defun divisible-five-digit-numbers (k)\n;; 10000 ile 30000 arasındaki tüm beş basamaklı sayıları bulur, burada üç alt sayı \n;; (ardışık rakamlarla oluşturulan) 'k' ile bölünebilir.\n;; Her alt sayı, orijinal sayıdan üç ardışık rakamdan oluşur.\n;; Fonksiyon, bu tür beş basamaklı sayıların bir listesini döndürür.\n;; Örnek:\n;; (divisible-five-digit-numbers 15) ;; (22555 25555 28555 30000) döndürür\n;; (divisible-five-digit-numbers 7) ;; Bir sayı listesi veya böyle bir sayı yoksa 'No' döndürür",
      "vi": "(defun divisible-five-digit-numbers (k)\n;; Tìm tất cả các số có năm chữ số từ 10000 đến 30000 mà ba số con \n;; (được tạo thành bởi các chữ số liên tiếp) chia hết cho 'k'.\n;; Mỗi số con bao gồm ba chữ số liên tiếp từ số gốc.\n;; Hàm trả về một danh sách các số có năm chữ số như vậy.\n;; Ví dụ:\n;; (divisible-five-digit-numbers 15) ;; Trả về (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Trả về một danh sách các số hoặc 'No' nếu không tồn tại số nào như vậy"
    },
    "prompt_bertscore": {
      "es": "0.9865310724924052",
      "arb": "0.978365774788823",
      "sw": "0.9779786441761861",
      "tr": "0.9885014858722714",
      "vi": "0.9905668445742721"
    },
    "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun divisible-five-digit-numbers (k)` para resolver el siguiente problema:\nEncuentra todos los números de cinco dígitos entre 10000 y 30000 donde tres subnúmeros \n(formados por dígitos consecutivos) son divisibles por 'k'.\nCada subnúmero consiste en tres dígitos consecutivos del número original.\nLa función devuelve una lista de tales números de cinco dígitos.\nEjemplo:\n(divisible-five-digit-numbers 15) Devuelve (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Devuelve una lista de números o 'No' si no existen tales números",
      "arb": "اكتب دالة Common Lisp `(defun divisible-five-digit-numbers (k)` لحل المشكلة التالية:\nتجد جميع الأرقام ذات الخمسة أرقام بين 10000 و 30000 حيث أن ثلاثة أرقام فرعية \n(مكونة من أرقام متتالية) قابلة للقسمة على 'k'.\nكل رقم فرعي يتكون من ثلاثة أرقام متتالية من الرقم الأصلي.\nتعيد الدالة قائمة من هذه الأرقام ذات الخمسة أرقام.\nمثال:\n(divisible-five-digit-numbers 15) تعيد (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) تعيد قائمة من الأرقام أو 'No' إذا لم توجد مثل هذه الأرقام",
      "sw": "Andika kazi ya Common Lisp `(defun divisible-five-digit-numbers (k)` kutatua tatizo lifuatalo:\nInapata nambari zote za tarakimu tano kati ya 10000 na 30000 ambapo nambari ndogo tatu \n(zinazoundwa na tarakimu zinazofuatana) zinagawanyika kwa 'k'.\nKila nambari ndogo inajumuisha tarakimu tatu zinazofuatana kutoka kwenye nambari ya awali.\nKazi inarejesha orodha ya nambari hizo za tarakimu tano.\nMfano:\n(divisible-five-digit-numbers 15) Inarejesha (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Inarejesha orodha ya nambari au 'No' ikiwa hakuna nambari kama hizo zilizopo",
      "tr": "Common Lisp dilinde `(defun divisible-five-digit-numbers (k)` fonksiyonunu aşağıdaki problemi çözmek için yazın:\n10000 ile 30000 arasındaki beş basamaklı tüm sayıları bulur, bu sayılarda üç alt sayı \n(ardışık rakamlarla oluşturulmuş) 'k' ile bölünebilir.\nHer alt sayı, orijinal sayıdan üç ardışık rakamdan oluşur.\nFonksiyon, bu tür beş basamaklı sayıların bir listesini döndürür.\nÖrnek:\n(divisible-five-digit-numbers 15) (22555 25555 28555 30000) döndürür\n(divisible-five-digit-numbers 7) Sayıların listesini veya böyle bir sayı yoksa 'No' döndürür",
      "vi": "Viết một hàm Common Lisp `(defun divisible-five-digit-numbers (k)` để giải quyết vấn đề sau:\nTìm tất cả các số có năm chữ số từ 10000 đến 30000 mà ba số con \n(được tạo thành từ các chữ số liên tiếp) chia hết cho 'k'.\nMỗi số con bao gồm ba chữ số liên tiếp từ số gốc.\nHàm trả về một danh sách các số có năm chữ số như vậy.\nVí dụ:\n(divisible-five-digit-numbers 15) Trả về (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Trả về một danh sách các số hoặc 'No' nếu không tồn tại số nào như vậy."
    },
    "instruction_bertscore": {
      "es": "0.9878060809082683",
      "arb": "0.9771708144165172",
      "sw": "0.9835299660653491",
      "tr": "0.9617900694914616",
      "vi": "0.9856932495452001"
    },
    "level": "middle",
    "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)",
    "entry_point": "divisible-five-digit-numbers",
    "signature": "(defun divisible-five-digit-numbers (k)",
    "docstring": {
      "es": "Encuentra todos los números de cinco dígitos entre 10000 y 30000 donde tres subnúmeros (formados por dígitos consecutivos) son divisibles por 'k'. Cada subnúmero consiste en tres dígitos consecutivos del número original. La función devuelve una lista de tales números de cinco dígitos. Ejemplo: (divisible-five-digit-numbers 15) Devuelve (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Devuelve una lista de números o 'No' si no existen tales números",
      "arb": "يعثر على جميع الأرقام المكونة من خمسة أرقام بين 10000 و 30000 حيث تكون ثلاثة أرقام فرعية (مكونة من أرقام متتالية) قابلة للقسمة على 'k'. \nكل رقم فرعي يتكون من ثلاثة أرقام متتالية من الرقم الأصلي. \nتعيد الدالة قائمة من هذه الأرقام المكونة من خمسة أرقام. \nمثال: \n(divisible-five-digit-numbers 15) يعيد (22555 25555 28555 30000) \n(divisible-five-digit-numbers 7) يعيد قائمة من الأرقام أو 'لا' إذا لم توجد مثل هذه الأرقام.",
      "sw": "Inapata nambari zote za tarakimu tano kati ya 10000 na 30000 ambapo nambari ndogo tatu (zilizoundwa na tarakimu mfululizo) zinagawanyika kwa 'k'. \nKila nambari ndogo inajumuisha tarakimu tatu mfululizo kutoka kwa nambari ya awali. \nKazi inarejesha orodha ya nambari hizo za tarakimu tano. \nMfano: \n(divisible-five-digit-numbers 15) Inarejesha (22555 25555 28555 30000) \n(divisible-five-digit-numbers 7) Inarejesha orodha ya nambari au 'Hapana' ikiwa hakuna nambari kama hizo zilizopo",
      "tr": "Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nHer bir alt sayı, orijinal sayının ardışık üç basamağından oluşur.\nFonksiyon, bu tür beş basamaklı sayıların bir listesini döndürür.\nÖrnek:\n(divisible-five-digit-numbers 15) (22555 25555 28555 30000) döndürür\n(divisible-five-digit-numbers 7) Sayıların bir listesini veya böyle bir sayı yoksa 'No' döndürür",
      "vi": "Tìm tất cả các số có năm chữ số giữa 10000 và 30000 mà ba số con (được tạo thành bởi các chữ số liên tiếp) chia hết cho 'k'. Mỗi số con bao gồm ba chữ số liên tiếp từ số gốc. Hàm trả về danh sách các số có năm chữ số như vậy. Ví dụ: (divisible-five-digit-numbers 15) Trả về (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Trả về danh sách các số hoặc 'No' nếu không tồn tại số nào như vậy."
    },
    "docstring_bertscore": {
      "es": "0.9863000653592617",
      "arb": "0.9665220410588558",
      "sw": "0.9774445270815832",
      "tr": "0.9816866761293453",
      "vi": "0.9647844224855626"
    }
  },
  {
    "task_id": "Common Lisp/30",
    "prompt": {
      "es": "(defun count-digit-two (L R)\n;; Esta función cuenta las ocurrencias del dígito '2' en todos los enteros dentro de un rango dado [L, R].\n;; Tanto L como R son inclusivos.\n;; Itera a través de cada número en el rango y cuenta cuántas veces aparece '2' en cada número.\n;; Ejemplo:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "arb": "(defun count-digit-two (L R)\n;; تقوم هذه الدالة بحساب عدد مرات ظهور الرقم '2' في جميع الأعداد الصحيحة ضمن النطاق المحدد [L, R].\n;; كلا من L و R مشمولان.\n;; تقوم بالمرور عبر كل رقم في النطاق وتحصي عدد مرات ظهور '2' في كل رقم.\n;; مثال:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "sw": "(defun count-digit-two (L R)\n;; Kazi ya hii kazi ni kuhesabu idadi ya matukio ya namba '2' katika namba zote ndani ya safu iliyotolewa [L, R].\n;; L na R zote zinajumuishwa.\n;; Inapitia kila namba katika safu na kuhesabu ni mara ngapi '2' inaonekana katika kila namba.\n;; Mfano:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "tr": "(defun count-digit-two (L R)\n;; Bu fonksiyon, verilen [L, R] aralığındaki tüm tamsayılar içinde '2' rakamının kaç kez geçtiğini sayar.\n;; Hem L hem de R dahildir.\n;; Aralıktaki her sayıyı iteratif olarak kontrol eder ve her sayıda '2' rakamının kaç kez göründüğünü sayar.\n;; Örnek:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "vi": "(defun count-digit-two (L R)\n;; Hàm này đếm số lần xuất hiện của chữ số '2' trong tất cả các số nguyên trong phạm vi cho trước [L, R].\n;; Cả L và R đều được bao gồm.\n;; Nó lặp qua từng số trong phạm vi và đếm số lần '2' xuất hiện trong mỗi số.\n;; Ví dụ:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9773813626204142",
      "sw": "0.9663861778782279",
      "tr": "0.9568745634519913",
      "vi": "0.9808381271415644"
    },
    "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-digit-two (L R)` para resolver el siguiente problema:\nEsta función cuenta las ocurrencias del dígito '2' en todos los enteros dentro de un rango dado [L, R].\nTanto L como R son inclusivos.\nItera a través de cada número en el rango y cuenta cuántas veces aparece '2' en cada número.\nEjemplo:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "arb": "اكتب دالة Common Lisp `(defun count-digit-two (L R)` لحل المشكلة التالية:  \nهذه الدالة تحسب عدد مرات ظهور الرقم '2' في جميع الأعداد الصحيحة ضمن النطاق المعطى [L, R].  \nكل من L و R مشمولان.  \nتقوم بالمرور عبر كل عدد في النطاق وتحسب عدد مرات ظهور '2' في كل عدد.  \nمثال:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "sw": "Andika kazi ya Common Lisp `(defun count-digit-two (L R)` kutatua tatizo lifuatalo:\nKazi hii inahesabu idadi ya matukio ya tarakimu '2' katika namba zote ndani ya safu iliyotolewa [L, R].\nZote L na R zinajumuishwa.\nInapitia kila namba katika safu na kuhesabu ni mara ngapi '2' inaonekana katika kila namba.\nMfano:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "tr": "Bir Common Lisp fonksiyonu `(defun count-digit-two (L R)` yazın ve aşağıdaki problemi çözün:\nBu fonksiyon, belirli bir [L, R] aralığındaki tüm tamsayılar içinde '2' rakamının kaç kez geçtiğini sayar.\nHem L hem de R dahildir.\nAralıktaki her bir sayıyı iteratif olarak kontrol eder ve her sayıda '2' rakamının kaç kez göründüğünü sayar.\nÖrnek:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "vi": "Viết một hàm Common Lisp `(defun count-digit-two (L R)` để giải quyết vấn đề sau:\nHàm này đếm số lần xuất hiện của chữ số '2' trong tất cả các số nguyên trong một khoảng cho trước [L, R].\nCả L và R đều được bao gồm.\nNó lặp qua từng số trong khoảng và đếm số lần '2' xuất hiện trong mỗi số.\nVí dụ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9"
    },
    "instruction_bertscore": {
      "es": "0.9891351167877727",
      "arb": "0.9771610815278465",
      "sw": "0.9852727490285492",
      "tr": "0.9670631102167948",
      "vi": "0.9840249529748881"
    },
    "level": "easy",
    "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)",
    "entry_point": "count-digit-two",
    "signature": "(defun count-digit-two (L R)",
    "docstring": {
      "es": "Esta función cuenta las ocurrencias del dígito '2' en todos los enteros dentro de un rango dado [L, R].\nTanto L como R son inclusivos.\nItera a través de cada número en el rango y cuenta cuántas veces aparece '2' en cada número.\nEjemplo:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "arb": "هذه الدالة تحسب عدد مرات ظهور الرقم '2' في جميع الأعداد الصحيحة ضمن نطاق معين [L, R].  \nكلا من L و R مشمولان.  \nتقوم بالمرور عبر كل رقم في النطاق وتحسب عدد مرات ظهور '2' في كل رقم.  \nمثال:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "sw": "Kazi hii inahesabu idadi ya matukio ya namba '2' katika nambari zote ndani ya safu iliyotolewa [L, R].\nZote L na R zinajumuishwa.\nInapitia kila nambari katika safu na kuhesabu ni mara ngapi '2' inaonekana katika kila nambari.\nMfano:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "tr": "Bu fonksiyon, verilen [L, R] aralığındaki tüm tamsayılar içinde '2' rakamının kaç kez geçtiğini sayar.\nHem L hem de R dahildir.\nAralıktaki her bir sayı üzerinden geçer ve her sayıda '2'nin kaç kez göründüğünü sayar.\nÖrnek:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "vi": "Hàm này đếm số lần xuất hiện của chữ số '2' trong tất cả các số nguyên trong phạm vi cho trước [L, R].  \nCả L và R đều được bao gồm.  \nHàm lặp qua từng số trong phạm vi và đếm số lần '2' xuất hiện trong mỗi số.  \nVí dụ:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  "
    },
    "docstring_bertscore": {
      "es": "0.9871525869546635",
      "arb": "0.9666751850826337",
      "sw": "0.9686654615006033",
      "tr": "0.9696534490158708",
      "vi": "0.9644231138224602"
    }
  },
  {
    "task_id": "Common Lisp/31",
    "prompt": {
      "es": "(defun represent-as-powers-of-two (n)\n;; Esta función toma un entero positivo 'n' y devuelve su representación como una suma de potencias de dos.\n;; Las potencias se expresan en un formato específico donde a^b se representa como a(b), y los términos se suman sin espacios.\n;; Específicamente, 2^0 se representa como 2()\n;; Ejemplo:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "arb": "(defun represent-as-powers-of-two (n)\n;; تأخذ هذه الدالة عدداً صحيحاً موجباً 'n' وتعيد تمثيله كمجموع لأسس العدد اثنين.\n;; يتم التعبير عن الأسس بصيغة محددة حيث يتم تمثيل a^b كـ a(b)، ويتم جمع الحدود بدون فراغات.\n;; على وجه التحديد، يتم تمثيل 2^0 كـ 2()\n;; مثال:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "sw": "(defun represent-as-powers-of-two (n)\n;; Kazi ya hii function ni kuchukua nambari nzima chanya 'n' na kurudisha uwakilishi wake kama jumla ya nguvu za mbili.\n;; Nguvu zinaonyeshwa katika muundo maalum ambapo a^b inawakilishwa kama a(b), na maneno yanaongezwa bila nafasi.\n;; Hasa, 2^0 inawakilishwa kama 2()\n;; Mfano:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "tr": "(defun represent-as-powers-of-two (n)\n;; Bu fonksiyon pozitif bir tamsayı olan 'n' alır ve onu iki kuvvetlerinin toplamı olarak temsil eder.\n;; Kuvvetler, a^b'nin a(b) olarak temsil edildiği ve terimlerin boşluksuz toplandığı belirli bir formatta ifade edilir.\n;; Özellikle, 2^0, 2() olarak temsil edilir.\n;; Örnek:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "vi": "(defun represent-as-powers-of-two (n)\n;; Hàm này nhận một số nguyên dương 'n' và trả về biểu diễn của nó dưới dạng tổng của các lũy thừa của hai.\n;; Các lũy thừa được biểu diễn theo định dạng cụ thể, trong đó a^b được biểu diễn dưới dạng a(b), và các hạng tử được cộng mà không có khoảng trắng.\n;; Cụ thể, 2^0 được biểu diễn dưới dạng 2()\n;; Ví dụ:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\""
    },
    "prompt_bertscore": {
      "es": "0.9970658320113527",
      "arb": "0.9881308415812603",
      "sw": "0.9666334727026163",
      "tr": "0.9845729741961633",
      "vi": "0.9868214701094783"
    },
    "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun represent-as-powers-of-two (n)` para resolver el siguiente problema:\nEsta función toma un número entero positivo 'n' y devuelve su representación como una suma de potencias de dos.\nLas potencias se expresan en un formato específico donde a^b se representa como a(b), y los términos se suman sin espacios.\nEspecíficamente, 2^0 se representa como 2()\nEjemplo:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "arb": "اكتب دالة Common Lisp `(defun represent-as-powers-of-two (n)` لحل المشكلة التالية:\nتأخذ هذه الدالة عددًا صحيحًا موجبًا 'n' وتعيد تمثيله كمجموع لقوى العدد اثنين.\nيتم التعبير عن القوى بصيغة محددة حيث يتم تمثيل a^b كـ a(b)، ويتم جمع الحدود بدون مسافات.\nتحديدًا، يتم تمثيل 2^0 كـ 2()\nمثال:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "sw": "Andika kazi ya Common Lisp `(defun represent-as-powers-of-two (n)` kutatua tatizo lifuatalo:\nKazi hii inachukua nambari nzima chanya 'n' na kurudisha uwakilishi wake kama jumla ya nguvu za mbili.\nNguvu zinaonyeshwa katika muundo maalum ambapo a^b inawakilishwa kama a(b), na maneno yanaongezwa bila nafasi.\nHasa, 2^0 inawakilishwa kama 2()\nMfano:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "tr": "Bir Common Lisp fonksiyonu `(defun represent-as-powers-of-two (n)` yazın:\nBu fonksiyon pozitif bir tam sayı 'n' alır ve onu iki kuvvetlerinin toplamı olarak temsil eder.\nKuvvetler, a^b'nin a(b) olarak temsil edildiği belirli bir formatta ifade edilir ve terimler boşluksuz olarak toplanır.\nÖzellikle, 2^0, 2() olarak temsil edilir.\nÖrnek:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "vi": "Viết một hàm Common Lisp `(defun represent-as-powers-of-two (n)` để giải quyết vấn đề sau:\nHàm này nhận một số nguyên dương 'n' và trả về biểu diễn của nó dưới dạng tổng của các lũy thừa của hai. \nCác lũy thừa được biểu diễn theo định dạng cụ thể trong đó a^b được biểu diễn dưới dạng a(b), và các hạng tử được cộng mà không có khoảng trắng.\nCụ thể, 2^0 được biểu diễn dưới dạng 2()\nVí dụ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\""
    },
    "instruction_bertscore": {
      "es": "0.9972199691870357",
      "arb": "0.9813380798106291",
      "sw": "0.9872274706083136",
      "tr": "0.956314624407854",
      "vi": "0.9906760912838413"
    },
    "level": "hard",
    "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)",
    "entry_point": "represent-as-powers-of-two",
    "signature": "(defun represent-as-powers-of-two (n)",
    "docstring": {
      "es": "Esta función toma un entero positivo 'n' y devuelve su representación como una suma de potencias de dos. \nLas potencias se expresan en un formato específico donde a^b se representa como a(b), y los términos se suman sin espacios.\nEspecíficamente, 2^0 se representa como 2()\nEjemplo:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "arb": "هذه الدالة تأخذ عددًا صحيحًا موجبًا 'n' وتعيد تمثيله كمجموع لأسس العدد اثنين. \nيتم التعبير عن الأسس بصيغة محددة حيث يتم تمثيل a^b كـ a(b)، ويتم جمع الحدود بدون مسافات.\nتحديدًا، يتم تمثيل 2^0 كـ 2()\nمثال:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "sw": "Kazi ya hii kazi ni kuchukua nambari nzima chanya 'n' na kurudisha uwakilishi wake kama jumla ya nguvu za mbili. \nNguvu zinaonyeshwa katika muundo maalum ambapo a^b inawakilishwa kama a(b), na maneno yanaongezwa bila nafasi.\nHasa, 2^0 inawakilishwa kama 2()\nMfano:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "tr": "Bu fonksiyon pozitif bir tam sayı 'n' alır ve bu sayının iki kuvvetlerinin toplamı olarak temsilini döndürür. \nKuvvetler, a^b'nin a(b) olarak temsil edildiği ve terimlerin boşluksuz toplandığı belirli bir formatta ifade edilir.\nÖzellikle, 2^0, 2() olarak temsil edilir.\nÖrnek:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "vi": "Hàm này nhận một số nguyên dương 'n' và trả về biểu diễn của nó dưới dạng tổng của các lũy thừa của hai. \nCác lũy thừa được biểu diễn theo định dạng cụ thể, trong đó a^b được biểu diễn dưới dạng a(b), và các hạng tử được cộng lại mà không có khoảng trắng.\nCụ thể, 2^0 được biểu diễn là 2()\nVí dụ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\""
    },
    "docstring_bertscore": {
      "es": "0.9913869894175652",
      "arb": "0.9662805065155173",
      "sw": "0.9198623741410933",
      "tr": "0.990116549500466",
      "vi": "0.9810337780668837"
    }
  },
  {
    "task_id": "Common Lisp/32",
    "prompt": {
      "es": "(defun create-largest-number (numbers)\n;; Esta función toma una lista de enteros positivos y los reorganiza para formar el número más grande posible. \n;; Lo hace concatenando los enteros en un orden tal que su combinación dígito a dígito produzca el valor máximo.\n;; Ejemplo:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "arb": "(defun create-largest-number (numbers)\n;; تأخذ هذه الدالة قائمة من الأعداد الصحيحة الموجبة وتعيد ترتيبها لتشكيل أكبر عدد ممكن.\n;; تقوم بذلك عن طريق دمج الأعداد بترتيب بحيث ينتج عن دمج الأرقام أكبر قيمة ممكنة.\n;; مثال:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "sw": "(defun create-largest-number (numbers)\n;; Kazi ya kazi hii ni kuchukua orodha ya nambari nzima chanya na kuzipanga upya ili kuunda nambari kubwa zaidi inayowezekana.\n;; Inafanya hivi kwa kuunganisha nambari kwa mpangilio ambao mchanganyiko wa tarakimu zao unatoa thamani ya juu zaidi.\n;; Mfano:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "tr": "(defun create-largest-number (numbers)\n;; Bu fonksiyon, pozitif tamsayıların bir listesini alır ve onları en büyük olası sayıyı oluşturacak şekilde yeniden düzenler.\n;; Bunu, rakam bazında kombinasyonlarının maksimum değeri verecek bir sırayla tamsayıları birleştirerek yapar.\n;; Örnek:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "vi": "(defun create-largest-number (numbers)\n;; Hàm này nhận một danh sách các số nguyên dương và sắp xếp lại chúng để tạo thành số lớn nhất có thể.\n;; Nó thực hiện điều này bằng cách nối các số nguyên theo thứ tự sao cho sự kết hợp từng chữ số của chúng tạo ra giá trị lớn nhất.\n;; Ví dụ:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\""
    },
    "prompt_bertscore": {
      "es": "0.9823481152981915",
      "arb": "0.9527893324052468",
      "sw": "0.9556277605502352",
      "tr": "0.9623005495707213",
      "vi": "0.9802458113453183"
    },
    "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))",
    "instruction": {
      "es": "Escribe una función en Common Lisp `(defun create-largest-number (numbers)` para resolver el siguiente problema:\nEsta función toma una lista de enteros positivos y los reorganiza para formar el número más grande posible.\nLo hace concatenando los enteros en un orden tal que su combinación dígito a dígito produzca el valor máximo.\nEjemplo:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "arb": "اكتب دالة Common Lisp `(defun create-largest-number (numbers)` لحل المشكلة التالية:\nتأخذ هذه الدالة قائمة من الأعداد الصحيحة الموجبة وتعيد ترتيبها لتكوين أكبر عدد ممكن.\nتقوم بذلك عن طريق دمج الأعداد بترتيب يجعل مجموع أرقامها يعطي القيمة القصوى.\nمثال:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "sw": "Andika kazi ya Common Lisp `(defun create-largest-number (numbers)` kutatua tatizo lifuatalo:\nKazi hii inachukua orodha ya nambari nzima chanya na kuzipanga upya ili kuunda nambari kubwa zaidi inayowezekana. \nInafanya hivi kwa kuunganisha nambari kwa mpangilio ambao mchanganyiko wa tarakimu zao unatoa thamani ya juu zaidi.\nMfano:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "tr": "Bir Common Lisp fonksiyonu `(defun create-largest-number (numbers)` yazın: \nBu fonksiyon, pozitif tamsayıların bir listesini alır ve onları en büyük olası sayıyı oluşturacak şekilde yeniden düzenler. \nBunu, tamsayıları öyle bir sırayla birleştirerek yapar ki, rakam bazında kombinasyonları maksimum değeri verir.\nÖrnek:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "vi": "Viết một hàm Common Lisp `(defun create-largest-number (numbers)` để giải quyết vấn đề sau:\nHàm này nhận một danh sách các số nguyên dương và sắp xếp lại chúng để tạo thành số lớn nhất có thể. \nNó thực hiện điều này bằng cách nối các số nguyên theo thứ tự sao cho sự kết hợp các chữ số của chúng tạo ra giá trị lớn nhất.\nVí dụ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\""
    },
    "instruction_bertscore": {
      "es": "0.9794836665732874",
      "arb": "0.9635378182141876",
      "sw": "0.9779015755883446",
      "tr": "0.9597437793060403",
      "vi": "0.9883640336485953"
    },
    "level": "hard",
    "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)",
    "entry_point": "create-largest-number",
    "signature": "(defun create-largest-number (numbers)",
    "docstring": {
      "es": "Esta función toma una lista de enteros positivos y los reorganiza para formar el número más grande posible. Lo hace concatenando los enteros en un orden tal que su combinación dígito a dígito produzca el valor máximo.\nEjemplo:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "arb": "هذه الدالة تأخذ قائمة من الأعداد الصحيحة الموجبة وتعيد ترتيبها لتكوين أكبر رقم ممكن. \nتقوم بذلك عن طريق دمج الأعداد بترتيب بحيث يؤدي دمج الأرقام إلى الحصول على أكبر قيمة ممكنة.\nمثال:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "sw": "Kazi ya kazi hii ni kuchukua orodha ya nambari za mzima chanya na kuzipanga upya ili kuunda nambari kubwa zaidi inayowezekana. \nInafanya hivi kwa kuunganisha nambari kwa mpangilio ambao mchanganyiko wa tarakimu zao unatoa thamani ya juu zaidi.\nMfano:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "tr": "Bu fonksiyon, pozitif tam sayılardan oluşan bir liste alır ve bunları en büyük olası sayıyı oluşturacak şekilde yeniden düzenler.\nBunu, rakam bazında kombinasyonları maksimum değeri verecek şekilde sıralayarak yapar.\nÖrnek:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "vi": "Hàm này nhận một danh sách các số nguyên dương và sắp xếp lại chúng để tạo thành số lớn nhất có thể. Nó thực hiện điều này bằng cách nối các số nguyên theo thứ tự sao cho sự kết hợp từng chữ số của chúng tạo ra giá trị lớn nhất.\n\nVí dụ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\""
    },
    "docstring_bertscore": {
      "es": "0.9784426447462836",
      "arb": "0.9478154290337522",
      "sw": "0.9445674250430696",
      "tr": "0.9362897025438217",
      "vi": "0.9784378776171387"
    }
  },
  {
    "task_id": "Common Lisp/33",
    "prompt": {
      "es": "(defun add-numbers (a b)\n\"Suma dos números.\"\n;; Ejemplo:\n;; >>> add-numbers 1 2\n;; 3",
      "arb": "(defun add-numbers (a b)\n\"جمع عددين معًا.\"\n;; مثال:\n;; >>> add-numbers 1 2\n;; 3",
      "sw": "(defun add-numbers (a b)\n\"Ongeza namba mbili pamoja.\"\n;; Mfano:\n;; >>> add-numbers 1 2\n;; 3",
      "tr": "(defun add-numbers (a b)\n\"İki sayıyı bir araya ekleyin.\"\n;; Örnek:\n;; >>> add-numbers 1 2\n;; 3",
      "vi": "(defun add-numbers (a b)\n\"Cộng hai số với nhau.\"\n;; Ví dụ:\n;; >>> add-numbers 1 2\n;; 3"
    },
    "prompt_bertscore": {
      "es": "0.9784589324375285",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "(+ a b))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun add-numbers (a b)` para resolver el siguiente problema:\n\"Suma dos números.\"\nEjemplo:\n>>> add-numbers 1 2\n3",
      "arb": "اكتب دالة Common Lisp `(defun add-numbers (a b)` لحل المشكلة التالية:  \n\"جمع رقمين معًا.\"  \nمثال:  \n>>> add-numbers 1 2  \n3",
      "sw": "Andika kazi ya Common Lisp `(defun add-numbers (a b)` kutatua tatizo lifuatalo:\n\"Ongeza namba mbili pamoja.\"\nMfano:\n>>> add-numbers 1 2\n3",
      "tr": "Common Lisp fonksiyonu `(defun add-numbers (a b)` aşağıdaki problemi çözmek için yazın:\n\"İki sayıyı topla.\"\nÖrnek:\n>>> add-numbers 1 2\n3",
      "vi": "Viết một hàm Common Lisp `(defun add-numbers (a b)` để giải quyết vấn đề sau:\n\"Cộng hai số lại với nhau.\"\nVí dụ:\n>>> add-numbers 1 2\n3"
    },
    "instruction_bertscore": {
      "es": "0.9889188083028256",
      "arb": "1",
      "sw": "1",
      "tr": "0.9638168938995416",
      "vi": "1"
    },
    "level": "easy",
    "test": "(defun test_add()\n(assert (equal (add-numbers 1 2) 3))\n(assert (equal (add-numbers 20 10) 30))\n(assert (equal (add-numbers -1 -2) -3))\n)\n;; 运行测试\n(test_add)",
    "entry_point": "add-numbers",
    "signature": "(defun add-numbers (a b)",
    "docstring": {
      "es": "\"Añadir dos números juntos.\"\nEjemplo:\n>>> add-numbers 1 2\n3",
      "arb": "\"جمع رقمين معًا.\"\nمثال:\n>>> add-numbers 1 2\n3",
      "sw": "\"Ongeza namba mbili pamoja.\"\n\nMfano:\n>>> add-numbers 1 2\n3",
      "tr": "\"İki sayıyı topla.\"\nÖrnek:\n>>> add-numbers 1 2\n3",
      "vi": "\"Thêm hai số với nhau.\"\nVí dụ:\n>>> add-numbers 1 2\n3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9897725216805137",
      "sw": "1",
      "tr": "0.9674897682752578",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/34",
    "prompt": {
      "es": "(defun count-valid-sequences (n)\n;; Esta función calcula el número de secuencias válidas que se pueden formar a partir de un entero positivo 'n'.\n;; Una secuencia válida es aquella que comienza con 'n' y puede tener números adicionales añadidos, cada uno no más de la mitad del último número en la secuencia.\n;; Ejemplo:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "arb": "(defun count-valid-sequences (n)\n;; هذه الدالة تحسب عدد التسلسلات الصالحة التي يمكن تشكيلها من عدد صحيح موجب 'n'.\n;; التسلسل الصالح هو الذي يبدأ بـ 'n' ويمكن إضافة أرقام إضافية له، بحيث لا يزيد كل رقم عن نصف الرقم الأخير في التسلسل.\n;; مثال:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "sw": "(defun count-valid-sequences (n)\n;; Kazi ya hii kazi ni kuhesabu idadi ya mfuatano sahihi ambayo inaweza kuundwa kutoka kwa nambari chanya 'n' iliyotolewa.\n;; Mfuatano sahihi ni ule unaoanza na 'n' na unaweza kuwa na nambari za ziada zilizoongezwa, kila moja isiwe zaidi ya nusu ya nambari ya mwisho katika mfuatano.\n;; Mfano:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "tr": "(defun count-valid-sequences (n)\n;; Bu fonksiyon, verilen pozitif bir tamsayı 'n' den oluşturulabilecek geçerli dizilerin sayısını hesaplar.\n;; Geçerli bir dizi, 'n' ile başlayan ve dizideki son sayının en fazla yarısı kadar ek sayılar eklenebilen bir dizidir.\n;; Örnek:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "vi": "(defun count-valid-sequences (n)\n;; Hàm này tính toán số lượng dãy hợp lệ có thể được tạo từ một số nguyên dương 'n' cho trước.\n;; Một dãy hợp lệ là dãy bắt đầu với 'n' và có thể có các số bổ sung được thêm vào, mỗi số không lớn hơn một nửa số cuối cùng trong dãy.\n;; Ví dụ:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4"
    },
    "prompt_bertscore": {
      "es": "0.9877858206094027",
      "arb": "0.9576090986010583",
      "sw": "0.9585384901539206",
      "tr": "0.9569341525663018",
      "vi": "0.9796995777974724"
    },
    "canonical_solution": "(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-valid-sequences (n)` para resolver el siguiente problema:\nEsta función calcula el número de secuencias válidas que se pueden formar a partir de un número entero positivo 'n'.\nUna secuencia válida es aquella que comienza con 'n' y puede tener números adicionales añadidos, cada uno no mayor que la mitad del último número en la secuencia.\nEjemplo:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "arb": "اكتب دالة Common Lisp `(defun count-valid-sequences (n)` لحل المشكلة التالية:\nهذه الدالة تحسب عدد التسلسلات الصالحة التي يمكن تشكيلها من عدد صحيح موجب 'n'.\nالتسلسل الصالح هو الذي يبدأ بـ 'n' ويمكن أن يحتوي على أرقام إضافية مضافة، بحيث لا يزيد كل منها عن نصف الرقم الأخير في التسلسل.\nمثال:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "sw": "Andika kazi ya Common Lisp `(defun count-valid-sequences (n)` kutatua tatizo lifuatalo: \nKazi hii inahesabu idadi ya mlolongo halali ambao unaweza kuundwa kutoka kwa nambari chanya 'n' iliyotolewa. \nMlolongo halali ni ule unaoanza na 'n' na unaweza kuwa na nambari za ziada zilizoongezwa, kila moja isiwe zaidi ya nusu ya nambari ya mwisho katika mlolongo. \nMfano: \n>>> count-valid-sequences 6 \n6 \n>>> count-valid-sequences 4 \n4",
      "tr": "Bir Common Lisp fonksiyonu `(defun count-valid-sequences (n)` yazın: \nBu fonksiyon, verilen pozitif bir tam sayı 'n' ile oluşturulabilecek geçerli dizilerin sayısını hesaplar.\nGeçerli bir dizi, 'n' ile başlayan ve dizideki son sayının en fazla yarısı kadar ek sayılar eklenebilen bir dizidir.\nÖrnek:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "vi": "Viết một hàm Common Lisp `(defun count-valid-sequences (n)` để giải quyết vấn đề sau:  \nHàm này tính toán số lượng dãy hợp lệ có thể được tạo thành từ một số nguyên dương 'n' cho trước.  \nMột dãy hợp lệ là dãy bắt đầu với 'n' và có thể có thêm các số được nối vào, mỗi số không lớn hơn một nửa số cuối cùng trong dãy.  \nVí dụ:  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  "
    },
    "instruction_bertscore": {
      "es": "0.9825197319474057",
      "arb": "0.9721204383483242",
      "sw": "0.9721279863028035",
      "tr": "0.9336060074656594",
      "vi": "0.9848182827167414"
    },
    "level": "easy",
    "test": "(defun test-count-valid-sequences ()\n(assert (equal (count-valid-sequences 6) 6))\n(assert (equal (count-valid-sequences 4) 4))\n(assert (equal (count-valid-sequences 10) 14))\n(assert (equal (count-valid-sequences 2) 2))\n(assert (equal (count-valid-sequences 1) 1)))\n\n(test-count-valid-sequences)",
    "entry_point": "count-valid-sequences",
    "signature": "(defun count-valid-sequences (n)",
    "docstring": {
      "es": "Esta función calcula el número de secuencias válidas que se pueden formar a partir de un entero positivo 'n' dado.  \nUna secuencia válida es aquella que comienza con 'n' y puede tener números adicionales añadidos, cada uno no más de la mitad del último número en la secuencia.  \nEjemplo:  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  ",
      "arb": "هذه الدالة تحسب عدد التتابعات الصحيحة التي يمكن تشكيلها من عدد صحيح موجب 'n'.\nالتتابع الصحيح هو الذي يبدأ بـ 'n' ويمكن إضافة أرقام إضافية إليه، بحيث لا يزيد أي رقم عن نصف الرقم الأخير في التتابع.\nمثال:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "sw": "Kazi ya kazi hii ni kuhesabu idadi ya mlolongo sahihi ambao unaweza kuundwa kutoka kwa nambari chanya 'n' iliyotolewa. \nMlolongo sahihi ni ule unaoanza na 'n' na unaweza kuwa na nambari za ziada zilizounganishwa, kila moja isiyozidi nusu ya nambari ya mwisho kwenye mlolongo. \nMfano:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "tr": "Bu fonksiyon, verilen pozitif bir tam sayı 'n' ile oluşturulabilecek geçerli dizilerin sayısını hesaplar.\nGeçerli bir dizi, 'n' ile başlayan ve dizideki son sayının en fazla yarısı kadar ek sayılar içerebilen bir dizidir.\nÖrnek:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "vi": "Hàm này tính số lượng dãy hợp lệ có thể được tạo ra từ một số nguyên dương 'n' cho trước.  \nMột dãy hợp lệ là dãy bắt đầu với 'n' và có thể thêm các số khác vào, mỗi số không lớn hơn một nửa số cuối cùng trong dãy.  \nVí dụ:  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  "
    },
    "docstring_bertscore": {
      "es": "0.9919060106032094",
      "arb": "0.9466937632720481",
      "sw": "0.9535123469922138",
      "tr": "0.9376817042541142",
      "vi": "0.960226053871193"
    }
  },
  {
    "task_id": "Common Lisp/35",
    "prompt": {
      "es": "(defun construct-preorder (inorder postorder)\n;; Esta función reconstruye el recorrido en preorden de un árbol binario a partir de sus recorridos en inorden y postorden.\n;; Los nodos del árbol binario están representados por letras mayúsculas distintas.\n;; Se asume que el árbol no tiene más de 8 nodos.\n;; Ejemplo:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "arb": "(defun construct-preorder (inorder postorder)\n;; تقوم هذه الدالة بإعادة بناء الترتيب السابق لزيارة شجرة ثنائية من ترتيبها الداخلي وترتيبها اللاحق.\n;; يتم تمثيل عقد الشجرة الثنائية بأحرف كبيرة مميزة.\n;; يُفترض أن الشجرة لا تحتوي على أكثر من 8 عقد.\n;; مثال:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "sw": "(defun construct-preorder (inorder postorder)\n;; Kazi hii inajenga upya mfuatano wa preorder wa mti wa binary kutoka kwenye mfuatano wake wa inorder na postorder.\n;; Nodi za mti wa binary zinawakilishwa na herufi kubwa za kipekee.\n;; Inadhaniwa kuwa mti hauna zaidi ya nodi 8.\n;; Mfano:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "tr": "(defun construct-preorder (inorder postorder)\n;; Bu fonksiyon, bir ikili ağacın inorder ve postorder geçişlerinden preorder geçişini yeniden oluşturur.\n;; İkili ağacın düğümleri, farklı büyük harflerle temsil edilir.\n;; Ağacın 8'den fazla düğümü olmadığı varsayılır.\n;; Örnek:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "vi": "(defun construct-preorder (inorder postorder)\n;; Hàm này tái tạo lại thứ tự duyệt trước của một cây nhị phân từ thứ tự duyệt giữa và thứ tự duyệt sau của nó.\n;; Các nút của cây nhị phân được biểu diễn bằng các chữ cái in hoa khác nhau.\n;; Giả định rằng cây không có nhiều hơn 8 nút.\n;; Ví dụ:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\""
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9945616987976458",
      "sw": "0.9674782477131577",
      "tr": "0.9837834184315497",
      "vi": "0.9855107082250291"
    },
    "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))",
    "instruction": {
      "es": "Escriba una función de Common Lisp `(defun construct-preorder (inorder postorder)` para resolver el siguiente problema:\nEsta función reconstruye el recorrido en preorden de un árbol binario a partir de sus recorridos en inorden y postorden.\nLos nodos del árbol binario están representados por letras mayúsculas distintas.\nSe asume que el árbol no tiene más de 8 nodos.\nEjemplo:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "arb": "اكتب دالة Common Lisp `(defun construct-preorder (inorder postorder)` لحل المشكلة التالية:\nهذه الدالة تعيد بناء ترتيب المرور المسبق لشجرة ثنائية من ترتيبات المرور الداخلي واللاحق.\nيتم تمثيل عقد الشجرة الثنائية بحروف كبيرة مميزة.\nيفترض أن الشجرة لا تحتوي على أكثر من 8 عقد.\nمثال:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "sw": "Andika kazi ya Common Lisp `(defun construct-preorder (inorder postorder)` kutatua tatizo lifuatalo:\nKazi hii inajenga upya mfuatano wa preorder wa mti wa binary kutoka kwa mfuatano wake wa inorder na postorder.\nNodi za mti wa binary zinawakilishwa na herufi kubwa za kipekee.\nInadhaniwa kuwa mti hauna zaidi ya nodi 8.\nMfano:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "tr": "Bir Common Lisp fonksiyonu `(defun construct-preorder (inorder postorder)` yazın:\nBu fonksiyon, bir ikili ağacın öncelik sıralamasını, sıralı ve sonrası sıralamalarından yeniden oluşturur.\nİkili ağacın düğümleri, farklı büyük harflerle temsil edilir.\nAğacın 8'den fazla düğüme sahip olmadığı varsayılır.\nÖrnek:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "vi": "Viết một hàm Common Lisp `(defun construct-preorder (inorder postorder)` để giải quyết vấn đề sau:  \nHàm này tái tạo lại duyệt trước của một cây nhị phân từ duyệt giữa và duyệt sau của nó.  \nCác nút của cây nhị phân được biểu diễn bằng các chữ cái in hoa khác nhau.  \nGiả sử rằng cây không có nhiều hơn 8 nút.  \nVí dụ:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  "
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9898340970986345",
      "sw": "0.97653797802254",
      "tr": "0.9749268870019661",
      "vi": "0.9854505232195755"
    },
    "level": "hard",
    "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)",
    "entry_point": "construct-preorder",
    "signature": "(defun construct-preorder (inorder postorder)",
    "docstring": {
      "es": "Esta función reconstruye el recorrido en preorden de un árbol binario a partir de sus recorridos en inorder y postorder.  \nLos nodos del árbol binario están representados por letras mayúsculas distintas.  \nSe supone que el árbol no tiene más de 8 nodos.  \nEjemplo:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "arb": "هذه الدالة تعيد بناء ترتيب المرور المسبق لشجرة ثنائية من ترتيبات المرور الداخلي واللاحق. \nيتم تمثيل عقد الشجرة الثنائية بحروف كبيرة مميزة.  \nيفترض أن الشجرة لا تحتوي على أكثر من 8 عقد.  \nمثال:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "sw": "Kazi ya kazi hii ni kujenga upya mfuatano wa preorder wa mti wa binary kutoka kwa mfuatano wake wa inorder na postorder. \nNodi za mti wa binary zinawakilishwa na herufi kubwa za kipekee. \nInadhaniwa kuwa mti hauna zaidi ya nodi 8. \nMfano:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "tr": "Bu fonksiyon, bir ikili ağacın öncelik sırasını, sıralı ve son sıralı geçişlerinden yeniden oluşturur. İkili ağacın düğümleri, farklı büyük harflerle temsil edilir. Ağacın 8'den fazla düğüme sahip olmadığı varsayılır.\nÖrnek:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "vi": "Hàm này tái tạo lại duyệt trước của một cây nhị phân từ duyệt giữa và duyệt sau của nó.  \nCác nút của cây nhị phân được biểu diễn bằng các chữ cái viết hoa khác nhau.  \nGiả sử rằng cây không có nhiều hơn 8 nút.  \nVí dụ:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9607536161632216",
      "sw": "0.9585784148605085",
      "tr": "0.9901252892372315",
      "vi": "0.9811458056017873"
    }
  },
  {
    "task_id": "Common Lisp/36",
    "prompt": {
      "es": "(defun count-prime-sums (numbers k)\n;; Esta función cuenta el número de formas de seleccionar 'k' enteros de una lista de 'n' enteros tal que su suma sea un número primo.\n;; Considera todas las posibles combinaciones de 'k' enteros de la lista y verifica si su suma es prima.\n;; Ejemplo:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) y (3+4) son primos\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Solo (1+2+5) es primo",
      "arb": "(defun count-prime-sums (numbers k)\n;; هذه الدالة تحسب عدد الطرق لاختيار 'k' من الأعداد الصحيحة من قائمة تحتوي على 'n' من الأعداد الصحيحة بحيث يكون مجموعها عددًا أوليًا.\n;; تأخذ في الاعتبار جميع التراكيب الممكنة من 'k' أعداد صحيحة من القائمة وتتحقق مما إذا كان مجموعها عددًا أوليًا.\n;; مثال:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) و (3+4) هما عددان أوليان\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; فقط (1+2+5) هو عدد أولي",
      "sw": "(defun count-prime-sums (numbers k)\n;; Kazi ya kazi hii ni kuhesabu idadi ya njia za kuchagua nambari 'k' kutoka kwenye orodha ya nambari 'n' ili jumla yao iwe nambari ya kwanza.\n;; Inazingatia mchanganyiko wote unaowezekana wa nambari 'k' kutoka kwenye orodha na kuangalia ikiwa jumla yao ni ya kwanza.\n;; Mfano:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) na (3+4) ni ya kwanza\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Ni (1+2+5) pekee ndiyo ya kwanza",
      "tr": "(defun count-prime-sums (numbers k)\n;; Bu fonksiyon, bir 'n' tamsayı listesinden 'k' tamsayı seçmenin toplamlarının asal sayı olacak şekilde kaç farklı yolu olduğunu sayar.\n;; Listedeki 'k' tamsayının tüm olası kombinasyonlarını dikkate alır ve toplamlarının asal olup olmadığını kontrol eder.\n;; Örnek:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) ve (3+4) asal\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Sadece (1+2+5) asal",
      "vi": "(defun count-prime-sums (numbers k)\n;; Hàm này đếm số cách chọn 'k' số nguyên từ danh sách 'n' số nguyên sao cho tổng của chúng là một số nguyên tố.\n;; Nó xem xét tất cả các tổ hợp có thể của 'k' số nguyên từ danh sách và kiểm tra xem tổng của chúng có phải là số nguyên tố không.\n;; Ví dụ:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) và (3+4) là số nguyên tố\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Chỉ có (1+2+5) là số nguyên tố"
    },
    "prompt_bertscore": {
      "es": "0.9950825076567192",
      "arb": "0.977619520447275",
      "sw": "0.9622719467958523",
      "tr": "0.9886061640830768",
      "vi": "0.986529880710119"
    },
    "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-prime-sums (numbers k)` para resolver el siguiente problema:\nEsta función cuenta el número de formas de seleccionar 'k' enteros de una lista de 'n' enteros tal que su suma sea un número primo.\nConsidera todas las combinaciones posibles de 'k' enteros de la lista y verifica si su suma es prima.\nEjemplo:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) y (3+4) son primos\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Solo (1+2+5) es primo",
      "arb": "اكتب دالة Common Lisp `(defun count-prime-sums (numbers k)` لحل المشكلة التالية:\nهذه الدالة تحسب عدد الطرق لاختيار 'k' أعداد صحيحة من قائمة تحتوي على 'n' أعداد صحيحة بحيث يكون مجموعها عددًا أوليًا.\nتعتبر جميع التوليفات الممكنة من 'k' أعداد صحيحة من القائمة وتتحقق مما إذا كان مجموعها أوليًا.\nمثال:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) و (3+4) هما أعداد أولية\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; فقط (1+2+5) هو عدد أولي",
      "sw": "Andika kazi ya Common Lisp `(defun count-prime-sums (numbers k)` kutatua tatizo lifuatalo:\nKazi hii inahesabu idadi ya njia za kuchagua nambari 'k' kutoka kwenye orodha ya nambari 'n' ili jumla yao iwe nambari ya kwanza.\nInazingatia mchanganyiko wote unaowezekana wa nambari 'k' kutoka kwenye orodha na kuangalia kama jumla yao ni ya kwanza.\nMfano:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) na (3+4) ni nambari za kwanza\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Ni (1+2+5) pekee ndiyo ya kwanza",
      "tr": "Common Lisp fonksiyonu `(defun count-prime-sums (numbers k)` yazın:\nBu fonksiyon, 'n' tamsayıdan oluşan bir listeden 'k' tamsayı seçmenin toplamlarının asal sayı olduğu yolların sayısını sayar.\nListedeki 'k' tamsayının tüm olası kombinasyonlarını dikkate alır ve toplamlarının asal olup olmadığını kontrol eder.\nÖrnek:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) ve (3+4) asal\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Sadece (1+2+5) asal",
      "vi": "Viết một hàm Common Lisp `(defun count-prime-sums (numbers k)` để giải quyết vấn đề sau:\nHàm này đếm số cách chọn 'k' số nguyên từ một danh sách 'n' số nguyên sao cho tổng của chúng là một số nguyên tố.\nNó xem xét tất cả các tổ hợp có thể của 'k' số nguyên từ danh sách và kiểm tra xem tổng của chúng có phải là số nguyên tố không.\nVí dụ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) và (3+4) là số nguyên tố\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Chỉ có (1+2+5) là số nguyên tố"
    },
    "instruction_bertscore": {
      "es": "0.9914132086278618",
      "arb": "0.9860714417906905",
      "sw": "0.9856817289831001",
      "tr": "0.9519328382022243",
      "vi": "0.9868695386616887"
    },
    "level": "hard",
    "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)",
    "entry_point": "count-prime-sums",
    "signature": "(defun count-prime-sums (numbers k)",
    "docstring": {
      "es": "Esta función cuenta el número de formas de seleccionar 'k' enteros de una lista de 'n' enteros de tal manera que su suma sea un número primo.\nConsidera todas las combinaciones posibles de 'k' enteros de la lista y verifica si su suma es prima.\nEjemplo:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) y (3+4) son primos\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Solo (1+2+5) es primo",
      "arb": "هذه الدالة تحسب عدد الطرق لاختيار 'k' من الأعداد الصحيحة من قائمة تحتوي على 'n' من الأعداد الصحيحة بحيث يكون مجموعها عددًا أوليًا. \nتأخذ في الاعتبار جميع التوليفات الممكنة من 'k' أعداد صحيحة من القائمة وتتحقق مما إذا كان مجموعها أوليًا.\nمثال:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) و (3+4) هما أعداد أولية\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; فقط (1+2+5) هو عدد أولي",
      "sw": "Kazi ya kazi hii ni kuhesabu idadi ya njia za kuchagua nambari 'k' kutoka kwenye orodha ya nambari 'n' ili jumla yao iwe nambari ya kwanza.\nInazingatia mchanganyiko wote unaowezekana wa nambari 'k' kutoka kwenye orodha na kuangalia kama jumla yao ni ya kwanza.\nMfano:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) na (3+4) ni nambari za kwanza\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Ni (1+2+5) pekee ndiyo ya kwanza",
      "tr": "Bu fonksiyon, 'n' tamsayısından oluşan bir listeden 'k' tamsayısını seçmenin toplamlarının asal sayı olacak şekilde kaç farklı yolu olduğunu sayar.\nListedeki 'k' tamsayısının tüm olası kombinasyonlarını dikkate alır ve toplamlarının asal olup olmadığını kontrol eder.\nÖrnek:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) ve (3+4) asaldır\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Sadece (1+2+5) asaldır",
      "vi": "Hàm này đếm số cách chọn 'k' số nguyên từ danh sách 'n' số nguyên sao cho tổng của chúng là một số nguyên tố. Nó xem xét tất cả các tổ hợp có thể của 'k' số nguyên từ danh sách và kiểm tra xem tổng của chúng có phải là số nguyên tố hay không.\nVí dụ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) và (3+4) là số nguyên tố\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Chỉ có (1+2+5) là số nguyên tố"
    },
    "docstring_bertscore": {
      "es": "0.9900323302189072",
      "arb": "0.9817349433119369",
      "sw": "0.9563162134509022",
      "tr": "0.9889913083919034",
      "vi": "0.9841786928898091"
    }
  },
  {
    "task_id": "Common Lisp/37",
    "prompt": {
      "es": "(defun calculate-table-tennis-scores (record)\n;; Esta función toma una cadena de registros de partidos de tenis de mesa (compuesta por 'W', 'L' y 'E') \n;; y calcula las puntuaciones bajo los sistemas de 11 puntos y 21 puntos.\n;; 'W' indica un punto ganado por el jugador, 'L' indica un punto ganado por el oponente, y 'E' marca el final del registro.\n;; La función devuelve dos listas: la primera lista contiene las puntuaciones bajo el sistema de 11 puntos, \n;; y la segunda lista contiene las puntuaciones bajo el sistema de 21 puntos.\n;; Ejemplo:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "arb": "(defun calculate-table-tennis-scores (record)\n;; تأخذ هذه الدالة سلسلة من سجلات مباريات تنس الطاولة (مكونة من 'W'، 'L'، و 'E') \n;; وتحسب النقاط وفقًا لنظامي 11 نقطة و21 نقطة.\n;; 'W' تشير إلى نقطة فاز بها اللاعب، 'L' تشير إلى نقطة فاز بها الخصم، و 'E' تشير إلى نهاية السجل.\n;; تعيد الدالة قائمتين: تحتوي القائمة الأولى على النقاط وفقًا لنظام 11 نقطة، \n;; وتحتوي القائمة الثانية على النقاط وفقًا لنظام 21 نقطة.\n;; مثال:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "sw": "(defun calculate-table-tennis-scores (record)\n;; Kazi ya kazi hii ni kuchukua kamba ya rekodi za mechi za tenisi ya meza (iliyoundwa na 'W', 'L', na 'E') \n;; na kuhesabu alama chini ya mifumo ya alama ya pointi 11 na pointi 21.\n;; 'W' inaashiria pointi iliyoshindwa na mchezaji, 'L' inaashiria pointi iliyoshindwa na mpinzani, na 'E' inaashiria mwisho wa rekodi.\n;; Kazi hii inarejesha orodha mbili: orodha ya kwanza ina alama chini ya mfumo wa pointi 11, \n;; na orodha ya pili ina alama chini ya mfumo wa pointi 21.\n;; Mfano:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "tr": "(defun calculate-table-tennis-scores (record)\n;; Bu fonksiyon, masa tenisi maç kayıtlarını içeren bir dizeyi ('W', 'L' ve 'E' ile oluşturulmuş) alır\n;; ve 11 puanlık ve 21 puanlık sistemler altında skorları hesaplar.\n;; 'W', oyuncunun kazandığı bir puanı, 'L', rakibin kazandığı bir puanı ve 'E', kaydın sonunu belirtir.\n;; Fonksiyon iki liste döndürür: ilk liste 11 puanlık sistem altındaki skorları,\n;; ikinci liste ise 21 puanlık sistem altındaki skorları içerir.\n;; Örnek:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "vi": "(defun calculate-table-tennis-scores (record)\n;; Hàm này nhận một chuỗi ghi lại các trận đấu bóng bàn (bao gồm 'W', 'L', và 'E') \n;; và tính toán điểm số theo hệ thống 11 điểm và 21 điểm.\n;; 'W' chỉ ra một điểm thắng bởi người chơi, 'L' chỉ ra một điểm thắng bởi đối thủ, và 'E' đánh dấu kết thúc của bản ghi.\n;; Hàm trả về hai danh sách: danh sách đầu tiên chứa điểm số theo hệ thống 11 điểm, \n;; và danh sách thứ hai chứa điểm số theo hệ thống 21 điểm.\n;; Ví dụ:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "prompt_bertscore": {
      "es": "0.9965795848385792",
      "arb": "0.9801349755927008",
      "sw": "0.975250853153434",
      "tr": "0.9922126959115272",
      "vi": "0.9722267056021778"
    },
    "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun calculate-table-tennis-scores (record)` para resolver el siguiente problema:\nEsta función toma una cadena de registros de partidos de tenis de mesa (compuesta por 'W', 'L' y 'E') \ny calcula las puntuaciones bajo los sistemas de 11 puntos y 21 puntos.\n'W' indica un punto ganado por el jugador, 'L' indica un punto ganado por el oponente, y 'E' marca el final del registro.\nLa función devuelve dos listas: la primera lista contiene las puntuaciones bajo el sistema de 11 puntos, \ny la segunda lista contiene las puntuaciones bajo el sistema de 21 puntos.\nEjemplo:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "arb": "اكتب دالة Common Lisp `(defun calculate-table-tennis-scores (record)` لحل المشكلة التالية:\nتأخذ هذه الدالة سلسلة من سجلات مباريات تنس الطاولة (مكونة من 'W'، 'L'، و 'E') \nوتحسب النقاط تحت نظامي 11 نقطة و21 نقطة.\n'W' تشير إلى نقطة فاز بها اللاعب، 'L' تشير إلى نقطة فاز بها الخصم، و 'E' تشير إلى نهاية السجل.\nتعيد الدالة قائمتين: تحتوي القائمة الأولى على النقاط تحت نظام 11 نقطة، \nوتحتوي القائمة الثانية على النقاط تحت نظام 21 نقطة.\nمثال:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "sw": "Andika kazi ya Common Lisp `(defun calculate-table-tennis-scores (record)` kutatua tatizo lifuatalo:\nKazi hii inachukua kamba ya rekodi za mechi za tenisi ya meza (iliyoundwa na 'W', 'L', na 'E') \nna inahesabu alama chini ya mifumo ya pointi 11 na pointi 21.\n'W' inaashiria pointi iliyoshindwa na mchezaji, 'L' inaashiria pointi iliyoshindwa na mpinzani, na 'E' inaashiria mwisho wa rekodi.\nKazi inarudisha orodha mbili: orodha ya kwanza ina alama chini ya mfumo wa pointi 11, \nna orodha ya pili ina alama chini ya mfumo wa pointi 21.\nMfano:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "tr": "Bir Common Lisp fonksiyonu `(defun calculate-table-tennis-scores (record)` yazın: \nBu fonksiyon, masa tenisi maç kayıtlarından oluşan bir dizeyi ('W', 'L' ve 'E' ile) alır \nve 11 puanlık ve 21 puanlık sistemler altında puanları hesaplar. \n'W', oyuncu tarafından kazanılan bir puanı, 'L' rakip tarafından kazanılan bir puanı ve 'E' kaydın sonunu işaret eder. \nFonksiyon iki liste döndürür: ilk liste 11 puanlık sistem altındaki puanları, \nikinci liste ise 21 puanlık sistem altındaki puanları içerir. \nÖrnek:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "vi": "Viết một hàm Common Lisp `(defun calculate-table-tennis-scores (record)` để giải quyết vấn đề sau:\nHàm này nhận vào một chuỗi các bản ghi trận đấu bóng bàn (bao gồm 'W', 'L', và 'E') \nvà tính toán điểm số theo hệ thống 11 điểm và 21 điểm.\n'W' biểu thị một điểm thắng của người chơi, 'L' biểu thị một điểm thắng của đối thủ, và 'E' đánh dấu kết thúc của bản ghi.\nHàm trả về hai danh sách: danh sách đầu tiên chứa điểm số theo hệ thống 11 điểm, \nvà danh sách thứ hai chứa điểm số theo hệ thống 21 điểm.\nVí dụ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "instruction_bertscore": {
      "es": "0.9970102155046628",
      "arb": "0.9929388885845908",
      "sw": "0.9903392141576062",
      "tr": "0.9732317753302143",
      "vi": "0.9762203680432653"
    },
    "level": "hard",
    "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)",
    "entry_point": "calculate-table-tennis-scores",
    "signature": "(defun calculate-table-tennis-scores (record)",
    "docstring": {
      "es": "Esta función toma una cadena de registros de partidos de tenis de mesa (compuesta por 'W', 'L' y 'E') y calcula los puntajes bajo los sistemas de 11 puntos y 21 puntos. 'W' indica un punto ganado por el jugador, 'L' indica un punto ganado por el oponente, y 'E' marca el final del registro. La función devuelve dos listas: la primera lista contiene los puntajes bajo el sistema de 11 puntos, y la segunda lista contiene los puntajes bajo el sistema de 21 puntos.\nEjemplo:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "arb": "هذه الدالة تأخذ سلسلة من سجلات مباريات تنس الطاولة (تتكون من 'W'، 'L'، و 'E') وتحسب النقاط وفقًا لنظامي 11 نقطة و21 نقطة. تشير 'W' إلى نقطة فاز بها اللاعب، وتشير 'L' إلى نقطة فاز بها الخصم، وتحدد 'E' نهاية السجل. تعيد الدالة قائمتين: تحتوي القائمة الأولى على النقاط وفقًا لنظام 11 نقطة، وتحتوي القائمة الثانية على النقاط وفقًا لنظام 21 نقطة.\n\nمثال:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "sw": "Kazi hii inachukua mfuatano wa rekodi za mechi za tenisi ya meza (zinazojumuisha 'W', 'L', na 'E') na inahesabu alama chini ya mifumo ya pointi 11 na 21. 'W' inaashiria pointi iliyoshindwa na mchezaji, 'L' inaashiria pointi iliyoshindwa na mpinzani, na 'E' inaashiria mwisho wa rekodi. Kazi hii inarudisha orodha mbili: orodha ya kwanza ina alama chini ya mfumo wa pointi 11, na orodha ya pili ina alama chini ya mfumo wa pointi 21. Mfano:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "tr": "Bu fonksiyon, masa tenisi maç kayıtlarından oluşan (W, L ve E ile) bir dize alır ve 11 puanlık ve 21 puanlık sistemler altında skorları hesaplar. \n'W', oyuncunun kazandığı bir puanı, 'L', rakibin kazandığı bir puanı ve 'E', kaydın sonunu belirtir. \nFonksiyon iki liste döndürür: ilk liste 11 puanlık sistem altındaki skorları, ikinci liste ise 21 puanlık sistem altındaki skorları içerir.\nÖrnek:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "vi": "Hàm này nhận vào một chuỗi các bản ghi trận đấu bóng bàn (bao gồm 'W', 'L', và 'E') và tính toán điểm số theo hệ thống 11 điểm và 21 điểm. 'W' biểu thị một điểm thắng của người chơi, 'L' biểu thị một điểm thắng của đối thủ, và 'E' đánh dấu kết thúc bản ghi. Hàm trả về hai danh sách: danh sách đầu tiên chứa điểm số theo hệ thống 11 điểm, và danh sách thứ hai chứa điểm số theo hệ thống 21 điểm. Ví dụ: \n>>> calculate-table-tennis-scores \"WWLLWE\" \n((\"2:2\") (\"2:2\")) \n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\" \n((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "docstring_bertscore": {
      "es": "0.9951160761911142",
      "arb": "0.9785721517547183",
      "sw": "0.9762108337849755",
      "tr": "0.96908516749573",
      "vi": "0.9687129341616706"
    }
  },
  {
    "task_id": "Common Lisp/38",
    "prompt": {
      "es": "(defun count-output-sequences (n)\n;; Esta función calcula el número total de diferentes secuencias de salida que se pueden obtener utilizando una pila\n;; con operaciones de push y pop en una secuencia de números del 1 al n.\n;; Las operaciones son:\n;; 1. Empujar el siguiente número de la secuencia de entrada en la pila.\n;; 2. Sacar el número superior de la pila y añadirlo a la secuencia de salida.\n;; Cuenta todas las posibles secuencias de estas operaciones que resultan en que todos los números sean movidos de la secuencia de entrada a la secuencia de salida.\n;; Ejemplo:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "arb": "(defun count-output-sequences (n)\n;; تقوم هذه الدالة بحساب العدد الإجمالي لتسلسلات المخرجات المختلفة التي يمكن الحصول عليها باستخدام مكدس \n;; مع العمليات دفع وإزالة على تسلسل الأرقام من 1 إلى n.\n;; العمليات هي: \n;; 1. دفع الرقم التالي من تسلسل الإدخال إلى المكدس.\n;; 2. إزالة الرقم العلوي من المكدس وإضافته إلى تسلسل المخرجات.\n;; تقوم بعد جميع التسلسلات الممكنة لهذه العمليات التي تؤدي إلى نقل جميع الأرقام من تسلسل الإدخال إلى تسلسل المخرجات.\n;; مثال:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "sw": "(defun count-output-sequences (n)\n;; Kazi ya hii kazi ni kuhesabu jumla ya idadi ya mlolongo tofauti ya matokeo ambayo yanaweza kupatikana kwa kutumia stack \n;; na operesheni za push na pop kwenye mlolongo wa namba kutoka 1 hadi n.\n;; Operesheni ni:\n;; 1. Push namba inayofuata kutoka kwenye mlolongo wa ingizo kwenye stack.\n;; 2. Pop namba ya juu kutoka kwenye stack na uiongeze kwenye mlolongo wa matokeo.\n;; Inahesabu milolongo yote inayowezekana ya operesheni hizi ambazo zinasababisha namba zote kuhamishwa kutoka kwenye mlolongo wa ingizo hadi kwenye mlolongo wa matokeo.\n;; Mfano:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "tr": "(defun count-output-sequences (n)\n;; Bu fonksiyon, 1'den n'e kadar olan bir sayı dizisi üzerinde yığın kullanarak \n;; push ve pop işlemleri ile elde edilebilecek farklı çıktı dizilerinin toplam sayısını hesaplar.\n;; İşlemler şunlardır: \n;; 1. Girdi dizisinden bir sonraki sayıyı yığına ekleyin.\n;; 2. Yığının üstündeki sayıyı çıkarın ve çıktı dizisine ekleyin.\n;; Bu işlemlerin tüm sayıları girdi dizisinden çıktı dizisine taşıdığı tüm olası dizilerini sayar.\n;; Örnek:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "vi": "(defun count-output-sequences (n)\n;; Hàm này tính tổng số lượng các dãy đầu ra khác nhau có thể thu được bằng cách sử dụng một ngăn xếp \n;; với các thao tác đẩy và bật ra trên một dãy số từ 1 đến n.\n;; Các thao tác là: \n;; 1. Đẩy số tiếp theo từ dãy đầu vào vào ngăn xếp.\n;; 2. Bật số trên cùng từ ngăn xếp và thêm nó vào dãy đầu ra.\n;; Nó đếm tất cả các dãy có thể của các thao tác này mà kết quả là tất cả các số được chuyển từ dãy đầu vào sang dãy đầu ra.\n;; Ví dụ:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14"
    },
    "prompt_bertscore": {
      "es": "0.9897423298625964",
      "arb": "0.9830486846521016",
      "sw": "0.9647139087002952",
      "tr": "0.9494861091686365",
      "vi": "0.9860474075145853"
    },
    "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun count-output-sequences (n)` para resolver el siguiente problema:\nEsta función calcula el número total de diferentes secuencias de salida que se pueden obtener utilizando una pila con operaciones de push y pop en una secuencia de números del 1 al n.\nLas operaciones son:\n1. Empujar el siguiente número de la secuencia de entrada en la pila.\n2. Sacar el número superior de la pila y añadirlo a la secuencia de salida.\nCuenta todas las posibles secuencias de estas operaciones que resultan en que todos los números sean movidos de la secuencia de entrada a la secuencia de salida.\nEjemplo:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "arb": "اكتب دالة Common Lisp `(defun count-output-sequences (n)` لحل المشكلة التالية:\nهذه الدالة تحسب العدد الإجمالي لتسلسلات الإخراج المختلفة التي يمكن الحصول عليها باستخدام مكدس \nمع العمليات دفع وسحب على تسلسل من الأرقام من 1 إلى n.\nالعمليات هي: \n1. دفع الرقم التالي من تسلسل الإدخال إلى المكدس.\n2. سحب الرقم العلوي من المكدس وإضافته إلى تسلسل الإخراج.\nتحسب جميع التسلسلات الممكنة لهذه العمليات التي تؤدي إلى نقل جميع الأرقام من تسلسل الإدخال إلى تسلسل الإخراج.\nمثال:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "sw": "Andika kazi ya Common Lisp `(defun count-output-sequences (n)` kutatua tatizo lifuatalo:\nKazi hii inahesabu jumla ya idadi ya mlolongo tofauti wa matokeo ambao unaweza kupatikana kwa kutumia stack \nna operesheni za push na pop kwenye mlolongo wa namba kutoka 1 hadi n.\nOperesheni ni:\n1. Push namba inayofuata kutoka kwenye mlolongo wa ingizo kwenye stack.\n2. Pop namba ya juu kutoka kwenye stack na uiongeze kwenye mlolongo wa matokeo.\nInahesabu milolongo yote inayowezekana ya operesheni hizi ambayo husababisha namba zote kuhamishwa kutoka kwenye mlolongo wa ingizo kwenda kwenye mlolongo wa matokeo.\nMfano:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "tr": "Bir Common Lisp fonksiyonu `(defun count-output-sequences (n)` yazın ve aşağıdaki problemi çözün:\nBu fonksiyon, 1'den n'ye kadar olan bir sayı dizisi üzerinde bir yığın kullanarak elde edilebilecek farklı çıktı dizilerinin toplam sayısını hesaplar.\nİşlemler şunlardır:\n1. Giriş dizisinden bir sonraki sayıyı yığına ekleyin.\n2. Yığının en üstündeki sayıyı çıkarın ve çıktı dizisine ekleyin.\nBu işlemlerin tüm sayıları giriş dizisinden çıktı dizisine taşıyan tüm olası dizilerini sayar.\nÖrnek:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "vi": "Viết một hàm Common Lisp `(defun count-output-sequences (n)` để giải quyết vấn đề sau:\nHàm này tính tổng số lượng các dãy đầu ra khác nhau có thể thu được bằng cách sử dụng một ngăn xếp với các thao tác đẩy và bật trên một dãy số từ 1 đến n.\nCác thao tác là:\n1. Đẩy số tiếp theo từ dãy đầu vào vào ngăn xếp.\n2. Bật số trên cùng từ ngăn xếp và thêm nó vào dãy đầu ra.\nNó đếm tất cả các dãy có thể của các thao tác này mà kết quả là tất cả các số được chuyển từ dãy đầu vào sang dãy đầu ra.\nVí dụ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14"
    },
    "instruction_bertscore": {
      "es": "0.9861212980163303",
      "arb": "0.9758705799422628",
      "sw": "0.9804347088376825",
      "tr": "0.9481048334989199",
      "vi": "0.9878323001185648"
    },
    "level": "easy",
    "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)",
    "entry_point": "count-output-sequences",
    "signature": "(defun count-output-sequences (n)",
    "docstring": {
      "es": "Esta función calcula el número total de diferentes secuencias de salida que se pueden obtener utilizando una pila con operaciones de push y pop en una secuencia de números del 1 al n.  \nLas operaciones son:  \n1. Empujar el siguiente número de la secuencia de entrada en la pila.  \n2. Sacar el número superior de la pila y añadirlo a la secuencia de salida.  \nCuenta todas las posibles secuencias de estas operaciones que resultan en que todos los números sean movidos de la secuencia de entrada a la secuencia de salida.  \nEjemplo:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "arb": "هذه الدالة تحسب العدد الإجمالي لتسلسلات المخرجات المختلفة التي يمكن الحصول عليها باستخدام مكدس مع عمليات الدفع والسحب على تسلسل من الأرقام من 1 إلى n.  \nالعمليات هي:  \n1. دفع الرقم التالي من تسلسل الإدخال إلى المكدس.  \n2. سحب الرقم العلوي من المكدس وإضافته إلى تسلسل المخرجات.  \nتحسب جميع تسلسلات العمليات الممكنة التي تؤدي إلى نقل جميع الأرقام من تسلسل الإدخال إلى تسلسل المخرجات.  \nمثال:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "sw": "Kazi hii inahesabu jumla ya idadi ya mfuatano tofauti wa matokeo ambayo yanaweza kupatikana kwa kutumia staki na operesheni za kusukuma (push) na kutoa (pop) kwenye mfuatano wa namba kutoka 1 hadi n. \nOperesheni ni: \n1. Sukuma namba inayofuata kutoka kwenye mfuatano wa ingizo kwenye staki.\n2. Toa namba ya juu kutoka kwenye staki na uiongeze kwenye mfuatano wa matokeo.\nInahesabu mfuatano yote inayowezekana ya operesheni hizi ambayo husababisha namba zote kuhamishwa kutoka kwenye mfuatano wa ingizo hadi kwenye mfuatano wa matokeo.\nMfano:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "tr": "Bu fonksiyon, 1'den n'e kadar olan bir sayı dizisinde push ve pop işlemleri kullanarak elde edilebilecek farklı çıktı dizilerinin toplam sayısını hesaplar.\nİşlemler şunlardır:\n1. Girdi dizisinden bir sonraki sayıyı yığına push et.\n2. Yığının tepesindeki sayıyı pop et ve çıktı dizisine ekle.\nBu işlemlerin tüm sayıların girdi dizisinden çıktı dizisine taşınmasıyla sonuçlanan tüm olası dizilerini sayar.\nÖrnek:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "vi": "Hàm này tính tổng số các dãy đầu ra khác nhau có thể thu được bằng cách sử dụng một ngăn xếp với các thao tác đẩy và bật trên một dãy số từ 1 đến n.  \nCác thao tác là:  \n1. Đẩy số tiếp theo từ dãy đầu vào vào ngăn xếp.  \n2. Bật số trên cùng từ ngăn xếp và thêm nó vào dãy đầu ra.  \nNó đếm tất cả các dãy có thể của các thao tác này mà kết quả là tất cả các số được chuyển từ dãy đầu vào sang dãy đầu ra.  \nVí dụ:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  "
    },
    "docstring_bertscore": {
      "es": "0.9836815210460788",
      "arb": "0.965623635845435",
      "sw": "0.9532002986636079",
      "tr": "0.9618005969016565",
      "vi": "0.9843395834984473"
    }
  },
  {
    "task_id": "Common Lisp/39",
    "prompt": {
      "es": "(defun max-herb-value (time-limit herb-info)\n;; Esta función calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado.\n;; 'time-limit' es el tiempo total disponible para recolectar hierbas.\n;; 'herb-info' es una lista de pares, cada par contiene dos enteros: el tiempo requerido para recolectar una hierba y su valor.\n;; La función utiliza un enfoque de programación dinámica para determinar el valor máximo que se puede obtener.\n;; Ejemplo:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "arb": "(defun max-herb-value (time-limit herb-info)\n;; تقوم هذه الدالة بحساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n;; 'time-limit' هو إجمالي الوقت المتاح لجمع الأعشاب.\n;; 'herb-info' هي قائمة من الأزواج، يحتوي كل زوج على عددين صحيحين: الوقت المطلوب لجمع عشبة وقيمتها.\n;; تستخدم الدالة نهج البرمجة الديناميكية لتحديد القيمة القصوى التي يمكن الحصول عليها.\n;; مثال:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "sw": "(defun max-herb-value (time-limit herb-info)\n;; Kazi ya hii function ni kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliowekwa.\n;; 'time-limit' ni muda wote unaopatikana kwa ajili ya kukusanya mimea.\n;; 'herb-info' ni orodha ya jozi, kila jozi ina namba mbili: muda unaohitajika kukusanya mmea na thamani yake.\n;; Function inatumia mbinu ya programu ya nguvu ili kubaini thamani ya juu inayoweza kupatikana.\n;; Mfano:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "tr": "(defun max-herb-value (time-limit herb-info)\n;; Bu fonksiyon, belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n;; 'time-limit', ot toplamak için mevcut toplam zamandır.\n;; 'herb-info', her biri iki tam sayı içeren çiftlerden oluşan bir listedir: bir otu toplamak için gereken zaman ve onun değeri.\n;; Fonksiyon, elde edilebilecek maksimum değeri belirlemek için dinamik programlama yaklaşımını kullanır.\n;; Örnek:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "vi": "(defun max-herb-value (time-limit herb-info)\n;; Hàm này tính toán tổng giá trị tối đa của các loại thảo mộc có thể thu thập trong một giới hạn thời gian cho trước.\n;; 'time-limit' là tổng thời gian có sẵn để thu thập thảo mộc.\n;; 'herb-info' là một danh sách các cặp, mỗi cặp chứa hai số nguyên: thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó.\n;; Hàm sử dụng phương pháp lập trình động để xác định giá trị tối đa có thể đạt được.\n;; Ví dụ:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14"
    },
    "prompt_bertscore": {
      "es": "0.9979721824400148",
      "arb": "0.995565378113015",
      "sw": "0.9728736447532085",
      "tr": "0.9952366448324024",
      "vi": "0.9801310029850802"
    },
    "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun max-herb-value (time-limit herb-info)` para resolver el siguiente problema:\nEsta función calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado.\n'time-limit' es el tiempo total disponible para recolectar hierbas.\n'herb-info' es una lista de pares, cada par contiene dos enteros: el tiempo requerido para recolectar una hierba y su valor.\nLa función utiliza un enfoque de programación dinámica para determinar el valor máximo que se puede obtener.\nEjemplo:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "arb": "اكتب دالة Common Lisp `(defun max-herb-value (time-limit herb-info)` لحل المشكلة التالية:\nتحسب هذه الدالة القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n'time-limit' هو الوقت الإجمالي المتاح لجمع الأعشاب.\n'herb-info' هو قائمة من الأزواج، يحتوي كل زوج على عددين صحيحين: الوقت المطلوب لجمع عشب وقيمته.\nتستخدم الدالة نهج البرمجة الديناميكية لتحديد القيمة القصوى التي يمكن الحصول عليها.\nمثال:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "sw": "Andika kazi ya Common Lisp `(defun max-herb-value (time-limit herb-info)` kutatua tatizo lifuatalo:\nKazi hii inahesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya kikomo cha muda kilichopewa.\n'time-limit' ni muda wote unaopatikana kwa ajili ya kukusanya mimea.\n'herb-info' ni orodha ya jozi, kila jozi ikiwa na namba mbili: muda unaohitajika kukusanya mmea na thamani yake.\nKazi hii inatumia mbinu ya programu ya nguvu ili kubaini thamani ya juu inayoweza kupatikana.\nMfano:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "tr": "Bir Common Lisp fonksiyonu `(defun max-herb-value (time-limit herb-info)` yazın ve aşağıdaki problemi çözün:\nBu fonksiyon, verilen bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n'time-limit', ot toplamak için mevcut toplam zamandır.\n'herb-info', her biri iki tam sayı içeren çiftlerden oluşan bir listedir: bir otu toplamak için gereken zaman ve onun değeri.\nFonksiyon, elde edilebilecek maksimum değeri belirlemek için dinamik programlama yaklaşımını kullanır.\nÖrnek:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "vi": "Viết một hàm Common Lisp `(defun max-herb-value (time-limit herb-info)` để giải quyết vấn đề sau:\nHàm này tính toán giá trị tổng tối đa của các loại thảo mộc có thể thu thập được trong một giới hạn thời gian cho trước.\n'time-limit' là tổng thời gian có sẵn để thu thập thảo mộc.\n'herb-info' là một danh sách các cặp, mỗi cặp chứa hai số nguyên: thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó.\nHàm sử dụng phương pháp lập trình động để xác định giá trị tối đa có thể đạt được.\nVí dụ:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14"
    },
    "instruction_bertscore": {
      "es": "0.9967237904952105",
      "arb": "0.9940168556624671",
      "sw": "0.979987591849973",
      "tr": "0.991676592513114",
      "vi": "0.9807956202400229"
    },
    "level": "middle",
    "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)",
    "entry_point": "max-herb-value",
    "signature": "(defun max-herb-value (time-limit herb-info)",
    "docstring": {
      "es": "Esta función calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado.\n'time-limit' es el tiempo total disponible para recolectar hierbas.\n'herb-info' es una lista de pares, cada par contiene dos enteros: el tiempo requerido para recolectar una hierba y su valor.\nLa función utiliza un enfoque de programación dinámica para determinar el valor máximo que se puede obtener.\nEjemplo:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "arb": "هذه الدالة تحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n'time-limit' هو إجمالي الوقت المتاح لجمع الأعشاب.\n'herb-info' هو قائمة من الأزواج، كل زوج يحتوي على عددين صحيحين: الوقت المطلوب لجمع عشبة وقيمتها.\nتستخدم الدالة نهج البرمجة الديناميكية لتحديد القيمة القصوى التي يمكن الحصول عليها.\nمثال:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "sw": "Kazi ya hii kazi ni kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliowekwa.\n\n'time-limit' ni muda wote unaopatikana kwa ajili ya kukusanya mimea.\n\n'herb-info' ni orodha ya jozi, kila jozi ikiwa na namba mbili: muda unaohitajika kukusanya mmea na thamani yake.\n\nKazi hii inatumia mbinu ya programu ya nguvu ili kuamua thamani ya juu inayoweza kupatikana.\n\nMfano:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "tr": "Bu fonksiyon, belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n'time-limit', ot toplamak için mevcut toplam zamanı ifade eder.\n'herb-info', her biri iki tam sayı içeren çiftlerden oluşan bir listedir: bir otu toplamak için gereken zaman ve onun değeri.\nFonksiyon, elde edilebilecek maksimum değeri belirlemek için dinamik programlama yaklaşımını kullanır.\nÖrnek:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "vi": "Hàm này tính tổng giá trị tối đa của các loại thảo mộc có thể thu thập trong một giới hạn thời gian nhất định.\n'time-limit' là tổng thời gian có sẵn để thu thập thảo mộc.\n'herb-info' là một danh sách các cặp, mỗi cặp chứa hai số nguyên: thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó.\nHàm sử dụng phương pháp lập trình động để xác định giá trị tối đa có thể đạt được.\nVí dụ:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14"
    },
    "docstring_bertscore": {
      "es": "0.9975596271386054",
      "arb": "0.9949096992252189",
      "sw": "0.9394892407215316",
      "tr": "0.989205431942659",
      "vi": "0.972797767947653"
    }
  },
  {
    "task_id": "Common Lisp/40",
    "prompt": {
      "es": "(defun min-box-space (box-capacity item-volumes)\n;; Esta función calcula el espacio mínimo restante en una caja después de empacar de manera óptima un conjunto dado de artículos.\n;; Cada artículo tiene un volumen específico, y la caja tiene una capacidad fija.\n;; La función devuelve el espacio restante más pequeño posible en la caja.\n;; Ejemplo:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "arb": "(defun min-box-space (box-capacity item-volumes)\n;; هذه الدالة تحسب الحد الأدنى من المساحة المتبقية في الصندوق بعد تعبئة مجموعة معينة من العناصر بشكل مثالي.\n;; كل عنصر له حجم محدد، والصندوق له سعة ثابتة.\n;; تعيد الدالة أصغر مساحة متبقية ممكنة في الصندوق.\n;; مثال:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "sw": "(defun min-box-space (box-capacity item-volumes)\n;; Kazi ya hii function ni kuhesabu nafasi ndogo zaidi inayobaki kwenye boksi baada ya kupakia vitu vilivyopewa kwa njia bora.\n;; Kila kitu kina ujazo maalum, na boksi lina uwezo uliowekwa.\n;; Function inarudisha nafasi ndogo zaidi inayoweza kubaki kwenye boksi.\n;; Mfano:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "tr": "(defun min-box-space (box-capacity item-volumes)\n;; Bu fonksiyon, belirli bir öğe setini en iyi şekilde paketledikten sonra bir kutuda kalan minimum alanı hesaplar.\n;; Her öğenin belirli bir hacmi vardır ve kutunun sabit bir kapasitesi vardır.\n;; Fonksiyon, kutuda kalan en küçük olası alanı döndürür.\n;; Örnek:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "vi": "(defun min-box-space (box-capacity item-volumes)\n;; Hàm này tính toán không gian còn lại tối thiểu trong một hộp sau khi đóng gói tối ưu một tập hợp các món đồ cho trước.\n;; Mỗi món đồ có một thể tích cụ thể, và hộp có dung tích cố định.\n;; Hàm trả về không gian còn lại nhỏ nhất có thể trong hộp.\n;; Ví dụ:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9939582597000618",
      "sw": "0.9551945476891982",
      "tr": "0.9978351274771008",
      "vi": "1"
    },
    "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun min-box-space (box-capacity item-volumes)` para resolver el siguiente problema:\nEsta función calcula el espacio mínimo restante en una caja después de empacar de manera óptima un conjunto dado de artículos.\nCada artículo tiene un volumen específico, y la caja tiene una capacidad fija.\nLa función devuelve el espacio restante más pequeño posible en la caja.\nEjemplo:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "arb": "اكتب دالة Common Lisp `(defun min-box-space (box-capacity item-volumes)` لحل المشكلة التالية:\nتحسب هذه الدالة الحد الأدنى للمساحة المتبقية في الصندوق بعد تعبئة مجموعة معينة من العناصر بشكل مثالي.\nكل عنصر له حجم محدد، والصندوق له سعة ثابتة.\nتعيد الدالة أصغر مساحة متبقية ممكنة في الصندوق.\nمثال:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "sw": "Andika kazi ya Common Lisp `(defun min-box-space (box-capacity item-volumes)` kutatua tatizo lifuatalo:  \nKazi hii inahesabu nafasi ndogo zaidi inayobaki kwenye sanduku baada ya kupakia seti fulani ya vitu kwa njia bora.  \nKila kitu kina ujazo maalum, na sanduku lina uwezo uliowekwa.  \nKazi inarudisha nafasi ndogo zaidi inayoweza kubaki kwenye sanduku.  \nMfano:  \n>>> min-box-space 10 '(2 3 4)  \n1  \n>>> min-box-space 15 '(5 5 6)  \n0",
      "tr": "Bir Common Lisp fonksiyonu `(defun min-box-space (box-capacity item-volumes)` yazın:\nBu fonksiyon, verilen bir dizi öğeyi en uygun şekilde paketledikten sonra bir kutuda kalan minimum alanı hesaplar.\nHer öğenin belirli bir hacmi vardır ve kutunun sabit bir kapasitesi vardır.\nFonksiyon, kutuda kalan en küçük olası alanı döndürür.\nÖrnek:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "vi": "Viết một hàm Common Lisp `(defun min-box-space (box-capacity item-volumes)` để giải quyết vấn đề sau:\nHàm này tính toán không gian còn lại tối thiểu trong một hộp sau khi đóng gói tối ưu một tập hợp các vật phẩm đã cho.\nMỗi vật phẩm có một thể tích cụ thể, và hộp có một dung tích cố định.\nHàm trả về không gian còn lại nhỏ nhất có thể trong hộp.\nVí dụ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0"
    },
    "instruction_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9938887390666996",
      "sw": "0.9886349654883269",
      "tr": "0.9725387539307836",
      "vi": "0.999999801369619"
    },
    "level": "middle",
    "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)",
    "entry_point": "min-box-space",
    "signature": "(defun min-box-space (box-capacity item-volumes)",
    "docstring": {
      "es": "Esta función calcula el espacio mínimo restante en una caja después de empacar de manera óptima un conjunto dado de artículos.  \nCada artículo tiene un volumen específico, y la caja tiene una capacidad fija.  \nLa función devuelve el menor espacio posible restante en la caja.  \nEjemplo:  \n>>> min-box-space 10 '(2 3 4)  \n1  \n>>> min-box-space 15 '(5 5 6)  \n0  ",
      "arb": "هذه الدالة تحسب الحد الأدنى من المساحة المتبقية في صندوق بعد تعبئة مجموعة معينة من العناصر بشكل مثالي. \nكل عنصر له حجم محدد، والصندوق له سعة ثابتة. \nتعيد الدالة أصغر مساحة ممكنة متبقية في الصندوق. \nمثال:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "sw": "Kazi ya kazi hii ni kuhesabu nafasi ndogo iliyobaki kwenye sanduku baada ya kupakia seti fulani ya vitu kwa njia bora.  \nKila kitu kina kiasi maalum, na sanduku lina uwezo uliowekwa.  \nKazi hii inarudisha nafasi ndogo zaidi inayoweza kubaki kwenye sanduku.  \nMfano:  \n>>> min-box-space 10 '(2 3 4)  \n1  \n>>> min-box-space 15 '(5 5 6)  \n0",
      "tr": "Bu fonksiyon, belirli bir dizi öğeyi en iyi şekilde paketledikten sonra bir kutuda kalan minimum alanı hesaplar. Her öğenin belirli bir hacmi vardır ve kutunun sabit bir kapasitesi vardır. Fonksiyon, kutuda mümkün olan en küçük kalan alanı döndürür.\nÖrnek:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "vi": "Hàm này tính toán không gian còn lại tối thiểu trong một hộp sau khi đóng gói tối ưu một tập hợp các vật phẩm cho trước. Mỗi vật phẩm có một thể tích cụ thể và hộp có một dung lượng cố định. Hàm trả về không gian còn lại nhỏ nhất có thể trong hộp. Ví dụ: >>> min-box-space 10 '(2 3 4) 1 >>> min-box-space 15 '(5 5 6) 0"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9737660910551982",
      "sw": "0.9609097396427151",
      "tr": "0.9959537005079383",
      "vi": "0.9947021304770375"
    }
  },
  {
    "task_id": "Common Lisp/41",
    "prompt": {
      "es": "(defun calculate-expression (a b c)\n  ;; Calcula el valor de la expresión (a+b)*c para los enteros dados a, b, y c.\n  ;; Devuelve el resultado del cálculo.\n  ;; Ejemplo:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "arb": "(defun calculate-expression (a b c)\n  ;; يحسب قيمة التعبير (a+b)*c للأعداد الصحيحة المعطاة a و b و c.\n  ;; يعيد نتيجة الحساب.\n  ;; مثال:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "sw": "(defun calculate-expression (a b c)\n  ;; Inahesabu thamani ya usemi (a+b)*c kwa namba kamili zilizotolewa a, b, na c.\n  ;; Inarudisha matokeo ya hesabu.\n  ;; Mfano:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "tr": "(defun calculate-expression (a b c)\n  ;; Verilen tamsayılar a, b ve c için (a+b)*c ifadesinin değerini hesaplar.\n  ;; Hesaplamanın sonucunu döndürür.\n  ;; Örnek:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "vi": "(defun calculate-expression (a b c)\n  ;; Tính giá trị của biểu thức (a+b)*c cho các số nguyên a, b, và c đã cho.\n  ;; Trả về kết quả của phép tính.\n  ;; Ví dụ:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "es": "0.9886107325818405",
      "arb": "0.9886107325818405",
      "sw": "0.9886107325818405",
      "tr": "0.9886107325818405",
      "vi": "0.9860781952236457"
    },
    "canonical_solution": "  (* (+ a b) c))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun calculate-expression (a b c)` para resolver el siguiente problema:   Calcula el valor de la expresión (a+b)*c para enteros dados a, b y c.\n   Devuelve el resultado del cálculo.\n   Ejemplo:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "arb": "اكتب دالة Common Lisp `(defun calculate-expression (a b c)` لحل المشكلة التالية: تحسب قيمة التعبير (a+b)*c للأعداد الصحيحة المعطاة a و b و c. تعيد نتيجة الحساب.\n   مثال:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "sw": "Andika kazi ya Common Lisp `(defun calculate-expression (a b c)` kutatua tatizo lifuatalo:   Inahesabu thamani ya usemi (a+b)*c kwa namba kamili zilizotolewa a, b, na c.  \n   Inarudisha matokeo ya hesabu.  \n   Mfano:  \n   >>> (calculate-expression 1 2 3)  \n   9  \n   >>> (calculate-expression -1 2 3)  \n   3  \n   >>> (calculate-expression 0 0 0)  \n   0",
      "tr": "Bir Common Lisp fonksiyonu `(defun calculate-expression (a b c)` yazın:   Verilen tamsayılar a, b ve c için (a+b)*c ifadesinin değerini hesaplar.\n   Hesaplamanın sonucunu döndürür.\n   Örnek:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "vi": "Viết một hàm Common Lisp `(defun calculate-expression (a b c)` để giải quyết vấn đề sau: Tính giá trị của biểu thức (a+b)*c cho các số nguyên a, b, và c đã cho. Trả về kết quả của phép tính. Ví dụ: >>> (calculate-expression 1 2 3) 9 >>> (calculate-expression -1 2 3) 3 >>> (calculate-expression 0 0 0) 0"
    },
    "instruction_bertscore": {
      "es": "0.9841338024236952",
      "arb": "0.9801282221597456",
      "sw": "0.9801282221597456",
      "tr": "0.9651582448626702",
      "vi": "0.9804456335086394"
    },
    "level": "easy",
    "test": "(defun check-calculate-expression ()\n  (assert (= (calculate-expression 1 2 3) 9))\n  (assert (= (calculate-expression -1 2 3) 3))\n  (assert (= (calculate-expression 0 0 0) 0))\n  (assert (= (calculate-expression 100 -100 1) 0))\n  (assert (= (calculate-expression -5 -5 -5) 50))\n  (assert (= (calculate-expression 10 20 30) 900))\n  (assert (= (calculate-expression 0 10 -2) -20)))",
    "entry_point": "calculate-expression",
    "signature": "(defun calculate-expression (a b c)",
    "docstring": {
      "es": "   Calcula el valor de la expresión (a+b)*c para los enteros dados a, b y c.\n   Devuelve el resultado del cálculo.\n   Ejemplo:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "arb": "   يحسب قيمة التعبير (a+b)*c للأعداد الصحيحة المعطاة a و b و c.\n   يعيد نتيجة الحساب.\n   مثال:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "sw": "Hesabu thamani ya usemi (a+b)*c kwa namba kamili zilizotolewa a, b, na c.  \nRudisha matokeo ya hesabu.  \nMfano:  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0  ",
      "tr": "   Verilen tamsayılar a, b ve c için (a+b)*c ifadesinin değerini hesaplar.\n   Hesaplamanın sonucunu döndürür.\n   Örnek:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "vi": "   Tính giá trị của biểu thức (a+b)*c cho các số nguyên a, b và c được cung cấp.\n   Trả về kết quả của phép tính.\n   Ví dụ:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0"
    },
    "docstring_bertscore": {
      "es": "0.9749105993107212",
      "arb": "0.9782003156814211",
      "sw": "0.9747000511068242",
      "tr": "0.9782003156814211",
      "vi": "0.9747000511068242"
    }
  },
  {
    "task_id": "Common Lisp/42",
    "prompt": {
      "es": "(defun char-to-ascii (char)\n  ;; Convierte un solo carácter visible (excluyendo el espacio) a su código ASCII.\n  ;; Entrada: Un carácter (no una cadena) que es visible y no es un espacio.\n  ;; Salida: Un entero que representa el código ASCII del carácter de entrada.\n  ;; Ejemplo:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "arb": "(defun char-to-ascii (char)\n  ;; يحول حرفًا مرئيًا واحدًا (باستثناء المسافة) إلى رمز ASCII الخاص به.\n  ;; المدخل: حرف (وليس سلسلة) يكون مرئيًا وليس مسافة.\n  ;; المخرج: عدد صحيح يمثل رمز ASCII للحرف المدخل.\n  ;; مثال:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "sw": "(defun char-to-ascii (char)\n  ;; Hubadilisha herufi moja inayoonekana (isipokuwa nafasi) kuwa msimbo wake wa ASCII.\n  ;; Ingizo: Herufi (sio kamba) ambayo inaonekana na sio nafasi.\n  ;; Tokeo: Nambari kamili inayowakilisha msimbo wa ASCII wa herufi iliyoingizwa.\n  ;; Mfano:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "tr": "(defun char-to-ascii (char)\n  ;; Tek bir görünen karakteri (boşluk hariç) ASCII koduna dönüştürür.\n  ;; Girdi: Görünen ve boşluk olmayan bir karakter (dize değil).\n  ;; Çıktı: Girdi karakterinin ASCII kodunu temsil eden bir tam sayı.\n  ;; Örnek:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "vi": "(defun char-to-ascii (char)\n  ;; Chuyển đổi một ký tự hiển thị đơn lẻ (không bao gồm khoảng trắng) thành mã ASCII của nó.\n  ;; Đầu vào: Một ký tự (không phải chuỗi) mà có thể nhìn thấy và không phải là khoảng trắng.\n  ;; Đầu ra: Một số nguyên đại diện cho mã ASCII của ký tự đầu vào.\n  ;; Ví dụ:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.970787032600437",
      "vi": "0.9819202654574424"
    },
    "canonical_solution": "  (char-code char))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `defun char-to-ascii (char)` para resolver el siguiente problema: Convierte un solo carácter visible (excluyendo el espacio) a su código ASCII.  \n Entrada: Un carácter (no una cadena) que es visible y no es un espacio.  \n Salida: Un entero que representa el código ASCII del carácter de entrada.  \n Ejemplo:  \n >>> (char-to-ascii #\\A)  \n 65  \n >>> (char-to-ascii #\\!)  \n 33",
      "arb": "اكتب دالة Common Lisp `defun char-to-ascii (char)` لحل المشكلة التالية: تحويل حرف مرئي واحد (باستثناء المسافة) إلى رمز ASCII الخاص به.\n المدخل: حرف (ليس سلسلة) يكون مرئيًا وليس مسافة.\n المخرج: عدد صحيح يمثل رمز ASCII للحرف المدخل.\n مثال:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "sw": "Andika kazi ya Common Lisp `defun char-to-ascii (char)` kutatua tatizo lifuatalo: Inabadilisha herufi moja inayoonekana (isipokuwa nafasi) kuwa msimbo wake wa ASCII.  \n Ingizo: Herufi (sio mfuatano wa herufi) ambayo inaonekana na si nafasi.  \n Tokeo: Nambari kamili inayowakilisha msimbo wa ASCII wa herufi ya ingizo.  \n Mfano:  \n >>> (char-to-ascii #\\A)  \n 65  \n >>> (char-to-ascii #\\!)  \n 33",
      "tr": "Bir Common Lisp fonksiyonu `defun char-to-ascii (char)` yazın: Tek bir görünür karakteri (boşluk hariç) ASCII koduna dönüştürür.\n Girdi: Görünür ve boşluk olmayan bir karakter (bir dize değil).\n Çıktı: Girdi karakterinin ASCII kodunu temsil eden bir tamsayı.\n Örnek:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "vi": "Viết một hàm Common Lisp `defun char-to-ascii (char)` để giải quyết vấn đề sau: Chuyển đổi một ký tự có thể nhìn thấy (không bao gồm khoảng trắng) thành mã ASCII của nó.  \n Đầu vào: Một ký tự (không phải chuỗi) có thể nhìn thấy và không phải là khoảng trắng.  \n Đầu ra: Một số nguyên đại diện cho mã ASCII của ký tự đầu vào.  \n Ví dụ:  \n >>> (char-to-ascii #\\A)  \n 65  \n >>> (char-to-ascii #\\!)  \n 33"
    },
    "instruction_bertscore": {
      "es": "0.9936950744451906",
      "arb": "0.9936950744451906",
      "sw": "0.9939147596466151",
      "tr": "0.9552873080771415",
      "vi": "0.9676421177775115"
    },
    "level": "easy",
    "test": "(defun check-char-to-ascii ()\n  (assert (= (char-to-ascii #\\A) 65))\n  (assert (= (char-to-ascii #\\!) 33))\n  (assert (= (char-to-ascii #\\~) 126))\n  (assert (= (char-to-ascii #\\0) 48))\n  (assert (= (char-to-ascii #\\Z) 90)))\n\n(check-char-to-ascii)",
    "entry_point": "char-to-ascii",
    "signature": "defun char-to-ascii (char)",
    "docstring": {
      "es": "Convierte un solo carácter visible (excluyendo el espacio) a su código ASCII.  \nEntrada: Un carácter (no una cadena) que es visible y no es un espacio.  \nSalida: Un entero que representa el código ASCII del carácter de entrada.  \nEjemplo:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33  ",
      "arb": "يحول حرفًا مرئيًا واحدًا (باستثناء المسافة) إلى رمز ASCII الخاص به.\nالمدخلات: حرف (وليس سلسلة) يكون مرئيًا وليس مسافة.\nالمخرجات: عدد صحيح يمثل رمز ASCII للحرف المدخل.\nمثال:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "sw": "Inabadilisha herufi moja inayoonekana (isipokuwa nafasi) kuwa msimbo wake wa ASCII.  \nIngizo: Herufi (sio kamba) ambayo inaonekana na si nafasi.  \nMatokeo: Nambari kamili inayowakilisha msimbo wa ASCII wa herufi iliyoingizwa.  \nMfano:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33",
      "tr": "Tek bir görünen karakteri (boşluk hariç) ASCII koduna dönüştürür.\nGirdi: Görünen ve boşluk olmayan bir karakter (dizi değil).\nÇıktı: Girdi karakterinin ASCII kodunu temsil eden bir tamsayı.\nÖrnek:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "vi": "Chuyển đổi một ký tự có thể nhìn thấy (không bao gồm khoảng trắng) thành mã ASCII của nó.  \nĐầu vào: Một ký tự (không phải chuỗi) có thể nhìn thấy và không phải là khoảng trắng.  \nĐầu ra: Một số nguyên đại diện cho mã ASCII của ký tự đầu vào.  \nVí dụ:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33  "
    },
    "docstring_bertscore": {
      "es": "0.99117485217062",
      "arb": "1",
      "sw": "0.9866180725992986",
      "tr": "0.9701969017383822",
      "vi": "0.9559783431727619"
    }
  },
  {
    "task_id": "Common Lisp/43",
    "prompt": {
      "es": "(defun ascii-to-char (code)\n  ;; Convierte un código ASCII a su carácter correspondiente.\n  ;; Entrada: Un entero que representa el código ASCII, garantizado para estar dentro del rango de caracteres visibles (<128 y >0).\n  ;; Salida: El carácter correspondiente al código ASCII.\n  ;; Ejemplo:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "arb": "(defun ascii-to-char (code)\n  ;; يحول رمز ASCII إلى الحرف المقابل له.\n  ;; المدخل: عدد صحيح يمثل رمز ASCII، مضمون أن يكون ضمن نطاق الأحرف المرئية (<128 و >0).\n  ;; المخرج: الحرف المقابل لرمز ASCII.\n  ;; مثال:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "sw": "(defun ascii-to-char (code)\n  ;; Inabadilisha msimbo wa ASCII kuwa herufi inayolingana nayo.\n  ;; Ingizo: Nambari nzima inayowakilisha msimbo wa ASCII, imehakikishwa kuwa ndani ya safu ya herufi zinazoonekana (<128 na >0).\n  ;; Tokeo: Herufi inayolingana na msimbo wa ASCII.\n  ;; Mfano:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "tr": "(defun ascii-to-char (code)\n  ;; Bir ASCII kodunu karşılık gelen karaktere dönüştürür.\n  ;; Girdi: Görünür karakterler aralığında olduğu garanti edilen bir tam sayı (128'den küçük ve 0'dan büyük).\n  ;; Çıktı: ASCII koduna karşılık gelen karakter.\n  ;; Örnek:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "vi": "(defun ascii-to-char (code)\n  ;; Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.\n  ;; Đầu vào: Một số nguyên đại diện cho mã ASCII, đảm bảo nằm trong phạm vi của các ký tự có thể nhìn thấy (<128 và >0).\n  ;; Đầu ra: Ký tự tương ứng với mã ASCII.\n  ;; Ví dụ:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9971963321716926",
      "tr": "0.9609874041216997",
      "vi": "0.984246425849742"
    },
    "canonical_solution": "  (code-char code))",
    "instruction": {
      "es": "Escribe una función en Common Lisp `defun ascii-to-char (code)` para resolver el siguiente problema: Convierte un código ASCII a su carácter correspondiente.\n Entrada: Un entero que representa el código ASCII, garantizado para estar dentro del rango de caracteres visibles (<128 y >0).\n Salida: El carácter correspondiente al código ASCII.\n Ejemplo:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "arb": "اكتب دالة Common Lisp `defun ascii-to-char (code)` لحل المشكلة التالية: تحويل كود ASCII إلى الحرف المقابل له.\n المدخلات: عدد صحيح يمثل كود ASCII، مضمون أن يكون ضمن نطاق الأحرف المرئية (<128 و >0).\n المخرجات: الحرف المقابل لكود ASCII.\n مثال:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "sw": "Andika kazi ya Common Lisp `defun ascii-to-char (code)` kutatua tatizo lifuatalo: Inabadilisha msimbo wa ASCII kuwa herufi inayolingana nayo.  \n Ingizo: Nambari nzima inayowakilisha msimbo wa ASCII, imehakikishwa kuwa ndani ya safu ya herufi zinazoonekana (<128 na >0).  \n Pato: Herufi inayolingana na msimbo wa ASCII.  \n Mfano:  \n >>> (ascii-to-char 65)  \n #\\A  \n >>> (ascii-to-char 33)  \n #\\!",
      "tr": "Bir Common Lisp fonksiyonu `defun ascii-to-char (code)` yazın: Bir ASCII kodunu karşılık gelen karaktere dönüştürür.\n Girdi: Görünür karakterler aralığında olduğu garanti edilen bir tam sayı (128'den küçük ve 0'dan büyük).\n Çıktı: ASCII koduna karşılık gelen karakter.\n Örnek:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "vi": "Viết một hàm Common Lisp `defun ascii-to-char (code)` để giải quyết vấn đề sau: Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.  \n Đầu vào: Một số nguyên đại diện cho mã ASCII, đảm bảo nằm trong phạm vi của các ký tự hiển thị (<128 và >0).  \n Đầu ra: Ký tự tương ứng với mã ASCII.  \n Ví dụ:  \n >>> (ascii-to-char 65)  \n #\\A  \n >>> (ascii-to-char 33)  \n #\\!"
    },
    "instruction_bertscore": {
      "es": "0.9951200487987348",
      "arb": "0.9887283217674132",
      "sw": "0.9864879696997207",
      "tr": "0.9422649016661132",
      "vi": "0.9793106595114061"
    },
    "level": "easy",
    "test": "(defun check-ascii-to-char ()\n  (assert (char= (ascii-to-char 65) #\\A))\n  (assert (char= (ascii-to-char 33) #\\!))\n  (assert (char= (ascii-to-char 126) #\\~))\n  (assert (char= (ascii-to-char 48) #\\0))\n  (assert (char= (ascii-to-char 90) #\\Z)))\n\n(check-ascii-to-char)",
    "entry_point": "ascii-to-char",
    "signature": "defun ascii-to-char (code)",
    "docstring": {
      "es": "Convierte un código ASCII a su carácter correspondiente.\nEntrada: Un entero que representa el código ASCII, garantizado para estar dentro del rango de caracteres visibles (<128 y >0).\nSalida: El carácter correspondiente al código ASCII.\nEjemplo:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "arb": "يحول رمز ASCII إلى الحرف المقابل له.  \nالمدخل: عدد صحيح يمثل رمز ASCII، مضمون أن يكون ضمن نطاق الأحرف المرئية (<128 و >0).  \nالمخرج: الحرف المقابل لرمز ASCII.  \nمثال:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  ",
      "sw": "Inabadilisha msimbo wa ASCII kuwa herufi inayolingana.\nIngizo: Nambari nzima inayowakilisha msimbo wa ASCII, imehakikishwa kuwa ndani ya safu ya herufi zinazoonekana (<128 na >0).\nPato: Herufi inayolingana na msimbo wa ASCII.\nMfano:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "tr": "ASCII kodunu karşılık gelen karaktere dönüştürür.\n Girdi: Görünür karakterler aralığında olduğu garanti edilen bir ASCII kodunu temsil eden bir tamsayı (<128 ve >0).\n Çıktı: ASCII koduna karşılık gelen karakter.\n Örnek:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "vi": "Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.  \nĐầu vào: Một số nguyên đại diện cho mã ASCII, đảm bảo nằm trong phạm vi của các ký tự có thể nhìn thấy (<128 và >0).  \nĐầu ra: Ký tự tương ứng với mã ASCII.  \nVí dụ:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9964421326149031",
      "sw": "0.9789592823673553",
      "tr": "0.9880625127301843",
      "vi": "0.9767282659275714"
    }
  },
  {
    "task_id": "Common Lisp/44",
    "prompt": {
      "es": "(defun reverse-three-digit (num)\n  ;; Invierte un número de tres dígitos.\n  ;; Entrada: Un entero de tres dígitos 'num'.\n  ;; Salida: El entero de tres dígitos en orden inverso. Los ceros a la izquierda se preservan en la salida.\n  ;; Ejemplo:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Para Common Lisp, los ceros a la izquierda no se muestran típicamente en la salida de enteros.",
      "arb": "(defun reverse-three-digit (num)\n  ;; يعكس رقمًا مكونًا من ثلاثة أرقام.\n  ;; المدخل: عدد صحيح مكون من ثلاثة أرقام 'num'.\n  ;; المخرج: العدد الصحيح المكون من ثلاثة أرقام بترتيب عكسي. يتم الحفاظ على الأصفار البادئة في المخرج.\n  ;; مثال:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; بالنسبة لـ Common Lisp، الأصفار البادئة لا تُعرض عادةً في مخرجات الأعداد الصحيحة.",
      "sw": "(defun reverse-three-digit (num)\n  ;; Inarudisha nambari ya tarakimu tatu.\n  ;; Ingizo: Nambari nzima ya tarakimu tatu 'num'.\n  ;; Tokeo: Nambari ya tarakimu tatu kwa mpangilio wa nyuma. Zeros zinazoongoza zinahifadhiwa kwenye matokeo.\n  ;; Mfano:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Kwa Common Lisp, zeros zinazoongoza hazionyeshwi kawaida katika matokeo ya nambari nzima.",
      "tr": "(defun reverse-three-digit (num)\n  ;; Üç basamaklı bir sayıyı tersine çevirir.\n  ;; Girdi: Üç basamaklı bir tamsayı 'num'.\n  ;; Çıktı: Ters sırada üç basamaklı tamsayı. Çıktıda baştaki sıfırlar korunur.\n  ;; Örnek:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Common Lisp için, baştaki sıfırlar genellikle tamsayı çıktısında gösterilmez.",
      "vi": "(defun reverse-three-digit (num)\n  ;; Đảo ngược một số có ba chữ số.\n  ;; Đầu vào: Một số nguyên có ba chữ số 'num'.\n  ;; Đầu ra: Số nguyên có ba chữ số theo thứ tự ngược lại. Các số không đứng đầu được giữ nguyên trong đầu ra.\n  ;; Ví dụ:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Đối với Common Lisp, các số không đứng đầu thường không được hiển thị trong đầu ra số nguyên."
    },
    "prompt_bertscore": {
      "es": "0.990486796530715",
      "arb": "0.9961151870077196",
      "sw": "0.9552396367856931",
      "tr": "0.988818301330022",
      "vi": "0.9791980360853593"
    },
    "canonical_solution": "  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun reverse-three-digit (num)` para resolver el siguiente problema: Invierte un número de tres dígitos.  \nEntrada: Un entero de tres dígitos 'num'.  \nSalida: El entero de tres dígitos en orden inverso. Los ceros a la izquierda se preservan en la salida.  \nEjemplo:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Para Common Lisp, los ceros a la izquierda no se muestran típicamente en la salida de enteros.",
      "arb": "اكتب دالة Common Lisp `(defun reverse-three-digit (num)` لحل المشكلة التالية: تعكس رقمًا مكونًا من ثلاثة أرقام.\n المدخل: عدد صحيح مكون من ثلاثة أرقام 'num'.\n المخرج: العدد الصحيح المكون من ثلاثة أرقام بترتيب عكسي. يتم الحفاظ على الأصفار البادئة في المخرج.\n مثال:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; في Common Lisp، الأصفار البادئة لا تُعرض عادةً في مخرجات الأعداد الصحيحة.",
      "sw": "Andika kazi ya Common Lisp `(defun reverse-three-digit (num)` kutatua tatizo lifuatalo: Inageuza namba ya tarakimu tatu.\n Ingizo: Namba ya tarakimu tatu 'num'.\n Tokeo: Namba ya tarakimu tatu katika mpangilio wa nyuma. Sifuri zinazoongoza zinahifadhiwa katika toleo.\n Mfano:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; Kwa Common Lisp, sifuri zinazoongoza hazionyeshwi kawaida katika toleo la namba.",
      "tr": "Bir Common Lisp fonksiyonu `(defun reverse-three-digit (num)` yazın: Üç basamaklı bir sayıyı tersine çevirme problemini çözmek için.\n Girdi: Üç basamaklı bir tamsayı 'num'.\n Çıktı: Üç basamaklı sayının ters sırası. Çıktıda öncü sıfırlar korunur.\n Örnek:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; Common Lisp için, öncü sıfırlar genellikle tamsayı çıktısında gösterilmez.",
      "vi": "Viết một hàm Common Lisp `(defun reverse-three-digit (num)` để giải quyết vấn đề sau: Đảo ngược một số có ba chữ số.  \n Đầu vào: Một số nguyên có ba chữ số 'num'.  \n Đầu ra: Số nguyên có ba chữ số theo thứ tự ngược lại. Các số không đứng đầu được giữ nguyên trong đầu ra.  \n Ví dụ:  \n >>> (reverse-three-digit 123)  \n 321  \n >>> (reverse-three-digit 100)  \n 1 ;; Đối với Common Lisp, các số không đứng đầu thường không được hiển thị trong đầu ra số nguyên."
    },
    "instruction_bertscore": {
      "es": "0.9860265513245766",
      "arb": "0.979401433595539",
      "sw": "0.9675757752302458",
      "tr": "0.9598383273674128",
      "vi": "0.9818962311813372"
    },
    "level": "easy",
    "test": "(defun check-reverse-three-digit ()\n  (assert (= (reverse-three-digit 123) 321))\n  (assert (= (reverse-three-digit 100) 1)) ;; Note: Leading zeros are not displayed in integers.\n  (assert (= (reverse-three-digit 250) 52))\n  (assert (= (reverse-three-digit 999) 999))\n  (assert (= (reverse-three-digit 500) 5)))\n\n(check-reverse-three-digit)",
    "entry_point": "reverse-three-digit",
    "signature": "(defun reverse-three-digit (num)",
    "docstring": {
      "es": "Invierte un número de tres dígitos.  \nEntrada: Un entero de tres dígitos 'num'.  \nSalida: El entero de tres dígitos en orden inverso. Los ceros a la izquierda se preservan en la salida.  \nEjemplo:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Para Common Lisp, los ceros a la izquierda no se muestran típicamente en la salida de enteros.",
      "arb": "يعكس رقمًا مكونًا من ثلاثة أرقام.  \nالمدخلات: عدد صحيح مكون من ثلاثة أرقام 'num'.  \nالمخرجات: العدد الصحيح المكون من ثلاثة أرقام بترتيب عكسي. يتم الحفاظ على الأصفار البادئة في المخرجات.  \nمثال:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; بالنسبة لـ Common Lisp، لا يتم عادةً عرض الأصفار البادئة في مخرجات الأعداد الصحيحة.",
      "sw": "Inarudisha nambari ya tarakimu tatu.\n\nIngizo: Nambari ya tarakimu tatu 'num'.\n\nPato: Nambari ya tarakimu tatu katika mpangilio wa nyuma. Zeros zinazoongoza zinahifadhiwa katika pato.\n\nMfano:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Kwa Common Lisp, zeros zinazoongoza hazionyeshwi kawaida katika pato la nambari.",
      "tr": "Üç basamaklı bir sayıyı tersine çevirir.\nGirdi: Üç basamaklı bir tamsayı 'num'.\nÇıktı: Ters sırada üç basamaklı tamsayı. Çıktıda baştaki sıfırlar korunur.\nÖrnek:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Common Lisp için, baştaki sıfırlar genellikle tamsayı çıktısında gösterilmez.",
      "vi": "Đảo ngược một số có ba chữ số.  \nĐầu vào: Một số nguyên có ba chữ số 'num'.  \nĐầu ra: Số nguyên có ba chữ số theo thứ tự ngược lại. Các số 0 đứng đầu được giữ nguyên trong đầu ra.  \nVí dụ:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Đối với Common Lisp, các số 0 đứng đầu thường không được hiển thị trong đầu ra số nguyên."
    },
    "docstring_bertscore": {
      "es": "0.9733857138755163",
      "arb": "0.9785580489976649",
      "sw": "0.9467599071889327",
      "tr": "0.9884778488569282",
      "vi": "0.9775120614111351"
    }
  },
  {
    "task_id": "Common Lisp/45",
    "prompt": {
      "es": "(defun int-bool-int-conversion (int)\n  ;; Convierte un entero a un booleano y luego de nuevo a un entero.\n  ;; Entrada: Un entero dentro del rango de valores enteros.\n  ;; Salida: Un entero resultante de la conversión del entero inicial a un booleano y luego de nuevo a un entero.\n  ;; La salida es 1 para cualquier entero de entrada distinto de cero, y 0 para una entrada de 0.\n  ;; Ejemplo:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "arb": "(defun int-bool-int-conversion (int)\n  ;; يحول عددًا صحيحًا إلى قيمة منطقية ثم يعيده إلى عدد صحيح.\n  ;; المدخل: عدد صحيح ضمن نطاق القيم الصحيحة.\n  ;; المخرج: عدد صحيح ناتج عن تحويل العدد الصحيح الأولي إلى قيمة منطقية ثم يعاد إلى عدد صحيح.\n  ;; المخرج هو 1 لأي عدد صحيح غير صفري، و0 للمدخل الذي يساوي 0.\n  ;; مثال:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "sw": "(defun int-bool-int-conversion (int)\n  ;; Hubadilisha nambari nzima kuwa boolean na kisha kurudi kwenye nambari nzima.\n  ;; Ingizo: Nambari nzima ndani ya safu ya thamani za nambari nzima.\n  ;; Tokeo: Nambari nzima inayotokana na ubadilishaji wa nambari nzima ya awali kuwa boolean na kisha kurudi kwenye nambari nzima.\n  ;; Tokeo ni 1 kwa ingizo lolote la nambari nzima isiyo sifuri, na 0 kwa ingizo la 0.\n  ;; Mfano:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "tr": "(defun int-bool-int-conversion (int)\n  ;; Bir tam sayıyı boolean'a ve ardından tekrar bir tam sayıya dönüştürür.\n  ;; Girdi: Tam sayı değerleri aralığında bir tam sayı.\n  ;; Çıktı: Başlangıçtaki tam sayının bir boolean'a ve ardından tekrar bir tam sayıya dönüştürülmesinden elde edilen bir tam sayı.\n  ;; Çıktı, sıfır olmayan herhangi bir giriş tam sayısı için 1 ve girişin 0 olması durumunda 0'dır.\n  ;; Örnek:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "vi": "(defun int-bool-int-conversion (int)\n  ;; Chuyển đổi một số nguyên thành một giá trị boolean và sau đó trở lại thành một số nguyên.\n  ;; Đầu vào: Một số nguyên trong phạm vi các giá trị số nguyên.\n  ;; Đầu ra: Một số nguyên là kết quả của việc chuyển đổi số nguyên ban đầu thành boolean và sau đó trở lại thành số nguyên.\n  ;; Đầu ra là 1 cho bất kỳ số nguyên đầu vào nào khác 0, và 0 cho đầu vào là 0.\n  ;; Ví dụ:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9832113629341692",
      "sw": "0.9793041047088319",
      "tr": "0.9785876449244391",
      "vi": "0.9824764305243401"
    },
    "canonical_solution": "  (if (= int 0) 0 1))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun int-bool-int-conversion (int)` para resolver el siguiente problema: Convierte un entero a un booleano y luego de vuelta a un entero.\n Entrada: Un entero dentro del rango de valores enteros.\n Salida: Un entero resultante de la conversión del entero inicial a un booleano y luego de vuelta a un entero.\n La salida es 1 para cualquier entero de entrada distinto de cero, y 0 para una entrada de 0.\n Ejemplo:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "arb": "اكتب دالة Common Lisp `(defun int-bool-int-conversion (int)` لحل المشكلة التالية: تحويل عدد صحيح إلى قيمة منطقية ثم العودة إلى عدد صحيح.\n المدخل: عدد صحيح ضمن نطاق القيم الصحيحة.\n المخرج: عدد صحيح ناتج عن تحويل العدد الصحيح الأولي إلى قيمة منطقية ثم العودة إلى عدد صحيح.\n المخرج هو 1 لأي عدد صحيح غير صفري، و0 للمدخل الذي يساوي 0.\n مثال:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "sw": "Andika kazi ya Common Lisp `(defun int-bool-int-conversion (int)` kutatua tatizo lifuatalo: Inabadilisha nambari kamili kuwa boolean na kisha kurudi kuwa nambari kamili.  \nIngizo: Nambari kamili ndani ya wigo wa thamani za nambari kamili.  \nMatokeo: Nambari kamili inayotokana na ubadilishaji wa nambari kamili ya awali kuwa boolean na kisha kurudi kuwa nambari kamili.  \nMatokeo ni 1 kwa ingizo lolote la nambari kamili isiyo sifuri, na 0 kwa ingizo la 0.  \nMfano:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "tr": "Bir Common Lisp fonksiyonu `(defun int-bool-int-conversion (int)` yazın: Bir tamsayıyı boole'a ve ardından tekrar bir tamsayıya dönüştüren problemi çözmek için.\n Girdi: Tamsayı değerleri aralığında bir tamsayı.\n Çıktı: Başlangıçtaki tamsayının boole'a ve ardından tekrar bir tamsayıya dönüştürülmesinden elde edilen bir tamsayı.\n Çıktı, sıfır olmayan herhangi bir giriş tamsayısı için 1 ve 0 girişi için 0'dır.\n Örnek:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "vi": "Viết một hàm Common Lisp `(defun int-bool-int-conversion (int)` để giải quyết vấn đề sau: Chuyển đổi một số nguyên thành một giá trị boolean và sau đó quay trở lại thành một số nguyên.\n Đầu vào: Một số nguyên trong phạm vi giá trị số nguyên.\n Đầu ra: Một số nguyên kết quả từ việc chuyển đổi số nguyên ban đầu thành một giá trị boolean và sau đó quay trở lại thành một số nguyên.\n Đầu ra là 1 cho bất kỳ số nguyên đầu vào nào khác không, và 0 cho đầu vào là 0.\n Ví dụ:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1"
    },
    "instruction_bertscore": {
      "es": "0.9882239992299656",
      "arb": "0.9776072053636509",
      "sw": "0.988049601755417",
      "tr": "0.9656498550557316",
      "vi": "0.9807837024171607"
    },
    "level": "easy",
    "test": "(defun check-int-bool-int-conversion ()\n  (assert (= (int-bool-int-conversion 3) 1))\n  (assert (= (int-bool-int-conversion 0) 0))\n  (assert (= (int-bool-int-conversion -5) 1))\n  (assert (= (int-bool-int-conversion 1) 1))\n  (assert (= (int-bool-int-conversion 100) 1)))\n\n(check-int-bool-int-conversion)",
    "entry_point": "int-bool-int-conversion",
    "signature": "(defun int-bool-int-conversion (int)",
    "docstring": {
      "es": "Convierte un entero a un booleano y luego de nuevo a un entero.  \nEntrada: Un entero dentro del rango de valores enteros.  \nSalida: Un entero resultante de la conversión del entero inicial a un booleano y luego de nuevo a un entero.  \nLa salida es 1 para cualquier entero de entrada distinto de cero, y 0 para una entrada de 0.  \nEjemplo:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1",
      "arb": "يقوم بتحويل عدد صحيح إلى قيمة منطقية ثم يعيده إلى عدد صحيح.\nالمدخلات: عدد صحيح ضمن نطاق القيم الصحيحة.\nالمخرجات: عدد صحيح ناتج عن تحويل العدد الصحيح الأولي إلى قيمة منطقية ثم يعاد إلى عدد صحيح.\nالمخرج هو 1 لأي عدد صحيح غير صفري، و0 للمدخل الذي يساوي 0.\nمثال:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "sw": "Inabadilisha nambari kamili kuwa boolean na kisha kurudi kwenye nambari kamili.  \nIngizo: Nambari kamili ndani ya wigo wa thamani za nambari kamili.  \nPato: Nambari kamili inayotokana na ubadilishaji wa nambari kamili ya awali kuwa boolean na kisha kurudi kwenye nambari kamili.  \nPato ni 1 kwa ingizo lolote la nambari kamili isiyo sifuri, na 0 kwa ingizo la 0.  \nMfano:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "tr": "Bir tamsayıyı booleana ve ardından tekrar bir tamsayıya dönüştürür.\nGirdi: Tamsayı değerleri aralığında bir tamsayı.\nÇıktı: İlk tamsayının booleana dönüştürülüp ardından tekrar tamsayıya dönüştürülmesi sonucu elde edilen bir tamsayı.\nÇıktı, sıfır olmayan herhangi bir girdi tamsayısı için 1, ve 0 girdisi için 0'dır.\nÖrnek:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "vi": "Chuyển đổi một số nguyên thành một giá trị boolean và sau đó quay lại thành số nguyên.  \nĐầu vào: Một số nguyên trong phạm vi các giá trị số nguyên.  \nĐầu ra: Một số nguyên kết quả từ việc chuyển đổi số nguyên ban đầu thành một boolean và sau đó quay lại thành số nguyên.  \nĐầu ra là 1 cho bất kỳ số nguyên đầu vào nào khác 0, và 0 cho đầu vào là 0.  \nVí dụ:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  "
    },
    "docstring_bertscore": {
      "es": "0.9926417375345625",
      "arb": "0.9706017104549314",
      "sw": "0.9871738404054342",
      "tr": "0.9873553885737001",
      "vi": "0.9809690245626663"
    }
  },
  {
    "task_id": "Common Lisp/46",
    "prompt": {
      "es": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calcula el término n de una secuencia aritmética dados los dos primeros términos.\n  ;; Entrada: Tres enteros 'a1' y 'a2' que representan los dos primeros términos de la secuencia, y 'n' el número del término a encontrar.\n  ;; Salida: El valor del término n en la secuencia aritmética.\n  ;; Ejemplo:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "arb": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; يحسب الحد n من متتالية حسابية معطاة أول حدين.\n  ;; المدخلات: ثلاثة أعداد صحيحة 'a1' و 'a2' تمثل أول حدين من المتتالية، و 'n' رقم الحد المراد إيجاده.\n  ;; المخرجات: قيمة الحد n في المتتالية الحسابية.\n  ;; مثال:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "sw": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Inahesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza.\n  ;; Ingizo: Nambari tatu za mzima 'a1' na 'a2' zinazowakilisha maneno mawili ya kwanza ya mlolongo, na 'n' nambari ya neno la kupata.\n  ;; Tokeo: Thamani ya neno la nth katika mlolongo wa hesabu.\n  ;; Mfano:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "tr": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; İlk iki terimi verilen bir aritmetik dizinin n. terimini hesaplar.\n  ;; Girdi: Dizinin ilk iki terimini temsil eden 'a1' ve 'a2' ile bulunacak terim numarası 'n' olan üç tamsayı.\n  ;; Çıktı: Aritmetik dizideki n. terimin değeri.\n  ;; Örnek:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "vi": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Tính toán số hạng thứ n của một dãy số cộng khi biết hai số hạng đầu tiên.\n  ;; Đầu vào: Ba số nguyên 'a1' và 'a2' đại diện cho hai số hạng đầu tiên của dãy số, và 'n' là số thứ tự của số hạng cần tìm.\n  ;; Đầu ra: Giá trị của số hạng thứ n trong dãy số cộng.\n  ;; Ví dụ:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29"
    },
    "prompt_bertscore": {
      "es": "0.9904671321229926",
      "arb": "0.9918100721291695",
      "sw": "0.9952930558606162",
      "tr": "0.9866981206428556",
      "vi": "0.9783439254469093"
    },
    "canonical_solution": "  (+ a1 (* (1- n) (- a2 a1))))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` para resolver el siguiente problema: Calcula el enésimo término de una secuencia aritmética dados los dos primeros términos.\n Entrada: Tres enteros 'a1' y 'a2' que representan los dos primeros términos de la secuencia, y 'n' el número del término a encontrar.\n Salida: El valor del enésimo término en la secuencia aritmética.\n Ejemplo:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "arb": "اكتب دالة بلغة Lisp العامة `(defun nth-term-arithmetic-sequence (a1 a2 n)` لحل المشكلة التالية: حساب الحد النوني من متتالية حسابية معطى الحدين الأولين.\n المدخلات: ثلاثة أعداد صحيحة 'a1' و 'a2' تمثل الحدين الأولين من المتتالية، و 'n' رقم الحد المطلوب إيجاده.\n المخرجات: قيمة الحد النوني في المتتالية الحسابية.\n مثال:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "sw": "Andika kazi ya Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` kutatua tatizo lifuatalo: Inakokotoa neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza.\n Ingizo: Nambari tatu za kipekee 'a1' na 'a2' zinazoashiria maneno mawili ya kwanza ya mlolongo, na 'n' nambari ya neno la kupata.\n Matokeo: Thamani ya neno la nth katika mlolongo wa hesabu.\n Mfano:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "tr": "Bir Common Lisp fonksiyonu `(defun nth-term-arithmetic-sequence (a1 a2 n)` yazın: Aşağıdaki problemi çözmek için: İlk iki terimi verilen bir aritmetik dizinin n'inci terimini hesaplar.\n Girdi: Dizinin ilk iki terimini temsil eden üç tamsayı 'a1' ve 'a2', ve bulunacak terim numarası 'n'.\n Çıktı: Aritmetik dizideki n'inci terimin değeri.\n Örnek:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "vi": "Viết một hàm Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` để giải quyết vấn đề sau: Tính toán số hạng thứ n của một dãy số cộng khi biết hai số hạng đầu tiên.\n Đầu vào: Ba số nguyên 'a1' và 'a2' đại diện cho hai số hạng đầu tiên của dãy số, và 'n' là số thứ tự của số hạng cần tìm.\n Đầu ra: Giá trị của số hạng thứ n trong dãy số cộng.\n Ví dụ:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29"
    },
    "instruction_bertscore": {
      "es": "0.9906415295975413",
      "arb": "0.9748007567100089",
      "sw": "0.9820279231239634",
      "tr": "0.9792997348404491",
      "vi": "0.9802201880261648"
    },
    "level": "easy",
    "test": "(defun check-nth-term-arithmetic-sequence ()\n  (assert (= (nth-term-arithmetic-sequence 1 4 100) 298))\n  (assert (= (nth-term-arithmetic-sequence 2 5 10) 29))\n  (assert (= (nth-term-arithmetic-sequence 0 3 4) 9))\n  (assert (= (nth-term-arithmetic-sequence -3 1 5) 13))\n  (assert (= (nth-term-arithmetic-sequence 100 -100 50) -9700)))\n\n(check-nth-term-arithmetic-sequence)",
    "entry_point": "nth-term-arithmetic-sequence",
    "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)",
    "docstring": {
      "es": "Calcula el enésimo término de una secuencia aritmética dados los dos primeros términos.  \nEntrada: Tres enteros 'a1' y 'a2' que representan los dos primeros términos de la secuencia, y 'n' el número del término a encontrar.  \nSalida: El valor del enésimo término en la secuencia aritmética.  \nEjemplo:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "arb": "يحسب الحد النوني لمتتالية حسابية معطى الحدين الأولين.\nالمدخلات: ثلاثة أعداد صحيحة 'a1' و 'a2' تمثل الحدين الأولين من المتتالية، و 'n' رقم الحد المطلوب إيجاده.\nالمخرجات: قيمة الحد النوني في المتتالية الحسابية.\nمثال:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "sw": "Hesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza.  \nIngizo: Nambari tatu za mzima 'a1' na 'a2' zinazowakilisha maneno mawili ya kwanza ya mlolongo, na 'n' nambari ya neno la kupata.  \nPato: Thamani ya neno la nth katika mlolongo wa hesabu.  \nMfano:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "tr": " nth terimini, ilk iki terim verildiğinde bir aritmetik dizinin hesaplar.\n Girdi: Dizinin ilk iki terimini temsil eden 'a1' ve 'a2' üç tamsayı ve bulunacak terim numarası 'n'.\n Çıktı: Aritmetik dizideki nth terimin değeri.\n Örnek:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "vi": "Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên.  \nĐầu vào: Ba số nguyên 'a1' và 'a2' đại diện cho hai số hạng đầu tiên của dãy, và 'n' là số thứ tự của số hạng cần tìm.  \nĐầu ra: Giá trị của số hạng thứ n trong dãy số học.  \nVí dụ:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29"
    },
    "docstring_bertscore": {
      "es": "0.9866927576225677",
      "arb": "0.9752295997026632",
      "sw": "0.9803375785813564",
      "tr": "0.9306972641657844",
      "vi": "0.9693509349455547"
    }
  },
  {
    "task_id": "Common Lisp/47",
    "prompt": {
      "es": "(defun multiply-a-b (a b)\n  ;; Multiplica dos enteros positivos A y B y devuelve el producto.\n  ;; Entrada: Dos enteros positivos 'a' y 'b', donde 1 <= a, b <= 50000.\n  ;; Salida: El producto de 'a' y 'b'.\n  ;; Ejemplo:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "arb": "(defun multiply-a-b (a b)\n  ;; يضرب عددين صحيحين موجبين A و B ويعيد الناتج.\n  ;; المدخلات: عددان صحيحان موجبان 'a' و 'b'، حيث 1 <= a, b <= 50000.\n  ;; المخرجات: حاصل ضرب 'a' و 'b'.\n  ;; مثال:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "sw": "(defun multiply-a-b (a b)\n  ;; Huzidisha namba mbili nzima chanya A na B na kurudisha zao.\n  ;; Ingizo: Namba mbili nzima chanya 'a' na 'b', ambapo 1 <= a, b <= 50000.\n  ;; Tokeo: Zao la 'a' na 'b'.\n  ;; Mfano:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "tr": "(defun multiply-a-b (a b)\n  ;; İki pozitif tam sayı A ve B'yi çarpar ve çarpımı döndürür.\n  ;; Girdi: 1 <= a, b <= 50000 olan iki pozitif tam sayı 'a' ve 'b'.\n  ;; Çıktı: 'a' ve 'b'nin çarpımı.\n  ;; Örnek:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "vi": "(defun multiply-a-b (a b)\n  ;; Nhân hai số nguyên dương A và B và trả về tích của chúng.\n  ;; Đầu vào: Hai số nguyên dương 'a' và 'b', với điều kiện 1 <= a, b <= 50000.\n  ;; Đầu ra: Tích của 'a' và 'b'.\n  ;; Ví dụ:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9818716010140889",
      "sw": "0.9910139615619816",
      "tr": "0.9971119142597528",
      "vi": "0.9717339036268302"
    },
    "canonical_solution": "  (* a b))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun multiply-a-b (a b)` para resolver el siguiente problema: Multiplica dos enteros positivos A y B y devuelve el producto.\n Entrada: Dos enteros positivos 'a' y 'b', donde 1 <= a, b <= 50000.\n Salida: El producto de 'a' y 'b'.\n Ejemplo:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "arb": "اكتب دالة بلغة Lisp شائعة `(defun multiply-a-b (a b)` لحل المشكلة التالية: تضرب عددين صحيحين موجبين A و B وتعيد الناتج.\n المدخلات: عددان صحيحان موجبان 'a' و 'b'، حيث 1 <= a, b <= 50000.\n المخرجات: ناتج ضرب 'a' و 'b'.\n مثال:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "sw": "Andika kazi ya Common Lisp `(defun multiply-a-b (a b)` kutatua tatizo lifuatalo: Kuzidisha namba mbili nzima chanya A na B na kurudisha zao.\n Ingizo: Namba mbili nzima chanya 'a' na 'b', ambapo 1 <= a, b <= 50000.\n Tokeo: Zao la 'a' na 'b'.\n Mfano:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "tr": "Bir Common Lisp fonksiyonu `(defun multiply-a-b (a b)` yazın: İki pozitif tam sayı A ve B'yi çarpar ve çarpımı döndürür.\n Girdi: İki pozitif tam sayı 'a' ve 'b', burada 1 <= a, b <= 50000.\n Çıktı: 'a' ve 'b'nin çarpımı.\n Örnek:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "vi": "Viết một hàm Common Lisp `(defun multiply-a-b (a b)` để giải quyết vấn đề sau: Nhân hai số nguyên dương A và B và trả về tích của chúng.\n Đầu vào: Hai số nguyên dương 'a' và 'b', với 1 <= a, b <= 50000.\n Đầu ra: Tích của 'a' và 'b'.\n Ví dụ:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648"
    },
    "instruction_bertscore": {
      "es": "0.9928332172218802",
      "arb": "0.963369181020689",
      "sw": "0.9928332172218802",
      "tr": "0.9742038724149991",
      "vi": "0.9853061189325631"
    },
    "level": "easy",
    "test": "(defun check-multiply-a-b ()\n  (assert (= (multiply-a-b 3 4) 12))\n  (assert (= (multiply-a-b 36 18) 648))\n  (assert (= (multiply-a-b 1 50000) 50000))\n  (assert (= (multiply-a-b 50000 50000) 2500000000))\n  (assert (= (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)",
    "entry_point": "multiply-a-b",
    "signature": "(defun multiply-a-b (a b)",
    "docstring": {
      "es": "Multiplica dos enteros positivos A y B y devuelve el producto.\nEntrada: Dos enteros positivos 'a' y 'b', donde 1 <= a, b <= 50000.\nSalida: El producto de 'a' y 'b'.\nEjemplo:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "arb": "يضرب عددين صحيحين موجبين A و B ويعيد الناتج.\n\nالمدخلات: عددان صحيحان موجبان 'a' و 'b'، حيث 1 <= a, b <= 50000.\n\nالمخرجات: حاصل ضرب 'a' و 'b'.\n\nمثال:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "sw": "Huzidisha nambari mbili nzima chanya A na B na rudisha zao.  \nIngizo: Nambari mbili nzima chanya 'a' na 'b', ambapo 1 <= a, b <= 50000.  \nMatokeo: Zao la 'a' na 'b'.  \nMfano:  \n>>> (multiply-a-b 3 4)  \n12  \n>>> (multiply-a-b 36 18)  \n648  ",
      "tr": "İki pozitif tam sayı A ve B'yi çarpar ve çarpımı döndürür.\nGirdi: 1 <= a, b <= 50000 olan iki pozitif tam sayı 'a' ve 'b'.\nÇıktı: 'a' ve 'b'nin çarpımı.\nÖrnek:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "vi": "Nhân hai số nguyên dương A và B và trả về tích.\n\nĐầu vào: Hai số nguyên dương 'a' và 'b', với 1 <= a, b <= 50000.\n\nĐầu ra: Tích của 'a' và 'b'.\n\nVí dụ:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648"
    },
    "docstring_bertscore": {
      "es": "0.9874088201461985",
      "arb": "0.9805570651523999",
      "sw": "0.9874088201461985",
      "tr": "0.9969545989979731",
      "vi": "0.9825586635020885"
    }
  },
  {
    "task_id": "Common Lisp/48",
    "prompt": {
      "es": "(defun power-of-two (n)\n  ;; Calcula 2 elevado a la potencia de n, donde n es un entero no negativo.\n  ;; Entrada: Un entero no negativo 'n' (0 <= n < 31).\n  ;; Salida: Un entero que representa 2^n.\n  ;; Ejemplo:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "arb": "(defun power-of-two (n)\n  ;; يحسب 2 مرفوعة إلى قوة n، حيث n هو عدد صحيح غير سالب.\n  ;; المدخل: عدد صحيح غير سالب 'n' (0 <= n < 31).\n  ;; المخرج: عدد صحيح يمثل 2^n.\n  ;; مثال:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "sw": "(defun power-of-two (n)\n  ;; Inahesabu 2 iliyopandishwa kwa nguvu ya n, ambapo n ni nambari isiyo hasi.\n  ;; Ingizo: Nambari isiyo hasi 'n' (0 <= n < 31).\n  ;; Tokeo: Nambari inayoashiria 2^n.\n  ;; Mfano:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "tr": "(defun power-of-two (n)\n  ;; n'inci kuvveti olarak 2'yi hesaplar, burada n negatif olmayan bir tam sayıdır.\n  ;; Girdi: Negatif olmayan bir tam sayı 'n' (0 <= n < 31).\n  ;; Çıktı: 2^n'i temsil eden bir tam sayı.\n  ;; Örnek:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "vi": "(defun power-of-two (n)\n  ;; Tính 2 lũy thừa n, trong đó n là một số nguyên không âm.\n  ;; Đầu vào: Một số nguyên không âm 'n' (0 <= n < 31).\n  ;; Đầu ra: Một số nguyên đại diện cho 2^n.\n  ;; Ví dụ:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9734828441318424",
      "tr": "0.9883900542285108",
      "vi": "0.9976837711267522"
    },
    "canonical_solution": "  (expt 2 n))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun power-of-two (n)` para resolver el siguiente problema: Calcula 2 elevado a la potencia de n, donde n es un entero no negativo.\n Entrada: Un entero no negativo 'n' (0 <= n < 31).\n Salida: Un entero que representa 2^n.\n Ejemplo:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "arb": "اكتب دالة بلغة Lisp العامة `(defun power-of-two (n)` لحل المشكلة التالية: حساب 2 مرفوعة إلى قوة n، حيث n عدد صحيح غير سالب.\n المدخل: عدد صحيح غير سالب 'n' (0 <= n < 31).\n المخرج: عدد صحيح يمثل 2^n.\n مثال:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "sw": "Andika kazi ya Common Lisp `(defun power-of-two (n)` kutatua tatizo lifuatalo: Inahesabu 2 iliyoinuliwa kwa nguvu ya n, ambapo n ni nambari kamili isiyo hasi.\n Ingizo: Nambari kamili isiyo hasi 'n' (0 <= n < 31).\n Tokeo: Nambari kamili inayowakilisha 2^n.\n Mfano:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "tr": "Common Lisp dilinde `(defun power-of-two (n)` fonksiyonunu aşağıdaki problemi çözmek için yazın: n'inci kuvvetine yükseltilmiş 2'yi hesaplar, burada n negatif olmayan bir tam sayıdır.\n Girdi: Negatif olmayan bir tam sayı 'n' (0 <= n < 31).\n Çıktı: 2^n'i temsil eden bir tam sayı.\n Örnek:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "vi": "Viết một hàm Common Lisp `(defun power-of-two (n)` để giải quyết vấn đề sau: Tính 2 lũy thừa n, trong đó n là một số nguyên không âm. \n Đầu vào: Một số nguyên không âm 'n' (0 <= n < 31).\n Đầu ra: Một số nguyên đại diện cho 2^n.\n Ví dụ:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024"
    },
    "instruction_bertscore": {
      "es": "0.9982770800749033",
      "arb": "0.9932376286776672",
      "sw": "0.990213481126411",
      "tr": "0.9603100745223707",
      "vi": "0.9982770800749033"
    },
    "level": "easy",
    "test": "(defun check-power-of-two ()\n  (assert (= (power-of-two 3) 8))\n  (assert (= (power-of-two 10) 1024))\n  (assert (= (power-of-two 0) 1))\n  (assert (= (power-of-two 5) 32))\n  (assert (= (power-of-two 15) 32768)))\n\n(check-power-of-two)",
    "entry_point": "power-of-two",
    "signature": "(defun power-of-two (n)",
    "docstring": {
      "es": " Calcula 2 elevado a la potencia de n, donde n es un entero no negativo.\n Entrada: Un entero no negativo 'n' (0 <= n < 31).\n Salida: Un entero que representa 2^n.\n Ejemplo:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "arb": " يحسب 2 مرفوعًا إلى قوة n، حيث n هو عدد صحيح غير سالب.\n المدخل: عدد صحيح غير سالب 'n' (0 <= n < 31).\n المخرج: عدد صحيح يمثل 2^n.\n مثال:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "sw": "Hesabu 2 iliyopandishwa kwa nguvu ya n, ambapo n ni nambari kamili isiyo hasi.\nIngizo: Nambari kamili isiyo hasi 'n' (0 <= n < 31).\nPato: Nambari kamili inayowakilisha 2^n.\nMfano:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "tr": " n'in negatif olmayan bir tam sayı olduğu durumda 2'nin n'inci kuvvetini hesaplar.\n Girdi: Negatif olmayan bir tam sayı 'n' (0 <= n < 31).\n Çıktı: 2^n'i temsil eden bir tam sayı.\n Örnek:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "vi": " Tính 2 lũy thừa n, trong đó n là một số nguyên không âm.\n Đầu vào: Một số nguyên không âm 'n' (0 <= n < 31).\n Đầu ra: Một số nguyên đại diện cho 2^n.\n Ví dụ:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9972056677996012",
      "tr": "0.935152742242778",
      "vi": "0.9972056677996012"
    }
  },
  {
    "task_id": "Common Lisp/49",
    "prompt": {
      "es": "(defun judge-sign (n)\n  ;; Determina si un entero N es positivo, negativo o cero.\n  ;; Entrada: Un entero 'N' (-10^9 <= N <= 10^9).\n  ;; Salida: Una cadena \"positive\" si N > 0, \"zero\" si N = 0, o \"negative\" si N < 0.\n  ;; Ejemplo:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "arb": "(defun judge-sign (n)\n  ;; يحدد ما إذا كان العدد الصحيح N موجبًا أو سالبًا أو صفرًا.\n  ;; المدخل: عدد صحيح 'N' (-10^9 <= N <= 10^9).\n  ;; المخرج: سلسلة نصية \"positive\" إذا كان N > 0، \"zero\" إذا كان N = 0، أو \"negative\" إذا كان N < 0.\n  ;; مثال:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "sw": "(defun judge-sign (n)\n  ;; Huamua ikiwa nambari nzima N ni chanya, hasi, au sifuri.\n  ;; Ingizo: Nambari nzima 'N' (-10^9 <= N <= 10^9).\n  ;; Tokeo: Mstari \"positive\" ikiwa N > 0, \"zero\" ikiwa N = 0, au \"negative\" ikiwa N < 0.\n  ;; Mfano:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "tr": "(defun judge-sign (n)\n  ;; Bir tam sayı N'nin pozitif, negatif veya sıfır olup olmadığını belirler.\n  ;; Girdi: Bir tam sayı 'N' (-10^9 <= N <= 10^9).\n  ;; Çıktı: N > 0 ise \"positive\", N = 0 ise \"zero\" veya N < 0 ise \"negative\" bir dize.\n  ;; Örnek:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "vi": "(defun judge-sign (n)\n  ;; Xác định xem một số nguyên N là dương, âm hay bằng không.\n  ;; Đầu vào: Một số nguyên 'N' (-10^9 <= N <= 10^9).\n  ;; Đầu ra: Một chuỗi \"positive\" nếu N > 0, \"zero\" nếu N = 0, hoặc \"negative\" nếu N < 0.\n  ;; Ví dụ:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\""
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9973250446586032",
      "sw": "0.9905787623971343",
      "tr": "0.9994110609202316",
      "vi": "0.9935925811685766"
    },
    "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun judge-sign (n)` para resolver el siguiente problema: Determina si un entero N es positivo, negativo o cero.  \nEntrada: Un entero 'N' (-10^9 <= N <= 10^9).  \nSalida: Una cadena \"positive\" si N > 0, \"zero\" si N = 0, o \"negative\" si N < 0.  \nEjemplo:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "arb": "اكتب دالة Common Lisp `(defun judge-sign (n)` لحل المشكلة التالية: تحديد ما إذا كان العدد الصحيح N موجبًا، سالبًا، أو صفرًا.\n المدخل: عدد صحيح 'N' (-10^9 <= N <= 10^9).\n المخرج: سلسلة نصية \"positive\" إذا كان N > 0، \"zero\" إذا كان N = 0، أو \"negative\" إذا كان N < 0.\n مثال:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "sw": "Andika kazi ya Common Lisp `(defun judge-sign (n)` kutatua tatizo lifuatalo: Inabainisha ikiwa nambari nzima N ni chanya, hasi, au sifuri. \n Ingizo: Nambari nzima 'N' (-10^9 <= N <= 10^9).\n Tokeo: Mstari \"positive\" ikiwa N > 0, \"zero\" ikiwa N = 0, au \"negative\" ikiwa N < 0.\n Mfano:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "tr": "Bir Common Lisp fonksiyonu `(defun judge-sign (n)` yazın: Bir tamsayı N'nin pozitif, negatif veya sıfır olup olmadığını belirler.\n Girdi: Bir tamsayı 'N' (-10^9 <= N <= 10^9).\n Çıktı: N > 0 ise \"positive\", N = 0 ise \"zero\" veya N < 0 ise \"negative\" bir dize.\n Örnek:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "vi": "Viết một hàm Common Lisp `(defun judge-sign (n)` để giải quyết vấn đề sau: Xác định xem một số nguyên N là dương, âm, hay bằng không. \n Đầu vào: Một số nguyên 'N' (-10^9 <= N <= 10^9).\n Đầu ra: Một chuỗi \"positive\" nếu N > 0, \"zero\" nếu N = 0, hoặc \"negative\" nếu N < 0.\n Ví dụ:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\""
    },
    "instruction_bertscore": {
      "es": "0.9935655674367558",
      "arb": "0.9911965028821528",
      "sw": "0.9768228139889441",
      "tr": "0.9780704114122242",
      "vi": "0.9930517106410186"
    },
    "level": "easy",
    "test": "(defun check-judge-sign ()\n  (assert (string= (judge-sign 95) \"positive\"))\n  (assert (string= (judge-sign 0) \"zero\"))\n  (assert (string= (judge-sign -3) \"negative\"))\n  (assert (string= (judge-sign 1) \"positive\"))\n  (assert (string= (judge-sign -1000000) \"negative\")))\n\n(check-judge-sign)",
    "entry_point": "judge-sign",
    "signature": "(defun judge-sign (n)",
    "docstring": {
      "es": "Determina si un entero N es positivo, negativo o cero.\nEntrada: Un entero 'N' (-10^9 <= N <= 10^9).\nSalida: Una cadena \"positive\" si N > 0, \"zero\" si N = 0, o \"negative\" si N < 0.\nEjemplo:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "arb": " يحدد ما إذا كان العدد الصحيح N موجبًا أو سالبًا أو صفرًا.\n المدخلات: عدد صحيح 'N' (-10^9 <= N <= 10^9).\n المخرجات: سلسلة نصية \"positive\" إذا كان N > 0، \"zero\" إذا كان N = 0، أو \"negative\" إذا كان N < 0.\n مثال:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "sw": "Inabainisha ikiwa nambari nzima N ni chanya, hasi, au sifuri.  \nIngizo: Nambari nzima 'N' (-10^9 <= N <= 10^9).  \nPato: Mfuatano wa herufi \"positive\" ikiwa N > 0, \"zero\" ikiwa N = 0, au \"negative\" ikiwa N < 0.  \nMfano:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "tr": " Belirtilen bir tamsayı N'nin pozitif, negatif veya sıfır olup olmadığını belirler.\n Girdi: Bir tamsayı 'N' (-10^9 <= N <= 10^9).\n Çıktı: N > 0 ise \"positive\", N = 0 ise \"zero\" veya N < 0 ise \"negative\" bir string.\n Örnek:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "vi": "Xác định xem một số nguyên N là dương, âm hay bằng không.  \nĐầu vào: Một số nguyên 'N' (-10^9 <= N <= 10^9).  \nĐầu ra: Một chuỗi \"positive\" nếu N > 0, \"zero\" nếu N = 0, hoặc \"negative\" nếu N < 0.  \nVí dụ:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  "
    },
    "docstring_bertscore": {
      "es": "0.992672922504385",
      "arb": "0.9883084171419054",
      "sw": "0.9890763221949863",
      "tr": "0.9948344183108067",
      "vi": "0.9922996960184205"
    }
  },
  {
    "task_id": "Common Lisp/50",
    "prompt": {
      "es": "(defun abs-value (n)\n  ;; Devuelve el valor absoluto de un entero n.\n  ;; Entrada: Un entero 'n', donde el valor absoluto de n no excede 10000.\n  ;; Salida: El valor absoluto de 'n'.\n  ;; Ejemplo:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "arb": "(defun abs-value (n)\n  ;; يُخرج القيمة المطلقة لعدد صحيح n.\n  ;; المدخل: عدد صحيح 'n'، حيث لا تتجاوز القيمة المطلقة لـ n 10000.\n  ;; المخرج: القيمة المطلقة لـ 'n'.\n  ;; مثال:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "sw": "(defun abs-value (n)\n  ;; Inatoa thamani kamili ya nambari nzima n.\n  ;; Ingizo: Nambari nzima 'n', ambapo thamani kamili ya n haizidi 10000.\n  ;; Matokeo: Thamani kamili ya 'n'.\n  ;; Mfano:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "tr": "(defun abs-value (n)\n  ;; Bir tam sayının mutlak değerini çıktılar.\n  ;; Girdi: Mutlak değeri 10000'i geçmeyen bir tam sayı 'n'.\n  ;; Çıktı: 'n' in mutlak değeri.\n  ;; Örnek:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "vi": "(defun abs-value (n)\n  ;; Trả về giá trị tuyệt đối của một số nguyên n.\n  ;; Đầu vào: Một số nguyên 'n', trong đó giá trị tuyệt đối của n không vượt quá 10000.\n  ;; Đầu ra: Giá trị tuyệt đối của 'n'.\n  ;; Ví dụ:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "es": "0.9875673271902643",
      "arb": "0.999999801369619",
      "sw": "0.9692234142409303",
      "tr": "0.9747914210821003",
      "vi": "0.9875673271902643"
    },
    "canonical_solution": "  (abs n))",
    "instruction": {
      "es": "Escribe una función de Common Lisp `(defun abs-value (n)` para resolver el siguiente problema: Devuelve el valor absoluto de un entero n.  \n Entrada: Un entero 'n', donde el valor absoluto de n no excede 10000.  \n Salida: El valor absoluto de 'n'.  \n Ejemplo:  \n >>> (abs-value -3)  \n 3  \n >>> (abs-value 5)  \n 5  \n >>> (abs-value 0)  \n 0",
      "arb": "اكتب دالة بلغة Lisp العامة `(defun abs-value (n)` لحل المشكلة التالية: تُرجع القيمة المطلقة لعدد صحيح n.  \n المدخل: عدد صحيح 'n'، حيث لا تتجاوز القيمة المطلقة لـ n 10000.  \n المخرج: القيمة المطلقة لـ 'n'.  \n مثال:  \n >>> (abs-value -3)  \n 3  \n >>> (abs-value 5)  \n 5  \n >>> (abs-value 0)  \n 0  ",
      "sw": "Andika kazi ya Common Lisp `(defun abs-value (n)` kutatua tatizo lifuatalo: Inatoa thamani kamili ya nambari nzima n.  \nIngizo: Nambari nzima 'n', ambapo thamani kamili ya n haizidi 10000.  \nMatokeo: Thamani kamili ya 'n'.  \nMfano:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "tr": "Bir Common Lisp fonksiyonu `(defun abs-value (n)` yazın: Aşağıdaki problemi çözmek için: Bir tamsayı n'in mutlak değerini çıktılar.\n Girdi: Mutlak değeri 10000'i aşmayan bir tamsayı 'n'.\n Çıktı: 'n'in mutlak değeri.\n Örnek:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "vi": "Viết một hàm Common Lisp `(defun abs-value (n)` để giải quyết vấn đề sau: Xuất giá trị tuyệt đối của một số nguyên n.  \n Đầu vào: Một số nguyên 'n', trong đó giá trị tuyệt đối của n không vượt quá 10000.  \n Đầu ra: Giá trị tuyệt đối của 'n'.  \n Ví dụ:  \n >>> (abs-value -3)  \n 3  \n >>> (abs-value 5)  \n 5  \n >>> (abs-value 0)  \n 0  "
    },
    "instruction_bertscore": {
      "es": "0.98916530860569",
      "arb": "0.9872818953327172",
      "sw": "0.9893883705235922",
      "tr": "0.9761363473920875",
      "vi": "0.9952181722069661"
    },
    "level": "easy",
    "test": "(defun check-abs-value ()\n  (assert (= (abs-value -3) 3))\n  (assert (= (abs-value 5) 5))\n  (assert (= (abs-value 0) 0))\n  (assert (= (abs-value -10000) 10000))\n  (assert (= (abs-value 9999) 9999)))\n\n(check-abs-value)",
    "entry_point": "abs-value",
    "signature": "(defun abs-value (n)",
    "docstring": {
      "es": "Devuelve el valor absoluto de un entero n.  \nEntrada: Un entero 'n', donde el valor absoluto de n no excede 10000.  \nSalida: El valor absoluto de 'n'.  \nEjemplo:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "arb": "يُخرج القيمة المطلقة لعدد صحيح n.  \nالمدخل: عدد صحيح 'n'، حيث لا تتجاوز القيمة المطلقة لـ n 10000.  \nالمخرج: القيمة المطلقة لـ 'n'.  \nمثال:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "sw": "Inatoa thamani kamili ya nambari nzima n.  \nIngizo: Nambari nzima 'n', ambapo thamani kamili ya n haizidi 10000.  \nMatokeo: Thamani kamili ya 'n'.  \nMfano:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "tr": " Bir tamsayı n'nin mutlak değerini çıktılar.\n Girdi: Mutlak değeri 10000'i aşmayan bir tamsayı 'n'.\n Çıktı: 'n'nin mutlak değeri.\n Örnek:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "vi": " Xuất giá trị tuyệt đối của một số nguyên n. \n Đầu vào: Một số nguyên 'n', trong đó giá trị tuyệt đối của n không vượt quá 10000. \n Đầu ra: Giá trị tuyệt đối của 'n'. \n Ví dụ:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0"
    },
    "docstring_bertscore": {
      "es": "0.985584201466012",
      "arb": "0.999999801369619",
      "sw": "0.9808901683013955",
      "tr": "0.9767244919503318",
      "vi": "0.99222858634201"
    }
  }
]