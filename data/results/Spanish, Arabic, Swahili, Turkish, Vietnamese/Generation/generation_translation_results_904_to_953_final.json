[
  {
    "task_id": "JavaScript/1",
    "prompt": {
      "en": "\n// return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "es": "// devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "arb": "// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "sw": "// rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "tr": "// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nfunction hello_mmcodeeval()",
      "vi": "// trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "es": "0.9918720448080524",
      "arb": "0.9948401785918567",
      "sw": "1",
      "tr": "0.9948401785918567",
      "vi": "1"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "Write a JavaScript function `function hello_mmcodeeval()` to solve the following problem:\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "es": "Escribe una función de JavaScript `function hello_mmcodeeval()` para resolver el siguiente problema:  \ndevuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "اكتب دالة JavaScript `function hello_mmcodeeval()` لحل المشكلة التالية:  \nإرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Andika kazi ya JavaScript `function hello_mmcodeeval()` kutatua tatizo lifuatalo:  \nrudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "Bir JavaScript fonksiyonu `function hello_mmcodeeval()` yazın ve aşağıdaki problemi çözün:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndürün",
      "vi": "Viết một hàm JavaScript `function hello_mmcodeeval()` để giải quyết vấn đề sau:  \ntrả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.986905093499894",
      "vi": "1"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(hello_mmcodeeval() === \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n})();",
    "entry_point": "hello_mmcodeeval",
    "signature": "function hello_mmcodeeval()",
    "docstring": {
      "en": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "es": "devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür",
      "vi": "trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "es": "0.9556511989351975",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "JavaScript/2",
    "prompt": {
      "en": "\n/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param {number} a - Length of side 'a'.\n * @param {number} b - Length of side 'b'.\n * @param {number} c - Length of side 'c'.\n * @returns {string|number} If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n * Example:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "es": "/**\n * Calcular el área de un triángulo dados sus tres lados.\n * \n * @param {number} a - Longitud del lado 'a'.\n * @param {number} b - Longitud del lado 'b'.\n * @param {number} c - Longitud del lado 'c'.\n * @returns {string|number} Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales. De lo contrario, devuelve -1.\n * Ejemplo:\n *  calculate_triangle_area(3, 5, 4) // devuelve 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "arb": "/**\n * حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n * \n * @param {number} a - طول الضلع 'a'.\n * @param {number} b - طول الضلع 'b'.\n * @param {number} c - طول الضلع 'c'.\n * @returns {string|number} إذا كانت الأضلاع المقدمة تشكل مثلثاً، يتم إرجاع المساحة المحسوبة مع منزلتين عشريتين. خلاف ذلك، يتم إرجاع -1.\n * مثال :\n *  calculate_triangle_area(3, 5, 4) // يعيد 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "sw": "/**\n * Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n * \n * @param {number} a - Urefu wa upande 'a'.\n * @param {number} b - Urefu wa upande 'b'.\n * @param {number} c - Urefu wa upande 'c'.\n * @returns {string|number} Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali. Vinginevyo, rudisha -1.\n * Mfano:\n *  calculate_triangle_area(3, 5, 4) // inarudisha 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "tr": "/**\n * Üç kenarı verilen bir üçgenin alanını hesaplayın.\n * \n * @param {number} a - 'a' kenarının uzunluğu.\n * @param {number} b - 'b' kenarının uzunluğu.\n * @param {number} c - 'c' kenarının uzunluğu.\n * @returns {string|number} Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün. Aksi takdirde, -1 döndürün.\n * Örnek:\n *  calculate_triangle_area(3, 5, 4) // 6 döndürür\n */\nfunction calculate_triangle_area(a, b, c)",
      "vi": "/**\n * Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n * \n * @param {number} a - Độ dài của cạnh 'a'.\n * @param {number} b - Độ dài của cạnh 'b'.\n * @param {number} c - Độ dài của cạnh 'c'.\n * @returns {string|number} Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân. Ngược lại, trả về -1.\n * Ví dụ:\n *  calculate_triangle_area(3, 5, 4) // trả về 6\n */\nfunction calculate_triangle_area(a, b, c)"
    },
    "prompt_bertscore": {
      "es": "0.9836437812736821",
      "arb": "0.9899870424920313",
      "sw": "0.9969238112889127",
      "tr": "0.9969238112889127",
      "vi": "0.9864871751781965"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return Number(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculate_triangle_area(a, b, c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\nExample:\n calculate_triangle_area(3, 5, 4) // returns 6\n",
      "es": "Escribe una función de JavaScript `function calculate_triangle_area(a, b, c)` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n\nParámetros:\n- a (number): Longitud del lado 'a'.\n- b (number): Longitud del lado 'b'.\n- c (number): Longitud del lado 'c'.\n\nDevuelve:\n- string|number: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales. De lo contrario, devuelve -1.\nEjemplo:\n calculate_triangle_area(3, 5, 4) // devuelve 6",
      "arb": "اكتب دالة JavaScript `function calculate_triangle_area(a, b, c)` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أضلاعه الثلاثة.\n\nالمعطيات:\n- a (number): طول الضلع 'a'.\n- b (number): طول الضلع 'b'.\n- c (number): طول الضلع 'c'.\n\nالقيم المعادة:\n- string|number: إذا كانت الأضلاع المعطاة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين. خلاف ذلك، أعد -1.\nمثال:\n calculate_triangle_area(3, 5, 4) // يعيد 6",
      "sw": "Andika kazi ya JavaScript `function calculate_triangle_area(a, b, c)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n\nVigezo:\n- a (number): Urefu wa upande 'a'.\n- b (number): Urefu wa upande 'b'.\n- c (number): Urefu wa upande 'c'.\n\nInarejesha:\n- string|number: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali. Vinginevyo, rudisha -1.\nMfano:\n calculate_triangle_area(3, 5, 4) // inarejesha 6",
      "tr": "Bir JavaScript fonksiyonu `function calculate_triangle_area(a, b, c)` yazın:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n\nParametreler:\n- a (number): 'a' kenarının uzunluğu.\n- b (number): 'b' kenarının uzunluğu.\n- c (number): 'c' kenarının uzunluğu.\n\nDöndürülenler:\n- string|number: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün. Aksi takdirde, -1 döndürün.\nÖrnek:\n calculate_triangle_area(3, 5, 4) // 6 döndürür",
      "vi": "Viết một hàm JavaScript `function calculate_triangle_area(a, b, c)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n\nTham số:\n- a (number): Chiều dài của cạnh 'a'.\n- b (number): Chiều dài của cạnh 'b'.\n- c (number): Chiều dài của cạnh 'c'.\n\nTrả về:\n- string|number: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân. Nếu không, trả về -1.\nVí dụ:\n calculate_triangle_area(3, 5, 4) // trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.986546962922888",
      "arb": "0.9837327676843858",
      "sw": "0.9969315578737731",
      "tr": "0.9762044776127825",
      "vi": "0.9873583680294156"
    },
    "level": "easy",
    "test": "const testCalculateTriangleArea = () => {\n    // Triangle with sides 3, 5, 4 should return area 6\n    console.assert(Math.abs(calculate_triangle_area(3, 5, 4) - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should return -1\n    console.assert(calculate_triangle_area(1, 1, 4) === -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    console.assert(Math.abs(calculate_triangle_area(7, 24, 25) - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area within precision range\n    console.assert(Math.abs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-6);\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestCalculateTriangleArea();",
    "entry_point": "calculate_triangle_area",
    "signature": "function calculate_triangle_area(a, b, c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\nExample:\n calculate_triangle_area(3, 5, 4) // returns 6\n",
      "es": "Calcular el área de un triángulo dados sus tres lados.\n\nParámetros:\n- a (número): Longitud del lado 'a'.\n- b (número): Longitud del lado 'b'.\n- c (número): Longitud del lado 'c'.\n\nDevuelve:\n- string|número: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales. De lo contrario, devuelve -1.\nEjemplo:\n calculate_triangle_area(3, 5, 4) // devuelve 6",
      "arb": "احسب مساحة المثلث المعطى أضلاعه الثلاثة.\n\nالمعلمات:\n- a (number): طول الضلع 'a'.\n- b (number): طول الضلع 'b'.\n- c (number): طول الضلع 'c'.\n\nالقيم المعادة:\n- string|number: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقتين عشريتين. خلاف ذلك، يتم إرجاع -1.\n\nمثال:\n calculate_triangle_area(3, 5, 4) // يعيد 6",
      "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n\nVigezo:\n- a (nambari): Urefu wa upande 'a'.\n- b (nambari): Urefu wa upande 'b'.\n- c (nambari): Urefu wa upande 'c'.\n\nRudisha:\n- string|nambari: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali. Vinginevyo, rudisha -1.\nMfano:\n calculate_triangle_area(3, 5, 4) // inarudisha 6",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n\nParametreler:\n- a (number): 'a' kenarının uzunluğu.\n- b (number): 'b' kenarının uzunluğu.\n- c (number): 'c' kenarının uzunluğu.\n\nDöndürülenler:\n- string|number: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün. Aksi takdirde, -1 döndürün.\nÖrnek:\n calculate_triangle_area(3, 5, 4) // 6 döndürür",
      "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n\nTham số:\n- a (number): Độ dài của cạnh 'a'.\n- b (number): Độ dài của cạnh 'b'.\n- c (number): Độ dài của cạnh 'c'.\n\nTrả về:\n- string|number: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân. Ngược lại, trả về -1.\nVí dụ:\n calculate_triangle_area(3, 5, 4) // trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9807582777283883",
      "arb": "0.9812113536275289",
      "sw": "0.9946576372716857",
      "tr": "0.9959467484446021",
      "vi": "0.9849650705683262"
    }
  },
  {
    "task_id": "JavaScript/3",
    "prompt": {
      "en": "\n/**\n * Calculate the value of the function for a given input.\n * \n * Parameters:\n * - x (number): Input value for the function.\n * \n * Returns:\n * - string: If x is not in the defined domain, returns \"Not define\".\n * Otherwise, returns the calculated function value as a string rounded to 5 decimal places.\n * \n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Examples:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "es": "/**\n * Calcular el valor de la función para una entrada dada.\n * \n * Parámetros:\n * - x (número): Valor de entrada para la función.\n * \n * Retorna:\n * - string: Si x no está en el dominio definido, retorna \"Not define\".\n * De lo contrario, retorna el valor calculado de la función como una cadena redondeada a 5 decimales.\n * \n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Ejemplos:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "arb": "/**\n * حساب قيمة الدالة لمدخل معين.\n * \n * المعلمات:\n * - x (رقم): قيمة المدخل للدالة.\n * \n * يعيد:\n * - سلسلة: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n * خلاف ذلك، يعيد قيمة الدالة المحسوبة كسلسلة مقربة إلى 5 منازل عشرية.\n * \n * تعريفات الدوال:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * أمثلة:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "sw": "/**\n * Hesabu thamani ya kazi kwa ingizo lililopewa.\n * \n * Vigezo:\n * - x (nambari): Thamani ya ingizo kwa kazi.\n * \n * Inarudisha:\n * - string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\n * Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa kama string iliyokatwa hadi sehemu 5 za desimali.\n * \n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Mifano:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "tr": "/**\n * Belirtilen bir giriş için fonksiyonun değerini hesapla.\n * \n * Parametreler:\n * - x (sayı): Fonksiyon için giriş değeri.\n * \n * Döndürür:\n * - string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\n * Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış bir string olarak döndürür.\n * \n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * \n * Örnekler:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "vi": "/**\n * Tính giá trị của hàm cho một đầu vào đã cho.\n * \n * Tham số:\n * - x (number): Giá trị đầu vào cho hàm.\n * \n * Trả về:\n * - string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n * Nếu không, trả về giá trị hàm đã tính dưới dạng chuỗi được làm tròn đến 5 chữ số thập phân.\n * \n * Định nghĩa Hàm:\n * - Với 0 <= x < 10: y = cos(x + 3.0)\n * - Với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Với 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Ví dụ:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {"
    },
    "prompt_bertscore": {
      "es": "0.9786748436617134",
      "arb": "0.9848601937271397",
      "sw": "0.9808605723746213",
      "tr": "0.9932046560344154",
      "vi": "0.9909672834224384"
    },
    "canonical_solution": "if (0 <= x && x < 10) {\n        return Math.cos(x + 3.0).toFixed(5);\n    } else if (10 <= x && x < 20) {\n        return Math.pow(Math.cos(x + 7.5), 2).toFixed(5);\n    } else if (20 <= x && x < 30) {\n        return Math.pow(Math.cos(x + 4.0), 4).toFixed(5);\n    } else {\n        return \"Not define\";\n    }\n};",
    "instruction": {
      "en": "Write a JavaScript function `const calculateFunctionValue = (x)` to solve the following problem:\nCalculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value as a string rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExamples:\ncalculateFunctionValue(40); // \"Not define\"\n",
      "es": "Escribe una función de JavaScript `const calculateFunctionValue = (x)` para resolver el siguiente problema:\nCalcula el valor de la función para una entrada dada.\n\nParámetros:\n- x (número): Valor de entrada para la función.\n\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función como una cadena redondeada a 5 decimales.\n\nDefiniciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\nEjemplos:\ncalculateFunctionValue(40); // \"Not define\"",
      "arb": "اكتب دالة JavaScript `const calculateFunctionValue = (x)` لحل المشكلة التالية:\nاحسب قيمة الدالة لإدخال معين.\n\nالمعلمات:\n- x (number): قيمة الإدخال للدالة.\n\nالإرجاع:\n- string: إذا لم يكن x في النطاق المحدد، يُرجع \"Not define\".\nوإلا، يُرجع قيمة الدالة المحسوبة كسلسلة نصية مقربة إلى 5 منازل عشرية.\n\nتعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\nأمثلة:\ncalculateFunctionValue(40); // \"Not define\"",
      "sw": "Andika kazi ya JavaScript `const calculateFunctionValue = (x)` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa ingizo lililotolewa.\n\nVigezo:\n- x (nambari): Thamani ya ingizo kwa kazi.\n\nRudisha:\n- string: Ikiwa x haipo katika kikoa kilichobainishwa, rudisha \"Not define\".\nVinginevyo, rudisha thamani ya kazi iliyohesabiwa kama string iliyokatwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMifano:\ncalculateFunctionValue(40); // \"Not define\"",
      "tr": "Bir JavaScript fonksiyonu `const calculateFunctionValue = (x)` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir giriş için fonksiyonun değerini hesaplayın.\n\nParametreler:\n- x (number): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış bir string olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnekler:\ncalculateFunctionValue(40); // \"Not define\"",
      "vi": "Viết một hàm JavaScript `const calculateFunctionValue = (x)` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào đã cho.\n\nTham số:\n- x (number): Giá trị đầu vào cho hàm.\n\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNếu không, trả về giá trị hàm đã tính dưới dạng chuỗi được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\ncalculateFunctionValue(40); // \"Not define\""
    },
    "instruction_bertscore": {
      "es": "0.9794622144921357",
      "arb": "0.9828109240860028",
      "sw": "0.972028869742667",
      "tr": "0.9837488567452496",
      "vi": "0.9891339250054865"
    },
    "level": "easy",
    "test": "const testCalculateFunctionValue = () => {\n    console.assert(calculateFunctionValue(40) === \"Not define\", \"Test case 40 failed\");\n    console.assert(calculateFunctionValue(5) === \"-0.14550\", \"Test case 5 failed\");\n    console.assert(calculateFunctionValue(15) === \"0.76266\", \"Test case 15 failed\");\n    console.assert(calculateFunctionValue(25) === \"0.31314\", \"Test case 25 failed\");\n    console.assert(calculateFunctionValue(-1) === \"Not define\", \"Test case -1 failed\");\n}\n\ntestCalculateFunctionValue();",
    "entry_point": "calculateFunctionValue",
    "signature": "const calculateFunctionValue = (x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value as a string rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExamples:\ncalculateFunctionValue(40); // \"Not define\"\n",
      "es": "Calcular el valor de la función para una entrada dada.\n\nParámetros:\n- x (número): Valor de entrada para la función.\n\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función como una cadena redondeada a 5 decimales.\n\nDefiniciones de Funciones:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\nEjemplos:\ncalculateFunctionValue(40); // \"Not define\"",
      "arb": "احسب قيمة الدالة لمُدخل مُعطى.\n\nالمعلمات:\n- x (رقم): قيمة الإدخال للدالة.\n\nالقيم المُعادة:\n- سلسلة نصية: إذا لم تكن x في النطاق المحدد، تُعاد \"غير معرف\".\nبخلاف ذلك، تُعاد قيمة الدالة المحسوبة كسلسلة نصية مقربة إلى 5 منازل عشرية.\n\nتعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\nأمثلة:\ncalculateFunctionValue(40); // \"غير معرف\"",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (nambari): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- kamba: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa kama kamba iliyokatwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMifano:\ncalculateFunctionValue(40); // \"Not define\"",
      "tr": "Verilen bir giriş için fonksiyonun değerini hesaplayın.\n\nParametreler:\n- x (sayı): Fonksiyon için giriş değeri.\n\nDöndürür:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış bir string olarak döndürür.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnekler:\ncalculateFunctionValue(40); // \"Not define\"",
      "vi": "Tính giá trị của hàm cho một đầu vào cho trước.\n\nTham số:\n- x (number): Giá trị đầu vào cho hàm.\n\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính dưới dạng chuỗi được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\ncalculateFunctionValue(40); // \"Not define\""
    },
    "docstring_bertscore": {
      "es": "0.9782726171401177",
      "arb": "0.9489094851724923",
      "sw": "0.9667488769539977",
      "tr": "0.978342535034242",
      "vi": "0.9872046281144946"
    }
  },
  {
    "task_id": "JavaScript/4",
    "prompt": {
      "en": "\n/**\n * Find the maximum and minimum of three distinct integers.\n *\n * Parameters:\n * a (number): The first integer.\n * b (number): The second integer.\n * c (number): The third integer.\n *\n * Returns:\n * Object: An object with properties 'max' and 'min'.\n *\n * Example call:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "es": "/**\n * Encuentra el máximo y el mínimo de tres enteros distintos.\n *\n * Parámetros:\n * a (number): El primer entero.\n * b (number): El segundo entero.\n * c (number): El tercer entero.\n *\n * Devuelve:\n * Object: Un objeto con propiedades 'max' y 'min'.\n *\n * Ejemplo de llamada:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "arb": "/**\n * إيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة مختلفة.\n *\n * المعاملات:\n * a (number): العدد الصحيح الأول.\n * b (number): العدد الصحيح الثاني.\n * c (number): العدد الصحيح الثالث.\n *\n * يعيد:\n * Object: كائن يحتوي على خصائص 'max' و 'min'.\n *\n * مثال على الاستدعاء:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "sw": "/**\n * Pata kubwa na ndogo kati ya nambari tatu tofauti.\n *\n * Vigezo:\n * a (nambari): Nambari ya kwanza.\n * b (nambari): Nambari ya pili.\n * c (nambari): Nambari ya tatu.\n *\n * Inarudisha:\n * Kitu: Kitu chenye sifa 'max' na 'min'.\n *\n * Mfano wa kupiga simu:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "tr": "/**\n * Üç farklı tam sayının maksimum ve minimumunu bulun.\n *\n * Parametreler:\n * a (sayı): Birinci tam sayı.\n * b (sayı): İkinci tam sayı.\n * c (sayı): Üçüncü tam sayı.\n *\n * Döndürür:\n * Nesne: 'max' ve 'min' özelliklerine sahip bir nesne.\n *\n * Örnek çağrı:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "vi": "/**\n * Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n *\n * Tham số:\n * a (number): Số nguyên thứ nhất.\n * b (number): Số nguyên thứ hai.\n * c (number): Số nguyên thứ ba.\n *\n * Trả về:\n * Object: Một đối tượng với các thuộc tính 'max' và 'min'.\n *\n * Ví dụ gọi:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)"
    },
    "prompt_bertscore": {
      "es": "0.9863193325062221",
      "arb": "0.9713636565965812",
      "sw": "0.9594138542431413",
      "tr": "0.9778989933933911",
      "vi": "0.9733044740496731"
    },
    "canonical_solution": "{\n    let max, min;\n    \n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = (b < c) ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = (a < c) ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return { max, min };\n}",
    "instruction": {
      "en": "Write a JavaScript function `function findMaxMin(a, b, c)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n\nExample call:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "es": "Escribe una función de JavaScript `function findMaxMin(a, b, c)` para resolver el siguiente problema:\nEncuentra el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\n- a (number): El primer entero.\n- b (number): El segundo entero.\n- c (number): El tercer entero.\n\nDevuelve:\n- Object: Un objeto con las propiedades 'max' y 'min'.\n\nEjemplo de llamada:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "arb": "اكتب دالة JavaScript `function findMaxMin(a, b, c)` لحل المشكلة التالية:\nابحث عن القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\n- a (number): العدد الصحيح الأول.\n- b (number): العدد الصحيح الثاني.\n- c (number): العدد الصحيح الثالث.\n\nالإرجاع:\n- Object: كائن يحتوي على الخصائص 'max' و 'min'.\n\nمثال على الاستدعاء:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "sw": "Andika kazi ya JavaScript `function findMaxMin(a, b, c)` kutatua tatizo lifuatalo:\nPata kiwango cha juu na cha chini cha nambari tatu tofauti za mzima.\n\nVigezo:\n- a (nambari): Nambari ya kwanza ya mzima.\n- b (nambari): Nambari ya pili ya mzima.\n- c (nambari): Nambari ya tatu ya mzima.\n\nInarudisha:\n- Kitu: Kitu chenye mali 'max' na 'min'.\n\nMfano wa kupiga simu:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "tr": "Bir JavaScript fonksiyonu `function findMaxMin(a, b, c)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\n- a (number): Birinci tam sayı.\n- b (number): İkinci tam sayı.\n- c (number): Üçüncü tam sayı.\n\nDöndürür:\n- Object: 'max' ve 'min' özelliklerine sahip bir nesne.\n\nÖrnek çağrı:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "vi": "Viết một hàm JavaScript `function findMaxMin(a, b, c)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\n- a (number): Số nguyên thứ nhất.\n- b (number): Số nguyên thứ hai.\n- c (number): Số nguyên thứ ba.\n\nTrả về:\n- Object: Một đối tượng với các thuộc tính 'max' và 'min'.\n\nVí dụ gọi:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);"
    },
    "instruction_bertscore": {
      "es": "0.9962280090641474",
      "arb": "0.9873726694168501",
      "sw": "0.9968489276352626",
      "tr": "0.9765504917365453",
      "vi": "0.9827257116525389"
    },
    "level": "middle",
    "test": "function testFindMaxMin() {\n    let result = findMaxMin(1, 2, 3);\n    console.assert(result.max === 3 && result.min === 1);\n\n    // Additional tests\n    result = findMaxMin(5, 3, 4);\n    console.assert(result.max === 5 && result.min === 3);\n\n    result = findMaxMin(10, -2, 7);\n    console.assert(result.max === 10 && result.min === -2);\n\n    result = findMaxMin(-1, -3, -2);\n    console.assert(result.max === -1 && result.min === -3);\n}\n\ntestFindMaxMin();",
    "entry_point": "findMaxMin",
    "signature": "function findMaxMin(a, b, c)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n\nExample call:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "es": "Encontrar el máximo y el mínimo de tres enteros distintos.\n\nParámetros:\n- a (número): El primer entero.\n- b (número): El segundo entero.\n- c (número): El tercer entero.\n\nDevuelve:\n- Objeto: Un objeto con las propiedades 'max' y 'min'.\n\nEjemplo de llamada:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\n\nالمعلمات:\n- a (رقم): العدد الصحيح الأول.\n- b (رقم): العدد الصحيح الثاني.\n- c (رقم): العدد الصحيح الثالث.\n\nالقيم المعادة:\n- كائن: كائن يحتوي على الخصائص 'max' و 'min'.\n\nمثال على الاستدعاء:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "sw": "Pata kubwa zaidi na ndogo zaidi ya nambari tatu tofauti.\n\nVigezo:\n- a (nambari): Nambari ya kwanza.\n- b (nambari): Nambari ya pili.\n- c (nambari): Nambari ya tatu.\n\nRudisha:\n- Kitu: Kitu chenye sifa 'max' na 'min'.\n\nMfano wa kupiga:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\n\nParametreler:\n- a (sayı): Birinci tam sayı.\n- b (sayı): İkinci tam sayı.\n- c (sayı): Üçüncü tam sayı.\n\nDöndürülenler:\n- Nesne: 'max' ve 'min' özelliklerine sahip bir nesne.\n\nÖrnek çağrı:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\nTham số:\n- a (number): Số nguyên thứ nhất.\n- b (number): Số nguyên thứ hai.\n- c (number): Số nguyên thứ ba.\n\nTrả về:\n- Object: Một đối tượng với các thuộc tính 'max' và 'min'.\n\nVí dụ gọi:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);"
    },
    "docstring_bertscore": {
      "es": "0.9971792499589236",
      "arb": "0.9683567898884751",
      "sw": "0.9468433319489674",
      "tr": "0.9714957457999694",
      "vi": "0.9662163489024431"
    }
  },
  {
    "task_id": "JavaScript/5",
    "prompt": {
      "en": "\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n *\n * Parameters:\n * - xa (number): x-coordinate of point A.\n * - ya (number): y-coordinate of point A.\n * - xb (number): x-coordinate of point B.\n * - yb (number): y-coordinate of point B.\n *\n * Returns:\n * number: The distance between points A and B.\n * Example usage:\n * console.log(calculateDistance(0,0,3,4)); // Expected output: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "es": "/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n *\n * Parámetros:\n * - xa (número): coordenada x del punto A.\n * - ya (número): coordenada y del punto A.\n * - xb (número): coordenada x del punto B.\n * - yb (número): coordenada y del punto B.\n *\n * Devuelve:\n * número: La distancia entre los puntos A y B.\n * Ejemplo de uso:\n * console.log(calculateDistance(0,0,3,4)); // Salida esperada: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "arb": "/**\n * حساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n *\n * المعاملات:\n * - xa (number): الإحداثي السيني للنقطة A.\n * - ya (number): الإحداثي الصادي للنقطة A.\n * - xb (number): الإحداثي السيني للنقطة B.\n * - yb (number): الإحداثي الصادي للنقطة B.\n *\n * العوائد:\n * number: المسافة بين النقطتين A و B.\n * مثال على الاستخدام:\n * console.log(calculateDistance(0,0,3,4)); // المخرج المتوقع: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "sw": "/**\n * Kuhesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n *\n * Vigezo:\n * - xa (nambari): x-kiwianishi cha pointi A.\n * - ya (nambari): y-kiwianishi cha pointi A.\n * - xb (nambari): x-kiwianishi cha pointi B.\n * - yb (nambari): y-kiwianishi cha pointi B.\n *\n * Inarejesha:\n * nambari: Umbali kati ya pointi A na B.\n * Mfano wa matumizi:\n * console.log(calculateDistance(0,0,3,4)); // Matokeo yanayotarajiwa: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "tr": "/**\n * A (xa, ya) ve B (xb, yb) noktaları arasındaki mesafeyi hesaplayın.\n *\n * Parametreler:\n * - xa (number): A noktasının x-koordinatı.\n * - ya (number): A noktasının y-koordinatı.\n * - xb (number): B noktasının x-koordinatı.\n * - yb (number): B noktasının y-koordinatı.\n *\n * Döndürür:\n * number: A ve B noktaları arasındaki mesafe.\n * Örnek kullanım:\n * console.log(calculateDistance(0,0,3,4)); // Beklenen çıktı: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "vi": "/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n *\n * Tham số:\n * - xa (number): tọa độ x của điểm A.\n * - ya (number): tọa độ y của điểm A.\n * - xb (number): tọa độ x của điểm B.\n * - yb (number): tọa độ y của điểm B.\n *\n * Trả về:\n * number: Khoảng cách giữa điểm A và B.\n * Ví dụ sử dụng:\n * console.log(calculateDistance(0,0,3,4)); // Kết quả mong đợi: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)"
    },
    "prompt_bertscore": {
      "es": "0.9958432620160829",
      "arb": "0.973298316507861",
      "sw": "0.9976015381490038",
      "tr": "0.9954539464692546",
      "vi": "0.9948642128679619"
    },
    "canonical_solution": "{\n    return Math.sqrt(Math.pow(xa - xb, 2) + Math.pow(ya - yb, 2));\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculateDistance(xa, ya, xb, yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\nExample usage:\nconsole.log(calculateDistance(0,0,3,4)); // Expected output: 5\n",
      "es": "Escribe una función de JavaScript `function calculateDistance(xa, ya, xb, yb)` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (number): coordenada x del punto A.\n- ya (number): coordenada y del punto A.\n- xb (number): coordenada x del punto B.\n- yb (number): coordenada y del punto B.\n\nDevuelve:\nnumber: La distancia entre los puntos A y B.\nEjemplo de uso:\nconsole.log(calculateDistance(0,0,3,4)); // Salida esperada: 5",
      "arb": "اكتب دالة JavaScript `function calculateDistance(xa, ya, xb, yb)` لحل المشكلة التالية:\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعطيات:\n- xa (number): الإحداثي السيني للنقطة A.\n- ya (number): الإحداثي الصادي للنقطة A.\n- xb (number): الإحداثي السيني للنقطة B.\n- yb (number): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nnumber: المسافة بين النقطتين A و B.\nمثال على الاستخدام:\nconsole.log(calculateDistance(0,0,3,4)); // المخرج المتوقع: 5",
      "sw": "Andika kazi ya JavaScript `function calculateDistance(xa, ya, xb, yb)` kutatua tatizo lifuatalo: \nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (nambari): x-kiwianishi cha pointi A.\n- ya (nambari): y-kiwianishi cha pointi A.\n- xb (nambari): x-kiwianishi cha pointi B.\n- yb (nambari): y-kiwianishi cha pointi B.\n\nInarudisha:\nnambari: Umbali kati ya pointi A na B.\nMfano wa matumizi:\nconsole.log(calculateDistance(0,0,3,4)); // Matokeo yanayotarajiwa: 5",
      "tr": "Bir JavaScript fonksiyonu `function calculateDistance(xa, ya, xb, yb)` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (number): A noktasının x-koordinatı.\n- ya (number): A noktasının y-koordinatı.\n- xb (number): B noktasının x-koordinatı.\n- yb (number): B noktasının y-koordinatı.\n\nDöndürür:\nnumber: A ve B noktaları arasındaki mesafe.\nÖrnek kullanım:\nconsole.log(calculateDistance(0,0,3,4)); // Beklenen çıktı: 5",
      "vi": "Viết một hàm JavaScript `function calculateDistance(xa, ya, xb, yb)` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (number): tọa độ x của điểm A.\n- ya (number): tọa độ y của điểm A.\n- xb (number): tọa độ x của điểm B.\n- yb (number): tọa độ y của điểm B.\n\nTrả về:\nnumber: Khoảng cách giữa hai điểm A và B.\nVí dụ sử dụng:\nconsole.log(calculateDistance(0,0,3,4)); // Kết quả mong đợi: 5"
    },
    "instruction_bertscore": {
      "es": "0.9979082234573216",
      "arb": "0.9697777916343987",
      "sw": "1",
      "tr": "0.9978520110594887",
      "vi": "0.9952098297309626"
    },
    "level": "easy",
    "test": "const testCalculateDistance = () => {\n    console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6);\n    console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6);\n    console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    // console.log(\"All test cases passed!\");\n}\n\ntestCalculateDistance();",
    "entry_point": "calculateDistance",
    "signature": "function calculateDistance(xa, ya, xb, yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\nExample usage:\nconsole.log(calculateDistance(0,0,3,4)); // Expected output: 5\n",
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (número): coordenada x del punto A.\n- ya (número): coordenada y del punto A.\n- xb (número): coordenada x del punto B.\n- yb (número): coordenada y del punto B.\n\nDevuelve:\nnúmero: La distancia entre los puntos A y B.\nEjemplo de uso:\nconsole.log(calculateDistance(0,0,3,4)); // Salida esperada: 5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (number): الإحداثي السيني للنقطة A.\n- ya (number): الإحداثي الصادي للنقطة A.\n- xb (number): الإحداثي السيني للنقطة B.\n- yb (number): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\nnumber: المسافة بين النقطتين A و B.\nمثال على الاستخدام:\nconsole.log(calculateDistance(0,0,3,4)); // المخرج المتوقع: 5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (nambari): x-kiwianishi cha pointi A.\n- ya (nambari): y-kiwianishi cha pointi A.\n- xb (nambari): x-kiwianishi cha pointi B.\n- yb (nambari): y-kiwianishi cha pointi B.\n\nInarejesha:\nnambari: Umbali kati ya pointi A na B.\nMfano wa matumizi:\nconsole.log(calculateDistance(0,0,3,4)); // Matokeo yanayotarajiwa: 5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (number): A noktasının x-koordinatı.\n- ya (number): A noktasının y-koordinatı.\n- xb (number): B noktasının x-koordinatı.\n- yb (number): B noktasının y-koordinatı.\n\nDöndürülenler:\nnumber: A ve B noktaları arasındaki mesafe.\nÖrnek kullanım:\nconsole.log(calculateDistance(0,0,3,4)); // Beklenen çıktı: 5",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (number): tọa độ x của điểm A.\n- ya (number): tọa độ y của điểm A.\n- xb (number): tọa độ x của điểm B.\n- yb (number): tọa độ y của điểm B.\n\nTrả về:\nnumber: Khoảng cách giữa điểm A và B.\nVí dụ sử dụng:\nconsole.log(calculateDistance(0,0,3,4)); // Kết quả mong đợi: 5"
    },
    "docstring_bertscore": {
      "es": "0.9945499796051648",
      "arb": "0.9645470591802259",
      "sw": "0.995644830265429",
      "tr": "0.9970847018975509",
      "vi": "0.995644830265429"
    }
  },
  {
    "task_id": "JavaScript/6",
    "prompt": {
      "en": "\n/**\n * Find the factorial of N and take the modulo 10007 of the result.\n * \n * Parameters:\n * - N (number): A non-negative integer representing the input value (N <= 10000).\n * \n * Returns:\n * - number: The result after taking the modulo 10007 of the factorial of N.\n * \n * Examples:\n * processRequest(1) returns 1\n */\nfunction processRequest(n)",
      "es": "/**\n * Encuentra el factorial de N y toma el módulo 10007 del resultado.\n * \n * Parámetros:\n * - N (number): Un entero no negativo que representa el valor de entrada (N <= 10000).\n * \n * Devuelve:\n * - number: El resultado después de tomar el módulo 10007 del factorial de N.\n * \n * Ejemplos:\n * processRequest(1) devuelve 1\n */\nfunction processRequest(n)",
      "arb": "/**\n * إيجاد مضروب N وأخذ باقي القسمة 10007 من النتيجة.\n * \n * المعاملات:\n * - N (عدد): عدد صحيح غير سالب يمثل قيمة الإدخال (N <= 10000).\n * \n * يعيد:\n * - عدد: النتيجة بعد أخذ باقي القسمة 10007 من مضروب N.\n * \n * أمثلة:\n * processRequest(1) يعيد 1\n */\nfunction processRequest(n)",
      "sw": "/**\n * Pata faktoria ya N na chukua modulo 10007 ya matokeo.\n * \n * Vigezo:\n * - N (nambari): Nambari isiyo hasi inayowakilisha thamani ya ingizo (N <= 10000).\n * \n * Inarudisha:\n * - nambari: Matokeo baada ya kuchukua modulo 10007 ya faktoria ya N.\n * \n * Mifano:\n * processRequest(1) inarudisha 1\n */\nfunction processRequest(n)",
      "tr": "/**\n * N'in faktöriyelini bulun ve sonucu 10007 ile mod alın.\n * \n * Parametreler:\n * - N (number): Giriş değerini temsil eden negatif olmayan bir tam sayı (N <= 10000).\n * \n * Döndürür:\n * - number: N'in faktöriyelinin 10007 ile modunun alınmasından sonra elde edilen sonuç.\n * \n * Örnekler:\n * processRequest(1) 1 döndürür\n */\nfunction processRequest(n)",
      "vi": "/**\n * Tìm giai thừa của N và lấy modulo 10007 của kết quả.\n * \n * Tham số:\n * - N (number): Một số nguyên không âm đại diện cho giá trị đầu vào (N <= 10000).\n * \n * Trả về:\n * - number: Kết quả sau khi lấy modulo 10007 của giai thừa của N.\n * \n * Ví dụ:\n * processRequest(1) trả về 1\n */\nfunction processRequest(n)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9425970116632035",
      "sw": "0.9814985731585053",
      "tr": "0.9658490813279096",
      "vi": "0.9867183809417212"
    },
    "canonical_solution": "{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function processRequest(n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n\nExamples:\nprocessRequest(1) returns 1\n",
      "es": "Escribe una función de JavaScript `function processRequest(n)` para resolver el siguiente problema:  \nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n\nParámetros:\n- N (number): Un entero no negativo que representa el valor de entrada (N <= 10000).\n\nDevuelve:\n- number: El resultado después de tomar el módulo 10007 del factorial de N.\n\nEjemplos:\nprocessRequest(1) devuelve 1",
      "arb": "اكتب دالة JavaScript `function processRequest(n)` لحل المشكلة التالية:\nابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (عدد): عدد صحيح غير سالب يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\n- عدد: النتيجة بعد أخذ باقي القسمة 10007 من مضروب N.\n\nأمثلة:\nprocessRequest(1) يعيد 1",
      "sw": "Andika kazi ya JavaScript `function processRequest(n)` kutatua tatizo lifuatalo: Tafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (number): Nambari isiyo hasi inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarudisha:\n- number: Matokeo baada ya kuchukua modulo 10007 ya faktoria ya N.\n\nMifano:\nprocessRequest(1) inarudisha 1",
      "tr": "Bir JavaScript fonksiyonu `function processRequest(n)` yazın ve aşağıdaki problemi çözün:\nN'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (number): Girdi değerini temsil eden negatif olmayan bir tam sayı (N <= 10000).\n\nDöndürür:\n- number: N'in faktöriyelinin 10007 modunu aldıktan sonra elde edilen sonuç.\n\nÖrnekler:\nprocessRequest(1) 1 döndürür",
      "vi": "Viết một hàm JavaScript `function processRequest(n)` để giải quyết vấn đề sau:  \nTìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:  \n- N (number): Một số nguyên không âm đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:  \n- number: Kết quả sau khi lấy phần dư 10007 của giai thừa của N.\n\nVí dụ:  \nprocessRequest(1) trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9241869547969849",
      "sw": "0.984497296020989",
      "tr": "0.9665047602157057",
      "vi": "0.9686998245565224"
    },
    "level": "middle",
    "test": "const testProcessRequest = () => {\n    console.assert(processRequest(0) === 1, \"Expected factorial of 0 modulo 10007 is 1\");\n    console.assert(processRequest(1) === 1, \"Expected factorial of 1 modulo 10007 is 1\");\n    console.assert(processRequest(2) === 2, \"Expected factorial of 2 modulo 10007 is 2\");\n    console.assert(processRequest(3) === 6, \"Expected factorial of 3 modulo 10007 is 6\");\n    console.assert(processRequest(4) === 24, \"Expected factorial of 4 modulo 10007 is 24\");\n    console.assert(processRequest(10) === 6266, \"Expected factorial of 10 modulo 10007 is 6266\");\n    console.assert(processRequest(10000) === 6991, \"Expected factorial of 10000 modulo 10007 is 6991\");\n\n    // console.log(\"All tests passed.\");\n}\n\ntestProcessRequest();",
    "entry_point": "processRequest",
    "signature": "function processRequest(n)",
    "docstring": {
      "en": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n\nExamples:\nprocessRequest(1) returns 1\n",
      "es": "Encontrar el factorial de N y tomar el módulo 10007 del resultado.\n\nParámetros:\n- N (number): Un entero no negativo que representa el valor de entrada (N <= 10000).\n\nDevuelve:\n- number: El resultado después de tomar el módulo 10007 del factorial de N.\n\nEjemplos:\nprocessRequest(1) devuelve 1",
      "arb": "احسب مضروب N وخذ باقي القسمة 10007 من النتيجة.\n\nالمعطيات:\n- N (عدد): عدد صحيح غير سالب يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\n- عدد: النتيجة بعد أخذ باقي القسمة 10007 من مضروب N.\n\nأمثلة:\nprocessRequest(1) يعيد 1",
      "sw": "Tafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n\nVigezo:\n- N (number): Nambari isiyo hasi inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\n- number: Matokeo baada ya kuchukua modulo 10007 ya factorial ya N.\n\nMifano:\nprocessRequest(1) inarejesha 1",
      "tr": "N'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n\nParametreler:\n- N (number): Girdi değerini temsil eden negatif olmayan bir tamsayı (N <= 10000).\n\nDöndürür:\n- number: N faktöriyelinin 10007 ile modülüsünün alınmasından sonra elde edilen sonuç.\n\nÖrnekler:\nprocessRequest(1) 1 döndürür",
      "vi": "Tìm giai thừa của N và lấy phần dư 10007 của kết quả.\n\nTham số:\n- N (number): Một số nguyên không âm đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\n- number: Kết quả sau khi lấy phần dư 10007 của giai thừa của N.\n\nVí dụ:\nprocessRequest(1) trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.8971654763913798",
      "sw": "0.9732780562089954",
      "tr": "0.9588588809585298",
      "vi": "0.9572231597707075"
    }
  },
  {
    "task_id": "JavaScript/7",
    "prompt": {
      "en": "// No direct imports are needed in JavaScript as we are not using any specific external libraries for this code\n/**\n * Calculate the area of a triangle given its base and height.\n * Parameters:\n * - base (number): The base length of the triangle.\n * - height (number): The height of the triangle.\n * Returns:\n * float: The calculated area of the triangle, rounded to one decimal place.\n * Examples:\n * calculate_triangle_area(1,2) returns 1.0\n */\nconst calculate_triangle_area = (base, height) =>",
      "es": "// No se necesitan importaciones directas en JavaScript ya que no estamos utilizando ninguna biblioteca externa específica para este código\n/**\n * Calcular el área de un triángulo dado su base y altura.\n * Parámetros:\n * - base (número): La longitud de la base del triángulo.\n * - height (número): La altura del triángulo.\n * Devuelve:\n * float: El área calculada del triángulo, redondeada a un decimal.\n * Ejemplos:\n * calculate_triangle_area(1,2) devuelve 1.0\n */\nconst calculate_triangle_area = (base, height) =>",
      "arb": "// لا حاجة لاستيرادات مباشرة في JavaScript حيث أننا لا نستخدم أي مكتبات خارجية محددة لهذا الكود\n/**\n * حساب مساحة المثلث المعطى قاعدته وارتفاعه.\n * المعاملات:\n * - base (number): طول قاعدة المثلث.\n * - height (number): ارتفاع المثلث.\n * يعيد:\n * float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n * أمثلة:\n * calculate_triangle_area(1,2) يعيد 1.0\n */\nconst calculate_triangle_area = (base, height) =>",
      "sw": "// Hakuna uingizaji wa moja kwa moja unahitajika katika JavaScript kwani hatutumii maktaba yoyote maalum ya nje kwa msimbo huu\n/**\n * Kuhesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n * Vigezo:\n * - base (nambari): Urefu wa msingi wa pembetatu.\n * - height (nambari): Urefu wa pembetatu.\n * Inarudisha:\n * float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n * Mifano:\n * calculate_triangle_area(1,2) inarudisha 1.0\n */\nconst calculate_triangle_area = (base, height) =>",
      "tr": "// Bu kod için belirli bir harici kütüphane kullanmadığımız için JavaScript'te doğrudan ithalat gerekmez\n/**\n * Tabanı ve yüksekliği verilen bir üçgenin alanını hesaplayın.\n * Parametreler:\n * - base (number): Üçgenin taban uzunluğu.\n * - height (number): Üçgenin yüksekliği.\n * Döndürür:\n * float: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış olarak.\n * Örnekler:\n * calculate_triangle_area(1,2) 1.0 döndürür\n */\nconst calculate_triangle_area = (base, height) =>",
      "vi": "// Không cần nhập trực tiếp trong JavaScript vì chúng ta không sử dụng bất kỳ thư viện bên ngoài cụ thể nào cho mã này\n/**\n * Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n * Tham số:\n * - base (number): Chiều dài đáy của tam giác.\n * - height (number): Chiều cao của tam giác.\n * Trả về:\n * float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n * Ví dụ:\n * calculate_triangle_area(1,2) trả về 1.0\n */\nconst calculate_triangle_area = (base, height) =>"
    },
    "prompt_bertscore": {
      "es": "0.9880688689023773",
      "arb": "0.9848290087573173",
      "sw": "0.9799921603487367",
      "tr": "0.9773454105214469",
      "vi": "0.971891814779753"
    },
    "canonical_solution": "{\n    return (base * height) / 2.0; // The formula for the area of a triangle is (base * height) / 2\n};",
    "instruction": {
      "en": "Write a JavaScript function `const calculate_triangle_area = (base, height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExamples:\ncalculate_triangle_area(1,2) returns 1.0",
      "es": "Escribe una función de JavaScript `const calculate_triangle_area = (base, height)` para resolver el siguiente problema:\nCalcular el área de un triángulo dado su base y altura.\nParámetros:\n- base (number): La longitud de la base del triángulo.\n- height (number): La altura del triángulo.\nDevuelve:\nfloat: El área calculada del triángulo, redondeada a un decimal.\nEjemplos:\ncalculate_triangle_area(1,2) devuelve 1.0",
      "arb": "اكتب دالة JavaScript `const calculate_triangle_area = (base, height)` لحل المشكلة التالية:\nحساب مساحة المثلث المعطى قاعدته وارتفاعه.\nالمعطيات:\n- base (number): طول قاعدة المثلث.\n- height (number): ارتفاع المثلث.\nالإرجاع:\nfloat: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.\nأمثلة:\ncalculate_triangle_area(1,2) يعيد 1.0",
      "sw": "Andika kazi ya JavaScript `const calculate_triangle_area = (base, height)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukitumia msingi wake na urefu.\nVigezo:\n- base (number): Urefu wa msingi wa pembetatu.\n- height (number): Urefu wa pembetatu.\nInarejesha:\nfloat: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\nMifano:\ncalculate_triangle_area(1,2) inarejesha 1.0",
      "tr": "Bir JavaScript fonksiyonu `const calculate_triangle_area = (base, height)` yazın:\nÜçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\nParametreler:\n- base (number): Üçgenin taban uzunluğu.\n- height (number): Üçgenin yüksekliği.\nDöndürür:\nfloat: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış.\nÖrnekler:\ncalculate_triangle_area(1,2) 1.0 döndürür",
      "vi": "Viết một hàm JavaScript `const calculate_triangle_area = (base, height)` để giải quyết vấn đề sau:  \nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.  \nTham số:  \n- base (number): Chiều dài đáy của tam giác.  \n- height (number): Chiều cao của tam giác.  \nTrả về:  \nfloat: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.  \nVí dụ:  \ncalculate_triangle_area(1,2) trả về 1.0  "
    },
    "instruction_bertscore": {
      "es": "0.9895276104206976",
      "arb": "0.9895276104206976",
      "sw": "0.9860019211573283",
      "tr": "0.9559630486334222",
      "vi": "0.987508731227859"
    },
    "level": "easy",
    "test": "const testCalculateTriangleArea = () => {\n    const epsilon = 1e-6;\n    console.assert(Math.abs(calculate_triangle_area(1, 2) - 1.0) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(3, 4) - 6.0) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(5, 8) - 20.0) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(7, 3) - 10.5) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(10, 10) - 50.0) < epsilon);\n    \n    // console.log(\"All tests passed.\");\n};\n\ntestCalculateTriangleArea();",
    "entry_point": "calculate_triangle_area",
    "signature": "const calculate_triangle_area = (base, height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExamples:\ncalculate_triangle_area(1,2) returns 1.0",
      "es": "Calcular el área de un triángulo dado su base y altura.\nParámetros:\n- base (number): La longitud de la base del triángulo.\n- height (number): La altura del triángulo.\nDevuelve:\nfloat: El área calculada del triángulo, redondeada a un decimal.\nEjemplos:\ncalculate_triangle_area(1,2) devuelve 1.0",
      "arb": "احسب مساحة المثلث بناءً على قاعدته وارتفاعه.\nالمعلمات:\n- base (number): طول قاعدة المثلث.\n- height (number): ارتفاع المثلث.\nالقيم المعادة:\nfloat: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\nأمثلة:\ncalculate_triangle_area(1,2) يعيد 1.0",
      "sw": "Hesabu eneo la pembetatu ukitumia msingi wake na urefu.\nVigezo:\n- base (number): Urefu wa msingi wa pembetatu.\n- height (number): Urefu wa pembetatu.\nInarejesha:\nfloat: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\nMifano:\ncalculate_triangle_area(1,2) inarejesha 1.0",
      "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\nParametreler:\n- base (number): Üçgenin taban uzunluğu.\n- height (number): Üçgenin yüksekliği.\nDöndürülen:\nfloat: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\nÖrnekler:\ncalculate_triangle_area(1,2) 1.0 döndürür",
      "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.  \nTham số:  \n- base (number): Chiều dài đáy của tam giác.  \n- height (number): Chiều cao của tam giác.  \nTrả về:  \nfloat: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.  \nVí dụ:  \ncalculate_triangle_area(1,2) trả về 1.0  "
    },
    "docstring_bertscore": {
      "es": "0.9891764319070279",
      "arb": "0.9775253696466645",
      "sw": "0.9832743287649572",
      "tr": "1",
      "vi": "0.9751632571553975"
    }
  },
  {
    "task_id": "JavaScript/8",
    "prompt": {
      "en": "\n/**\n * Calculate the Hamming distance between two integers in their binary representation.\n *\n * Parameters:\n * - x: The first positive integer (x <= 1,000,000,000).\n * - y: The second positive integer (y <= 1,000,000,000).\n *\n * Returns:\n * The Hamming distance between x and y, i.e., the number of bits that need to be\n * flipped to transform x into y.\n * \n * Examples:\n * hammingDistance(1, 2) // returns 2\n */\nfunction hammingDistance(x, y)",
      "es": "/**\n * Calcular la distancia de Hamming entre dos enteros en su representación binaria.\n *\n * Parámetros:\n * - x: El primer entero positivo (x <= 1,000,000,000).\n * - y: El segundo entero positivo (y <= 1,000,000,000).\n *\n * Devuelve:\n * La distancia de Hamming entre x e y, es decir, el número de bits que deben ser\n * cambiados para transformar x en y.\n * \n * Ejemplos:\n * hammingDistance(1, 2) // devuelve 2\n */\nfunction hammingDistance(x, y)",
      "arb": "/**\n * حساب مسافة هامنج بين عددين صحيحين في تمثيلهما الثنائي.\n *\n * المعاملات:\n * - x: العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n * - y: العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n *\n * يعيد:\n * مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى\n * قلبها لتحويل x إلى y.\n * \n * أمثلة:\n * hammingDistance(1, 2) // يعيد 2\n */\nfunction hammingDistance(x, y)",
      "sw": "/**\n * Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wao wa binary.\n *\n * Vigezo:\n * - x: Nambari ya kwanza chanya (x <= 1,000,000,000).\n * - y: Nambari ya pili chanya (y <= 1,000,000,000).\n *\n * Inarejesha:\n * Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji\n * kubadilishwa ili kubadilisha x kuwa y.\n * \n * Mifano:\n * hammingDistance(1, 2) // inarejesha 2\n */\nfunction hammingDistance(x, y)",
      "tr": "/**\n * İki tam sayının ikili gösterimlerinde Hamming mesafesini hesapla.\n *\n * Parametreler:\n * - x: İlk pozitif tam sayı (x <= 1,000,000,000).\n * - y: İkinci pozitif tam sayı (y <= 1,000,000,000).\n *\n * Döndürür:\n * x ve y arasındaki Hamming mesafesi, yani x'i y'ye dönüştürmek için\n * çevrilmesi gereken bit sayısı.\n * \n * Örnekler:\n * hammingDistance(1, 2) // 2 döndürür\n */\nfunction hammingDistance(x, y)",
      "vi": "/**\n * Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân của chúng.\n *\n * Tham số:\n * - x: Số nguyên dương thứ nhất (x <= 1,000,000,000).\n * - y: Số nguyên dương thứ hai (y <= 1,000,000,000).\n *\n * Trả về:\n * Khoảng cách Hamming giữa x và y, tức là số bit cần phải\n * lật để biến đổi x thành y.\n * \n * Ví dụ:\n * hammingDistance(1, 2) // trả về 2\n */\nfunction hammingDistance(x, y)"
    },
    "prompt_bertscore": {
      "es": "0.9905018924396737",
      "arb": "0.9959151662140175",
      "sw": "0.9708696628389475",
      "tr": "0.9764481970903123",
      "vi": "0.9858763867565142"
    },
    "canonical_solution": "{\n    let distance = 0;\n    let xorResult = x ^ y; // XOR x and y to get a number where set bits are the differences\n\n    // Count the number of bits set in xorResult\n    while (xorResult) {\n        distance += xorResult & 1; // Increment distance if the last bit is set\n        xorResult >>= 1; // Shift right by one bit to check the next bit\n    }\n\n    return distance;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function hammingDistance(x, y)` to solve the following problem:\nCalculate the Hamming distance between two integers in their binary representation.\n\nParameters:\n- x: The first positive integer (x <= 1,000,000,000).\n- y: The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- The Hamming distance between x and y, i.e., the number of bits that need to be\nflipped to transform x into y.\n\nExamples:\n- hammingDistance(1, 2) // returns 2\n",
      "es": "Escribe una función de JavaScript `function hammingDistance(x, y)` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en su representación binaria.\n\nParámetros:\n- x: El primer entero positivo (x <= 1,000,000,000).\n- y: El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser\ncambiados para transformar x en y.\n\nEjemplos:\n- hammingDistance(1, 2) // devuelve 2",
      "arb": "اكتب دالة JavaScript `function hammingDistance(x, y)` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في تمثيلهما الثنائي.\n\nالمعطيات:\n- x: العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y: العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالقيم المعادة:\n- مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى\nتغيير لتحويل x إلى y.\n\nأمثلة:\n- hammingDistance(1, 2) // يعيد 2",
      "sw": "Andika kazi ya JavaScript `function hammingDistance(x, y)` kutatua tatizo lifuatalo: \nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wao wa binary.\n\nVigezo:\n- x: Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y: Nambari ya pili chanya (y <= 1,000,000,000).\n\nInarudisha:\n- Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n- hammingDistance(1, 2) // inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `function hammingDistance(x, y)` yazın ve aşağıdaki problemi çözün:\nİki tam sayının ikili gösterimlerinde Hamming mesafesini hesaplayın.\n\nParametreler:\n- x: İlk pozitif tam sayı (x <= 1,000,000,000).\n- y: İkinci pozitif tam sayı (y <= 1,000,000,000).\n\nDöndürür:\n- x ve y arasındaki Hamming mesafesi, yani x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n- hammingDistance(1, 2) // 2 döndürür",
      "vi": "Viết một hàm JavaScript `function hammingDistance(x, y)` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong dạng biểu diễn nhị phân của chúng.\n\nTham số:\n- x: Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y: Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y.\n\nVí dụ:\n- hammingDistance(1, 2) // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.988704088860927",
      "arb": "0.9690212085130367",
      "sw": "0.9715932733170576",
      "tr": "0.976349477790938",
      "vi": "0.9874396078552589"
    },
    "level": "middle",
    "test": "const testHammingDistance = () => {\n    console.assert(hammingDistance(1, 2) === 2, \"01 and 10 have 2 different bits\");\n    console.assert(hammingDistance(4, 7) === 2, \"100 and 111 have 2 different bits\");\n    console.assert(hammingDistance(25, 30) === 3, \"11001 and 11110 have 3 different bits\");\n    console.assert(hammingDistance(0, 0) === 0, \"Same numbers have 0 different bits\");\n    console.assert(hammingDistance(0xFFFFFFF, 0x0000000) === 28,\n                   \"Max unsigned int and 0 have 28 different bits\");\n}\n\n// Run the test function\ntestHammingDistance();",
    "entry_point": "hammingDistance",
    "signature": "function hammingDistance(x, y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in their binary representation.\n\nParameters:\n- x: The first positive integer (x <= 1,000,000,000).\n- y: The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- The Hamming distance between x and y, i.e., the number of bits that need to be\nflipped to transform x into y.\n\nExamples:\n- hammingDistance(1, 2) // returns 2\n",
      "es": "Calcular la distancia de Hamming entre dos enteros en su representación binaria.\n\nParámetros:\n- x: El primer entero positivo (x <= 1,000,000,000).\n- y: El segundo entero positivo (y <= 1,000,000,000).\n\nDevuelve:\n- La distancia de Hamming entre x e y, es decir, el número de bits que deben ser\ncambiados para transformar x en y.\n\nEjemplos:\n- hammingDistance(1, 2) // devuelve 2",
      "arb": "احسب مسافة هامنج بين عددين صحيحين في تمثيلهما الثنائي.\n\nالمعلمات:\n- x: العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y: العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n\nالقيم المعادة:\n- مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى\nتغيير لتحويل x إلى y.\n\nأمثلة:\n- hammingDistance(1, 2) // يعيد 2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wao wa binary.\n\nVigezo:\n- x: Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y: Nambari ya pili chanya (y <= 1,000,000,000).\n\nRudisha:\n- Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika\nkubadilishwa ili kubadilisha x kuwa y.\n\nMifano:\n- hammingDistance(1, 2) // inarudisha 2",
      "tr": "İkili gösterimlerinde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n\nParametreler:\n- x: İlk pozitif tamsayı (x <= 1,000,000,000).\n- y: İkinci pozitif tamsayı (y <= 1,000,000,000).\n\nDöndürür:\n- x ve y arasındaki Hamming mesafesi, yani x'i y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\nÖrnekler:\n- hammingDistance(1, 2) // 2 döndürür",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân của chúng.\n\nTham số:\n- x: Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y: Số nguyên dương thứ hai (y <= 1,000,000,000).\n\nTrả về:\n- Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi để biến đổi x thành y.\n\nVí dụ:\n- hammingDistance(1, 2) // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9860219828258129",
      "arb": "0.9710774302175099",
      "sw": "0.9664628492053075",
      "tr": "0.9957234878963188",
      "vi": "0.9783038021099402"
    }
  },
  {
    "task_id": "JavaScript/9",
    "prompt": {
      "en": "\n/**\n * Count the number of odd integers in a given list of numbers.\n *\n * @param {number} count - The count of numbers to evaluate.\n * @param {...number} nums - A sequence of integers.\n * @returns {number} The count of odd numbers in the input list.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "es": "/**\n * Contar el número de enteros impares en una lista dada de números.\n *\n * @param {number} count - La cantidad de números a evaluar.\n * @param {...number} nums - Una secuencia de enteros.\n * @returns {number} La cantidad de números impares en la lista de entrada.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // devuelve 3\n */\nfunction countOddNumbers(count, ...nums)",
      "arb": "/**\n * احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n *\n * @param {number} count - عدد الأرقام لتقييمها.\n * @param {...number} nums - سلسلة من الأعداد الصحيحة.\n * @returns {number} عدد الأعداد الفردية في قائمة الإدخال.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // يعيد 3\n */\nfunction countOddNumbers(count, ...nums)",
      "sw": "/**\n * Hesabu idadi ya namba zisizo za kawaida katika orodha iliyotolewa ya namba.\n *\n * @param {number} count - Idadi ya namba za kutathmini.\n * @param {...number} nums - Mfululizo wa namba za mzima.\n * @returns {number} Idadi ya namba zisizo za kawaida katika orodha ya pembejeo.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // inarejesha 3\n */\nfunction countOddNumbers(count, ...nums)",
      "tr": "/**\n * Verilen bir sayı listesindeki tek tam sayıların sayısını hesapla.\n *\n * @param {number} count - Değerlendirilecek sayıların sayısı.\n * @param {...number} nums - Bir dizi tam sayı.\n * @returns {number} Girdi listesindeki tek sayıların sayısı.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // 3 döndürür\n */\nfunction countOddNumbers(count, ...nums)",
      "vi": "/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n *\n * @param {number} count - Số lượng số cần đánh giá.\n * @param {...number} nums - Một dãy số nguyên.\n * @returns {number} Số lượng số lẻ trong danh sách đầu vào.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // trả về 3\n */\nfunction countOddNumbers(count, ...nums)"
    },
    "prompt_bertscore": {
      "es": "0.9922496411623997",
      "arb": "0.9772190815991086",
      "sw": "0.9663426778247813",
      "tr": "0.9716798761631887",
      "vi": "0.9922496411623997"
    },
    "canonical_solution": "{\n    let ans = 0;\n    for (let i = 0; i < count; i++) {\n        if (nums[i] % 2 !== 0) {\n            ans++;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countOddNumbers(count, ...nums)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n@param {number} count - The count of numbers to evaluate.\n@param {...number} nums - A sequence of integers.\n\nReturns:\n@returns {number} The count of odd numbers in the input list.\n\nExample:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "es": "Escribe una función de JavaScript `function countOddNumbers(count, ...nums)` para resolver el siguiente problema:\nCuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n@param {number} count - La cantidad de números a evaluar.\n@param {...number} nums - Una secuencia de enteros.\n\nDevuelve:\n@returns {number} La cantidad de números impares en la lista de entrada.\n\nEjemplo:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // devuelve 3",
      "arb": "اكتب دالة JavaScript `function countOddNumbers(count, ...nums)` لحل المشكلة التالية:\nعد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n@param {number} count - عدد الأرقام لتقييمها.\n@param {...number} nums - تسلسل من الأعداد الصحيحة.\n\nالقيم المعادة:\n@returns {number} عدد الأعداد الفردية في قائمة الإدخال.\n\nمثال:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // يعيد 3",
      "sw": "Andika kazi ya JavaScript `function countOddNumbers(count, ...nums)` kutatua tatizo lifuatalo:\nHesabu idadi ya nambari zisizogawanyika kwa mbili katika orodha iliyotolewa ya nambari.\n\nVigezo:\n@param {number} count - Idadi ya nambari za kutathmini.\n@param {...number} nums - Mlolongo wa nambari nzima.\n\nInarejesha:\n@returns {number} Idadi ya nambari zisizogawanyika kwa mbili katika orodha ya pembejeo.\n\nMfano:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // inarejesha 3",
      "tr": "Bir JavaScript fonksiyonu `function countOddNumbers(count, ...nums)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n@param {number} count - Değerlendirilecek sayıların sayısı.\n@param {...number} nums - Bir dizi tam sayı.\n\nDöndürür:\n@returns {number} Girdi listesindeki tek sayıların sayısı.\n\nÖrnek:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // 3 döndürür",
      "vi": "Viết một hàm JavaScript `function countOddNumbers(count, ...nums)` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n@param {number} count - Số lượng số cần đánh giá.\n@param {...number} nums - Một dãy các số nguyên.\n\nTrả về:\n@returns {number} Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9931704916088775",
      "arb": "0.9855033589009308",
      "sw": "0.9417039694700706",
      "tr": "0.9692150717649268",
      "vi": "0.9931704916088775"
    },
    "level": "easy",
    "test": "const testCountOddNumbers = () => {\n    console.assert(countOddNumbers(5, 1, 4, 3, 2, 5) === 3, \"Test 1 failed\");\n    console.assert(countOddNumbers(4, 2, 2, 0, 0) === 0, \"Test 2 failed\");\n    console.assert(countOddNumbers(6, 7, 7, 8, 1, 9, 10) === 4, \"Test 3 failed\"); // Additional Test Sample\n    // console.log(\"All tests passed!\");\n}\n\ntestCountOddNumbers();",
    "entry_point": "countOddNumbers",
    "signature": "function countOddNumbers(count, ...nums)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n@param {number} count - The count of numbers to evaluate.\n@param {...number} nums - A sequence of integers.\n\nReturns:\n@returns {number} The count of odd numbers in the input list.\n\nExample:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "es": "Cuenta el número de enteros impares en una lista dada de números.\n\nParámetros:\n@param {number} count - La cantidad de números a evaluar.\n@param {...number} nums - Una secuencia de enteros.\n\nDevuelve:\n@returns {number} La cantidad de números impares en la lista de entrada.\n\nEjemplo:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // devuelve 3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\nالمعلمات:\n@param {number} count - عدد الأرقام لتقييمها.\n@param {...number} nums - تسلسل من الأعداد الصحيحة.\n\nالقيم المعادة:\n@returns {number} عدد الأعداد الفردية في قائمة الإدخال.\n\nمثال:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // يعيد 3",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n\nVigezo:\n@param {number} count - Idadi ya nambari za kutathmini.\n@param {...number} nums - Mlolongo wa nambari nzima.\n\nInarudisha:\n@returns {number} Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.\n\nMfano:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // inarudisha 3",
      "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n\nParametreler:\n@param {number} count - Değerlendirilecek sayıların sayısı.\n@param {...number} nums - Bir dizi tam sayı.\n\nDöndürülenler:\n@returns {number} Girdi listesindeki tek sayıların sayısı.\n\nÖrnek:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // 3 döndürür",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\nTham số:\n@param {number} count - Số lượng số cần đánh giá.\n@param {...number} nums - Một dãy các số nguyên.\n\nTrả về:\n@returns {number} Số lượng số lẻ trong danh sách đầu vào.\n\nVí dụ:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.991141482266606",
      "arb": "0.9684731872917615",
      "sw": "0.9898662752203621",
      "tr": "0.9629202763595501",
      "vi": "0.991141482266606"
    }
  },
  {
    "task_id": "JavaScript/10",
    "prompt": {
      "en": "\n/**\n * Calculate the sum of even numbers in a given list.\n * Parameters:\n * - numbers (Array): An array of integers.\n * - size (Number): The size of the array.\n * Returns:\n *   Number: The sum of even numbers in the input array.\n * Example usage:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n */\nfunction calculateEvenSum(numbers, size)",
      "es": "/**\n * Calcular la suma de los números pares en una lista dada.\n * Parámetros:\n * - numbers (Array): Un array de enteros.\n * - size (Number): El tamaño del array.\n * Devuelve:\n *   Number: La suma de los números pares en el array de entrada.\n * Ejemplo de uso:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // devuelve 6\n */\nfunction calculateEvenSum(numbers, size)",
      "arb": "/**\n * احسب مجموع الأعداد الزوجية في قائمة معينة.\n * المعلمات:\n * - numbers (Array): مصفوفة من الأعداد الصحيحة.\n * - size (Number): حجم المصفوفة.\n * يعيد:\n *   Number: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * مثال على الاستخدام:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // يعيد 6\n */\nfunction calculateEvenSum(numbers, size)",
      "sw": "/**\n * Hesabu jumla ya namba shufwa katika orodha iliyotolewa.\n * Vigezo:\n * - numbers (Array): Orodha ya nambari za mzima.\n * - size (Number): Ukubwa wa orodha.\n * Inarudisha:\n *   Number: Jumla ya namba shufwa katika orodha ya ingizo.\n * Mfano wa matumizi:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // inarudisha 6\n */\nfunction calculateEvenSum(numbers, size)",
      "tr": "/**\n * Verilen bir listedeki çift sayıların toplamını hesapla.\n * Parametreler:\n * - numbers (Array): Bir tamsayı dizisi.\n * - size (Number): Dizinin boyutu.\n * Döndürür:\n *   Number: Girdi dizisindeki çift sayıların toplamı.\n * Örnek kullanım:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 döndürür\n */\nfunction calculateEvenSum(numbers, size)",
      "vi": "/**\n * Tính tổng các số chẵn trong một danh sách cho trước.\n * Tham số:\n * - numbers (Array): Một mảng các số nguyên.\n * - size (Number): Kích thước của mảng.\n * Trả về:\n *   Number: Tổng các số chẵn trong mảng đầu vào.\n * Ví dụ sử dụng:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // trả về 6\n */\nfunction calculateEvenSum(numbers, size)"
    },
    "prompt_bertscore": {
      "es": "0.9846313715281876",
      "arb": "0.9946204933904321",
      "sw": "0.9635749620954411",
      "tr": "0.999999801369619",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "{\n    let ans = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculateEvenSum(numbers, size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n",
      "es": "Escribe una función de JavaScript `function calculateEvenSum(numbers, size)` para resolver el siguiente problema:\nCalcular la suma de los números pares en una lista dada.\nParámetros:\n- numbers (Array): Un array de enteros.\n- size (Number): El tamaño del array.\nDevuelve:\n  Number: La suma de los números pares en el array de entrada.\nEjemplo de uso:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // devuelve 6",
      "arb": "اكتب دالة JavaScript `function calculateEvenSum(numbers, size)` لحل المشكلة التالية:\nاحسب مجموع الأعداد الزوجية في قائمة معينة.\nالمعطيات:\n- numbers (Array): مصفوفة من الأعداد الصحيحة.\n- size (Number): حجم المصفوفة.\nالقيم المعادة:\n  Number: مجموع الأعداد الزوجية في المصفوفة المدخلة.\nمثال على الاستخدام:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // يعيد 6",
      "sw": "Andika kazi ya JavaScript `function calculateEvenSum(numbers, size)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\nVigezo:\n- numbers (Array): Orodha ya namba nzima.\n- size (Number): Ukubwa wa orodha.\nInarudisha:\n  Number: Jumla ya namba shufwa katika orodha ya ingizo.\nMfano wa matumizi:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // inarudisha 6",
      "tr": "Bir JavaScript fonksiyonu `function calculateEvenSum(numbers, size)` yazın:\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\nParametreler:\n- numbers (Array): Bir tamsayı dizisi.\n- size (Number): Dizinin boyutu.\nDöndürür:\n  Number: Girdi dizisindeki çift sayıların toplamı.\nÖrnek kullanım:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 döndürür",
      "vi": "Viết một hàm JavaScript `function calculateEvenSum(numbers, size)` để giải quyết vấn đề sau:\nTính tổng của các số chẵn trong một danh sách cho trước.\nTham số:\n- numbers (Array): Một mảng các số nguyên.\n- size (Number): Kích thước của mảng.\nTrả về:\n  Number: Tổng của các số chẵn trong mảng đầu vào.\nVí dụ sử dụng:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.9883241089420072",
      "arb": "0.9705802583737796",
      "sw": "0.9678069809937705",
      "tr": "0.9716107527905886",
      "vi": "1"
    },
    "level": "easy",
    "test": "const testCalculateEvenSum = () => {\n    console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6);\n    console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4);\n    console.assert(calculateEvenSum([7, 11, 19], 3) === 0); // Should return 0 because there are no even numbers\n    console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20));\n\n    // console.log(\"All tests passed successfully.\");\n}\n\ntestCalculateEvenSum();",
    "entry_point": "calculateEvenSum",
    "signature": "function calculateEvenSum(numbers, size)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n",
      "es": "Calcular la suma de los números pares en una lista dada.\nParámetros:\n- numbers (Array): Un arreglo de enteros.\n- size (Number): El tamaño del arreglo.\nDevuelve:\n  Number: La suma de los números pares en el arreglo de entrada.\nEjemplo de uso:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // devuelve 6",
      "arb": "احسب مجموع الأعداد الزوجية في قائمة معينة.  \nالمعلمات:  \n- numbers (Array): مصفوفة من الأعداد الصحيحة.  \n- size (Number): حجم المصفوفة.  \nالقيم المعادة:  \n  Number: مجموع الأعداد الزوجية في المصفوفة المدخلة.  \nمثال على الاستخدام:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // يعيد 6  ",
      "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.  \nVigezo:  \n- numbers (Array): Orodha ya namba nzima.  \n- size (Number): Ukubwa wa orodha.  \nInarejesha:  \n  Number: Jumla ya namba shufwa katika orodha ya pembejeo.  \nMfano wa matumizi:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // inarejesha 6  ",
      "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.  \nParametreler:  \n- numbers (Dizi): Bir tamsayı dizisi.  \n- size (Sayı): Dizinin boyutu.  \nDöndürülen:  \n  Sayı: Girdi dizisindeki çift sayıların toplamı.  \nÖrnek kullanım:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 döndürür  ",
      "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\nTham số:\n- numbers (Array): Một mảng các số nguyên.\n- size (Number): Kích thước của mảng.\nTrả về:\n  Number: Tổng các số chẵn trong mảng đầu vào.\nVí dụ sử dụng:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9930848819146514",
      "arb": "0.9877381493179542",
      "sw": "0.9579894757807401",
      "tr": "1",
      "vi": "0.9966723452265225"
    }
  },
  {
    "task_id": "JavaScript/11",
    "prompt": {
      "en": "// No import is necessary as we're not using any modules or libraries\n/**\n * Determine if two closed intervals intersect.\n * \n * @param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n * @param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n * @param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n * @param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n * @returns {number} 1 if the intervals intersect, 0 otherwise.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "es": "// No es necesario importar ya que no estamos usando ningún módulo o biblioteca\n/**\n * Determinar si dos intervalos cerrados se intersectan.\n * \n * @param {number} a - Inicio del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n * @param {number} b - Fin del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n * @param {number} c - Inicio del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n * @param {number} d - Fin del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n * @returns {number} 1 si los intervalos se intersectan, 0 en caso contrario.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "arb": "// لا حاجة للاستيراد لأننا لا نستخدم أي وحدات أو مكتبات\n/**\n * تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n * \n * @param {number} a - بداية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n * @param {number} b - نهاية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n * @param {number} c - بداية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n * @param {number} d - نهاية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n * @returns {number} 1 إذا كانت الفترات تتقاطع، 0 إذا لم تتقاطع.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "sw": "// Hakuna uingizaji unaohitajika kwani hatutumii moduli au maktaba\n/**\n * Kuamua kama vipindi viwili vilivyofungwa vinakatana.\n * \n * @param {number} a - Mwanzo wa kipindi cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n * @param {number} b - Mwisho wa kipindi cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n * @param {number} c - Mwanzo wa kipindi cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n * @param {number} d - Mwisho wa kipindi cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n * @returns {number} 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "tr": "// Herhangi bir modül veya kütüphane kullanmadığımız için ithalat gerekli değil\n/**\n * İki kapalı aralığın kesişip kesişmediğini belirleyin.\n * \n * @param {number} a - İlk kapalı aralığın başlangıcı, 0 <= a <= b <= 1000 şartını sağlamalıdır.\n * @param {number} b - İlk kapalı aralığın sonu, 0 <= a <= b <= 1000 şartını sağlamalıdır.\n * @param {number} c - İkinci kapalı aralığın başlangıcı, 0 <= c <= d <= 1000 şartını sağlamalıdır.\n * @param {number} d - İkinci kapalı aralığın sonu, 0 <= c <= d <= 1000 şartını sağlamalıdır.\n * @returns {number} Aralıklar kesişiyorsa 1, aksi takdirde 0 döner.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "vi": "// Không cần import vì chúng ta không sử dụng bất kỳ module hay thư viện nào\n/**\n * Xác định xem hai khoảng đóng có giao nhau hay không.\n * \n * @param {number} a - Điểm bắt đầu của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n * @param {number} b - Điểm kết thúc của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n * @param {number} c - Điểm bắt đầu của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n * @param {number} d - Điểm kết thúc của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n * @returns {number} 1 nếu các khoảng giao nhau, 0 nếu không.\n */\nfunction areIntervalsIntersecting(a, b, c, d)"
    },
    "prompt_bertscore": {
      "es": "0.9866804425389435",
      "arb": "0.9698161272979384",
      "sw": "0.9865610656799415",
      "tr": "0.9615133773706801",
      "vi": "0.9653242998612155"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function areIntervalsIntersecting(a, b, c, d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n",
      "es": "Escribe una función de JavaScript `function areIntervalsIntersecting(a, b, c, d)` para resolver el siguiente problema:\nDeterminar si dos intervalos cerrados se intersectan.\n\n@param {number} a - Inicio del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} b - Fin del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} c - Inicio del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@param {number} d - Fin del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@returns {number} 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "اكتب دالة JavaScript `function areIntervalsIntersecting(a, b, c, d)` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param {number} a - بداية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} b - نهاية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} c - بداية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@param {number} d - نهاية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@returns {number} 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.",
      "sw": "Andika kazi ya JavaScript `function areIntervalsIntersecting(a, b, c, d)` kutatua tatizo lifuatalo:  \nTambua kama vipindi viwili vilivyofungwa vinakatana.\n\n@param {number} a - Mwanzo wa kipindi cha kwanza kilichofungwa, lazima kitimize 0 <= a <= b <= 1000.\n@param {number} b - Mwisho wa kipindi cha kwanza kilichofungwa, lazima kitimize 0 <= a <= b <= 1000.\n@param {number} c - Mwanzo wa kipindi cha pili kilichofungwa, lazima kitimize 0 <= c <= d <= 1000.\n@param {number} d - Mwisho wa kipindi cha pili kilichofungwa, lazima kitimize 0 <= c <= d <= 1000.\n@returns {number} 1 ikiwa vipindi vinakatana, 0 vinginevyo.",
      "tr": "Bir JavaScript fonksiyonu `function areIntervalsIntersecting(a, b, c, d)` yazın ve aşağıdaki problemi çözün:\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n\n@param {number} a - İlk kapalı aralığın başlangıcı, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} b - İlk kapalı aralığın sonu, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} c - İkinci kapalı aralığın başlangıcı, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@param {number} d - İkinci kapalı aralığın sonu, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@returns {number} Aralıklar kesişiyorsa 1, aksi takdirde 0 döner.",
      "vi": "Viết một hàm JavaScript `function areIntervalsIntersecting(a, b, c, d)` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n\n@param {number} a - Điểm bắt đầu của đoạn đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} b - Điểm kết thúc của đoạn đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} c - Điểm bắt đầu của đoạn đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@param {number} d - Điểm kết thúc của đoạn đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@returns {number} 1 nếu các đoạn giao nhau, 0 nếu không."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9678304193787326",
      "vi": "0.9568813168849465"
    },
    "level": "easy",
    "test": "const testAreIntervalsIntersecting = () => {\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1);\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1);\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1);\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0);\n    // Additional test cases\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1);\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1);\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0);\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1);\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0);\n\n    // console.log(\"All tests passed.\");\n}\n\ntestAreIntervalsIntersecting();",
    "entry_point": "areIntervalsIntersecting",
    "signature": "function areIntervalsIntersecting(a, b, c, d)",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n",
      "es": "Determinar si dos intervalos cerrados se intersectan.\n\n@param {number} a - Inicio del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} b - Fin del primer intervalo cerrado, debe satisfacer 0 <= a <= b <= 1000.\n@param {number} c - Inicio del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@param {number} d - Fin del segundo intervalo cerrado, debe satisfacer 0 <= c <= d <= 1000.\n@returns {number} 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "تحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n\n@param {number} a - بداية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} b - نهاية الفترة المغلقة الأولى، يجب أن تحقق 0 <= a <= b <= 1000.\n@param {number} c - بداية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@param {number} d - نهاية الفترة المغلقة الثانية، يجب أن تحقق 0 <= c <= d <= 1000.\n@returns {number} 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.",
      "sw": "Tambua kama vipindi viwili vilivyofungwa vinakatana.\n\n@param {number} a - Mwanzo wa kipengele cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n@param {number} b - Mwisho wa kipengele cha kwanza kilichofungwa, lazima itimize 0 <= a <= b <= 1000.\n@param {number} c - Mwanzo wa kipengele cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n@param {number} d - Mwisho wa kipengele cha pili kilichofungwa, lazima itimize 0 <= c <= d <= 1000.\n@returns {number} 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.",
      "tr": "İki kapalı aralığın kesişip kesişmediğini belirleyin.\n\n@param {number} a - İlk kapalı aralığın başlangıcı, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} b - İlk kapalı aralığın sonu, 0 <= a <= b <= 1000 koşulunu sağlamalıdır.\n@param {number} c - İkinci kapalı aralığın başlangıcı, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@param {number} d - İkinci kapalı aralığın sonu, 0 <= c <= d <= 1000 koşulunu sağlamalıdır.\n@returns {number} Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\n@param {number} a - Điểm bắt đầu của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} b - Điểm kết thúc của khoảng đóng thứ nhất, phải thỏa mãn 0 <= a <= b <= 1000.\n@param {number} c - Điểm bắt đầu của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@param {number} d - Điểm kết thúc của khoảng đóng thứ hai, phải thỏa mãn 0 <= c <= d <= 1000.\n@returns {number} 1 nếu các khoảng giao nhau, 0 nếu không."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9740135845099677",
      "sw": "1",
      "tr": "0.9457748991293807",
      "vi": "0.9409831398172951"
    }
  },
  {
    "task_id": "JavaScript/12",
    "prompt": {
      "en": "\n/**\n * Given three digits a, b, and c, where two of them are equal and the third is different,\n * this function finds and returns the value that occurs exactly once.\n * Examples:\n * extraNumber(0, 0, 1) // returns 1\n * extraNumber(4, 3, 4) // returns 3\n */\nfunction extraNumber(a, b, c)",
      "es": "/**\n * Dado tres dígitos a, b y c, donde dos de ellos son iguales y el tercero es diferente,\n * esta función encuentra y devuelve el valor que ocurre exactamente una vez.\n * Ejemplos:\n * extraNumber(0, 0, 1) // devuelve 1\n * extraNumber(4, 3, 4) // devuelve 3\n */\nfunction extraNumber(a, b, c)",
      "arb": "/**\n * بالنظر إلى ثلاثة أرقام a و b و c، حيث أن اثنين منهما متساويان والثالث مختلف،\n * تقوم هذه الدالة بإيجاد وإرجاع القيمة التي تحدث مرة واحدة فقط.\n * أمثلة:\n * extraNumber(0, 0, 1) // يعيد 1\n * extraNumber(4, 3, 4) // يعيد 3\n */\nfunction extraNumber(a, b, c)",
      "sw": "/**\n * Kwa kuzingatia tarakimu tatu a, b, na c, ambapo mbili kati ya hizo ni sawa na ya tatu ni tofauti,\n * kazi hii inapata na kurudisha thamani inayotokea mara moja tu.\n * Mifano:\n * extraNumber(0, 0, 1) // inarudisha 1\n * extraNumber(4, 3, 4) // inarudisha 3\n */\nfunction extraNumber(a, b, c)",
      "tr": "/**\n * Üç basamaklı a, b ve c verildiğinde, bunlardan ikisi eşit ve üçüncüsü farklıdır,\n * bu fonksiyon tam olarak bir kez geçen değeri bulur ve döndürür.\n * Örnekler:\n * extraNumber(0, 0, 1) // 1 döndürür\n * extraNumber(4, 3, 4) // 3 döndürür\n */\nfunction extraNumber(a, b, c)",
      "vi": "/**\n * Cho ba chữ số a, b và c, trong đó hai số bằng nhau và số thứ ba khác,\n * hàm này tìm và trả về giá trị xuất hiện chính xác một lần.\n * Ví dụ:\n * extraNumber(0, 0, 1) // trả về 1\n * extraNumber(4, 3, 4) // trả về 3\n */\nfunction extraNumber(a, b, c)"
    },
    "prompt_bertscore": {
      "es": "0.9894414048353285",
      "arb": "0.9851001392274299",
      "sw": "0.9825082113853056",
      "tr": "0.9868157098284283",
      "vi": "0.9759172580818061"
    },
    "canonical_solution": "{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function extraNumber(a, b, c)` to solve the following problem:\nGiven three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\nExamples:\nextraNumber(0, 0, 1) // returns 1\nextraNumber(4, 3, 4) // returns 3\n",
      "es": "Escribe una función de JavaScript `function extraNumber(a, b, c)` para resolver el siguiente problema:  \nDado tres dígitos a, b y c, donde dos de ellos son iguales y el tercero es diferente,  \nesta función encuentra y devuelve el valor que ocurre exactamente una vez.  \nEjemplos:  \nextraNumber(0, 0, 1) // devuelve 1  \nextraNumber(4, 3, 4) // devuelve 3  ",
      "arb": "اكتب دالة JavaScript `function extraNumber(a, b, c)` لحل المشكلة التالية:\nمعطى ثلاثة أرقام a، b، و c، حيث أن اثنين منهما متساويان والثالث مختلف،\nتقوم هذه الدالة بإيجاد وإرجاع القيمة التي تظهر مرة واحدة فقط.\nأمثلة:\nextraNumber(0, 0, 1) // يعيد 1\nextraNumber(4, 3, 4) // يعيد 3",
      "sw": "Andika kazi ya JavaScript `function extraNumber(a, b, c)` kutatua tatizo lifuatalo:  \nUkipewa tarakimu tatu a, b, na c, ambapo mbili kati ya hizo ni sawa na ya tatu ni tofauti,  \nkazi hii inapata na kurudisha thamani inayotokea mara moja tu.  \nMifano:  \nextraNumber(0, 0, 1) // inarudisha 1  \nextraNumber(4, 3, 4) // inarudisha 3  ",
      "tr": "Bir JavaScript fonksiyonu `function extraNumber(a, b, c)` yazın ve aşağıdaki problemi çözün:\nÜç rakam verildiğinde a, b ve c, bunlardan ikisi eşit ve üçüncüsü farklı olduğunda,\nbu fonksiyon tam olarak bir kez meydana gelen değeri bulur ve döndürür.\nÖrnekler:\nextraNumber(0, 0, 1) // 1 döndürür\nextraNumber(4, 3, 4) // 3 döndürür",
      "vi": "Viết một hàm JavaScript `function extraNumber(a, b, c)` để giải quyết vấn đề sau:  \nCho ba chữ số a, b và c, trong đó hai số bằng nhau và số thứ ba khác biệt,  \nhàm này tìm và trả về giá trị xuất hiện đúng một lần.  \nVí dụ:  \nextraNumber(0, 0, 1) // trả về 1  \nextraNumber(4, 3, 4) // trả về 3  "
    },
    "instruction_bertscore": {
      "es": "0.9926574293346643",
      "arb": "0.982691944487763",
      "sw": "0.9865775520015674",
      "tr": "0.9723544249371833",
      "vi": "0.9748460444368848"
    },
    "level": "easy",
    "test": "const testExtraNumber = () => {\n    console.assert(extraNumber(2, 7, 2) === 7, 'Test with 2, 7, 2 failed');\n    console.assert(extraNumber(3, 2, 2) === 3, 'Test with 3, 2, 2 failed');\n    console.assert(extraNumber(5, 5, 1) === 1, 'Test with 5, 5, 1 failed');\n    console.assert(extraNumber(500000000, 3, 500000000) === 3, 'Test with 500000000, 3, 500000000 failed');\n    console.assert(extraNumber(500000000, 500000000, 3) === 3, 'Test with 500000000, 500000000, 3 failed');\n};\n\ntestExtraNumber();",
    "entry_point": "extraNumber",
    "signature": "function extraNumber(a, b, c)",
    "docstring": {
      "en": "Given three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\nExamples:\nextraNumber(0, 0, 1) // returns 1\nextraNumber(4, 3, 4) // returns 3\n",
      "es": "Dado tres dígitos a, b y c, donde dos de ellos son iguales y el tercero es diferente, esta función encuentra y devuelve el valor que ocurre exactamente una vez.\nEjemplos:\nextraNumber(0, 0, 1) // devuelve 1\nextraNumber(4, 3, 4) // devuelve 3",
      "arb": "بالنظر إلى ثلاثة أرقام a و b و c، حيث أن اثنين منهما متساويان والثالث مختلف، تقوم هذه الدالة بالعثور على القيمة التي تظهر مرة واحدة فقط وإعادتها.\nأمثلة:\nextraNumber(0, 0, 1) // يعيد 1\nextraNumber(4, 3, 4) // يعيد 3",
      "sw": "Kwa kupewa tarakimu tatu a, b, na c, ambapo mbili kati ya hizo ni sawa na ya tatu ni tofauti, \nkazi hii inatafuta na kurudisha thamani inayotokea mara moja tu.\nMifano:\nextraNumber(0, 0, 1) // inarudisha 1\nextraNumber(4, 3, 4) // inarudisha 3",
      "tr": "Üç basamaklı a, b ve c verildiğinde, bunlardan ikisi eşit ve üçüncüsü farklıdır, bu fonksiyon tam olarak bir kez ortaya çıkan değeri bulur ve döndürür.\nÖrnekler:\nextraNumber(0, 0, 1) // 1 döndürür\nextraNumber(4, 3, 4) // 3 döndürür",
      "vi": "Được cho ba chữ số a, b và c, trong đó hai số bằng nhau và số thứ ba khác biệt, hàm này tìm và trả về giá trị xuất hiện chính xác một lần.\n\nVí dụ:\nextraNumber(0, 0, 1) // trả về 1\nextraNumber(4, 3, 4) // trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9904254197429753",
      "arb": "0.964411394629979",
      "sw": "0.9700638193830889",
      "tr": "0.9947837675636428",
      "vi": "0.9648847308279852"
    }
  },
  {
    "task_id": "JavaScript/13",
    "prompt": {
      "en": "\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n * @param {number} score1 - The score in the first subject.\n * @param {number} score2 - The score in the second subject.\n * @param {number} score3 - The score in the third subject.\n * @param {number} score4 - The score in the fourth subject.\n * @param {number} score5 - The score in the fifth subject.\n * @returns {number} The total score obtained by summing up the scores in all subjects.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "es": "/**\n * Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n * @param {number} score1 - La puntuación en la primera materia.\n * @param {number} score2 - La puntuación en la segunda materia.\n * @param {number} score3 - La puntuación en la tercera materia.\n * @param {number} score4 - La puntuación en la cuarta materia.\n * @param {number} score5 - La puntuación en la quinta materia.\n * @returns {number} La puntuación total obtenida sumando las puntuaciones en todas las materias.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // devuelve 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "arb": "/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n * @param {number} score1 - الدرجة في المادة الأولى.\n * @param {number} score2 - الدرجة في المادة الثانية.\n * @param {number} score3 - الدرجة في المادة الثالثة.\n * @param {number} score4 - الدرجة في المادة الرابعة.\n * @param {number} score5 - الدرجة في المادة الخامسة.\n * @returns {number} المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // يعيد 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "sw": "/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n * @param {number} score1 - Alama katika somo la kwanza.\n * @param {number} score2 - Alama katika somo la pili.\n * @param {number} score3 - Alama katika somo la tatu.\n * @param {number} score4 - Alama katika somo la nne.\n * @param {number} score5 - Alama katika somo la tano.\n * @returns {number} Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // inarejesha 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "tr": "/**\n * Farklı derslerdeki puanlara dayalı olarak bir öğrencinin toplam puanını hesaplayın.\n * @param {number} score1 - İlk dersteki puan.\n * @param {number} score2 - İkinci dersteki puan.\n * @param {number} score3 - Üçüncü dersteki puan.\n * @param {number} score4 - Dördüncü dersteki puan.\n * @param {number} score5 - Beşinci dersteki puan.\n * @returns {number} Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // 500 döndürür\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "vi": "/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n * @param {number} score1 - Điểm số trong môn học thứ nhất.\n * @param {number} score2 - Điểm số trong môn học thứ hai.\n * @param {number} score3 - Điểm số trong môn học thứ ba.\n * @param {number} score4 - Điểm số trong môn học thứ tư.\n * @param {number} score5 - Điểm số trong môn học thứ năm.\n * @returns {number} Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // trả về 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)"
    },
    "prompt_bertscore": {
      "es": "0.9980446825290925",
      "arb": "0.9702707922401272",
      "sw": "0.9702707922401272",
      "tr": "0.9638800583607108",
      "vi": "0.9626944336163135"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculateTotalScore(score1, score2, score3, score4, score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n@param {number} score1 - The score in the first subject.\n@param {number} score2 - The score in the second subject.\n@param {number} score3 - The score in the third subject.\n@param {number} score4 - The score in the fourth subject.\n@param {number} score5 - The score in the fifth subject.\n@returns {number} The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500\n",
      "es": "Escribe una función de JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` para resolver el siguiente problema:\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n@param {number} score1 - La puntuación en la primera materia.\n@param {number} score2 - La puntuación en la segunda materia.\n@param {number} score3 - La puntuación en la tercera materia.\n@param {number} score4 - La puntuación en la cuarta materia.\n@param {number} score5 - La puntuación en la quinta materia.\n@returns {number} La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // devuelve 500",
      "arb": "اكتب دالة JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n@param {number} score1 - الدرجة في المادة الأولى.\n@param {number} score2 - الدرجة في المادة الثانية.\n@param {number} score3 - الدرجة في المادة الثالثة.\n@param {number} score4 - الدرجة في المادة الرابعة.\n@param {number} score5 - الدرجة في المادة الخامسة.\n@returns {number} المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // يعيد 500",
      "sw": "Andika kazi ya JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n@param {number} score1 - Alama katika somo la kwanza.\n@param {number} score2 - Alama katika somo la pili.\n@param {number} score3 - Alama katika somo la tatu.\n@param {number} score4 - Alama katika somo la nne.\n@param {number} score5 - Alama katika somo la tano.\n@returns {number} Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // inarejesha 500",
      "tr": "Bir JavaScript fonksiyonu `function calculateTotalScore(score1, score2, score3, score4, score5)` yazın ve aşağıdaki problemi çözün:\nFarklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n@param {number} score1 - İlk dersteki puan.\n@param {number} score2 - İkinci dersteki puan.\n@param {number} score3 - Üçüncü dersteki puan.\n@param {number} score4 - Dördüncü dersteki puan.\n@param {number} score5 - Beşinci dersteki puan.\n@returns {number} Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // 500 döndürür.",
      "vi": "Viết một hàm JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n@param {number} score1 - Điểm số trong môn học thứ nhất.\n@param {number} score2 - Điểm số trong môn học thứ hai.\n@param {number} score3 - Điểm số trong môn học thứ ba.\n@param {number} score4 - Điểm số trong môn học thứ tư.\n@param {number} score5 - Điểm số trong môn học thứ năm.\n@returns {number} Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // trả về 500"
    },
    "instruction_bertscore": {
      "es": "0.9918845585220576",
      "arb": "0.9972515514176202",
      "sw": "0.9723901784057695",
      "tr": "0.9622564536261315",
      "vi": "0.9676250355647426"
    },
    "level": "easy",
    "test": "function testCalculateTotalScore() {\n    console.assert(calculateTotalScore(100, 100, 100, 100, 100) === 500, 'Test failed: Expected 500 for all 100 scores');\n    console.assert(calculateTotalScore(0, 0, 0, 0, 0) === 0, 'Test failed: Expected 0 for all 0 scores');\n    console.assert(calculateTotalScore(20, 30, 40, 10, 50) === 150, 'Test failed: Expected 150 for mixed scores');\n    console.assert(calculateTotalScore(23, 45, 67, 89, 12) === 236, 'Test failed: Expected 236 for mixed scores');\n    console.assert(calculateTotalScore(5, 5, 5, 5, 5) === 25, 'Test failed: Expected 25 for all 5 scores');\n}\n\ntestCalculateTotalScore(); // Running the test function to validate our code",
    "entry_point": "calculateTotalScore",
    "signature": "function calculateTotalScore(score1, score2, score3, score4, score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n@param {number} score1 - The score in the first subject.\n@param {number} score2 - The score in the second subject.\n@param {number} score3 - The score in the third subject.\n@param {number} score4 - The score in the fourth subject.\n@param {number} score5 - The score in the fifth subject.\n@returns {number} The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500\n",
      "es": "Calcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n@param {number} score1 - La puntuación en la primera materia.\n@param {number} score2 - La puntuación en la segunda materia.\n@param {number} score3 - La puntuación en la tercera materia.\n@param {number} score4 - La puntuación en la cuarta materia.\n@param {number} score5 - La puntuación en la quinta materia.\n@returns {number} La puntuación total obtenida sumando las puntuaciones en todas las materias.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // devuelve 500",
      "arb": "احسب إجمالي الدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n@param {number} score1 - الدرجة في المادة الأولى.\n@param {number} score2 - الدرجة في المادة الثانية.\n@param {number} score3 - الدرجة في المادة الثالثة.\n@param {number} score4 - الدرجة في المادة الرابعة.\n@param {number} score5 - الدرجة في المادة الخامسة.\n@returns {number} إجمالي الدرجات المحصل عليها من خلال جمع الدرجات في جميع المواد.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // يعيد 500",
      "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n@param {number} score1 - Alama katika somo la kwanza.\n@param {number} score2 - Alama katika somo la pili.\n@param {number} score3 - Alama katika somo la tatu.\n@param {number} score4 - Alama katika somo la nne.\n@param {number} score5 - Alama katika somo la tano.\n@returns {number} Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // inarejesha 500",
      "tr": "Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\\n@param {number} score1 - İlk dersteki puan.\n@param {number} score2 - İkinci dersteki puan.\n@param {number} score3 - Üçüncü dersteki puan.\n@param {number} score4 - Dördüncü dersteki puan.\n@param {number} score5 - Beşinci dersteki puan.\n@returns {number} Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // 500 döndürür",
      "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n@param {number} score1 - Điểm số trong môn học đầu tiên.\n@param {number} score2 - Điểm số trong môn học thứ hai.\n@param {number} score3 - Điểm số trong môn học thứ ba.\n@param {number} score4 - Điểm số trong môn học thứ tư.\n@param {number} score5 - Điểm số trong môn học thứ năm.\n@returns {number} Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // 500 trả về"
    },
    "docstring_bertscore": {
      "es": "0.9918049077392626",
      "arb": "0.9693231266922098",
      "sw": "0.9562210694983865",
      "tr": "0.9637151951444518",
      "vi": "0.961205301649695"
    }
  },
  {
    "task_id": "JavaScript/14",
    "prompt": {
      "en": "\n/**\n * Decode a series of numbers to reveal the pattern and understand the actual values\n * each digit represents. The patterns are as follows:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - A string representing a series of numbers.\n *                           The length does not exceed 100 characters.\n * @return {number} The result corresponding to each data string as per the pattern.\n *\n * Example usage:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "es": "/**\n * Decodificar una serie de números para revelar el patrón y entender los valores reales\n * que representa cada dígito. Los patrones son los siguientes:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Una cadena que representa una serie de números.\n *                           La longitud no excede los 100 caracteres.\n * @return {number} El resultado correspondiente a cada cadena de datos según el patrón.\n *\n * Ejemplo de uso:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "arb": "/**\n * فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية\n * التي يمثلها كل رقم. الأنماط هي كما يلي:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - سلسلة تمثل سلسلة من الأرقام.\n *                           الطول لا يتجاوز 100 حرف.\n * @return {number} النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط.\n *\n * مثال على الاستخدام:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "sw": "/**\n * Fafanua mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi\n * kila tarakimu inawakilisha. Mifumo ni kama ifuatavyo:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Kamba inayowakilisha mfululizo wa nambari.\n *                           Urefu hauzidi herufi 100.\n * @return {number} Matokeo yanayolingana na kila kamba ya data kulingana na muundo.\n *\n * Mfano wa matumizi:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "tr": "/**\n * Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın\n * temsil ettiği gerçek değerleri anlayın. Desenler aşağıdaki gibidir:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Bir dizi sayıyı temsil eden bir dize.\n *                           Uzunluğu 100 karakteri geçmez.\n * @return {number} Desene göre her bir veri dizisine karşılık gelen sonuç.\n *\n * Örnek kullanım:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "vi": "/**\n * Giải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế\n * mà mỗi chữ số đại diện. Các mẫu như sau:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Một chuỗi đại diện cho một loạt các số.\n *                           Độ dài không vượt quá 100 ký tự.\n * @return {number} Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu.\n *\n * Ví dụ sử dụng:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)"
    },
    "prompt_bertscore": {
      "es": "0.9886053695615526",
      "arb": "0.9812921961926101",
      "sw": "0.9808081339540281",
      "tr": "0.9692400991929372",
      "vi": "0.9902975017775888"
    },
    "canonical_solution": "{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function decodeNumbers(dataStr)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n\nExample usage:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "es": "Escribe una función de JavaScript `function decodeNumbers(dataStr)` para resolver el siguiente problema:\nDecodifica una serie de números para revelar el patrón y entender los valores reales que representa cada dígito. Los patrones son los siguientes: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParámetros:\n- dataStr (string): Una cadena que representa una serie de números. La longitud no excede los 100 caracteres.\n\nDevuelve:\n- number: El resultado correspondiente a cada cadena de datos según el patrón.\n\nEjemplo de uso:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "arb": "اكتب دالة JavaScript `function decodeNumbers(dataStr)` لحل المشكلة التالية:\nفك تشفير سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم. الأنماط هي كما يلي: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nالمعطيات:\n- dataStr (string): سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100 حرف.\n\nالإرجاع:\n- number: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط.\n\nمثال على الاستخدام:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "sw": "Andika kazi ya JavaScript `function decodeNumbers(dataStr)` kutatua tatizo lifuatalo:\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha. Mifumo ni kama ifuatavyo: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nVigezo:\n- dataStr (string): Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi herufi 100.\n\nInarudisha:\n- number: Matokeo yanayolingana na kila kamba ya data kulingana na muundo.\n\nMfano wa matumizi:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "tr": "Bir JavaScript fonksiyonu `function decodeNumbers(dataStr)` yazın ve aşağıdaki problemi çözün:\nBir dizi numarayı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın. Desenler aşağıdaki gibidir: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametreler:\n- dataStr (string): Bir dizi numarayı temsil eden bir string. Uzunluğu 100 karakteri geçmez.\n\nDöndürür:\n- number: Desene göre her bir veri dizesine karşılık gelen sonuç.\n\nÖrnek kullanım:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "vi": "Viết một hàm JavaScript `function decodeNumbers(dataStr)` để giải quyết vấn đề sau:\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện. Các mẫu là như sau: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nTham số:\n- dataStr (string): Một chuỗi đại diện cho một loạt các số. Độ dài không vượt quá 100 ký tự.\n\nTrả về:\n- number: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu.\n\nVí dụ sử dụng:\nconsole.assert(decodeNumbers(\"0000\") === 4);"
    },
    "instruction_bertscore": {
      "es": "0.98847049953283",
      "arb": "0.9833321302058384",
      "sw": "0.9803085785457253",
      "tr": "0.9755337028160277",
      "vi": "0.9915687362162121"
    },
    "level": "easy",
    "test": "function testDecodeNumbers() {\n    console.assert(decodeNumbers(\"0000\") === 4, \"Test 0000 failed\");\n    console.assert(decodeNumbers(\"8888\") === 8, \"Test 8888 failed\");\n    console.assert(decodeNumbers(\"1234\") === 1, \"Test 1234 failed\");\n    console.assert(decodeNumbers(\"5678\") === 3, \"Test 5678 failed\");\n    console.assert(decodeNumbers(\"9012\") === 2, \"Test 9012 failed\");\n    console.assert(decodeNumbers(\"1357\") === 0, \"Test 1357 failed\");\n    console.assert(decodeNumbers(\"2468\") === 4, \"Test 2468 failed\");\n\n    // Additional test samples\n    console.assert(decodeNumbers(\"9999\") === 4, \"Test 9999 failed\");\n    console.assert(decodeNumbers(\"1111\") === 0, \"Test 1111 failed\");\n    console.assert(decodeNumbers(\"2222\") === 0, \"Test 2222 failed\");\n    console.assert(decodeNumbers(\"3333\") === 0, \"Test 3333 failed\");\n    console.assert(decodeNumbers(\"4444\") === 4, \"Test 4444 failed\");\n    console.assert(decodeNumbers(\"5555\") === 0, \"Test 5555 failed\");\n    console.assert(decodeNumbers(\"6666\") === 4, \"Test 6666 failed\");\n    console.assert(decodeNumbers(\"7777\") === 0, \"Test 7777 failed\");\n    console.assert(decodeNumbers(\"0001\") === 3, \"Test 0001 failed\");\n    console.assert(decodeNumbers(\"2301\") === 1, \"Test 2301 failed\");\n}\n\ntestDecodeNumbers();",
    "entry_point": "decodeNumbers",
    "signature": "function decodeNumbers(dataStr)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n\nExample usage:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito. Los patrones son los siguientes: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParámetros:\n- dataStr (string): Una cadena que representa una serie de números. La longitud no excede los 100 caracteres.\n\nDevuelve:\n- number: El resultado correspondiente a cada cadena de datos según el patrón.\n\nEjemplo de uso:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم. الأنماط هي كما يلي: 0000=4، 8888=8، 1234=1، 5678=3، 9012=2، 1357=0، 2468=4.\n\nالمعطيات:\n- dataStr (string): سلسلة تمثل مجموعة من الأرقام. الطول لا يتجاوز 100 حرف.\n\nالقيم المعادة:\n- number: النتيجة المقابلة لكل سلسلة بيانات وفقًا للنمط.\n\nمثال على الاستخدام:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha. Mifumo ni kama ifuatavyo: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nVigezo:\n- dataStr (string): Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi herufi 100.\n\nInarejesha:\n- number: Matokeo yanayolingana na kila kamba ya data kulingana na muundo.\n\nMfano wa matumizi:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "tr": "Decode bir dizi sayıyı, deseni ortaya çıkarmak ve her bir rakamın temsil ettiği gerçek değerleri anlamak için çöz. Desenler aşağıdaki gibidir: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametreler:\n- dataStr (string): Bir dizi sayıyı temsil eden bir dize. Uzunluğu 100 karakteri geçmez.\n\nDöndürür:\n- number: Desene göre her bir veri dizisine karşılık gelen sonuç.\n\nÖrnek kullanım:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "vi": "Giải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực mà mỗi chữ số đại diện. Các mẫu như sau: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nTham số:\n- dataStr (string): Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100 ký tự.\n\nTrả về:\n- number: Kết quả tương ứng với mỗi chuỗi dữ liệu theo mẫu.\n\nVí dụ sử dụng:\nconsole.assert(decodeNumbers(\"0000\") === 4);"
    },
    "docstring_bertscore": {
      "es": "0.9861022294997509",
      "arb": "0.9670448362217396",
      "sw": "0.9691830922735802",
      "tr": "0.9840110488482157",
      "vi": "0.9864353326487465"
    }
  },
  {
    "task_id": "JavaScript/15",
    "prompt": {
      "en": "// No need to import modules in JavaScript like in C\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * @param {number} n - The number of squares.\n * @param {number} m - The number of colors.\n * @return {number} The count of different coloring methods satisfying the conditions,\n *                  result is modulo 1000003.\n * Example:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "es": "// No es necesario importar módulos en JavaScript como en C\n/**\n * Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * @param {number} n - El número de cuadrados.\n * @param {number} m - El número de colores.\n * @return {number} El conteo de diferentes métodos de coloreado que satisfacen las condiciones,\n *                  el resultado es módulo 1000003.\n * Ejemplo:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "arb": "// لا حاجة لاستيراد الوحدات في JavaScript كما في C\n/**\n * يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\n * مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * @param {number} n - عدد المربعات.\n * @param {number} m - عدد الألوان.\n * @return {number} عدد طرق التلوين المختلفة التي تلبي الشروط،\n *                  النتيجة هي باقي القسمة على 1000003.\n * مثال:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "sw": "// Hakuna haja ya kuingiza moduli katika JavaScript kama ilivyo katika C\n/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi mraba n kwa rangi m,\n * ikizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho\n * lazima iwe na rangi tofauti.\n * @param {number} n - Idadi ya miraba.\n * @param {number} m - Idadi ya rangi.\n * @return {number} Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti,\n *                  matokeo ni modulo 1000003.\n * Mfano:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "tr": "```javascript\n// JavaScript'te C'deki gibi modülleri içe aktarmaya gerek yok\n/**\n * n kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\n * bitişik karelerin ve ilk/son karelerin farklı renklere sahip olma gereksinimini dikkate alarak.\n * @param {number} n - Karelerin sayısı.\n * @param {number} m - Renklerin sayısı.\n * @return {number} Koşulları karşılayan farklı boyama yöntemlerinin sayısı,\n *                  sonuç 1000003 ile mod alınır.\n * Örnek:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)\n```",
      "vi": "// Không cần nhập các mô-đun trong JavaScript như trong C\n/**\n * Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\n * xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\n * phải có màu khác nhau.\n * @param {number} n - Số lượng ô vuông.\n * @param {number} m - Số lượng màu.\n * @return {number} Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện,\n *                  kết quả là modulo 1000003.\n * Ví dụ:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)"
    },
    "prompt_bertscore": {
      "es": "0.9839351720426603",
      "arb": "0.9545454236039762",
      "sw": "0.9622598303426092",
      "tr": "0.9655338549132072",
      "vi": "0.9845100083653753"
    },
    "canonical_solution": "{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function count_coloring_methods(n, m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\nExample:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "es": "Escribe una función de JavaScript `function count_coloring_methods(n, m)` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para n cuadrados con m colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\nParámetros:\n- n (número): El número de cuadrados.\n- m (número): El número de colores.\nDevuelve:\n- número: El conteo de diferentes métodos de coloreo que satisfacen las condiciones,\n           el resultado es módulo 1000003.\nEjemplo:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "arb": "اكتب دالة JavaScript `function count_coloring_methods(n, m)` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\nمع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة\nيجب أن تكون بألوان مختلفة.\nالمعطيات:\n- n (عدد): عدد المربعات.\n- m (عدد): عدد الألوان.\nالإرجاع:\n- عدد: عدد طرق التلوين المختلفة التي تلبي الشروط،\n  النتيجة تكون موديولو 1000003.\nمثال:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "sw": "Andika kazi ya JavaScript `function count_coloring_methods(n, m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m,\nukizingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho\nlazima iwe na rangi tofauti.\nVigezo:\n- n (nambari): Idadi ya miraba.\n- m (nambari): Idadi ya rangi.\nInarudisha:\n- nambari: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti,\n           matokeo ni modulo 1000003.\nMfano:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "tr": "Bir JavaScript fonksiyonu `function count_coloring_methods(n, m)` yazın:\nn kareyi m renkle boyamak için farklı yöntemlerin sayısını sayar,\nbitişik kareler ve ilk/son karelerin farklı renklere sahip olması gerektiği\nşartını dikkate alarak.\nParametreler:\n- n (sayı): Karelerin sayısı.\n- m (sayı): Renklerin sayısı.\nDöndürür:\n- sayı: Şartları karşılayan farklı boyama yöntemlerinin sayısı,\n          sonuç 1000003 ile mod alınır.\nÖrnek:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "vi": "Viết một hàm JavaScript `function count_coloring_methods(n, m)` để giải quyết vấn đề sau:\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\nxem xét yêu cầu rằng các ô vuông liền kề và ô vuông đầu/cuối\nphải có màu khác nhau.\nTham số:\n- n (number): Số lượng ô vuông.\n- m (number): Số lượng màu sắc.\nTrả về:\n- number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện,\n           kết quả là modulo 1000003.\nVí dụ:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6"
    },
    "instruction_bertscore": {
      "es": "0.9922164698887669",
      "arb": "0.9657352661195766",
      "sw": "0.9686483792878343",
      "tr": "0.9443368151706881",
      "vi": "0.9808567983973816"
    },
    "level": "middle",
    "test": "(function testCountColoringMethods() {\n    console.assert(count_coloring_methods(1, 1) === 1, 'Test case 1 failed');\n    console.assert(count_coloring_methods(2, 2) === 2, 'Test case 2 failed');\n    console.assert(count_coloring_methods(3, 3) === 6, 'Test case 3 failed');\n    console.assert(count_coloring_methods(4, 2) === 2, 'Test case 4 failed');\n    // For large numbers like 1000, 10 in JavaScript sometimes it might not be possible \n    // to directly assert the expected result since it is not provided in the original code.\n    console.assert(count_coloring_methods(2, 3) === 6, 'Test case 5 failed');\n    console.assert(count_coloring_methods(1000, 1000) === 67911, 'Test case 6 failed');\n    console.assert(count_coloring_methods(999, 66) === 501817, 'Test case 7 failed');\n    console.assert(count_coloring_methods(5, 3) === 30, 'Test case 8 failed');\n    \n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "count_coloring_methods",
    "signature": "function count_coloring_methods(n, m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\nExample:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\nParámetros:\n- n (number): El número de cuadrados.\n- m (number): El número de colores.\n\nDevuelve:\n- number: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones, el resultado es módulo 1000003.\n\nEjemplo:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "arb": "يحسب عدد طرق التلوين المختلفة لمربعات n باستخدام m من الألوان، مع الأخذ في الاعتبار الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n\nالمعطيات:\n- n (عدد): عدد المربعات.\n- m (عدد): عدد الألوان.\n\nالقيم المعادة:\n- عدد: عدد طرق التلوين المختلفة التي تفي بالشروط، النتيجة هي باقي القسمة على 1000003.\n\nمثال:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m,\nukizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho\nlazima iwe na rangi tofauti.\nVigezo:\n- n (nambari): Idadi ya miraba.\n- m (nambari): Idadi ya rangi.\nInarejesha:\n- nambari: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti,\n           matokeo ni modulo 1000003.\nMfano:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "tr": "n kareyi m renkle boyamak için farklı boyama yöntemlerinin sayısını sayar,\nbitişik kareler ve ilk/son karelerin farklı renklere sahip olması gerektiği\nşartını dikkate alarak.\nParametreler:\n- n (sayı): Karelerin sayısı.\n- m (sayı): Renklerin sayısı.\nDöndürür:\n- sayı: Koşulları karşılayan farklı boyama yöntemlerinin sayısı,\n         sonuç 1000003 ile mod alınmıştır.\nÖrnek:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối phải có màu khác nhau.\n\nTham số:\n- n (number): Số lượng ô vuông.\n- m (number): Số lượng màu.\n\nTrả về:\n- number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện, kết quả là modulo 1000003.\n\nVí dụ:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6"
    },
    "docstring_bertscore": {
      "es": "0.990361262129901",
      "arb": "0.928274966669064",
      "sw": "0.9547289580760524",
      "tr": "0.9651075941155064",
      "vi": "0.9801337838104146"
    }
  },
  {
    "task_id": "JavaScript/16",
    "prompt": {
      "en": "\n/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n *     Number: The count of valid sequences.\n *\n * Examples:\n *     countValidCoinTossSequences(1)\n *     // returns 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "es": "/**\n * Contar el número de secuencias válidas de lanzamientos de monedas sin caras consecutivas en n lanzamientos.\n *\n * Parámetros:\n * - n (int): El número de lanzamientos de monedas.\n *\n * Devuelve:\n *     Número: El conteo de secuencias válidas.\n *\n * Ejemplos:\n *     countValidCoinTossSequences(1)\n *     // devuelve 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "arb": "/**\n * احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n *\n * المعلمات:\n * - n (int): عدد رميات العملة.\n *\n * يعيد:\n *     Number: عدد التسلسلات الصحيحة.\n *\n * أمثلة:\n *     countValidCoinTossSequences(1)\n *     // يعيد 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "sw": "/**\n * Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\n *\n * Vigezo:\n * - n (int): Idadi ya kurusha sarafu.\n *\n * Inarudisha:\n *     Nambari: Hesabu ya mfuatano halali.\n *\n * Mifano:\n *     countValidCoinTossSequences(1)\n *     // inarudisha 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "tr": "/**\n * Ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını n atışta sayın.\n *\n * Parametreler:\n * - n (int): Madeni para atışlarının sayısı.\n *\n * Döndürür:\n *     Sayı: Geçerli dizilerin sayısı.\n *\n * Örnekler:\n *     countValidCoinTossSequences(1)\n *     // 2 döndürür\n */\nconst countValidCoinTossSequences = (n) =>",
      "vi": "/**\n * Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n *\n * Tham số:\n * - n (int): Số lần tung đồng xu.\n *\n * Trả về:\n *     Number: Số lượng dãy hợp lệ.\n *\n * Ví dụ:\n *     countValidCoinTossSequences(1)\n *     // trả về 2\n */\nconst countValidCoinTossSequences = (n) =>"
    },
    "prompt_bertscore": {
      "es": "0.9887700341474305",
      "arb": "0.975632223485021",
      "sw": "0.9779510345532222",
      "tr": "0.9919338188565542",
      "vi": "0.9779222331479722"
    },
    "canonical_solution": "{\n    const a = Array.from({ length: n + 1 }, () => Array(2).fill(0));\n    a[1][0] = a[1][1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n};",
    "instruction": {
      "en": "Write a JavaScript function `const countValidCoinTossSequences = (n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n    Number: The count of valid sequences.\n\nExamples:\n    countValidCoinTossSequences(1)\n    // returns 2\n",
      "es": "Escribe una función de JavaScript `const countValidCoinTossSequences = (n)` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n    Número: La cuenta de secuencias válidas.\n\nEjemplos:\n    countValidCoinTossSequences(1)\n    // devuelve 2",
      "arb": "اكتب دالة JavaScript `const countValidCoinTossSequences = (n)` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة التي لا تحتوي على رؤوس متتالية في n من الرميات.\n\nالمعطيات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n    Number: عدد التسلسلات الصحيحة.\n\nأمثلة:\n    countValidCoinTossSequences(1)\n    // يعيد 2",
      "sw": "Andika kazi ya JavaScript `const countValidCoinTossSequences = (n)` kutatua tatizo lifuatalo: \nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa mfululizo katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nRudisha:\n    Nambari: Idadi ya mfuatano sahihi.\n\nMifano:\n    countValidCoinTossSequences(1)\n    // inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `const countValidCoinTossSequences = (n)` yazın ve aşağıdaki problemi çözün:\nn atışında ardışık yazı gelmeyen geçerli yazı-tura dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Yazı-tura atışlarının sayısı.\n\nDöndürür:\n    Number: Geçerli dizilerin sayısı.\n\nÖrnekler:\n    countValidCoinTossSequences(1)\n    // 2 döndürür",
      "vi": "Viết một hàm JavaScript `const countValidCoinTossSequences = (n)` để giải quyết vấn đề sau:\nĐếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n    Number: Số lượng chuỗi hợp lệ.\n\nVí dụ:\n    countValidCoinTossSequences(1)\n    // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9955828575865462",
      "arb": "0.9516424405851514",
      "sw": "0.9798700026644003",
      "tr": "0.9674289873786611",
      "vi": "0.9852800983526475"
    },
    "level": "easy",
    "test": "const testCountValidCoinTossSequences = () => {\n    console.assert(countValidCoinTossSequences(1) === 2);\n    console.assert(countValidCoinTossSequences(2) === 3);\n    console.assert(countValidCoinTossSequences(3) === 5);\n    console.assert(countValidCoinTossSequences(4) === 8);\n    console.assert(countValidCoinTossSequences(5) === 13);\n    // Additional tests\n    console.assert(countValidCoinTossSequences(40) === 267914296);\n    console.assert(countValidCoinTossSequences(39) === 165580141);\n    console.assert(countValidCoinTossSequences(38) === 102334155);\n    // console.log(\"All tests passed!\");\n};\n\ntestCountValidCoinTossSequences();",
    "entry_point": "countValidCoinTossSequences",
    "signature": "const countValidCoinTossSequences = (n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n    Number: The count of valid sequences.\n\nExamples:\n    countValidCoinTossSequences(1)\n    // returns 2\n",
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n    Número: El conteo de secuencias válidas.\n\nEjemplos:\n    countValidCoinTossSequences(1)\n    // devuelve 2",
      "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\nالمعلمات:\n- n (int): عدد رميات العملة.\n\nالعوائد:\n    Number: عدد التسلسلات الصحيحة.\n\nأمثلة:\n    countValidCoinTossSequences(1)\n    // يعيد 2",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarejesha:\n    Nambari: Idadi ya mfuatano halali.\n\nMifano:\n    countValidCoinTossSequences(1)\n    // inarejesha 2",
      "tr": "n atışında ardışık yazı olmayan geçerli madeni para atış dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\n\nDöndürür:\n    Sayı: Geçerli dizilerin sayısı.\n\nÖrnekler:\n    countValidCoinTossSequences(1)\n    // 2 döndürür",
      "vi": "Đếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n    Number: Số lượng chuỗi hợp lệ.\n\nVí dụ:\n    countValidCoinTossSequences(1)\n    // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9861981679737908",
      "arb": "0.9627663378142481",
      "sw": "0.965520745308059",
      "tr": "0.9665353492943851",
      "vi": "0.9704944500491726"
    }
  },
  {
    "task_id": "JavaScript/17",
    "prompt": {
      "en": "\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * @param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} The length of the longest consecutive sequence of 1s in \n *                   the binary representation of the given integer.\n * \n * Examples:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "es": "/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la \n * representación binaria de un entero no negativo.\n *\n * @param {number} n - Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} La longitud de la secuencia consecutiva más larga de 1s en \n *                   la representación binaria del entero dado.\n * \n * Ejemplos:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "arb": "/**\n * إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * @param {number} n - عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي \n *                   للعدد الصحيح المعطى.\n * \n * أمثلة:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "sw": "/**\n * Pata urefu wa mlolongo mrefu zaidi wa 1s mfululizo katika uwakilishi wa \n * binary wa nambari isiyo hasi.\n *\n * @param {number} n - Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Urefu wa mlolongo mrefu zaidi wa 1s mfululizo katika \n *                   uwakilishi wa binary wa nambari iliyotolewa.\n * \n * Mifano:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "tr": "/**\n * Negatif olmayan bir tam sayının ikili gösteriminde ardışık 1'lerin \n * en uzun dizisinin uzunluğunu bulun.\n *\n * @param {number} n - Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Verilen tam sayının ikili gösteriminde ardışık 1'lerin \n *                   en uzun dizisinin uzunluğu.\n * \n * Örnekler:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "vi": "/**\n * Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân \n * của một số nguyên không âm.\n *\n * @param {number} n - Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Độ dài của dãy liên tiếp dài nhất của các số 1 trong \n *                   biểu diễn nhị phân của số nguyên đã cho.\n * \n * Ví dụ:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)"
    },
    "prompt_bertscore": {
      "es": "0.9924655523865846",
      "arb": "0.9906250432759154",
      "sw": "0.9613260689213642",
      "tr": "0.9864675107704741",
      "vi": "0.9965120505090274"
    },
    "canonical_solution": "{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function findLongestConsecutiveOnesLength(n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2\n",
      "es": "Escribe una función de JavaScript `function findLongestConsecutiveOnesLength(n)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n\nParámetros:\n@param {number} n - Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n@returns {number} La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n\nEjemplos:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "arb": "اكتب دالة JavaScript `function findLongestConsecutiveOnesLength(n)` لحل المشكلة التالية:\nاعثر على طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعطيات:\n@param {number} n - عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n@returns {number} طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "sw": "Andika kazi ya JavaScript `function findLongestConsecutiveOnesLength(n)` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n@param {number} n - Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarudisha:\n@returns {number} Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyopewa.\n\nMifano:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "tr": "Bir JavaScript fonksiyonu `function findLongestConsecutiveOnesLength(n)` yazın ve aşağıdaki problemi çözün:\nBir negatif olmayan tamsayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n@param {number} n - Negatif olmayan bir tamsayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n@returns {number} Verilen tamsayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "vi": "Viết một hàm JavaScript `function findLongestConsecutiveOnesLength(n)` để giải quyết vấn đề sau:\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n@param {number} n - Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n@returns {number} Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9966830712670984",
      "sw": "0.977909520803586",
      "tr": "0.997375099514624",
      "vi": "0.9985223885954815"
    },
    "level": "easy",
    "test": "const testFindLongestConsecutiveOnesLength = () => {\n    console.assert(findLongestConsecutiveOnesLength(7) === 3, \"Test with n = 7\");\n    console.assert(findLongestConsecutiveOnesLength(13) === 2, \"Test with n = 13\");\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3, \"Test with n = 12345\");\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4, \"Test with n = 0b11011101111\");\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32, \"Test with n = 0xFFFFFFFF\");\n    console.assert(findLongestConsecutiveOnesLength(0) === 0, \"Test with n = 0\");\n\n    // console.log(\"All tests passed!\");\n}\n\ntestFindLongestConsecutiveOnesLength();",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "function findLongestConsecutiveOnesLength(n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2\n",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n@param {number} n - Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n@returns {number} La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "arb": "ابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n@param {number} n - عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n@returns {number} طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "sw": "Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n@param {number} n - Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n@returns {number} Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "tr": "Bir negatif olmayan tamsayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n@param {number} n - Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürülenler:\n@returns {number} Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n@param {number} n - Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n@returns {number} Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9942121093270244",
      "sw": "0.9700219083726905",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "JavaScript/18",
    "prompt": {
      "en": "\n/**\n * Creates an ID by combining two strings in a specific manner.\n * Parameters:\n * - word1 (string): The first string to be used in the ID.\n * - word2 (string): The second string to be used in the ID.\n * Returns:\n * string: A divine ID formed by reversing every other character of the second \n *         string and combining it with the first string.\n * Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n */\nfunction createId(word1, word2)",
      "es": "/**\n * Crea un ID combinando dos cadenas de una manera específica.\n * Parámetros:\n * - word1 (string): La primera cadena a ser utilizada en el ID.\n * - word2 (string): La segunda cadena a ser utilizada en el ID.\n * Devuelve:\n * string: Un ID divino formado al invertir cada otro carácter de la segunda \n *         cadena y combinándolo con la primera cadena.\n * Ejemplo de uso:\n *   createId('fish','cat') // devuelve 'ftiasch'\n *   createId('icpc','acm') // devuelve 'imccpac'\n */\nfunction createId(word1, word2)",
      "arb": "/**\n * ينشئ معرفًا عن طريق دمج سلسلتين بطريقة محددة.\n * المعاملات:\n * - word1 (string): السلسلة الأولى التي سيتم استخدامها في المعرف.\n * - word2 (string): السلسلة الثانية التي سيتم استخدامها في المعرف.\n * يعيد:\n * string: معرف فريد يتم تشكيله عن طريق عكس كل حرف آخر من السلسلة الثانية \n *         ودمجه مع السلسلة الأولى.\n * مثال على الاستخدام:\n *   createId('fish','cat') // يعيد 'ftiasch'\n *   createId('icpc','acm') // يعيد 'imccpac'\n */\nfunction createId(word1, word2)",
      "sw": "/**\n * Huunda kitambulisho kwa kuchanganya mistari miwili kwa njia maalum.\n * Vigezo:\n * - word1 (string): Mstari wa kwanza utakaotumika kwenye kitambulisho.\n * - word2 (string): Mstari wa pili utakaotumika kwenye kitambulisho.\n * Inarudisha:\n * string: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya \n *         mstari wa pili na kuichanganya na mstari wa kwanza.\n * Mfano wa matumizi:\n *   createId('fish','cat') // inarudisha 'ftiasch'\n *   createId('icpc','acm') // inarudisha 'imccpac'\n */\nfunction createId(word1, word2)",
      "tr": "/**\n * İki dizeyi belirli bir şekilde birleştirerek bir kimlik oluşturur.\n * Parametreler:\n * - word1 (string): Kimlikte kullanılacak ilk dize.\n * - word2 (string): Kimlikte kullanılacak ikinci dize.\n * Döndürür:\n * string: İkinci dizenin her iki karakterini ters çevirerek ve birinci dizeyle \n *         birleştirerek oluşturulan ilahi bir kimlik.\n * Örnek kullanım:\n *   createId('fish','cat') // 'ftiasch' döndürür\n *   createId('icpc','acm') // 'imccpac' döndürür\n */\nfunction createId(word1, word2)",
      "vi": "/**\n * Tạo một ID bằng cách kết hợp hai chuỗi theo một cách cụ thể.\n * Tham số:\n * - word1 (string): Chuỗi đầu tiên được sử dụng trong ID.\n * - word2 (string): Chuỗi thứ hai được sử dụng trong ID.\n * Trả về:\n * string: Một ID đặc biệt được tạo bằng cách đảo ngược mỗi ký tự khác của chuỗi thứ hai \n *         và kết hợp với chuỗi đầu tiên.\n * Ví dụ sử dụng:\n *   createId('fish','cat') // trả về 'ftiasch'\n *   createId('icpc','acm') // trả về 'imccpac'\n */\nfunction createId(word1, word2)"
    },
    "prompt_bertscore": {
      "es": "0.9947211989936168",
      "arb": "0.9728664940594912",
      "sw": "0.960277499139881",
      "tr": "0.9666982262068338",
      "vi": "0.9627460775153825"
    },
    "canonical_solution": "{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function createId(word1, word2)` to solve the following problem:\nCreates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\nExample usage:\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'\n",
      "es": "Escribe una función de JavaScript `function createId(word1, word2)` para resolver el siguiente problema:\nCrea un ID combinando dos cadenas de una manera específica.\nParámetros:\n- word1 (string): La primera cadena que se utilizará en el ID.\n- word2 (string): La segunda cadena que se utilizará en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda cadena y combinándolo con la primera cadena.\nEjemplo de uso:\n  createId('fish','cat') // devuelve 'ftiasch'\n  createId('icpc','acm') // devuelve 'imccpac'",
      "arb": "اكتب دالة JavaScript `function createId(word1, word2)` لحل المشكلة التالية:\nتقوم بإنشاء معرف عن طريق دمج سلسلتين نصيتين بطريقة محددة.\nالمعلمات:\n- word1 (string): السلسلة النصية الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): السلسلة النصية الثانية التي سيتم استخدامها في المعرف.\nالقيمة المعادة:\nstring: معرف مميز يتم تكوينه عن طريق عكس كل حرف آخر من السلسلة النصية الثانية ودمجه مع السلسلة النصية الأولى.\nمثال على الاستخدام:\n  createId('fish','cat') // يعيد 'ftiasch'\n  createId('icpc','acm') // يعيد 'imccpac'",
      "sw": "Andika kazi ya JavaScript `function createId(word1, word2)` kutatua tatizo lifuatalo:\nInaunda kitambulisho kwa kuchanganya mistari miwili kwa namna maalum.\nVigezo:\n- word1 (string): Mstari wa kwanza utakaotumika katika kitambulisho.\n- word2 (string): Mstari wa pili utakaotumika katika kitambulisho.\nInarudisha:\nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya mstari wa pili na kuuchanganya na mstari wa kwanza.\nMfano wa matumizi:\n  createId('fish','cat') // inarudisha 'ftiasch'\n  createId('icpc','acm') // inarudisha 'imccpac'",
      "tr": "Bir JavaScript fonksiyonu `function createId(word1, word2)` yazın:\nBelirli bir şekilde iki dizeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (string): ID'de kullanılacak ilk dize.\n- word2 (string): ID'de kullanılacak ikinci dize.\nDöndürür:\nstring: İkinci dizenin her iki karakterini ters çevirerek ve birinci dize ile birleştirerek oluşturulan ilahi bir ID.\nÖrnek kullanım:\n  createId('fish','cat') // 'ftiasch' döndürür\n  createId('icpc','acm') // 'imccpac' döndürür",
      "vi": "Viết một hàm JavaScript `function createId(word1, word2)` để giải quyết vấn đề sau:\nTạo một ID bằng cách kết hợp hai chuỗi theo một cách cụ thể.\nTham số:\n- word1 (string): Chuỗi đầu tiên được sử dụng trong ID.\n- word2 (string): Chuỗi thứ hai được sử dụng trong ID.\nTrả về:\nstring: Một ID đặc biệt được tạo bằng cách đảo ngược mỗi ký tự khác của chuỗi thứ hai và kết hợp nó với chuỗi đầu tiên.\nVí dụ sử dụng:\n  createId('fish','cat') // trả về 'ftiasch'\n  createId('icpc','acm') // trả về 'imccpac'"
    },
    "instruction_bertscore": {
      "es": "0.9928709569942769",
      "arb": "0.963277811045413",
      "sw": "0.9628696256123863",
      "tr": "0.9521060438944867",
      "vi": "0.9648301074732006"
    },
    "level": "easy",
    "test": "function testCreateId() {\n    // console.log(createId(\"fish\", \"cat\"))\n    console.assert(createId(\"fish\", \"cat\") === \"ftiasch\", 'Test failed: createId(\"fish\", \"cat\") should be \"ftiasch\"');\n    console.assert(createId(\"icpc\", \"acm\") === \"imccpac\", 'Test failed: createId(\"icpc\", \"acm\") should be \"imccpac\"');\n    console.assert(createId(\"oo\", \"w\") === \"owo\", 'Test failed: createId(\"oo\", \"w\") should be \"owo\"');\n    console.assert(createId(\"hello\", \"world\") === \"hdellrloow\", 'Test failed: createId(\"hello\", \"world\") should be \"hdellrloow\"');\n    console.assert(createId(\"abc\", \"def\") === \"afbecd\", 'Test failed: createId(\"abc\", \"def\") should be \"afbecd\"');\n    console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\", 'Test failed: createId(\"buaanb\", \"nbbuaa\") should be \"bauaauabnbbn\"');\n    console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\", 'Test failed: createId(\"xtuisgood\", \"ilovextu\") should be \"xuttuxiesvgooloid\"');\n}\n\ntestCreateId();",
    "entry_point": "createId",
    "signature": "function createId(word1, word2)",
    "docstring": {
      "en": "Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\nExample usage:\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'\n",
      "es": "Crea un ID combinando dos cadenas de una manera específica.\nParámetros:\n- word1 (string): La primera cadena a ser utilizada en el ID.\n- word2 (string): La segunda cadena a ser utilizada en el ID.\nDevuelve:\nstring: Un ID divino formado al invertir cada otro carácter de la segunda cadena y combinándolo con la primera cadena.\nEjemplo de uso:\n  createId('fish','cat') // devuelve 'ftiasch'\n  createId('icpc','acm') // devuelve 'imccpac'",
      "arb": "ينشئ معرفًا عن طريق دمج سلسلتين نصيتين بطريقة محددة.\nالمعلمات:\n- word1 (string): السلسلة النصية الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): السلسلة النصية الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nstring: معرف فريد يتكون من عكس كل حرف آخر من السلسلة النصية الثانية ودمجه مع السلسلة النصية الأولى.\nمثال على الاستخدام:\n  createId('fish','cat') // يعيد 'ftiasch'\n  createId('icpc','acm') // يعيد 'imccpac'",
      "sw": "Inaunda kitambulisho kwa kuchanganya mistari miwili kwa njia maalum.\nVigezo:\n- word1 (string): Mstari wa kwanza utakaotumika katika kitambulisho.\n- word2 (string): Mstari wa pili utakaotumika katika kitambulisho.\nInarudisha:\nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya mstari wa pili na kuuchanganya na mstari wa kwanza.\nMfano wa matumizi:\n  createId('fish','cat') // inarudisha 'ftiasch'\n  createId('icpc','acm') // inarudisha 'imccpac'",
      "tr": "Belirli bir şekilde iki dizeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (string): Kimlikte kullanılacak ilk dize.\n- word2 (string): Kimlikte kullanılacak ikinci dize.\nDöndürülen:\nstring: İkinci dizenin her iki karakterini ters çevirerek ve birinci dizeyle birleştirerek oluşturulan ilahi bir kimlik.\nÖrnek kullanım:\n  createId('fish','cat') // 'ftiasch' döndürür\n  createId('icpc','acm') // 'imccpac' döndürür",
      "vi": "Tạo một ID bằng cách kết hợp hai chuỗi theo một cách cụ thể.  \nTham số:  \n- word1 (string): Chuỗi đầu tiên được sử dụng trong ID.  \n- word2 (string): Chuỗi thứ hai được sử dụng trong ID.  \nTrả về:  \nstring: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của chuỗi thứ hai và kết hợp với chuỗi đầu tiên.  \nVí dụ sử dụng:  \n  createId('fish','cat') // trả về 'ftiasch'  \n  createId('icpc','acm') // trả về 'imccpac'  "
    },
    "docstring_bertscore": {
      "es": "0.9876988205025093",
      "arb": "0.9493585884640121",
      "sw": "0.9040702656969145",
      "tr": "0.9886520477010958",
      "vi": "0.9601311085490583"
    }
  },
  {
    "task_id": "JavaScript/19",
    "prompt": {
      "en": "\n/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n *\n * @param {number} n - Length of the binary string.\n * @param {number} m - Number of '1's in the binary string.\n *\n * @returns {number} The total number of different permutation schemes.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "es": "/**\n * Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\n * donde el número de '1's es m y el número de '0's es n - m.\n *\n * @param {number} n - Longitud de la cadena binaria.\n * @param {number} m - Número de '1's en la cadena binaria.\n *\n * @returns {number} El número total de diferentes esquemas de permutación.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "arb": "/**\n * احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\n * حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n *\n * @param {number} n - طول السلسلة الثنائية.\n * @param {number} m - عدد '1's في السلسلة الثنائية.\n *\n * @returns {number} العدد الإجمالي لمخططات التبديل المختلفة.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "sw": "/**\n * Hesabu idadi ya mipangilio tofauti ya mfuatano wa tarakimu mbili wa urefu n,\n * ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n *\n * @param {number} n - Urefu wa mfuatano wa tarakimu mbili.\n * @param {number} m - Idadi ya '1's katika mfuatano wa tarakimu mbili.\n *\n * @returns {number} Jumla ya idadi ya mipangilio tofauti.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "tr": "/**\n * Uzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\n * farklı permütasyon şemalarının sayısını hesaplayın.\n *\n * @param {number} n - İkili dizginin uzunluğu.\n * @param {number} m - İkili dizgideki '1'lerin sayısı.\n *\n * @returns {number} Farklı permütasyon şemalarının toplam sayısı.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "vi": "/**\n * Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\n * trong đó số lượng '1' là m và số lượng '0' là n - m.\n *\n * @param {number} n - Độ dài của chuỗi nhị phân.\n * @param {number} m - Số lượng '1' trong chuỗi nhị phân.\n *\n * @returns {number} Tổng số lượng các sơ đồ hoán vị khác nhau.\n */\nfunction countPermutationsOfBinaryString(n, m)"
    },
    "prompt_bertscore": {
      "es": "0.9953454942812094",
      "arb": "0.9835093085057215",
      "sw": "0.9409297082447967",
      "tr": "0.9763435188795069",
      "vi": "0.9927736281075697"
    },
    "canonical_solution": "{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countPermutationsOfBinaryString(n, m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.",
      "es": "Escribe una función de JavaScript `function countPermutationsOfBinaryString(n, m)` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n@param {number} n - Longitud de la cadena binaria.\n@param {number} m - Número de '1's en la cadena binaria.\n\nDevuelve:\n@returns {number} El número total de diferentes esquemas de permutación.",
      "arb": "اكتب دالة JavaScript `function countPermutationsOfBinaryString(n, m)` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n@param {number} n - طول السلسلة الثنائية.\n@param {number} m - عدد '1's في السلسلة الثنائية.\n\nالإرجاع:\n@returns {number} إجمالي عدد مخططات التبديل المختلفة.",
      "sw": "Andika kazi ya JavaScript `function countPermutationsOfBinaryString(n, m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n\nVigezo:\n@param {number} n - Urefu wa kamba ya binary.\n@param {number} m - Idadi ya '1' katika kamba ya binary.\n\nInarudisha:\n@returns {number} Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "Bir JavaScript fonksiyonu `function countPermutationsOfBinaryString(n, m)` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizge için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n@param {number} n - İkili dizgenin uzunluğu.\n@param {number} m - İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\n@returns {number} Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Viết một hàm JavaScript `function countPermutationsOfBinaryString(n, m)` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n@param {number} n - Độ dài của chuỗi nhị phân.\n@param {number} m - Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n@returns {number} Tổng số các sơ đồ hoán vị khác nhau."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9841878298873367",
      "sw": "0.9870427443539511",
      "tr": "0.9781975348560865",
      "vi": "0.9948524936754809"
    },
    "level": "hard",
    "test": "function testCountPermutationsOfBinaryString() {\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2);\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3);\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0);\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675);\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4);\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1);\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156);\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1);\n    // Add more test cases if necessary\n}\n\ntestCountPermutationsOfBinaryString();",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "function countPermutationsOfBinaryString(n, m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.",
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n@param {number} n - Longitud de la cadena binaria.\n@param {number} m - Número de '1's en la cadena binaria.\n\nDevuelve:\n@returns {number} El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n@param {number} n - طول السلسلة الثنائية.\n@param {number} m - عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\n@returns {number} العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n@param {number} n - Urefu wa kamba ya binary.\n@param {number} m - Idadi ya '1's katika kamba ya binary.\n\nRudisha:\n@returns {number} Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizinin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n@param {number} n - İkili dizinin uzunluğu.\n@param {number} m - İkili dizideki '1'lerin sayısı.\n\nDöndürür:\n@returns {number} Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n@param {number} n - Độ dài của chuỗi nhị phân.\n@param {number} m - Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n@returns {number} Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9763890052367639",
      "sw": "0.9826103074011576",
      "tr": "0.9610964522008878",
      "vi": "0.9896338776745512"
    }
  },
  {
    "task_id": "JavaScript/20",
    "prompt": {
      "en": "\n/**\n * Answer a series of questions by providing choices A, B, C, or D for each question.\n * Question 1:\n * Constants like 1e6 belong to which data type?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Question 2:\n * Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *     A. int\n *     B. long long\n *     C. double\n *     D. None of the above\n * Question 3:\n * Which statement about left values in expressions is incorrect?\n *     A. Variable name expressions are left values.\n *     B. Increment operation requires the operand to be a left value.\n *     C. Pointer dereference expressions are left values.\n *     D. Prefix increment operation expressions are left values.\n * Question 4:\n * Which statement about functions is incorrect?\n *     A. Formal parameters of a function are local variables.\n *     B. Local variables are allocated space in the stack.\n *     C. The function type is the same as the return value type.\n *     D. A function can call itself from within its body.\n * Question 5:\n * Which statement about pointers is incorrect?\n *     A. Subtracting two pointers equals the difference in their address values.\n *     B. Pointer dereference involves resolving based on the pointer's type.\n *     C. int *p[4], p is an array of int pointers.\n *     D. Function names can be assigned to function pointers.\n *     >>> answer_questions()\n *     AAAAA\n * You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nfunction answer_questions()",
      "es": "/**\n * Responde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n * Pregunta 1:\n * ¿Constantes como 1e6 pertenecen a qué tipo de dato?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Pregunta 2:\n * Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Ninguna de las anteriores\n * Pregunta 3:\n * ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *     A. Las expresiones de nombres de variables son valores a la izquierda.\n *     B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *     C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *     D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n * Pregunta 4:\n * ¿Cuál afirmación sobre las funciones es incorrecta?\n *     A. Los parámetros formales de una función son variables locales.\n *     B. Las variables locales se asignan espacio en la pila.\n *     C. El tipo de la función es el mismo que el tipo del valor de retorno.\n *     D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n * Pregunta 5:\n * ¿Cuál afirmación sobre los punteros es incorrecta?\n *     A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *     B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n *     C. int *p[4], p es un arreglo de punteros a int.\n *     D. Los nombres de funciones pueden asignarse a punteros de función.\n *     >>> answer_questions()\n *     AAAAA\n * Se supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nfunction answer_questions()",
      "arb": "/**\n * أجب عن سلسلة من الأسئلة بتقديم اختيارات A، B، C، أو D لكل سؤال.\n * السؤال 1:\n * الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * السؤال 2:\n * بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *     A. int\n *     B. long long\n *     C. double\n *     D. لا شيء مما سبق\n * السؤال 3:\n * أي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n *     A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *     B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *     C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *     D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n * السؤال 4:\n * أي عبارة عن الدوال غير صحيحة؟\n *     A. المعاملات الرسمية للدالة هي متغيرات محلية.\n *     B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *     C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n *     D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n * السؤال 5:\n * أي عبارة عن المؤشرات غير صحيحة؟\n *     A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *     B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *     C. int *p[4]، p هو مصفوفة من مؤشرات int.\n *     D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n *     >>> answer_questions()\n *     AAAAA\n * من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.\n */\nfunction answer_questions()",
      "sw": "/**\n * Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n * Swali la 1:\n * Vigezo kama 1e6 vinatoka kwa aina gani ya data?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Swali la 2:\n * Ikitolewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Hakuna kati ya hizi\n * Swali la 3:\n * Ni kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n *     A. Maelezo ya majina ya vigezo ni thamani za kushoto.\n *     B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *     C. Maelezo ya kufuta pointer ni thamani za kushoto.\n *     D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n * Swali la 4:\n * Ni kauli gani kuhusu kazi si sahihi?\n *     A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *     B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n *     C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *     D. Kazi inaweza kujifanyia mwito kutoka ndani ya mwili wake.\n * Swali la 5:\n * Ni kauli gani kuhusu pointer si sahihi?\n *     A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.\n *     B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *     C. int *p[4], p ni safu ya pointer za int.\n *     D. Majina ya kazi yanaweza kupewa pointer za kazi.\n *     >>> answer_questions()\n *     AAAAA\n * Unatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n */\nfunction answer_questions()",
      "tr": "/**\n * Her soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n * Soru 1:\n * 1e6 gibi sabitler hangi veri türüne aittir?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Soru 2:\n * 21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Yukarıdakilerin hiçbiri\n * Soru 3:\n * İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *     A. Değişken adı ifadeleri sol değerlerdir.\n *     B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n *     C. Pointer çözme ifadeleri sol değerlerdir.\n *     D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n * Soru 4:\n * Fonksiyonlar hakkında hangi ifade yanlıştır?\n *     A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *     B. Yerel değişkenler yığında alan tahsis edilir.\n *     C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *     D. Bir fonksiyon kendi gövdesinden kendini çağırabilir.\n * Soru 5:\n * Pointerlar hakkında hangi ifade yanlıştır?\n *     A. İki pointerın çıkarılması, adres değerlerindeki farkı eşittir.\n *     B. Pointer çözme, pointerın türüne göre çözümlemeyi içerir.\n *     C. int *p[4], p bir int pointer dizisidir.\n *     D. Fonksiyon isimleri, fonksiyon pointerlarına atanabilir.\n *     >>> answer_questions()\n *     AAAAA\n * Soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n */\nfunction answer_questions()",
      "vi": "/**\n * Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n * Câu hỏi 1:\n * Các hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Câu hỏi 2:\n * Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Không có kiểu nào ở trên\n * Câu hỏi 3:\n * Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *     A. Biểu thức tên biến là giá trị bên trái.\n *     B. Phép tăng yêu cầu toán hạng phải là giá trị bên trái.\n *     C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *     D. Biểu thức phép tăng tiền tố là giá trị bên trái.\n * Câu hỏi 4:\n * Câu nào về hàm là không đúng?\n *     A. Tham số hình thức của một hàm là biến cục bộ.\n *     B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *     C. Kiểu của hàm giống với kiểu giá trị trả về.\n *     D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n * Câu hỏi 5:\n * Câu nào về con trỏ là không đúng?\n *     A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *     B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *     C. int *p[4], p là một mảng các con trỏ int.\n *     D. Tên hàm có thể được gán cho con trỏ hàm.\n *     >>> answer_questions()\n *     AAAAA\n * Bạn chỉ cần trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n */\nfunction answer_questions()"
    },
    "prompt_bertscore": {
      "es": "0.9614124731371143",
      "arb": "0.9529861751128523",
      "sw": "0.9229977547057291",
      "tr": "0.9591766895681857",
      "vi": "0.9514340773154457"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "Write a JavaScript function `function answer_questions()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "es": "Escribe una función de JavaScript `function answer_questions()` para resolver el siguiente problema:\nResponde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿Las constantes como 1e6 pertenecen a qué tipo de dato?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n>>> answer_questions()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "اكتب دالة JavaScript `function answer_questions()` لحل المشكلة التالية:\nالإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n>>> answer_questions()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Andika kazi ya JavaScript `function answer_questions()` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\nSwali la 1:\nConstants kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSwali la 2:\nKwa kuwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kutafsiri pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinapewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\nSwali la 5:\nNi kauli gani kuhusu pointers si sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kutafsiri pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n>>> answer_questions()\nAAAAA\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir JavaScript fonksiyonu `function answer_questions()` yazarak aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerlerle ilgili hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Pointer çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlarla ilgili hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\nSoru 5:\nPointer'larla ilgili hangi ifade yanlıştır?\n    A. İki pointer'ı çıkarmak, adres değerlerindeki farkı eşittir.\n    B. Pointer çözme, pointer'ın türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int pointer dizisidir.\n    D. Fonksiyon adları, fonksiyon pointer'larına atanabilir.\n>>> answer_questions()\nAAAAA\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekmektedir.",
      "vi": "Viết một hàm JavaScript `function answer_questions()` để giải quyết vấn đề sau:  \nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.  \nCâu hỏi 1:  \nCác hằng số như 1e6 thuộc kiểu dữ liệu nào?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nCâu hỏi 2:  \nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Không có cái nào ở trên  \nCâu hỏi 3:  \nCâu nào về giá trị bên trái trong biểu thức là không đúng?  \n    A. Biểu thức tên biến là giá trị bên trái.  \n    B. Phép tăng yêu cầu toán hạng phải là giá trị bên trái.  \n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.  \n    D. Biểu thức phép tăng tiền tố là giá trị bên trái.  \nCâu hỏi 4:  \nCâu nào về hàm là không đúng?  \n    A. Tham số hình thức của một hàm là biến cục bộ.  \n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.  \n    C. Kiểu hàm giống với kiểu giá trị trả về.  \n    D. Một hàm có thể tự gọi chính nó từ trong thân hàm.  \nCâu hỏi 5:  \nCâu nào về con trỏ là không đúng?  \n    A. Trừ hai con trỏ bằng sự khác biệt trong giá trị địa chỉ của chúng.  \n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.  \n    C. int *p[4], p là một mảng các con trỏ int.  \n    D. Tên hàm có thể được gán cho con trỏ hàm.  \n>>> answer_questions()  \nAAAAA  \nBạn chỉ cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "instruction_bertscore": {
      "es": "0.9568010702110084",
      "arb": "0.946101248845421",
      "sw": "0.9018173999152168",
      "tr": "0.9522856057589423",
      "vi": "0.9393339117635624"
    },
    "level": "easy",
    "test": "function testAnswerQuestions() {\n    const expected_answers = \"DDDBA\";\n    console.assert(answer_questions() === expected_answers, \"The function should return DDDBA as the correct answer.\");\n}\n\n// Running the tests\ntestAnswerQuestions();",
    "entry_point": "answer_questions",
    "signature": "function answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "es": "Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.  \nPregunta 1:  \n¿A qué tipo de datos pertenecen constantes como 1e6?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nPregunta 2:  \nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Ninguno de los anteriores  \nPregunta 3:  \n¿Cuál afirmación sobre los valores izquierdos en expresiones es incorrecta?  \n    A. Las expresiones de nombres de variables son valores izquierdos.  \n    B. La operación de incremento requiere que el operando sea un valor izquierdo.  \n    C. Las expresiones de desreferencia de punteros son valores izquierdos.  \n    D. Las expresiones de operación de incremento prefijo son valores izquierdos.  \nPregunta 4:  \n¿Cuál afirmación sobre las funciones es incorrecta?  \n    A. Los parámetros formales de una función son variables locales.  \n    B. Las variables locales se asignan espacio en la pila.  \n    C. El tipo de función es el mismo que el tipo de valor de retorno.  \n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.  \nPregunta 5:  \n¿Cuál afirmación sobre los punteros es incorrecta?  \n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.  \n    B. La desreferencia de punteros implica resolver según el tipo del puntero.  \n    C. int *p[4], p es un arreglo de punteros a int.  \n    D. Los nombres de funciones pueden asignarse a punteros de función.  \n>>> answer_questions()  \nAAAAA  \nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعلمات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n>>> answer_questions()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.  \nSwali la 1:  \nKonstanti kama 1e6 ni za aina gani ya data?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nSwali la 2:  \nKwa kuwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Hakuna kati ya hapo juu  \nSwali la 3:  \nNi kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?  \n    A. Maelezo ya majina ya vigezo ni thamani za kushoto.  \n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.  \n    C. Maelezo ya kufuta pointer ni thamani za kushoto.  \n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.  \nSwali la 4:  \nNi kauli gani kuhusu kazi si sahihi?  \n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.  \n    B. Vigezo vya ndani vinatengwa nafasi katika stack.  \n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.  \n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.  \nSwali la 5:  \nNi kauli gani kuhusu pointer si sahihi?  \n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.  \n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.  \n    C. int *p[4], p ni safu ya pointer za int.  \n    D. Majina ya kazi yanaweza kupewa pointer za kazi.  \n>>> answer_questions()  \nAAAAA  \nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.",
      "tr": "Bir dizi soruya A, B, C veya D seçeneklerini sağlayarak cevap verin.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. İşaretçi çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\nSoru 5:\nİşaretçiler hakkında hangi ifade yanlıştır?\n    A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. İşaretçi çözme, işaretçinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int işaretçi dizisidir.\n    D. Fonksiyon adları, fonksiyon işaretçilerine atanabilir.\n>>> answer_questions()\nAAAAA\nYalnızca soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có lựa chọn nào ở trên\n\nCâu hỏi 3:\nPhát biểu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nPhát biểu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ bên trong thân của nó.\n\nCâu hỏi 5:\nPhát biểu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> answer_questions()\nAAAAA\n\nBạn được yêu cầu chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9533671481836772",
      "arb": "0.9504415213014143",
      "sw": "0.904710650045371",
      "tr": "0.9407139956509928",
      "vi": "0.940316933519304"
    }
  },
  {
    "task_id": "JavaScript/21",
    "prompt": {
      "en": "\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets,\n * where each bucket contains a_i squares with a side length of 1, into a single larger square.\n * Input: length of the list, array of numbers\n * @param {number} length - The number of buckets.\n * @param {number[]} squares - An array of numbers, where each number represents the count of squares in a bucket.\n * @returns {boolean} - Returns true if it's possible to form a perfect square, otherwise returns false.\n *\n * Examples:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "es": "/**\n * Determina si es posible ensamblar los cuadrados de madera de n cubetas,\n * donde cada cubeta contiene a_i cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\n * Entrada: longitud de la lista, arreglo de números\n * @param {number} length - El número de cubetas.\n * @param {number[]} squares - Un arreglo de números, donde cada número representa la cantidad de cuadrados en una cubeta.\n * @returns {boolean} - Devuelve true si es posible formar un cuadrado perfecto, de lo contrario devuelve false.\n *\n * Ejemplos:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "arb": "/**\n * يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\n * حيث يحتوي كل دلو على a_i مربعات بطول جانب 1، في مربع أكبر واحد.\n * المدخلات: طول القائمة، مصفوفة من الأرقام\n * @param {number} length - عدد الدلاء.\n * @param {number[]} squares - مصفوفة من الأرقام، حيث يمثل كل رقم عدد المربعات في دلو.\n * @returns {boolean} - يعيد true إذا كان من الممكن تشكيل مربع مثالي، وإلا يعيد false.\n *\n * أمثلة:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "sw": "/**\n * Huamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n,\n * ambapo kila ndoo ina a_i miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\n * Ingizo: urefu wa orodha, safu ya nambari\n * @param {number} length - Idadi ya ndoo.\n * @param {number[]} squares - Safu ya nambari, ambapo kila nambari inawakilisha idadi ya miraba katika ndoo.\n * @returns {boolean} - Inarejesha kweli ikiwa inawezekana kuunda mraba kamili, vinginevyo inarejesha uongo.\n *\n * Mifano:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "tr": "/**\n * Her bir kovada a_i kenar uzunluğu 1 olan kareler bulunan n kovadan,\n * tek bir büyük kare oluşturmanın mümkün olup olmadığını belirler.\n * Girdi: listenin uzunluğu, sayıların dizisi\n * @param {number} length - Kova sayısı.\n * @param {number[]} squares - Her bir sayının bir kovadaki kare sayısını temsil ettiği bir sayı dizisi.\n * @returns {boolean} - Mükemmel bir kare oluşturmak mümkünse true, aksi takdirde false döner.\n *\n * Örnekler:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "vi": "/**\n * Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\n * trong đó mỗi thùng chứa a_i hình vuông với cạnh dài 1, thành một hình vuông lớn hơn duy nhất hay không.\n * Đầu vào: độ dài của danh sách, mảng số\n * @param {number} length - Số lượng thùng.\n * @param {number[]} squares - Một mảng số, trong đó mỗi số đại diện cho số lượng hình vuông trong một thùng.\n * @returns {boolean} - Trả về true nếu có thể tạo thành một hình vuông hoàn hảo, nếu không trả về false.\n *\n * Ví dụ:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)"
    },
    "prompt_bertscore": {
      "es": "0.9905044746346272",
      "arb": "0.978706624522679",
      "sw": "0.9665681233072559",
      "tr": "0.9381683486876496",
      "vi": "0.9569299813283"
    },
    "canonical_solution": "{\n    let sum = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Summing the squares\n    }\n    let root = Math.sqrt(sum);\n    return Math.floor(root) === root; // Checking if sum is a perfect square\n}",
    "instruction": {
      "en": "Write a JavaScript function `function Is_Square(length, squares)` to solve the following problem:\nDetermines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of the list, array of numbers\nParameters:\n- length (number): The number of buckets.\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.\nReturns:\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.\n\nExamples:\nIs_Square(1, [9]) // true\n",
      "es": "Escribe una función de JavaScript `function Is_Square(length, squares)` para resolver el siguiente problema:\nDetermina si es posible ensamblar los cuadrados de madera de n cubetas,\ndonde cada cubeta contiene a_i cuadrados con una longitud de lado de 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\nParámetros:\n- length (number): El número de cubetas.\n- squares (number[]): Un array de números, donde cada número representa la cantidad de cuadrados en una cubeta.\nDevuelve:\n- boolean: Devuelve true si es posible formar un cuadrado perfecto, de lo contrario devuelve false.\n\nEjemplos:\nIs_Square(1, [9]) // true",
      "arb": "اكتب دالة JavaScript `function Is_Square(length, squares)` لحل المشكلة التالية:\nتحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على a_i مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة من الأرقام\nالمعلمات:\n- length (number): عدد الدلاء.\n- squares (number[]): مصفوفة من الأرقام، حيث يمثل كل رقم عدد المربعات في دلو.\nالإرجاع:\n- boolean: يعيد true إذا كان من الممكن تشكيل مربع كامل، وإلا يعيد false.\n\nأمثلة:\nIs_Square(1, [9]) // true",
      "sw": "Andika kazi ya JavaScript `function Is_Square(length, squares)` kutatua tatizo lifuatalo:\nInabainisha kama inawezekana kukusanya mraba wa mbao kutoka kwenye ndoo n,\nambapo kila ndoo ina a_i miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nIngizo: urefu wa orodha, safu ya namba\nVigezo:\n- length (nambari): Idadi ya ndoo.\n- squares (nambari[]): Safu ya namba, ambapo kila namba inawakilisha idadi ya miraba kwenye ndoo.\nInarudisha:\n- boolean: Inarudisha kweli ikiwa inawezekana kuunda mraba kamili, vinginevyo inarudisha uongo.\n\nMifano:\nIs_Square(1, [9]) // true",
      "tr": "Bir JavaScript fonksiyonu `function Is_Square(length, squares)` yazın ve aşağıdaki problemi çözün:\nHer bir kovada a_i kenar uzunluğu 1 olan kareler bulunan n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\nGirdi: listenin uzunluğu, sayıların dizisi\nParametreler:\n- length (number): Kova sayısı.\n- squares (number[]): Her bir sayının bir kovadaki kare sayısını temsil ettiği bir sayı dizisi.\nDöndürür:\n- boolean: Mükemmel bir kare oluşturmanın mümkün olup olmadığını belirler, mümkünse true, aksi takdirde false döndürür.\n\nÖrnekler:\nIs_Square(1, [9]) // true",
      "vi": "Viết một hàm JavaScript `function Is_Square(length, squares)` để giải quyết vấn đề sau:\nXác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\ntrong đó mỗi thùng chứa a_i hình vuông với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\nTham số:\n- length (number): Số lượng thùng.\n- squares (number[]): Một mảng số, trong đó mỗi số đại diện cho số lượng hình vuông trong một thùng.\nTrả về:\n- boolean: Trả về true nếu có thể tạo thành một hình vuông hoàn hảo, ngược lại trả về false.\n\nVí dụ:\nIs_Square(1, [9]) // true"
    },
    "instruction_bertscore": {
      "es": "0.9889450275131223",
      "arb": "0.967109589725957",
      "sw": "0.9707637928458558",
      "tr": "0.9401413442624692",
      "vi": "0.9634561811275824"
    },
    "level": "easy",
    "test": "const testIsSquare = () => {\n    console.assert(Is_Square(1, [9]) === true);\n    console.assert(Is_Square(2, [14, 2]) === true);\n    console.assert(Is_Square(2, [7, 7]) === false);\n    console.assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) === false);\n    console.assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) === true);\n    console.assert(Is_Square(4, [2, 2, 2, 2]) === false);\n\n    // Additional test cases\n    console.assert(Is_Square(3, [4, 5, 6]) === false);\n    console.assert(Is_Square(4, [16, 9, 4, 1]) === false);\n    console.assert(Is_Square(5, [1, 1, 1, 1, 1]) === false);\n    console.assert(Is_Square(2, [25, 25]) === false);\n    console.assert(Is_Square(3, [10, 10, 5]) === true);\n\n    // console.log(\"All tests passed!\");\n}\n\ntestIsSquare();",
    "entry_point": "Is_Square",
    "signature": "function Is_Square(length, squares)",
    "docstring": {
      "en": "Determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of the list, array of numbers\nParameters:\n- length (number): The number of buckets.\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.\nReturns:\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.\n\nExamples:\nIs_Square(1, [9]) // true\n",
      "es": "Determina si es posible ensamblar los cuadrados de madera de n cubetas, donde cada cubeta contiene a_i cuadrados con un lado de longitud 1, en un cuadrado más grande.  \nEntrada: longitud de la lista, array de números  \nParámetros:  \n- length (número): El número de cubetas.  \n- squares (número[]): Un array de números, donde cada número representa la cantidad de cuadrados en una cubeta.  \nDevuelve:  \n- booleano: Devuelve verdadero si es posible formar un cuadrado perfecto, de lo contrario devuelve falso.  \n\nEjemplos:  \nIs_Square(1, [9]) // true  ",
      "arb": "يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلوًا، حيث يحتوي كل دلو على a_i من المربعات ذات طول ضلع 1، في مربع أكبر واحد.\n\nالمدخلات: طول القائمة، مصفوفة الأرقام\n\nالمعلمات:\n- length (رقم): عدد الدلاء.\n- squares (number[]): مصفوفة من الأرقام، حيث يمثل كل رقم عدد المربعات في دلو.\n\nالمخرجات:\n- boolean: يعيد true إذا كان من الممكن تشكيل مربع مثالي، وإلا يعيد false.\n\nأمثلة:\nIs_Square(1, [9]) // true",
      "sw": "Inabainisha ikiwa inawezekana kuunganisha mraba wa mbao kutoka kwenye n ndoo, ambapo kila ndoo ina a_i miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.  \nIngizo: urefu wa orodha, safu ya namba  \nVigezo:  \n- length (nambari): Idadi ya ndoo.  \n- squares (nambari[]): Safu ya namba, ambapo kila namba inawakilisha idadi ya miraba katika ndoo.  \nInarejesha:  \n- boolean: Inarejesha kweli ikiwa inawezekana kuunda mraba kamili, vinginevyo inarejesha uongo.  \n\nMifano:  \nIs_Square(1, [9]) // true",
      "tr": "n kovadan, her bir kova a_i kenar uzunluğu 1 olan kareler içeriyorsa, ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\nGirdi: listenin uzunluğu, sayıların dizisi\nParametreler:\n- length (number): Kova sayısı.\n- squares (number[]): Her bir sayının bir kovadaki kare sayısını temsil ettiği bir sayı dizisi.\nDöndürür:\n- boolean: Mükemmel bir kare oluşturmak mümkünse true, aksi takdirde false döner.\n\nÖrnekler:\nIs_Square(1, [9]) // true",
      "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ n xô, trong đó mỗi xô chứa a_i hình vuông có cạnh dài 1, thành một hình vuông lớn hơn hay không.  \nĐầu vào: độ dài của danh sách, mảng số  \nTham số:  \n- length (number): Số lượng xô.  \n- squares (number[]): Một mảng số, trong đó mỗi số đại diện cho số lượng hình vuông trong một xô.  \nTrả về:  \n- boolean: Trả về true nếu có thể tạo thành một hình vuông hoàn hảo, ngược lại trả về false.  \n\nVí dụ:  \nIs_Square(1, [9]) // true  "
    },
    "docstring_bertscore": {
      "es": "0.9820555327469271",
      "arb": "0.9602844512032173",
      "sw": "0.9639928804171386",
      "tr": "0.9251417710386196",
      "vi": "0.9676689328789513"
    }
  },
  {
    "task_id": "JavaScript/22",
    "prompt": {
      "en": "\n/**\n * Given integers c and d, where a + b = c and a * b = d, find and return the\n * possible value of a (a <= b). If there are multiple groups, output the group\n * with the smallest a.\n * \n * Parameters:\n *   - c (int): The sum of a and b.\n *   - d (int): The product of a and b.\n * \n * Returns:\n *   A possible value of a or -1 if valid values do not exist.\n * \n * Examples:\n *   findIntegers(7, 11) // returns -1\n *   findIntegers(5, 6)  // returns 2\n */\nfunction findIntegers(c, d)",
      "es": "/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el\n * valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo\n * con el menor a.\n * \n * Parámetros:\n *   - c (int): La suma de a y b.\n *   - d (int): El producto de a y b.\n * \n * Devuelve:\n *   Un valor posible de a o -1 si no existen valores válidos.\n * \n * Ejemplos:\n *   findIntegers(7, 11) // devuelve -1\n *   findIntegers(5, 6)  // devuelve 2\n */\nfunction findIntegers(c, d)",
      "arb": "/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد\n * القيمة الممكنة لـ a (a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة\n * ذات القيمة الأصغر لـ a.\n * \n * المعطيات:\n *   - c (int): مجموع a و b.\n *   - d (int): حاصل ضرب a و b.\n * \n * يعيد:\n *   قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n * \n * أمثلة:\n *   findIntegers(7, 11) // يعيد -1\n *   findIntegers(5, 6)  // يعيد 2\n */\nfunction findIntegers(c, d)",
      "sw": "/**\n * Ukipewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta na urejeshe\n * thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi\n * lenye a ndogo zaidi.\n * \n * Vigezo:\n *   - c (int): Jumla ya a na b.\n *   - d (int): Bidhaa ya a na b.\n * \n * Inarejesha:\n *   Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n * \n * Mifano:\n *   findIntegers(7, 11) // inarejesha -1\n *   findIntegers(5, 6)  // inarejesha 2\n */\nfunction findIntegers(c, d)",
      "tr": "/**\n * a ve b'nin toplamı c ve a * b = d olan c ve d tamsayıları verildiğinde,\n * a'nın (a <= b) olası değerini bulun ve döndürün. Birden fazla grup varsa,\n * en küçük a'ya sahip olan grubu çıktıya verin.\n * \n * Parametreler:\n *   - c (int): a ve b'nin toplamı.\n *   - d (int): a ve b'nin çarpımı.\n * \n * Döndürür:\n *   a'nın olası bir değeri veya geçerli değerler yoksa -1.\n * \n * Örnekler:\n *   findIntegers(7, 11) // -1 döndürür\n *   findIntegers(5, 6)  // 2 döndürür\n */\nfunction findIntegers(c, d)",
      "vi": "/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về\n * giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm\n * với a nhỏ nhất.\n * \n * Tham số:\n *   - c (int): Tổng của a và b.\n *   - d (int): Tích của a và b.\n * \n * Trả về:\n *   Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n * \n * Ví dụ:\n *   findIntegers(7, 11) // trả về -1\n *   findIntegers(5, 6)  // trả về 2\n */\nfunction findIntegers(c, d)"
    },
    "prompt_bertscore": {
      "es": "0.9906089542150516",
      "arb": "0.9676466862762754",
      "sw": "0.9718997599949943",
      "tr": "0.9706696420452453",
      "vi": "0.9817099158839264"
    },
    "canonical_solution": "{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a JavaScript function `function findIntegers(c, d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // returns -1\n  findIntegers(5, 6)  // returns 2\n",
      "es": "Escribe una función de JavaScript `function findIntegers(c, d)` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, muestra el grupo con el menor a.\n\nParámetros:\n  - c (int): La suma de a y b.\n  - d (int): El producto de a y b.\n\nDevuelve:\n  Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\n  findIntegers(7, 11) // devuelve -1\n  findIntegers(5, 6)  // devuelve 2",
      "arb": "اكتب دالة JavaScript `function findIntegers(c, d)` لحل المشكلة التالية:\nمعطى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة الممكنة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة ذات القيمة الأصغر لـ a.\n\nالمعطيات:\n  - c (int): مجموع a و b.\n  - d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n  قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\n  findIntegers(7, 11) // يعيد -1\n  findIntegers(5, 6)  // يعيد 2",
      "sw": "Andika kazi ya JavaScript `function findIntegers(c, d)` kutatua tatizo lifuatalo:\nUkipiwa nambari kamili c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n\nVigezo:\n  - c (int): Jumla ya a na b.\n  - d (int): Bidhaa ya a na b.\n\nRudisha:\n  Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n\nMifano:\n  findIntegers(7, 11) // inarudisha -1\n  findIntegers(5, 6)  // inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `function findIntegers(c, d)` yazın ve aşağıdaki problemi çözün:\nVerilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın (a <= b) olası değerini bulun ve döndürün. Birden fazla grup varsa, en küçük a'ya sahip grubu çıktı olarak verin.\n\nParametreler:\n  - c (int): a ve b'nin toplamı.\n  - d (int): a ve b'nin çarpımı.\n\nDöndürülen:\n  a'nın olası bir değeri veya geçerli değerler yoksa -1.\n\nÖrnekler:\n  findIntegers(7, 11) // -1 döndürür\n  findIntegers(5, 6)  // 2 döndürür",
      "vi": "Viết một hàm JavaScript `function findIntegers(c, d)` để giải quyết vấn đề sau:  \nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n\nTham số:\n  - c (int): Tổng của a và b.\n  - d (int): Tích của a và b.\n\nTrả về:\n  Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\n  findIntegers(7, 11) // trả về -1\n  findIntegers(5, 6)  // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9799629616827246",
      "arb": "0.9536454293475071",
      "sw": "0.9817691077374748",
      "tr": "0.959690744994304",
      "vi": "0.9863600517343343"
    },
    "level": "easy",
    "test": "const testFindIntegers = () => {\n    console.assert(findIntegers(5, 6) === 2, \"Expected 2\");\n    console.assert(findIntegers(6, 9) === 3, \"Expected 3\");\n    console.assert(findIntegers(7, 12) === 3, \"Expected 3\");\n    console.assert(findIntegers(7, 11) === -1, \"Expected -1\");\n    console.assert(findIntegers(9, 8) === 1, \"Expected 1\");\n    console.assert(findIntegers(10, 25) === 5, \"Expected 5\");\n    console.assert(findIntegers(10000, 8765) === -1, \"Expected -1\");\n    // console.log(\"All tests passed successfully.\");\n}\n\ntestFindIntegers();",
    "entry_point": "findIntegers",
    "signature": "function findIntegers(c, d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // returns -1\n  findIntegers(5, 6)  // returns 2\n",
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n\nParámetros:\n  - c (int): La suma de a y b.\n  - d (int): El producto de a y b.\n\nDevuelve:\n  Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\n  findIntegers(7, 11) // devuelve -1\n  findIntegers(5, 6)  // devuelve 2",
      "arb": "معطى عددان صحيحان c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة المحتملة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، أخرج المجموعة ذات القيمة الأصغر لـ a.\n\nالمعلمات:\n  - c (int): مجموع a و b.\n  - d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n  قيمة محتملة لـ a أو -1 إذا لم تكن هناك قيم صالحة موجودة.\n\nأمثلة:\n  findIntegers(7, 11) // يعيد -1\n  findIntegers(5, 6)  // يعيد 2",
      "sw": "Kutolewa nambari za mzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n\nVigezo:\n  - c (int): Jumla ya a na b.\n  - d (int): Bidhaa ya a na b.\n\nRudisha:\n  Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n\nMifano:\n  findIntegers(7, 11) // inarudisha -1\n  findIntegers(5, 6)  // inarudisha 2",
      "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıkartın.\n\nParametreler:\n  - c (int): a ve b'nin toplamı.\n  - d (int): a ve b'nin çarpımı.\n\nDöndürür:\n  a'nın olası bir değeri veya geçerli değerler mevcut değilse -1.\n\nÖrnekler:\n  findIntegers(7, 11) // -1 döndürür\n  findIntegers(5, 6)  // 2 döndürür",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n\nTham số:\n  - c (int): Tổng của a và b.\n  - d (int): Tích của a và b.\n\nTrả về:\n  Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\n  findIntegers(7, 11) // trả về -1\n  findIntegers(5, 6)  // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9900464329759607",
      "arb": "0.9607492462948388",
      "sw": "0.9590318880204112",
      "tr": "0.9872475322767981",
      "vi": "0.9840750078309088"
    }
  },
  {
    "task_id": "JavaScript/23",
    "prompt": {
      "en": "\n/**\n * Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n * \n * @param {number} edges_count - The number of edges.\n * @param {...number} edges - The lengths of the edges.\n * @returns {number} The count of distinct acute-angled triangles that can be formed.\n * \n * Examples:\n * count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "es": "/**\n * Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n * \n * @param {number} edges_count - El número de lados.\n * @param {...number} edges - Las longitudes de los lados.\n * @returns {number} La cantidad de triángulos acutángulos distintos que se pueden formar.\n * \n * Ejemplos:\n * count_acute_triangles(4, 1, 1, 1, 1) // devuelve 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "arb": "/**\n * احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n * \n * @param {number} edges_count - عدد الحواف.\n * @param {...number} edges - أطوال الحواف.\n * @returns {number} عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n * \n * أمثلة:\n * count_acute_triangles(4, 1, 1, 1, 1) // يعيد 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "sw": "/**\n * Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti ya pande zilizotolewa.\n * \n * @param {number} edges_count - Idadi ya pande.\n * @param {...number} edges - Urefu wa pande.\n * @returns {number} Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n * \n * Mifano:\n * count_acute_triangles(4, 1, 1, 1, 1) // inarudisha 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "tr": "/**\n * Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayar.\n * \n * @param {number} edges_count - Kenarların sayısı.\n * @param {...number} edges - Kenarların uzunlukları.\n * @returns {number} Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n * \n * Örnekler:\n * count_acute_triangles(4, 1, 1, 1, 1) // 4 döndürür\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "vi": "/**\n * Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n * \n * @param {number} edges_count - Số lượng cạnh.\n * @param {...number} edges - Độ dài của các cạnh.\n * @returns {number} Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n * \n * Ví dụ:\n * count_acute_triangles(4, 1, 1, 1, 1) // trả về 4\n */\nfunction count_acute_triangles(edges_count, ...edges)"
    },
    "prompt_bertscore": {
      "es": "0.9562486791213504",
      "arb": "0.9865257094721174",
      "sw": "0.9412570511127422",
      "tr": "0.9864506271880862",
      "vi": "0.9628559201160949"
    },
    "canonical_solution": "{\n    // Sort the edges array\n    edges.sort((a, b) => a - b);\n\n    let sum = 0;\n    // Check each combination of three edges for an acute triangle.\n    for (let i = 0; i < edges_count - 2; i++) {\n        for (let j = i + 1; j < edges_count - 1; j++) {\n            for (let k = j + 1; k < edges_count; k++) {\n                const x = edges[i], y = edges[j], z = edges[k];\n                // The sum of any two sides must be greater than the third, and\n                // it needs to meet the acute angle criteria via Pythagoras.\n                if (x + y > z && (x * x + y * y > z * z)) {\n                    sum++;\n                }\n            }\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function count_acute_triangles(edges_count, ...edges)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nParameters:\n- edges_count (number): The number of edges.\n- edges (...number): The lengths of the edges.\n\nReturns:\n- number: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n- count_acute_triangles(4, 1, 1, 1, 1) // devuelve 4\n",
      "es": "Escribe una función de JavaScript `function count_acute_triangles(edges_count, ...edges)` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nParámetros:\n- edges_count (número): El número de lados.\n- edges (...número): Las longitudes de los lados.\n\nDevuelve:\n- número: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n- count_acute_triangles(4, 1, 1, 1, 1) // devuelve 4",
      "arb": "اكتب دالة JavaScript `function count_acute_triangles(edges_count, ...edges)` لحل المشكلة التالية:\nعد عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nالمعطيات:\n- edges_count (number): عدد الأضلاع.\n- edges (...number): أطوال الأضلاع.\n\nالمخرجات:\n- number: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n- count_acute_triangles(4, 1, 1, 1, 1) // يعيد 4",
      "sw": "Andika kazi ya JavaScript `function count_acute_triangles(edges_count, ...edges)` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nVigezo:\n- edges_count (nambari): Idadi ya pande.\n- edges (...nambari): Urefu wa pande.\n\nInarudisha:\n- nambari: Idadi ya pembetatu zenye pembe kali zinazoweza kuundwa.\n\nMifano:\n- count_acute_triangles(4, 1, 1, 1, 1) // inarudisha 4",
      "tr": "Bir JavaScript fonksiyonu `function count_acute_triangles(edges_count, ...edges)` yazın ve aşağıdaki problemi çözün:\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nParametreler:\n- edges_count (number): Kenarların sayısı.\n- edges (...number): Kenarların uzunlukları.\n\nDöndürür:\n- number: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\n- count_acute_triangles(4, 1, 1, 1, 1) // 4 döndürür",
      "vi": "Viết một hàm JavaScript `function count_acute_triangles(edges_count, ...edges)` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nTham số:\n- edges_count (number): Số lượng cạnh.\n- edges (...number): Độ dài của các cạnh.\n\nTrả về:\n- number: Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n\nVí dụ:\n- count_acute_triangles(4, 1, 1, 1, 1) // trả về 4"
    },
    "instruction_bertscore": {
      "es": "0.9635292771078031",
      "arb": "0.9507007339486649",
      "sw": "0.9551744860207136",
      "tr": "0.9712641427756827",
      "vi": "0.9763472928567466"
    },
    "level": "hard",
    "test": "(function testAcuteTriangles() {\n    console.assert(count_acute_triangles(4, 1, 1, 1, 1) === 4, \"Test case 1 failed\");\n    console.assert(count_acute_triangles(3, 1, 2, 3) === 0, \"Test case 2 failed\");\n    // Additional tests to ensure correctness\n    console.assert(count_acute_triangles(5, 3, 4, 5, 7, 10) === 0, \"Test case 3 failed\");\n    console.assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) === 4, \"Test case 4 failed\");\n})();",
    "entry_point": "count_acute_triangles",
    "signature": "function count_acute_triangles(edges_count, ...edges)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nParameters:\n- edges_count (number): The number of edges.\n- edges (...number): The lengths of the edges.\n\nReturns:\n- number: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n- count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n",
      "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nParámetros:\n- edges_count (número): El número de lados.\n- edges (...número): Las longitudes de los lados.\n\nDevuelve:\n- número: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\n- count_acute_triangles(4, 1, 1, 1, 1) // devuelve 4",
      "arb": "احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nالمعطيات:\n- edges_count (عدد): عدد الأضلاع.\n- edges (...عدد): أطوال الأضلاع.\n\nالقيم المعادة:\n- عدد: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n- count_acute_triangles(4, 1, 1, 1, 1) // يعيد 4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nVigezo:\n- edges_count (nambari): Idadi ya pande.\n- edges (...nambari): Urefu wa pande.\n\nInarejesha:\n- nambari: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\n- count_acute_triangles(4, 1, 1, 1, 1) // inarejesha 4",
      "tr": "Verilen bir kenar kümesinden herhangi bir 3 kenar seçilerek oluşturulabilecek dik açılı olmayan üçgenlerin sayısını sayın.\n\nParametreler:\n- edges_count (number): Kenarların sayısı.\n- edges (...number): Kenarların uzunlukları.\n\nDöndürür:\n- number: Oluşturulabilecek farklı dik açılı olmayan üçgenlerin sayısı.\n\nÖrnekler:\n- count_acute_triangles(4, 1, 1, 1, 1) // 4 döndürür",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count (number): Số lượng cạnh.\n- edges (...number): Độ dài của các cạnh.\n\nTrả về:\n- number: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n- count_acute_triangles(4, 1, 1, 1, 1) // trả về 4"
    },
    "docstring_bertscore": {
      "es": "0.9527619214126639",
      "arb": "0.9440241709509392",
      "sw": "0.9476011068526154",
      "tr": "0.9595952037810261",
      "vi": "0.9503346581564176"
    }
  },
  {
    "task_id": "JavaScript/24",
    "prompt": {
      "en": "\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * Parameters:\n * - integer_value (number): The input integer.\n * - char_value (string): The input character.\n * Returns:\n * - string: A string containing the integer and character separated by a comma.\n * Examples:\n * process_integer_and_char(234, 'H') returns '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "es": "/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * Parámetros:\n * - integer_value (number): El entero de entrada.\n * - char_value (string): El carácter de entrada.\n * Devuelve:\n * - string: Una cadena que contiene el entero y el carácter separados por una coma.\n * Ejemplos:\n * process_integer_and_char(234, 'H') devuelve '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "arb": "/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n * المعلمات:\n * - integer_value (number): العدد الصحيح المدخل.\n * - char_value (string): الحرف المدخل.\n * يعيد:\n * - string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * أمثلة:\n * process_integer_and_char(234, 'H') يعيد '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "sw": "/**\n * Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa ikitenganishwa na koma.\n * Vigezo:\n * - integer_value (number): Nambari kamili ya ingizo.\n * - char_value (string): Herufi ya ingizo.\n * Inarudisha:\n * - string: Kamba inayojumuisha nambari kamili na herufi ikitenganishwa na koma.\n * Mifano:\n * process_integer_and_char(234, 'H') inarudisha '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "tr": "/**\n * Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * Parametreler:\n * - integer_value (number): Girdi tam sayısı.\n * - char_value (string): Girdi karakteri.\n * Döndürür:\n * - string: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n * Örnekler:\n * process_integer_and_char(234, 'H') '234,H' döndürür\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "vi": "/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n * Tham số:\n * - integer_value (number): Số nguyên đầu vào.\n * - char_value (string): Ký tự đầu vào.\n * Trả về:\n * - string: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n * Ví dụ:\n * process_integer_and_char(234, 'H') trả về '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)"
    },
    "prompt_bertscore": {
      "es": "0.9965279409395101",
      "arb": "0.9999996027392379",
      "sw": "0.9869199907784716",
      "tr": "0.9892870690292643",
      "vi": "0.9812987509951843"
    },
    "canonical_solution": "{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function process_integer_and_char(integer_value, char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\nExamples:\nprocess_integer_and_char(234, 'H') returns '234,H'\n",
      "es": "Escribe una función de JavaScript `function process_integer_and_char(integer_value, char_value)` para resolver el siguiente problema:  \nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.  \nParámetros:  \n- integer_value (number): El entero de entrada.  \n- char_value (string): El carácter de entrada.  \nDevuelve:  \n- string: Una cadena que contiene el entero y el carácter separados por una coma.  \nEjemplos:  \nprocess_integer_and_char(234, 'H') devuelve '234,H'  ",
      "arb": "اكتب دالة JavaScript `function process_integer_and_char(integer_value, char_value)` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (number): العدد الصحيح المدخل.\n- char_value (string): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\nأمثلة:\nprocess_integer_and_char(234, 'H') يعيد '234,H'",
      "sw": "Andika kazi ya JavaScript `function process_integer_and_char(integer_value, char_value)` kutatua tatizo lifuatalo:  \nSoma nambari nzima na herufi, kisha zirudishe kama kamba iliyopangwa ikitenganishwa na koma.  \nVigezo:  \n- integer_value (number): Nambari nzima ya pembejeo.  \n- char_value (string): Herufi ya pembejeo.  \nRudisha:  \n- string: Kamba inayoambatana na nambari nzima na herufi ikitenganishwa na koma.  \nMifano:  \nprocess_integer_and_char(234, 'H') inarudisha '234,H'  ",
      "tr": "Bir JavaScript fonksiyonu `function process_integer_and_char(integer_value, char_value)` yazın:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (number): Girdi tam sayısı.\n- char_value (string): Girdi karakteri.\nDöndürülen:\n- string: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\nÖrnekler:\nprocess_integer_and_char(234, 'H') '234,H' döndürür.",
      "vi": "Viết một hàm JavaScript `function process_integer_and_char(integer_value, char_value)` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bởi dấu phẩy.\nTham số:\n- integer_value (number): Số nguyên đầu vào.\n- char_value (string): Ký tự đầu vào.\nTrả về:\n- string: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\nVí dụ:\nprocess_integer_and_char(234, 'H') trả về '234,H'"
    },
    "instruction_bertscore": {
      "es": "0.9932910602501657",
      "arb": "0.994437157548737",
      "sw": "0.9841719394568539",
      "tr": "0.9691181401389818",
      "vi": "0.9840201858457432"
    },
    "level": "easy",
    "test": "const testProcessIntegerAndChar = () => {\n    console.assert(process_integer_and_char(234, 'H') === '234,H', 'Test 1 Failed');\n    console.assert(process_integer_and_char(123, 'A') === '123,A', 'Test 2 Failed');\n    console.assert(process_integer_and_char(0, 'Z') === '0,Z', 'Test 3 Failed');\n}\n\ntestProcessIntegerAndChar();",
    "entry_point": "process_integer_and_char",
    "signature": "function process_integer_and_char(integer_value, char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\nExamples:\nprocess_integer_and_char(234, 'H') returns '234,H'\n",
      "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (number): El entero de entrada.\n- char_value (string): El carácter de entrada.\nDevuelve:\n- string: Una cadena que contiene el entero y el carácter separados por una coma.\nEjemplos:\nprocess_integer_and_char(234, 'H') devuelve '234,H'",
      "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (number): العدد الصحيح المدخل.\n- char_value (string): الحرف المدخل.\nالقيم المعادة:\n- string: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\nأمثلة:\nprocess_integer_and_char(234, 'H') يعيد '234,H'",
      "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama mfuatano wa maandishi uliopangwa ukiwa umetenganishwa na koma.  \nVigezo:  \n- integer_value (nambari): Nambari kamili ya ingizo.  \n- char_value (kamba): Herufi ya ingizo.  \nInarejesha:  \n- kamba: Mfuatano wa maandishi unao na nambari kamili na herufi zikitenganishwa na koma.  \nMifano:  \nprocess_integer_and_char(234, 'H') inarejesha '234,H'  ",
      "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (number): Girdi tam sayısı.\n- char_value (string): Girdi karakteri.\nDöndürülenler:\n- string: Tam sayı ve karakteri virgülle ayırarak içeren bir dize.\nÖrnekler:\nprocess_integer_and_char(234, 'H') '234,H' döndürür.",
      "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng cách nhau bởi dấu phẩy.  \nTham số:  \n- integer_value (number): Số nguyên đầu vào.  \n- char_value (string): Ký tự đầu vào.  \nTrả về:  \n- string: Một chuỗi chứa số nguyên và ký tự cách nhau bởi dấu phẩy.  \nVí dụ:  \nprocess_integer_and_char(234, 'H') trả về '234,H'  "
    },
    "docstring_bertscore": {
      "es": "0.9897028024167703",
      "arb": "0.9794212966336425",
      "sw": "0.9758026483519489",
      "tr": "0.9855073315085514",
      "vi": "0.9780402195943069"
    }
  },
  {
    "task_id": "JavaScript/25",
    "prompt": {
      "en": "\n/**\n * Shifts all characters by 5 positions in alphabetical order.\n * Only letters are replaced, and all letters are in uppercase.\n *\n * @param {string} text The input text to be processed.\n * @returns {string} The transformed text with characters shifted by 5 positions.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "es": "/**\n * Desplaza todos los caracteres 5 posiciones en orden alfabético.\n * Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n *\n * @param {string} text El texto de entrada a ser procesado.\n * @returns {string} El texto transformado con caracteres desplazados 5 posiciones.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // devuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "arb": "/**\n * يحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\n * يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n *\n * @param {string} text النص المدخل ليتم معالجته.\n * @returns {string} النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // يعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "sw": "/**\n * Inahamisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\n * Ni herufi pekee zinabadilishwa, na herufi zote ni kubwa.\n *\n * @param {string} text Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n * @returns {string} Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // inarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "tr": "/**\n * Tüm karakterleri alfabetik sırada 5 pozisyon kaydırır.\n * Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n *\n * @param {string} text İşlenecek giriş metni.\n * @returns {string} Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // döndürür \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "vi": "/**\n * Dịch chuyển tất cả các ký tự 5 vị trí theo thứ tự bảng chữ cái.\n * Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n *\n * @param {string} text Văn bản đầu vào cần được xử lý.\n * @returns {string} Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // trả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)"
    },
    "prompt_bertscore": {
      "es": "0.988909671305298",
      "arb": "0.9910189273215075",
      "sw": "0.9644068261312153",
      "tr": "0.9733523439715025",
      "vi": "0.9852753312235027"
    },
    "canonical_solution": "{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function shiftCharacters(text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n\nExample:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "es": "Escribe una función de JavaScript `function shiftCharacters(text)` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético.\nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\n- text (string): El texto de entrada a ser procesado.\n\nDevuelve:\n- string: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// devuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "اكتب دالة JavaScript `function shiftCharacters(text)` لحل المشكلة التالية:\nتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي.\nيتم استبدال الأحرف فقط، وجميع الأحرف تكون بحروف كبيرة.\n\nالمعلمات:\n- text (string): النص المدخل ليتم معالجته.\n\nيعيد:\n- string: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\nمثال:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// يعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Andika kazi ya JavaScript `function shiftCharacters(text)` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti.\nNi herufi pekee zinazobadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\n- text (string): Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n\nInarudisha:\n- string: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\nMfano:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// inarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Bir JavaScript fonksiyonu `function shiftCharacters(text)` yazın:\nAlfabetik sırada tüm karakterleri 5 pozisyon kaydırır.\nSadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\n- text (string): İşlenecek giriş metni.\n\nDöndürülen:\n- string: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür.",
      "vi": "Viết một hàm JavaScript `function shiftCharacters(text)` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái.\nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\n- text (string): Văn bản đầu vào cần xử lý.\n\nTrả về:\n- string: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\nVí dụ:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// trả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "es": "0.9821780876920257",
      "arb": "0.9945299179366802",
      "sw": "0.9766382863649626",
      "tr": "0.954965725490246",
      "vi": "0.984508022061565"
    },
    "level": "middle",
    "test": "const testShiftCharacters = () => {\n    console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\", 'Test 1 failed');\n    console.assert(shiftCharacters(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\", 'Test 2 failed');\n    console.assert(shiftCharacters(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\", 'Test 3 failed');\n};\n\ntestShiftCharacters();",
    "entry_point": "shiftCharacters",
    "signature": "function shiftCharacters(text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n\nExample:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético.  \nSolo se reemplazan las letras, y todas las letras están en mayúsculas.\n\nParámetros:\n- text (string): El texto de entrada a ser procesado.\n\nDevuelve:\n- string: El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// devuelve \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\n- text (string): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\n- string: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\nمثال:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// يعيد \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. \nNi herufi pekee zinazobadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\n- text (string): Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n\nRudisha:\n- string: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\nMfano:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// inarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. \nYalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\n- text (string): İşlenecek giriş metni.\n\nDöndürür:\n- string: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\nÖrnek:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür",
      "vi": "Dịch chuyển tất cả các ký tự lên 5 vị trí trong thứ tự bảng chữ cái.  \nChỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\n- text (string): Văn bản đầu vào cần xử lý.\n\nTrả về:\n- string: Văn bản đã được biến đổi với các ký tự dịch chuyển lên 5 vị trí.\n\nVí dụ:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// trả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9751628598946355",
      "arb": "0.9865505382697467",
      "sw": "0.9445014797565661",
      "tr": "0.9627562076648154",
      "vi": "0.980511578795143"
    }
  },
  {
    "task_id": "JavaScript/26",
    "prompt": {
      "en": "\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9\n*/\nfunction classify_integer(x)",
      "es": "/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que \nse determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\nclassify_integer(\"24\") // devuelve 6\nclassify_integer(\"39\") // devuelve 3\nclassify_integer(\"123456789\") // devuelve 9\nclassify_integer(\"123456789012345678901234567890\") // devuelve 9\nclassify_integer(\"12345\") // devuelve 6\nclassify_integer(\"999999999\") // devuelve 9\n*/\nfunction classify_integer(x)",
      "arb": "/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالإرجاع:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\nclassify_integer(\"24\") // يعيد 6\nclassify_integer(\"39\") // يعيد 3\nclassify_integer(\"123456789\") // يعيد 9\nclassify_integer(\"123456789012345678901234567890\") // يعيد 9\nclassify_integer(\"12345\") // يعيد 6\nclassify_integer(\"999999999\") // يعيد 9\n*/\nfunction classify_integer(x)",
      "sw": "/*\nKlasifai nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusishwa na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \ndarasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kuhesabu inayopaswa kuainishwa kama string.\n\nInarudisha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\nclassify_integer(\"24\") // inarudisha 6\nclassify_integer(\"39\") // inarudisha 3\nclassify_integer(\"123456789\") // inarudisha 9\nclassify_integer(\"123456789012345678901234567890\") // inarudisha 9\nclassify_integer(\"12345\") // inarudisha 6\nclassify_integer(\"999999999\") // inarudisha 9\n*/\nfunction classify_integer(x)",
      "tr": "/*\nAşağıdaki yönteme göre tam sayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in rakamlarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı bir string olarak.\n\nDöndürür:\nint: Tam sayı x'in ait olduğu sınıf.\n\nÖrnekler:\nclassify_integer(\"24\") // 6 döndürür\nclassify_integer(\"39\") // 3 döndürür\nclassify_integer(\"123456789\") // 9 döndürür\nclassify_integer(\"123456789012345678901234567890\") // 9 döndürür\nclassify_integer(\"12345\") // 6 döndürür\nclassify_integer(\"999999999\") // 9 döndürür\n*/\nfunction classify_integer(x)",
      "vi": "/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \nlớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\nclassify_integer(\"24\") // trả về 6\nclassify_integer(\"39\") // trả về 3\nclassify_integer(\"123456789\") // trả về 9\nclassify_integer(\"123456789012345678901234567890\") // trả về 9\nclassify_integer(\"12345\") // trả về 6\nclassify_integer(\"999999999\") // trả về 9\n*/\nfunction classify_integer(x)"
    },
    "prompt_bertscore": {
      "es": "0.9948209114448964",
      "arb": "0.9827682185540804",
      "sw": "0.9712124988766137",
      "tr": "0.993640649720787",
      "vi": "0.9842098778596315"
    },
    "canonical_solution": "{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function classify_integer(x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "es": "Escribe una función de JavaScript `function classify_integer(x)` para resolver el siguiente problema:\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que \nse determine la clase.\n\nParámetros:\n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nEjemplos:\nclassify_integer(\"24\") // devuelve 6\nclassify_integer(\"39\") // devuelve 3\nclassify_integer(\"123456789\") // devuelve 9\nclassify_integer(\"123456789012345678901234567890\") // devuelve 9\nclassify_integer(\"12345\") // devuelve 6\nclassify_integer(\"999999999\") // devuelve 9",
      "arb": "اكتب دالة JavaScript `function classify_integer(x)` لحل المشكلة التالية:\nصنّف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعطيات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\nclassify_integer(\"24\") // يعيد 6\nclassify_integer(\"39\") // يعيد 3\nclassify_integer(\"123456789\") // يعيد 9\nclassify_integer(\"123456789012345678901234567890\") // يعيد 9\nclassify_integer(\"12345\") // يعيد 6\nclassify_integer(\"999999999\") // يعيد 9",
      "sw": "Andika kazi ya JavaScript `function classify_integer(x)` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake yenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \ndarasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari ya kuainishwa kama kamba.\n\nRudisha:\nint: Darasa ambalo nambari x inahusishwa.\n\nMifano:\nclassify_integer(\"24\") // inarudisha 6\nclassify_integer(\"39\") // inarudisha 3\nclassify_integer(\"123456789\") // inarudisha 9\nclassify_integer(\"123456789012345678901234567890\") // inarudisha 9\nclassify_integer(\"12345\") // inarudisha 6\nclassify_integer(\"999999999\") // inarudisha 9",
      "tr": "Bir JavaScript fonksiyonu `function classify_integer(x)` yazın ve aşağıdaki problemi çözün:\nTam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayı, string olarak.\n\nDöndürülen:\nint: Tam sayı x'in ait olduğu sınıf.\n\nÖrnekler:\nclassify_integer(\"24\") // 6 döndürür\nclassify_integer(\"39\") // 3 döndürür\nclassify_integer(\"123456789\") // 9 döndürür\nclassify_integer(\"123456789012345678901234567890\") // 9 döndürür\nclassify_integer(\"12345\") // 6 döndürür\nclassify_integer(\"999999999\") // 9 döndürür",
      "vi": "Viết một hàm JavaScript `function classify_integer(x)` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tính tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \nlớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\nclassify_integer(\"24\") // trả về 6\nclassify_integer(\"39\") // trả về 3\nclassify_integer(\"123456789\") // trả về 9\nclassify_integer(\"123456789012345678901234567890\") // trả về 9\nclassify_integer(\"12345\") // trả về 6\nclassify_integer(\"999999999\") // trả về 9"
    },
    "instruction_bertscore": {
      "es": "0.9950670144869985",
      "arb": "0.9752250312038995",
      "sw": "0.9746291400607948",
      "tr": "0.9872872583530051",
      "vi": "0.9817361350942231"
    },
    "level": "easy",
    "test": "function testClassifyInteger() {\n    console.assert(classify_integer(\"24\") === 6, \"Test failed: classify_integer('24') should return 6.\");\n    console.assert(classify_integer(\"39\") === 3, \"Test failed: classify_integer('39') should return 3.\");\n    console.assert(classify_integer(\"123456789\") === 9, \"Test failed: classify_integer('123456789') should return 9.\");\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9, \"Test failed: classify_integer('123456789012345678901234567890') should return 9.\");\n    console.assert(classify_integer(\"12345\") === 6, \"Test failed: classify_integer('12345') should return 6.\");\n    console.assert(classify_integer(\"999999999\") === 9, \"Test failed: classify_integer('999999999') should return 9.\");\n}\n\ntestClassifyInteger();",
    "entry_point": "classify_integer",
    "signature": "function classify_integer(x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "es": "Clasificar el entero x basado en el siguiente método:  \nSi x es un número de un solo dígito, x pertenece a su propia clase.  \nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que  \nse determine la clase.\n\nParámetros:  \n- x (string): El entero a clasificar como una cadena.\n\nDevuelve:  \nint: La clase a la que pertenece el entero x.\n\nEjemplos:  \nclassify_integer(\"24\") // devuelve 6  \nclassify_integer(\"39\") // devuelve 3  \nclassify_integer(\"123456789\") // devuelve 9  \nclassify_integer(\"123456789012345678901234567890\") // devuelve 9  \nclassify_integer(\"12345\") // devuelve 6  \nclassify_integer(\"999999999\") // devuelve 9  ",
      "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nوإلا، قم بجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعطيات:\n- x (string): العدد الصحيح الذي سيتم تصنيفه كسلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nأمثلة:\nclassify_integer(\"24\") // يعيد 6\nclassify_integer(\"39\") // يعيد 3\nclassify_integer(\"123456789\") // يعيد 9\nclassify_integer(\"123456789012345678901234567890\") // يعيد 9\nclassify_integer(\"12345\") // يعيد 6\nclassify_integer(\"999999999\") // يعيد 9",
      "sw": "Tambua nambari nzima x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \ndarasa litakapobainishwa.\n\nVigezo:\n- x (string): Nambari nzima inayopaswa kutambuliwa kama kamba.\n\nInarejesha:\nint: Darasa ambalo nambari nzima x inahusiana.\n\nMifano:\nclassify_integer(\"24\") // inarejesha 6\nclassify_integer(\"39\") // inarejesha 3\nclassify_integer(\"123456789\") // inarejesha 9\nclassify_integer(\"123456789012345678901234567890\") // inarejesha 9\nclassify_integer(\"12345\") // inarejesha 6\nclassify_integer(\"999999999\") // inarejesha 9",
      "tr": "Tamsayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tamsayıyı bir string olarak belirtir.\n\nDöndürülen:\nint: Tamsayı x'in ait olduğu sınıf.\n\nÖrnekler:\nclassify_integer(\"24\") // 6 döndürür\nclassify_integer(\"39\") // 3 döndürür\nclassify_integer(\"123456789\") // 9 döndürür\nclassify_integer(\"123456789012345678901234567890\") // 9 döndürür\nclassify_integer(\"12345\") // 6 döndürür\nclassify_integer(\"999999999\") // 9 döndürür",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\n\nTham số:\n- x (string): Số nguyên cần phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nVí dụ:\nclassify_integer(\"24\") // trả về 6\nclassify_integer(\"39\") // trả về 3\nclassify_integer(\"123456789\") // trả về 9\nclassify_integer(\"123456789012345678901234567890\") // trả về 9\nclassify_integer(\"12345\") // trả về 6\nclassify_integer(\"999999999\") // trả về 9"
    },
    "docstring_bertscore": {
      "es": "0.9946135413270959",
      "arb": "0.9705033884163191",
      "sw": "0.967166795275695",
      "tr": "0.9852806942437906",
      "vi": "0.9781524457595916"
    }
  },
  {
    "task_id": "JavaScript/27",
    "prompt": {
      "en": "\n/**\n * Transforms the case of a given letter.\n * - letter (char): The input letter to be transformed.\n * \n * Returns:\n * - char: The letter with its case reversed. If the input is lowercase,\n * returns uppercase, and if the input is uppercase, returns lowercase.\n * \n * Example:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "es": "/**\n * Transforma el caso de una letra dada.\n * - letter (char): La letra de entrada a ser transformada.\n * \n * Devuelve:\n * - char: La letra con su caso invertido. Si la entrada es minúscula,\n * devuelve mayúscula, y si la entrada es mayúscula, devuelve minúscula.\n * \n * Ejemplo:\n * transformLetterCase('b') devuelve 'B'\n * transformLetterCase('Z') devuelve 'z'\n */\nfunction transformLetterCase(letter)",
      "arb": "/**\n * يحول حالة حرف معين.\n * - letter (char): الحرف المدخل الذي سيتم تحويله.\n * \n * يعيد:\n * - char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة،\n * يعيد بحروف كبيرة، وإذا كان المدخل بحروف كبيرة، يعيد بحروف صغيرة.\n * \n * مثال:\n * transformLetterCase('b') يعيد 'B'\n * transformLetterCase('Z') يعيد 'z'\n */\nfunction transformLetterCase(letter)",
      "sw": "/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * - letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n * \n * Inarudisha:\n * - char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo,\n * inarudisha herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarudisha herufi ndogo.\n * \n * Mfano:\n * transformLetterCase('b') inarejesha 'B'\n * transformLetterCase('Z') inarejesha 'z'\n */\nfunction transformLetterCase(letter)",
      "tr": "/**\n * Verilen bir harfin büyük/küçük harf durumunu değiştirir.\n * - letter (char): Dönüştürülecek giriş harfi.\n * \n * Döndürür:\n * - char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse,\n * büyük harf olarak döner ve eğer giriş büyük harfse, küçük harf olarak döner.\n * \n * Örnek:\n * transformLetterCase('b') 'B' döner\n * transformLetterCase('Z') 'z' döner\n */\nfunction transformLetterCase(letter)",
      "vi": "/**\n * Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n * - letter (char): Chữ cái đầu vào cần được chuyển đổi.\n * \n * Trả về:\n * - char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường,\n * trả về chữ hoa, và nếu đầu vào là chữ hoa, trả về chữ thường.\n * \n * Ví dụ:\n * transformLetterCase('b') trả về 'B'\n * transformLetterCase('Z') trả về 'z'\n */\nfunction transformLetterCase(letter)"
    },
    "prompt_bertscore": {
      "es": "0.9970972156115562",
      "arb": "0.9504230486759782",
      "sw": "0.9386218218475523",
      "tr": "0.9681307485148574",
      "vi": "0.9773475954556382"
    },
    "canonical_solution": "{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function transformLetterCase(letter)` to solve the following problem:\nTransforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n\nExample:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "es": "Escribe una función de JavaScript `function transformLetterCase(letter)` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n- letter (char): La letra de entrada a transformar.\n\nDevuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve mayúscula, y si la entrada es mayúscula, devuelve minúscula.\n\nEjemplo:\ntransformLetterCase('b') devuelve 'B'\ntransformLetterCase('Z') devuelve 'z'",
      "arb": "اكتب دالة JavaScript `function transformLetterCase(letter)` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n\nالمخرجات:\n- char: الحرف مع حالته معكوسة. إذا كان المدخل بحروف صغيرة، يعيد حروف كبيرة، وإذا كان المدخل بحروف كبيرة، يعيد حروف صغيرة.\n\nمثال:\ntransformLetterCase('b') يعيد 'B'\ntransformLetterCase('Z') يعيد 'z'",
      "sw": "Andika kazi ya JavaScript `function transformLetterCase(letter)` kutatua tatizo lifuatalo:\nHubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n- letter (char): Herufi ya kuingiza ambayo itabadilishwa.\n\nInarudisha:\n- char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarudisha herufi ndogo.\n\nMfano:\ntransformLetterCase('b') inarudisha 'B'\ntransformLetterCase('Z') inarudisha 'z'",
      "tr": "Bir JavaScript fonksiyonu `function transformLetterCase(letter)` yazın:\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n- letter (char): Dönüştürülecek giriş harfi.\n\nDöndürülen:\n- char: Harfin büyük/küçük durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf döner ve eğer giriş büyük harfse, küçük harf döner.\n\nÖrnek:\ntransformLetterCase('b') 'B' döner\ntransformLetterCase('Z') 'z' döner",
      "vi": "Viết một hàm JavaScript `function transformLetterCase(letter)` để giải quyết vấn đề sau:\nChuyển đổi chữ hoa/thường của một chữ cái cho trước.\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, trả về chữ hoa, và nếu đầu vào là chữ hoa, trả về chữ thường.\n\nVí dụ:\ntransformLetterCase('b') trả về 'B'\ntransformLetterCase('Z') trả về 'z'"
    },
    "instruction_bertscore": {
      "es": "0.9767099919325163",
      "arb": "0.9783268432341402",
      "sw": "0.9273664313062103",
      "tr": "0.950137616818431",
      "vi": "0.9353702425100112"
    },
    "level": "hard",
    "test": "const testTransformLetterCase = () => {\n    console.assert(transformLetterCase('b') === 'B');\n    console.assert(transformLetterCase('B') === 'b');\n    // Additional test cases\n    console.assert(transformLetterCase('z') === 'Z');\n    console.assert(transformLetterCase('Z') === 'z');\n    console.assert(transformLetterCase('m') === 'M');\n    console.assert(transformLetterCase('M') === 'm');\n    console.assert(transformLetterCase('1') === '1'); // Non-alphabetic, should be unchanged\n    console.assert(transformLetterCase('!') === '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to log a message for passed tests\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestTransformLetterCase();",
    "entry_point": "transformLetterCase",
    "signature": "function transformLetterCase(letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n\nExample:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "es": "Transforma el caso de una letra dada.\n- letter (char): La letra de entrada a ser transformada.\n\nDevuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve mayúscula, y si la entrada es mayúscula, devuelve minúscula.\n\nEjemplo:\ntransformLetterCase('b') devuelve 'B'\ntransformLetterCase('Z') devuelve 'z'",
      "arb": "يحول حالة حرف معين.\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n\nReturns:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، يعيد بحروف كبيرة، وإذا كان المدخل بحروف كبيرة، يعيد بحروف صغيرة.\n\nمثال :\ntransformLetterCase('b') يعيد 'B'\ntransformLetterCase('Z') يعيد 'z'",
      "sw": "Hurekebisha herufi ya herufi iliyotolewa.\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n\nInarejesha:\n- char: Herufi ikiwa na herufi zake zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarejesha herufi ndogo.\n\nMfano:\ntransformLetterCase('b') inarejesha 'B'\ntransformLetterCase('Z') inarejesha 'z'",
      "tr": "Verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n- letter (char): Dönüştürülecek giriş harfi.\n\nDöndürür:\n- char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf döndürür ve eğer giriş büyük harfse, küçük harf döndürür.\n\nÖrnek:\ntransformLetterCase('b') 'B' döndürür\ntransformLetterCase('Z') 'z' döndürür",
      "vi": "Chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, trả về chữ hoa, và nếu đầu vào là chữ hoa, trả về chữ thường.\n\nVí dụ:\ntransformLetterCase('b') trả về 'B'\ntransformLetterCase('Z') trả về 'z'"
    },
    "docstring_bertscore": {
      "es": "0.9798700026644003",
      "arb": "0.9512986113955799",
      "sw": "0.9366545865537828",
      "tr": "0.9760056486013665",
      "vi": "0.9629228585545037"
    }
  },
  {
    "task_id": "JavaScript/28",
    "prompt": {
      "en": "\n/**\n * Display the ASCII information for a given character.\n *\n * @param {char} character - The input character for which ASCII information is to be displayed.\n * @returns {number} - The corresponding ASCII code.\n * \n * Examples:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "es": "/**\n * Muestra la información ASCII para un carácter dado.\n *\n * @param {char} character - El carácter de entrada para el cual se mostrará la información ASCII.\n * @returns {number} - El código ASCII correspondiente.\n * \n * Ejemplos:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "arb": "/**\n * عرض معلومات ASCII للحرف المعطى.\n *\n * @param {char} character - الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n * @returns {number} - الكود ASCII المقابل.\n * \n * أمثلة:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "sw": "/**\n * Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n *\n * @param {char} character - Herufi ya ingizo ambayo taarifa za ASCII zitaonyeshwa.\n * @returns {number} - Nambari ya ASCII inayolingana.\n * \n * Mifano:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "tr": "/**\n * Belirtilen bir karakter için ASCII bilgisini göster.\n *\n * @param {char} character - ASCII bilgisinin gösterileceği giriş karakteri.\n * @returns {number} - Karşılık gelen ASCII kodu.\n * \n * Örnekler:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "vi": "/**\n * Hiển thị thông tin ASCII cho một ký tự được cung cấp.\n *\n * @param {char} character - Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n * @returns {number} - Mã ASCII tương ứng.\n * \n * Ví dụ:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)"
    },
    "prompt_bertscore": {
      "es": "0.9841067886918744",
      "arb": "0.9843280629363473",
      "sw": "0.9617737818002168",
      "tr": "0.9653519094841793",
      "vi": "0.9843409739111146"
    },
    "canonical_solution": "{\n    return character.charCodeAt(0);\n}",
    "instruction": {
      "en": "Write a JavaScript function `function display_ascii_info(character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\ndisplay_ascii_info('A');\n// => 65\n",
      "es": "Escribe una función de JavaScript `function display_ascii_info(character)` para resolver el siguiente problema:\nMuestra la información ASCII para un carácter dado.\n\nParámetros:\n@param {char} character - El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n@returns {number} - El código ASCII correspondiente.\n\nEjemplos:\ndisplay_ascii_info('A');\n// => 65",
      "arb": "اكتب دالة JavaScript `function display_ascii_info(character)` لحل المشكلة التالية:\nعرض معلومات ASCII للحرف المعطى.\n\nالمعطيات:\n@param {char} character - الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n@returns {number} - الكود ASCII المقابل.\n\nأمثلة:\ndisplay_ascii_info('A');\n// => 65",
      "sw": "Andika kazi ya JavaScript `function display_ascii_info(character)` kutatua tatizo lifuatalo:\nOnyesha taarifa za ASCII kwa herufi iliyopewa.\n\nVigezo:\n@param {char} character - Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarejesha:\n@returns {number} - Nambari ya ASCII inayolingana.\n\nMifano:\ndisplay_ascii_info('A');\n// => 65",
      "tr": "Bir JavaScript fonksiyonu `function display_ascii_info(character)` yazın:\nVerilen bir karakter için ASCII bilgisini görüntüleyin.\n\nParametreler:\n@param {char} character - ASCII bilgisinin görüntüleneceği giriş karakteri.\n\nDöndürülenler:\n@returns {number} - Karşılık gelen ASCII kodu.\n\nÖrnekler:\ndisplay_ascii_info('A');\n// => 65",
      "vi": "Viết một hàm JavaScript `function display_ascii_info(character)` để giải quyết vấn đề sau:  \nHiển thị thông tin ASCII cho một ký tự cho trước.\n\nTham số:  \n@param {char} character - Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:  \n@returns {number} - Mã ASCII tương ứng.\n\nVí dụ:  \ndisplay_ascii_info('A');  \n// => 65"
    },
    "instruction_bertscore": {
      "es": "0.9859081676174799",
      "arb": "0.9841691586315194",
      "sw": "0.9635892634828757",
      "tr": "0.9643861685715877",
      "vi": "0.9866879904934228"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(display_ascii_info('A') === 65, \"'A' should return 65\");\n    console.assert(display_ascii_info('B') === 66, \"'B' should return 66\"); // Additional test case\n    console.assert(display_ascii_info('0') === 48, \"'0' should return 48\"); // Additional test case\n    console.assert(display_ascii_info(' ') === 32, \"' ' should return 32\"); // Additional test case\n    // console.log(\"All tests passed.\");\n})();",
    "entry_point": "display_ascii_info",
    "signature": "function display_ascii_info(character)",
    "docstring": {
      "en": "Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\ndisplay_ascii_info('A');\n// => 65\n",
      "es": "Mostrar la información ASCII para un carácter dado.\n\nParámetros:\n@param {char} character - El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n@returns {number} - El código ASCII correspondiente.\n\nEjemplos:\ndisplay_ascii_info('A');\n// => 65",
      "arb": "عرض معلومات ASCII للحرف المعطى.\n\nالمعلمات:\n@param {char} character - الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n@returns {number} - رمز ASCII المقابل.\n\nأمثلة:\ndisplay_ascii_info('A');\n// => 65",
      "sw": "Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n\nVigezo:\n@param {char} character - Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarejesha:\n@returns {number} - Nambari ya ASCII inayolingana.\n\nMifano:\ndisplay_ascii_info('A');\n// => 65",
      "tr": "Verilen bir karakter için ASCII bilgisini görüntüleyin.\n\nParametreler:\n@param {char} character - ASCII bilgisinin gösterileceği giriş karakteri.\n\nDönüş:\n@returns {number} - Karşılık gelen ASCII kodu.\n\nÖrnekler:\ndisplay_ascii_info('A');\n// => 65",
      "vi": "Hiển thị thông tin ASCII cho một ký tự cho trước.\n\nTham số:\n@param {char} character - Ký tự đầu vào mà thông tin ASCII sẽ được hiển thị.\n\nTrả về:\n@returns {number} - Mã ASCII tương ứng.\n\nVí dụ:\ndisplay_ascii_info('A');\n// => 65"
    },
    "docstring_bertscore": {
      "es": "0.9829100406461393",
      "arb": "0.9727224870332408",
      "sw": "0.9515812624277925",
      "tr": "0.9569967211363277",
      "vi": "0.9817379227676524"
    }
  },
  {
    "task_id": "JavaScript/29",
    "prompt": {
      "en": "\n/**\n * Evaluate the grade for an input integer.\n * \n * Parameters:\n * - score (int): The integer score to be evaluated.\n * \n * Returns:\n * ​​    char: The grade corresponding to the input score.\n * ​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n * ​​         Otherwise, returns 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "es": "/**\n * Evaluar la calificación para un entero de entrada.\n * \n * Parámetros:\n * - score (int): La puntuación entera a evaluar.\n * \n * Devuelve:\n * ​​    char: La calificación correspondiente a la puntuación de entrada.\n * ​​         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n * ​​         De lo contrario, devuelve 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // devuelve 'A'\n */\nfunction evaluate_integer_grade(score)",
      "arb": "/**\n * تقييم الدرجة لعدد صحيح مدخل.\n * \n * المعلمات:\n * - score (int): الدرجة الصحيحة التي سيتم تقييمها.\n * \n * يعيد:\n * ​​    char: الدرجة المقابلة للدرجة المدخلة.\n * ​​         إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n * ​​         خلاف ذلك، يعيد 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // يعيد 'A'\n */\nfunction evaluate_integer_grade(score)",
      "sw": "/**\n * Tambua alama kwa nambari kamili iliyoingizwa.\n * \n * Vigezo:\n * - score (int): Alama ya nambari kamili inayopaswa kutambuliwa.\n * \n * Inarudisha:\n * ​​    char: Alama inayolingana na alama iliyoingizwa.\n * ​​         Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n * ​​         Vinginevyo, inarudisha 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // inarejesha 'A'\n */\nfunction evaluate_integer_grade(score)",
      "tr": "/**\n * Bir tamsayı için notu değerlendir.\n * \n * Parametreler:\n * - score (int): Değerlendirilecek tamsayı puanı.\n * \n * Döndürür:\n * ​​    char: Girdi puanına karşılık gelen not.\n * ​​         Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n * ​​         Aksi takdirde, 'B' döndürür.\n * \n * @example\n * evaluate_integer_grade(90) // 'A' döndürür\n */\nfunction evaluate_integer_grade(score)",
      "vi": "/**\n * Đánh giá điểm cho một số nguyên đầu vào.\n * \n * Tham số:\n * - score (int): Điểm số nguyên cần được đánh giá.\n * \n * Trả về:\n * ​​    char: Điểm tương ứng với điểm số đầu vào.\n * ​​         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm), trả về 'A'.\n * ​​         Ngược lại, trả về 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // trả về 'A'\n */\nfunction evaluate_integer_grade(score)"
    },
    "prompt_bertscore": {
      "es": "0.9951337542950263",
      "arb": "0.9608970272983288",
      "sw": "0.9706710324579125",
      "tr": "0.9598530260156094",
      "vi": "0.995337350435587"
    },
    "canonical_solution": "{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}",
    "instruction": {
      "en": "Write a JavaScript function `function evaluate_integer_grade(score)` to solve the following problem:\nEvaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\n@example\nevaluate_integer_grade(90) // returns 'A'\n",
      "es": "Escribe una función de JavaScript `function evaluate_integer_grade(score)` para resolver el siguiente problema:\nEvalúa la calificación para un entero de entrada.\n\nParámetros:\n- score (int): La puntuación entera a evaluar.\n\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n\n@example\nevaluate_integer_grade(90) // devuelve 'A'",
      "arb": "اكتب دالة JavaScript `function evaluate_integer_grade(score)` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n\nالمعطيات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n\nالقيم المعادة:\n    char: الدرجة المقابلة للدرجة المدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n    خلاف ذلك، تعيد 'B'.\n\n@example\nevaluate_integer_grade(90) // يعيد 'A'",
      "sw": "Andika kazi ya JavaScript `function evaluate_integer_grade(score)` kutatua tatizo lifuatalo:  \nTambua alama kwa namba kamili iliyoingizwa.\n\nVigezo:\n- score (int): Alama ya namba kamili inayopaswa kutathminiwa.\n\nInarudisha:\n    char: Alama inayolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n\n@example\nevaluate_integer_grade(90) // inarejesha 'A'",
      "tr": "Bir JavaScript fonksiyonu `function evaluate_integer_grade(score)` yazın:\nBir tamsayı notunu değerlendirin.\n\nParametreler:\n- score (int): Değerlendirilecek tamsayı puanı.\n\nDöndürür:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n    Aksi takdirde, 'B' döndürür.\n\n@example\nevaluate_integer_grade(90) // 'A' döndürür",
      "vi": "Viết một hàm JavaScript `function evaluate_integer_grade(score)` để giải quyết vấn đề sau:  \nĐánh giá điểm cho một số nguyên đầu vào.\n\nTham số:  \n- score (int): Điểm số nguyên cần được đánh giá.\n\nTrả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n    Ngược lại, trả về 'B'.\n\n@example  \nevaluate_integer_grade(90) // trả về 'A'"
    },
    "instruction_bertscore": {
      "es": "0.9913365373007823",
      "arb": "0.9747546744616088",
      "sw": "0.9636248183210809",
      "tr": "0.9625702896281667",
      "vi": "0.965703485258611"
    },
    "level": "easy",
    "test": "function testEvaluateIntegerGrade() {\n    console.assert(evaluate_integer_grade(90) === 'A', 'Score of 90 should yield an A');\n    console.assert(evaluate_integer_grade(89) === 'B', 'Score of 89 should yield a B');\n    console.assert(evaluate_integer_grade(95) === 'A', 'Score of 95 should yield an A');\n    console.assert(evaluate_integer_grade(100) === 'A', 'Score of 100 should yield an A');\n    console.assert(evaluate_integer_grade(101) === 'B', 'Score of 101 should yield a B');\n\n    // console.log(\"All tests passed!\");\n}\n\ntestEvaluateIntegerGrade();",
    "entry_point": "evaluate_integer_grade",
    "signature": "function evaluate_integer_grade(score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\n@example\nevaluate_integer_grade(90) // returns 'A'\n",
      "es": "Evaluar la calificación para un entero de entrada.\n\nParámetros:\n- score (int): La puntuación entera a evaluar.\n\nDevuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n\n@example\nevaluate_integer_grade(90) // devuelve 'A'",
      "arb": "تقييم الدرجة لعدد صحيح مُدخل.\n\nالمعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n\nالعوائد:\n    char: الدرجة المقابلة للدرجة المُدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، تُرجع 'A'.\n    خلاف ذلك، تُرجع 'B'.\n\n@example\nevaluate_integer_grade(90) // يعيد 'A'",
      "sw": "Tambua daraja kwa namba kamili iliyoingizwa.\n\nVigezo:\n- score (int): Alama ya namba kamili inayopaswa kutathminiwa.\n\nRudisha:\n    char: Daraja linalolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n\n@mfano\nevaluate_integer_grade(90) // inarudisha 'A'",
      "tr": "Girdi tam sayısı için notu değerlendirin.\n\nParametreler:\n- score (int): Değerlendirilecek tam sayı puanı.\n\nDöndürülenler:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n    Aksi takdirde, 'B' döner.\n\n@example\nevaluate_integer_grade(90) // 'A' döner",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n\nTham số:\n- score (int): Điểm số nguyên cần được đánh giá.\n\nTrả về:\n    char: Điểm tương ứng với điểm số đầu vào.\n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n    Ngược lại, trả về 'B'.\n\n@example\nevaluate_integer_grade(90) // trả về 'A'"
    },
    "docstring_bertscore": {
      "es": "0.9888032054210634",
      "arb": "0.9909710573996782",
      "sw": "0.9632527836174026",
      "tr": "0.9941515270608088",
      "vi": "0.9577918385516104"
    }
  },
  {
    "task_id": "JavaScript/30",
    "prompt": {
      "en": "// Note: No import statement is required in JavaScript for this function\n/**\n * Checks if a string with exactly three characters has two characters that are the same.\n * \n * @param {string} str - The three-character string to be checked.\n * @return {string} - Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n * \n * Examples:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "es": "// Nota: No se requiere una declaración de importación en JavaScript para esta función\n/**\n * Verifica si una cadena con exactamente tres caracteres tiene dos caracteres que son iguales.\n * \n * @param {string} str - La cadena de tres caracteres a verificar.\n * @return {string} - Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n * \n * Ejemplos:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "arb": "// ملاحظة: لا حاجة لجملة استيراد في JavaScript لهذه الدالة\n/**\n * يتحقق مما إذا كانت سلسلة تحتوي على ثلاثة أحرف بالضبط لديها حرفان متماثلان.\n * \n * @param {string} str - السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n * @return {string} - يعيد 'Yes' إذا كان المدخل يحتوي على حرفين متساويين بالضبط، وإلا 'No'.\n * \n * أمثلة:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "sw": "// Kumbuka: Hakuna tamko la kuingiza linalohitajika katika JavaScript kwa kazi hii\n/**\n * Hukagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n * \n * @param {string} str - Kamba ya herufi tatu inayopaswa kukaguliwa.\n * @return {string} - Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n * \n * Mifano:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "tr": "```javascript\n// Not: Bu fonksiyon için JavaScript'te herhangi bir import ifadesi gerekli değildir.\n/**\n * Üç karakterden oluşan bir dizgede iki karakterin aynı olup olmadığını kontrol eder.\n * \n * @param {string} str - Kontrol edilecek üç karakterli dizge.\n * @return {string} - Girdi tam olarak iki eşit karaktere sahipse 'Yes', aksi takdirde 'No' döner.\n * \n * Örnekler:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)\n```",
      "vi": "// Lưu ý: Không cần câu lệnh import trong JavaScript cho hàm này\n/**\n * Kiểm tra xem một chuỗi có đúng ba ký tự có hai ký tự giống nhau hay không.\n * \n * @param {string} str - Chuỗi ba ký tự cần được kiểm tra.\n * @return {string} - Trả về 'Yes' nếu đầu vào có đúng hai ký tự bằng nhau, ngược lại trả về 'No'.\n * \n * Ví dụ:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)"
    },
    "prompt_bertscore": {
      "es": "0.987867060435246",
      "arb": "0.976799375603982",
      "sw": "0.9547162457316662",
      "tr": "0.9535759087141449",
      "vi": "0.9732224397023057"
    },
    "canonical_solution": "{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function checkTwoEqualDigits(str)` to solve the following problem:\nChecks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "es": "Escribe una función de JavaScript `function checkTwoEqualDigits(str)` para resolver el siguiente problema:\nVerifica si una cadena con exactamente tres caracteres tiene dos caracteres que son iguales.\n\nParámetros:\n- str (string): La cadena de tres caracteres que se va a verificar.\n\nDevuelve:\n- string: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\nEjemplos:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "arb": "اكتب دالة جافا سكريبت `function checkTwoEqualDigits(str)` لحل المشكلة التالية:\nالتحقق مما إذا كانت سلسلة تحتوي على ثلاثة أحرف بالضبط تحتوي على حرفين متشابهين.\n\nالمعلمات:\n- str (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n- string: تعيد 'Yes' إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا تعيد 'No'.\n\nأمثلة:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "sw": "Andika kazi ya JavaScript `function checkTwoEqualDigits(str)` kutatua tatizo lifuatalo:\nInakagua kama kamba yenye herufi tatu tu ina herufi mbili ambazo ni sawa.\n\nVigezo:\n- str (string): Kamba ya herufi tatu itakayokaguliwa.\n\nInarudisha:\n- string: Inarudisha 'Yes' ikiwa kipengele kina herufi mbili sawa, vinginevyo 'No'.\n\nMifano:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "tr": "Bir JavaScript fonksiyonu `function checkTwoEqualDigits(str)` yazın:\nTam olarak üç karakter içeren bir dizgede iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n- str (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n- string: Girdi tam olarak iki eşit karaktere sahipse 'Yes', aksi takdirde 'No' döndürür.\n\nÖrnekler:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "vi": "Viết một hàm JavaScript `function checkTwoEqualDigits(str)` để giải quyết vấn đề sau:  \nKiểm tra xem một chuỗi có đúng ba ký tự có hai ký tự giống nhau hay không.\n\nTham số:\n- str (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n- string: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại 'No'.\n\nVí dụ:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'"
    },
    "instruction_bertscore": {
      "es": "0.9932370327865241",
      "arb": "0.9727542678942065",
      "sw": "0.9716894104214784",
      "tr": "0.95287633251214",
      "vi": "0.9749145719183419"
    },
    "level": "easy",
    "test": "const testCheckTwoEqualDigits = () => {\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\");\n\n    // Additional test cases to cover more scenarios\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\n    \n    // console.log(\"All tests passed successfully.\");\n};\n\ntestCheckTwoEqualDigits();",
    "entry_point": "checkTwoEqualDigits",
    "signature": "function checkTwoEqualDigits(str)",
    "docstring": {
      "en": "Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "es": "Verifica si una cadena con exactamente tres caracteres tiene dos caracteres que son iguales.\n\nParámetros:\n- str (string): La cadena de tres caracteres que se va a verificar.\n\nDevuelve:\n- string: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\nEjemplos:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "arb": "يتحقق مما إذا كانت سلسلة تحتوي على ثلاثة أحرف بالضبط تحتوي على حرفين متشابهين.\n\nالمعلمات:\n- str (string): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n- string: يعيد 'Yes' إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n\nأمثلة:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "sw": "Hukagua kama kamba yenye herufi tatu ina herufi mbili zinazofanana.\n\nVigezo:\n- str (string): Kamba ya herufi tatu itakayokaguliwa.\n\nInarejesha:\n- string: Inarejesha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n\nMifano:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "tr": "Üç karakterden oluşan bir dizgede iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n- str (string): Kontrol edilecek üç karakterli dizge.\n\nDöndürülenler:\n- string: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döner, aksi takdirde 'No'.\n\nÖrnekler:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "vi": "Kiểm tra xem một chuỗi có đúng ba ký tự có hai ký tự giống nhau hay không.\n\nTham số:\n- str (string): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n- string: Trả về 'Yes' nếu đầu vào có đúng hai ký tự bằng nhau, ngược lại trả về 'No'.\n\nVí dụ:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'"
    },
    "docstring_bertscore": {
      "es": "0.9879294303748909",
      "arb": "0.9663772395110813",
      "sw": "0.955711383940651",
      "tr": "0.9594939022866984",
      "vi": "0.9615292678011629"
    }
  },
  {
    "task_id": "JavaScript/31",
    "prompt": {
      "en": "\n/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)",
      "es": "/**\n * Dada una cadena que consiste en letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro\n * en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena\n * esté compuesta por el mismo carácter.\n * @param {string} s - La cadena de entrada.\n * @returns {number} El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n *\n * Ejemplos:\n * minRoundsToSameChar(\"aab\") // devuelve 1\n * minRoundsToSameChar(\"abc\") // devuelve 2\n * minRoundsToSameChar(\"aaa\") // devuelve 0\n */\nfunction minRoundsToSameChar(s)",
      "arb": "/**\n * بالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر\n * في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة\n * تتكون من نفس الحرف.\n * @param {string} s - السلسلة المدخلة.\n * @returns {number} الحد الأدنى لعدد الجولات لجعل جميع الحروف في السلسلة متشابهة.\n *\n * أمثلة:\n * minRoundsToSameChar(\"aab\") // يعيد 1\n * minRoundsToSameChar(\"abc\") // يعيد 2\n * minRoundsToSameChar(\"aaa\") // يعيد 0\n */\nfunction minRoundsToSameChar(s)",
      "sw": "/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine\n * katika kila raundi. Kazi hii inahesabu idadi ndogo zaidi ya raundi zinazohitajika kufanya kamba\n * iwe na herufi sawa.\n * @param {string} s - Kamba ya ingizo.\n * @returns {number} Idadi ndogo zaidi ya raundi za kufanya herufi zote katika kamba ziwe sawa.\n *\n * Mifano:\n * minRoundsToSameChar(\"aab\") // inarudisha 1\n * minRoundsToSameChar(\"abc\") // inarudisha 2\n * minRoundsToSameChar(\"aaa\") // inarudisha 0\n */\nfunction minRoundsToSameChar(s)",
      "tr": "/**\n * Küçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karaktere değiştirebilirsiniz.\n * Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n * @param {string} s - Girdi dizisi.\n * @returns {number} Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n *\n * Örnekler:\n * minRoundsToSameChar(\"aab\") // 1 döndürür\n * minRoundsToSameChar(\"abc\") // 2 döndürür\n * minRoundsToSameChar(\"aaa\") // 0 döndürür\n */\nfunction minRoundsToSameChar(s)",
      "vi": "/**\n * Cho một chuỗi gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác\n * trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi\n * được tạo thành từ cùng một ký tự.\n * @param {string} s - Chuỗi đầu vào.\n * @returns {number} Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n *\n * Ví dụ:\n * minRoundsToSameChar(\"aab\") // trả về 1\n * minRoundsToSameChar(\"abc\") // trả về 2\n * minRoundsToSameChar(\"aaa\") // trả về 0\n */\nfunction minRoundsToSameChar(s)"
    },
    "prompt_bertscore": {
      "es": "0.9876503546895369",
      "arb": "0.9954271313678148",
      "sw": "0.9701053331327252",
      "tr": "0.9811515658828374",
      "vi": "0.98429211083738"
    },
    "canonical_solution": "{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function minRoundsToSameChar(s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1\nminRoundsToSameChar(\"abc\") // returns 2\nminRoundsToSameChar(\"aaa\") // returns 0",
      "es": "Escribe una función de JavaScript `function minRoundsToSameChar(s)` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter.\n@param {string} s - La cadena de entrada.\n@returns {number} El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n\nEjemplos:\nminRoundsToSameChar(\"aab\") // devuelve 1\nminRoundsToSameChar(\"abc\") // devuelve 2\nminRoundsToSameChar(\"aaa\") // devuelve 0",
      "arb": "اكتب دالة JavaScript `function minRoundsToSameChar(s)` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف.\n@param {string} s - سلسلة الإدخال.\n@returns {number} الحد الأدنى لعدد الجولات لجعل جميع الأحرف في السلسلة متشابهة.\n\nأمثلة:\nminRoundsToSameChar(\"aab\") // يعيد 1\nminRoundsToSameChar(\"abc\") // يعيد 2\nminRoundsToSameChar(\"aaa\") // يعيد 0",
      "sw": "Andika kazi ya JavaScript `function minRoundsToSameChar(s)` kutatua tatizo lifuatalo:  \nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine katika kila raundi. Kazi hii inahesabu idadi ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa.  \n@param {string} s - Kamba ya ingizo.  \n@returns {number} Idadi ndogo ya raundi za kufanya herufi zote kwenye kamba ziwe sawa.  \n\nMifano:  \nminRoundsToSameChar(\"aab\") // inarudisha 1  \nminRoundsToSameChar(\"abc\") // inarudisha 2  \nminRoundsToSameChar(\"aaa\") // inarudisha 0  ",
      "tr": "Bir JavaScript fonksiyonu `function minRoundsToSameChar(s)` yazın ve aşağıdaki problemi çözün:\nKüçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karakterle değiştirebilirsiniz. Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n@param {string} s - Girdi dizisi.\n@returns {number} Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n\nÖrnekler:\nminRoundsToSameChar(\"aab\") // 1 döndürür\nminRoundsToSameChar(\"abc\") // 2 döndürür\nminRoundsToSameChar(\"aaa\") // 0 döndürür",
      "vi": "Viết một hàm JavaScript `function minRoundsToSameChar(s)` để giải quyết vấn đề sau:\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự.\n@param {string} s - Chuỗi đầu vào.\n@returns {number} Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n\nVí dụ:\nminRoundsToSameChar(\"aab\") // trả về 1\nminRoundsToSameChar(\"abc\") // trả về 2\nminRoundsToSameChar(\"aaa\") // trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.9887050820128321",
      "arb": "0.9920484285864114",
      "sw": "0.9774399585828195",
      "tr": "0.981656285681047",
      "vi": "0.9846176660318962"
    },
    "level": "middle",
    "test": "const testMinRoundsToSameChar = () => {\n    console.assert(minRoundsToSameChar(\"aab\") === 1, \"Expected 1 round for 'aab'\");\n    console.assert(minRoundsToSameChar(\"abc\") === 2, \"Expected 2 rounds for 'abc'\");\n    console.assert(minRoundsToSameChar(\"aaa\") === 0, \"Expected 0 rounds for 'aaa'\");\n    console.assert(minRoundsToSameChar(\"abab\") === 1, \"Expected 1 round for 'abab'\");\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0, \"Expected 0 rounds for 'zzzzz'\");\n};\n\ntestMinRoundsToSameChar();",
    "entry_point": "minRoundsToSameChar",
    "signature": "function minRoundsToSameChar(s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1\nminRoundsToSameChar(\"abc\") // returns 2\nminRoundsToSameChar(\"aaa\") // returns 0",
      "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter.\n@param {string} s - La cadena de entrada.\n@returns {number} El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n\nEjemplos:\nminRoundsToSameChar(\"aab\") // devuelve 1\nminRoundsToSameChar(\"abc\") // devuelve 2\nminRoundsToSameChar(\"aaa\") // devuelve 0",
      "arb": "نظرًا لسلسلة تتكون من حروف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف.\n@param {string} s - السلسلة المدخلة.\n@returns {number} الحد الأدنى لعدد الجولات لجعل جميع الحروف في السلسلة متشابهة.\n\nأمثلة:\nminRoundsToSameChar(\"aab\") // يعيد 1\nminRoundsToSameChar(\"abc\") // يعيد 2\nminRoundsToSameChar(\"aaa\") // يعيد 0",
      "sw": "Ukipiwa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine katika kila raundi. Kazi hii inahesabu idadi ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa. \n\n@param {string} s - Uzi wa ingizo.\n\n@returns {number} Idadi ndogo ya raundi za kufanya herufi zote kwenye uzi kuwa sawa.\n\nMifano:\nminRoundsToSameChar(\"aab\") // inarudisha 1\nminRoundsToSameChar(\"abc\") // inarudisha 2\nminRoundsToSameChar(\"aaa\") // inarudisha 0",
      "tr": "Küçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karakterle değiştirebilirsiniz. Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n@param {string} s - Girdi stringi.\n@returns {number} Stringdeki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n\nÖrnekler:\nminRoundsToSameChar(\"aab\") // 1 döndürür\nminRoundsToSameChar(\"abc\") // 2 döndürür\nminRoundsToSameChar(\"aaa\") // 0 döndürür",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự.\n\n@param {string} s - Chuỗi đầu vào.\n\n@returns {number} Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n\nVí dụ:\nminRoundsToSameChar(\"aab\") // trả về 1\nminRoundsToSameChar(\"abc\") // trả về 2\nminRoundsToSameChar(\"aaa\") // trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9844069191976181",
      "arb": "0.9827964240681873",
      "sw": "0.9876582999047783",
      "tr": "0.9884071364412798",
      "vi": "0.9865435862064105"
    }
  },
  {
    "task_id": "JavaScript/32",
    "prompt": {
      "en": "\n/**\n * Calculates the year Y_n when the n-th event occurs, considering that each\n * event has a periodicity of a_i years. The countdown for event i+1 starts\n * the year after event i occurs.\n * @param {number} n - the total number of events\n * @param {number[]} signs - an array representing the periodicities of the events\n * @returns {number} The year when the n-th event occurs\n * \n * Example:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction apocalypseYear(n, signs)",
      "es": "/**\n * Calcula el año Y_n cuando ocurre el evento n-ésimo, considerando que cada\n * evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza\n * el año después de que ocurre el evento i.\n * @param {number} n - el número total de eventos\n * @param {number[]} signs - un arreglo que representa las periodicidades de los eventos\n * @returns {number} El año en que ocurre el evento n-ésimo\n * \n * Ejemplo:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // devuelve 36\n */\nfunction apocalypseYear(n, signs)",
      "arb": "/**\n * يحسب السنة Y_n عندما يحدث الحدث رقم n، مع الأخذ في الاعتبار أن كل\n * حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1\n * في السنة التي تلي حدوث الحدث i.\n * @param {number} n - العدد الإجمالي للأحداث\n * @param {number[]} signs - مصفوفة تمثل دوريات الأحداث\n * @returns {number} السنة التي يحدث فيها الحدث رقم n\n * \n * مثال:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // يعيد 36\n */\nfunction apocalypseYear(n, signs)",
      "sw": "/**\n * Inahesabu mwaka Y_n wakati tukio la n linapotokea, ikizingatia kwamba kila\n * tukio lina kipindi cha miaka a_i. Hesabu ya nyuma kwa tukio i+1 huanza\n * mwaka baada ya tukio i kutokea.\n * @param {number} n - jumla ya idadi ya matukio\n * @param {number[]} signs - safu inayowakilisha vipindi vya matukio\n * @returns {number} Mwaka ambapo tukio la n linatokea\n * \n * Mfano:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // inarudisha 36\n */\nfunction apocalypseYear(n, signs)",
      "tr": "/**\n * Her bir olayın a_i yıl periyoduna sahip olduğunu göz önünde bulundurarak, n-inci olayın gerçekleştiği Y_n yılını hesaplar. \n * i+1 olayının geri sayımı, i olayı gerçekleştiği yılın ardından başlar.\n * @param {number} n - toplam olay sayısı\n * @param {number[]} signs - olayların periyotlarını temsil eden bir dizi\n * @returns {number} n-inci olayın gerçekleştiği yıl\n * \n * Örnek:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // 36 döndürür\n */\nfunction apocalypseYear(n, signs)",
      "vi": "/**\n * Tính toán năm Y_n khi sự kiện thứ n xảy ra, với giả định rằng mỗi\n * sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu\n * vào năm sau khi sự kiện i xảy ra.\n * @param {number} n - tổng số sự kiện\n * @param {number[]} signs - một mảng đại diện cho chu kỳ của các sự kiện\n * @returns {number} Năm khi sự kiện thứ n xảy ra\n * \n * Ví dụ:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // trả về 36\n */\nfunction apocalypseYear(n, signs)"
    },
    "prompt_bertscore": {
      "es": "0.9947712538496376",
      "arb": "0.948737074001754",
      "sw": "0.948384107814655",
      "tr": "0.9574146394580252",
      "vi": "0.9525730239202997"
    },
    "canonical_solution": "{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function apocalypseYear(n, signs)` to solve the following problem:\nCalculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18])\n// returns 36",
      "es": "Escribe una función de JavaScript `function apocalypseYear(n, signs)` para resolver el siguiente problema:\nCalcula el año Y_n cuando ocurre el n-ésimo evento, considerando que cada evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza el año después de que ocurre el evento i.\nParámetros:\n- n (number): El número total de eventos\n- signs (number[]): Un arreglo que representa las periodicidades de los eventos\nDevuelve:\n- number: El año en que ocurre el n-ésimo evento\n\nEjemplo:\napocalypseYear(6, [3,2,4,5,9,18])\n// devuelve 36",
      "arb": "اكتب دالة JavaScript `function apocalypseYear(n, signs)` لحل المشكلة التالية:\nتحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن لكل حدث دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1 في السنة التي تلي حدوث الحدث i.\nالمعطيات:\n- n (رقم): العدد الإجمالي للأحداث\n- signs (عدد[]): مصفوفة تمثل دوريات الأحداث\nالإرجاع:\n- رقم: السنة التي يحدث فيها الحدث n\n\nمثال:\napocalypseYear(6, [3,2,4,5,9,18])\n// يعيد 36",
      "sw": "Andika kazi ya JavaScript `function apocalypseYear(n, signs)` kutatua tatizo lifuatalo:\nHesabu mwaka Y_n wakati tukio la n linatokea, ukizingatia kwamba kila tukio lina kipindi cha miaka a_i. Muda wa kuhesabu kwa tukio la i+1 huanza mwaka baada ya tukio la i kutokea.\nVigezo:\n- n (nambari): Jumla ya matukio\n- signs (nambari[]): Orodha inayowakilisha vipindi vya matukio\nInarudisha:\n- nambari: Mwaka ambapo tukio la n linatokea\n\nMfano:\napocalypseYear(6, [3,2,4,5,9,18])\n// inarudisha 36",
      "tr": "Bir JavaScript fonksiyonu `function apocalypseYear(n, signs)` yazın, aşağıdaki problemi çözmek için:\nHer olayın a_i yıllık bir periyodiklikle gerçekleştiğini göz önünde bulundurarak, n-inci olayın gerçekleştiği Y_n yılını hesaplar. i+1 olayının geri sayımı, i olayı gerçekleştikten sonraki yıl başlar.\nParametreler:\n- n (number): Toplam olay sayısı\n- signs (number[]): Olayların periyodikliklerini temsil eden bir dizi\nDöndürür:\n- number: n-inci olayın gerçekleştiği yıl\n\nÖrnek:\napocalypseYear(6, [3,2,4,5,9,18])\n// 36 döndürür",
      "vi": "Viết một hàm JavaScript `function apocalypseYear(n, signs)` để giải quyết vấn đề sau:\nTính toán năm Y_n khi sự kiện thứ n xảy ra, với điều kiện mỗi sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu vào năm sau khi sự kiện i xảy ra.\nTham số:\n- n (number): Tổng số sự kiện\n- signs (number[]): Một mảng đại diện cho chu kỳ của các sự kiện\nTrả về:\n- number: Năm khi sự kiện thứ n xảy ra\n\nVí dụ:\napocalypseYear(6, [3,2,4,5,9,18])\n// trả về 36"
    },
    "instruction_bertscore": {
      "es": "0.9937759170102718",
      "arb": "0.9563853368235024",
      "sw": "0.9630885162922868",
      "tr": "0.9576120780567738",
      "vi": "0.963221002756437"
    },
    "level": "easy",
    "test": "const testApocalypseYear = () => {\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36);\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5);\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5);\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012);\n    console.assert(apocalypseYear(2, [1, 2]) === 2);\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6);\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13);\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10);\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15);\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14);\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800);\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6);\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998);\n};\n\ntestApocalypseYear();",
    "entry_point": "apocalypseYear",
    "signature": "function apocalypseYear(n, signs)",
    "docstring": {
      "en": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18])\n// returns 36",
      "es": "Calcula el año Y_n cuando ocurre el evento n-ésimo, considerando que cada evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza el año después de que ocurre el evento i.\n\nParámetros:\n- n (número): El número total de eventos\n- signs (número[]): Un arreglo que representa las periodicidades de los eventos\n\nDevuelve:\n- número: El año en que ocurre el evento n-ésimo\n\nEjemplo:\napocalypseYear(6, [3,2,4,5,9,18])\n// devuelve 36",
      "arb": "يحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن كل حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1 في السنة التي تلي حدوث الحدث i.\n\nالمعلمات:\n- n (عدد): العدد الإجمالي للأحداث\n- signs (عدد[]): مصفوفة تمثل دوريات الأحداث\n\nالقيم المعادة:\n- عدد: السنة التي يحدث فيها الحدث n\n\nمثال:\napocalypseYear(6, [3,2,4,5,9,18])\n// يعيد 36",
      "sw": "Hesabu mwaka Y_n wakati tukio la n linapotokea, ukizingatia kwamba kila tukio lina kipindi cha a_i miaka. Kuanzia kwa tukio la i+1 huanza mwaka mmoja baada ya tukio la i kutokea.\n\nVipengele:\n- n (nambari): Jumla ya idadi ya matukio\n- signs (nambari[]): Kifurushi kinachowakilisha vipindi vya matukio\n\nInarudi:\n- nambari: Mwaka ambapo tukio la n linatokea\n\nMfano:\napocalypseYear(6, [3,2,4,5,9,18])\n// inarudi 36",
      "tr": "Y_n yılını hesaplar, n'inci olayın gerçekleştiği yıl, her olayın a_i yıllık bir periyodiklikle gerçekleştiğini dikkate alarak. Olay i+1 için geri sayım, olay i gerçekleştiği yılın sonrasında başlar.\nParametreler:\n- n (number): Toplam olay sayısı\n- signs (number[]): Olayların periyodikliklerini temsil eden bir dizi\nDöndürür:\n- number: n'inci olayın gerçekleştiği yıl\n\nÖrnek:\napocalypseYear(6, [3,2,4,5,9,18])\n// 36 döndürür",
      "vi": "Tính toán năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng mỗi sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu từ năm sau khi sự kiện i xảy ra.\nTham số:\n- n (number): Tổng số sự kiện\n- signs (number[]): Một mảng đại diện cho chu kỳ của các sự kiện\nTrả về:\n- number: Năm khi sự kiện thứ n xảy ra\n\nVí dụ:\napocalypseYear(6, [3,2,4,5,9,18])\n// trả về 36"
    },
    "docstring_bertscore": {
      "es": "0.9917204898273227",
      "arb": "0.9356721606891842",
      "sw": "0.9289026386731342",
      "tr": "0.9478976620115005",
      "vi": "0.9553004176822898"
    }
  },
  {
    "task_id": "JavaScript/33",
    "prompt": {
      "en": "\n/**\n * This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\n * Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\n * Then the result is the remainder of x' divided by y. \n * For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Given a prime number p, there will be several queries. For each query, an integer n is given,\n * and you need to compute the value of n! ⊕ p, where n! is the factorial of n,\n * i.e. the product of all positive integers less than or equal to n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n, p)",
      "es": "/**\n * Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.\n * De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.\n * Entonces el resultado es el resto de x' dividido por y.\n * Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,\n * y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,\n * es decir, el producto de todos los enteros positivos menores o iguales a n.\n * \n * @example\n * newModuloFactorial(3, 7); // devuelve 6\n */\nfunction newModuloFactorial(n, p)",
      "arb": "/**\n * هذه المسألة تقدم عملية جديدة للمودولو، يرمز لها بالرمز \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y.\n * خلاف ذلك، قسم x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى القيمة النهائية كـ x'.\n * ثم تكون النتيجة هي باقي قسمة x' على y.\n * على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\n * بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،\n * وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n،\n * أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n * \n * @example\n * newModuloFactorial(3, 7); // يعيد 6\n */\nfunction newModuloFactorial(n, p)",
      "sw": "/**\n * Shida hii inatambulisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y.\n * Vinginevyo, gawa x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ikiwakilisha thamani ya mwisho kama x'.\n * Kisha matokeo ni baki ya x' iliyogawanywa na y.\n * Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa,\n * na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n,\n * yaani ni bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n * \n * @example\n * newModuloFactorial(3, 7); // inarejesha 6\n */\nfunction newModuloFactorial(n, p)",
      "tr": "/**\n * Bu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtmaktadır.\n * x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\n * Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\n * Sonra sonuç, x'in y'ye bölümünden kalan olur.\n * Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Verilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\n * ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\n * yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n * \n * @example\n * newModuloFactorial(3, 7); // 6 döndürür\n */\nfunction newModuloFactorial(n, p)",
      "vi": "/**\n * Vấn đề này giới thiệu một phép toán modulo mới, ký hiệu là \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y.\n * Nếu không, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'.\n * Sau đó kết quả là phần dư của x' chia cho y. \n * Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho,\n * và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n,\n * tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n * \n * @example\n * newModuloFactorial(3, 7); // trả về 6\n */\nfunction newModuloFactorial(n, p)"
    },
    "prompt_bertscore": {
      "es": "0.9947539730064876",
      "arb": "0.9881663964194655",
      "sw": "0.9812707441114583",
      "tr": "0.9660888281978187",
      "vi": "0.9761599844074307"
    },
    "canonical_solution": "{\n    const pj = new Array(p).fill(1);\n    for (let i = 2; i < p; i++) pj[i] = (i * pj[i - 1]) % p;\n    \n    let ans = 1;\n    while (n > 0) {\n        ans = (ans * pj[n % p]) % p;\n        ans = ((n / p) & 1) ? p - ans : ans;\n        n = Math.floor(n / p);\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function newModuloFactorial(n, p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y. \nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6\n",
      "es": "Escribe una función de JavaScript `function newModuloFactorial(n, p)` para resolver el siguiente problema:\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\".\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.\nDe lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.\nEntonces el resultado es el resto de x' dividido por y.\nPor ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,\ny necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,\nes decir, el producto de todos los enteros positivos menores o iguales a n.\n\n@example\nnewModuloFactorial(3, 7); // devuelve 6",
      "arb": "اكتب دالة JavaScript `function newModuloFactorial(n, p)` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية باقي جديدة، يرمز لها بالرمز \"⊕\".\nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y.\nوإلا، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع الإشارة إلى القيمة النهائية كـ x'.\nثم تكون النتيجة هي باقي قسمة x' على y.\nعلى سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،\nوتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n،\nأي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n\n@example\nnewModuloFactorial(3, 7); // يعيد 6",
      "sw": "Andika kazi ya JavaScript `function newModuloFactorial(n, p)` kutatua tatizo lifuatalo:  \nTatizo hili linaanzisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\".  \nWakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni mabaki ya x kugawanywa na y.  \nVinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'.  \nKisha matokeo ni mabaki ya x' kugawanywa na y.  \nKwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nUkipatiwa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inapewa,  \nna unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n,  \nyaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n\n@example\nnewModuloFactorial(3, 7); // inarejesha 6",
      "tr": "Bir JavaScript fonksiyonu `function newModuloFactorial(n, p)` yazın ve aşağıdaki problemi çözün:\nBu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\nAksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\nDaha sonra sonuç, x' in y'ye bölümünden kalan olur.\nÖrneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\nve n! ⊕ p değerini hesaplamanız gerekir, burada n! n faktöriyelidir,\nyani n'den küçük veya eşit tüm pozitif tamsayıların çarpımıdır.\n\n@example\nnewModuloFactorial(3, 7); // 6 döndürür",
      "vi": "Viết một hàm JavaScript `function newModuloFactorial(n, p)` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\".\nKhi tính x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y.\nNgược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'.\nSau đó kết quả là phần dư của x' chia cho y.\nVí dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho,\nvà bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n,\ntức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n\n@example\nnewModuloFactorial(3, 7); // trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.9949065211391224",
      "arb": "0.9889670754854172",
      "sw": "0.983483287925806",
      "tr": "0.9796725640656516",
      "vi": "0.9858608935867935"
    },
    "level": "easy",
    "test": "(function testNewModuloFactorial() {\n    console.assert(newModuloFactorial(3, 7) === 6, 'Test at n=3, p=7 failed');\n    console.assert(newModuloFactorial(10, 3) === 1, 'Test at n=10, p=3 failed');\n    console.assert(newModuloFactorial(11, 7) === 4, 'Test at n=11, p=7 failed');\n    console.assert(newModuloFactorial(45, 7) === 1, 'Test at n=45, p=7 failed');\n    console.assert(newModuloFactorial(14, 7) === 2, 'Test at n=14, p=7 failed');\n    console.assert(newModuloFactorial(1919, 10007) === 3152, 'Test at n=1919, p=10007 failed');\n    console.assert(newModuloFactorial(810, 10007) === 3679, 'Test at n=810, p=10007 failed');\n    console.assert(newModuloFactorial(1, 2) === 1, 'Test at n=1, p=2 failed');\n    console.assert(newModuloFactorial(5, 11) === 10, 'Test at n=5, p=11 failed');\n    console.assert(newModuloFactorial(6, 13) === 5, 'Test at n=6, p=13 failed');\n    console.assert(newModuloFactorial(8, 17) === 13, 'Test at n=8, p=17 failed');\n    console.assert(newModuloFactorial(15, 19) === 16, 'Test at n=15, p=19 failed');\n    console.assert(newModuloFactorial(21, 23) === 1, 'Test at n=21, p=23 failed');\n    console.assert(newModuloFactorial(30, 29) === 28, 'Test at n=30, p=29 failed');\n    console.assert(newModuloFactorial(100, 101) === 100, 'Test at n=100, p=101 failed');\n})();",
    "entry_point": "newModuloFactorial",
    "signature": "function newModuloFactorial(n, p)",
    "docstring": {
      "en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y. \nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6\n",
      "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". \nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. \nDe lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. \nEntonces, el resultado es el resto de x' dividido por y. \nPor ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4. \nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, \ny necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, \nes decir, el producto de todos los enteros positivos menores o iguales a n.\n\n@example\nnewModuloFactorial(3, 7); // devuelve 6",
      "arb": "هذه المسألة تقدم عملية جديدة للمودولو، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y. وإلا، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع تحديد القيمة النهائية كـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4. بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n\n@example\nnewModuloFactorial(3, 7); // يعيد 6",
      "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari kamili n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, ni bidhaa ya nambari zote kamili chanya zilizo chini au sawa na n.\n\n@example\nnewModuloFactorial(3, 7); // inarudisha 6",
      "tr": "Bu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölünmesinden kalan değerdir.\nAksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\nSonuç, x' in y'ye bölünmesinden kalan değerdir.\nÖrneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\nve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\nyani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n\n@example\nnewModuloFactorial(3, 7); // 6 döndürür",
      "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n\n@example\nnewModuloFactorial(3, 7); // trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.992564271685959",
      "arb": "0.9886635682631958",
      "sw": "0.9957201111798413",
      "tr": "0.967787316586048",
      "vi": "0.9813162304687153"
    }
  },
  {
    "task_id": "JavaScript/34",
    "prompt": {
      "en": "\n/**\n * You are given an array a of n integers. You can perform at most one operation where\n * you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n * with x, at a cost of (j - i + 1).\n * Find the minimum cost to make all elements in the array equal.\n */\nfunction makeEqualAgain(n, a)",
      "es": "/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j]\n * con x, a un costo de (j - i + 1).\n * Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n */\nfunction makeEqualAgain(n, a)",
      "arb": "/**\n * لديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث\n * تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j]\n * بـ x، بتكلفة (j - i + 1).\n * ابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n */\nfunction makeEqualAgain(n, a)",
      "sw": "/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\n * unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\n * na x, kwa gharama ya (j - i + 1).\n * Pata gharama ya chini kabisa ya kufanya vipengele vyote katika safu kuwa sawa.\n */\nfunction makeEqualAgain(n, a)",
      "tr": "/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları\n * x ile değiştirebilirsiniz, bu işlemin maliyeti (j - i + 1) olacaktır.\n * Dizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n */\nfunction makeEqualAgain(n, a)",
      "vi": "/**\n * Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác\n * trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j]\n * bằng x, với chi phí là (j - i + 1).\n * Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n */\nfunction makeEqualAgain(n, a)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9885692188322043",
      "sw": "0.968060433359971",
      "tr": "0.9251070107219385",
      "vi": "0.9899586383475433"
    },
    "canonical_solution": "{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function makeEqualAgain(n, a)` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "es": "Escribe una función de JavaScript `function makeEqualAgain(n, a)` para resolver el siguiente problema:\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde\nseleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j]\ncon x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.",
      "arb": "اكتب دالة JavaScript `function makeEqualAgain(n, a)` لحل المشكلة التالية:\nأنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث\nتختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j]\nبـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.",
      "sw": "Andika kazi ya JavaScript `function makeEqualAgain(n, a)` kutatua tatizo lifuatalo:\nUmepewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\nunachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\nna x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.",
      "tr": "Bir JavaScript fonksiyonu `function makeEqualAgain(n, a)` yazın ve aşağıdaki problemi çözün:\nSize n tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; burada \nüç tamsayı i, j, x (1 <= i <= j <= n) seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.",
      "vi": "Viết một hàm JavaScript `function makeEqualAgain(n, a)` để giải quyết vấn đề sau:\nBạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9954080628512355",
      "sw": "0.9693112088693477",
      "tr": "0.9565066999863147",
      "vi": "0.983409794684823"
    },
    "level": "middle",
    "test": "function testMakeEqualAgain() {\n    console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4);\n    console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0);\n    console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2);\n    console.assert(makeEqualAgain(3, [1, 2, 3]) === 2);\n    console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6);\n    console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7);\n    \n    console.assert(makeEqualAgain(3, [1, 2, 1]) === 1);\n    console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1);\n    console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0);\n    console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1);\n    console.assert(makeEqualAgain(1, [1]) === 0);\n    console.assert(makeEqualAgain(2, [1, 2]) === 1);\n    console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2);\n    console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2);\n    console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3);\n    console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5);\n\n}\n\ntestMakeEqualAgain();",
    "entry_point": "makeEqualAgain",
    "signature": "function makeEqualAgain(n, a)",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.",
      "arb": "تم إعطاؤك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).  \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.",
      "sw": "Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\nunachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\nna x, kwa gharama ya (j - i + 1).\nPata gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.",
      "tr": "Bir n tam sayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetine sahiptir. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau."
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9935842386925731",
      "sw": "0.961239863335995",
      "tr": "0.9620892068453002",
      "vi": "0.9758252922153868"
    }
  },
  {
    "task_id": "JavaScript/35",
    "prompt": {
      "en": "\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n * determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a \n * positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can \n * only move stones in the last pile loses. Assuming both players use the best possible strategy, find out \n * who will win the game.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "es": "/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras,\n * determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan moviendo un \n * número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador que solo puede \n * mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua \n * quién ganará el juego.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // devuelve \"Dan\"\n */\nfunction gameWinner(piles)",
      "arb": "/**\n * بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، مع احتواء كل كومة على عدد موجب من الحجارة،\n * حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة \n * من الكومة اليسرى غير الفارغة إلى الكومة المجاورة على اليمين. اللاعب الذي يمكنه فقط نقل الحجارة \n * في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف \n * من سيفوز باللعبة.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // يعيد \"Dan\"\n */\nfunction gameWinner(piles)",
      "sw": "/**\n * Ukiwa na mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe,\n * bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha \n * idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza \n * tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, gundua \n * nani atashinda mchezo.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // inarejesha \"Dan\"\n */\nfunction gameWinner(piles)",
      "tr": "/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir,\n * Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla \n * soldaki en dolu olmayan yığından sağdaki bitişik yığına pozitif sayıda taş taşırlar. \n * Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da \n * en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // \"Dan\" döndürür\n */\nfunction gameWinner(piles)",
      "vi": "/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương,\n * xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt \n * di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi \n * chỉ có thể di chuyển đá ở đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, \n * tìm ra ai sẽ thắng trò chơi.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // trả về \"Dan\"\n */\nfunction gameWinner(piles)"
    },
    "prompt_bertscore": {
      "es": "0.9775734381988749",
      "arb": "0.9858759894957522",
      "sw": "0.9676586040991374",
      "tr": "0.9567091043445892",
      "vi": "0.9883314582661055"
    },
    "canonical_solution": "{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "Write a JavaScript function `function gameWinner(piles)` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "es": "Escribe una función de JavaScript `function gameWinner(piles)` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras,\ndetermina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan moviendo un\nnúmero positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador que solo puede\nmover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua\nquién ganará el juego.\n\n@example\ngameWinner([3, 1, 2, 2]) // devuelve \"Dan\"",
      "arb": "اكتب دالة JavaScript `function gameWinner(piles)` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، مع احتواء كل كومة على عدد موجب من الحجارة،\nحدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبان في نقل عدد\nموجب من الحجارة من الكومة غير الفارغة الأكثر إلى اليسار إلى الكومة المجاورة على اليمين. اللاعب الذي لا يمكنه\nإلا نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف\nمن سيفوز باللعبة.\n\n@example\ngameWinner([3, 1, 2, 2]) // يعيد \"Dan\"",
      "sw": "Andika kazi ya JavaScript `function gameWinner(piles)` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa marundo ya mawe N yaliyopangwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe,\n amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha\n idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza\n tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, tafuta\n nani atakayeshinda mchezo.\n\n@example\ngameWinner([3, 1, 2, 2]) // inarejesha \"Dan\"",
      "tr": "Bir JavaScript fonksiyonu `function gameWinner(piles)` yazın ve aşağıdaki problemi çözün:\n1'den N'ye kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir,\nCharlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla\npozitif sayıda taşı en soldaki boş olmayan yığından bitişik sağdaki yığına taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" döndürür",
      "vi": "Viết một hàm JavaScript `function gameWinner(piles)` để giải quyết vấn đề sau:\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương,\nxác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một\nsố lượng đá dương từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể\ndi chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra\nai sẽ thắng trò chơi.\n\n@example\ngameWinner([3, 1, 2, 2]) // trả về \"Dan\""
    },
    "instruction_bertscore": {
      "es": "0.9948497128501463",
      "arb": "0.991550859481919",
      "sw": "0.9622711522743281",
      "tr": "0.9659044992042184",
      "vi": "0.995029671975364"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\", \"Test 1 failed\");\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\", \"Test 2 failed\");\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\", \"Test 3 failed\");\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\", \"Test 4 failed\");\n    console.assert(gameWinner([1, 1]) === \"Charlie\", \"Test 5 failed\");\n    console.assert(gameWinner([2, 1]) === \"Charlie\", \"Test 6 failed\");\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\", \"Test 7 failed\");\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\", \"Test 8 failed\");\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\", \"Test 9 failed\");\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\", \"Test 10 failed\");\n})();",
    "entry_point": "gameWinner",
    "signature": "function gameWinner(piles)",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "es": "Dada una secuencia de N montones de piedras numerados del 1 al N, con cada montón conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y ellos se turnan moviendo un número positivo de piedras del montón más a la izquierda que no esté vacío al montón adyacente a la derecha. El jugador que solo pueda mover piedras en el último montón pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n\n@example\ngameWinner([3, 1, 2, 2]) // devuelve \"Dan\"",
      "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث يحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون على نقل عدد موجب من الحجارة من الكومة غير الفارغة اليسرى إلى الكومة المجاورة اليمنى. اللاعب الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز باللعبة.\n\n@example\ngameWinner([3, 1, 2, 2]) // يعيد \"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n\n@example\ngameWinner([3, 1, 2, 2]) // inarudisha \"Dan\"",
      "tr": "Verilen 1'den N'ye numaralandırılmış N taş yığını dizisinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk hamleyi yapar ve sırayla pozitif sayıda taşı en soldaki boş olmayan yığından bitişik sağ yığına taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" döndürür",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n\n@example\ngameWinner([3, 1, 2, 2]) // trả về \"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9931257997731446",
      "arb": "0.9880805880948584",
      "sw": "0.9709195190645872",
      "tr": "0.9740372215253108",
      "vi": "0.9884899653101713"
    }
  },
  {
    "task_id": "JavaScript/36",
    "prompt": {
      "en": "\n/**\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps\n * to the right and then open the door at that position. It is guaranteed that\n * C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n * \n * Example:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "es": "/**\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos\n * a la derecha y luego abrir la puerta en esa posición. Se garantiza que\n * C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n * \n * Ejemplo:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "arb": "/**\n * بالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات\n * إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن\n * C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n * \n * مثال:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "sw": "/**\n * Ukiwa na milango n iliyopangwa kwenye mduara, mchezaji anaanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i\n * kuelekea kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa\n * C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kuamua gharama ya jumla ya chini kabisa inayohitajika kufungua milango yote.\n * \n * Mfano:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "tr": "/**\n * Bir daire şeklinde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\n * ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n * \n * Örnek:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */",
      "vi": "/**\n * Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước\n * sang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng\n * C_i >= C_{i+1} cho 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n * \n * Ví dụ:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)"
    },
    "prompt_bertscore": {
      "es": "0.9873899502600001",
      "arb": "0.9915971403607001",
      "sw": "0.9963608927890598",
      "tr": "0.9716041979880145",
      "vi": "0.9841769052163798"
    },
    "canonical_solution": "{\n   return C[n-2] * (n - 1) + C[n-1];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function minTotalCost(n, C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "es": "Escribe una función de JavaScript `function minTotalCost(n, C)` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos\na la derecha y luego abrir la puerta en esa posición. Se garantiza que\nC_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "arb": "اكتب دالة JavaScript `function minTotalCost(n, C)` لحل المشكلة التالية:\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات\nإلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن\nC_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "sw": "Andika kazi ya JavaScript `function minTotalCost(n, C)` kutatua tatizo lifuatalo:\nUkipiwa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1.\nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i\nkulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa\nC_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "tr": "Bir JavaScript fonksiyonu `function minTotalCost(n, C)` yazın ve aşağıdaki problemi çözün:\nBir çember şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder.\nC_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "vi": "Viết một hàm JavaScript `function minTotalCost(n, C)` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước\nsang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng\nC_i >= C_{i+1} với 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    > minTotalCost(3, [1, 1, 1])\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9909498039489074",
      "arb": "0.9909498039489074",
      "sw": "0.993395738460971",
      "tr": "0.9783192952796609",
      "vi": "0.9832806849371504"
    },
    "level": "easy",
    "test": "function testMinTotalCost() {\n    console.assert(minTotalCost(5, [4, 3, 3, 3, 3]) === 15);\n    console.assert(minTotalCost(3, [1, 1, 1]) === 3);\n    console.assert(minTotalCost(4, [5, 4, 3, 2]) === 11);\n    console.assert(minTotalCost(4, [100, 99, 98, 97]) === 391);\n    console.assert(minTotalCost(6, [10, 9, 8, 7, 6, 5]) === 35);\n    console.assert(minTotalCost(7, [2, 2, 2, 2, 2, 2, 2]) === 14);\n    console.assert(minTotalCost(8, [9, 7, 7, 7, 7, 7, 7, 7]) === 56);\n    console.assert(minTotalCost(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]) === 18);\n    console.assert(minTotalCost(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]) === 50);\n    console.assert(minTotalCost(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === 11);\n\n}\n\ntestMinTotalCost();",
    "entry_point": "minTotalCost",
    "signature": "function minTotalCost(n, C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "arb": "نظرًا لوجود n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.  \nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في هذا الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.  \nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "sw": "Kwa kuzingatia milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusogea hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "tr": "Verilen n kapı bir çember şeklinde düzenlenmiştir, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa gitmek için bir maliyet C_i ödeyebilir ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için. Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "vi": "Cho n cánh cửa được sắp xếp theo hình tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    > minTotalCost(3, [1, 1, 1])\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9927710459126163",
      "arb": "0.9751026748891819",
      "sw": "0.994608376937189",
      "tr": "0.9633600440231614",
      "vi": "0.9848387416459881"
    }
  },
  {
    "task_id": "JavaScript/37",
    "prompt": {
      "en": "\n/**\n * Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n * calculate the total number of handshakes that occur. Each student will shake hands with \n * every student already in the classroom who has a smaller ID number. The sequence represents \n * the order in which students enter the classroom.\n *\n * Examples:\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n, order)",
      "es": "/**\n * Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones van de 0 a N-1,\n * calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con \n * cada estudiante que ya esté en el aula y que tenga un número de identificación menor. La secuencia representa \n * el orden en que los estudiantes ingresan al aula.\n *\n * Ejemplos:\n *    countHandshakes(3, [2, 1, 0])  // devuelve 0\n */\nfunction countHandshakes(n, order)",
      "arb": "/**\n * بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل الدراسي، حيث تتراوح المعرفات من 0 إلى N-1،\n * احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل \n * الذي لديه رقم معرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n *\n * أمثلة:\n *    countHandshakes(3, [2, 1, 0])  // يعيد 0\n */\nfunction countHandshakes(n, order)",
      "sw": "/**\n * Ukipewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1,\n * hesabu jumla ya mikono iliyoshikwa inayotokea. Kila mwanafunzi atashikana mikono na \n * kila mwanafunzi aliyeko darasani tayari ambaye ana namba ya kitambulisho ndogo. Mlolongo unaonyesha \n * mpangilio ambao wanafunzi wanaingia darasani.\n *\n * Mifano:\n *    countHandshakes(3, [2, 1, 0])  // inarejesha 0\n */\nfunction countHandshakes(n, order)",
      "tr": "/**\n * 0'dan N-1'e kadar olan öğrenci kimlik numaralarının bir sınıfa giriş sırasına göre,\n * gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan \n * ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. \n * Sıra, öğrencilerin sınıfa giriş sırasını temsil eder.\n *\n * Örnekler:\n *    countHandshakes(3, [2, 1, 0])  // 0 döndürür\n */\nfunction countHandshakes(n, order)",
      "vi": "/**\n * Cho một dãy số ID của học sinh khi vào lớp học, trong đó các ID nằm trong khoảng từ 0 đến N-1,\n * tính tổng số lần bắt tay diễn ra. Mỗi học sinh sẽ bắt tay với \n * mọi học sinh đã có mặt trong lớp có số ID nhỏ hơn. Dãy số đại diện cho thứ tự học sinh vào lớp.\n *\n * Ví dụ:\n *    countHandshakes(3, [2, 1, 0])  // trả về 0\n */\nfunction countHandshakes(n, order)"
    },
    "prompt_bertscore": {
      "es": "0.9943573081355609",
      "arb": "0.9846160769888479",
      "sw": "0.9930582654435928",
      "tr": "0.9184930162942389",
      "vi": "0.9713203551735156"
    },
    "canonical_solution": "{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countHandshakes(n, order)` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n\nExamples:\ncountHandshakes(3, [2, 1, 0])  // returns 0",
      "es": "Escribe una función de JavaScript `function countHandshakes(n, order)` para resolver el siguiente problema:\nDada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1,\ncalcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con\ncada estudiante que ya esté en el aula y que tenga un número de identificación menor. La secuencia representa\nel orden en que los estudiantes ingresan al aula.\n\nEjemplos:\ncountHandshakes(3, [2, 1, 0])  // devuelve 0",
      "arb": "اكتب دالة JavaScript `function countHandshakes(n, order)` لحل المشكلة التالية:\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1،\nاحسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح\nكل طالب موجود بالفعل في الفصل الذي لديه رقم تعريف أصغر. يمثل التسلسل\nالترتيب الذي يدخل فيه الطلاب إلى الفصل.\n\nأمثلة:\ncountHandshakes(3, [2, 1, 0])  // يعيد 0",
      "sw": "Andika kazi ya JavaScript `function countHandshakes(n, order)` kutatua tatizo lifuatalo:\nUkipiwa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1,\nhesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi aliyeko darasani tayari ambaye ana namba ya kitambulisho ndogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\ncountHandshakes(3, [2, 1, 0])  // inarudisha 0",
      "tr": "Bir JavaScript fonksiyonu `function countHandshakes(n, order)` yazın ve aşağıdaki problemi çözün:\nBir sınıfa giren öğrenci kimlik numaralarının bir dizisi verildiğinde, kimlik numaraları 0'dan N-1'e kadar sıralanır, toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\ncountHandshakes(3, [2, 1, 0])  // 0 döndürür",
      "vi": "Viết một hàm JavaScript `function countHandshakes(n, order)` để giải quyết vấn đề sau:\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1,\ntính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với\nmọi học sinh đã có mặt trong lớp có số ID nhỏ hơn. Dãy số biểu thị\nthứ tự học sinh vào lớp.\n\nVí dụ:\ncountHandshakes(3, [2, 1, 0])  // trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.997090859439363",
      "arb": "0.9927370801174593",
      "sw": "0.9842027271659143",
      "tr": "0.9571423172056264",
      "vi": "0.9793482006534217"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2, \"Test 1 failed\");\n    console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15, \"Test 2 failed\");\n    console.assert(countHandshakes(3, [1, 2, 0]) === 1, \"Test 3 failed\");\n    console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0, \"Test 4 failed\");\n    console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6, \"Test 5 failed\");\n    console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0, \"Test 6 failed\");\n    console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5, \"Test 7 failed\");\n    console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3, \"Test 8 failed\");\n    console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4, \"Test 9 failed\");\n    console.assert(countHandshakes(3, [2, 0, 1]) === 1, \"Test 10 failed\");\n    console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7, \"Test 11 failed\");\n    console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0, \"Test 12 failed\");\n})();",
    "entry_point": "countHandshakes",
    "signature": "function countHandshakes(n, order)",
    "docstring": {
      "en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n\nExamples:\ncountHandshakes(3, [2, 1, 0])  // returns 0",
      "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula y que tenga un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\ncountHandshakes(3, [2, 1, 0])  // devuelve 0",
      "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل الذي لديه رقم معرف أصغر. يمثل التسلسل الترتيب الذي يدخل به الطلاب إلى الفصل.\n\nأمثلة:\ncountHandshakes(3, [2, 1, 0])  // يعيد 0",
      "sw": "Kwa kupewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinaanzia 0 hadi N-1, hesabu jumla ya mikono inayoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani na ana namba ya kitambulisho ndogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\ncountHandshakes(3, [2, 1, 0])  // inarudisha 0",
      "tr": "Verilen bir sınıfa giren öğrenci kimlik numaralarının dizisinde, kimlik numaraları 0'dan N-1'e kadar sıralanmıştır,\ntoplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan\nher öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\ncountHandshakes(3, [2, 1, 0])  // 0 döndürür",
      "vi": "Cho một dãy số ID của học sinh khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1,\ntính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với\nmỗi học sinh đã có mặt trong lớp học có số ID nhỏ hơn. Dãy số đại diện cho\nthứ tự mà học sinh vào lớp học.\n\nVí dụ:\ncountHandshakes(3, [2, 1, 0])  // trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.996344803728196",
      "arb": "0.9859379621746351",
      "sw": "0.9796715709137465",
      "tr": "0.9428029913683367",
      "vi": "0.990589091176948"
    }
  },
  {
    "task_id": "JavaScript/38",
    "prompt": {
      "en": "\n/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n, counts)",
      "es": "/**\n * Dado n enteros positivos que representan la cantidad de cada número de 1 a n, \n * encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \n * una secuencia construida a partir de estos números. El modo es el número más grande \n * entre los elementos más frecuentes en una secuencia.\n * Por ejemplo:\n *   maxModeSum(3, [1, 2, 3])\n *   Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.\n */\nfunction maxModeSum(n, counts)",
      "arb": "/**\n * بالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n * على سبيل المثال:\n *   maxModeSum(3, [1, 2, 3])\n *   تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.\n */\nfunction maxModeSum(n, counts)",
      "sw": "/**\n * Ukipewa n nambari chanya zinazoashiria idadi ya kila nambari kutoka 1 hadi n, \n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \n * mlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi \n * kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * Kwa mfano:\n *   maxModeSum(3, [1, 2, 3])\n *   Mlolongo unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.\n */\nfunction maxModeSum(n, counts)",
      "tr": "/**\n * 1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık rastlanan eleman) maksimum toplamını bulun.\n * Mod, bir dizideki en sık rastlanan elemanlar arasında en büyük sayıdır.\n * Örneğin:\n *   maxModeSum(3, [1, 2, 3])\n *   Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] ve toplam 17'dir.\n */\nfunction maxModeSum(n, counts)",
      "vi": "/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, \n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của \n * một dãy được tạo từ các số này. Mode là số lớn nhất \n * trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n * Ví dụ:\n *   maxModeSum(3, [1, 2, 3])\n *   Một dãy đạt giá trị tối đa là [3, 2, 3, 1, 2, 2], và tổng là 17.\n */\nfunction maxModeSum(n, counts)"
    },
    "prompt_bertscore": {
      "es": "0.9939501158544394",
      "arb": "0.9814487169328656",
      "sw": "0.9519489272630881",
      "tr": "0.9556368975477629",
      "vi": "0.9664590752280677"
    },
    "canonical_solution": "{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function maxModeSum(n, counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   maxModeSum(3, [1, 2, 3]) A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "es": "Escribe una función de JavaScript `function maxModeSum(n, counts)` para resolver el siguiente problema:  \nDado n números enteros positivos que representan la cantidad de cada número del 1 al n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia. Por ejemplo: maxModeSum(3, [1, 2, 3]) Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.",
      "arb": "اكتب دالة JavaScript `function maxModeSum(n, counts)` لحل المشكلة التالية:  \nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر عدد بين العناصر الأكثر تكرارًا في تسلسل. على سبيل المثال: maxModeSum(3, [1, 2, 3]) تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.",
      "sw": "Andika kazi ya JavaScript `function maxModeSum(n, counts)` kutatua tatizo lifuatalo:  \nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo. Kwa mfano: maxModeSum(3, [1, 2, 3]) Mlolongo unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.",
      "tr": "Bir JavaScript fonksiyonu `function maxModeSum(n, counts)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde, bu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır. Örneğin: maxModeSum(3, [1, 2, 3]) Maksimum değere ulaşan bir dizi [3, 2, 3, 1, 2, 2] ve toplam 17'dir.",
      "vi": "Viết một hàm JavaScript `function maxModeSum(n, counts)` để giải quyết vấn đề sau:  \nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy. Ví dụ: maxModeSum(3, [1, 2, 3]) Một dãy đạt giá trị lớn nhất là [3, 2, 3, 1, 2, 2], và tổng là 17."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.975410551979786",
      "sw": "0.9544105535752535",
      "tr": "0.9638504624339366",
      "vi": "0.9694971269059963"
    },
    "level": "easy",
    "test": "(function testMaxModeSum() {\n  console.assert(maxModeSum(3, [1, 3, 2]) === 17, 'Test case 1 failed');\n  console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37, 'Test case 2 failed');\n  console.assert(maxModeSum(2, [1, 1]) === 4, 'Test case 3 failed');\n  console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75, 'Test case 4 failed');\n  console.assert(maxModeSum(1, [100000]) === 100000, 'Test case 5 failed');\n  console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62, 'Test case 6 failed');\n  console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000, 'Test case 7 failed');\n  console.assert(maxModeSum(3, [2, 2, 5]) === 27, 'Test case 8 failed');\n  console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64, 'Test case 9 failed');\n  console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126, 'Test case 10 failed');\n  console.assert(maxModeSum(3, [3, 1, 2]) === 16, 'Test case 11 failed');\n})();",
    "entry_point": "maxModeSum",
    "signature": "function maxModeSum(n, counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   maxModeSum(3, [1, 2, 3]) A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. La moda es el número más grande entre los elementos más frecuentes en una secuencia. Por ejemplo: maxModeSum(3, [1, 2, 3]) Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.",
      "arb": "نظرًا لوجود n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، ابحث عن الحد الأقصى لمجموع الوضع (العنصر الأكثر تكرارًا) لجميع البادئات لتسلسل مُنشأ من هذه الأرقام. الوضع هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل. على سبيل المثال: maxModeSum(3, [1, 2, 3]) تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.",
      "sw": "Ukipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo. Kwa mfano: \n\nmaxModeSum(3, [1, 2, 3]) \n\nMfuatano unaofikia thamani yake ya juu ni [3, 2, 3, 1, 2, 2], na jumla ni 17.",
      "tr": "Verilen n pozitif tam sayı, 1'den n'e kadar olan her sayının sayısını temsil eder, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizide en sık görülen elemanlar arasında en büyük sayıdır. Örneğin: maxModeSum(3, [1, 2, 3]) Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] olup, toplam 17'dir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy. Ví dụ:\n\nmaxModeSum(3, [1, 2, 3])\n\nMột dãy đạt giá trị tối đa là [3, 2, 3, 1, 2, 2], và tổng là 17."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9801107426862146",
      "sw": "0.9926445183598971",
      "tr": "0.9491919375743239",
      "vi": "0.9645552030258483"
    }
  },
  {
    "task_id": "JavaScript/39",
    "prompt": {
      "en": "\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n */\nfunction sumOfXorSubarrays(A)",
      "es": "/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Ejemplo:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // devuelve 39\n */\nfunction sumOfXorSubarrays(A)",
      "arb": "/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع الـ XOR لجميع المصفوفات الفرعية.\n * يتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\n * مجموع الـ XOR لمصفوفة فرعية هو نتيجة تطبيق عملية XOR على جميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع نتائج الـ XOR لجميع المصفوفات الفرعية الممكنة.\n *\n * مثال:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // يعيد 39\n */\nfunction sumOfXorSubarrays(A)",
      "sw": "/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\n * Kipengele kidogo kinafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= urefu wa safu.\n * Jumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n *\n * Mfano:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // inarudisha 39\n */\nfunction sumOfXorSubarrays(A)",
      "tr": "/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= dizinin uzunluğu olacak şekilde bir (L, R) indeks çifti ile tanımlanır.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\n * Nihai sonuç, mümkün olan tüm alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 döndürür\n */\nfunction sumOfXorSubarrays(A)",
      "vi": "/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng.\n * Tổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Ví dụ:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // trả về 39\n */\nfunction sumOfXorSubarrays(A)"
    },
    "prompt_bertscore": {
      "es": "0.9914501538787343",
      "arb": "0.9740503311304591",
      "sw": "0.9718115681058149",
      "tr": "0.9822509850418655",
      "vi": "0.9896563229076082"
    },
    "canonical_solution": "{\n    const n = A.length;\n    let q = new Array(n + 1).fill(0);\n    let w = Array.from({ length: 21 }, () => [0, 0]);\n    let ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function sumOfXorSubarrays(A)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "es": "Escribe una función de JavaScript `function sumOfXorSubarrays(A)` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nEjemplo:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // devuelve 39",
      "arb": "اكتب دالة JavaScript `function sumOfXorSubarrays(A)` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\nمجموع XOR لمصفوفة فرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nمثال:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // يعيد 39",
      "sw": "Andika kazi ya JavaScript `function sumOfXorSubarrays(A)` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo za safu.\nSehemu ndogo ya safu inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= urefu wa safu.\nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR za sehemu ndogo zote zinazowezekana.\n\nMfano:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // inarudisha 39",
      "tr": "Bir JavaScript fonksiyonu `function sumOfXorSubarrays(A)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve 1 <= L <= R <= dizinin uzunluğu olmalıdır.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 döndürür",
      "vi": "Viết một hàm JavaScript `function sumOfXorSubarrays(A)` để giải quyết vấn đề sau:  \nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.\n\nVí dụ:  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // trả về 39"
    },
    "instruction_bertscore": {
      "es": "0.9926232649091263",
      "arb": "0.9699027301440696",
      "sw": "0.9711765467776463",
      "tr": "0.9734586112253562",
      "vi": "0.9959417826850762"
    },
    "level": "middle",
    "test": "const testSumOfXorSubarrays = () => {\n    console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39);\n    console.assert(sumOfXorSubarrays([1, 1, 1]) === 4);\n    console.assert(sumOfXorSubarrays([2, 3, 1]) === 9);\n    console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74);\n    console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0);\n    console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72);\n    console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125);\n    console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390);\n    console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192);\n    console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192);\n    console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218);\n}\n\ntestSumOfXorSubarrays();",
    "entry_point": "sumOfXorSubarrays",
    "signature": "function sumOfXorSubarrays(A)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nEjemplo:  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // devuelve 39",
      "arb": "بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع الـ XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\nمجموع الـ XOR لقطعة فرعية هو نتيجة تطبيق عملية XOR على جميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع قيم الـ XOR لجميع القطع الفرعية الممكنة.\n\nمثال:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // يعيد 39",
      "sw": "Ukipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= urefu wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMfano:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // inarejesha 39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= dizinin uzunluğu olacak şekilde bir (L, R) indeks çifti ile tanımlanır.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucu elde edilir.\nSonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 döndürür",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng. \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nVí dụ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // trả về 39"
    },
    "docstring_bertscore": {
      "es": "0.9871480184558996",
      "arb": "0.9691580648455698",
      "sw": "0.9781276169619623",
      "tr": "0.9691129757490748",
      "vi": "0.9933027794426467"
    }
  },
  {
    "task_id": "JavaScript/40",
    "prompt": {
      "en": "\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n * and b >= k. Different legal representations of the same number are counted only once.\n * Example:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n, k) {",
      "es": "/**\n * Dado dos enteros positivos n y k, encuentra el número de enteros positivos x,\n * donde 1 <= x <= n, que se pueden expresar como x = a^b con a y b siendo enteros positivos\n * y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\n * Ejemplo:\n *   countPowerNumbers(99, 1) devuelve 99\n */\nfunction countPowerNumbers(n, k) {",
      "arb": "/**\n * معطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b بحيث أن a و b هما عددان صحيحان موجبان\n * و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس العدد مرة واحدة فقط.\n * مثال:\n *   countPowerNumbers(99, 1) يعيد 99\n */\nfunction countPowerNumbers(n, k) {",
      "sw": "/**\n * Ukipewa nambari mbili chanya n na k, tafuta idadi ya nambari chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya\n * na b >= k. Uwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n * Mfano:\n *   countPowerNumbers(99, 1) inarudisha 99\n */\nfunction countPowerNumbers(n, k) {",
      "tr": "/**\n * İki pozitif tam sayı n ve k verildiğinde, 1 <= x <= n aralığında,\n * x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun,\n * burada a ve b pozitif tam sayılardır ve b >= k'dır. Aynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n * Örnek:\n *   countPowerNumbers(99, 1) 99 döndürür\n */\nfunction countPowerNumbers(n, k) {",
      "vi": "/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương\n * và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n * Ví dụ:\n *   countPowerNumbers(99, 1) trả về 99\n */\nfunction countPowerNumbers(n, k) {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9819840258097546",
      "sw": "0.970411223919519",
      "tr": "0.9579860990642626",
      "vi": "0.975575613826426"
    },
    "canonical_solution": "let count = 0;\n    let x = 0;\n    let mp = new Array(n + 1).fill(false);\n    \n    for (let i = 2; i <= Math.cbrt(n); ++i) {\n        let t = i * i;\n        let m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if (Math.pow(Math.floor(Math.sqrt(t)), 2) === t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k === 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += Math.floor(Math.sqrt(n)) - x;\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countPowerNumbers(n, k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99\n",
      "es": "Escribe una función de JavaScript `function countPowerNumbers(n, k)` para resolver el siguiente problema:  \nDado dos enteros positivos n y k, encuentra el número de enteros positivos x,  \ndonde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos  \ny b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.  \nEjemplo:  \n  countPowerNumbers(99, 1) devuelve 99  ",
      "arb": "اكتب دالة JavaScript `function countPowerNumbers(n, k)` لحل المشكلة التالية:\nمعطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x،\nحيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة\nو b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\nمثال:\n  countPowerNumbers(99, 1) يعيد 99",
      "sw": "Andika kazi ya JavaScript `function countPowerNumbers(n, k)` kutatua tatizo lifuatalo:  \nUkipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x,  \nambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya  \nna b >= k. Uwakilishi tofauti halali wa nambari sawa unahesabiwa mara moja tu.  \nMfano:  \n  countPowerNumbers(99, 1) inarudisha 99  ",
      "tr": "Bir JavaScript fonksiyonu `function countPowerNumbers(n, k)` yazın ve aşağıdaki problemi çözün:\nİki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun. Burada a ve b pozitif tamsayılar ve b >= k. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\nÖrnek:\n  countPowerNumbers(99, 1) döndürür 99",
      "vi": "Viết một hàm JavaScript `function countPowerNumbers(n, k)` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,  \nvới 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương  \nvà b >= k. Các biểu diễn hợp pháp khác nhau của cùng một số chỉ được đếm một lần.  \nVí dụ:  \n  countPowerNumbers(99, 1) trả về 99  "
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9932350464827138",
      "sw": "0.9889190069332067",
      "tr": "0.9307397710673259",
      "vi": "0.9732486589126023"
    },
    "level": "hard",
    "test": "const testCountPowerNumbers = () => {\n    console.assert(countPowerNumbers(99, 1) === 99, 'Expected 99, got ' + countPowerNumbers(99, 1));\n    console.assert(countPowerNumbers(99, 3) === 7, 'Expected 7, got ' + countPowerNumbers(99, 3));\n    console.assert(countPowerNumbers(99, 2) === 12, 'Expected 12, got ' + countPowerNumbers(99, 2));\n    console.assert(countPowerNumbers(10, 1) === 10, 'Expected 10, got ' + countPowerNumbers(10, 1));\n    console.assert(countPowerNumbers(10, 2) === 4, 'Expected 4, got ' + countPowerNumbers(10, 2));\n    console.assert(countPowerNumbers(500, 1) === 500, 'Expected 500, got ' + countPowerNumbers(500, 1));\n    console.assert(countPowerNumbers(500, 2) === 30, 'Expected 30, got ' + countPowerNumbers(500, 2));\n    console.assert(countPowerNumbers(500, 3) === 13, 'Expected 13, got ' + countPowerNumbers(500, 3));\n    console.assert(countPowerNumbers(1000, 1) === 1000, 'Expected 1000, got ' + countPowerNumbers(1000, 1));\n    console.assert(countPowerNumbers(1000, 2) === 41, 'Expected 41, got ' + countPowerNumbers(1000, 2));\n    console.assert(countPowerNumbers(1000, 3) === 17, 'Expected 17, got ' + countPowerNumbers(1000, 3));\n    console.assert(countPowerNumbers(1000, 93) === 1, 'Expected 1, got ' + countPowerNumbers(1000, 93));\n    console.assert(countPowerNumbers(50, 2) === 10, 'Expected 10, got ' + countPowerNumbers(50, 2));\n    console.assert(countPowerNumbers(50, 3) === 5, 'Expected 5, got ' + countPowerNumbers(50, 3));\n    console.assert(countPowerNumbers(2, 3) === 1, 'Expected 1, got ' + countPowerNumbers(2, 3));\n};\ntestCountPowerNumbers();",
    "entry_point": "countPowerNumbers",
    "signature": "function countPowerNumbers(n, k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99\n",
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que se pueden expresar como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\nEjemplo:\n  countPowerNumbers(99, 1) devuelve 99",
      "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعدادًا صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n\nمثال:\n  countPowerNumbers(99, 1) يعيد 99",
      "sw": "Kwa kupewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x,\nambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya\nna b >= k. Uwakilishi tofauti halali wa nambari ile ile unahesabiwa mara moja tu.\nMfano:\n  countPowerNumbers(99, 1) inarudisha 99",
      "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\nÖrnek:\n  countPowerNumbers(99, 1) 99 döndürür",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các cách biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n\nVí dụ:\n  countPowerNumbers(99, 1) trả về 99"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9904204539834495",
      "sw": "0.9852530846208268",
      "tr": "0.9441097806451653",
      "vi": "0.9688317151295295"
    }
  },
  {
    "task_id": "JavaScript/41",
    "prompt": {
      "en": "\n/**\n * Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', \n * such that the longest balanced subsequence is of length 2 * k. The result should be calculated \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * For example:\n *     countBalancedSubsequences(2, 2, 2)\n *     // returns 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "es": "/**\n * Dados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\n * tal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado\n * módulo 1,000,000,007 (10^9 + 7).\n * \n * Por ejemplo:\n *     countBalancedSubsequences(2, 2, 2)\n *     // devuelve 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "arb": "/**\n * بالنظر إلى ثلاثة أعداد صحيحة n، m، و k، جد عدد التتابعات التي تتكون من n '(' و m ')',\n * بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة 1,000,000,007 (10^9 + 7).\n * \n * على سبيل المثال:\n *     countBalancedSubsequences(2, 2, 2)\n *     // يعيد 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "sw": "/**\n * Ukipewa nambari tatu n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')', \n * kiasi kwamba mlolongo mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa \n * kwa modulo 1,000,000,007 (10^9 + 7).\n * \n * Kwa mfano:\n *     countBalancedSubsequences(2, 2, 2)\n *     // inarudisha 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "tr": "/**\n * Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' içeren dizilerin sayısını bulun, \n * öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olur. Sonuç, 1,000,000,007 (10^9 + 7) \n * modunda hesaplanmalıdır.\n * \n * Örneğin:\n *     countBalancedSubsequences(2, 2, 2)\n *     // 2 döndürür\n */\nfunction countBalancedSubsequences(n, m, k)",
      "vi": "/**\n * Cho ba số nguyên n, m, và k, tìm số lượng dãy bao gồm n '(' và m ')', \n * sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả cần được tính \n * theo modulo 1,000,000,007 (10^9 + 7).\n * \n * Ví dụ:\n *     countBalancedSubsequences(2, 2, 2)\n *     // trả về 2\n */\nfunction countBalancedSubsequences(n, m, k)"
    },
    "prompt_bertscore": {
      "es": "0.9891776236893142",
      "arb": "0.9752236407912321",
      "sw": "0.9867598946913575",
      "tr": "0.9756959838373331",
      "vi": "0.9823570536653381"
    },
    "canonical_solution": "{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countBalancedSubsequences(n, m, k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    countBalancedSubsequences(2, 2, 2)\n    // returns 2",
      "es": "Escribe una función de JavaScript `function countBalancedSubsequences(n, m, k)` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    countBalancedSubsequences(2, 2, 2)\n    // devuelve 2",
      "arb": "اكتب دالة JavaScript `function countBalancedSubsequences(n, m, k)` لحل المشكلة التالية:\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التسلسلات المكونة من n '(' و m ')', بحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    countBalancedSubsequences(2, 2, 2)\n    // يعيد 2",
      "sw": "Andika kazi ya JavaScript `function countBalancedSubsequences(n, m, k)` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')', kiasi kwamba mlolongo mrefu zaidi ulio sawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    countBalancedSubsequences(2, 2, 2)\n    // inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `function countBalancedSubsequences(n, m, k)` yazın ve aşağıdaki problemi çözün:\nVerilen üç tamsayı n, m ve k için, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    countBalancedSubsequences(2, 2, 2)\n    // 2 döndürür",
      "vi": "Viết một hàm JavaScript `function countBalancedSubsequences(n, m, k)` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    countBalancedSubsequences(2, 2, 2)\n    // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9905436048196911",
      "arb": "0.9863614421470015",
      "sw": "0.9844889535449856",
      "tr": "0.9464059478499285",
      "vi": "0.989467624045625"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2, 'Test case 1 failed');\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0, 'Test case 2 failed');\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4, 'Test case 3 failed');\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14, 'Test case 4 failed');\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35, 'Test case 5 failed');\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6, 'Test case 6 failed');\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6, 'Test case 7 failed');\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27, 'Test case 8 failed');\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110, 'Test case 9 failed');\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659, 'Test case 10 failed');\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648, 'Test case 11 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531, 'Test case 12 failed');\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485, 'Test case 13 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024, 'Test case 14 failed');\n})();",
    "entry_point": "countBalancedSubsequences",
    "signature": "function countBalancedSubsequences(n, m, k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    countBalancedSubsequences(2, 2, 2)\n    // returns 2",
      "es": "Dado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', de tal manera que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    countBalancedSubsequences(2, 2, 2)\n    // devuelve 2",
      "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن هو بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    countBalancedSubsequences(2, 2, 2)\n    // يعيد 2",
      "sw": "Kutolewa nambari tatu za mzima n, m, na k, pata idadi ya misururu inayojumuisha n '(' na m ')', kiasi kwamba mfuatano mrefu zaidi wenye usawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    countBalancedSubsequences(2, 2, 2)\n    // inarudisha 2",
      "tr": "Verilen üç tamsayı n, m ve k için, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    countBalancedSubsequences(2, 2, 2)\n    // 2 döndürür",
      "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    countBalancedSubsequences(2, 2, 2)\n    // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9876702177276403",
      "arb": "0.9594817858334552",
      "sw": "0.9908336051760019",
      "tr": "0.957806537199807",
      "vi": "0.9745494892779998"
    }
  },
  {
    "task_id": "JavaScript/42",
    "prompt": {
      "en": "\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left \n * corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations\n * to cut the paper such that the remaining area is less than k.\n * In each operation, a line is randomly chosen that is parallel to the axes, passes through points with\n * integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part\n * of the paper along this line is then discarded.\n * The answer should be modulo 10^9+7.\n *\n * For example:\n *    expectedCuts(3, 3, 4) // returns 3\n *    expectedCuts(5, 5, 12) // returns 2\n */\nfunction expectedCuts(n, m, k)",
      "es": "/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\n * En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\n * La respuesta debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *    expectedCuts(3, 3, 4) // devuelve 3\n *    expectedCuts(5, 5, 12) // devuelve 2\n */\nfunction expectedCuts(n, m, k)",
      "arb": "/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود زاويتها السفلية اليسرى \n * عند (0,0) وزاويتها العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات\n * لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\n * في كل عملية، يتم اختيار خط بشكل عشوائي يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة،\n * ويقطع الورقة (وليس فقط ملامسة الحافة). يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\n * يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *    expectedCuts(3, 3, 4) // يعيد 3\n *    expectedCuts(5, 5, 12) // يعيد 2\n */\nfunction expectedCuts(n, m, k)",
      "sw": "/**\n * Ukipewa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian na kona yake ya chini-kushoto \n * iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni\n * za kukata karatasi ili eneo linalobaki liwe chini ya k.\n * Katika kila operesheni, mstari huchaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye\n * kuratibu za nambari kamili, na hukata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu \n * kisha hutupwa.\n * Jibu linapaswa kuwa modulo 10^9+7.\n *\n * Kwa mfano:\n *    expectedCuts(3, 3, 4) // inarejesha 3\n *    expectedCuts(5, 5, 12) // inarejesha 2\n */\nfunction expectedCuts(n, m, k)",
      "tr": "/**\n * n x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. \n * Kalan alanın k'dan küçük olması için kağıdı kesmek için gereken beklenen işlem sayısını hesaplamanız gerekiyor.\n * Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. \n * Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\n * Cevap 10^9+7 modunda olmalıdır.\n *\n * Örneğin:\n *    expectedCuts(3, 3, 4) // 3 döndürür\n *    expectedCuts(5, 5, 12) // 2 döndürür\n */\nfunction expectedCuts(n, m, k)",
      "vi": "/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái\n * tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến\n * để cắt giấy sao cho diện tích còn lại nhỏ hơn k.\n * Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có\n * tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải\n * của tờ giấy dọc theo đường này sau đó bị loại bỏ.\n * Câu trả lời nên được lấy modulo 10^9+7.\n *\n * Ví dụ:\n *    expectedCuts(3, 3, 4) // trả về 3\n *    expectedCuts(5, 5, 12) // trả về 2\n */\nfunction expectedCuts(n, m, k)"
    },
    "prompt_bertscore": {
      "es": "0.968350632346663",
      "arb": "0.9617984119674652",
      "sw": "0.9636589827466189",
      "tr": "0.953855580290642",
      "vi": "0.9449589255240893"
    },
    "canonical_solution": "{\n    const MD = 1000000007;\n    const N = 1000000;\n    let vv = new Array(N * 2 + 2).fill(0);\n    let ans = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function expectedCuts(n, m, k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    expectedCuts(3, 3, 4) // returns 3\n    expectedCuts(5, 5, 12) // returns 2\n",
      "es": "Escribe una función de JavaScript `function expectedCuts(n, m, k)` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en el plano con su esquina inferior izquierda en (0,0) y su esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    expectedCuts(3, 3, 4) // devuelve 3\n    expectedCuts(5, 5, 12) // devuelve 2",
      "arb": "اكتب دالة JavaScript `function expectedCuts(n, m, k)` لحل المشكلة التالية:\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع ركنها السفلي الأيسر عند (0,0) وركنها العلوي الأيمن عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن يكون الجواب موديولو 10^9+7.\n\nعلى سبيل المثال:\n    expectedCuts(3, 3, 4) // يعيد 3\n    expectedCuts(5, 5, 12) // يعيد 2",
      "sw": "Andika kazi ya JavaScript `function expectedCuts(n, m, k)` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi hiyo ili eneo linalobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (sio tu kugusa ukingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    expectedCuts(3, 3, 4) // inarudisha 3\n    expectedCuts(5, 5, 12) // inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `function expectedCuts(n, m, k)` yazın. Aşağıdaki problemi çözmek için: \nBir dikdörtgen kağıt, n x m boyutunda, düzlem Kartezyen koordinat sistemine yerleştirilmiş ve sol alt köşesi (0,0), sağ üst köşesi (n,m) olan bir kağıt verildiğinde, kalan alanın k'dan küçük olması için kağıdı kesmek üzere beklenen işlem sayısını hesaplamanız gerekir. Her işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    expectedCuts(3, 3, 4) // 3 döndürür\n    expectedCuts(5, 5, 12) // 2 döndürür",
      "vi": "Viết một hàm JavaScript `function expectedCuts(n, m, k)` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    expectedCuts(3, 3, 4) // trả về 3\n    expectedCuts(5, 5, 12) // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9843089944197679",
      "arb": "0.9570870979596986",
      "sw": "0.9677144192362083",
      "tr": "0.9579996059301729",
      "vi": "0.957533420425884"
    },
    "level": "hard",
    "test": "function testExpectedCuts() {\n    console.assert(expectedCuts(2, 4, 10) === 0, 'Test 1 failed');\n    console.assert(expectedCuts(2, 4, 8) === 1, 'Test 2 failed');\n    console.assert(expectedCuts(2, 4, 2) === 833333342, 'Test 3 failed');\n    console.assert(expectedCuts(2, 4, 6) === 250000003, 'Test 4 failed');\n    console.assert(expectedCuts(3, 3, 4) === 666666673, 'Test 5 failed');\n    console.assert(expectedCuts(5, 5, 12) === 666666673, 'Test 6 failed');\n    console.assert(expectedCuts(6, 7, 20) === 722222229, 'Test 7 failed');\n    console.assert(expectedCuts(10, 10, 50) === 714285721, 'Test 9 failed');\n    console.assert(expectedCuts(1, 10, 5) === 945634929, 'Test 10 failed');\n    console.assert(expectedCuts(10, 1, 5) === 945634929, 'Test 11 failed');\n}\n\ntestExpectedCuts();",
    "entry_point": "expectedCuts",
    "signature": "function expectedCuts(n, m, k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    expectedCuts(3, 3, 4) // returns 3\n    expectedCuts(5, 5, 12) // returns 2\n",
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    expectedCuts(3, 3, 4) // devuelve 3\n    expectedCuts(5, 5, 12) // devuelve 2",
      "arb": "بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثي ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزواية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    expectedCuts(3, 3, 4) // يعيد 3\n    expectedCuts(5, 5, 12) // يعيد 2",
      "sw": "Kwa kupewa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa moduli ya 10^9+7.\n\nKwa mfano:\n    expectedCuts(3, 3, 4) // inarudisha 3\n    expectedCuts(5, 5, 12) // inarudisha 2",
      "tr": "Verilen bir n x m boyutunda dikdörtgen kağıt, alt sol köşesi (0,0) ve üst sağ köşesi (n,m) olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınarak verilmelidir.\n\nÖrneğin:\n    expectedCuts(3, 3, 4) // 3 döndürür\n    expectedCuts(5, 5, 12) // 2 döndürür",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời cần được tính theo modulo 10^9+7.\n\nVí dụ:\n    expectedCuts(3, 3, 4) // trả về 3\n    expectedCuts(5, 5, 12) // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9785089872935493",
      "arb": "0.9497957739326699",
      "sw": "0.9551341640533636",
      "tr": "0.9392441308313346",
      "vi": "0.9374214984549585"
    }
  },
  {
    "task_id": "JavaScript/43",
    "prompt": {
      "en": "\n/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "es": "/**\n * Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos\n * tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener\n * dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1\n * puntos de corte 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]).\n * El resultado debe ser módulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // devuelve 2\n */\nconst countPermutations = (n, k, q) => {",
      "arb": "/**\n * بالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد التباديل p من n عنصر\n * بحيث يكون f(p) = q، حيث أن f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق\n * تقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي اختيار k-1\n * نقاط تقطيع 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]).\n * يجب أن تكون النتيجة موديولو 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // يعيد 2\n */\nconst countPermutations = (n, k, q) => {",
      "sw": "/**\n * Ukipewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n\n * kama kwamba f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa\n * kugawanya p katika sehemu k zisizo tupu zinazoendelea na kupanga kila sehemu (yaani, chagua k-1\n * sehemu za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Matokeo yanapaswa kuwa modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // inarudisha 2\n */\nconst countPermutations = (n, k, q) => {",
      "tr": "/**\n * n elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, n elemanlı p permütasyonlarının sayısını bulun\n * öyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak\n * elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n, ve bunu [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\n * Sonuç 998244353 ile mod alınmış olmalıdır.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // 2 döndürür\n */\nconst countPermutations = (n, k, q) => {",
      "vi": "/**\n * Cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử\n * sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách\n * chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1\n * điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia nó thành [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Kết quả nên được lấy modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // trả về 2\n */\nconst countPermutations = (n, k, q) => {"
    },
    "prompt_bertscore": {
      "es": "0.988226184164157",
      "arb": "0.9771416157505051",
      "sw": "0.9696037914206121",
      "tr": "0.9753167984399376",
      "vi": "0.9803788937006117"
    },
    "canonical_solution": "const P = 998244353;\n    let dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc = new Array(n + 1).fill(0);\n    let f = new Array(n + 1).fill(0);\n    \n    dp[0][0] = f[0] = jc[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n    \n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n    \n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n    \n    return ans;\n};",
    "instruction": {
      "en": "Write a JavaScript function `const countPermutations = (n, k, q) =>` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n\n @example\n countPermutations(2, 1, [1, 2])\n // returns 2\n",
      "es": "Escribe una función de JavaScript `const countPermutations = (n, k, q) =>` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos\ntal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener\ndividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1\npuntos de ruptura 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]).\nEl resultado debe ser módulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// devuelve 2",
      "arb": "اكتب دالة JavaScript `const countPermutations = (n, k, q) =>` لحل المشكلة التالية:\nبالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد التباديل p من n عنصر\nبحيث يكون f(p) = q، حيث أن f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق\nتقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي اختيار k-1\nنقاط توقف 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]).\nيجب أن تكون النتيجة موديولو 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// يعيد 2",
      "sw": "Andika kazi ya JavaScript `const countPermutations = (n, k, q) =>` kutatua tatizo lifuatalo:\nUkipiwa mpangilio q wa vipengele n na nambari kamili k, pata idadi ya mipangilio p ya vipengele n\nkama kwamba f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa\nkugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu (yaani, chagua k-1\nalama za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\nMatokeo yanapaswa kuwa modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `const countPermutations = (n, k, q) =>` yazın, aşağıdaki problemi çözmek için:\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, n elemanlı p permütasyonlarının sayısını bulun\nöyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık segmentlere bölerek ve her segmenti sıralayarak\nelde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane\n1 <= x1 < x2 < ... < x(k-1) < n kesme noktası seçin ve [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\nSonuç 998244353 ile mod alınmalıdır.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 2 döndürür",
      "vi": "Viết một hàm JavaScript `const countPermutations = (n, k, q) =>` để giải quyết vấn đề sau:  \nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia thành [1, x1], (x1, x2], ..., (x(k-1), n]). Kết quả nên được lấy modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9975316202548794",
      "arb": "0.9820571217899754",
      "sw": "0.9818565051051302",
      "tr": "0.9772784720830381",
      "vi": "0.9809205587496939"
    },
    "level": "hard",
    "test": "console.assert(countPermutations(2, 1, [1, 2]) === 2, 'Test failed for input ([1, 2])');\nconsole.assert(countPermutations(3, 3, [3, 1, 2]) === 1, 'Test failed for input ([3, 1, 2])');\nconsole.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13, 'Test failed for input ([1, 2, 3, 6, 5, 4])');\nconsole.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720, 'Test failed for input ([1, 2, 3, 4, 5, 6])');\nconsole.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0, 'Test failed for input ([1, 2, 5, 3, 4, 5])');\nconsole.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1, 'Test failed for input ([1, 2, 3, 4, 5, 6, 7, 8, 9])');\nconsole.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093);",
    "entry_point": "countPermutations",
    "signature": "const countPermutations = (n, k, q) =>",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n\n @example\n countPermutations(2, 1, [1, 2])\n // returns 2\n",
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de corte 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]). El resultado debe ser módulo 998244353.\n\n @example\n countPermutations(2, 1, [1, 2])\n // devuelve 2",
      "arb": "بالنظر إلى تبديل q يحتوي على n من العناصر وعدد صحيح k، ابحث عن عدد التبديلات p التي تحتوي على n من العناصر بحيث أن f(p) = q، حيث أن f(p) هو التبديل الأصغر ترتيبًا لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى بالضبط k من المقاطع المتجاورة غير الفارغة وترتيب كل مقطع (أي اختيار k-1 من نقاط التقسيم 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]). يجب أن تكون النتيجة مودولو 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// يعيد 2",
      "sw": "Ukipiwa mpangilio q wa vipengele n na nambari kamili k, pata idadi ya mipangilio p ya vipengele n\n kama f(p) = q, ambapo f(p) ni mpangilio mdogo kabisa wa lexicographically ambao unaweza kupatikana kwa\n kugawanya p katika sehemu k hasa zisizo tupu na kupanga kila sehemu (yaani, chagua k-1\n sehemu za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\n Matokeo yanapaswa kuwa modulo 998244353.\n\n @mfano\n countPermutations(2, 1, [1, 2])\n // inarudisha 2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, n elemanlı p permütasyonlarının sayısını bulun\n öyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak\n elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n, ve [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\n Sonuç 998244353 ile mod alınmalıdır.\n\n @örnek\n countPermutations(2, 1, [1, 2])\n // 2 döndürür",
      "vi": "Cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia thành [1, x1], (x1, x2], ..., (x(k-1), n]). Kết quả nên được lấy modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9843971863089475",
      "arb": "0.9847948443317793",
      "sw": "0.9629170982734536",
      "tr": "0.9739659132185193",
      "vi": "1"
    }
  },
  {
    "task_id": "JavaScript/44",
    "prompt": {
      "en": "\n/**\n * Determines the number of ways to choose a triplet (a, b, c) \n * from an array of distinct integers representing heights such that the \n * greatest common divisor (GCD) of the maximum and minimum values \n * of the triplet is 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights)",
      "es": "/**\n * Determina el número de maneras de elegir un triplete (a, b, c) \n * de un arreglo de enteros distintos que representan alturas tal que el \n * máximo común divisor (MCD) de los valores máximo y mínimo \n * del triplete sea 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Devuelve: 1\n */\nfunction countTriplets(heights)",
      "arb": "/**\n * يحدد عدد الطرق لاختيار ثلاثية (a, b, c) \n * من مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون \n * القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى \n * للثلاثية هو 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // يعيد: 1\n */\nfunction countTriplets(heights)",
      "sw": "/**\n * Huamua idadi ya njia za kuchagua tatu (a, b, c) \n * kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili kwamba \n * mgawanyiko mkuu wa kawaida (GCD) wa thamani ya juu na ya chini \n * ya tatu ni 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Inarudisha: 1\n */\nfunction countTriplets(heights)",
      "tr": "/**\n * Bir dizideki farklı tamsayıları temsil eden yüksekliklerden \n * (a, b, c) üçlüsünü seçmenin yollarını belirler, \n * bu üçlünün maksimum ve minimum değerlerinin \n * en büyük ortak böleni (GCD) 1 olacak şekilde.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Döndürür: 1\n */\nfunction countTriplets(heights)",
      "vi": "/**\n * Xác định số cách chọn một bộ ba (a, b, c) \n * từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho \n * ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất \n * của bộ ba là 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Trả về: 1\n */\nfunction countTriplets(heights)"
    },
    "prompt_bertscore": {
      "es": "0.9981114223371202",
      "arb": "1",
      "sw": "0.9355764208455254",
      "tr": "0.9588531206774799",
      "vi": "0.9834489248698869"
    },
    "canonical_solution": "{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countTriplets(heights)` to solve the following problem:\nDetermines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "es": "Escribe una función de JavaScript `function countTriplets(heights)` para resolver el siguiente problema:\nDetermina el número de formas de elegir un triplete (a, b, c) de un arreglo de enteros distintos que representan alturas, tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Devuelve: 1",
      "arb": "اكتب دالة JavaScript `function countTriplets(heights)` لحل المشكلة التالية:\nتحديد عدد الطرق لاختيار ثلاثية (a, b, c) من مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى للثلاثية هو 1.\n\n@example\ncountTriplets([1, 5, 7])\n// يعيد: 1",
      "sw": "Andika kazi ya JavaScript `function countTriplets(heights)` kutatua tatizo lifuatalo:  \nInabainisha idadi ya njia za kuchagua tatu (a, b, c) kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili kwamba mgawanyiko mkuu wa juu zaidi (GCD) wa thamani za juu na za chini za tatu hiyo ni 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Inarudisha: 1",
      "tr": "Bir JavaScript fonksiyonu `function countTriplets(heights)` yazın ve aşağıdaki problemi çözün:\nBir dizi farklı tamsayıdan yükseklikleri temsil eden bir üçlü (a, b, c) seçmenin kaç yolu olduğunu belirler, böylece üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olur.\n\n@example\ncountTriplets([1, 5, 7])\n// Döndürür: 1",
      "vi": "Viết một hàm JavaScript `function countTriplets(heights)` để giải quyết vấn đề sau:  \nXác định số cách chọn một bộ ba (a, b, c) từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Trả về: 1"
    },
    "instruction_bertscore": {
      "es": "0.9877856219790216",
      "arb": "0.9900416658468159",
      "sw": "0.9529172503706332",
      "tr": "0.9686030915609584",
      "vi": "0.9783453158595765"
    },
    "level": "hard",
    "test": "const main = () => {\n    console.assert(countTriplets([1, 5, 7]) === 1);\n    console.assert(countTriplets([1, 6, 2, 3]) === 3);\n    console.assert(countTriplets([16, 4, 8, 2]) === 0);\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77);\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7);\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104);\n    console.assert(countTriplets([3, 7, 11, 13]) === 4);\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10);\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87);\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122);\n}\n\nmain();",
    "entry_point": "countTriplets",
    "signature": "function countTriplets(heights)",
    "docstring": {
      "en": "Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "es": "Determina el número de maneras de elegir un triplete (a, b, c) de un arreglo de enteros distintos que representan alturas tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Devuelve: 1",
      "arb": "يحدد عدد الطرق لاختيار ثلاثية (a, b, c) من مصفوفة من الأعداد الصحيحة المختلفة التي تمثل الارتفاعات بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى للثلاثية هو 1.\n\n@example\ncountTriplets([1, 5, 7])\n// يعيد: 1",
      "sw": "Inabainisha idadi ya njia za kuchagua tatu (a, b, c) kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili kwamba mgawanyiko mkuu wa juu (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Inarejesha: 1",
      "tr": "Belirli yükseklikleri temsil eden farklı tamsayıların bulunduğu bir diziden bir üçlü (a, b, c) seçmenin kaç yolu olduğunu belirler, öyle ki üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1'dir.\n\n@example\ncountTriplets([1, 5, 7])\n// Döndürür: 1",
      "vi": "Xác định số cách để chọn một bộ ba (a, b, c) từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Trả về: 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9949263841772259",
      "sw": "0.8932872182016736",
      "tr": "0.9764670669765105",
      "vi": "0.9843580561238836"
    }
  },
  {
    "task_id": "JavaScript/45",
    "prompt": {
      "en": "\n/**\n * Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all \n * connected pixels of the same color to a chosen color, where two pixels are connected if they are \n * adjacent and have the same color. The goal is to find the minimum number of operations required \n * to make all pixels the same color.\n * Note: For each color, there are at most 20 pixels of that color.\n * \n * Examples:\n *    extraNumber(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction minOperations(n, pixels)",
      "es": "/**\n * Dada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un entero. Puedes cambiar todos\n * los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son\n * adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones requeridas\n * para hacer que todos los píxeles sean del mismo color.\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n * \n * Ejemplos:\n *    extraNumber(5, [1, 2, 3, 2, 1]) devuelve 2\n */\nfunction minOperations(n, pixels)",
      "arb": "/**\n * معطى صورة بكسل بحجم 1 في n، كل بكسل له لون ممثل برقم صحيح. يمكنك تغيير جميع \n * البكسلات المتصلة من نفس اللون إلى لون مختار، حيث يكون البكسلان متصلان إذا كانا \n * متجاورين ولهما نفس اللون. الهدف هو العثور على الحد الأدنى من العمليات المطلوبة \n * لجعل جميع البكسلات بنفس اللون.\n * ملاحظة: لكل لون، هناك على الأكثر 20 بكسل من ذلك اللون.\n * \n * أمثلة:\n *    extraNumber(5, [1, 2, 3, 2, 1]) يعيد 2\n */ \nfunction minOperations(n, pixels)",
      "sw": "/**\n * Ukipewa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kubadilisha \n * pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa \n * ikiwa ziko karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika \n * kufanya pikseli zote ziwe na rangi sawa.\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n * \n * Mifano:\n *    extraNumber(5, [1, 2, 3, 2, 1]) inarudisha 2\n */\nfunction minOperations(n, pixels)",
      "tr": "/**\n * 1'e n piksel görüntüsü verildiğinde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. \n * Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel \n * bitişik ve aynı renkte ise bağlı kabul edilir. Amaç, tüm pikselleri aynı renkte yapmak için \n * gereken minimum işlem sayısını bulmaktır.\n * Not: Her renk için en fazla 20 piksel vardır.\n * \n * Örnekler:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 döndürür\n */\nfunction minOperations(n, pixels)",
      "vi": "/**\n * Cho một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả\n * các pixel kết nối có cùng màu thành một màu đã chọn, trong đó hai pixel được kết nối nếu chúng\n * liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết\n * để làm cho tất cả các pixel có cùng màu.\n * Lưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n * \n * Ví dụ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) trả về 2\n */\nfunction minOperations(n, pixels)"
    },
    "prompt_bertscore": {
      "es": "0.9939360130973859",
      "arb": "0.9999996027392379",
      "sw": "0.9648011074375695",
      "tr": "0.9699684768001922",
      "vi": "0.9947227880366651"
    },
    "canonical_solution": "{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function minOperations(n, pixels)` to solve the following problem:\nGiven a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\nextraNumber(5, [1, 2, 3, 2, 1]) returns 2",
      "es": "Escribe una función de JavaScript `function minOperations(n, pixels)` para resolver el siguiente problema:\nDada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un número entero. Puedes cambiar todos los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\nextraNumber(5, [1, 2, 3, 2, 1]) devuelve 2",
      "arb": "اكتب دالة JavaScript `function minOperations(n, pixels)` لحل المشكلة التالية:\nبالنظر إلى صورة بحجم 1 في n بكسل، كل بكسل له لون ممثل برقم صحيح. يمكنك تغيير جميع البكسلات المتصلة بنفس اللون إلى لون مختار، حيث يكون البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\nextraNumber(5, [1, 2, 3, 2, 1]) يعيد 2",
      "sw": "Andika kazi ya JavaScript `function minOperations(n, pixels)` kutatua tatizo lifuatalo:\nUkipiwa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa zipo karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\nextraNumber(5, [1, 2, 3, 2, 1]) inarudisha 2",
      "tr": "Bir JavaScript fonksiyonu `function minOperations(n, pixels)` yazın ve aşağıdaki problemi çözün:\n1'e n piksel görüntü verildiğinde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel bitişik ve aynı renkte ise bağlıdır. Amaç, tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulmaktır.\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 döndürür",
      "vi": "Viết một hàm JavaScript `function minOperations(n, pixels)` để giải quyết vấn đề sau:\nCho một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả các pixel kết nối có cùng màu sang một màu đã chọn, trong đó hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\nextraNumber(5, [1, 2, 3, 2, 1]) trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9991123208271551",
      "arb": "0.9773763968608883",
      "sw": "0.977778623382484",
      "tr": "0.9691135716402179",
      "vi": "0.987748080837006"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2);\n    console.assert(minOperations(4, [1, 1, 2, 2]) === 1);\n    console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3);\n    console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0);\n    console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1);\n    console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2);\n    console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1);\n    console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8);\n    console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5);\n    console.assert(minOperations(3, [3, 3, 3]) === 0);\n    console.assert(minOperations(4, [2, 1, 1, 2]) === 1);\n})();",
    "entry_point": "minOperations",
    "signature": "function minOperations(n, pixels)",
    "docstring": {
      "en": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\nextraNumber(5, [1, 2, 3, 2, 1]) returns 2",
      "es": "Dada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un número entero. Puedes cambiar todos los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\nextraNumber(5, [1, 2, 3, 2, 1]) devuelve 2",
      "arb": "نظرًا لصورة مكونة من 1 في n بكسل، كل بكسل له لون يمثله عدد صحيح. يمكنك تغيير جميع البكسلات المتصلة من نفس اللون إلى لون مختار، حيث يعتبر بكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى من العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\nextraNumber(5, [1, 2, 3, 2, 1]) يعيد 2",
      "sw": "Dokezo: Picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari kamili. Unaweza kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika ili kufanya pikseli zote ziwe na rangi sawa. \nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\nextraNumber(5, [1, 2, 3, 2, 1]) inarudisha 2",
      "tr": "Verilen 1'e n piksel görüntüsünde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Amaç, tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulmaktır.\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 döndürür",
      "vi": "Đưa ra một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả các pixel kết nối có cùng màu sang một màu được chọn, trong đó hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\nLưu ý: Đối với mỗi màu, có nhiều nhất 20 pixel của màu đó.\n\nVí dụ:\nextraNumber(5, [1, 2, 3, 2, 1]) trả về 2"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.962395097632094",
      "sw": "0.9478392646794763",
      "tr": "0.966602684993556",
      "vi": "0.9944361643968318"
    }
  },
  {
    "task_id": "JavaScript/46",
    "prompt": {
      "en": "\n/**\n * Given an integer n, write a function to compute the sum of all numbers from 1 to n\n * that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\n * it should only be counted once.\n * For example:\n *     sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "es": "/**\n * Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n\n * que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5,\n * solo debe contarse una vez.\n * Por ejemplo:\n *     sumOfMultiples(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "arb": "/**\n * بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n\n * التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5،\n * يجب أن يُحسب مرة واحدة فقط.\n * على سبيل المثال:\n *     sumOfMultiples(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "sw": "/**\n * Ukipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n\n * ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5,\n * inapaswa kuhesabiwa mara moja tu.\n * Kwa mfano:\n *     sumOfMultiples(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "tr": "/**\n * Verilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın.\n * Bir sayı hem 3'ün hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n * Örneğin:\n *     sumOfMultiples(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "vi": "/**\n * Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n\n * mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5,\n * nó chỉ nên được tính một lần.\n * Ví dụ:\n *     sumOfMultiples(10); // trả về 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)"
    },
    "prompt_bertscore": {
      "es": "0.9923449837452964",
      "arb": "0.9960913513619954",
      "sw": "0.9915083525803775",
      "tr": "0.9487287315257505",
      "vi": "0.9866325726171141"
    },
    "canonical_solution": "{\n    let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function sumOfMultiples(n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "es": "Escribe una función de JavaScript `function sumOfMultiples(n)` para resolver el siguiente problema:\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    sumOfMultiples(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)",
      "arb": "اكتب دالة JavaScript `function sumOfMultiples(n)` لحل المشكلة التالية:\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    sumOfMultiples(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)",
      "sw": "Andika kazi ya JavaScript `function sumOfMultiples(n)` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni marudufu ya 3 au 5. Ikiwa nambari ni marudufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    sumOfMultiples(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)",
      "tr": "Bir JavaScript fonksiyonu `function sumOfMultiples(n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı n için, 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    sumOfMultiples(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)",
      "vi": "Viết một hàm JavaScript `function sumOfMultiples(n)` để giải quyết vấn đề sau:  \nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.  \nVí dụ:  \n    sumOfMultiples(10); // trả về 33 (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "es": "0.9927915048418628",
      "arb": "0.9961793446207939",
      "sw": "0.9918039145873574",
      "tr": "0.9578170646100018",
      "vi": "0.9882982869924727"
    },
    "level": "easy",
    "test": "const testSumOfMultiples = () => {\n    console.assert(sumOfMultiples(10) === 33, 'Test case n=10 failed');\n    console.assert(sumOfMultiples(15) === 60, 'Test case n=15 failed');\n    console.assert(sumOfMultiples(20) === 98, 'Test case n=20 failed');\n    console.assert(sumOfMultiples(5) === 8, 'Test case n=5 failed');\n    console.assert(sumOfMultiples(3) === 3, 'Test case n=3 failed');\n    console.assert(sumOfMultiples(6) === 14, 'Test case n=6 failed');\n    console.assert(sumOfMultiples(9) === 23, 'Test case n=9 failed');\n    console.assert(sumOfMultiples(12) === 45, 'Test case n=12 failed');\n    console.assert(sumOfMultiples(17) === 60, 'Test case n=17 failed');\n    console.assert(sumOfMultiples(21) === 119, 'Test case n=21 failed');\n    console.assert(sumOfMultiples(25) === 168, 'Test case n=25 failed');\n};\n\ntestSumOfMultiples();",
    "entry_point": "sumOfMultiples",
    "signature": "function sumOfMultiples(n)",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, debe contarse solo una vez.  \nPor ejemplo:  \n    sumOfMultiples(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)",
      "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي من مضاعفات إما 3 أو 5. إذا كان الرقم من مضاعفات كل من 3 و5، فيجب احتسابه مرة واحدة فقط.  \nعلى سبيل المثال:  \n    sumOfMultiples(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)",
      "sw": "Ukipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    sumOfMultiples(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)",
      "tr": "Verilen bir tamsayı n için, 1'den n'e kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katı ise, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    sumOfMultiples(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)",
      "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\nVí dụ:\n    sumOfMultiples(10); // trả về 33 (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "es": "0.9887452053498011",
      "arb": "0.9941972120484468",
      "sw": "0.9887452053498011",
      "tr": "0.983227054734271",
      "vi": "0.9861052089554665"
    }
  },
  {
    "task_id": "JavaScript/47",
    "prompt": {
      "en": "\n/**\n * Determine if a given string is a palindrome.\n * A palindrome is a word, phrase, number, or other sequence of characters\n * that reads the same forward and backward (ignoring spaces, punctuation,\n * and capitalization).\n * \n * Examples:\n * isPalindrome(\"racecar\") // returns true\n * isPalindrome(\"hello\") // returns false\n */\nfunction isPalindrome(str)",
      "es": "/**\n * Determinar si una cadena dada es un palíndromo.\n * Un palíndromo es una palabra, frase, número u otra secuencia de caracteres\n * que se lee igual de adelante hacia atrás (ignorando espacios, puntuación\n * y mayúsculas).\n * \n * Ejemplos:\n * isPalindrome(\"racecar\") // devuelve true\n * isPalindrome(\"hello\") // devuelve false\n */\nfunction isPalindrome(str)",
      "arb": "/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة.\n * الكلمة المتطابقة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف\n * الذي يقرأ نفسه من الأمام إلى الخلف والعكس صحيح (مع تجاهل المسافات وعلامات الترقيم\n * والحروف الكبيرة).\n * \n * أمثلة:\n * isPalindrome(\"racecar\") // يعيد true\n * isPalindrome(\"hello\") // يعيد false\n */\nfunction isPalindrome(str)",
      "sw": "/**\n * Tambua kama string iliyotolewa ni palindrome.\n * Palindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi\n * ambao unasomeka sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji,\n * na herufi kubwa na ndogo).\n * \n * Mifano:\n * isPalindrome(\"racecar\") // inarudisha true\n * isPalindrome(\"hello\") // inarudisha false\n */\nfunction isPalindrome(str)",
      "tr": "/**\n * Verilen bir stringin palindrom olup olmadığını belirleyin.\n * Palindrom, ileri ve geri okunduğunda aynı olan (boşluk, noktalama işaretleri\n * ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n * \n * Örnekler:\n * isPalindrome(\"racecar\") // true döndürür\n * isPalindrome(\"hello\") // false döndürür\n */\nfunction isPalindrome(str)",
      "vi": "/**\n * Xác định xem một chuỗi cho trước có phải là chuỗi đối xứng hay không.\n * Chuỗi đối xứng là một từ, cụm từ, số, hoặc một chuỗi ký tự khác\n * mà khi đọc từ trái sang phải và từ phải sang trái đều giống nhau (bỏ qua khoảng trắng, dấu câu,\n * và chữ hoa chữ thường).\n * \n * Ví dụ:\n * isPalindrome(\"racecar\") // trả về true\n * isPalindrome(\"hello\") // trả về false\n */\nfunction isPalindrome(str)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9992515607242606",
      "sw": "0.9976243806428228",
      "tr": "0.9759085183450404",
      "vi": "0.9975252640826864"
    },
    "canonical_solution": "{\n  let start = 0;\n  let end = str.length - 1;\n\n  while (start < end) {\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while (!isalnum(str[start]) && start < end) start++;\n    while (!isalnum(str[end]) && start < end) end--;\n    if (str[start].toLowerCase() !== str[end].toLowerCase())\n      return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\n// Helper function to check if a character is alphanumeric\nfunction isalnum(char) {\n  let code = char.charCodeAt(0);\n  return (code > 47 && code < 58) || // numeric (0-9)\n         (code > 64 && code < 91) || // upper alpha (A-Z)\n         (code > 96 && code < 123);  // lower alpha (a-z)\n}",
    "instruction": {
      "en": "Write a JavaScript function `function isPalindrome(str)` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\nisPalindrome(\"hello\") // returns false",
      "es": "Escribe una función de JavaScript `function isPalindrome(str)` para resolver el siguiente problema:  \nDeterminar si una cadena dada es un palíndromo.  \nUn palíndromo es una palabra, frase, número u otra secuencia de caracteres  \nque se lee igual de adelante hacia atrás (ignorando espacios, puntuación  \ny mayúsculas).\n\nEjemplos:  \nisPalindrome(\"racecar\") // devuelve true  \nisPalindrome(\"hello\") // devuelve false",
      "arb": "اكتب دالة JavaScript `function isPalindrome(str)` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة.\nالكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف\nيُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم،\nوحالة الأحرف).\n\nأمثلة:\nisPalindrome(\"racecar\") // يعيد true\nisPalindrome(\"hello\") // يعيد false",
      "sw": "Andika kazi ya JavaScript `function isPalindrome(str)` kutatua tatizo lifuatalo:  \nTambua kama mfuatano wa herufi uliopewa ni palindrome.  \nPalindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi  \nambao unasomeka sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji,  \nna herufi kubwa na ndogo).\n\nMifano:  \nisPalindrome(\"racecar\") // inarejesha true  \nisPalindrome(\"hello\") // inarejesha false",
      "tr": "Bir JavaScript fonksiyonu `function isPalindrome(str)` yazın:\nVerilen bir stringin palindrom olup olmadığını belirleyin.\nPalindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\nÖrnekler:\nisPalindrome(\"racecar\") // true döndürür\nisPalindrome(\"hello\") // false döndürür",
      "vi": "Viết một hàm JavaScript `function isPalindrome(str)` để giải quyết vấn đề sau:  \nXác định xem một chuỗi đã cho có phải là một palindrome hay không.  \nMột palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và phân biệt chữ hoa chữ thường).\n\nVí dụ:  \nisPalindrome(\"racecar\") // trả về true  \nisPalindrome(\"hello\") // trả về false  "
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9868325934108162",
      "tr": "0.9622969742238627",
      "vi": "0.9860831609831716"
    },
    "level": "hard",
    "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome(\"A man a plan a canal Panama\") === true, \"Test 1 failed\");\n  console.assert(isPalindrome(\"No lemon, no melon\") === true, \"Test 2 failed\");\n  console.assert(isPalindrome(\"Was it a car or a cat I saw\") === true, \"Test 3 failed\");\n  console.assert(isPalindrome(\"Madam, in Eden, I'm Adam\") === true, \"Test 4 failed\");\n  console.assert(isPalindrome(\"Never odd or even\") === true, \"Test 5 failed\");\n  console.assert(isPalindrome(\"Eva, can I see bees in a cave\") === true, \"Test 6 failed\");\n  console.assert(isPalindrome(\"hello\") === false, \"Test 7 failed\");\n  console.assert(isPalindrome(\"GitHub\") === false, \"Test 8 failed\");\n  console.assert(isPalindrome(\"programming\") === false, \"Test 9 failed\");\n};\n\ntestIsPalindrome();",
    "entry_point": "isPalindrome",
    "signature": "function isPalindrome(str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\nisPalindrome(\"hello\") // returns false",
      "es": "Determinar si una cadena dada es un palíndromo.  \nUn palíndromo es una palabra, frase, número u otra secuencia de caracteres  \nque se lee igual de adelante hacia atrás (ignorando espacios, puntuación  \ny mayúsculas).\n\nEjemplos:  \nisPalindrome(\"racecar\") // devuelve true  \nisPalindrome(\"hello\") // devuelve false  ",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي جملة متناظرة.\nالجملة المتناظرة هي كلمة، أو عبارة، أو رقم، أو تسلسل آخر من الأحرف\nيُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم،\nوحالة الأحرف).\n\nأمثلة:\nisPalindrome(\"racecar\") // يُرجع true\nisPalindrome(\"hello\") // يُرجع false",
      "sw": "Amua ikiwa kamba iliyotolewa ni palindrome.  \nPalindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi  \nambazo zinasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji,  \nna herufi kubwa na ndogo).\n\nMifano:  \nisPalindrome(\"racecar\") // inarudisha true  \nisPalindrome(\"hello\") // inarudisha false  ",
      "tr": "Belirtilen bir dizgenin palindrom olup olmadığını belirleyin.  \nPalindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\nÖrnekler:  \nisPalindrome(\"racecar\") // true döndürür  \nisPalindrome(\"hello\") // false döndürür",
      "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không.  \nMột chuỗi palindrome là một từ, cụm từ, số, hoặc một dãy ký tự khác  \nmà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu,  \nvà chữ hoa chữ thường).\n\nVí dụ:\nisPalindrome(\"racecar\") // trả về true\nisPalindrome(\"hello\") // trả về false"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9822223822669964",
      "sw": "0.9968254892503005",
      "tr": "0.9820871149775117",
      "vi": "0.9974277365655982"
    }
  },
  {
    "task_id": "JavaScript/48",
    "prompt": {
      "en": "\n/**\n * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n * For example:\n *   addDigits(38)  // returns 2\n *   Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n */\nfunction addDigits(num)",
      "es": "/**\n * Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\n * Por ejemplo:\n *   addDigits(38)  // devuelve 2\n *   Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n */\nfunction addDigits(num)",
      "arb": "/**\n * بالنظر إلى عدد صحيح غير سالب، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\n * على سبيل المثال:\n *   addDigits(38)  // يعيد 2\n *   الشرح: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.\n */\nfunction addDigits(num)",
      "sw": "/**\n * Ukipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\n * Kwa mfano:\n *   addDigits(38)  // inarudisha 2\n *   Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n */\nfunction addDigits(num)",
      "tr": "/**\n * Verilen negatif olmayan bir tam sayı num için, sonucu tek basamaklı olana kadar tüm basamaklarını tekrar tekrar topla.\n * Örneğin:\n *   addDigits(38)  // 2 döndürür\n *   Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.\n */\nfunction addDigits(num)",
      "vi": "/**\n * Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\n * Ví dụ:\n *   addDigits(38)  // trả về 2\n *   Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n */\nfunction addDigits(num)"
    },
    "prompt_bertscore": {
      "es": "0.9924633674523933",
      "arb": "0.9779774523938999",
      "sw": "0.9917929899164005",
      "tr": "0.9564522752619111",
      "vi": "0.966306527095433"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function addDigits(num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "es": "Escribe una función de JavaScript `function addDigits(num)` para resolver el siguiente problema:  \nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.  \nPor ejemplo:  \n  addDigits(38)  // devuelve 2  \n  Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "اكتب دالة JavaScript `function addDigits(num)` لحل المشكلة التالية:\nمعطى عدد صحيح غير سالب num، قم بجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n  addDigits(38)  // يعيد 2\n  التفسير: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Andika kazi ya JavaScript `function addDigits(num)` kutatua tatizo lifuatalo:\nUkipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n  addDigits(38)  // inarudisha 2\n  Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Bir JavaScript fonksiyonu `function addDigits(num)` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tamsayı num için, sonucu tek basamaklı olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n  addDigits(38)  // 2 döndürür\n  Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.",
      "vi": "Viết một hàm JavaScript `function addDigits(num)` để giải quyết vấn đề sau:  \nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n  addDigits(38)  // trả về 2  \n  Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9851861461824181",
      "sw": "0.9937741293368425",
      "tr": "0.9567216180585945",
      "vi": "0.9949891513776329"
    },
    "level": "easy",
    "test": "const testAddDigits = () => {\n    console.assert(addDigits(38) === 2, 'Test 1 failed');\n    console.assert(addDigits(0) === 0, 'Test 2 failed');\n    console.assert(addDigits(9) === 9, 'Test 3 failed');\n    console.assert(addDigits(123) === 6, 'Test 4 failed');\n    console.assert(addDigits(456) === 6, 'Test 5 failed');\n    console.assert(addDigits(9999) === 9, 'Test 6 failed');\n    console.assert(addDigits(100) === 1, 'Test 7 failed');\n    console.assert(addDigits(1010) === 2, 'Test 8 failed');\n    console.assert(addDigits(1234) === 1, 'Test 9 failed');\n    console.assert(addDigits(9876) === 3, 'Test 10 failed');\n    console.assert(addDigits(199) === 1, 'Test 11 failed');\n};\n\ntestAddDigits();",
    "entry_point": "addDigits",
    "signature": "function addDigits(num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n  addDigits(38)  // devuelve 2\n  Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "بالنظر إلى عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقماً واحداً فقط.\nعلى سبيل المثال:\n  addDigits(38)  // يعيد 2\n  التوضيح: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Ukipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.  \nKwa mfano:  \n  addDigits(38)  // inarudisha 2  \n  Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Verilen negatif olmayan bir tam sayı num için, sonucu yalnızca bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.  \nÖrneğin:  \n  addDigits(38)  // 2 döndürür  \n  Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n  addDigits(38)  // trả về 2  \n  Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "docstring_bertscore": {
      "es": "0.9903282894866492",
      "arb": "0.9712097180512792",
      "sw": "0.9999996027392379",
      "tr": "0.9732687205810868",
      "vi": "0.9597636423441437"
    }
  },
  {
    "task_id": "JavaScript/49",
    "prompt": {
      "en": "\n/**\n * You are playing a game called Nim. In this game, you start with a pile\n * of n stones, and you and your opponent take turns to remove 1 to 3\n * stones from the pile. The one who removes the last stone wins the game.\n * Given the number of stones n, determine if you can win the game if both\n * you and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *   canWinNim(1) // returns true\n */\nfunction canWinNim(n)",
      "es": "/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con un montón\n * de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3\n * piedras del montón. El que quita la última piedra gana el juego.\n * Dado el número de piedras n, determina si puedes ganar el juego si ambos\n * tú y tu oponente juegan de manera óptima.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *   canWinNim(1) // devuelve true\n */\nfunction canWinNim(n)",
      "arb": "/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة،\n * وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل\n * الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك\n * الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * إليك بعض الحالات:\n *   canWinNim(1) // يعيد true\n */\nfunction canWinNim(n)",
      "sw": "/**\n * Unacheza mchezo uitwao Nim. Katika mchezo huu, unaanza na rundo\n * la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3\n * kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo.\n * Ukizingatia idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote\n * wewe na mpinzani wako mna cheza kwa umahiri.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hapa kuna baadhi ya kesi:\n *   canWinNim(1) // inarudisha kweli\n */\nfunction canWinNim(n)",
      "tr": "/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla\n * başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş\n * çıkarırsınız. Son taşı çıkaran oyunu kazanır.\n * Taş sayısı n verildiğinde, eğer hem siz hem de rakibiniz optimal\n * oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *   canWinNim(1) // true döndürür\n */\nfunction canWinNim(n)",
      "vi": "/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với\n * một đống n viên đá, và bạn cùng đối thủ của mình lần lượt lấy đi từ 1 đến 3\n * viên đá từ đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi.\n * Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và\n * đối thủ đều chơi tối ưu.\n * Lưu ý: Bạn luôn đi trước.\n *\n * Dưới đây là một số trường hợp:\n *   canWinNim(1) // trả về true\n */\nfunction canWinNim(n)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9773934790736573",
      "sw": "0.9944931713161888",
      "tr": "0.9742382354709181",
      "vi": "0.9781975348560865"
    },
    "canonical_solution": "{\n    return n % 4 !== 0;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function canWinNim(n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true",
      "es": "Escribe una función de JavaScript `function canWinNim(n)` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n  canWinNim(1) // devuelve true",
      "arb": "اكتب دالة JavaScript `function canWinNim(n)` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n  canWinNim(1) // يعيد true",
      "sw": "Andika kazi ya JavaScript `function canWinNim(n)` kutatua tatizo lifuatalo:\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ufanisi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n  canWinNim(1) // inarudisha true",
      "tr": "Bir JavaScript fonksiyonu `function canWinNim(n)` yazın ve aşağıdaki problemi çözün:\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Verilen taş sayısına göre, eğer siz ve rakibiniz en iyi şekilde oynarsanız oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n  canWinNim(1) // true döndürür",
      "vi": "Viết một hàm JavaScript `function canWinNim(n)` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu. Lưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n  canWinNim(1) // trả về true"
    },
    "instruction_bertscore": {
      "es": "0.9972489692226668",
      "arb": "0.9840734187878606",
      "sw": "0.9930703818968358",
      "tr": "0.9639622913384592",
      "vi": "0.9810554287784164"
    },
    "level": "easy",
    "test": "function testCanWinNim() {\n    console.assert(canWinNim(1) === true, \"Test case 1 failed\");\n    console.assert(canWinNim(2) === true, \"Test case 2 failed\");\n    console.assert(canWinNim(3) === true, \"Test case 3 failed\");\n    console.assert(canWinNim(4) === false, \"Test case 4 failed\");\n    console.assert(canWinNim(5) === true, \"Test case 5 failed\");\n    console.assert(canWinNim(6) === true, \"Test case 6 failed\");\n    console.assert(canWinNim(7) === true, \"Test case 7 failed\");\n    console.assert(canWinNim(8) === false, \"Test case 8 failed\");\n    console.assert(canWinNim(9) === true, \"Test case 9 failed\");\n    console.assert(canWinNim(10) === true, \"Test case 10 failed\");\n    console.assert(canWinNim(11) === true, \"Test case 11 failed\");\n    console.assert(canWinNim(12) === false, \"Test case 12 failed\");\n    console.assert(canWinNim(13) === true, \"Test case 13 failed\");\n    console.assert(canWinNim(14) === true, \"Test case 14 failed\");\n    console.assert(canWinNim(15) === true, \"Test case 15 failed\");\n    console.assert(canWinNim(16) === false, \"Test case 16 failed\");\n    console.assert(canWinNim(17) === true, \"Test case 17 failed\");\n    console.assert(canWinNim(18) === true, \"Test case 18 failed\");\n    console.assert(canWinNim(19) === true, \"Test case 19 failed\");\n    console.assert(canWinNim(20) === false, \"Test case 20 failed\");\n}\ntestCanWinNim();",
    "entry_point": "canWinNim",
    "signature": "function canWinNim(n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true",
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. Nota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n  canWinNim(1) // devuelve true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. ملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n  canWinNim(1) // يعيد true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaocheza kwa ufanisi. Kumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n  canWinNim(1) // inarudisha kweli",
      "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n  canWinNim(1) // true döndürür",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống gồm n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Với số viên đá n đã cho, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. Lưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n  canWinNim(1) // trả về true"
    },
    "docstring_bertscore": {
      "es": "0.9880182181552135",
      "arb": "0.981889279118001",
      "sw": "0.9876555190794438",
      "tr": "0.9688392630840088",
      "vi": "0.9744855302953065"
    }
  },
  {
    "task_id": "JavaScript/50",
    "prompt": {
      "en": "\n/**\n * Given two integers a and b, return the sum if the sum is even,\n * or return the product of a and b if the sum is odd.\n * Examples:\n *   evenSumOrOddProduct(2, 3) returns 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "es": "/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par,\n * o devuelve el producto de a y b si la suma es impar.\n * Ejemplos:\n *   evenSumOrOddProduct(2, 3) devuelve 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "arb": "/**\n * بالنظر إلى عددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا،\n * أو قم بإرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *   evenSumOrOddProduct(2, 3) يعيد 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "sw": "/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni nambari shufwa,\n * au rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.\n * Mifano:\n *   evenSumOrOddProduct(2, 3) inarudisha 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "tr": "/**\n * İki tamsayı a ve b verildiğinde, toplam çift ise toplamı döndür,\n * veya toplam tek ise a ve b'nin çarpımını döndür.\n * Örnekler:\n *   evenSumOrOddProduct(2, 3) 6 döndürür\n */\nfunction evenSumOrOddProduct(a, b)",
      "vi": "/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\n * hoặc trả về tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *   evenSumOrOddProduct(2, 3) trả về 6\n */\nfunction evenSumOrOddProduct(a, b)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9635733730523929",
      "tr": "0.9654873754040451",
      "vi": "0.9971595855512011"
    },
    "canonical_solution": "{\n    let sum = a + b;\n    if (sum % 2 === 0) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function evenSumOrOddProduct(a, b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even,\n or return the product of a and b if the sum is odd.\n Examples:\n   evenSumOrOddProduct(2, 3) returns 6\n",
      "es": "Escribe una función de JavaScript `function evenSumOrOddProduct(a, b)` para resolver el siguiente problema:  \nDado dos enteros a y b, devuelve la suma si la suma es par,  \no devuelve el producto de a y b si la suma es impar.  \nEjemplos:  \n  evenSumOrOddProduct(2, 3) devuelve 6  ",
      "arb": "اكتب دالة JavaScript `function evenSumOrOddProduct(a, b)` لحل المشكلة التالية:\nبالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\n   evenSumOrOddProduct(2, 3) يعيد 6",
      "sw": "Andika kazi ya JavaScript `function evenSumOrOddProduct(a, b)` kutatua tatizo lifuatalo:  \nUkipiwa nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni nambari shufwa,  \nau rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.  \nMifano:  \n  evenSumOrOddProduct(2, 3) inarudisha 6  ",
      "tr": "Bir JavaScript fonksiyonu `function evenSumOrOddProduct(a, b)` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, toplam çift ise toplamı döndürün,\n eğer toplam tek ise a ve b'nin çarpımını döndürün.\n Örnekler:\n   evenSumOrOddProduct(2, 3) 6 döndürür",
      "vi": "Viết một hàm JavaScript `function evenSumOrOddProduct(a, b)` để giải quyết vấn đề sau:\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\nhoặc trả về tích của a và b nếu tổng là số lẻ.\nVí dụ:\n  evenSumOrOddProduct(2, 3) trả về 6"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9785826791649131",
      "tr": "0.9538492241184489",
      "vi": "0.9972702226734376"
    },
    "level": "easy",
    "test": "const testEvenSumOrOddProduct = () => {\n    console.assert(evenSumOrOddProduct(2, 3) === 6, 'Test Case 1 Failed');\n    console.assert(evenSumOrOddProduct(5, 5) === 10, 'Test Case 2 Failed');\n    console.assert(evenSumOrOddProduct(1, 1) === 2, 'Test Case 3 Failed');\n    console.assert(evenSumOrOddProduct(0, 0) === 0, 'Test Case 4 Failed');\n    console.assert(evenSumOrOddProduct(-1, -1) === -2, 'Test Case 5 Failed');\n    console.assert(evenSumOrOddProduct(100, 200) === 300, 'Test Case 6 Failed');\n    console.assert(evenSumOrOddProduct(3, 4) === 12, 'Test Case 7 Failed');\n    console.assert(evenSumOrOddProduct(-5, 5) === 0, 'Test Case 8 Failed');\n    console.assert(evenSumOrOddProduct(7, 8) === 56, 'Test Case 9 Failed');\n    console.assert(evenSumOrOddProduct(9, 10) === 90, 'Test Case 10 Failed');\n    console.assert(evenSumOrOddProduct(11, 14) === 154, 'Test Case 11 Failed');\n}\n\ntestEvenSumOrOddProduct();",
    "entry_point": "evenSumOrOddProduct",
    "signature": "function evenSumOrOddProduct(a, b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even,\n or return the product of a and b if the sum is odd.\n Examples:\n   evenSumOrOddProduct(2, 3) returns 6\n",
      "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\nEjemplos:\n   evenSumOrOddProduct(2, 3) devuelve 6",
      "arb": "إعطاء عددين صحيحين a و b، إرجاع المجموع إذا كان المجموع زوجيًا، أو إرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n\nأمثلة:\n   evenSumOrOddProduct(2, 3) يعيد 6",
      "sw": "Ukipiwa nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni nambari shufwa, \n au rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.\n Mifano:\n   evenSumOrOddProduct(2, 3) inarudisha 6",
      "tr": " Verilen iki tam sayı a ve b için, toplam çift ise toplamı döndürün,\n eğer toplam tek ise a ve b'nin çarpımını döndürün.\n Örnekler:\n   evenSumOrOddProduct(2, 3) 6 döndürür",
      "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\nhoặc trả về tích của a và b nếu tổng là số lẻ.\nVí dụ:\n  evenSumOrOddProduct(2, 3) trả về 6  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9452818985236521",
      "vi": "0.9967698727436106"
    }
  }
]