[
  {
    "task_id": "Python/1",
    "prompt": {
      "en": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "es": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verifica si en la lista dada de números, hay dos números más cercanos entre sí que\n    el umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "arb": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" تحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "sw": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko\n    kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "tr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "vi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n    ngưỡng đã cho hay không.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9804283526654893",
      "arb": "0.9812977578432791",
      "sw": "0.9746450304912776",
      "tr": "0.9787008642416289",
      "vi": "0.982236683654431"
    },
    "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False",
    "instruction": {
      "en": "Write a python function 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' to solve the following problem:\n Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "es": "Escribe una función en Python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' para resolver el siguiente problema:\n Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el\n    umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True",
      "arb": "اكتب دالة بايثون 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' لحل المشكلة التالية:\n تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True",
      "sw": "Andika kazi ya python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' kutatua tatizo lifuatalo:\n Angalia kama katika orodha iliyotolewa ya namba, kuna namba zozote mbili zilizo karibu zaidi ya\n    kizingiti kilichopewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True",
      "tr": "Bir Python fonksiyonu 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' yazarak aşağıdaki problemi çözün:\n Verilen sayı listesindeki herhangi iki sayının\n    verilen eşikten daha yakın olup olmadığını kontrol edin.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "vi": "Viết một hàm python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' để giải quyết vấn đề sau:  \n Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True"
    },
    "instruction_bertscore": {
      "es": "0.9800177836678903",
      "arb": "0.9859729211216972",
      "sw": "0.9841189051451176",
      "tr": "0.9730736655469105",
      "vi": "0.983318623339928"
    },
    "level": "easy",
    "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:",
    "docstring": {
      "en": " Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "es": "Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True",
      "arb": " تحقق مما إذا كان في قائمة الأرقام المعطاة، هل يوجد أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True",
      "sw": " Angalia kama katika orodha ya nambari zilizotolewa, kuna nambari mbili zozote ambazo ziko karibu zaidi kuliko kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "tr": " Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9730839943267243",
      "arb": "0.9706269365133228",
      "sw": "0.9636691128960517",
      "tr": "0.9587311616235243",
      "vi": "0.6686314901220702"
    }
  },
  {
    "task_id": "Python/2",
    "prompt": {
      "en": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "es": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n    separar esos grupos en cadenas separadas y devolver la lista de estas.\n    Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n    Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "arb": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" المدخل لهذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n    فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل.\n    المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض\n    تجاهل أي مسافات في سلسلة الإدخال.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "sw": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ingizo kwa kazi hii ni kamba inayo na vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\n    kutenganisha vikundi hivyo katika kamba tofauti na kurudisha orodha ya hizo.\n    Vikundi vilivyotenganishwa vina uwiano (kila kufungua brace imefungwa ipasavyo) na havijapachikwa ndani ya kila mmoja\n    Puuzia nafasi zozote kwenye kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "tr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu fonksiyona girdi, birden fazla iç içe geçmiş parantez grubunu içeren bir stringdir. Amacınız,\n    bu grupları ayrı stringlere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n    Girdi stringindeki boşlukları göz ardı edin.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "vi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Đầu vào cho hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n    tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n    Các nhóm riêng biệt là cân bằng (mỗi dấu mở đều được đóng đúng cách) và không lồng vào nhau\n    Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9511015700575933",
      "arb": "0.9496682532280455",
      "sw": "0.9522055577153852",
      "tr": "0.9356532908029859",
      "vi": "0.9375615328735881"
    },
    "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result",
    "instruction": {
      "en": "Write a python function 'def separate_paren_groups(paren_string: str) -> List[str]:' to solve the following problem:\n Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "es": "Escribe una función en Python 'def separate_paren_groups(paren_string: str) -> List[str]:' para resolver el siguiente problema:\n La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n    separar esos grupos en cadenas separadas y devolver la lista de estas.\n    Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n    Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "arb": "اكتب دالة بايثون 'def separate_paren_groups(paren_string: str) -> List[str]:' لحل المشكلة التالية:\n المدخلات لهذه الدالة هي سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n    فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل.\n    المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض.\n    تجاهل أي مسافات في سلسلة المدخلات.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "sw": "Andika kazi ya python 'def separate_paren_groups(paren_string: str) -> List[str]:' kutatua tatizo lifuatalo:\n Ingizo kwa kazi hii ni kamba inayojumuisha vikundi vingi vya mabano yaliyojificha. Lengo lako ni\n    kutenganisha vikundi hivyo kuwa kamba tofauti na kurudisha orodha ya hizo.\n    Vikundi vilivyotenganishwa vina usawa (kila mabano ya kufungua yanafungwa ipasavyo) na havijajificha ndani ya kila kimoja\n    Puuza nafasi zozote kwenye kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "tr": "Bir python fonksiyonu 'def separate_paren_groups(paren_string: str) -> List[str]:' yazın ve aşağıdaki problemi çözün:\n Bu fonksiyona giriş, birden fazla iç içe geçmiş parantez grubu içeren bir stringdir. Amacınız bu grupları ayrı stringlere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n    Giriş stringindeki boşlukları yok sayın.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "vi": "Viết một hàm python 'def separate_paren_groups(paren_string: str) -> List[str]:' để giải quyết vấn đề sau:\n Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n    tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n    Các nhóm riêng biệt là cân bằng (mỗi dấu mở được đóng đúng cách) và không lồng vào nhau\n    Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']"
    },
    "instruction_bertscore": {
      "es": "0.9531119081440474",
      "arb": "0.9507746244504098",
      "sw": "0.9382293282146273",
      "tr": "0.8616042820139417",
      "vi": "0.9354955782804442"
    },
    "level": "hard",
    "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)",
    "entry_point": "separate_paren_groups",
    "signature": "def separate_paren_groups(paren_string: str) -> List[str]:",
    "docstring": {
      "en": " Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "es": "La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es separar esos grupos en cadenas separadas y devolver la lista de estas. Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí. Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "arb": "مدخل هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بها. \nالمجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض. \nتجاهل أي مسافات في سلسلة المدخلات.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "sw": "Ingizo kwa kazi hii ni kamba inayojumuisha makundi mengi ya mabano yaliyopachikwa. Lengo lako ni\n    kutenganisha makundi hayo katika kamba tofauti na kurudisha orodha ya hizo.\n    Makundi tofauti yamebalansiwa (kila kufungua brace imefungwa ipasavyo) na hayajapachikwa ndani ya kila moja\n    Puuza nafasi zozote katika kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "tr": "Bu fonksiyonun girdisi, birden fazla iç içe geçmiş parantez grubunu içeren bir dizedir. Amacınız, bu grupları ayrı dizelere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açma parantezi düzgün bir şekilde kapatılır) ve birbirlerinin içinde iç içe değildir.\n    Girdi dizesindeki boşlukları yok sayın.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "vi": "Đầu vào cho hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách của chúng. Các nhóm riêng biệt là cân bằng (mỗi dấu mở ngoặc được đóng đúng cách) và không lồng vào nhau. Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']"
    },
    "docstring_bertscore": {
      "es": "0.9358457636422087",
      "arb": "0.9166922332597766",
      "sw": "0.9282505351321967",
      "tr": "0.9325508828816019",
      "vi": "0.9223136716734449"
    }
  },
  {
    "task_id": "Python/3",
    "prompt": {
      "en": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "es": "def truncate_number(number: float) -> float:\n    \"\"\" Dado un número de punto flotante positivo, se puede descomponer en\n    una parte entera (el mayor entero menor que el número dado) y decimales\n    (parte restante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "arb": "def truncate_number(number: float) -> float:\n    \"\"\" بالنظر إلى عدد عشري موجب، يمكن تحليله إلى\n    جزء صحيح (أكبر عدد صحيح أصغر من العدد المعطى) وأجزاء عشرية\n    (الجزء المتبقي دائماً أصغر من 1).\n    \n    إرجاع الجزء العشري من العدد.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "sw": "def truncate_number(number: float) -> float:\n    \"\"\" Ukipewa namba chanya ya nukta, inaweza kugawanywa katika\n    sehemu ya namba kamili (namba kamili kubwa zaidi iliyo ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "tr": "def truncate_number(number: float) -> float:\n    \"\"\" Pozitif bir ondalık sayının, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı)\n    ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabileceği verilmiştir.\n    \n    Sayının ondalık kısmını döndür.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "vi": "def truncate_number(number: float) -> float:\n    \"\"\" Cho một số thực dương, nó có thể được phân tách thành\n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.96295861202309",
      "arb": "0.9242010575540384",
      "sw": "0.9143078741658337",
      "tr": "0.9143474016116596",
      "vi": "0.9165883495704953"
    },
    "canonical_solution": "    return number % 1.0",
    "instruction": {
      "en": "Write a python function 'def truncate_number(number: float) -> float:' to solve the following problem:\n Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "es": "Escribe una función de Python 'def truncate_number(number: float) -> float:' para resolver el siguiente problema:\n Dado un número de punto flotante positivo, se puede descomponer en\n    una parte entera (el entero más grande menor que el número dado) y decimales\n    (parte sobrante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5",
      "arb": "اكتب دالة بايثون 'def truncate_number(number: float) -> float:' لحل المشكلة التالية:\n  بالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى\n    جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وعشري\n    (الجزء المتبقي دائماً أصغر من 1).\n    \n    أعد الجزء العشري من الرقم.\n    >>> truncate_number(3.5)\n    0.5",
      "sw": "Andika kazi ya python 'def truncate_number(number: float) -> float:' kutatua tatizo lifuatalo:\n Kwa kuzingatia nambari chanya ya nukta inayoyeyuka, inaweza kugawanywa katika\n    sehemu ya nambari kamili (nambari kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya nambari.\n    >>> truncate_number(3.5)\n    0.5",
      "tr": "Bir python fonksiyonu 'def truncate_number(number: float) -> float:' yazın ve aşağıdaki problemi çözün:\n Verilen pozitif bir ondalık sayı, bir tam sayı kısmına (verilen sayıdan küçük en büyük tam sayı) ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n    \n    Sayının ondalık kısmını döndürün.\n    >>> truncate_number(3.5)\n    0.5",
      "vi": "Viết một hàm python 'def truncate_number(number: float) -> float:' để giải quyết vấn đề sau:  \n Cho một số thực dương, nó có thể được phân tách thành  \n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân  \n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số đó.\n    >>> truncate_number(3.5)\n    0.5"
    },
    "instruction_bertscore": {
      "es": "0.9620566314628105",
      "arb": "0.9310754564112749",
      "sw": "0.9268968690854439",
      "tr": "0.9372558407171754",
      "vi": "0.9225270007026763"
    },
    "level": "easy",
    "test": "def check(truncate_number):\n    assert truncate_number(3.5) == 0.5\n    assert abs(truncate_number(1.33) - 0.33) < 1e-6\n    assert abs(truncate_number(123.456) - 0.456) < 1e-6\n \ncheck(truncate_number)",
    "entry_point": "truncate_number",
    "signature": "def truncate_number(number: float) -> float:",
    "docstring": {
      "en": " Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "es": "Dado un número de punto flotante positivo, se puede descomponer en\n    una parte entera (el entero más grande menor que el número dado) y decimales\n    (parte sobrante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5",
      "arb": "بالنظر إلى عدد عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من العدد المعطى) وأجزاء عشرية (الجزء المتبقي الذي يكون دائماً أصغر من 1).\n\nإرجاع الجزء العشري من العدد.\n>>> truncate_number(3.5)\n0.5",
      "sw": " Ikitolewa namba chanya ya nukta, inaweza kugawanywa katika\n    sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "tr": " Verilen pozitif bir kayan noktalı sayı, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalıklara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n    \n    Sayının ondalık kısmını döndürün.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "vi": "Đưa ra một số thực dương, nó có thể được phân tách thành\n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số.\n    >>> truncate_number(3.5)\n    0.5"
    },
    "docstring_bertscore": {
      "es": "0.9557147606571286",
      "arb": "0.90186407805476",
      "sw": "0.907603105654001",
      "tr": "0.9521116055451557",
      "vi": "0.8965020509187233"
    }
  },
  {
    "task_id": "Python/4",
    "prompt": {
      "en": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "es": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n    saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n    en ese momento la función debe devolver True. De lo contrario, debe devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "arb": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" لديك قائمة بعمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي نقطة\n    يصبح رصيد الحساب أقل من الصفر، وفي هذه الحالة يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "sw": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n    salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na\n    wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "tr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sıfır bakiye ile başlayan bir banka hesabında yapılan para yatırma ve çekme işlemlerinin bir listesini alıyorsunuz.\n    Göreviniz, hesabın bakiyesinin herhangi bir noktada sıfırın altına düşüp düşmediğini tespit etmektir ve\n    bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "vi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Bạn được cung cấp một danh sách các giao dịch gửi tiền và rút tiền trên một tài khoản ngân hàng bắt đầu với\n    số dư bằng không. Nhiệm vụ của bạn là phát hiện nếu tại bất kỳ thời điểm nào số dư của tài khoản giảm xuống dưới không, và\n    tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9768230126193251",
      "arb": "0.9462645230186317",
      "sw": "0.9757672921441247",
      "tr": "0.9621706453015245",
      "vi": "0.9700354152386009"
    },
    "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False",
    "instruction": {
      "en": "Write a python function 'def below_zero(operations: List[int]) -> bool:' to solve the following problem:\n You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ",
      "es": "Escribe una función en Python 'def below_zero(operations: List[int]) -> bool:' para resolver el siguiente problema:\n Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n    saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n    en ese momento la función debe devolver True. De lo contrario, debe devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "arb": "اكتب دالة بايثون 'def below_zero(operations: List[int]) -> bool:' لحل المشكلة التالية:\n لديك قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي نقطة ينخفض رصيد الحساب إلى أقل من الصفر، وفي تلك الحالة يجب أن تعيد الدالة True. وإلا يجب أن تعيد False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "sw": "Andika kazi ya python 'def below_zero(operations: List[int]) -> bool:' kutatua tatizo lifuatalo:\n Unapewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n    salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti litashuka chini ya sifuri, na\n    wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "tr": "Bir python fonksiyonu 'def below_zero(operations: List[int]) -> bool:' yazın ve aşağıdaki problemi çözün:\n    Sıfır bakiyeyle başlayan bir banka hesabında yapılan para yatırma ve çekme işlemlerinin bir listesini veriliyor. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "vi": "Viết một hàm python 'def below_zero(operations: List[int]) -> bool:' để giải quyết vấn đề sau:  \nBạn được cung cấp một danh sách các giao dịch gửi và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.  \n>>> below_zero([1, 2, 3])  \nFalse  \n>>> below_zero([1, 2, -4, 5])  \nTrue  "
    },
    "instruction_bertscore": {
      "es": "0.9698965726022575",
      "arb": "0.8772013354239442",
      "sw": "0.9683087213362647",
      "tr": "0.9522550166802629",
      "vi": "0.9691483319568991"
    },
    "level": "easy",
    "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)",
    "entry_point": "below_zero",
    "signature": "def below_zero(operations: List[int]) -> bool:",
    "docstring": {
      "en": " You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ",
      "es": "Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese punto la función debería devolver True. De lo contrario, debería devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "arb": "أنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي اكتشاف ما إذا كان في أي نقطة ينخفض رصيد الحساب إلى ما دون الصفر، وعند هذه النقطة يجب أن تُعيد الدالة True. خلاف ذلك، يجب أن تُعيد False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "sw": "Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "tr": " Verilen bir banka hesabı üzerinde sıfır bakiyeyle başlayan para yatırma ve çekme işlemlerinin bir listesidir. Göreviniz, herhangi bir noktada hesap bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ",
      "vi": "Bạn được cung cấp một danh sách các hoạt động gửi và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Nếu không, nó nên trả về False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True"
    },
    "docstring_bertscore": {
      "es": "0.9737388786929964",
      "arb": "0.953303189200984",
      "sw": "0.9517471187959566",
      "tr": "0.9299819961636778",
      "vi": "0.9618019873143238"
    }
  },
  {
    "task_id": "Python/5",
    "prompt": {
      "en": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "es": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Para una lista dada de números de entrada, calcular la Desviación Absoluta Media\n    alrededor de la media de este conjunto de datos.\n    La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n    elemento y un punto central (media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "arb": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n    حول متوسط هذه المجموعة من البيانات.\n    الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية \n    (المتوسط في هذه الحالة):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "sw": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko wa Kawaida wa \n    Wastani kuzunguka wastani wa seti hii ya data.\n    Mkengeuko wa Kawaida wa Wastani ni wastani wa tofauti kamili kati ya kila \n    kipengele na kituo (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "tr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapmayı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "vi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Đối với một danh sách các số đầu vào cho trước, tính Độ lệch tuyệt đối trung bình\n    quanh giá trị trung bình của tập dữ liệu này.\n    Độ lệch tuyệt đối trung bình là sự khác biệt tuyệt đối trung bình giữa mỗi\n    phần tử và một điểm trung tâm (trung bình trong trường hợp này):\n    MAD = trung bình | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9770850060919102",
      "arb": "0.9441870478633878",
      "sw": "0.965919595113177",
      "tr": "0.9535886210585311",
      "vi": "0.9754435246230378"
    },
    "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)",
    "instruction": {
      "en": "Write a python function 'def mean_absolute_deviation(numbers: List[float]) -> float:' to solve the following problem:\n For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "es": "Escribe una función de Python 'def mean_absolute_deviation(numbers: List[float]) -> float:' para resolver el siguiente problema:\n Para una lista dada de números de entrada, calcula la Desviación Absoluta Media\n    alrededor de la media de este conjunto de datos.\n    La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n    elemento y un punto central (media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "arb": "اكتب دالة بايثون 'def mean_absolute_deviation(numbers: List[float]) -> float:' لحل المشكلة التالية:\nبالنسبة لقائمة معينة من الأرقام المدخلة، احسب الانحراف المطلق المتوسط حول متوسط هذه المجموعة.\nالانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0",
      "sw": "Andika kazi ya python 'def mean_absolute_deviation(numbers: List[float]) -> float:' kutatua tatizo lifuatalo:\n Kwa orodha fulani ya namba za pembejeo, hesabu Mkengeuko wa Wastani wa Kawaida\n    kuzunguka wastani wa seti hii ya data.\n    Mkengeuko wa Wastani wa Kawaida ni wastani wa tofauti ya kawaida kati ya kila\n    kipengele na sehemu ya kati (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "tr": "Bir python fonksiyonu 'def mean_absolute_deviation(numbers: List[float]) -> float:' yazın ve aşağıdaki problemi çözün:\n Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapmayı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n    MAD = ortalama | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "vi": "Viết một hàm python 'def mean_absolute_deviation(numbers: List[float]) -> float:' để giải quyết vấn đề sau:\n Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình\n    xung quanh giá trị trung bình của tập dữ liệu này.\n    Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi\n    phần tử và một điểm trung tâm (trung bình trong trường hợp này):\n    MAD = trung bình | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0"
    },
    "instruction_bertscore": {
      "es": "0.9840452132737536",
      "arb": "0.9562397407542038",
      "sw": "0.9614476307145575",
      "tr": "0.9580675375204868",
      "vi": "0.9692969074819132"
    },
    "level": "easy",
    "test": "def check(mean_absolute_deviation):\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n    \ncheck(mean_absolute_deviation)",
    "entry_point": "mean_absolute_deviation",
    "signature": "def mean_absolute_deviation(numbers: List[float]) -> float:",
    "docstring": {
      "en": " For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "es": " Para una lista dada de números de entrada, calcular la Desviación Absoluta Media\n    alrededor de la media de este conjunto de datos.\n    La Desviación Absoluta Media es la diferencia absoluta promedio entre cada\n    elemento y un punto central (la media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "arb": "للحصول على قائمة معينة من الأرقام المدخلة، احسب الانحراف المطلق المتوسط حول متوسط هذه المجموعة من البيانات. الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة): MAD = متوسط | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0",
      "sw": "Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko Wastani wa Absolute\n    kuzunguka wastani wa seti hii ya data.\n    Mkengeuko Wastani wa Absolute ni tofauti ya wastani ya absolute kati ya kila\n    kipengele na sehemu ya kati (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "tr": "Verilen bir giriş numaraları listesi için, bu veri kümesinin etrafındaki Ortalama Mutlak Sapmayı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:\n    MAD = ortalama | x - x_ortalama |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "vi": " Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình xung quanh trung bình của tập dữ liệu này. Độ lệch tuyệt đối trung bình là sự khác biệt tuyệt đối trung bình giữa mỗi phần tử và một điểm trung tâm (trung bình trong trường hợp này): MAD = trung bình | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0"
    },
    "docstring_bertscore": {
      "es": "0.9659033074219321",
      "arb": "0.9436106224976245",
      "sw": "0.9653231080789292",
      "tr": "0.9511492413490417",
      "vi": "0.971635581588218"
    }
  },
  {
    "task_id": "Python/6",
    "prompt": {
      "en": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    \"\"\"",
      "es": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.\n    \"\"\"",
      "arb": "def add(a: int, b: int) -> int:\n    \"\"\"\n    يجمع عددين صحيحين معًا.\n\n    Parameters:\n    a (int): الرقم الأول الذي سيتم جمعه.\n    b (int): الرقم الثاني الذي سيتم جمعه.\n\n    يعيد:\n    int: مجموع العددين.\n    \"\"\"",
      "sw": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Huongeza namba mbili za integer pamoja.\n\n    Parameters:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarejesha:\n    int: Jumla ya namba hizo mbili.\n    \"\"\"",
      "tr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürülen:\n    int: İki sayının toplamı.\n    \"\"\"",
      "vi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Cộng hai số nguyên lại với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất để cộng.\n    b (int): Số thứ hai để cộng.\n\n    Trả về:\n    int: Tổng của hai số.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9671620281465502",
      "arb": "0.9878525604174304",
      "sw": "1",
      "tr": "0.9827362390627338",
      "vi": "0.9729272749560879"
    },
    "canonical_solution": "    return a + b",
    "instruction": {
      "en": "Write a python function 'def add(a: int, b: int) -> int:' to solve the following problem:\n\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    ",
      "es": "Escribe una función de Python 'def add(a: int, b: int) -> int:' para resolver el siguiente problema:\n\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.",
      "arb": "اكتب دالة بايثون 'def add(a: int, b: int) -> int:' لحل المشكلة التالية:\n\n    يجمع عددين صحيحين معًا.\n\n    المعاملات:\n    a (int): الرقم الأول الذي سيتم جمعه.\n    b (int): الرقم الثاني الذي سيتم جمعه.\n\n    يعيد:\n    int: مجموع الرقمين.",
      "sw": "Andika kazi ya python 'def add(a: int, b: int) -> int:' kutatua tatizo lifuatalo:\n\n    Huongeza namba mbili za mzima pamoja.\n\n    Vigezo:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarejesha:\n    int: Jumla ya namba hizo mbili.",
      "tr": "Aşağıdaki problemi çözmek için bir python fonksiyonu 'def add(a: int, b: int) -> int:' yazın:\n\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürür:\n    int: İki sayının toplamı.",
      "vi": "Viết một hàm python 'def add(a: int, b: int) -> int:' để giải quyết vấn đề sau:\n\n    Cộng hai số nguyên lại với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất cần cộng.\n    b (int): Số thứ hai cần cộng.\n\n    Trả về:\n    int: Tổng của hai số."
    },
    "instruction_bertscore": {
      "es": "0.9713934511537364",
      "arb": "0.9952418092223092",
      "sw": "0.9952418092223092",
      "tr": "0.9633360097470562",
      "vi": "0.981667011721623"
    },
    "level": "easy",
    "test": "# Test cases:\n# The following lines are not part of the function's implementation but are provided\n# for testing purposes.\n\n# Test case 1: Positive integers\nassert add(2, 3) == 5\n\n# Test case 2: A positive and a negative integer\nassert add(-1, 1) == 0\n\n# Test case 3: Two negative integers\nassert add(-4, -5) == -9\n\n# Test case 4: Zeroes\nassert add(0, 0) == 0\n\n# Test case 5: Large integers\nassert add(123456, 654321) == 777777\n\nprint(\"All test cases passed.\")",
    "entry_point": "add",
    "signature": "def add(a: int, b: int) -> int:",
    "docstring": {
      "en": "\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    ",
      "es": "    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.",
      "arb": "    يجمع عددين صحيحين معًا.\n\n    Parameters:\n    a (int): الرقم الأول الذي سيتم جمعه.\n    b (int): الرقم الثاني الذي سيتم جمعه.\n\n    يعيد:\n    int: مجموع الرقمين.",
      "sw": "    Huongeza namba mbili za integer pamoja.\n\n    Vigezo:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarudisha:\n    int: Jumla ya namba hizo mbili.",
      "tr": "    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürülenler:\n    int: İki sayının toplamı.",
      "vi": "    Cộng hai số nguyên với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất cần được cộng.\n    b (int): Số thứ hai cần được cộng.\n\n    Trả về:\n    int: Tổng của hai số."
    },
    "docstring_bertscore": {
      "es": "0.9582540514482786",
      "arb": "0.9933260191972277",
      "sw": "0.999999801369619",
      "tr": "0.9807264968674227",
      "vi": "0.9883330473091537"
    }
  },
  {
    "task_id": "Python/7",
    "prompt": {
      "en": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "es": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Encuentra la alfombra más superior que cubre un punto dado en el plano de coordenadas.\n\n    Argumentos:\n    n (int): El número total de alfombras.\n    carpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                              Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                              coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                              las longitudes de la alfombra a lo largo del eje x e y respectivamente.\n    point (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\n    Devuelve:\n    int: El número de la alfombra más superior que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\n    Ejemplos:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "arb": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    يجد السجادة العليا التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج المرتبة، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و(g, k) هي\n                              أطوال السجادة على طول المحورين x و y على التوالي.\n    point (tuple): زوج مرتب يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العليا التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    امثله:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "sw": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\n    Hoja:\n    n (int): Jumla ya idadi ya mazulia.\n    carpets (list of tuples): Orodha inayo na n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                              Kila tuple ina integer nne (a, b, g, k) ambapo (a, b) ni\n                              kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                              urefu wa zulia kando ya mhimili wa x na y mtawalia.\n    point (tuple): Tuple inayo na integer mbili (x, y), kuratibu za nukta ya kuangalia.\n\n    Inarejesha:\n    int: Namba ya zulia la juu zaidi linalofunika nukta (x, y), au -1 kama hakuna zulia linaloifunika.\n\n    Mifano:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "tr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Koordinat düzleminde verilen bir noktayı kaplayan en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgisini temsil eden n adet demet içeren bir liste.\n                              Her demet dört tam sayı (a, b, g, k) içerir, burada (a, b) halının\n                              sol alt köşesinin koordinatlarıdır ve (g, k) sırasıyla x ve y ekseni\n                              boyunca halının uzunluklarıdır.\n    point (tuple): Kontrol edilecek noktanın koordinatlarını içeren iki tam sayılık bir demet (x, y).\n\n    Döndürür:\n    int: Noktayı (x, y) kaplayan en üstteki halının numarası veya hiçbir halı kaplamıyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "vi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Tìm tấm thảm trên cùng bao phủ một điểm nhất định trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số tấm thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là\n                              tọa độ của góc dưới bên trái của tấm thảm và (g, k) là\n                              chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng bao phủ điểm (x, y), hoặc -1 nếu không có tấm thảm nào bao phủ nó.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9861937981054081",
      "arb": "0.9826983006599561",
      "sw": "0.9797784340587432",
      "tr": "0.9795704680497996",
      "vi": "0.987104717032834"
    },
    "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point",
    "instruction": {
      "en": "Write a python function 'def find_topmost_carpet(n, carpets, point) -> int:' to solve the following problem:\n\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "es": "Escribe una función de Python 'def find_topmost_carpet(n, carpets, point) -> int:' para resolver el siguiente problema:\n\n    Encuentra la alfombra más alta que cubre un punto dado en el plano de coordenadas.\n\n    Argumentos:\n    n (int): El número total de alfombras.\n    carpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                              Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                              coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                              las longitudes de la alfombra a lo largo del eje x e y respectivamente.\n    point (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\n    Devuelve:\n    int: El número de la alfombra más alta que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\n    Ejemplos:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "arb": "اكتب دالة بايثون 'def find_topmost_carpet(n, carpets, point) -> int:' لحل المشكلة التالية:\n\n    إيجاد السجادة العليا التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث أن (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و (g, k) هي\n                              أطوال السجادة على طول محوري x و y على التوالي.\n    point (tuple): زوج يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العليا التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    أمثلة:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "sw": "Andika kazi ya python 'def find_topmost_carpet(n, carpets, point) -> int:' kutatua tatizo lifuatalo:\n\n    Inapata zulia la juu kabisa linalofunika sehemu fulani kwenye ndege ya kuratibu.\n\n    Hoja:\n    n (int): Jumla ya idadi ya mazulia.\n    carpets (list of tuples): Orodha inayojumuisha n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                              Kila tuple ina namba nne za mzima (a, b, g, k) ambapo (a, b) ni\n                              kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                              urefu wa zulia kando ya mhimili wa x na y mtawalia.\n    point (tuple): Tuple inayojumuisha namba mbili za mzima (x, y), kuratibu za sehemu ya kuangalia.\n\n    Inarejesha:\n    int: Namba ya zulia la juu kabisa linalofunika sehemu (x, y), au -1 ikiwa hakuna zulia linalofunika.\n\n    Mifano:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "tr": "Bir python fonksiyonu 'def find_topmost_carpet(n, carpets, point) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Koordinat düzleminde verilen bir noktayı kaplayan en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgilerini temsil eden n adet demet içeren bir liste.\n                              Her demet dört tamsayı (a, b, g, k) içerir, burada (a, b)\n                              halının sol alt köşesinin koordinatlarıdır ve (g, k) halının\n                              x ve y eksenleri boyunca uzunluklarıdır.\n    point (tuple): İki tamsayı (x, y) içeren bir demet, kontrol edilecek noktanın koordinatları.\n\n    Döndürür:\n    int: Nokta (x, y) üzerindeki en üstteki halının numarası veya hiçbir halı kaplamıyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "vi": "Viết một hàm python 'def find_topmost_carpet(n, carpets, point) -> int:' để giải quyết vấn đề sau:\n\n    Tìm tấm thảm trên cùng phủ lên một điểm cho trước trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số tấm thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái của tấm thảm và (g, k) là chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng phủ lên điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ lên nó.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1"
    },
    "instruction_bertscore": {
      "es": "0.9869176072138992",
      "arb": "0.9875671285598833",
      "sw": "0.980602948770419",
      "tr": "0.9763329914693121",
      "vi": "0.9817742721273818"
    },
    "level": "easy",
    "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()",
    "entry_point": "find_topmost_carpet",
    "signature": "def find_topmost_carpet(n, carpets, point) -> int:",
    "docstring": {
      "en": "\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "es": "Encuentra la alfombra más alta que cubre un punto dado en el plano de coordenadas.\n\nArgumentos:\nn (int): El número total de alfombras.\ncarpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                          Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                          coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                          las longitudes de la alfombra a lo largo del eje x e y respectivamente.\npoint (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\nDevuelve:\nint: El número de la alfombra más alta que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\nEjemplos:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "arb": "    يجد السجادة العلوية التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و (g, k) هي\n                              أطوال السجادة على طول المحورين x و y على التوالي.\n    point (tuple): زوج يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العلوية التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    امثله:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "sw": "Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\nHoja:\nn (int): Jumla ya idadi ya mazulia.\ncarpets (list of tuples): Orodha inayo na n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                          Kila tuple ina namba nne za mzima (a, b, g, k) ambapo (a, b) ni\n                          kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                          urefu wa zulia kando ya mhimili wa x na y mtawalia.\npoint (tuple): Tuple inayo na namba mbili za mzima (x, y), kuratibu za nukta ya kukagua.\n\nInarejesha:\nint: Namba ya zulia la juu zaidi linalofunika nukta (x, y), au -1 ikiwa hakuna zulia linaloifunika.\n\nMifano:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "tr": "    Belirtilen bir noktayı koordinat düzleminde örten en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgilerini temsil eden n demetini içeren bir liste.\n                              Her demet, halının sol alt köşesinin koordinatları olan (a, b) ve\n                              sırasıyla x ve y ekseni boyunca halının uzunlukları olan (g, k) dört tam sayı içerir.\n    point (tuple): Kontrol edilecek noktanın koordinatlarını içeren iki tam sayı (x, y) içeren bir demet.\n\n    Döndürür:\n    int: Noktayı (x, y) örten en üstteki halının numarası veya hiçbir halı örtmüyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "vi": "    Tìm tấm thảm trên cùng phủ lên một điểm cho trước trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số lượng thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái của tấm thảm và (g, k) là\n                              chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng phủ lên điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ lên.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1"
    },
    "docstring_bertscore": {
      "es": "0.9853603450265856",
      "arb": "0.9825431703323678",
      "sw": "0.9827469651033096",
      "tr": "0.9575526875728444",
      "vi": "0.9795760297004686"
    }
  },
  {
    "task_id": "Python/8",
    "prompt": {
      "en": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "es": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calcular la suma máxima de valores recolectados en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina\n    superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximizan la\n    suma de los valores recolectados. Cada valor puede ser recolectado como máximo una vez,\n    incluso si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor que se colocará en la cuadrícula en esa\n      posición. La lista termina con una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recolectados en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "arb": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    حساب مجموع القيم الأقصى التي تم جمعها على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية لإيجاد مسارين من الزاوية العلوية اليسرى\n    إلى الزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم التي تم جمعها. يمكن جمع\n    كل قيمة مرة واحدة فقط، حتى إذا مر كلا المسارين من خلالها.\n\n    يعيدالحجج:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج\n      على الإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموقع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: مجموع القيم الأقصى التي تم جمعها على المسارين.\n\n    أمثلة:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "sw": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Kuhesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo inakuza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi inajumuisha\n      x-kiwiania, y-kiwiania, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "tr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N boyutundaki bir ızgarada iki yol üzerinde toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar iki yol bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer, her iki yol\n    da üzerinden geçse bile en fazla bir kez toplanabilir.\n\n    Argümanlar:\n    - N (int): Izgaranın boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatı, y-koordinatı ve\n      o konumda ızgaraya yerleştirilecek değeri içerdiği bir demet listesi. Liste, tüm elemanları\n      sıfır olan bir demet ile sonlandırılır.\n\n    Döndürür:\n    - int: İki yol üzerinde toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "vi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Tính tổng giá trị lớn nhất thu thập được trên hai đường đi trong lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới mà tối đa hóa tổng giá trị thu thập được. Mỗi\n    giá trị có thể được thu thập tối đa một lần, ngay cả khi cả hai đường đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba mà mỗi bộ chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\n    Trả về:\n    - int: Tổng giá trị lớn nhất thu thập được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9855951261369689",
      "arb": "0.9864663189881879",
      "sw": "0.9622089809650642",
      "tr": "0.9832457259900882",
      "vi": "0.955096821541729"
    },
    "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]",
    "instruction": {
      "en": "Write a python function 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' to solve the following problem:\n\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ",
      "es": "Escribe una función de Python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' para resolver el siguiente problema:\n\n    Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina superior izquierda hasta\n    la esquina inferior derecha de la cuadrícula que maximicen la suma de los valores recogidos. Cada\n    valor puede ser recogido como máximo una vez, incluso si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor a colocar en la cuadrícula en esa posición.\n      La lista termina con una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recogidos en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "arb": "اكتب دالة بايثون 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب مجموع القيم الأقصى التي تم جمعها على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية لإيجاد مسارين من الزاوية العلوية اليسرى إلى\n    الزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم التي تم جمعها. يمكن جمع كل\n    قيمة مرة واحدة فقط، حتى إذا مر كلا المسارين عبرها.\n\n    يعيدالحجج:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\n      الإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموقع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: مجموع القيم الأقصى التي تم جمعها على المسارين.\n\n    أمثلة:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "sw": "Andika kazi ya python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\n      x-coordinate, y-coordinate, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "tr": "Bir python fonksiyonu 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar olan iki yolu bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer\n    en fazla bir kez toplanabilir, her iki yol da üzerinden geçse bile.\n\n    Argümanlar:\n    - N (int): Izgaranın boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatı, y-koordinatı ve\n      o pozisyonda ızgaraya yerleştirilecek değeri içerdiği demetlerin bir listesi.\n      Liste, tüm elemanları sıfır olan bir demet ile sonlanır.\n\n    Döndürür:\n    - int: İki yolda toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "vi": "Viết một hàm python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng giá trị lớn nhất thu được trên hai đường đi trong một lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới mà tối đa hóa tổng giá trị thu được. Mỗi\n    giá trị có thể được thu thập nhiều nhất một lần, ngay cả khi cả hai đường đi đều đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba, trong đó mỗi bộ ba chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các số không.\n\n    Trả về:\n    - int: Tổng giá trị lớn nhất thu được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67"
    },
    "instruction_bertscore": {
      "es": "0.9798902629632659",
      "arb": "0.982276012469876",
      "sw": "0.9641384764864371",
      "tr": "0.9805109829039999",
      "vi": "0.9513873991759025"
    },
    "level": "hard",
    "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()",
    "entry_point": "max_value_on_paths",
    "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ",
      "es": "    Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina\n    superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximicen la\n    suma de los valores recogidos. Cada valor puede ser recogido como máximo una vez, incluso\n    si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor que se colocará en la cuadrícula en esa\n      posición. La lista está terminada por una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recogidos en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "arb": "    حساب الحد الأقصى لمجموع القيم المجمعة على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية للعثور على مسارين من الزاوية العلوية اليسرى إلى\n    الزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم المجمعة. يمكن جمع كل\n    قيمة مرة واحدة فقط، حتى إذا مر كلا المسارين بها.\n\n    Args:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\n      الإحداثي السيني، الإحداثي الصادي، والقيمة التي توضع على الشبكة في ذلك الموضع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: الحد الأقصى لمجموع القيم المجمعة على المسارين.\n\n    امثله:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "sw": "    Kuhesabu jumla ya juu ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\n      x-kiwianishi, y-kiwianishi, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "tr": "    N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlamayı kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar olan iki yolu bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer en fazla\n    bir kez toplanabilir, her iki yol da aynı değerden geçse bile.\n\n    Argümanlar:\n    - N (int): Izgaranın boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatını, y-koordinatını ve\n      o konumda ızgaraya yerleştirilecek değeri içeren demetlerin listesi. Liste, tüm elemanları\n      sıfır olan bir demet ile sonlandırılır.\n\n    Döndürür:\n    - int: İki yolda toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "vi": "    Tính tổng lớn nhất của các giá trị thu thập được trên hai đường đi trong lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới nhằm tối đa hóa tổng các giá trị thu thập được. Mỗi\n    giá trị chỉ có thể được thu thập tối đa một lần, ngay cả khi cả hai đường đi đều đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba, trong đó mỗi bộ ba chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\n    Trả về:\n    - int: Tổng lớn nhất của các giá trị thu thập được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67"
    },
    "docstring_bertscore": {
      "es": "0.9913125030246771",
      "arb": "0.9739740570641418",
      "sw": "0.9579469688791986",
      "tr": "0.9767268755149042",
      "vi": "0.9638993255076711"
    }
  },
  {
    "task_id": "Python/9",
    "prompt": {
      "en": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "es": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generar todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición,\n    de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\n    Retorna:\n        lista de tuplas: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las\n                         combinaciones de números válidas en orden ascendente basado en el primer número.\n\n    Ejemplo:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "arb": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 بدون تكرار،\n    بحيث يكون الرقم الثاني ضعف الأول والثالث ثلاثة أضعاف الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من المجموعات، حيث يحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل\n                        توليفات الأرقام الصالحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    امثله:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "sw": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tengeneza michanganyiko yote ya kipekee ya nambari tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    kiasi kwamba nambari ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarejesha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina nambari tatu za integer zinazowakilisha\n                          michanganyiko halali ya nambari kwa mpangilio wa kupanda kulingana na nambari ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "tr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1'den 9'a kadar olan rakamlardan tekrar etmeden oluşturulan üç sayının tüm benzersiz kombinasyonlarını üret,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Döndürür:\n        list of tuples: Her bir tuple'ın, ilk sayıya göre artan sırada geçerli sayı kombinasyonlarını temsil eden\n                        üç tam sayı içerdiği sıralı bir tuple listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "vi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        danh sách các bộ giá trị: Một danh sách đã sắp xếp của các bộ giá trị, trong đó mỗi bộ chứa ba số nguyên\n                                  đại diện cho các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9825846840820041",
      "arb": "0.9572134268820368",
      "sw": "0.9754413396888464",
      "tr": "0.9726366787086338",
      "vi": "0.9765445328251142"
    },
    "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])",
    "instruction": {
      "en": "Write a python function 'def find_number_combinations():' to solve the following problem:\n\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    ",
      "es": "Escribe una función de Python 'def find_number_combinations():' para resolver el siguiente problema:\n\n    Generar todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición,\n    de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\n    Retorna:\n        list of tuples: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las\n                        combinaciones de números válidas en orden ascendente basado en el primer número.\n\n    Ejemplo:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "arb": "اكتب دالة بايثون 'def find_number_combinations():' لحل المشكلة التالية:\n\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 دون تكرار،\n    بحيث يكون الرقم الثاني ضعف الرقم الأول والرقم الثالث ثلاثة أضعاف الرقم الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من التوليفات، حيث يحتوي كل توليفة على ثلاثة أعداد صحيحة تمثل\n                        التوليفات العددية الصحيحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    امثله:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "sw": "Andika kazi ya python 'def find_number_combinations():' kutatua tatizo lifuatalo:\n\n    Tengeneza michanganyiko yote ya kipekee ya namba tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    kiasi kwamba namba ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarudisha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina namba tatu za mzima zinazowakilisha\n                          michanganyiko halali ya namba kwa mpangilio wa kupanda kulingana na namba ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "tr": "Bir python fonksiyonu 'def find_number_combinations():' yazın ve aşağıdaki problemi çözün:\n\n    1'den 9'a kadar olan rakamlardan, tekrar etmeden, her biri üç rakamdan oluşan tüm benzersiz kombinasyonları oluşturun,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Döndürür:\n        list of tuples: Her bir tuple'ın geçerli sayı kombinasyonlarını birinci sayıya göre artan sırada içerdiği\n                        sıralı tuple listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "vi": "Viết một hàm python 'def find_number_combinations():' để giải quyết vấn đề sau:\n\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo thành từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        list of tuples: Một danh sách đã sắp xếp của các bộ ba, trong đó mỗi bộ ba chứa ba số nguyên đại diện cho\n                        các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]"
    },
    "instruction_bertscore": {
      "es": "0.9828077459999063",
      "arb": "0.9510928303208278",
      "sw": "0.9793297280279853",
      "tr": "0.9470419623300023",
      "vi": "0.9604193212319398"
    },
    "level": "middle",
    "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")",
    "entry_point": "find_number_combinations",
    "signature": "def find_number_combinations():",
    "docstring": {
      "en": "\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    ",
      "es": "Genera todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición, de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\nDevuelve:\n    list of tuples: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las combinaciones de números válidas en orden ascendente basado en el primer número.\n\nEjemplo:\n    >>> find_number_combinations()\n    [(123, 246, 369), (124, 248, 372), ...]",
      "arb": "    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 بدون تكرار،\n    بحيث يكون الرقم الثاني ضعف الأول والثالث ثلاثة أضعاف الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من المجموعات، حيث يحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل\n                        توليفات الأرقام الصحيحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    امثله:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "sw": "    Tengeneza mchanganyiko wa kipekee wa nambari tatu, kila moja ikitengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    ambapo nambari ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarejesha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina nambari tatu za mzima zinazowakilisha\n                          mchanganyiko halali wa nambari katika mpangilio wa kupanda kulingana na nambari ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "tr": "    1'den 9'a kadar olan rakamlardan tekrar etmeden oluşturulan üç sayının tüm benzersiz kombinasyonlarını üretin,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Dönüş:\n        list of tuples: Her bir demetin, ilk sayıya göre artan sırayla geçerli sayı kombinasyonlarını temsil eden\n                        üç tam sayı içerdiği sıralı bir demet listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "vi": "    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        list of tuples: Một danh sách đã sắp xếp của các bộ ba, trong đó mỗi bộ ba chứa ba số nguyên đại diện cho\n                        các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]"
    },
    "docstring_bertscore": {
      "es": "0.9806273803072864",
      "arb": "0.9405163584218631",
      "sw": "0.956804645557867",
      "tr": "0.959537402340145",
      "vi": "0.9534195866042704"
    }
  },
  {
    "task_id": "Python/10",
    "prompt": {
      "en": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "es": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calcular la suma acumulativa de valores factoriales desde 1 hasta un entero especificado n.\n\n    Esta función emplea un método más eficiente para calcular factoriales multiplicando\n    iterativamente el número actual por el resultado factorial anterior, evitando así cálculos\n    redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\n    Argumentos:\n    n (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\n             El valor de n debe estar en el rango de 1 a 50, inclusive.\n\n    Devuelve:\n    int: La suma de todos los valores factoriales desde 1! hasta n!.\n\n    Ejemplos:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "arb": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    حساب المجموع التراكمي لقيم المضروب من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضروبات عن طريق ضرب الرقم الحالي في نتيجة المضروب السابقة،\n    وبالتالي تجنب الحسابات المتكررة. ثم تجمع مضروب كل رقم من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضروب له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\n    يعيد:\n    int: مجموع جميع قيم المضروب من 1! إلى n!.\n\n    أمثلة:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "sw": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Kuhesabu jumla ya thamani za faktoria kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii inatumia mbinu bora zaidi ya kuhesabu faktoria kwa kuzidisha\n    namba ya sasa na matokeo ya faktoria ya awali, hivyo kuepuka mahesabu\n    yanayojirudia. Kisha inakusanya faktoria ya kila namba kutoka 1 hadi n\n    ikijumuishwa.\n\n    Hoja:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya faktoria itahesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuishwa.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za faktoria kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "tr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1'den belirtilen bir tamsayı n'e kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyel hesaplamalarını daha verimli bir şekilde gerçekleştirmek için\n    mevcut sayıyı önceki faktöriyel sonucuyla çarparak yinelemeli bir yöntem kullanır, böylece\n    gereksiz hesaplamalardan kaçınılır. Daha sonra 1'den n'e kadar her sayının faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n değeri 1 ile 50 arasında olmalıdır, dahil.\n\n    Döndürür:\n    int: 1!'den n!'e kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "vi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân lặp\n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa.\n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa sẽ được tính.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9813984634464638",
      "arb": "0.9702288812297288",
      "sw": "0.9642240861806631",
      "tr": "0.9582159144151199",
      "vi": "0.9579509414868194"
    },
    "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials",
    "instruction": {
      "en": "Write a python function 'def sum_of_factorials_optimized(n: int) -> int:' to solve the following problem:\n\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "es": "Escribe una función de Python 'def sum_of_factorials_optimized(n: int) -> int:' para resolver el siguiente problema:\n\n    Calcular la suma acumulativa de los valores factoriales desde 1 hasta un número entero especificado n.\n\n    Esta función emplea un método más eficiente para calcular factoriales multiplicando iterativamente\n    el número actual por el resultado factorial anterior, evitando así cálculos redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\n    Argumentos:\n    n (int): El límite superior del rango para el cual se debe calcular la suma de factoriales.\n             El valor de n debe estar en el rango de 1 a 50, inclusive.\n\n    Devuelve:\n    int: La suma de todos los valores factoriales desde 1! hasta n!.\n\n    Ejemplos:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "arb": "اكتب دالة بايثون 'def sum_of_factorials_optimized(n: int) -> int:' لحل المشكلة التالية:\n\n    احسب المجموع التراكمي لقيم المضاعفات من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضاعفات عن طريق ضرب الرقم الحالي في نتيجة المضاعف السابقة بشكل تكراري، وبالتالي تجنب الحسابات الزائدة. ثم تجمع مضاعف كل رقم من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضاعفات له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\n    يعيد:\n    int: مجموع جميع قيم المضاعفات من 1! إلى n!.\n\n    أمثلة:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "sw": "Andika kazi ya python 'def sum_of_factorials_optimized(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu jumla ya thamani za factorial kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii inatumia njia bora zaidi ya kuhesabu factorial kwa kuzidisha\n    nambari ya sasa na matokeo ya factorial ya awali, hivyo kuepuka mahesabu ya kurudia.\n    Kisha inakusanya factorial ya kila nambari kutoka 1 hadi n ikijumuisha.\n\n    Hoja:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya factorial inapaswa kuhesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuisha.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za factorial kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "tr": "Bir python fonksiyonu 'def sum_of_factorials_optimized(n: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    1'den belirtilen bir tamsayı n'ye kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyelleri hesaplamak için daha verimli bir yöntem kullanır; önceki faktöriyel sonucuna\n    mevcut sayıyı çarparak tekrarlayan hesaplamalardan kaçınır. Daha sonra 1'den n'ye kadar her sayının\n    faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n'nin değeri 1 ile 50 arasında olmalıdır, dahil.\n\n    Döndürür:\n    int: 1!'den n!'ye kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "vi": "Viết một hàm python 'def sum_of_factorials_optimized(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân lặp\n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa.\n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa cần được tính toán.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153"
    },
    "instruction_bertscore": {
      "es": "0.9812711413722204",
      "arb": "0.9766670877702127",
      "sw": "0.9615842884167095",
      "tr": "0.9516021186178012",
      "vi": "0.9685619750720841"
    },
    "level": "easy",
    "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()",
    "entry_point": "sum_of_factorials_optimized",
    "signature": "def sum_of_factorials_optimized(n: int) -> int:",
    "docstring": {
      "en": "\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "es": "Calcular la suma acumulativa de los valores factoriales desde 1 hasta un entero especificado n.\n\nEsta función emplea un método más eficiente para calcular factoriales multiplicando iterativamente el número actual por el resultado factorial anterior, evitando así cálculos redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\nArgumentos:\nn (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\n         El valor de n debe estar en el rango de 1 a 50, inclusive.\n\nDevuelve:\nint: La suma de todos los valores factoriales desde 1! hasta n!.\n\nEjemplos:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153",
      "arb": "    حساب مجموع القيم التراكمية للعاملي من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب القيم العاملي عن طريق ضرب العدد الحالي\n    في نتيجة العاملي السابقة بشكل تكراري، مما يتجنب الحسابات المكررة. ثم تجمع العاملي\n    لكل عدد من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع القيم العاملي له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شامل.\n\n    يعيد:\n    int: مجموع كل القيم العاملي من 1! إلى n!.\n\n    امثله:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "sw": "    Hesabu jumla ya thamani za faktoria kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii hutumia njia bora zaidi ya kuhesabu faktoria kwa kuzidisha\n    nambari ya sasa na matokeo ya faktoria ya awali, hivyo kuepuka mahesabu\n    yasiyo ya lazima. Kisha inakusanya faktoria ya kila nambari kutoka 1 hadi n ikijumuishwa.\n\n    Vipengele:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya faktoria itahesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuishwa.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za faktoria kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "tr": "    1'den belirtilen bir tamsayı n'e kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyelleri hesaplamak için daha verimli bir yöntem kullanır; önceki faktöriyel sonucuna\n    mevcut sayıyı iteratif olarak çarparak gereksiz hesaplamalardan kaçınır. Daha sonra 1'den n'e kadar\n    her sayının faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n değeri 1 ile 50 arasında olmalıdır, her iki değer de dahil.\n\n    Döndürür:\n    int: 1!'den n!'e kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "vi": "    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân lặp\n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa.\n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa sẽ được tính toán.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153"
    },
    "docstring_bertscore": {
      "es": "0.9765741287518884",
      "arb": "0.961615473386532",
      "sw": "0.9466464892413617",
      "tr": "0.9523714140835493",
      "vi": "0.9618562134083463"
    }
  },
  {
    "task_id": "Python/11",
    "prompt": {
      "en": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"",
      "es": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\n    Argumentos:\n    - N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\n    Devuelve:\n    - str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.\n    \"\"\"",
      "arb": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    يحدد البسط والمقام للعنصر N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.\n    \"\"\"",
      "sw": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Huamua kianzilishi na kipeuo cha neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana nayo.\n\n    Inarejesha:\n    - str: Uwakilishi wa herufi wa sehemu katika nafasi ya N katika jedwali la Cantor.\n    \"\"\"",
      "tr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor tablosundaki N-inci terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N-inci pozisyondaki kesirin string gösterimi.\n    \"\"\"",
      "vi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9740302694619746",
      "arb": "0.9303027842290491",
      "sw": "0.960180964774698",
      "tr": "0.9639386543231161",
      "vi": "0.9540875805756908"
    },
    "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"",
    "instruction": {
      "en": "Write a python function 'def cantor_numbering(N: int) -> str:' to solve the following problem:\n\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    ",
      "es": "Escribe una función en Python 'def cantor_numbering(N: int) -> str:' para resolver el siguiente problema:\n\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\n    Argumentos:\n    - N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\n    Devuelve:\n    - str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.",
      "arb": "اكتب دالة بايثون 'def cantor_numbering(N: int) -> str:' لحل المشكلة التالية:\n\n    تحديد البسط والمقام للعنصر N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.",
      "sw": "Andika kazi ya python 'def cantor_numbering(N: int) -> str:' kutatua tatizo lifuatalo:\n\n    Huamua numerator na denominator ya neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana nayo.\n\n    Inarejesha:\n    - str: Uwakilishi wa kamba wa sehemu katika nafasi ya N katika jedwali la Cantor.",
      "tr": "Bir python fonksiyonu 'def cantor_numbering(N: int) -> str:' yazın:\n\n    Cantor tablosundaki N. terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki ilgili kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N. pozisyondaki kesirin string gösterimi.",
      "vi": "Viết một hàm python 'def cantor_numbering(N: int) -> str:' để giải quyết vấn đề sau:\n\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor."
    },
    "instruction_bertscore": {
      "es": "0.9776663972171993",
      "arb": "0.9383681708509708",
      "sw": "0.9514096457785784",
      "tr": "0.9327797050805542",
      "vi": "0.9634577701706306"
    },
    "level": "easy",
    "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()",
    "entry_point": "cantor_numbering",
    "signature": "def cantor_numbering(N: int) -> str:",
    "docstring": {
      "en": "\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    ",
      "es": "Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\nArgumentos:\n- N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\nDevuelve:\n- str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.",
      "arb": "    يحدد البسط والمقام للحد N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.",
      "sw": "    Huamua kigezo na kipatanishi cha neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana.\n\n    Inarejesha:\n    - str: Uwakilishi wa kamba ya sehemu katika nafasi ya N katika jedwali la Cantor.",
      "tr": "    Cantor tablosundaki N. terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N. pozisyondaki kesirin string gösterimi.",
      "vi": "    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi đại diện cho phân số tại vị trí thứ N trong bảng Cantor."
    },
    "docstring_bertscore": {
      "es": "0.9525487910138135",
      "arb": "0.9515987419013237",
      "sw": "0.856607337518247",
      "tr": "0.9529116887199642",
      "vi": "0.9442543835625586"
    }
  },
  {
    "task_id": "Python/12",
    "prompt": {
      "en": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"",
      "es": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)\n    \"\"\"",
      "arb": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب المراد إدراجها.\n    نوع الإرجاع: int (تُرجع الدالة أكبر حاصل يمكن الحصول عليه عن طريق إدراج K علامات ضرب في سلسلة الأرقام.)\n    \"\"\"",
      "sw": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Mstari wa herufi unaowakilisha mstari wa nambari.\n    N (int): Nambari kamili inayowakilisha urefu wa mstari wa nambari.\n    K (int): Nambari kamili inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa ya juu zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K kwenye mstari wa nambari.)\n    \"\"\"",
      "tr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizisini temsil eden bir string.\n    N (int): Sayı dizisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işareti sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)\n    \"\"\"",
      "vi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn vào.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9744233589860426",
      "arb": "0.9525918938064981",
      "sw": "0.9459771048572743",
      "tr": "0.9579972223656005",
      "vi": "0.9711721769092636"
    },
    "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]",
    "instruction": {
      "en": "Write a python function 'def max_product(num_str: str, N: int, K: int) -> int:' to solve the following problem:\n\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    ",
      "es": "Escribe una función de Python 'def max_product(num_str: str, N: int, K: int) -> int:' para resolver el siguiente problema:\n\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)",
      "arb": "اكتب دالة بايثون 'def max_product(num_str: str, N: int, K: int):' لحل المشكلة التالية:\n\n    اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب التي سيتم إدراجها.\n    نوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه بإدراج K علامات ضرب في سلسلة الأرقام.)",
      "sw": "Andika kazi ya python 'def max_product(num_str: str, N: int, K: int) -> int:' kutatua tatizo lifuatalo:\n\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Mfuatano wa herufi unaowakilisha mfuatano wa nambari.\n    N (int): Nambari kamili inayowakilisha urefu wa mfuatano wa nambari.\n    K (int): Nambari kamili inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa ya juu zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K kwenye mfuatano wa nambari.)",
      "tr": "Bir Python fonksiyonu 'def max_product(num_str: str, N: int, K: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizgisini temsil eden bir dize.\n    N (int): Sayı dizgisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işaretlerinin sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)",
      "vi": "Viết một hàm python 'def max_product(num_str: str, N: int, K: int) -> int:' để giải quyết vấn đề sau:\n\n    Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn vào.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)"
    },
    "instruction_bertscore": {
      "es": "0.9738693788533364",
      "arb": "0.9430820670536907",
      "sw": "0.9355245783160753",
      "tr": "0.9579650442438729",
      "vi": "0.9491464512170669"
    },
    "level": "middle",
    "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()",
    "entry_point": "max_product",
    "signature": "def max_product(num_str: str, N: int, K: int) -> int:",
    "docstring": {
      "en": "\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    ",
      "es": "    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)",
      "arb": "اسم الدالة: max_product  \nالمعطيات:  \nnum_str (str): سلسلة تمثل رقمًا كسلسلة نصية.  \nN (int): عدد صحيح يمثل طول سلسلة الرقم.  \nK (int): عدد صحيح يمثل عدد علامات الضرب التي سيتم إدراجها.  \nنوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه بإدراج K من علامات الضرب في سلسلة الرقم.)  ",
      "sw": "    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Kamba inayowakilisha mfuatano wa nambari.\n    N (int): Nambari ya mzima inayowakilisha urefu wa mfuatano wa nambari.\n    K (int): Nambari ya mzima inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa ya juu zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K katika mfuatano wa nambari.)",
      "tr": "Fonksiyon adı: max_product\nArgümanlar:\nnum_str (str): Sayı dizgisini temsil eden bir dize.\nN (int): Sayı dizgisinin uzunluğunu temsil eden bir tamsayı.\nK (int): Eklenecek çarpma işaretlerinin sayısını temsil eden bir tamsayı.\nDönüş tipi: int (Fonksiyon, sayı dizgisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)",
      "vi": "    Tên hàm: max_product\n    Đối số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)"
    },
    "docstring_bertscore": {
      "es": "0.9676663506839978",
      "arb": "0.7405293318845066",
      "sw": "0.9157981979147385",
      "tr": "0.9368623539323453",
      "vi": "0.9351916737974608"
    }
  },
  {
    "task_id": "Python/13",
    "prompt": {
      "en": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"\n\n",
      "es": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Si la puntuación promedio final es mayor que 80 y se publican uno o más artículos, se añadirá una beca de 8000\n    Si la puntuación promedio final es mayor que 85 puntos y la evaluación de la clase es mayor que 80 puntos, la beca se incrementará en 4000 puntos\n    Si la puntuación promedio final es mayor que 90 puntos, la beca se incrementará en 2000\n    Si la puntuación promedio final es mayor que 85 y el estudiante es de la región occidental, la beca se incrementará en 1000\n    Si la evaluación final de la clase es mayor que 80 puntos y el líder de la clase es el líder de la clase, la beca se incrementará en 850 puntos\n\n    Parámetros:\n    grades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de la clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Retorna:\n    int: La cantidad total de beca a la que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "arb": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    إذا كان متوسط الدرجة النهائية أكبر من 80 وتم نشر ورقة بحثية واحدة أو أكثر، سيتم إضافة منحة دراسية بقيمة 8000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 نقطة وكان تقييم الفصل أكبر من 80 نقطة، سيتم زيادة المنحة الدراسية بمقدار 4000 نقطة\n    إذا كان متوسط الدرجة النهائية أكبر من 90 نقطة، سيتم زيادة المنحة الدراسية بمقدار 2000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 وكان الطالب من المنطقة الغربية، سيتم زيادة المنحة الدراسية بمقدار 1000\n    إذا كان التقييم النهائي للفصل أكبر من 80 نقطة وكان قائد الفصل هو قائد الفصل، سيتم زيادة المنحة الدراسية بمقدار 850 نقطة\n\n    Parameters:\n    grades (list of int): قائمة تحتوي على درجتين أكاديميتين للطالب [متوسط نهاية الفصل، تقييم الفصل].\n    leader (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الفصل.\n    west (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (int): عدد يمثل عدد الأوراق البحثية المنشورة من قبل الطالب.\n\n    يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يكون الطالب مؤهلاً للحصول عليه.\n\n    امثله:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "sw": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko 80 na karatasi moja au zaidi zimechapishwa, udhamini wa 8000 utaongezwa\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko pointi 85 na tathmini ya darasa ni kubwa kuliko pointi 80, udhamini utaongezwa kwa pointi 4000\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko pointi 90, udhamini utaongezwa kwa 2000\n    Ikiwa alama ya wastani ya mwisho ni kubwa kuliko 85 na mwanafunzi anatoka mkoa wa magharibi, udhamini utaongezwa kwa 1000\n    Ikiwa tathmini ya mwisho ya darasa ni kubwa kuliko pointi 80 na kiongozi wa darasa ni kiongozi wa darasa, udhamini utaongezwa kwa 850\n\n    Parameters:\n    grades (list of int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [wastani wa mwisho wa muhula, tathmini ya darasa].\n    leader (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi ni kiongozi wa darasa.\n    west (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi anatoka mkoa wa magharibi.\n    papers (int): Nambari inayowakilisha idadi ya karatasi za utafiti zilizochapishwa na mwanafunzi.\n\n    Inarejesha:\n    int: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\n    Mifano:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "tr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Eğer final ortalama puanı 80'den büyükse ve bir veya daha fazla makale yayınlanmışsa, burs miktarına 8000 eklenir\n    Eğer final ortalama puanı 85 puandan büyükse ve sınıf değerlendirmesi 80 puandan büyükse, burs miktarı 4000 puan artırılır\n    Eğer final ortalama puanı 90 puandan büyükse, burs miktarı 2000 artırılır\n    Eğer final ortalama puanı 85'ten büyükse ve öğrenci batı bölgesindense, burs miktarı 1000 artırılır\n    Eğer sınıfın son değerlendirmesi 80 puandan büyükse ve sınıf lideri sınıf lideriyse, burs miktarı 850 artırılır\n\n    Parametreler:\n    grades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\n    leader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\n    west (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\n    papers (int): Öğrencinin yayınladığı araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\n    Dönüş:\n    int: Öğrencinin hak kazandığı toplam burs miktarı.\n\n    Örnekler:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "vi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Nếu điểm trung bình cuối kỳ lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng sẽ được cộng thêm 8000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 điểm và đánh giá lớp lớn hơn 80 điểm, học bổng sẽ được tăng thêm 4000 điểm\n    Nếu điểm trung bình cuối kỳ lớn hơn 90 điểm, học bổng sẽ được tăng thêm 2000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 và sinh viên đến từ khu vực phía tây, học bổng sẽ được tăng thêm 1000\n    Nếu đánh giá cuối kỳ của lớp lớn hơn 80 điểm và lớp trưởng là lớp trưởng, học bổng sẽ được tăng thêm 850 điểm\n\n    Tham số:\n    grades (list of int): Một danh sách hai phần tử chứa điểm học tập của sinh viên [điểm trung bình cuối kỳ, đánh giá lớp].\n    leader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có phải là lớp trưởng hay không.\n    west (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có đến từ tỉnh phía tây hay không.\n    papers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được sinh viên xuất bản.\n\n    Trả về:\n    int: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\n    Ví dụ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.988396609031085",
      "arb": "0.9621813713421004",
      "sw": "0.9663585682552641",
      "tr": "0.9499771234705547",
      "vi": "0.9668229660861236"
    },
    "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship",
    "instruction": {
      "en": "Write a python function 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' to solve the following problem:\n\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ",
      "es": "Escribe una función de Python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' para resolver el siguiente problema:\n\n    Si la puntuación media final es superior a 80 y se publican uno o más artículos, se añadirá una beca de 8000\n    Si la puntuación media final es superior a 85 puntos y la evaluación de la clase es superior a 80 puntos, la beca se incrementará en 4000 puntos\n    Si la puntuación media final es superior a 90 puntos, la beca se incrementará en 2000\n    Si la puntuación media final es superior a 85 y el estudiante es de la región occidental, la beca se incrementará en 1000\n    Si la evaluación final de la clase es superior a 80 puntos y el líder de la clase es el líder de la clase, la beca se incrementará en 850 puntos\n\n    Parámetros:\n    grades (lista de int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Retorna:\n    int: La cantidad total de beca para la que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "arb": "اكتب دالة بايثون 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' لحل المشكلة التالية:\n\n    إذا كان متوسط الدرجة النهائية أكبر من 80 وتم نشر ورقة أو أكثر، سيتم إضافة منحة دراسية بقيمة 8000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 نقطة وكان تقييم الصف أكبر من 80 نقطة، سيتم زيادة المنحة الدراسية بمقدار 4000 نقطة\n    إذا كان متوسط الدرجة النهائية أكبر من 90 نقطة، سيتم زيادة المنحة الدراسية بمقدار 2000\n    إذا كان متوسط الدرجة النهائية أكبر من 85 وكان الطالب من المنطقة الغربية، سيتم زيادة المنحة الدراسية بمقدار 1000\n    إذا كان التقييم النهائي للصف أكبر من 80 نقطة وكان قائد الصف هو قائد الصف، سيتم زيادة المنحة الدراسية بمقدار 850 نقطة\n\n    المعاملات:\n    grades (قائمة من الأعداد الصحيحة): قائمة تحتوي على عنصرين تمثل درجات الطالب الأكاديمية [متوسط نهاية الفصل، تقييم الصف].\n    leader (سلسلة نصية): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الصف.\n    west (سلسلة نصية): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (عدد صحيح): عدد صحيح يمثل عدد الأوراق البحثية المنشورة من قبل الطالب.\n\n    يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يستحقه الطالب.\n\n    أمثلة:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "sw": "Andika kazi ya python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' kutatua tatizo lifuatalo:\n\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya 80 na moja au zaidi ya karatasi zimechapishwa, udhamini wa 8000 utaongezwa\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya pointi 85 na tathmini ya darasa ni zaidi ya pointi 80, udhamini utaongezwa kwa pointi 4000\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya pointi 90, udhamini utaongezwa kwa 2000\n    Ikiwa alama ya wastani ya mwisho ni zaidi ya 85 na mwanafunzi anatoka katika eneo la magharibi, udhamini utaongezwa kwa 1000\n    Ikiwa tathmini ya mwisho ya darasa ni zaidi ya pointi 80 na kiongozi wa darasa ni kiongozi wa darasa, udhamini utaongezwa kwa 850\n\n    Vigezo:\n    grades (orodha ya int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [mwisho wa wastani wa muhula, tathmini ya darasa].\n    leader (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi ni kiongozi wa darasa.\n    west (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi anatoka katika jimbo la magharibi.\n    papers (int): Nambari inayoonyesha idadi ya karatasi za utafiti zilizochapishwa na mwanafunzi.\n\n    Inarudi:\n    int: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\n    Mifano:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "tr": "Bir python fonksiyonu 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Eğer nihai ortalama puan 80'den büyükse ve bir veya daha fazla makale yayınlanmışsa, 8000 burs eklenecektir\n    Eğer nihai ortalama puan 85 puandan büyükse ve sınıf değerlendirmesi 80 puandan büyükse, burs 4000 puan artırılacaktır\n    Eğer nihai ortalama puan 90 puandan büyükse, burs 2000 artırılacaktır\n    Eğer nihai ortalama puan 85'ten büyükse ve öğrenci batı bölgesindense, burs 1000 artırılacaktır\n    Eğer sınıfın nihai değerlendirmesi 80 puandan büyükse ve sınıf lideri sınıf lideriyse, burs 850 artırılacaktır\n\n    Parametreler:\n    grades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\n    leader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir string ('Y' veya 'N').\n    west (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir string ('Y' veya 'N').\n    papers (int): Öğrenci tarafından yayınlanan araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\n    Dönüş:\n    int: Öğrencinin hak kazandığı toplam burs miktarı.\n\n    Örnekler:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "vi": "Viết một hàm python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' để giải quyết vấn đề sau:\n\n    Nếu điểm trung bình cuối kỳ lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng sẽ được cộng thêm 8000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 điểm và đánh giá lớp lớn hơn 80 điểm, học bổng sẽ được tăng thêm 4000 điểm\n    Nếu điểm trung bình cuối kỳ lớn hơn 90 điểm, học bổng sẽ được tăng thêm 2000\n    Nếu điểm trung bình cuối kỳ lớn hơn 85 và sinh viên đến từ khu vực phía tây, học bổng sẽ được tăng thêm 1000\n    Nếu đánh giá cuối kỳ của lớp lớn hơn 80 điểm và lớp trưởng là lớp trưởng, học bổng sẽ được tăng thêm 850 điểm\n\n    Tham số:\n    grades (list of int): Một danh sách hai phần tử chứa điểm học tập của sinh viên [điểm trung bình cuối kỳ, đánh giá lớp].\n    leader (str): Một chuỗi ('Y' hoặc 'N') cho biết liệu sinh viên có phải là lớp trưởng hay không.\n    west (str): Một chuỗi ('Y' hoặc 'N') cho biết liệu sinh viên có đến từ một tỉnh phía tây hay không.\n    papers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được xuất bản bởi sinh viên.\n\n    Trả về:\n    int: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\n    Ví dụ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000"
    },
    "instruction_bertscore": {
      "es": "0.9842057066216299",
      "arb": "0.9596514161788591",
      "sw": "0.9536807855553313",
      "tr": "0.9599340672110717",
      "vi": "0.9754598123142827"
    },
    "level": "easy",
    "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()",
    "entry_point": "calculate_scholarship",
    "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:",
    "docstring": {
      "en": "\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ",
      "es": "    Si la puntuación promedio final es mayor que 80 y se publican uno o más artículos, se añadirá una beca de 8000\n    Si la puntuación promedio final es mayor que 85 puntos y la evaluación de la clase es mayor que 80 puntos, la beca se incrementará en 4000 puntos\n    Si la puntuación promedio final es mayor que 90 puntos, la beca se incrementará en 2000\n    Si la puntuación promedio final es mayor que 85 y el estudiante es de la región occidental, la beca se incrementará en 1000\n    Si la evaluación final de la clase es mayor que 80 puntos y el líder de la clase es el líder de la clase, la beca se incrementará en 850 puntos\n\n    Parámetros:\n    grades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de la clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Devuelve:\n    int: La cantidad total de beca para la que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "arb": "    إذا كانت الدرجة النهائية المتوسطة أكبر من 80 وتم نشر ورقة بحثية واحدة أو أكثر، سيتم إضافة منحة دراسية بقيمة 8000\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 85 نقطة وكان تقييم الفصل أكبر من 80 نقطة، سيتم زيادة المنحة الدراسية بمقدار 4000 نقطة\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 90 نقطة، سيتم زيادة المنحة الدراسية بمقدار 2000\n    إذا كانت الدرجة النهائية المتوسطة أكبر من 85 وكان الطالب من المنطقة الغربية، سيتم زيادة المنحة الدراسية بمقدار 1000\n    إذا كان التقييم النهائي للفصل أكبر من 80 نقطة وكان قائد الفصل هو قائد الفصل، سيتم زيادة المنحة الدراسية بمقدار 850 نقطة\n\n    Parameters:\n    grades (list of int): قائمة تحتوي على درجتين أكاديميتين للطالب [متوسط نهاية الفصل، تقييم الفصل].\n    leader (str): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الفصل.\n    west (str): سلسلة نصية ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (int): عدد صحيح يمثل عدد الأبحاث المنشورة من قبل الطالب.\n\n   يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يكون الطالب مؤهلاً للحصول عليه.\n\n    امثله:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "sw": "Ikiwa alama ya wastani ya mwisho ni zaidi ya 80 na moja au zaidi ya karatasi zimechapishwa, udhamini wa 8000 utaongezwa  \nIkiwa alama ya wastani ya mwisho ni zaidi ya 80 na karatasi moja au zaidi zimechapishwa, udhamini wa 8000 utaongezwa \nIkiwa alama ya wastani ya mwisho ni zaidi ya pointi 85 na tathmini ya darasa ni zaidi ya pointi 80, udhamini utaongezwa kwa pointi 4000 \nIkiwa alama ya wastani ya mwisho ni zaidi ya pointi 90, udhamini utaongezwa kwa 2000  \nIkiwa alama ya wastani ya mwisho ni zaidi ya 85 na mwanafunzi anatoka eneo la magharibi, udhamini utaongezwa kwa 1000  \nIkiwa tathmini ya mwisho ya darasa ni zaidi ya pointi 80 na kiongozi wa darasa ni kiongozi wa darasa, udhamini utaongezwa kwa pointi 850\n\nParameters:  \ngrades (list of int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [mwisho wa wastani wa muhula, tathmini ya darasa].  \nleader (str): Kamba ('Y' au 'N') inayoonyesha ikiwa mwanafunzi ni kiongozi wa darasa.  \nwest (str): Kamba ('Y' au 'N') inayoonyesha ikiwa mwanafunzi anatoka mkoa wa magharibi.  \npapers (int): Nambari inayoonyesha idadi ya karatasi za utafiti zilizochapishwa na mwanafunzi.\n\nInarejesha:  \nint: Kiasi cha jumla cha udhamini ambacho mwanafunzi anastahili.\n\nMifano:  \n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)  \n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)  \n9000",
      "tr": "Eğer nihai ortalama puan 80'den büyükse ve bir veya daha fazla makale yayımlanmışsa, 8000 burs eklenecektir\nEğer nihai ortalama puan 85 puandan büyükse ve sınıf değerlendirmesi 80 puandan büyükse, burs 4000 puan artırılacaktır\nEğer nihai ortalama puan 90 puandan büyükse, burs 2000 artırılacaktır\nEğer nihai ortalama puan 85'ten büyükse ve öğrenci batı bölgesindense, burs 1000 artırılacaktır\nEğer sınıfın nihai değerlendirmesi 80 puandan büyükse ve sınıf lideri sınıf lideriyse, burs 850 artırılacaktır\n\nParametreler:\ngrades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\nleader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\nwest (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\npapers (int): Öğrencinin yayımladığı araştırma makalelerinin sayısını temsil eden bir tam sayı.\n\nDöndürülenler:\nint: Öğrencinin hak kazandığı toplam burs miktarı.\n\nÖrnekler:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000",
      "vi": "Nếu điểm trung bình cuối kỳ lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng sẽ được cộng thêm 8000  \nNếu điểm trung bình cuối cùng lớn hơn 80 và có một hoặc nhiều bài báo được xuất bản, học bổng 8000 sẽ được thêm vào   \nNếu điểm trung bình cuối cùng lớn hơn 85 điểm và đánh giá lớp lớn hơn 80 điểm, học bổng sẽ được tăng thêm 4000 điểm  \nNếu điểm trung bình cuối cùng lớn hơn 90 điểm, học bổng sẽ được tăng thêm 2000  \nNếu điểm trung bình cuối cùng lớn hơn 85 và học sinh đến từ khu vực miền Tây, học bổng sẽ được tăng thêm 1000   \nNếu đánh giá cuối cùng của lớp lớn hơn 80 điểm và lớp trưởng là lớp trưởng, học bổng sẽ được tăng thêm 850 điểm  \n\nParameters:  \ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].  \ngrades (list of int): Danh sách hai phần tử chứa điểm học tập của học sinh [điểm trung bình cuối kỳ, đánh giá lớp]. \nleader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu học sinh là lớp trưởng.   \nwest (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu học sinh đến từ tỉnh miền Tây.  \npapers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được học sinh xuất bản.  \n\nTrả về: \nint: Tổng số tiền học bổng mà học sinh đủ điều kiện nhận.  \n\nVí dụ:  \n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)  \n4850  \n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)  \n9000  "
    },
    "docstring_bertscore": {
      "es": "0.9835549934933595",
      "arb": "0.9608857053666098",
      "sw": "0.9801413317648939",
      "tr": "0.9567841866286204",
      "vi": "0.9999996027392379"
    }
  },
  {
    "task_id": "Python/14",
    "prompt": {
      "en": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "es": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifica la corrección de un número ISBN dado y corrígelo si es necesario.\n\n    La función verifica el número ISBN proporcionado contra el cálculo estándar de suma de verificación de ISBN.\n    Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta,\n    la función devuelve el número ISBN corregido.\n\n    Argumentos:\n    isbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n          donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\n    Devuelve:\n    Una cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\n    en el mismo formato que la entrada si la suma de verificación es incorrecta.\n\n    Ejemplos:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "arb": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    التحقق من صحة رقم ISBN المعطى وتصحيحه إذا لزم الأمر.\n\n    تقوم الدالة بالتحقق من رقم ISBN المقدم وفقًا لحساب التحقق القياسي لـ ISBN.\n    إذا كان حساب التحقق صحيحًا، تعيد الدالة \"Right\". إذا كان حساب التحقق غير صحيح،\n    تعيد الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، ويمكن أن يكون 'x' الأخير أيضًا 'X' لتمثيل رقم التحقق.\n\n    يعيد:\n    سلسلة تكون إما \"Right\" إذا كان حساب التحقق لـ ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق الإدخال إذا كان حساب التحقق غير صحيح.\n\n    امثله:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "sw": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hii inakagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya kawaida ya checksum ya ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN inayopaswa kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo sawa na pembejeo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "tr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verilen ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına göre kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\n    Döndürür:\n    Kontrol toplamı doğruysa \"Right\" veya kontrol toplamı yanlışsa girişle aynı formatta düzeltilmiş\n    ISBN numarasını döndüren bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "vi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Xác minh tính đúng đắn của một số ISBN đã cho và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp dựa trên tính toán tổng kiểm tra tiêu chuẩn ISBN.\n    Nếu tổng kiểm tra đúng, hàm trả về \"Right\". Nếu tổng kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số tổng kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu tổng kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    trong cùng định dạng như đầu vào nếu tổng kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9909223929563246",
      "arb": "0.9536692649932313",
      "sw": "0.9892217196339038",
      "tr": "0.9783794802851145",
      "vi": "0.9855301740023704"
    },
    "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit",
    "instruction": {
      "en": "Write a python function 'def verify_isbn(isbn: str) -> str:' to solve the following problem:\n\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    ",
      "es": "Escribe una función de Python 'def verify_isbn(isbn: str) -> str:' para resolver el siguiente problema:\n\n    Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\n    La función verifica el número ISBN proporcionado contra el cálculo de la suma de verificación estándar de ISBN.\n    Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta,\n    la función devuelve el número ISBN corregido.\n\n    Argumentos:\n    isbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n          donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\n    Devuelve:\n    Una cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\n    en el mismo formato que la entrada si la suma de verificación es incorrecta.\n\n    Ejemplos:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "arb": "اكتب دالة بايثون 'def verify_isbn(isbn: str) -> str:' لحل المشكلة التالية:\n\n    تحقق من صحة رقم ISBN المعطى وصححه إذا لزم الأمر.\n\n    تقوم الدالة بفحص رقم ISBN المقدم مقابل حساب المجموع الاختباري القياسي لـ ISBN.\n    إذا كان المجموع الاختباري صحيحًا، تعيد الدالة \"Right\". إذا كان المجموع الاختباري غير صحيح،\n    تعيد الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، و'X' الأخير يمكن أن يكون أيضًا 'X' لتمثيل رقم المجموع الاختباري.\n\n    يعيد:\n    سلسلة تكون إما \"Right\" إذا كان المجموع الاختباري لـ ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق المدخل إذا كان المجموع الاختباري غير صحيح.\n\n    أمثلة:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "sw": "Andika kazi ya python 'def verify_isbn(isbn: str) -> str:' kutatua tatizo lifuatalo:\n\n    Hakikisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hukagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya kiwango cha checksum cha ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN itakayohakikiwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo sawa na ingizo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "tr": "Bir python fonksiyonu 'def verify_isbn(isbn: str) -> str:' yazarak aşağıdaki problemi çözün:\n\n    Verilen bir ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına göre kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\n    Dönüş:\n    Eğer ISBN kontrol toplamı doğruysa \"Right\" veya kontrol toplamı yanlışsa girişle aynı formatta\n    düzeltilmiş ISBN numarası olan bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "vi": "Viết một hàm python 'def verify_isbn(isbn: str) -> str:' để giải quyết vấn đề sau:\n\n    Xác minh tính chính xác của một số ISBN đã cho và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp dựa trên tính toán kiểm tra tiêu chuẩn ISBN.\n    Nếu kiểm tra đúng, hàm trả về \"Right\". Nếu kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    trong cùng định dạng như đầu vào nếu kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'"
    },
    "instruction_bertscore": {
      "es": "0.9909712560300592",
      "arb": "0.9741277969790627",
      "sw": "0.9902557893975715",
      "tr": "0.9825457525273212",
      "vi": "0.957572749241329"
    },
    "level": "middle",
    "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()",
    "entry_point": "verify_isbn",
    "signature": "def verify_isbn(isbn: str) -> str:",
    "docstring": {
      "en": "\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    ",
      "es": "Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\nLa función verifica el número ISBN proporcionado contra el cálculo estándar de suma de verificación de ISBN. Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta, la función devuelve el número ISBN corregido.\n\nArgumentos:\nisbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n      donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\nDevuelve:\nUna cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\nen el mismo formato que la entrada si la suma de verificación es incorrecta.\n\nEjemplos:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'",
      "arb": "    التحقق من صحة رقم ISBN المقدم وتصحيحه إذا لزم الأمر.\n\n    تقوم الدالة بفحص رقم ISBN المقدم وفقًا لحساب التحقق القياسي لـ ISBN.\n    إذا كان التحقق صحيحًا، تُرجع الدالة \"Right\". إذا كان التحقق غير صحيح،\n    تُرجع الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، ويمكن أن يكون 'x' الأخير أيضًا 'X' لتمثيل رقم التحقق.\n\n    يعيد:\n    سلسلة إما \"Right\" إذا كان تحقق ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق الإدخال إذا كان التحقق غير صحيح.\n\n    امثله:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n",
      "sw": "    Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hii inachunguza nambari ya ISBN iliyotolewa dhidi ya hesabu ya kawaida ya checksum ya ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN inayopaswa kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni ama \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo ule ule kama pembejeo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "tr": "    Verilen bir ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına karşı kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol basamağını temsil eden 'X' de olabilir.\n\n    Döndürür:\n    Kontrol toplamı doğruysa \"Right\" veya kontrol toplamı yanlışsa girişle aynı formatta düzeltilmiş\n    ISBN numarasını döndüren bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "vi": "    Xác minh tính chính xác của một số ISBN đã cho và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp dựa trên tính toán kiểm tra chuẩn của ISBN.\n    Nếu kiểm tra đúng, hàm trả về \"Right\". Nếu kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    trong cùng định dạng như đầu vào nếu kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'"
    },
    "docstring_bertscore": {
      "es": "0.9881642114852741",
      "arb": "0.9273787463898345",
      "sw": "0.9804972774077084",
      "tr": "0.9764172107508708",
      "vi": "0.9463771464446785"
    }
  },
  {
    "task_id": "Python/15",
    "prompt": {
      "en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "es": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizar la colocación de pasillos en un aula para minimizar la cantidad de conversaciones entre estudiantes.\n\n    Argumentos:\n    M (int): El número de filas en el aula.\n    N (int): El número de columnas en el aula.\n    K (int): El número de pasillos horizontales a añadir.\n    L (int): El número de pasillos verticales a añadir.\n    D (int): El número de pares de estudiantes conversando en el aula.\n    chatting_pairs (list of tuples): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par que conversa.\n\n    Devuelve:\n    (str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\n    La función trabaja contando el número de pares que conversan y que pueden ser separados añadiendo un pasillo en cada posición posible.\n    Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares que conversan.\n\n    Ejemplos:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "arb": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي يجب إضافتها.\n    L (int): عدد الممرات الرأسية التي يجب إضافتها.\n    D (int): عدد الأزواج التي تتحدث في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج يتحدث.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافات تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\n    تعمل الدالة عن طريق حساب عدد الأزواج التي يمكن فصلها بإضافة ممر في كل موقع ممكن.\n    ثم تختار المواقع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من الأزواج التي تتحدث.\n\n    أمثلة:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "sw": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza kiasi cha mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya mistari katika darasa.\n    N (int): Idadi ya safu katika darasa.\n    K (int): Idadi ya njia za mlalo za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya wanandoa wanaozungumza darasani.\n    chatting_pairs (list of tuples): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya wanandoa wanaozungumza.\n\n    Inarejesha:\n    (str, str): Kamba mbili zilizotenganishwa na nafasi zinazoonyesha mistari na safu bora kwa njia za kupita.\n\n    Kazi hii inafanya kazi kwa kuhesabu idadi ya wanandoa wanaozungumza ambao wanaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha huchagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha wanandoa wengi wanaozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "tr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Bir sınıfta öğrenciler arasındaki konuşmaları en aza indirmek için koridorların yerleşimini optimize edin.\n\n    Argümanlar:\n    M (int): Sınıftaki sıra sayısı.\n    N (int): Sınıftaki sütun sayısı.\n    K (int): Eklenecek yatay koridor sayısı.\n    L (int): Eklenecek dikey koridor sayısı.\n    D (int): Sınıftaki konuşan çiftlerin sayısı.\n    chatting_pairs (list of tuples): Her biri bir konuşan çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren bir demet listesi.\n\n    Dönüş Değeri:\n    (str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\n    Fonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek konuşan çiftlerin sayısını sayarak çalışır.\n    Daha sonra, mümkün olduğunca çok konuşan çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\n    Örnekler:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Dönüş: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Dönüş: ('2', '2')\n    \"\"\"",
      "vi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Tối ưu hóa việc sắp xếp lối đi trong lớp học để giảm thiểu việc trò chuyện giữa các học sinh.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm.\n    L (int): Số lối đi dọc cần thêm.\n    D (int): Số cặp trò chuyện trong lớp học.\n    chatting_pairs (list of tuples): Danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\n    Hàm hoạt động bằng cách đếm số cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách càng nhiều cặp trò chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2')\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9712687112744466",
      "arb": "0.9625698923674046",
      "sw": "0.9309632302459901",
      "tr": "0.963801797990583",
      "vi": "0.9643162506774634"
    },
    "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)",
    "instruction": {
      "en": "Write a python function 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' to solve the following problem:\n\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    ",
      "es": "Escribe una función de Python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' para resolver el siguiente problema:\n\n    Optimizar la colocación de pasillos en un aula para minimizar la cantidad de conversaciones entre estudiantes.\n\n    Argumentos:\n    M (int): El número de filas en el aula.\n    N (int): El número de columnas en el aula.\n    K (int): El número de pasillos horizontales a añadir.\n    L (int): El número de pasillos verticales a añadir.\n    D (int): El número de pares que conversan en el aula.\n    chatting_pairs (lista de tuplas): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par que conversa.\n\n    Devuelve:\n    (str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\n    La función trabaja contando el número de pares que conversan y que pueden ser separados añadiendo un pasillo en cada posición posible.\n    Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares que conversan.\n\n    Ejemplos:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Devuelve: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Devuelve: ('2', '2')",
      "arb": "اكتب دالة بايثون 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' لحل المشكلة التالية:\n\n    تحسين توزيع الممرات في الفصل الدراسي لتقليل كمية المحادثات بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي يجب إضافتها.\n    L (int): عدد الممرات العمودية التي يجب إضافتها.\n    D (int): عدد الأزواج المتحدثة في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج متحدث.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافة تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\n    تعمل الدالة عن طريق حساب عدد الأزواج المتحدثة التي يمكن فصلها بإضافة ممر في كل موقع ممكن.\n    ثم تختار المواقع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من الأزواج المتحدثة.\n\n    أمثلة:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    يعيد: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    يعيد: ('2', '2')",
      "sw": "Andika kazi ya python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' kutatua tatizo lifuatalo:\n\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza kiasi cha mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya safu katika darasa.\n    N (int): Idadi ya nguzo katika darasa.\n    K (int): Idadi ya njia za usawa za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya jozi zinazozungumza darasani.\n    chatting_pairs (orodha ya jozi): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya jozi inayozungumza.\n\n    Inarudisha:\n    (str, str): Mistari miwili iliyotenganishwa na nafasi inayowakilisha faharasa bora za safu na nguzo kwa njia za kupita.\n\n    Kazi hufanya kazi kwa kuhesabu idadi ya jozi zinazozungumza ambazo zinaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha huchagua nafasi zenye ufanisi zaidi kwa njia za kupita, ikilenga kutenganisha jozi nyingi zinazozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Inarudisha: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Inarudisha: ('2', '2')",
      "tr": "Bir python fonksiyonu 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' yazarak aşağıdaki problemi çözün:\n\n    Bir sınıfta öğrenciler arasındaki konuşmayı en aza indirmek için koridorların yerleştirilmesini optimize edin.\n\n    Argümanlar:\n    M (int): Sınıftaki sıra sayısı.\n    N (int): Sınıftaki sütun sayısı.\n    K (int): Eklenecek yatay koridor sayısı.\n    L (int): Eklenecek dikey koridor sayısı.\n    D (int): Sınıftaki konuşan çiftlerin sayısı.\n    chatting_pairs (list of tuples): Her biri bir konuşan çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren bir demet listesi.\n\n    Döndürür:\n    (str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\n    Fonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek konuşan çiftlerin sayısını sayarak çalışır.\n    Daha sonra, mümkün olduğunca çok konuşan çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\n    Örnekler:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Döndürür: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Döndürür: ('2', '2')",
      "vi": "Viết một hàm python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' để giải quyết vấn đề sau:\n\n    Tối ưu hóa việc bố trí lối đi trong một lớp học để giảm thiểu lượng trò chuyện giữa các học sinh.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm vào.\n    L (int): Số lối đi dọc cần thêm vào.\n    D (int): Số cặp trò chuyện trong lớp học.\n    chatting_pairs (list of tuples): Một danh sách các bộ giá trị, mỗi bộ chứa các vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\n    Hàm hoạt động bằng cách đếm số lượng cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách ra càng nhiều cặp trò chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2')"
    },
    "instruction_bertscore": {
      "es": "0.9700457440184147",
      "arb": "0.9724171921375903",
      "sw": "0.9704265184588586",
      "tr": "0.968612824449629",
      "vi": "0.9746164277164086"
    },
    "level": "hard",
    "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()",
    "entry_point": "optimize_seating",
    "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):",
    "docstring": {
      "en": "\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    ",
      "es": "Optimizar la colocación de pasillos en un aula para minimizar la cantidad de charlas entre estudiantes.\n\nArgumentos:\nM (int): El número de filas en el aula.\nN (int): El número de columnas en el aula.\nK (int): El número de pasillos horizontales a añadir.\nL (int): El número de pasillos verticales a añadir.\nD (int): El número de pares de charlas en el aula.\nchatting_pairs (list of tuples): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par de charlas.\n\nDevuelve:\n(str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\nLa función trabaja contando el número de pares de charlas que pueden ser separados añadiendo un pasillo en cada posición posible. Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares de charlas.\n\nEjemplos:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDevuelve: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDevuelve: ('2', '2')",
      "arb": "    تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي سيتم إضافتها.\n    L (int): عدد الممرات العمودية التي سيتم إضافتها.\n    D (int): عدد الأزواج التي تتحدث في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، يحتوي كل زوج على المواقع (Xi, Yi) و (Pi, Qi) لزوج يتحدث.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافة تمثلان الفهارس المثلى للصفوف والأعمدة للممرات.\n\n    تعمل الدالة عن طريق حساب عدد الأزواج التي يمكن فصلها بإضافة ممر في كل موضع ممكن.\n    ثم تختار المواضع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من الأزواج.\n\n    امثله:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    يعيد: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    يعيد: ('2', '2')",
      "sw": "    Boresha uwekaji wa njia za kupita darasani ili kupunguza mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya mistari katika darasa.\n    N (int): Idadi ya safu katika darasa.\n    K (int): Idadi ya njia za usawa za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya wanandoa wanaozungumza darasani.\n    chatting_pairs (orodha ya jozi): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya wanandoa wanaozungumza.\n\n    Inarejesha:\n    (str, str): Mistari miwili iliyotenganishwa na nafasi inayoonyesha faharasa bora za mistari na safu kwa njia za kupita.\n\n    Kazi hii inafanya kazi kwa kuhesabu idadi ya wanandoa wanaozungumza ambao wanaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha huchagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha wanandoa wengi wanaozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Inarudisha: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Inarudisha: ('2', '2')",
      "tr": "Optimize sınıftaki koridorların yerleşimini, öğrenciler arasındaki sohbet miktarını en aza indirmek için optimize edin.\n\nArgümanlar:\nM (int): Sınıftaki sıra sayısı.\nN (int): Sınıftaki sütun sayısı.\nK (int): Eklenecek yatay koridor sayısı.\nL (int): Eklenecek dikey koridor sayısı.\nD (int): Sınıftaki sohbet eden çift sayısı.\nchatting_pairs (list of tuples): Her biri sohbet eden bir çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren demetlerden oluşan bir liste.\n\nDöndürür:\n(str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\nFonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek sohbet eden çiftlerin sayısını sayarak çalışır. Ardından, mümkün olduğunca çok sohbet eden çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\nÖrnekler:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDöndürür: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDöndürür: ('2', '2')",
      "vi": "    Tối ưu hóa việc bố trí lối đi trong một lớp học để giảm thiểu lượng trò chuyện giữa các học sinh.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm.\n    L (int): Số lối đi dọc cần thêm.\n    D (int): Số cặp trò chuyện trong lớp học.\n    chatting_pairs (list of tuples): Danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\n    Hàm hoạt động bằng cách đếm số cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách ra càng nhiều cặp trò chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2')"
    },
    "docstring_bertscore": {
      "es": "0.9747079963220656",
      "arb": "0.9633304480963872",
      "sw": "0.9179888923871723",
      "tr": "0.9773080680098123",
      "vi": "0.9332069590301603"
    }
  },
  {
    "task_id": "Python/16",
    "prompt": {
      "en": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "es": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Cuenta el número de formas diferentes de pasar una pelota entre 'n' estudiantes dispuestos en un círculo\n    de manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\n    La función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante\n    puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\n    Argumentos:\n    n: El número de estudiantes de pie en un círculo.\n    m: El número de veces que se pasa la pelota.\n\n    Devuelve:\n    Un entero que representa el número de formas distintas de pasar la pelota que resultan en que la pelota\n    regrese al estudiante inicial después de 'm' pases.\n\n    Casos:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "arb": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة\n    بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأ التمرير.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. كل طالب\n    يمكنه تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد طرق التمرير المميزة التي تؤدي إلى\n    عودة الكرة إلى الطالب الذي بدأ التمرير بعد 'm' تمريرات.\n\n    حالات:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "sw": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu kuamua idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira ama kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliopo katika duara.\n    m: Idadi ya mara ambazo mpira unapitiwa.\n\n    Inarejesha:\n    Nambari inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "tr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Bir daire şeklinde dizilmiş 'n' öğrenci arasında bir topu geçmenin farklı yollarının sayısını sayar\n    öyle ki 'm' pas sonrasında top başlangıçtaki öğrenciye geri döner.\n\n    Fonksiyon, pas dizilerinin sayısını belirlemek için dinamik programlama kullanır. Her öğrenci\n    topu ya sol komşusuna ya da sağ komşusuna geçirebilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez paslandığı.\n\n    Döndürür:\n    'm' pas sonrasında topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı paslaşma yollarının sayısını temsil eden bir tamsayı.\n\n    Durumlar:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "vi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Đếm số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh được sắp xếp thành vòng tròn\n    sao cho sau 'm' lần chuyền, quả bóng trở về học sinh bắt đầu.\n\n    Hàm này sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần quả bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là quả bóng\n    trở về học sinh bắt đầu sau 'm' lần chuyền.\n\n    Trường hợp:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9854894547742583",
      "arb": "0.9743691328920201",
      "sw": "0.9843475287136887",
      "tr": "0.9841389668136021",
      "vi": "0.9477498810080106"
    },
    "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]",
    "instruction": {
      "en": "Write a python function 'def count_passing_ways(n: int, m: int) -> int:' to solve the following problem:\n\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "es": "Escribe una función de Python 'def count_passing_ways(n: int, m: int) -> int:' para resolver el siguiente problema:\n\n    Cuenta el número de formas diferentes de pasar una pelota entre 'n' estudiantes dispuestos en un círculo \n    de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\n    La función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante\n    puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\n    Args:\n    n: El número de estudiantes parados en un círculo.\n    m: El número de veces que se pasa la pelota.\n\n    Devuelve:\n    Un entero que representa el número de formas distintas de pasar la pelota que resultan en que la pelota\n    regrese al estudiante inicial después de 'm' pases.\n\n    Casos:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "arb": "اكتب دالة بايثون 'def count_passing_ways(n: int, m: int) -> int:' لحل المشكلة التالية:\n\n    تحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة \n    بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأت منه.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب\n    تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد طرق التمرير المميزة التي تؤدي إلى عودة الكرة\n    إلى الطالب الذي بدأت منه بعد 'm' تمريرات.\n\n    حالات:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "sw": "Andika kazi ya python 'def count_passing_ways(n: int, m: int) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu ili kubaini idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliopo katika duara.\n    m: Idadi ya mara ambazo mpira unapita.\n\n    Inarejesha:\n    Nambari inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n    Matukio:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "tr": "Bir python fonksiyonu 'def count_passing_ways(n: int, m: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    'n' öğrencinin bir daire şeklinde dizildiği bir durumda, topun 'm' pas sonrasında\n    başlangıçtaki öğrenciye geri dönmesi için farklı yolların sayısını sayar.\n\n    Fonksiyon, pas dizilerinin sayısını belirlemek için dinamik programlama kullanır. Her öğrenci\n    topu ya sol komşusuna ya da sağ komşusuna paslayabilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez paslandığı.\n\n    Döndürür:\n    'm' pas sonrasında topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı pas yollarının sayısını temsil eden bir tamsayı.\n\n    Durumlar:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "vi": "Viết một hàm python 'def count_passing_ways(n: int, m: int) -> int:' để giải quyết vấn đề sau:\n\n    Đếm số cách khác nhau để chuyền bóng giữa 'n' học sinh sắp xếp thành vòng tròn \n    sao cho sau 'm' lần chuyền, bóng quay lại học sinh bắt đầu.\n\n    Hàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là bóng\n    quay lại học sinh bắt đầu sau 'm' lần chuyền.\n\n    Trường hợp:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6"
    },
    "instruction_bertscore": {
      "es": "0.9869152236493267",
      "arb": "0.9661043213675394",
      "sw": "0.9673960147354093",
      "tr": "0.9412620168722681",
      "vi": "0.9554716370707419"
    },
    "level": "easy",
    "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()",
    "entry_point": "count_passing_ways",
    "signature": "def count_passing_ways(n: int, m: int) -> int:",
    "docstring": {
      "en": "\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "es": "Cuenta el número de diferentes maneras de pasar una pelota entre 'n' estudiantes dispuestos en un círculo de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\nLa función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\nArgumentos:\nn: El número de estudiantes parados en un círculo.\nm: El número de veces que se pasa la pelota.\n\nDevuelve:\nUn entero que representa el número de formas distintas de pasar la pelota que resultan en que la pelota regrese al estudiante inicial después de 'm' pases.\n\nCases:\n>>> count_passing_ways(3, 3)\n2\n>>> count_passing_ways(5, 4)\n6",
      "arb": "    يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' من الطلاب المرتبين في دائرة \n    بحيث بعد 'm' من التمريرات، تعود الكرة إلى الطالب الذي بدأت منه.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب\n    تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد الطرق المختلفة للتمرير التي تؤدي إلى عودة الكرة\n    إلى الطالب الذي بدأت منه بعد 'm' من التمريرات.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "sw": "    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya 'm' kupitisha, mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu ili kubaini idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliopo katika duara.\n    m: Idadi ya mara ambazo mpira unapita.\n\n    Inarejesha:\n    Nambari inayoashiria idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya 'm' kupitisha.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "tr": "    Topun bir daire şeklinde dizilmiş 'n' öğrenci arasında kaç farklı şekilde geçirilebileceğini sayar,\n    öyle ki 'm' pas sonrasında top başlangıçtaki öğrenciye geri döner.\n\n    Fonksiyon, pas dizilerini belirlemek için dinamik programlama kullanır. Her öğrenci\n    topu ya sol komşusuna ya da sağ komşusuna geçirebilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez geçirildiği.\n\n    Döndürür:\n    Topun 'm' pas sonrasında başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı pas yollarının sayısını temsil eden bir tamsayı.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "vi": "    Đếm số cách khác nhau để chuyền bóng giữa 'n' học sinh sắp xếp thành vòng tròn \n    sao cho sau 'm' lần chuyền, bóng quay trở lại học sinh bắt đầu.\n\n    Hàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là bóng\n    quay trở lại học sinh bắt đầu sau 'm' lần chuyền.\n\n    Trường hợp:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9815436622550002",
      "arb": "0.9622439399121264",
      "sw": "0.9536110662915881",
      "tr": "0.9688656809246865",
      "vi": "0.9443834933102313"
    }
  },
  {
    "task_id": "Python/17",
    "prompt": {
      "en": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Elimina los enteros duplicados de la lista de entrada y devuelve los números únicos ordenados.\n\n    La función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado,\n    luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo\n    de números únicos y una lista de estos números únicos en orden ascendente.\n\n    Argumentos:\n    numbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\n    Devuelve:\n    Tuple[int, List[int]]: Una tupla con dos elementos:\n        - Un entero que representa el conteo de números únicos.\n        - Una lista de los números únicos ordenados en orden ascendente.\n\n    Ejemplos:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأرقام الفريدة المرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب المجموعة الناتجة من الأرقام الفريدة. تعيد الدالة زوج يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة بترتيب تصاعدي.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة بالأرقام الفريدة مرتبة بترتيب تصاعدي.\n\n    امثله:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Ondoa namba za kurudia kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya namba za ingizo kuwa seti ili kuondoa marudio yoyote,\n    kisha inapanga seti inayotokana ya namba za kipekee. Inarudisha jozi inayojumuisha idadi\n    ya namba za kipekee na orodha ya namba hizi za kipekee kwa mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na marudio.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Girdi listesinden yinelenen tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\n    Fonksiyon, önce girdi listesindeki sayıları bir kümeye dönüştürerek yinelenenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını ve\n    bu benzersiz sayıların artan sırayla listelendiği bir liste içeren bir demet döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Yinelenenler içerebilecek bir tamsayı listesi.\n\n    Dönüş:\n    Tuple[int, List[int]]: İki elemanlı bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\n    Hàm này đầu tiên chuyển đổi danh sách các số đầu vào thành một tập hợp để loại bỏ bất kỳ trùng lặp nào,\n    sau đó sắp xếp tập hợp các số duy nhất. Nó trả về một bộ giá trị chứa số lượng\n    các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\n    Tham số:\n    numbers (List[int]): Một danh sách các số nguyên, có thể chứa các phần tử trùng lặp.\n\n    Trả về:\n    Tuple[int, List[int]]: Một bộ giá trị với hai phần tử:\n        - Một số nguyên đại diện cho số lượng các số duy nhất.\n        - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\n    Ví dụ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.994688226350365",
      "arb": "0.9951754666750436",
      "sw": "0.989233637456766",
      "tr": "0.9629113379924036",
      "vi": "0.9788581795034086"
    },
    "canonical_solution": "# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers",
    "instruction": {
      "en": "Write a python function 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' to solve the following problem:\n\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    ",
      "es": "Escribe una función de Python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' para resolver el siguiente problema:\n\n    Eliminar números enteros duplicados de la lista de entrada y devolver los números únicos ordenados.\n\n    La función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado,\n    luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo\n    de números únicos y una lista de estos números únicos en orden ascendente.\n\n    Argumentos:\n    numbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\n    Devuelve:\n    Tuple[int, List[int]]: Una tupla con dos elementos:\n        - Un entero que representa el conteo de números únicos.\n        - Una lista de los números únicos ordenados en orden ascendente.\n\n    Ejemplos:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "arb": "اكتب دالة بايثون 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' لحل المشكلة التالية:\n\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأعداد الفريدة مرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب المجموعة الناتجة من الأرقام الفريدة. تُرجع الدالة زوج يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة مرتبة تصاعدياً.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة بالأرقام الفريدة مرتبة تصاعدياً.\n\n    أمثلة:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "sw": "Andika kazi ya python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' kutatua tatizo lifuatalo:\n\n    Ondoa namba za kurudia kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya ingizo ya namba kuwa seti ili kuondoa nakala zozote,\n    kisha inapanga seti inayotokana na namba za kipekee. Inarudisha jozi inayojumuisha hesabu\n    ya namba za kipekee na orodha ya namba hizi za kipekee katika mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na nakala.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha hesabu ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "tr": "Bir python fonksiyonu 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' yazın ve aşağıdaki problemi çözün:\n\n    Girdi listesinden tekrar eden tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\n    Fonksiyon, ilk olarak girdi listesindeki sayıları bir sete dönüştürerek tekrar edenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu seti sıralar. Fonksiyon, benzersiz sayıların sayısını ve\n    bu sayıların artan sırayla bulunduğu bir listeyi içeren bir demet döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Tekrar edebilen tamsayılar içeren bir liste.\n\n    Döndürür:\n    Tuple[int, List[int]]: İki elemanlı bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla bulunduğu bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "vi": "Viết một hàm python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' để giải quyết vấn đề sau:\n\n    Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\n    Hàm đầu tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ số trùng lặp nào,\n    sau đó sắp xếp tập hợp các số duy nhất kết quả. Nó trả về một bộ chứa số lượng\n    các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\n    Tham số:\n    numbers (List[int]): Một danh sách các số nguyên, có thể chứa các số trùng lặp.\n\n    Trả về:\n    Tuple[int, List[int]]: Một bộ với hai phần tử:\n        - Một số nguyên đại diện cho số lượng các số duy nhất.\n        - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\n    Ví dụ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])"
    },
    "instruction_bertscore": {
      "es": "0.9979443741866699",
      "arb": "0.9877687383966337",
      "sw": "0.9939076089528979",
      "tr": "0.9592889157334703",
      "vi": "0.9907243584664328"
    },
    "level": "easy",
    "test": "def test_process_random_numbers():\n    # Test case 1: Basic example with duplicates\n    assert process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15]) == (8, [15, 20, 32, 40, 67, 89, 300, 400]), \"Test case 1 failed\"\n\n    # Test case 2: All elements are the same\n    assert process_random_numbers([1, 1, 1, 1]) == (1, [1]), \"Test case 2 failed\"\n\n    # Test case 3: No duplicates\n    assert process_random_numbers([3, 1, 4, 2]) == (4, [1, 2, 3, 4]), \"Test case 3 failed\"\n\n    # Test case 4: Random numbers with single element\n    assert process_random_numbers([42]) == (1, [42]), \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert process_random_numbers([]) == (0, []), \"Test case 5 failed\"\n\n    # Test case 6: Random numbers with negatives and zero\n    assert process_random_numbers([0, -1, -2, -1, 0, 3]) == (4, [-2, -1, 0, 3]), \"Test case 6 failed\"\n\n    # Test case 7: Large range of numbers\n    assert process_random_numbers(list(range(1000, 0, -1))) == (1000, list(range(1, 1001))), \"Test case 7 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_process_random_numbers()",
    "entry_point": "process_random_numbers",
    "signature": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:",
    "docstring": {
      "en": "\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    ",
      "es": "Eliminar números enteros duplicados de la lista de entrada y devolver los números únicos ordenados.\n\nLa función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado, luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo de números únicos y una lista de estos números únicos en orden ascendente.\n\nArgumentos:\nnumbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\nDevuelve:\nTuple[int, List[int]]: Una tupla con dos elementos:\n    - Un entero que representa el conteo de números únicos.\n    - Una lista de los números únicos ordenados en orden ascendente.\n\nEjemplos:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "arb": "    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأرقام الفريدة مرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب مجموعة الأرقام الفريدة الناتجة. تُرجع الدالة زوجًا يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة مرتبة تصاعديًا.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة بالأرقام الفريدة مرتبة تصاعديًا.\n\n    امثله:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "sw": "    Ondoa namba rudufu kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya namba za ingizo kuwa seti ili kuondoa rudufu zozote,\n    kisha inapanga seti inayotokana ya namba za kipekee. Inarudisha jozi inayojumuisha idadi\n    ya namba za kipekee na orodha ya namba hizi za kipekee katika mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na rudufu.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "tr": "    Girdi listesinden yinelenen tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\n    Fonksiyon, önce sayılar listesini bir kümeye dönüştürerek yinelenenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını içeren bir demet\n    ve bu benzersiz sayıların artan sırayla listelendiği bir liste döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Yinelenenler içerebilecek bir tamsayı listesi.\n\n    Döndürür:\n    Tuple[int, List[int]]: İki öğeden oluşan bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "vi": "Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\nHàm này đầu tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ số trùng lặp nào, sau đó sắp xếp tập hợp các số duy nhất kết quả. Nó trả về một bộ chứa số lượng các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\nTham số:\nnumbers (List[int]): Một danh sách các số nguyên, có thể chứa các số trùng lặp.\n\nTrả về:\nTuple[int, List[int]]: Một bộ với hai phần tử:\n    - Một số nguyên đại diện cho số lượng các số duy nhất.\n    - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])"
    },
    "docstring_bertscore": {
      "es": "0.9982901896800517",
      "arb": "0.9885658421157266",
      "sw": "0.9885702119841094",
      "tr": "0.9642147505527545",
      "vi": "0.9942216435853141"
    }
  },
  {
    "task_id": "Python/18",
    "prompt": {
      "en": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n    \n    Esta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un \n    valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una \n    selección de artículos sin que el precio total exceda el presupuesto.\n    \n    Argumentos:\n    n (int): El presupuesto total disponible para la compra de artículos.\n    m (int): El número de diferentes artículos para elegir.\n    items (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n        - El primer entero representa el precio del artículo.\n        - El segundo entero representa el valor de importancia del artículo.\n    \n    Devuelve:\n    int: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n    \n    Ejemplos:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    يحسب أقصى قيمة إجمالية للأهمية للعناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. \n    الهدف هو تعظيم مجموع قيم الأهمية لمجموعة مختارة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): إجمالي الميزانية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة أهمية العنصر.\n    \n    يعيد:\n    int: أقصى قيمة إجمالية للأهمية يمكن تحقيقها دون تجاوز الميزانية.\n    \n    أمثلة:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Inahesabu thamani ya juu kabisa ya umuhimu wa jumla ya vitu ambavyo vinaweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua toleo la tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu inayohusishwa. \n    Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila jumla ya bei kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti ya jumla inayopatikana kwa ajili ya kununua vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili:\n        - Namba ya kwanza inawakilisha bei ya kipengee.\n        - Namba ya pili inawakilisha thamani ya umuhimu ya kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu wa jumla inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir öğenin bir fiyatı ve ona bağlı bir önem değeri olduğu 0-1 sırt çantası probleminin bir varyantını çözer. \n    Amaç, toplam fiyat bütçeyi aşmadan, bir öğe seçiminin önem değerlerinin toplamını maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilebilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her birinin iki tam sayı içerdiği bir demet listesi:\n        - İlk tam sayı, eşyanın fiyatını temsil eder.\n        - İkinci tam sayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán giá trị tầm quan trọng tối đa của các món hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán cái túi 0-1, trong đó mỗi món hàng có một giá và \n    một giá trị tầm quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị tầm quan trọng của một \n    tập hợp các món hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua các món hàng.\n    m (int): Số lượng món hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của món hàng.\n        - Số nguyên thứ hai đại diện cho giá trị tầm quan trọng của món hàng.\n    \n    Trả về:\n    int: Giá trị tầm quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9925072647666019",
      "arb": "0.9594082925924723",
      "sw": "0.9664191505214798",
      "tr": "0.978001089409243",
      "vi": "0.9655709987944607"
    },
    "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]",
    "instruction": {
      "en": "Write a python function 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    ",
      "es": "Escribe una función de Python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' para resolver el siguiente problema:\n\nCalcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n\nEsta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una selección de artículos sin que el precio total exceda el presupuesto.\n\nArgumentos:\nn (int): El presupuesto total disponible para la compra de artículos.\nm (int): El número de diferentes artículos para elegir.\nitems (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n- El primer entero representa el precio del artículo.\n- El segundo entero representa el valor de importancia del artículo.\n\nDevuelve:\nint: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n\nEjemplos:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80",
      "arb": "اكتب دالة بايثون 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    تحسب القيمة القصوى لأهمية العناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. الهدف هو تعظيم مجموع قيم الأهمية لمجموعة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): الميزانية الكلية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة أهمية العنصر.\n    \n    Returns:\n    int: القيمة القصوى الإجمالية للأهمية التي يمكن تحقيقها دون تجاوز الميزانية.\n    \n    أمثلة:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "sw": "Andika kazi ya python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu thamani ya juu kabisa ya umuhimu wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua toleo la tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya \n    umuhimu inayohusiana. Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila jumla ya bei \n    kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti jumla inayopatikana kwa ununuzi wa vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili:\n        - Namba ya kwanza inawakilisha bei ya kipengee.\n        - Namba ya pili inawakilisha thamani ya umuhimu wa kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "tr": "Bir python fonksiyonu 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir eşyanın bir fiyatı ve ilişkili bir önem değeri olduğu 0-1 sırt çantası probleminin bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan eşyaların önem değerlerinin toplamını maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her bir demetin iki tam sayı içerdiği demetlerin listesi:\n        - İlk tam sayı, eşyanın fiyatını temsil eder.\n        - İkinci tam sayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "vi": "Viết một hàm python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán tổng giá trị quan trọng tối đa của các mặt hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán cái túi 0-1, trong đó mỗi mặt hàng có một giá và một \n    giá trị quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị quan trọng của một \n    lựa chọn các mặt hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua hàng.\n    m (int): Số lượng các mặt hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của mặt hàng.\n        - Số nguyên thứ hai đại diện cho giá trị quan trọng của mặt hàng.\n    \n    Trả về:\n    int: Tổng giá trị quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80"
    },
    "instruction_bertscore": {
      "es": "0.9920369080243113",
      "arb": "0.9786992751985807",
      "sw": "0.956479884884875",
      "tr": "0.96606221172676",
      "vi": "0.9639144214166298"
    },
    "level": "easy",
    "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()",
    "entry_point": "max_happiness",
    "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    ",
      "es": "Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n\nEsta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una selección de artículos sin que el precio total exceda el presupuesto.\n\nArgumentos:\nn (int): El presupuesto total disponible para la compra de artículos.\nm (int): El número de diferentes artículos para elegir.\nitems (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n    - El primer entero representa el precio del artículo.\n    - El segundo entero representa el valor de importancia del artículo.\n\nDevuelve:\nint: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n\nEjemplos:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80",
      "arb": "    يحسب القيمة القصوى لإجمالي الأهمية للعناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. \n    الهدف هو تعظيم مجموع قيم الأهمية لمجموعة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): الميزانية الإجمالية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة الأهمية للعنصر.\n    \n    يعيد:\n    int: القيمة القصوى الإجمالية للأهمية التي يمكن تحقيقها دون تجاوز الميزانية.\n    \n    امثله:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "sw": "    Inakokotoa thamani ya juu kabisa ya umuhimu wa jumla wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua aina ya tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu inayohusiana. Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila bei ya jumla kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti ya jumla inayopatikana kwa ununuzi wa vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili:\n        - Namba ya kwanza inawakilisha bei ya kipengee.\n        - Namba ya pili inawakilisha thamani ya umuhimu wa kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu wa jumla inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "tr": "    Verilen bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir öğenin bir fiyatı ve ilişkili bir önem değeri olduğu 0-1 sırt çantası probleminin bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan, bir dizi öğenin önem değerlerinin toplamını maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her bir demetin iki tam sayı içerdiği demetlerin listesi:\n        - İlk tam sayı, eşyanın fiyatını temsil eder.\n        - İkinci tam sayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "vi": "    Tính toán giá trị tầm quan trọng tối đa của các món hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán ba lô 0-1, trong đó mỗi món hàng có một giá và một \n    giá trị tầm quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị tầm quan trọng của một \n    lựa chọn các món hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua các món hàng.\n    m (int): Số lượng các món hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của món hàng.\n        - Số nguyên thứ hai đại diện cho giá trị tầm quan trọng của món hàng.\n    \n    Trả về:\n    int: Giá trị tầm quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80"
    },
    "docstring_bertscore": {
      "es": "0.9947380825760048",
      "arb": "0.9726229732123424",
      "sw": "0.9431664849656306",
      "tr": "0.9810006067932509",
      "vi": "0.9618027818358479"
    }
  },
  {
    "task_id": "Python/19",
    "prompt": {
      "en": "\ndef max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "es": "def max_energy(beads):\n    \"\"\"\n    Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir\n    con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes\n    libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente,\n    y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los órdenes posibles de fusión de cuentas\n    y utiliza programación dinámica para calcular la máxima energía obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta coincide\n               con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener al fusionar todas las cuentas de manera óptima.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "arb": "```python\ndef max_energy(beads):\n    \"\"\"\n    حساب الحد الأقصى للطاقة التي يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في عقد، حيث\n    يحتوي كل خرزة على قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى،\n    والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    للعثور على الحد الأقصى لإطلاق الطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب الحد الأقصى للطاقة الممكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة\n               وقيمة الذيل للخرزة السابقة. يُفترض أن قيمة الذيل للخرزة الأخيرة تتطابق\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\n    يعيد:\n        عدد صحيح يمثل الحد الأقصى للطاقة التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    امثله:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"\n```",
      "sw": "def max_energy(beads):\n    \"\"\"\n    Kuhesabu nishati ya juu inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazoonyesha nishati ya shanga kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\n    ya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zilizo karibu\n    hutolewa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana,\n    na thamani ya mkia ya shanga ya pili.\n\n    Ili kupata nishati ya juu inayotolewa, kazi inazingatia mpangilio wote unaowezekana wa kuunganisha shanga\n    na hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia ya shanga iliyotangulia. Thamani ya mkia ya shanga ya mwisho inadhaniwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarudisha:\n        Nambari ya mzima inayowakilisha nishati ya juu inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "tr": "def max_energy(beads):\n    \"\"\"\n    Bir kolyedeki boncukları birleştirerek açığa çıkabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesi alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\n    boncuğun kuyruk değeriyle eşleşmelidir. Kolye daireseldir ve iki bitişik boncuğu birleştirmek,\n    ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin çarpımına eşit enerji açığa çıkarır.\n\n    Maksimum enerji açığa çıkışını bulmak için, fonksiyon boncukları birleştirmenin tüm olası sıralarını\n    dikkate alır ve dinamik programlama kullanarak elde edilebilecek maksimum enerjiyi hesaplar.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve önceki boncuğun kuyruk değerini temsil ettiği\n               bir tamsayı listesi. Kolyenin dairesel doğası nedeniyle, son boncuğun kuyruk değerinin\n               ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "vi": "def max_energy(beads):\n    \"\"\"\n    Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một vòng cổ.\n\n    Hàm nhận vào một danh sách các số nguyên đại diện cho năng lượng của các hạt trên một vòng cổ, \n    trong đó mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với \n    giá trị đuôi của hạt tiếp theo trong chuỗi. Vòng cổ là vòng tròn, và việc hợp nhất hai hạt liền kề \n    giải phóng năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và giá trị đuôi \n    của hạt thứ hai.\n\n    Để tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự có thể của việc hợp nhất các hạt \n    và sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên, trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt \n               và giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định là khớp \n               với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của vòng cổ.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\n    Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.985032406267497",
      "arb": "0.9690607359588627",
      "sw": "0.9649286281421939",
      "tr": "0.9700995728516751",
      "vi": "0.9697932848041194"
    },
    "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))",
    "instruction": {
      "en": "Write a python function 'def max_energy(beads):' to solve the following problem:\n\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    ",
      "es": "Escribe una función de Python 'def max_energy(beads):' para resolver el siguiente problema:\n\n    Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir con el valor de cola\n    de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes\n    libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente, y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los posibles órdenes de fusión de cuentas\n    y utiliza programación dinámica para calcular la energía máxima obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta coincide\n               con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener al fusionar óptimamente todas las cuentas.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "arb": "اكتب دالة بايثون 'def max_energy(beads):' لحل المشكلة التالية:\n\n    حساب الحد الأقصى للطاقة التي يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في عقد، حيث\n    كل خرزة لها قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى، والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    لإيجاد الحد الأقصى لإطلاق الطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب الحد الأقصى للطاقة الممكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\n               قيمة الذيل للخرزة السابقة. يُفترض أن قيمة الذيل للخرزة الأخيرة تتطابق\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\n    يعيد:\n        عدد صحيح يمثل الحد الأقصى للطاقة التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    أمثلة:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "sw": "Andika kazi ya python 'def max_energy(beads):' kutatua tatizo lifuatalo:\n\n    Hesabu nishati ya juu zaidi inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazowakilisha shanga za nishati kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\n    ya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zinazofuatana\n    hutoa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana, na thamani ya mkia ya shanga ya pili.\n\n    Ili kupata utoaji wa nishati ya juu zaidi, kazi inazingatia mpangilio wote unaowezekana wa kuunganisha shanga\n    na hutumia programu ya nguvu ili kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia ya shanga iliyopita. Thamani ya mkia ya shanga ya mwisho inadhaniwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarejesha:\n        Nambari ya mzima inayowakilisha nishati ya juu zaidi inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "tr": "Bir python fonksiyonu 'def max_energy(beads):' yazarak aşağıdaki problemi çözün:\n\n    Bir kolyedeki boncukları birleştirerek açığa çıkabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesini alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki boncuğun\n    kuyruk değeri ile eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğu birleştirmek,\n    ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin çarpımına eşit enerji açığa çıkarır.\n\n    Maksimum enerji açığa çıkışını bulmak için, fonksiyon boncukları birleştirmenin tüm olası sıralarını dikkate alır\n    ve elde edilebilecek maksimum enerjiyi hesaplamak için dinamik programlama kullanır.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve\n               önceki boncuğun kuyruk değerini temsil ettiği bir tamsayı listesi. Kolyenin dairesel doğası\n               nedeniyle son boncuğun kuyruk değerinin ilk boncuğun baş değeri ile eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "vi": "Viết một hàm python 'def max_energy(beads):' để giải quyết vấn đề sau:\n\n    Tính toán năng lượng tối đa có thể được phát ra bằng cách hợp nhất các hạt trên một chuỗi hạt.\n\n    Hàm nhận một danh sách các số nguyên đại diện cho năng lượng của các hạt trên một chuỗi hạt, trong đó\n    mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với giá trị đuôi\n    của hạt tiếp theo trong chuỗi. Chuỗi hạt là vòng tròn, và việc hợp nhất hai hạt liền kề\n    phát ra năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp,\n    và giá trị đuôi của hạt thứ hai.\n\n    Để tìm năng lượng phát ra tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể\n    và sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt và\n               giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định\n               là khớp với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của chuỗi hạt.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\n    Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48"
    },
    "instruction_bertscore": {
      "es": "0.9864526134918965",
      "arb": "0.9829344721830066",
      "sw": "0.9664483491874919",
      "tr": "0.967359864006061",
      "vi": "0.9512507414737505"
    },
    "level": "middle",
    "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()",
    "entry_point": "max_energy",
    "signature": "def max_energy(beads):",
    "docstring": {
      "en": "\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    ",
      "es": "    Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente, y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los posibles órdenes de fusión de cuentas\n    y utiliza programación dinámica para calcular la energía máxima obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta coincide\n               con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener al fusionar óptimamente todas las cuentas.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "arb": "    حساب أقصى طاقة يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في عقد، حيث\n    كل خرزة لها قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي\n    حاصل ضرب قيمة الرأس للخرزة الأولى، والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    للعثور على أقصى إطلاق للطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب أقصى طاقة يمكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\n               قيمة الذيل للخرزة السابقة. يُفترض أن تتطابق قيمة الذيل للخرزة الأخيرة\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\n    يعيد:\n        عدد صحيح يمثل أقصى طاقة يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    امثله:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "sw": "    Kuhesabu nishati ya juu kabisa inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazoashiria shanga za nishati kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani\n    ya mkia ya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili\n    zinazofuatana hutoa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana,\n    na thamani ya mkia ya shanga ya pili.\n\n    Ili kupata nishati ya juu kabisa inayotolewa, kazi inazingatia mpangilio wote wa uwezekano wa kuunganisha shanga\n    na hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia ya shanga iliyotangulia. Thamani ya mkia ya shanga ya mwisho inachukuliwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarudisha:\n        Nambari ya mzima inayowakilisha nishati ya juu kabisa inayoweza kupatikana kwa kuunganisha shanga zote kwa ufanisi.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "tr": "    Boncukları bir kolyede birleştirerek serbest bırakılabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesini alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\n    boncuğun kuyruk değeriyle eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğun\n    birleştirilmesi, ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin\n    çarpımına eşit enerji serbest bırakır.\n\n    Maksimum enerji serbest bırakılmasını bulmak için, fonksiyon boncukları birleştirmenin tüm\n    olası sıralarını dikkate alır ve elde edilebilecek maksimum enerjiyi hesaplamak için dinamik\n    programlama kullanır.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve önceki boncuğun kuyruk değerini temsil\n               ettiği bir tamsayı listesi. Kolyenin dairesel yapısı nedeniyle son boncuğun kuyruk\n               değerinin ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil\n        eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "vi": "    Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một chuỗi hạt.\n\n    Hàm này nhận một danh sách các số nguyên đại diện cho các hạt năng lượng trên một chuỗi hạt, trong đó\n    mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với giá trị đuôi\n    của hạt tiếp theo trong chuỗi. Chuỗi hạt là vòng tròn, và việc hợp nhất hai hạt liền kề giải phóng\n    năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và giá trị đuôi của hạt thứ hai.\n\n    Để tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể có\n    và sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt và\n               giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định\n               khớp với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của chuỗi hạt.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\n   Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48"
    },
    "docstring_bertscore": {
      "es": "0.9868737098996905",
      "arb": "0.9786315422386478",
      "sw": "0.9529315517580678",
      "tr": "0.9612376784018036",
      "vi": "0.953064038222218"
    }
  },
  {
    "task_id": "Python/20",
    "prompt": {
      "en": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "es": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^degree` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "arb": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    يحول قائمة من معاملات متعددة الحدود إلى تمثيل سلسلة منسق.\n\n    تأخذ الدالة أعلى درجة `n` لمتعددة الحدود وقائمة من المعاملات `coeffs`،\n    التي يتم ترتيبها من الحد ذو الدرجة الأعلى إلى الحد الثابت. تعيد سلسلة تمثل\n    متعددة الحدود بالقواعد التالية:\n    - يتم حذف الحدود ذات المعامل الصفري.\n    - يتم تحديد إشارة كل حد (+ للإيجابي، - للسالب)، بدون '+' في البداية للحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يتضمن المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): أعلى درجة لمتعددة الحدود.\n        coeffs (List[int]): قائمة من المعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: تمثيل السلسلة لمتعددة الحدود.\n\n    أمثلة:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "sw": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Hubadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangiliwa.\n\n    Kazi inachukua kiwango cha juu zaidi `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kutoka kwa kiwango cha juu zaidi hadi kwa neno la mara kwa mara. Inarudisha kamba ambayo\n    inawakilisha polinomu kwa sheria zifuatazo:\n    - Maneno yenye kigezo cha sifuri hayajumuishwi.\n    - Alama ya kila neno imedhamiriwa (+ kwa chanya, - kwa hasi), bila '+' inayoongoza kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\n      hakuna kitu kwa kiwango 0 (neno la mara kwa mara).\n    - Maneno yanaunganishwa bila nafasi za ziada, yakianza na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu zaidi cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "tr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Bir polinom katsayıları listesini biçimlendirilmiş bir string gösterimine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış\n    bir katsayılar listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim değişken `x` içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^derece`, derece 1 için `x` ve\n      derece 0 için (sabit terim) hiçbir şey.\n    - Terimler ek boşluklar olmadan birleştirilir, en yüksek dereceli terimle başlar.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayılar listesi.\n\n    Döndürür:\n        str: Polinomun string gösterimi.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "vi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Chuyển đổi một danh sách các hệ số đa thức thành một chuỗi định dạng.\n\n    Hàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`,\n    được sắp xếp từ bậc cao nhất đến hằng số. Nó trả về một chuỗi đại diện cho đa thức với các quy tắc sau:\n    - Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n    - Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' đầu tiên cho hạng tử đầu tiên.\n    - Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n    - Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và\n      không có gì cho bậc 0 (hằng số).\n    - Các hạng tử được nối với nhau mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\n    Tham số:\n        n (int): Bậc cao nhất của đa thức.\n        coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\n    Trả về:\n        str: Chuỗi đại diện cho đa thức.\n\n    Ví dụ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9922144835849566",
      "arb": "0.9830435202621947",
      "sw": "0.9867130179214332",
      "tr": "0.9564206930313266",
      "vi": "0.9592084704291512"
    },
    "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)",
    "instruction": {
      "en": "Write a python function 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' to solve the following problem:\n\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    ",
      "es": "Escribe una función de Python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' para resolver el siguiente problema:\n\n    Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^grado` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "arb": "اكتب دالة بايثون 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' لحل المشكلة التالية:\n\n    تحويل قائمة من معاملات الحدوديات إلى تمثيل نصي منسق.\n\n    تأخذ الدالة الدرجة الأعلى `n` للحدودية وقائمة من المعاملات `coeffs`،\n    التي تكون مرتبة من الحد ذو الدرجة الأعلى إلى الحد الثابت. تُرجع سلسلة تمثل الحدودية بالقواعد التالية:\n    - يتم حذف الحدود ذات المعامل الصفري.\n    - يتم تحديد إشارة كل حد (+ للإيجابي، - للسلبي)، بدون '+' في البداية للحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يتضمن المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): الدرجة الأعلى للحدودية.\n        coeffs (List[int]): قائمة بالمعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: التمثيل النصي للحدودية.\n\n    أمثلة:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "sw": "Andika kazi ya Python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' kutatua tatizo lifuatalo:\n\n    Inabadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangwa.\n\n    Kazi inachukua kiwango cha juu zaidi `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kutoka kwa kiwango cha juu zaidi hadi kwa neno la kawaida. Inarudisha kamba ambayo\n    inawakilisha polinomu na sheria zifuatazo:\n    - Maneno yenye kigezo cha sifuri hayajumuishwi.\n    - Alama ya kila neno inaamuliwa (+ kwa chanya, - kwa hasi), bila '+' ya mwanzo kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\n      hakuna kitu kwa kiwango 0 (neno la kawaida).\n    - Maneno yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu zaidi cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "tr": "Bir python fonksiyonu 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    Bir polinom katsayıları listesini biçimlendirilmiş bir string temsilcisine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış\n    bir katsayı listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^derece`, derece 1 için `x` ve\n      derece 0 (sabit terim) için hiçbir şey.\n    - Terimler, en yüksek dereceli terimle başlayarak ek boşluk olmadan birleştirilir.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayı listesi.\n\n    Döndürür:\n        str: Polinomun string temsili.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "vi": "Viết một hàm python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' để giải quyết vấn đề sau:\n\n    Chuyển đổi một danh sách các hệ số đa thức thành một biểu diễn chuỗi được định dạng.\n\n    Hàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`,\n    được sắp xếp từ hạng tử có bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi\n    đại diện cho đa thức với các quy tắc sau:\n    - Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n    - Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' đứng đầu cho hạng tử đầu tiên.\n    - Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n    - Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và\n      không có gì cho bậc 0 (hạng tử hằng số).\n    - Các hạng tử được nối mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\n    Tham số:\n        n (int): Bậc cao nhất của đa thức.\n        coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\n    Trả về:\n        str: Biểu diễn chuỗi của đa thức.\n\n    Ví dụ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'"
    },
    "instruction_bertscore": {
      "es": "0.9866985179036176",
      "arb": "0.9804498047466411",
      "sw": "0.9850341939409264",
      "tr": "0.9658903964471649",
      "vi": "0.974049536608935"
    },
    "level": "hard",
    "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()",
    "entry_point": "polynomial_to_string",
    "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:",
    "docstring": {
      "en": "\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    ",
      "es": "    Convierte una lista de coeficientes polinomiales en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^grado` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "arb": "    يحول قائمة من معاملات كثيرات الحدود إلى تمثيل سلسلة نصية منسقة.\n\n    تأخذ الدالة أعلى درجة `n` لكثيرة الحدود وقائمة من المعاملات `coeffs`،\n    والتي تُرتب من الحد ذو الدرجة الأعلى إلى الحد الثابت. تُرجع سلسلة نصية\n    تمثل كثيرة الحدود بالقواعد التالية:\n    - يتم حذف الحدود التي معاملها صفر.\n    - يتم تحديد إشارة كل حد (+ للموجب، - للسالب)، بدون '+' في بداية الحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يحتوي على المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1،\n      ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): أعلى درجة لكثيرة الحدود.\n        coeffs (List[int]): قائمة بالمعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: التمثيل النصي لكثيرة الحدود.\n\n    امثله:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "sw": "    Hubadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangiliwa.\n\n    Kazi hii inachukua kiwango cha juu zaidi `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kuanzia kiwango cha juu zaidi hadi kiwango cha kawaida. Inarudisha kamba\n    inayowakilisha polinomu kwa sheria zifuatazo:\n    - Masharti yenye kigezo cha sifuri hayajumuishwi.\n    - Ishara ya kila neno inatambuliwa (+ kwa chanya, - kwa hasi), bila '+' ya kwanza kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\n      hakuna kitu kwa kiwango 0 (neno la kawaida).\n    - Masharti yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu zaidi cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, ikianza na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "tr": "    Bir polinom katsayıları listesini biçimlendirilmiş bir string gösterimine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceden sabit terime kadar sıralanan\n    `coeffs` katsayılar listesini alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, eğer 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^derece`, derece 1 için `x` ve\n      derece 0 (sabit terim) için hiçbir şey.\n    - Terimler, en yüksek dereceli terimle başlayarak ek boşluklar olmadan birleştirilir.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayılar listesi.\n\n    Döndürür:\n        str: Polinomun string gösterimi.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "vi": "Chuyển đổi một danh sách các hệ số đa thức thành một biểu diễn chuỗi có định dạng.\n\nHàm này nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`, được sắp xếp từ hạng tử có bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi đại diện cho đa thức với các quy tắc sau:\n- Các hạng tử có hệ số bằng không sẽ bị loại bỏ.\n- Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' đứng đầu cho hạng tử đầu tiên.\n- Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n- Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và không có gì cho bậc 0 (hạng tử hằng số).\n- Các hạng tử được nối liền mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\nTham số:\n    n (int): Bậc cao nhất của đa thức.\n    coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\nTrả về:\n    str: Chuỗi biểu diễn của đa thức.\n\nVí dụ:\n    >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n    '100x^5-x^4+x^3-3x^2+10'\n\n    >>> polynomial_to_string(3, [-50, 0, 0, 1])\n    '-50x^3+1'"
    },
    "docstring_bertscore": {
      "es": "0.9912362289583597",
      "arb": "0.9821065807548531",
      "sw": "0.9735573305247305",
      "tr": "0.961404726552254",
      "vi": "0.9775446367936249"
    }
  },
  {
    "task_id": "Python/21",
    "prompt": {
      "en": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n    \n    La función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n    luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n    del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n    calificados para la entrevista.\n    \n    Argumentos:\n    - n (int): El número total de solicitantes.\n    - m (int): El número planeado de voluntarios a reclutar.\n    - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n    \n    Devuelve:\n    - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n      el número de registro y el puntaje de prueba de los solicitantes calificados.\n    \n    Ejemplos:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    يختار ويحدد درجة المقابلة الفاصلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان لدى عدة متقدمين نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم تسجيلهم بترتيب تصاعدي. يتم حساب درجة المقابلة الفاصلة بناءً على 150%\n    من العدد المخطط لتجنيد المتطوعين، مع التقريب للأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو تزيد عن الفاصلة يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط لتجنيد المتطوعين.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة اختبار المتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على درجة المقابلة الفاصلة وقائمة من الأزواج، كل منها يشمل\n      رقم التسجيل ودرجة اختبار المتقدمين المؤهلين.\n    \n    أمثلة:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Huchagua na kuamua alama ya mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    basi hupangwa kulingana na namba zao za usajili kwa mpangilio wa kupanda. Alama ya mahojiano inahesabiwa kwa msingi wa 150%\n    ya idadi iliyopangwa ya wanaojitolea, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya alama hiyo wanachukuliwa\n    kuwa wanastahili kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya wanaojitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina namba ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayoelezea alama ya mahojiano na orodha ya jozi, ambapo kila moja inajumuisha\n      namba ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Mülakat puanı barajını ve mülakat sürecine hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n    \n    Fonksiyon, başvuru sahiplerini test puanlarına göre azalan sırayla sıralar. Birden fazla başvuru sahibi aynı puana sahipse,\n    kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si\n    baz alınarak hesaplanır ve aşağı yuvarlanır. Puanları baraj puanına eşit veya daha yüksek olan tüm başvuru sahipleri\n    mülakat için nitelikli kabul edilir.\n    \n    Argümanlar:\n    - n (int): Toplam başvuru sahibi sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarasını ve test puanını içerdiği demetlerin listesi.\n    \n    Döndürür:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her biri nitelikli başvuru sahiplerinin kayıt numarası ve test puanını içeren\n      demetlerin listesini içeren bir demet.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Lựa chọn và xác định điểm phỏng vấn cắt và danh sách ứng viên đủ điều kiện cho quá trình phỏng vấn.\n    \n    Hàm sắp xếp các ứng viên dựa trên điểm thi của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\n    họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn cắt được tính dựa trên 150%\n    số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn điểm cắt được coi là\n    đủ điều kiện cho phỏng vấn.\n    \n    Tham số:\n    - n (int): Tổng số ứng viên.\n    - m (int): Số lượng tình nguyện viên dự kiến được tuyển dụng.\n    - applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm thi của một ứng viên.\n    \n    Trả về:\n    - Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn cắt và danh sách các bộ giá trị, mỗi bộ bao gồm\n      số đăng ký và điểm thi của các ứng viên đủ điều kiện.\n    \n    Ví dụ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9788520219615965",
      "arb": "0.9729447544296189",
      "sw": "0.958017085403704",
      "tr": "0.9661069035624928",
      "vi": "0.9598711013802836"
    },
    "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants",
    "instruction": {
      "en": "Write a python function 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' to solve the following problem:\n\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ",
      "es": "Escribe una función en Python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' para resolver el siguiente problema:\n\n   Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n   \n   La función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n   luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n   del número planificado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n   calificados para la entrevista.\n   \n   Argumentos:\n   - n (int): El número total de solicitantes.\n   - m (int): El número planificado de voluntarios a reclutar.\n   - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n   \n   Devuelve:\n   - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n     el número de registro y el puntaje de prueba de los solicitantes calificados.\n   \n   Ejemplos:\n   >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n   (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "arb": "اكتب دالة بايثون 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' لحل المشكلة التالية:\n\n    يختار ويحدد درجة المقابلة الفاصلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان لدى عدة متقدمين نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم تسجيلهم بترتيب تصاعدي. يتم حساب درجة المقابلة الفاصلة بناءً على 150%\n    من العدد المخطط لتجنيد المتطوعين، ويتم تقريبها إلى الأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو تزيد عن الدرجة الفاصلة يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط لتجنيد المتطوعين.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة الاختبار للمتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على درجة المقابلة الفاصلة وقائمة من الأزواج، يحتوي كل منها على\n      رقم التسجيل ودرجة الاختبار للمتقدمين المؤهلين.\n    \n    أمثلة:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "sw": "Andika kazi ya python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' kutatua tatizo lifuatalo:\n\n    Huchagua na kuamua alama ya mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    wanapangwa kisha kwa nambari zao za usajili kwa mpangilio wa kupanda. Alama ya mahojiano inahesabiwa kwa msingi wa 150%\n    ya idadi iliyopangwa ya walioajiriwa, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya alama hiyo wanachukuliwa\n    kuwa wanastahili kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya wajitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina nambari ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha alama ya mahojiano na orodha ya jozi, kila moja ikiwa na\n      nambari ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "tr": "Bir python fonksiyonu 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' yazın ve aşağıdaki problemi çözün:\n\n    Mülakat süreci için mülakat puanı barajını ve başvuranların listesini seçer ve belirler.\n    \n    Fonksiyon, başvuranları test puanlarına göre azalan sırayla sıralar. Birden fazla başvuran aynı puana sahipse,\n    kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının\n    %150'si üzerinden hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puan alan tüm başvuranlar\n    mülakat için nitelikli kabul edilir.\n    \n    Argümanlar:\n    - n (int): Toplam başvuran sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir tuple'ın bir başvuranın kayıt numarası ve test puanını içerdiği tuple'lardan oluşan bir liste.\n    \n    Döndürülenler:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her birinin kayıt numarası ve test puanını içeren nitelikli başvuranların\n      tuple'larından oluşan bir liste içeren bir tuple.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "vi": "Viết một hàm python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' để giải quyết vấn đề sau:\n\n    Chọn và xác định điểm phỏng vấn tối thiểu và danh sách ứng viên đủ điều kiện cho quá trình phỏng vấn.\n    \n    Hàm sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\n    họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn tối thiểu được tính dựa trên 150%\n    số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm bằng hoặc cao hơn điểm tối thiểu được coi là\n    đủ điều kiện cho phỏng vấn.\n    \n    Tham số:\n    - n (int): Tổng số ứng viên.\n    - m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n    - applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n    \n    Trả về:\n    - Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn tối thiểu và một danh sách các bộ giá trị, mỗi bộ bao gồm\n      số đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n    \n    Ví dụ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])"
    },
    "instruction_bertscore": {
      "es": "0.9788975083188535",
      "arb": "0.9833090890816384",
      "sw": "0.9618933572895998",
      "tr": "0.9564753163861112",
      "vi": "0.9532265178739046"
    },
    "level": "middle",
    "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()",
    "entry_point": "select_volunteers",
    "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:",
    "docstring": {
      "en": "\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ",
      "es": "    Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n    \n    La función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n    luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n    del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n    calificados para la entrevista.\n    \n    Argumentos:\n    - n (int): El número total de solicitantes.\n    - m (int): El número planeado de voluntarios a reclutar.\n    - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n    \n    Devuelve:\n    - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n      el número de registro y el puntaje de prueba de los solicitantes calificados.\n    \n    Ejemplos:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "arb": "    يختار ويحدد الحد الأدنى لدرجة المقابلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان لدى عدة متقدمين نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم التسجيل بترتيب تصاعدي. يتم حساب الحد الأدنى لدرجة المقابلة بناءً على 150%\n    من العدد المخطط للمتطوعين، مع التقريب إلى الأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو تزيد عن الحد الأدنى يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط للمتطوعين الذين سيتم تجنيدهم.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة اختبار المتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على الحد الأدنى لدرجة المقابلة وقائمة من الأزواج، كل منها يتضمن\n      رقم التسجيل ودرجة اختبار المتقدمين المؤهلين.\n    \n    امثله:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "sw": "    Huchagua na kuamua alama ya kukatwa kwa mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    basi hupangwa kulingana na nambari zao za usajili kwa mpangilio wa kupanda. Alama ya kukatwa kwa mahojiano huhesabiwa kwa msingi wa 150%\n    ya idadi iliyopangwa ya wanaojitolea, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya alama ya kukatwa wanachukuliwa\n    kuwa wamehitimu kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya wanaojitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina nambari ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha alama ya kukatwa kwa mahojiano na orodha ya jozi, kila moja ikiwa na\n      nambari ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "tr": "    Mülakat puanı barajını ve mülakat sürecine katılmaya hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n    \n    Fonksiyon, başvuru sahiplerini test puanlarına göre azalan sırada sıralar. Birden fazla başvuru sahibi aynı puana sahipse,\n    bunlar kayıt numaralarına göre artan sırada sıralanır. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si\n    üzerinden hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puana sahip tüm başvuru sahipleri mülakata hak kazanmış sayılır.\n    \n    Argümanlar:\n    - n (int): Toplam başvuru sahibi sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarası ve test puanını içerdiği demetlerin listesi.\n    \n    Döndürür:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her biri kayıt numarası ve hak kazanan başvuru sahiplerinin test puanını içeren\n      demetlerin listesini içeren bir demet.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "vi": "Chọn và xác định điểm phỏng vấn tối thiểu và danh sách các ứng viên đủ điều kiện cho quá trình phỏng vấn.\n\nHàm sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số, họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn tối thiểu được tính dựa trên 150% số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn điểm tối thiểu được coi là đủ điều kiện cho phỏng vấn.\n\nTham số:\n- n (int): Tổng số ứng viên.\n- m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n- applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n\nTrả về:\n- Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn tối thiểu và danh sách các bộ giá trị, mỗi bộ bao gồm số đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n\nVí dụ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])"
    },
    "docstring_bertscore": {
      "es": "0.9724116304869213",
      "arb": "0.9487221767231764",
      "sw": "0.9416914557560655",
      "tr": "0.9644266891693187",
      "vi": "0.9437125198830955"
    }
  },
  {
    "task_id": "Python/22",
    "prompt": {
      "en": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "es": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo,\n    o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a ser decodificado.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "arb": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    يفك تشفير رسالة مشفرة باستخدام شفرة مستمدة من زوج معروف مشفر-أصلي.\n    \n    تقوم الدالة ببناء خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه\n    الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم تكن جميع الحروف ممثلة في الخريطة، فإن الدالة تعيد \"فشل\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي يجب فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"فشل\" إذا لم يكن فك التشفير ممكنًا.\n    \n    أمثلة:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "sw": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Hufungua ujumbe uliofichwa kwa kutumia cipher inayotokana na jozi inayojulikana ya encoded-original.\n    \n    Kazi hii inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za awali na kutumia ramani hii\n    kufungua ujumbe uliofichwa uliotolewa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani,\n    au ikiwa si herufi zote zinawakilishwa katika ramani, kazi inarudi \"Failed\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyofichwa.\n    original (str): Kamba inayowakilisha taarifa ya awali inayolingana na kamba iliyofichwa.\n    message (str): Kamba inayowakilisha ujumbe uliofichwa unaopaswa kufunguliwa.\n    \n    Inarejesha:\n    str: Ujumbe uliofunguliwa ikiwa umefanikiwa, au \"Failed\" ikiwa ufunguzi hauwezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "tr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Bilinen bir şifrelenmiş-orijinal çiftinden türetilen bir şifre kullanarak şifreli bir mesajı çözer.\n    \n    Fonksiyon, şifrelenmiş harflerden orijinal harflere bir eşleme oluşturur ve bu eşlemeyi\n    verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa\n    veya tüm harfler eşlemede temsil edilmezse, fonksiyon \"Başarısız\" döner.\n    \n    Argümanlar:\n    encoded (str): Şifrelenmiş bilgiyi temsil eden bir dize.\n    original (str): Şifrelenmiş dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\n    message (str): Çözülecek şifreli mesajı temsil eden bir dize.\n    \n    Döndürür:\n    str: Başarılıysa çözülen mesaj, aksi takdirde \"Başarısız\" döner.\n    \n    Örnekler:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "vi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Giải mã một thông điệp được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp đã mã hóa-gốc đã biết.\n    \n    Hàm này xây dựng một ánh xạ từ các chữ cái đã mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này\n    để giải mã một thông điệp đã được mã hóa. Nếu phát hiện mâu thuẫn trong quá trình xây dựng ánh xạ,\n    hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp đã được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã được giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9896741996419013",
      "arb": "0.9823773139642037",
      "sw": "0.9630235641576883",
      "tr": "0.96316399583708",
      "vi": "0.9640701476353611"
    },
    "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message",
    "instruction": {
      "en": "Write a python function 'def decode(encoded: str, original: str, message: str) -> str:' to solve the following problem:\n\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    ",
      "es": "Escribe una función de Python 'def decode(encoded: str, original: str, message: str) -> str:' para resolver el siguiente problema:\n\n    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a ser decodificado.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "arb": "اكتب دالة بايثون 'def decode(encoded: str, original: str, message: str) -> str:' لحل المشكلة التالية:\n\n    تقوم بفك تشفير رسالة مشفرة باستخدام شفرة مشتقة من زوج معروف من المشفر-الأصلي.\n    \n    تقوم الدالة ببناء خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه\n    الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم تكن جميع الحروف ممثلة في الخريطة، فإن الدالة تُرجع \"فشل\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي سيتم فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"فشل\" إذا لم يكن فك التشفير ممكنًا.\n    \n    أمثلة:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "sw": "Andika kazi ya python 'def decode(encoded: str, original: str, message: str) -> str:' kutatua tatizo lifuatalo:\n\n    Inafungua ujumbe uliofichwa kwa kutumia cipher inayotokana na jozi inayojulikana ya encoded-original.\n    \n    Kazi inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za asili na kutumia\n    ramani hii kufungua ujumbe uliosimbwa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani,\n    au si herufi zote zinawakilishwa katika ramani, kazi inarudisha \"Failed\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyosimbwa.\n    original (str): Kamba inayowakilisha taarifa ya asili inayolingana na kamba iliyosimbwa.\n    message (str): Kamba inayowakilisha ujumbe uliosimbwa ambao unahitaji kufunguliwa.\n    \n    Inarejesha:\n    str: Ujumbe uliotafsiriwa ikiwa umefanikiwa, au \"Failed\" ikiwa kutafsiri hakuezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "tr": "Bir python fonksiyonu 'def decode(encoded: str, original: str, message: str) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    Bilinen bir kodlanmış-orijinal çiftinden türetilmiş bir şifre kullanarak şifreli bir mesajı çözer.\n    \n    Fonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu\n    eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa veya\n    eşlemede tüm harfler temsil edilmezse, fonksiyon \"Failed\" döndürür.\n    \n    Argümanlar:\n    encoded (str): Kodlanmış bilgiyi temsil eden bir dize.\n    original (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\n    message (str): Çözülecek şifreli mesajı temsil eden bir dize.\n    \n    Döndürür:\n    str: Başarılı olursa çözülen mesaj veya çözme mümkün değilse \"Failed\".\n    \n    Örnekler:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "vi": "Viết một hàm python 'def decode(encoded: str, original: str, message: str) -> str:' để giải quyết vấn đề sau:\n\n    Giải mã một thông điệp được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp đã mã hóa-gốc đã biết.\n    \n    Hàm xây dựng một ánh xạ từ các chữ cái đã mã hóa sang các chữ cái gốc của chúng và sử dụng ánh xạ này\n    để giải mã một thông điệp được mã hóa. Nếu tìm thấy một mâu thuẫn trong quá trình xây dựng ánh xạ,\n    hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'"
    },
    "instruction_bertscore": {
      "es": "0.9890834728887036",
      "arb": "0.9871917171397273",
      "sw": "0.9658600059988666",
      "tr": "0.9803330100825927",
      "vi": "0.9857754825229486"
    },
    "level": "hard",
    "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()",
    "entry_point": "decode",
    "signature": "def decode(encoded: str, original: str, message: str) -> str:",
    "docstring": {
      "en": "\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    ",
      "es": "    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido de codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a decodificar.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "arb": "    يفك تشفير رسالة مشفرة باستخدام شفرة مستمدة من زوج معروف من المشفر-الأصلي.\n    \n    تقوم الدالة ببناء خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه\n    الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم يتم تمثيل جميع الحروف في الخريطة، فإن الدالة تعيد \"فشل\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي سيتم فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"فشل\" إذا كان فك التشفير غير ممكن.\n    \n    امثله:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "sw": "    Inafasiri ujumbe uliofichwa kwa kutumia cipher inayotokana na jozi inayojulikana ya iliyosimbwa-asili.\n    \n    Kazi hii inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za asili na kutumia ramani hii\n    kufasiri ujumbe uliosimbwa. Ikiwa kuna mkanganyiko unaopatikana wakati wa ujenzi wa ramani,\n    au ikiwa si herufi zote zinawakilishwa kwenye ramani, kazi hii inarudisha \"Imeshindwa\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyosimbwa.\n    original (str): Kamba inayowakilisha taarifa ya asili inayolingana na kamba iliyosimbwa.\n    message (str): Kamba inayowakilisha ujumbe uliofichwa unaotakiwa kufasiriwa.\n    \n    Inarejesha:\n    str: Ujumbe uliofasiriwa ikiwa umefanikiwa, au \"Imeshindwa\" ikiwa kufasiri haiwezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "tr": "Şifreli bir mesajı, bilinen bir kodlanmış-orijinal çiftinden türetilen bir şifre kullanarak çözer.\n\nFonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa veya tüm harfler eşlemeye dahil edilmezse, fonksiyon \"Başarısız\" döndürür.\n\nArgümanlar:\nencoded (str): Kodlanmış bilgiyi temsil eden bir dize.\noriginal (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\nmessage (str): Çözülecek şifreli mesajı temsil eden bir dize.\n\nDöndürür:\nstr: Başarılı olursa çözülen mesaj veya çözme mümkün değilse \"Başarısız\".\n\nÖrnekler:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'    \n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "vi": "    Giải mã một thông điệp đã được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp mã hóa-gốc đã biết.\n    \n    Hàm này xây dựng một ánh xạ từ các chữ cái đã mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này để giải mã một thông điệp đã được mã hóa. Nếu một mâu thuẫn được tìm thấy trong quá trình xây dựng ánh xạ, hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp đã được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'"
    },
    "docstring_bertscore": {
      "es": "0.9903255086613147",
      "arb": "0.9728448433479584",
      "sw": "0.9724914799000973",
      "tr": "0.9774055955269004",
      "vi": "0.958866031652247"
    }
  },
  {
    "task_id": "Python/23",
    "prompt": {
      "en": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "es": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Encuentra el mayor factor primo de un número entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos. \n    La función itera a través de posibles factores comenzando desde el menor primo (2) \n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve \n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran \n    factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo y \n    se devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El número entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "arb": "```python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو حاصل ضرب عددين أوليين مميزين بالضبط.\n    تقوم الدالة بالتحقق من العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تقوم الدالة بإرجاع\n    قسمة 'n' على هذا العامل، والذي هو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\n    حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم\n    إرجاعه كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب الذي سيتم تحليله، وهو حاصل ضرب عددين أوليين مميزين.\n    \n    يعيد:\n    int: الأكبر من بين العاملين الأوليين لـ 'n'.\n    \n    امثله:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n```",
      "sw": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Pata kigezo kikubwa zaidi cha namba ya kwanza ya namba nzima chanya iliyotolewa.\n    \n    Namba hiyo inadhaniwa kuwa ni zao la namba mbili za kwanza tofauti kabisa. \n    Kazi hii inazunguka kupitia viambajengo vinavyowezekana kuanzia na kigezo kidogo zaidi (2) \n    na inakagua kama ni kigezo cha 'n'. Ikiwa kigezo kinapatikana, kazi inarejesha \n    mgawanyo wa 'n' kwa kigezo hiki, ambacho ni kigezo kikubwa zaidi cha namba ya kwanza. Ikiwa hakuna viambajengo \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni namba ya kwanza na inarejeshwa \n    kama kigezo kikubwa zaidi cha namba ya kwanza.\n    \n    Hoja:\n    n (int): Namba nzima chanya ya kufanyia ufafanuzi, ambayo ni zao la namba mbili za kwanza tofauti.\n    \n    Inarejesha:\n    int: Kigezo kikubwa zaidi kati ya viambajengo viwili vya kwanza vya 'n'.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "tr": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Verilen pozitif bir tam sayının en büyük asal çarpanını bulun.\n    \n    Tam sayının, tam olarak iki farklı asal sayının çarpımı olduğu varsayılır.\n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar \n    arasında iterasyon yapar ve bunların 'n' sayısının bir çarpanı olup olmadığını \n    kontrol eder. Bir çarpan bulunursa, fonksiyon bu çarpan ile 'n' sayısının \n    bölünmesini döndürür, bu da daha büyük asal çarpandır. 'n' sayısının kareköküne \n    kadar hiçbir çarpan bulunamazsa, 'n' sayısının kendisi asal bir sayıdır ve \n    en büyük asal çarpan olarak döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan pozitif tam sayı.\n    \n    Döndürür:\n    int: 'n' sayısının iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "vi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau. \n    Hàm sẽ lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2) \n    và kiểm tra xem chúng có phải là ước số của 'n' hay không. Nếu tìm thấy một ước số, \n    hàm sẽ trả về kết quả chia của 'n' cho ước số này, đó là ước số nguyên tố lớn hơn. \n    Nếu không tìm thấy ước số nào đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố \n    và được trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số nguyên tố lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   "
    },
    "prompt_bertscore": {
      "es": "0.9890497057239277",
      "arb": "0.953013387475054",
      "sw": "0.9693924486951909",
      "tr": "0.9678167138824412",
      "vi": "0.9640967641064199"
    },
    "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor",
    "instruction": {
      "en": "Write a python function 'def largest_prime_factor(n: int) -> int:' to solve the following problem:\n\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
      "es": "Escribe una función de Python 'def largest_prime_factor(n: int) -> int:' para resolver el siguiente problema:\n\n    Encuentra el mayor factor primo de un entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos.\n    La función itera a través de posibles factores comenzando desde el primo más pequeño (2)\n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve\n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran factores\n    hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo y se\n    devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "arb": "اكتب دالة بايثون 'def largest_prime_factor(n: int) -> int:' لحل المشكلة التالية:\n\n    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين مميزين بالضبط.\n    تقوم الدالة بالتكرار عبر العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملًا لـ 'n'. إذا تم العثور على عامل، تقوم الدالة بإرجاع\n    قسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\n    حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم إرجاعه كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب لتفكيكه، وهو ناتج ضرب عددين أوليين مميزين.\n    \n    يعيد:\n    int: الأكبر بين العاملين الأوليين لـ 'n'.\n    \n    أمثلة:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "sw": "Andika kazi ya python 'def largest_prime_factor(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Tafuta kipengele kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n    \n    Nambari inadhaniwa kuwa ni zao la nambari mbili tofauti za kwanza. \n    Kazi hii inarudia kupitia vipengele vinavyowezekana kuanzia na nambari ya kwanza ndogo zaidi (2) \n    na inakagua kama ni kipengele cha 'n'. Ikiwa kipengele kinapatikana, kazi inarejesha \n    mgawanyiko wa 'n' kwa kipengele hiki, ambacho ni kipengele kikubwa zaidi cha kwanza. Ikiwa hakuna vipengele \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya kwanza na inarejeshwa \n    kama kipengele kikubwa zaidi cha kwanza.\n    \n    Hoja:\n    n (int): Nambari chanya ya kufanyia ufafanuzi, ambayo ni zao la nambari mbili tofauti za kwanza.\n    \n    Inarejesha:\n    int: Kati ya vipengele viwili vya kwanza vya 'n', kikubwa zaidi.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "tr": "Bir python fonksiyonu 'def largest_prime_factor(n: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen bir pozitif tam sayının en büyük asal çarpanını bulun.\n    \n    Tam sayının tam olarak iki farklı asal sayının çarpımı olduğu varsayılır. \n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanları iteratif \n    olarak kontrol eder ve bunların 'n' sayısının çarpanı olup olmadığını kontrol eder. \n    Eğer bir çarpan bulunursa, fonksiyon bu çarpan ile 'n' sayısının bölünmesini döndürür, \n    bu da daha büyük asal çarpandır. Eğer 'n' sayısının kareköküne kadar hiçbir çarpan \n    bulunamazsa, o zaman 'n' sayısının kendisi asal sayıdır ve en büyük asal çarpan olarak \n    döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan, çarpanlarına ayrılacak pozitif tam sayı.\n    \n    Döndürür:\n    int: 'n' sayısının iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
      "vi": "Viết một hàm python 'def largest_prime_factor(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau.\n    Hàm lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2)\n    và kiểm tra nếu chúng là một ước của 'n'. Nếu tìm thấy một ước, hàm trả về\n    phép chia của 'n' cho ước này, đó là ước số nguyên tố lớn hơn. Nếu không tìm thấy\n    ước nào cho đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố và được\n    trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số nguyên tố lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5"
    },
    "instruction_bertscore": {
      "es": "0.9896573160595133",
      "arb": "0.9766521904916351",
      "sw": "0.9673479461831989",
      "tr": "0.9658999307054545",
      "vi": "0.974749708702083"
    },
    "level": "easy",
    "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()",
    "entry_point": "largest_prime_factor",
    "signature": "def largest_prime_factor(n: int) -> int:",
    "docstring": {
      "en": "\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
      "es": "    Encontrar el mayor factor primo de un entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos.\n    La función itera a través de posibles factores comenzando desde el menor primo (2)\n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve\n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran\n    factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo\n    y se devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
      "arb": "    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين مميزين بالضبط.\n    تقوم الدالة بالتكرار عبر العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تُرجع الدالة\n    ناتج قسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور\n    على عوامل حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم\n    إرجاعه كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب لتحليله إلى عوامل، وهو ناتج ضرب عددين أوليين مميزين.\n    \n    يعيد:\n    int: الأكبر بين العاملين الأوليين لـ 'n'.\n    \n    امثله:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "sw": "    Pata kipengele kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n    \n    Nambari inadhaniwa kuwa ni zao la nambari mbili tofauti za kwanza. \n    Kazi inazunguka kupitia vipengele vinavyowezekana kuanzia na nambari ya kwanza ndogo zaidi (2) \n    na inakagua ikiwa ni kipengele cha 'n'. Ikiwa kipengele kinapatikana, kazi inarudisha \n    mgawanyiko wa 'n' kwa kipengele hiki, ambacho ni kipengele kikubwa zaidi cha kwanza. Ikiwa hakuna vipengele \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya kwanza na inarudishwa \n    kama kipengele kikubwa zaidi cha kwanza.\n    \n    Hoja:\n    n (int): Nambari chanya ya kufanyia utafiti, ambayo ni zao la nambari mbili tofauti za kwanza.\n    \n    Inarudisha:\n    int: Kipengele kikubwa zaidi kati ya vipengele viwili vya kwanza vya 'n'.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "tr": "    Verilen pozitif bir tamsayının en büyük asal çarpanını bulun.\n    \n    Tamsayının tam olarak iki farklı asal sayının çarpımı olduğu varsayılır. \n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar arasında \n    iterasyon yapar ve bunların 'n' sayısının bir çarpanı olup olmadığını kontrol eder. \n    Eğer bir çarpan bulunursa, fonksiyon bu çarpanla 'n' sayısının bölünmesini döndürür, \n    bu da daha büyük asal çarpandır. Eğer 'n' sayısının kareköküne kadar hiçbir çarpan \n    bulunamazsa, o zaman 'n' kendisi bir asal sayıdır ve en büyük asal çarpan olarak \n    döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan pozitif tamsayı.\n    \n    Döndürür:\n    int: 'n' sayısının iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "vi": "    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau. \n    Hàm này lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2) \n    và kiểm tra xem chúng có phải là ước số của 'n' không. Nếu tìm thấy một ước số, \n    hàm trả về kết quả của 'n' chia cho ước số này, đó là ước số nguyên tố lớn hơn. \n    Nếu không tìm thấy ước số nào cho đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố \n    và được trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5"
    },
    "docstring_bertscore": {
      "es": "0.9893573841841506",
      "arb": "0.9699559630861869",
      "sw": "0.9568872757963776",
      "tr": "0.9637545239598967",
      "vi": "0.9343284261614831"
    }
  },
  {
    "task_id": "Python/24",
    "prompt": {
      "en": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "es": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Cuenta el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a particionar.\n    k (int): El número de partes en las que dividir n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionar.\n\n    Ejemplos:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "arb": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    عد عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث أن كل جزء لا يقل عن x ولا يهم ترتيب الأجزاء.\n\n    المعاملات:\n    n (int): العدد الصحيح المراد تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    يعيد:\n    int: عدد طرق التقسيم المميزة.\n\n    أمثلة:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "sw": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kugawanya nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu hauna umuhimu.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawanya n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarejesha:\n    int: Idadi ya njia tofauti za kugawanya.\n\n    Mifano:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "tr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Bir tamsayı n'yi k parçaya ayırmanın yollarını say,\n    burada her parça en az x ve parçaların sırası önemli değil.\n\n    Parametreler:\n    n (int): Parçalanacak tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her parça için minimum değer.\n\n    Dönüş:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "vi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Đếm số cách phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác nhau.\n\n    Ví dụ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9808609696353834",
      "arb": "0.99258175115949",
      "sw": "0.9642272642667598",
      "tr": "0.983142040931188",
      "vi": "0.9848975362387743"
    },
    "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count",
    "instruction": {
      "en": "Write a python function 'def count_partitions(n: int, k: int, x: int) -> int:' to solve the following problem:\n\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "es": "Escribe una función de Python 'def count_partitions(n: int, k: int, x: int) -> int:' para resolver el siguiente problema:\n\n    Cuenta el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a ser particionado.\n    k (int): El número de partes en que se divide n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionar.\n\n    Ejemplos:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "arb": "اكتب دالة بايثون 'def count_partitions(n: int, k: int, x: int) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث أن كل جزء لا يقل عن x وترتيب الأجزاء لا يهم.\n\n    المعاملات:\n    n (int): العدد الصحيح الذي سيتم تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    يعيد:\n    int: عدد طرق التقسيم المميزة.\n\n    أمثلة:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "sw": "Andika kazi ya python 'def count_partitions(n: int, k: int, x: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya njia za kugawa nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawa n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarudisha:\n    int: Idadi ya njia tofauti za kugawa.\n\n    Mifano:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "tr": "Bir python fonksiyonu 'def count_partitions(n: int, k: int, x: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Bir tamsayı n'yi k parçaya ayırmanın yollarını sayın,\n    burada her parça en az x olmalı ve parçaların sırası önemli değildir.\n\n    Parametreler:\n    n (int): Parçalanacak tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her parça için minimum değer.\n\n    Döndürür:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "vi": "Viết một hàm python 'def count_partitions(n: int, k: int, x: int) -> int:' để giải quyết vấn đề sau:\n\n    Đếm số cách để phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác biệt.\n\n    Ví dụ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    "
    },
    "instruction_bertscore": {
      "es": "0.9791654607028696",
      "arb": "0.983073910710493",
      "sw": "0.9621597206305675",
      "tr": "0.9773174036377209",
      "vi": "0.9884037597248022"
    },
    "level": "easy",
    "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()",
    "entry_point": "count_partitions",
    "signature": "def count_partitions(n: int, k: int, x: int) -> int:",
    "docstring": {
      "en": "\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "es": "    Contar el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a ser particionado.\n    k (int): El número de partes en las que dividir n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionamiento.\n\n    Ejemplos:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "arb": "    احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث يكون كل جزء على الأقل x ولا يهم ترتيب الأجزاء.\n\n    المعاملات:\n    n (int): العدد الصحيح الذي سيتم تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    يعيد:\n    int: عدد طرق التقسيم المتميزة.\n\n    أمثلة:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "sw": "    Hesabu idadi ya njia za kugawanya nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawa n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarejesha:\n    int: Idadi ya njia tofauti za kugawanya.\n\n    Mifano:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "tr": "    Bir tamsayı n'yi k parçaya ayırmanın kaç yolu olduğunu sayın,\n    burada her bir parça en az x ve parçaların sırası önemli değildir.\n\n    Parametreler:\n    n (int): Bölünecek tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her bir parça için minimum değer.\n\n    Döndürür:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "vi": "    Đếm số cách để phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác biệt.\n\n    Ví dụ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    "
    },
    "docstring_bertscore": {
      "es": "0.9847642552531",
      "arb": "0.9743548315045856",
      "sw": "0.9648571212050213",
      "tr": "0.980425969100917",
      "vi": "0.9837142950589495"
    }
  },
  {
    "task_id": "Python/25",
    "prompt": {
      "en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "es": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calcula el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede añadir un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario utilizado para la memoización, almacenando el número de secuencias\n                     válidas para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "arb": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    حساب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. \n    تستخدم هذه الدالة التخزين المؤقت لتخزين النتائج المحسوبة مسبقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الذي يبدأ به التسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، حيث يخزن عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    امثله:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "sw": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Kuhesabu idadi ya mfuatano halali ambayo inaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mfuatano huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mfuatano\n    ikiwa ni nambari nzima chanya na haizidi nusu ya nambari ya mwisho katika mfuatano. Kazi hii\n    hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n    \n    Hoja:\n        n (int): Nambari ya kuanzia ya mfuatano.\n        last (int): Nambari ya mwisho katika mfuatano wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, kuhifadhi idadi ya mfuatano halali\n                     kwa kila thamani ya 'last' iliyokutana.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya mfuatano halali ambayo inaweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "tr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir 'n' sayısı ile başlar ve diziye yeni bir sayı eklenebilir\n    eğer pozitif bir tam sayıysa ve dizideki son sayının yarısından büyük değilse. Bu\n    fonksiyon, performansı optimize etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoizasyon kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Memoizasyon için kullanılan bir sözlük, karşılaşılan her 'last' değeri için\n                     geçerli dizilerin sayısını saklar.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n    \n    Örnekler:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "vi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Tính toán số lượng dãy hợp lệ có thể được tạo thành theo các quy tắc cụ thể.\n    \n    Mỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy\n    nếu nó là một số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này\n    sử dụng ghi nhớ để lưu trữ các kết quả đã tính trước đó nhằm tối ưu hóa hiệu suất.\n    \n    Tham số:\n        n (int): Số bắt đầu của dãy.\n        last (int): Số cuối cùng trong dãy hiện tại.\n        memo (dict): Một từ điển được sử dụng để ghi nhớ, lưu trữ số lượng dãy hợp lệ\n                     cho mỗi giá trị 'last' đã gặp.\n    \n    Trả về:\n        int: Tổng số dãy hợp lệ có thể được tạo thành bắt đầu với 'n'.\n    \n    Ví dụ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.99056068703246",
      "arb": "0.9774546572310161",
      "sw": "0.9604953966678763",
      "tr": "0.9863048324884065",
      "vi": "0.9860339006486749"
    },
    "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count",
    "instruction": {
      "en": "Write a python function 'def count_sequences(n: int, last: int, memo: dict) -> int:' to solve the following problem:\n\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    ",
      "es": "Escribe una función en Python 'def count_sequences(n: int, last: int, memo: dict) -> int:' para resolver el siguiente problema:\n\n    Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede añadir un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario usado para la memoización, almacenando el número de secuencias válidas\n                     para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "arb": "اكتب دالة بايثون 'def count_sequences(n: int, last: int, memo: dict) -> int:' لحل المشكلة التالية:\n\n    احسب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا وليس أكبر من نصف الرقم الأخير في التسلسل. هذه\n    الدالة تستخدم التخزين المؤقت لتخزين النتائج المحسوبة سابقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الابتدائي للتسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، ويخزن عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    أمثلة:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "sw": "Andika kazi ya python 'def count_sequences(n: int, last: int, memo: dict) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mlolongo huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\n    ikiwa ni nambari chanya na si kubwa zaidi ya nusu ya nambari ya mwisho katika mlolongo. Hii\n    kazi hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n    \n    Vipengele:\n        n (int): Nambari ya kuanzia ya mlolongo.\n        last (int): Nambari ya mwisho katika mlolongo wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, ikihifadhi idadi ya milolongo halali\n                     kwa kila thamani ya 'last' iliyokutana.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya milolongo halali inayoweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "tr": "Bir python fonksiyonu 'def count_sequences(n: int, last: int, memo: dict) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir sayı 'n' ile başlar ve diziye yeni bir sayı eklenebilir\n    eğer pozitif bir tam sayıysa ve dizideki son sayının yarısından büyük değilse. Bu\n    fonksiyon, performansı optimize etmek için daha önce hesaplanan sonuçları saklamak amacıyla memoization kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan\n                     memoization için kullanılan bir sözlük.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n    \n    Örnekler:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "vi": "Viết một hàm python 'def count_sequences(n: int, last: int, memo: dict) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán số lượng dãy hợp lệ có thể được hình thành theo các quy tắc cụ thể.\n    \n    Mỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy\n    nếu nó là số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này\n    sử dụng ghi nhớ để lưu trữ các kết quả đã tính toán trước đó nhằm tối ưu hóa hiệu suất.\n    \n    Tham số:\n        n (int): Số bắt đầu của dãy.\n        last (int): Số cuối cùng trong dãy hiện tại.\n        memo (dict): Một từ điển được sử dụng để ghi nhớ, lưu trữ số lượng dãy hợp lệ\n                     cho mỗi giá trị 'last' đã gặp.\n    \n    Trả về:\n        int: Tổng số dãy hợp lệ có thể được hình thành bắt đầu với 'n'.\n    \n    Ví dụ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6"
    },
    "instruction_bertscore": {
      "es": "0.9887887054032478",
      "arb": "0.9245913662527719",
      "sw": "0.963203920543668",
      "tr": "0.9794304336311701",
      "vi": "0.9849519609631779"
    },
    "level": "easy",
    "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()",
    "entry_point": "count_sequences",
    "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:",
    "docstring": {
      "en": "\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    ",
      "es": "    Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede agregar un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario utilizado para la memoización, almacenando el número de secuencias válidas\n                     para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "arb": "    حساب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. \n    تستخدم هذه الدالة التخزين المؤقت لتخزين النتائج المحسوبة سابقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الذي يبدأ به التسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، حيث يتم تخزين عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    امثله:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "sw": "    Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mlolongo huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\n    ikiwa ni nambari nzima chanya na si kubwa kuliko nusu ya nambari ya mwisho kwenye mlolongo. \n    Kazi hii hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n    \n    Hoja:\n        n (int): Nambari ya kuanzia ya mlolongo.\n        last (int): Nambari ya mwisho katika mlolongo wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, ikihifadhi idadi ya milolongo halali\n                     kwa kila thamani ya 'last' iliyokutana.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya milolongo halali inayoweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "tr": "    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir sayı 'n' ile başlar ve dizinin son sayısının yarısından büyük olmayan\n    pozitif bir tamsayı ise diziye yeni bir sayı eklenebilir. Bu fonksiyon, performansı optimize\n    etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoization kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan,\n                     memoization için kullanılan bir sözlük.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n    \n    Örnekler:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "vi": "Tính toán số lượng dãy hợp lệ có thể được hình thành theo các quy tắc cụ thể.\n\nMỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy nếu nó là một số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này sử dụng ghi nhớ để lưu trữ các kết quả đã tính toán trước đó nhằm tối ưu hóa hiệu suất.\n\nTham số:\n    n (int): Số bắt đầu của dãy.\n    last (int): Số cuối cùng trong dãy hiện tại.\n    memo (dict): Một từ điển được sử dụng để ghi nhớ, lưu trữ số lượng dãy hợp lệ cho mỗi giá trị 'last' đã gặp.\n\nTrả về:\n    int: Tổng số dãy hợp lệ có thể được hình thành bắt đầu với 'n'.\n\nVí dụ:\n    >>> count_sequences(1, 1, {})\n    1\n    >>> count_sequences(6, 6, {})\n    6"
    },
    "docstring_bertscore": {
      "es": "0.990964502597104",
      "arb": "0.9677807617834739",
      "sw": "0.9731513300258952",
      "tr": "0.9745526673640963",
      "vi": "0.992342004289581"
    }
  },
  {
    "task_id": "Python/26",
    "prompt": {
      "en": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "es": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (GCD)\n    y y0 como su mínimo común múltiplo (LCM).\n\n    Argumentos:\n    x0 (int): El GCD que cada par (P, Q) debe tener.\n    y0 (int): El LCM que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cuenta de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su GCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el GCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario en 2 para contar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "arb": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    يحسب عدد الأزواج من الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD)\n    و y0 كأصغر مضاعف مشترك (LCM).\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\n    y0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بتكرار جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a',\n    تحسب العامل المقابل 'b' بحيث يكون 'a * b = y0 / x0'. ثم تتحقق مما إذا كانت 'a' و 'b'\n    متوافقة (GCD لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات 'x0' بواسطة عوامل متوافقة للحفاظ\n    على GCD كـ 'x0'. إذا كانت 'a' و 'b' متوافقة، يتم زيادة العد بمقدار 1 إذا كانت 'a' هي نفسها 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\n    حالات المثال:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "sw": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya jozi za nambari chanya (P, Q) ambapo P na Q zina x0 kama kipimo chao kikuu cha pamoja (GCD)\n    na y0 kama kinyume cha chini zaidi (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Hesabu ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyobainishwa.\n\n    Kazi hii inafanya mzunguko kupitia vigezo vyote vinavyowezekana 'a' vya mgawo 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni huru (GCD yao ni 1) kwa sababu P na Q zinaweza tu kuwa vipimo vya 'x0' kwa vigezo huru ili kudumisha\n    GCD kama 'x0'. Ikiwa 'a' na 'b' ni huru, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuzingatia jozi zote mbili (P, Q) na (Q, P).\n\n    Mifano ya Kesi:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "tr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    x0'u en büyük ortak bölenleri (EBOB) ve y0'u en küçük ortak katları (EKOK) olan pozitif tam sayı çiftlerinin (P, Q) sayısını sayar.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken EBOB.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken EKOK.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası 'a' çarpanlarını iteratif olarak kontrol eder. Her 'a' çarpanı için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen 'b' çarpanını hesaplar. Daha sonra 'a' ve 'b'nin\n    aralarında asal olup olmadığını (EBOB'ları 1 ise) kontrol eder çünkü P ve Q, EBOB'u 'x0' olarak korumak için\n    sadece aralarında asal çarpanlarla 'x0' katları olabilir. Eğer 'a' ve 'b' aralarında asal ise, 'a' ve 'b' aynıysa\n    sayım 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "vi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước số chung lớn nhất (GCD)\n    và y0 là bội số chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm duyệt qua tất cả các ước số 'a' có thể có của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra xem 'a' và 'b'\n    có phải là số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\n    GCD là 'x0'. Nếu 'a' và 'b' là số nguyên tố cùng nhau, số đếm được tăng thêm 1 nếu 'a' giống như 'b',\n    nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9776507054170975",
      "arb": "0.9564947821634526",
      "sw": "0.9455192618289888",
      "tr": "0.9423526962945306",
      "vi": "0.9492827116584568"
    },
    "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count",
    "instruction": {
      "en": "Write a python function 'def count_coprime_pairs(x0: int, y0: int) -> int:' to solve the following problem:\n\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ",
      "es": "Escribe una función en Python 'def count_coprime_pairs(x0: int, y0: int) -> int:' para resolver el siguiente problema:\n\n    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (MCD)\n    y y0 como su mínimo común múltiplo (MCM).\n\n    Argumentos:\n    x0 (int): El MCD que cada par (P, Q) debe tener.\n    y0 (int): El MCM que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cuenta de todos los posibles pares (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su MCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el MCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario en 2 para contar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "arb": "اكتب دالة بايثون 'def count_coprime_pairs(x0: int, y0: int) -> int:' لحل المشكلة التالية:\n\n    تحسب عدد الأزواج من الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD)\n    و y0 كأصغر مضاعف مشترك (LCM).\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\n    y0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بتكرار جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a',\n    تحسب العامل المقابل 'b' بحيث 'a * b = y0 / x0'. ثم تتحقق مما إذا كانت 'a' و 'b'\n    متوافقة (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات 'x0' بعوامل متوافقة للحفاظ\n    على القاسم المشترك الأكبر كـ 'x0'. إذا كانت 'a' و 'b' متوافقة، يتم زيادة العد بمقدار 1 إذا كانت 'a' هي نفسها 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\n    حالات المثال:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "sw": "Andika kazi ya python 'def count_coprime_pairs(x0: int, y0: int) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu idadi ya jozi za nambari nzima chanya (P, Q) ambapo P na Q zina x0 kama kigezo chao kikuu cha mgawanyiko (GCD)\n    na y0 kama kigezo chao kidogo cha kuzidisha (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Hesabu ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyotajwa.\n\n    Kazi hii inarudia kupitia vigezo vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni co-prime (GCD yao ni 1) kwa sababu P na Q zinaweza tu kuwa vizidisho vya 'x0' kwa vigezo vya co-prime ili kudumisha\n    GCD kama 'x0'. Ikiwa 'a' na 'b' ni co-prime, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuzingatia jozi zote mbili (P, Q) na (Q, P).\n\n    Mifano ya Matukio:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "tr": "Bir python fonksiyonu 'def count_coprime_pairs(x0: int, y0: int) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Pozitif tam sayı çiftlerinin (P, Q) sayısını sayar, öyle ki P ve Q'nun en büyük ortak böleni (GCD) x0 ve en küçük ortak katı (LCM) y0'dır.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası çarpanları 'a' üzerinden iterasyon yapar. Her çarpan 'a' için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen çarpan 'b'yi hesaplar. Daha sonra 'a' ve 'b'nin\n    aralarında asal (GCD'leri 1) olup olmadığını kontrol eder çünkü P ve Q, GCD'yi 'x0' olarak korumak için\n    yalnızca 'x0'ın çarpanları ile aralarında asal olabilir. Eğer 'a' ve 'b' aralarında asal ise, 'a' ve 'b'\n    aynıysa sayım 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "vi": "Viết một hàm python 'def count_coprime_pairs(x0: int, y0: int) -> int:' để giải quyết vấn đề sau:\n\n    Đếm số lượng cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước số chung lớn nhất (GCD)\n    và y0 là bội số chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm lặp qua tất cả các ước số 'a' có thể có của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra nếu 'a' và 'b'\n    là các số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\n    GCD là 'x0'. Nếu 'a' và 'b' là các số nguyên tố cùng nhau, số đếm được tăng thêm 1 nếu 'a' giống 'b',\n    nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0"
    },
    "instruction_bertscore": {
      "es": "0.9732609739962265",
      "arb": "0.946430975277939",
      "sw": "0.9707192996405041",
      "tr": "0.9491369169587772",
      "vi": "0.9455097275706992"
    },
    "level": "easy",
    "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()",
    "entry_point": "count_coprime_pairs",
    "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:",
    "docstring": {
      "en": "\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ",
      "es": "    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (MCD)\n    y y0 como su mínimo común múltiplo (mcm).\n\n    Argumentos:\n    x0 (int): El MCD que cada par (P, Q) debe tener.\n    y0 (int): El mcm que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cantidad de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su MCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el MCD como 'x0'. Si 'a' y 'b' son coprimos, el conteo se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario, en 2 para contar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "arb": "    يحسب عدد الأزواج من الأعداد الصحيحة الموجبة (P، Q) بحيث يكون لـ P و Q القاسم المشترك الأكبر (GCD) x0 \n    وأصغر مضاعف مشترك (LCM) y0.\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P، Q).\n    y0 (int): أصغر مضاعف مشترك الذي يجب أن يكون لكل زوج (P، Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P، Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بتكرار جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a'،\n    تحسب العامل المقابل 'b' بحيث 'a * b = y0 / x0'. ثم تتحقق مما إذا كانت 'a' و 'b'\n    متوافقة (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا مضاعفات لـ 'x0' فقط بعوامل متوافقة للحفاظ\n    على القاسم المشترك الأكبر كـ 'x0'. إذا كانت 'a' و 'b' متوافقة، يتم زيادة العداد بمقدار 1 إذا كانت 'a' هي نفسها 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P، Q) و (Q، P).\n\n    أمثلة الحالات:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "sw": "    Inahesabu idadi ya jozi za nambari nzima chanya (P, Q) ambapo P na Q zina x0 kama kigezo chao kikuu cha mgawanyiko (GCD)\n    na y0 kama kigezo chao cha chini cha kuzidisha (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Idadi ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyotajwa.\n\n    Kazi hii inazunguka kupitia vigezo vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni nambari ambazo hazina mgawanyiko wa pamoja (GCD yao ni 1) kwa sababu P na Q zinaweza kuwa tu\n    maradufu ya 'x0' kwa vigezo ambavyo havina mgawanyiko wa pamoja ili kudumisha GCD kama 'x0'.\n    Ikiwa 'a' na 'b' hazina mgawanyiko wa pamoja, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuhesabu jozi zote mbili (P, Q) na (Q, P).\n\n    Mfano wa Matukio:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "tr": "    Pozitif tam sayı çiftlerinin (P, Q) sayısını sayar, öyle ki P ve Q'nun en büyük ortak böleni (GCD) x0\n    ve en küçük ortak katı (LCM) y0'dır.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası 'a' çarpanlarını iterasyonla kontrol eder. Her bir 'a' çarpanı için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen 'b' çarpanını hesaplar. Daha sonra 'a' ve 'b'nin\n    aralarında asal olup olmadığını kontrol eder (GCD'leri 1 ise) çünkü P ve Q, GCD'nin 'x0' olarak kalması için\n    yalnızca aralarında asal çarpanlarla 'x0' katları olabilir. Eğer 'a' ve 'b' aralarında asal ise, sayım\n    'a' ve 'b' aynıysa 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ",
      "vi": "    Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước số chung lớn nhất (GCD)\n    và y0 là bội số chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm lặp qua tất cả các ước số 'a' có thể có của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra nếu 'a' và 'b'\n    là các số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\n    GCD là 'x0'. Nếu 'a' và 'b' là các số nguyên tố cùng nhau, số đếm được tăng thêm 1 nếu 'a' giống như 'b',\n    nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9728450419783394",
      "arb": "0.9324181977870707",
      "sw": "0.9609806506887445",
      "tr": "0.9471966953968284",
      "vi": "0.9432127658444117"
    }
  },
  {
    "task_id": "Python/27",
    "prompt": {
      "en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "es": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\n    devuelve el recorrido preorder como una cadena.\n\n    Argumentos:\n    inorder (str): El recorrido inorder del árbol binario.\n    postorder (str): El recorrido postorder del árbol binario.\n\n    Devuelve:\n    str: El recorrido preorder del árbol binario.\n\n    Ejemplo:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "arb": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    يعيد بناء الشجرة الثنائية من ترتيباتها التتابعية واللاحقة\n    ويعيد الترتيب التمهيدي كسلسلة نصية.\n\n    يعيدالحجج:\n    inorder (str): الترتيب التتابعي للشجرة الثنائية.\n    postorder (str): الترتيب اللاحق للشجرة الثنائية.\n\n    يعيد:\n    str: الترتيب التمهيدي للشجرة الثنائية.\n\n    امثله:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "sw": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Inajenga upya mti wa binary kutoka kwa inorder na postorder traversals na\n    inarudisha preorder traversal kama kamba.\n\n    Hoja:\n    inorder (str): Inorder traversal ya mti wa binary.\n    postorder (str): Postorder traversal ya mti wa binary.\n\n    Inarejesha:\n    str: Preorder traversal ya mti wa binary.\n\n    Mfano:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "tr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    İkili ağacı inorder ve postorder traversallarından yeniden oluşturur ve\n    preorder traversalını bir string olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder traversalı.\n    postorder (str): İkili ağacın postorder traversalı.\n\n    Döndürür:\n    str: İkili ağacın preorder traversalı.\n\n    Örnek:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "vi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Tái tạo cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng một chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Ví dụ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9499987741820876",
      "sw": "0.9791555291838178",
      "tr": "0.9763566284846552",
      "vi": "0.9687472972175897"
    },
    "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder",
    "instruction": {
      "en": "Write a python function 'def preorder_traversal(inorder: str, postorder: str) -> str:' to solve the following problem:\n\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    ",
      "es": "Escribe una función de Python 'def preorder_traversal(inorder: str, postorder: str) -> str:' para resolver el siguiente problema:\n\n    Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\n    devuelve el recorrido preorder como una cadena.\n\n    Argumentos:\n    inorder (str): El recorrido inorder del árbol binario.\n    postorder (str): El recorrido postorder del árbol binario.\n\n    Devuelve:\n    str: El recorrido preorder del árbol binario.\n\n    Ejemplo:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "arb": "اكتب دالة بايثون 'def preorder_traversal(inorder: str, postorder: str) -> str:' لحل المشكلة التالية:\n\n    يعيد بناء الشجرة الثنائية من ترتيبها الوسطي وترتيبها اللاحق ويعيد\n    ترتيبها السابق كسلسلة نصية.\n\n    يعيدالحجج:\n    inorder (str): الترتيب الوسطي للشجرة الثنائية.\n    postorder (str): الترتيب اللاحق للشجرة الثنائية.\n\n    يعيد:\n    str: الترتيب السابق للشجرة الثنائية.\n\n    مثال:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "sw": "Andika kazi ya python 'def preorder_traversal(inorder: str, postorder: str) -> str:' kutatua tatizo lifuatalo:\n\n    Inajenga upya mti wa binary kutoka kwa inorder na postorder traversals na\n    inarudisha preorder traversal kama kamba.\n\n    Hoja:\n    inorder (str): Inorder traversal ya mti wa binary.\n    postorder (str): Postorder traversal ya mti wa binary.\n\n    Inarejesha:\n    str: Preorder traversal ya mti wa binary.\n\n    Mfano:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "tr": "Bir python fonksiyonu 'def preorder_traversal(inorder: str, postorder: str) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    İkili ağacı inorder ve postorder traversallarından yeniden oluşturur ve\n    preorder traversalını bir string olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder traversalı.\n    postorder (str): İkili ağacın postorder traversalı.\n\n    Döndürür:\n    str: İkili ağacın preorder traversalı.\n\n    Örnek:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "vi": "Viết một hàm python 'def preorder_traversal(inorder: str, postorder: str) -> str:' để giải quyết vấn đề sau:\n\n    Tái tạo cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng một chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Ví dụ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'"
    },
    "instruction_bertscore": {
      "es": "0.9942687189856193",
      "arb": "0.996219467957763",
      "sw": "0.980796613391928",
      "tr": "0.9700956002440545",
      "vi": "0.9717817735486597"
    },
    "level": "hard",
    "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()",
    "entry_point": "preorder_traversal",
    "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:",
    "docstring": {
      "en": "\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    ",
      "es": "Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y devuelve el recorrido preorder como una cadena.\n\nArgumentos:\ninorder (str): El recorrido inorder del árbol binario.\npostorder (str): El recorrido postorder del árbol binario.\n\nDevuelve:\nstr: El recorrido preorder del árbol binario.\n\nEjemplo:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'",
      "arb": "يعيد بناء الشجرة الثنائية من ترتيبها الوسطي وترتيبها اللاحق ويعيد ترتيبها السابق كسلسلة نصية.\n\nيعيدالحجج:\ninorder (str): الترتيب الوسطي للشجرة الثنائية.\npostorder (str): الترتيب اللاحق للشجرة الثنائية.\n\nيعيد:\nstr: الترتيب السابق للشجرة الثنائية.\n\nامثله:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'",
      "sw": "    Inajenga upya mti wa binary kutoka kwa mfuatano wake wa inorder na postorder na\n    inarudisha mfuatano wa preorder kama kamba.\n\n    Hoja:\n    inorder (str): Mfuatano wa inorder wa mti wa binary.\n    postorder (str): Mfuatano wa postorder wa mti wa binary.\n\n    Inarudisha:\n    str: Mfuatano wa preorder wa mti wa binary.\n\n    Mfano:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "tr": "    İkili ağacı, inorder ve postorder geçişlerinden yeniden oluşturur ve\n    preorder geçişini bir dize olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder geçişi.\n    postorder (str): İkili ağacın postorder geçişi.\n\n    Döndürülenler:\n    str: İkili ağacın preorder geçişi.\n\n    Örnek:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "vi": "    Tái tạo cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Ví dụ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'"
    },
    "docstring_bertscore": {
      "es": "0.9928854570120924",
      "arb": "0.9846923510551653",
      "sw": "0.9212257730765168",
      "tr": "0.9674357408116163",
      "vi": "0.9614327334359799"
    }
  },
  {
    "task_id": "Python/28",
    "prompt": {
      "en": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "es": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B usando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"NO ANSWER!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a lograr.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (con la que se reemplaza).\n\n    Devuelve:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"NO ANSWER!\".\n\n    Ejemplos:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "arb": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    تنفيذ تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة هدف B، مع قائمة من قواعد التحويل،\n    وتحاول تحويل A إلى B باستخدام القواعد. يتم استخدام خوارزمية البحث بعرض\n    (BFS) لاستكشاف التحويلات الممكنة حتى حد أقصى من 10 خطوات. إذا كان من الممكن\n    تحويل A إلى B في غضون 10 خطوات، فإن الدالة تعيد الحد الأدنى لعدد الخطوات\n    المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد \"NO ANSWER!\".\n\n    المعاملات:\n    A (str): السلسلة الابتدائية التي سيتم تحويلها.\n    B (str): سلسلة الهدف المراد تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث تحتوي كل قاعدة على\n                            السلسلة الفرعية المصدر (التي سيتم استبدالها) والسلسلة\n                            الفرعية الهدف (التي سيتم الاستبدال بها).\n\n    العوائد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ذلك ممكنًا، وإلا \"NO ANSWER!\".\n\n    أمثلة:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "sw": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10,\n    kazi inarudisha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarudisha\n    \"NO ANSWER!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayopaswa kubadilishwa.\n    B (str): Kamba lengwa inayopaswa kufikiwa.\n    rules (list of tuples): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ndogo ya chanzo (inayopaswa kubadilishwa) na\n                            sehemu ndogo ya lengwa (ya kubadilisha nayo).\n\n    Inarudisha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"NO ANSWER!\".\n\n    Mifano:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "tr": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Bir dizi dönüşüm kuralı kullanarak A'dan B'ye string dönüşümü gerçekleştirin.\n\n    Bu fonksiyon, başlangıç stringi A ve hedef string B'yi, bir dizi dönüşüm kuralı ile birlikte alır\n    ve A'yı kuralları kullanarak B'ye dönüştürmeye çalışır.\n    Olası dönüşümleri maksimum 10 adımda keşfetmek için Genişlik Öncelikli Arama (BFS) algoritması kullanılır.\n    A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür.\n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç stringi.\n    B (str): Elde edilmesi gereken hedef string.\n    rules (list of tuples): Her bir kuralın bir kaynak alt dize (değiştirilecek) ve\n                            bir hedef alt dize (ile değiştirilecek) içerdiği dönüşüm kuralları listesi.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "vi": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận vào một chuỗi ban đầu A và một chuỗi mục tiêu B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc đó.\n    Thuật toán Tìm kiếm theo Chiều rộng (BFS) được sử dụng để khám phá các khả năng chuyển đổi\n    tối đa trong 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm sẽ\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm sẽ trả về \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần chuyển đổi.\n    B (str): Chuỗi mục tiêu cần đạt được.\n    rules (list of tuples): Danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một bộ\n                            chứa chuỗi con nguồn (cần thay thế) và chuỗi con mục tiêu (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\n    Ví dụ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9870342032475666",
      "arb": "0.9872542857097533",
      "sw": "0.9900702686216849",
      "tr": "0.9751586886566338",
      "vi": "0.9903717895400959"
    },
    "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"",
    "instruction": {
      "en": "Write a python function 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' to solve the following problem:\n\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    ",
      "es": "Escribe una función de Python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' para resolver el siguiente problema:\n\n    Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B usando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"NO ANSWER!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a alcanzar.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (con la que se reemplaza).\n\n    Devuelve:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"NO ANSWER!\".\n\n    Ejemplos:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "arb": "اكتب دالة بايثون 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' لحل المشكلة التالية:\n\n    قم بإجراء تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة مستهدفة B، بالإضافة إلى قائمة\n    من قواعد التحويل، وتحاول تحويل A إلى B باستخدام القواعد.\n    يتم استخدام خوارزمية البحث بالعرض (BFS) لاستكشاف التحويلات الممكنة\n    بحد أقصى 10 خطوات. إذا كان بالإمكان تحويل A إلى B في غضون 10 خطوات، فإن الدالة\n    تعيد الحد الأدنى لعدد الخطوات المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد\n    \"NO ANSWER!\".\n\n    المعاملات:\n    A (str): السلسلة الابتدائية التي سيتم تحويلها.\n    B (str): السلسلة المستهدفة التي يجب تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث تكون كل قاعدة عبارة عن زوج\n                            يحتوي على الجزء الفرعي المصدر (الذي سيتم استبداله) والجزء\n                            الفرعي الهدف (الذي سيتم الاستبدال به).\n\n    العوائد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ذلك ممكنًا، وإلا \"NO ANSWER!\".\n\n    أمثلة:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "sw": "Andika kazi ya python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' kutatua tatizo lifuatalo:\n\n    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10,\n    kazi inarudisha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarudisha\n    \"NO ANSWER!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayotakiwa kubadilishwa.\n    B (str): Kamba lengwa inayotakiwa kufikiwa.\n    rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ndogo ya chanzo (itakayobadilishwa) na\n                            sehemu ndogo ya lengwa (ya kubadilisha nayo).\n\n    Inarejesha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"NO ANSWER!\".\n\n    Mifano:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "tr": "Bir python fonksiyonu 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' yazarak aşağıdaki problemi çözün:\n\n    A'dan B'ye bir dizi dönüşüm kuralı kullanarak string dönüşümü gerçekleştirin.\n\n    Bu fonksiyon, başlangıç stringi A ve hedef string B'yi, dönüşüm kuralları listesi ile birlikte alır\n    ve A'yı B'ye kuralları kullanarak dönüştürmeye çalışır.\n    Olası dönüşümleri en fazla 10 adımda keşfetmek için Genişlik Öncelikli Arama (BFS) algoritması kullanılır.\n    Eğer A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür. \n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç stringi.\n    B (str): Elde edilmesi gereken hedef string.\n    rules (list of tuples): Her bir kuralın, kaynak alt dize (değiştirilecek) ve\n                            hedef alt dizeyi (ile değiştirilecek) içeren bir demet olduğu dönüşüm kuralları listesi.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "vi": "Viết một hàm python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' để giải quyết vấn đề sau:\n\n    Thực hiện chuyển đổi chuỗi từ A sang B sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận một chuỗi ban đầu A và một chuỗi mục tiêu B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B sử dụng các quy tắc đó.\n    Thuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\n    lên đến tối đa 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm trả về\n    \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần chuyển đổi.\n    B (str): Chuỗi mục tiêu cần đạt được.\n    rules (list of tuples): Một danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một tuple\n                            chứa chuỗi con nguồn (cần thay thế) và chuỗi con mục tiêu (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\n    Ví dụ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'"
    },
    "instruction_bertscore": {
      "es": "0.9859081676174799",
      "arb": "0.9777702809064804",
      "sw": "0.9857903798015262",
      "tr": "0.9761911693772531",
      "vi": "0.9901123782624643"
    },
    "level": "hard",
    "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()",
    "entry_point": "string_transformation",
    "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:",
    "docstring": {
      "en": "\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    ",
      "es": "    Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B utilizando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A se puede transformar en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"¡SIN RESPUESTA!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a alcanzar.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (para reemplazar con).\n\n    Devuelve:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"¡SIN RESPUESTA!\".\n\n    Ejemplos:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    '¡SIN RESPUESTA!'",
      "arb": "    إجراء تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة مستهدفة B، بالإضافة إلى قائمة\n    من قواعد التحويل، وتحاول تحويل A إلى B باستخدام القواعد.\n    يتم استخدام خوارزمية البحث بعرض أول (BFS) لاستكشاف التحويلات الممكنة\n    حتى حد أقصى يبلغ 10 خطوات. إذا كان من الممكن تحويل A إلى B في غضون 10 خطوات، فإن الدالة\n    تعيد الحد الأدنى لعدد الخطوات المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): السلسلة الابتدائية المراد تحويلها.\n    B (str): السلسلة المستهدفة المراد تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث تكون كل قاعدة عبارة عن زوج\n                            يحتوي على الجزء الفرعي المصدر (الذي سيتم استبداله) والجزء الفرعي الهدف (الذي سيتم الاستبدال به).\n\n    يعيد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ممكنًا، وإلا \"NO ANSWER!\".\n\n    امثله:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "sw": "    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10, kazi\n    inarejesha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarejesha\n    \"HAKUNA JIBU!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayopaswa kubadilishwa.\n    B (str): Kamba lengwa inayopaswa kufikiwa.\n    rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ndogo ya chanzo (inayopaswa kubadilishwa) na\n                            sehemu ndogo ya lengwa (ya kubadilisha nayo).\n\n    Inarejesha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"HAKUNA JIBU!\".\n\n    Mifano:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'HAKUNA JIBU!'",
      "tr": "    A'dan B'ye bir dizi dönüşüm kuralı kullanarak string dönüşümü gerçekleştirin.\n\n    Bu fonksiyon, başlangıç stringi A ve hedef string B'yi, dönüşüm kuralları listesiyle birlikte alır\n    ve A'yı kuralları kullanarak B'ye dönüştürmeye çalışır. Olası dönüşümleri keşfetmek için\n    Genişlik Öncelikli Arama (BFS) algoritması kullanılır ve maksimum 10 adımda gerçekleştirilir.\n    Eğer A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gerekli minimum adım sayısını döndürür.\n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç stringi.\n    B (str): Elde edilmek istenen hedef string.\n    rules (list of tuples): Her kuralın, kaynak alt stringi (değiştirilecek) ve\n                            hedef alt stringi (ile değiştirilecek) içeren bir tuple olduğu\n                            dönüşüm kuralları listesi.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "vi": "    Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận một chuỗi ban đầu A và một chuỗi đích B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc.\n    Thuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\n    lên đến tối đa 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm trả về \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần được chuyển đổi.\n    B (str): Chuỗi đích cần đạt được.\n    rules (list of tuples): Danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một bộ\n                            chứa chuỗi con nguồn (để được thay thế) và chuỗi con đích (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không \"NO ANSWER!\".\n\n    Ví dụ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'"
    },
    "docstring_bertscore": {
      "es": "0.9836473566205408",
      "arb": "0.9809167847724541",
      "sw": "0.9767640193961578",
      "tr": "0.9749620445794093",
      "vi": "0.9874670188478417"
    }
  },
  {
    "task_id": "Python/29",
    "prompt": {
      "en": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "es": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calcula el entero positivo más pequeño n tal que la suma de la serie armónica\n    hasta 1/n es mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Retorna:\n    - int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "arb": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    حساب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    السلسلة التوافقية تُعرّف كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    يعيدالحجج:\n    - k (int): عدد صحيح موجب يمثل القيمة الحدية التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n بحيث يتجاوز مجموع السلسلة التوافقية S_n القيمة الحدية k.\n\n    امثله:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "sw": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Hesabu namba ndogo zaidi chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Namba chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Namba ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "tr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Harmonik serinin toplamı 1/n'ye kadar olan en küçük pozitif tamsayı n'yi hesaplayın\n    ve bu toplam verilen pozitif tamsayı k'dan büyük olsun.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değeri temsil eden pozitif bir tamsayı.\n\n    Döndürür:\n    - int: Harmonik seri toplamı S_n'nin eşik k'yı aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "vi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Tính toán số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    đến 1/n lớn hơn một số nguyên dương cho trước k.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n mà tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9767727591329233",
      "arb": "0.9746339071899396",
      "sw": "0.9688569411879209",
      "tr": "0.9879214851596495",
      "vi": "0.9768196359028475"
    },
    "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1",
    "instruction": {
      "en": "Write a python function 'def find_min_n_greater_than_k(k: int) -> int:' to solve the following problem:\n\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ",
      "es": "Escribe una función de Python 'def find_min_n_greater_than_k(k: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el menor entero positivo n tal que la suma de la serie armónica\n    hasta 1/n sea mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Devuelve:\n    - int: El menor entero n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "arb": "اكتب دالة بايثون 'def find_min_n_greater_than_k(k: int) -> int:' لحل المشكلة التالية:\n\n    احسب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    تُعرّف السلسلة التوافقية كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    الوسائط:\n    - k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\n    أمثلة:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "sw": "Andika kazi ya python 'def find_min_n_greater_than_k(k: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu nambari ndogo zaidi chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko nambari chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Nambari chanya inayowakilisha thamani ya kizingiti ambayo jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Nambari ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "tr": "Bir python fonksiyonu 'def find_min_n_greater_than_k(k: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Harmonik serinin toplamının 1/n'ye kadar olan kısmının\n    verilen pozitif bir tamsayı k'dan büyük olduğu en küçük pozitif tamsayı n'yi hesaplayın.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\n    Döndürür:\n    - int: Harmonik seri toplamı S_n'nin eşik k'yı aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "vi": "Viết một hàm python 'def find_min_n_greater_than_k(k: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    lên đến 1/n lớn hơn một số nguyên dương k cho trước.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11"
    },
    "instruction_bertscore": {
      "es": "0.9852669887474992",
      "arb": "0.9745016193561704",
      "sw": "0.9728690762544446",
      "tr": "0.9835567811667888",
      "vi": "0.9849233581883089"
    },
    "level": "easy",
    "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()",
    "entry_point": "find_min_n_greater_than_k",
    "signature": "def find_min_n_greater_than_k(k: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ",
      "es": "    Calcular el entero positivo más pequeño n tal que la suma de la serie armónica\n    hasta 1/n sea mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Devuelve:\n    - int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ",
      "arb": "    حساب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    السلسلة التوافقية تُعرّف كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    يعيدالحجج:\n    - k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\n    امثله:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "sw": "    Hesabu namba ndogo zaidi chanya n kama jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Namba chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Namba ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ",
      "tr": "    Harmonik serinin 1/n'ye kadar olan toplamının verilen pozitif bir tamsayı k'dan büyük olması için\n    en küçük pozitif tamsayı n'yi hesaplayın.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\n    Döndürür:\n    - int: Harmonik seri toplamı S_n'nin eşik k'yı aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "vi": "    Tính số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    đến 1/n lớn hơn một số nguyên dương cho trước k.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    "
    },
    "docstring_bertscore": {
      "es": "0.983483287925806",
      "arb": "0.9748547841736503",
      "sw": "0.9641356956611027",
      "tr": "0.9972146061667477",
      "vi": "0.9614470348234144"
    }
  },
  {
    "task_id": "Python/30",
    "prompt": {
      "en": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "es": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y sí mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El entero a verificar para la primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Casos:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "arb": "def is_prime(num: int) -> bool:\n    \"\"\"\n    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    يعيدالحجج:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "sw": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Kuamua kama nambari iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari ya asili iliyo kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua kama ni ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum kwa nambari zilizo chini au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia uboreshaji wa 6k +/- 1 ili kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari ya kuangalia kama ni ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, uongo vinginevyo.\n\n    Kesi:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "tr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Verilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük olan ve 1 ve kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3'e bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tam sayı.\n\n    Döndürür:\n    bool: `num` asal bir sayı ise True, aksi takdirde False.\n\n    Durumlar:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "vi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\n    Một số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số phép thử. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.98665481921979",
      "arb": "0.9804827773898929",
      "sw": "0.9751376338362441",
      "tr": "0.9434161633545914",
      "vi": "0.9654712863431812"
    },
    "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "instruction": {
      "en": "Write a python function 'def is_prime(num: int) -> bool:' to solve the following problem:\n\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "es": "Escribe una función de Python 'def is_prime(num: int) -> bool:' para resolver el siguiente problema:\n\n    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y sí mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El entero a verificar para primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Casos:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "arb": "اكتب دالة بايثون 'def is_prime(num: int) -> bool:' لحل المشكلة التالية:\n\n    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    يعيدالحجج:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "sw": "Andika kazi ya python 'def is_prime(num: int) -> bool:' kutatua tatizo lifuatalo:\n\n    Tambua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari asilia kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua uhalisia wa nambari kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi za ukingo kwa nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia uboreshaji wa 6k +/- 1 kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari kamili ya kukagua uhalisia wa kuwa ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, Si kweli vinginevyo.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "tr": "Bir python fonksiyonu 'def is_prime(num: int) -> bool:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen bir tamsayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük ve kendisinden başka pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3 ile bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tamsayı.\n\n    Döndürür:\n    bool: `num` asal bir sayıysa True, aksi takdirde False.\n\n    Durumlar:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "vi": "Viết một hàm python 'def is_prime(num: int) -> bool:' để giải quyết vấn đề sau:\n\n    Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\n    Số nguyên tố là một số tự nhiên lớn hơn 1 mà không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số kiểm tra. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các yếu tố lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là một số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False"
    },
    "instruction_bertscore": {
      "es": "0.9854165574244185",
      "arb": "0.9828597871597374",
      "sw": "0.9860146335017146",
      "tr": "0.9413448457411596",
      "vi": "0.970189949675046"
    },
    "level": "easy",
    "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()",
    "entry_point": "is_prime",
    "signature": "def is_prime(num: int) -> bool:",
    "docstring": {
      "en": "\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "es": "    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y él mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El número entero a verificar para primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "arb": "    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و 3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و 3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    المتغيرات:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "sw": "    Kuamua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari asilia kubwa kuliko 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe. Kazi hii inakagua hali ya kuwa nambari ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum za nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia uboreshaji wa 6k +/- 1 kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari kamili ya kukagua hali ya kuwa nambari ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, Si kweli vinginevyo.\n\n    Mifano:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "tr": "    Verilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük ve kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3 ile bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tam sayı.\n\n    Döndürür:\n    bool: `num` bir asal sayı ise True, aksi takdirde False.\n\n    Durumlar:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "vi": "    Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\n    Số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số kiểm tra. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    "
    },
    "docstring_bertscore": {
      "es": "0.9866383328981642",
      "arb": "0.9745671673819118",
      "sw": "0.9705037856770812",
      "tr": "0.9293805433699042",
      "vi": "0.9609427122859668"
    }
  },
  {
    "task_id": "Python/31",
    "prompt": {
      "en": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "es": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Genera todos los números únicos a partir del número dado aplicando reglas de transformación.\n\n    Cada regla permite transformar un solo dígito en otro. Se utiliza una búsqueda en anchura\n    (BFS) para explorar todas las posibles transformaciones. La función devuelve la cantidad\n    de números únicos que se pueden generar a partir del número original, incluyendo el número mismo.\n\n    Argumentos:\n    - n (int): El número entero original a transformar.\n    - rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\n                              como una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\n    Devuelve:\n    - int: La cantidad total de números únicos que se pueden generar.\n\n    Casos:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "arb": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    كل قاعدة تسمح بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول\n    (BFS) لاستكشاف جميع التحويلات الممكنة. تقوم الدالة بإرجاع عدد\n    الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    Args:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    حالات:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "sw": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa kwanza kwa upana\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi hii inarejesha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya awali, ikiwa ni pamoja na namba yenyewe.\n\n    Hoja:\n    - n (int): Namba ya awali ya integer ya kubadilisha.\n    - rules (list of tuples): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarejesha:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Matukio:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "tr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Verilen sayıyı dönüşüm kurallarını uygulayarak tüm benzersiz sayıları oluşturun.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri\n    keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere\n    orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tam sayı.\n    - rules (list of tuples): Her kuralın (x, y) şeklinde bir demet olarak temsil edildiği dönüşüm kuralları listesi,\n                              burada x rakamı y'ye dönüştürülebilir.\n\n    Döner:\n    - int: Üretilebilecek benzersiz sayıların toplam sayısı.\n\n    Durumlar:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "vi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên gốc cần biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) chỉ ra rằng chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số lượng các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9879590263016651",
      "arb": "0.9604469308549037",
      "sw": "0.9687955644001811",
      "tr": "0.9489525879651768",
      "vi": "0.9703667307141671"
    },
    "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)",
    "instruction": {
      "en": "Write a python function 'def generate_numbers(n, rules) -> int:' to solve the following problem:\n\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ",
      "es": "Escribe una función de Python 'def generate_numbers(n, rules) -> int:' para resolver el siguiente problema:\n\n    Generar todos los números únicos a partir del número dado aplicando reglas de transformación.\n\n    Cada regla permite que un solo dígito se transforme en otro. Se utiliza una búsqueda en anchura\n    (BFS) para explorar todas las posibles transformaciones. La función devuelve la cantidad\n    de números únicos que se pueden generar a partir del número original, incluyendo el número en sí mismo.\n\n    Argumentos:\n    - n (int): El número entero original a transformar.\n    - rules (lista de tuplas): Una lista de reglas de transformación, donde cada regla se representa\n                               como una tupla (x, y) que indica que el dígito x puede transformarse en y.\n\n    Devuelve:\n    - int: El conteo total de números únicos que se pueden generar.\n\n    Casos:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "arb": "اكتب دالة بايثون 'def generate_numbers(n, rules) -> int:' لحل المشكلة التالية:\n\n    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    كل قاعدة تسمح بتحويل رقم واحد إلى آخر. يتم استخدام البحث بالعرض\n    (BFS) لاستكشاف جميع التحويلات الممكنة. تعيد الدالة عدد\n    الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    يعيدالحجج:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث تمثل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "sw": "Andika kazi ya python 'def generate_numbers(n, rules) -> int:' kutatua tatizo lifuatalo:\n\n    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa kina kwanza\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarudisha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya awali, ikijumuisha namba yenyewe.\n\n    Hoja:\n    - n (int): Namba ya awali ya integer ya kubadilisha.\n    - rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarudisha:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Mifano:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "tr": "Bir python fonksiyonu 'def generate_numbers(n, rules) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen sayıyı dönüştürme kurallarını uygulayarak tüm benzersiz sayıları oluşturun.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri\n    keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere\n    oluşturulabilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tamsayı.\n    - rules (list of tuples): Her kuralın, x rakamının y'ye dönüştürülebileceğini belirten\n                              bir (x, y) demeti olarak temsil edildiği dönüşüm kuralları listesi.\n\n    Döndürür:\n    - int: Oluşturulabilecek benzersiz sayıların toplam sayısı.\n\n    Durumlar:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "vi": "Viết một hàm python 'def generate_numbers(n, rules) -> int:' để giải quyết vấn đề sau:\n\n    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên gốc cần biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) cho biết chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9992211702759622",
      "arb": "0.9583027158916322",
      "sw": "0.9693630513987979",
      "tr": "0.952113393218585",
      "vi": "0.9635876744398274"
    },
    "level": "hard",
    "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()",
    "entry_point": "generate_numbers",
    "signature": "def generate_numbers(n, rules) -> int:",
    "docstring": {
      "en": "\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ",
      "es": "Generar todos los números únicos a partir del número dado aplicando reglas de transformación.\n\nCada regla permite transformar un solo dígito en otro. Se utiliza una búsqueda en anchura\n(BFS) para explorar todas las posibles transformaciones. La función devuelve el conteo\nde números únicos que se pueden generar a partir del número original, incluyendo el número en sí mismo.\n\nArgumentos:\n- n (int): El número entero original a transformar.\n- rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\n                          como una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\nDevuelve:\n- int: El conteo total de números únicos que se pueden generar.\n\nCases:\n>>> generate_numbers(234, [(2, 5), (3, 6)])\n4\n>>> generate_numbers(100, [(1, 9)])\n2",
      "arb": "    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    تسمح كل قاعدة بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول (BFS)\n    لاستكشاف جميع التحويلات الممكنة. تُرجع الدالة عدد الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    يعيدالحجج:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "sw": "    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa kina kwanza\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarejesha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya awali, ikijumuisha namba yenyewe.\n\n    Vipengele:\n    - n (int): Namba ya awali ya integer kubadilishwa.\n    - rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarejesha:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Matukio:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ",
      "tr": "    Verilen sayıdan dönüşüm kuralları uygulanarak tüm benzersiz sayıları üretin.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri\n    keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere\n    orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tamsayı.\n    - rules (list of tuples): Her kuralın (x, y) şeklinde bir demet olarak temsil edildiği,\n                              rakam x'in y'ye dönüştürülebileceğini belirten dönüşüm kuralları listesi.\n\n    Döndürür:\n    - int: Üretilebilecek benzersiz sayıların toplam sayısı.\n\n    Örnekler:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "vi": "    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên gốc để biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) chỉ ra rằng chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số lượng các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9926196895622676",
      "arb": "0.9601702387341221",
      "sw": "0.9641789970841682",
      "tr": "0.9586389971267242",
      "vi": "0.9480214087388853"
    }
  },
  {
    "task_id": "Python/32",
    "prompt": {
      "en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "es": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\n    Esta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\n    las declaraciones hechas por todos los participantes son consistentes con este escenario, sin tener en cuenta ninguna declaración\n    sobre el día de la semana.\n\n    Parámetros:\n    - scenario (str): El nombre del participante que se está probando como el posible criminal.\n    - liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n    - statements (dict): Un diccionario que asigna nombres de participantes a listas de sus respectivas declaraciones.\n    - days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\n    Retorna:\n    - bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\n    Casos de prueba:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "arb": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    يقيم اتساق السيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المقدمة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (السيناريو) ومجموعة من الكذابين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي تصريحات\n    حول يوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كذابون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    يعيد:\n    - bool: True إذا كان السيناريو متسقًا مع التصريحات، False خلاف ذلك.\n\n    حالات الاختبار:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "sw": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Inatathmini uthabiti wa tukio ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\n    Kazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua kama\n    kauli zilizotolewa na washiriki wote zinashabihiana na tukio hili, bila kujali kauli zozote\n    kuhusu siku ya juma.\n\n    Vigezo:\n    - scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n    - liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n    - statements (dict): Kamusi inayohusisha majina ya washiriki na orodha ya kauli zao husika.\n    - days_of_week (set): Seti ya mistari inayowakilisha siku za juma.\n\n    Inarudisha:\n    - bool: Kweli ikiwa tukio linashabihiana na kauli, La sivyo.\n\n    Mifano ya Majaribio:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "tr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Verilen ifadeler temelinde bir katılımcının suçlu olduğu bir senaryonun tutarlılığını değerlendirir.\n\n    Bu fonksiyon, potansiyel suçlunun adını (senaryo) ve yalancı olarak kabul edilen katılımcıların bir kümesini (liar_count) alır ve\n    tüm katılımcılar tarafından yapılan ifadelerin bu senaryo ile tutarlı olup olmadığını kontrol eder, haftanın günü hakkındaki ifadeleri dikkate almaz.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarını içeren bir küme.\n    - statements (dict): Katılımcı adlarını, onların ilgili ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerin bir kümesi.\n\n    Döndürür:\n    - bool: Senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "vi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một người bị nghi là tội phạm (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\n    các tuyên bố của tất cả người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được cho là nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Các trường hợp kiểm tra:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9871986692030635",
      "arb": "0.9785195147037441",
      "sw": "0.973777015726155",
      "tr": "0.9743842288009787",
      "vi": "0.9730917409115847"
    },
    "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True",
    "instruction": {
      "en": "Write a python function 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' to solve the following problem:\n\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ",
      "es": "Escribe una función en Python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' para resolver el siguiente problema:\n\n    Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\n    Esta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\n    las declaraciones hechas por todos los participantes son consistentes con este escenario, sin tener en cuenta ninguna declaración\n    sobre el día de la semana.\n\n    Parámetros:\n    - scenario (str): El nombre del participante que se está probando como el posible criminal.\n    - liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n    - statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n    - days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\n    Retorna:\n    - bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\n    Casos de prueba:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "arb": "اكتب دالة بايثون 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' لحل المشكلة التالية:\n\n    تقييم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المعطاة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي تصريحات\n    حول يوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    العوائد:\n    - bool: صحيح إذا كان السيناريو متسقًا مع التصريحات، خطأ خلاف ذلك.\n\n    حالات الاختبار:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "sw": "Andika kazi ya python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' kutatua tatizo lifuatalo:\n\n    Inatathmini uthabiti wa hali ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\n    Kazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua kama\n    kauli zilizotolewa na washiriki wote zinakubaliana na hali hii, bila kujali kauli zozote kuhusu siku ya wiki.\n\n    Vigezo:\n    - scenario (str): Jina la mshiriki anayejaribiwa kama mhalifu anayewezekana.\n    - liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n    - statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za kauli zao husika.\n    - days_of_week (set): Seti ya mistari inayowakilisha siku za wiki.\n\n    Inarudisha:\n    - bool: Kweli ikiwa hali inakubaliana na kauli, Vinginevyo uongo.\n\n    Mifano ya Majaribio:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "tr": "Bir python fonksiyonu 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen ifadelere dayanarak bir katılımcının suçlu olduğu bir senaryonun tutarlılığını değerlendirir.\n\n    Bu fonksiyon potansiyel suçlunun adını (scenario) ve yalancıların bir kümesini (liar_count) alır ve\n    tüm katılımcılar tarafından yapılan ifadelerin bu senaryoyla tutarlı olup olmadığını kontrol eder, haftanın günü hakkındaki\n    ifadeleri göz ardı eder.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarının bulunduğu bir küme.\n    - statements (dict): Katılımcı adlarını, onların ilgili ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerin bulunduğu bir küme.\n\n    Döndürür:\n    - bool: Eğer senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "vi": "Viết một hàm python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' để giải quyết vấn đề sau:\n\n    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một tội phạm tiềm năng (scenario) và một tập hợp những kẻ nói dối (liar_count) và kiểm tra xem\n    các tuyên bố được đưa ra bởi tất cả người tham gia có nhất quán với kịch bản này hay không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được giả định là kẻ nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Trường hợp kiểm tra:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True"
    },
    "instruction_bertscore": {
      "es": "0.9868935729377939",
      "arb": "0.9800952495164938",
      "sw": "0.9703464704153015",
      "tr": "0.9708319230665509",
      "vi": "0.9824269715594625"
    },
    "level": "hard",
    "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()",
    "entry_point": "check_scenario",
    "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:",
    "docstring": {
      "en": "\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ",
      "es": "Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\nEsta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si las declaraciones hechas por todos los participantes son consistentes con este escenario, ignorando cualquier declaración sobre el día de la semana.\n\nParámetros:\n- scenario (str): El nombre del participante que se está probando como el posible criminal.\n- liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n- statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n- days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\nDevuelve:\n- bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\nCasos de prueba:\n>>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\nTrue",
      "arb": "    يقيم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المقدمة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، مع تجاهل أي تصريحات\n    تتعلق بيوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    يعيد:\n    - bool: True إذا كان السيناريو متسقًا مع التصريحات، False خلاف ذلك.\n\n    حالات الاختبار:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "sw": "Hupima uthabiti wa hali ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\nKazi hii inachukua jina la mhalifu anayewezekana (hali) na seti ya waongo (liar_count) na inakagua kama kauli zilizotolewa na washiriki wote zinakubaliana na hali hii, bila kujali kauli zozote kuhusu siku ya wiki.\n\nVigezo:\n- scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n- liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n- statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za kauli zao husika.\n- days_of_week (set): Seti ya mistari inayowakilisha siku za wiki.\n\nInarejesha:\n- bool: Kweli ikiwa hali inakubaliana na kauli, Si kweli vinginevyo.\n\nMifano ya Majaribio:\n>>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\nTrue",
      "tr": "    Bir katılımcının suçlu olduğu bir senaryonun verilen ifadelere göre tutarlılığını değerlendirir.\n\n    Bu fonksiyon, potansiyel bir suçlunun adını (senaryo) ve bir dizi yalancıyı (liar_count) alır ve\n    tüm katılımcılar tarafından yapılan ifadelerin bu senaryo ile tutarlı olup olmadığını, haftanın günü hakkındaki\n    ifadeleri görmezden gelerek kontrol eder.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların isimlerinden oluşan bir küme.\n    - statements (dict): Katılımcı isimlerini, onların ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerden oluşan bir küme.\n\n    Döndürür:\n    - bool: Senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "vi": "    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một người có thể là tội phạm (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\n    các tuyên bố của tất cả các người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được giả định là người nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Các trường hợp kiểm tra:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True"
    },
    "docstring_bertscore": {
      "es": "0.9872989775454861",
      "arb": "0.9731205423168348",
      "sw": "0.9653892519958138",
      "tr": "0.9666531371103388",
      "vi": "0.970775909299099"
    }
  },
  {
    "task_id": "Python/33",
    "prompt": {
      "en": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "es": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calcula el puntaje de una serie de juegos de ping-pong basado en el sistema de puntuación proporcionado.\n\n    Esta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntuaciones de los juegos formateadas como \"player_score:opponent_score\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    la puntuación actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan la puntuación de cada juego.\n\n    Casos:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "arb": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    حساب النتيجة لسلسلة من مباريات كرة الطاولة بناءً على نظام النقاط المقدم.\n\n    تأخذ هذه الدالة نظام النقاط المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط \n    التي فاز بها اللاعب ('W') والمنافس ('L'). تقوم الدالة بمعالجة السلسلة وتعيد قائمة \n    بنتائج المباريات بصيغة \"player_score:opponent_score\".\n\n    تعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط \n    (11 أو 21) بفارق نقطتين على الأقل. إذا انتهى تسلسل النقاط في منتصف اللعبة، \n    يتم تضمين النتيجة الحالية لتلك اللعبة في المخرجات أيضًا.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز باللعبة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والمنافس.\n\n    يعيد:\n    - list: قائمة من السلاسل تمثل نتيجة كل لعبة.\n\n    حالات:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "sw": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Kuhesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba hiyo na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayotakiwa na mfumo \n    (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo, \n    alama za mchezo huo pia zinajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayoashiria pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "tr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ile rakibin ('L') \n    kazandığı puanların dizisini temsil eden bir dize alır. Fonksiyon diziyi işler ve oyun skorlarını \n    \"oyuncu_skoru:rakip_skoru\" formatında bir liste olarak döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun \n    bitmiş kabul edilir. Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut skoru da \n    çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakibin kazandığı puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden dizelerin bir listesi.\n\n    Durumlar:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "vi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho trình tự các điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số trận đấu được định dạng dưới dạng \"player_score:opponent_score\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị các điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.984662159237248",
      "arb": "0.9521040575906764",
      "sw": "0.9754764972662896",
      "tr": "0.9588006822568866",
      "vi": "0.9538464432931144"
    },
    "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores",
    "instruction": {
      "en": "Write a python function 'def calculate_score(system: int, points: str) -> list:' to solve the following problem:\n\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    ",
      "es": "Escribe una función de Python 'def calculate_score(system: int, points: str) -> list:' para resolver el siguiente problema:\n\n    Calcular la puntuación de una serie de juegos de ping-pong basados en el sistema de puntuación proporcionado.\n\n    Esta función recibe el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntuaciones de los juegos formateadas como \"player_score:opponent_score\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    la puntuación actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan la puntuación de cada juego.\n\n    Casos:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "arb": "اكتب دالة بايثون 'def calculate_score(system: int, points: str) -> list:' لحل المشكلة التالية:\n\n    حساب النتيجة لسلسلة من مباريات تنس الطاولة بناءً على نظام التسجيل المقدم.\n\n    تأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والمنافس ('L'). \n    تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بتنسيق \"player_score:opponent_score\".\n\n    تعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط في النظام \n    (11 أو 21) مع تقدم لا يقل عن نقطتين. إذا انتهى تسلسل النقاط في منتصف اللعبة، \n    يتم تضمين النتيجة الحالية لتلك اللعبة أيضًا في المخرجات.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز باللعبة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والمنافس.\n\n    يعيد:\n    - list: قائمة من السلاسل تمثل نتيجة كل لعبة.\n\n    حالات:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "sw": "Andika kazi ya python 'def calculate_score(system: int, points: str) -> list:' kutatua tatizo lifuatalo:\n\n    Hesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayohitajika na mfumo \n    (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo, \n    alama za mchezo huo pia zinajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayoashiria pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Matukio:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "tr": "Bir python fonksiyonu 'def calculate_score(system: int, points: str) -> list:' aşağıdaki problemi çözmek için yazın:\n\n    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ile rakibin ('L') \n    kazandığı puanların dizisini temsil eden bir dize alır. Fonksiyon diziyi işler ve \"oyuncu_skoru:rakip_skoru\" \n    formatında oyun skorlarının bir listesini döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun bitmiş sayılır. \n    Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut skoru da çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakibin kazandığı puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden dizelerin bir listesi.\n\n    Durumlar:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "vi": "Viết một hàm python 'def calculate_score(system: int, points: str) -> list:' để giải quyết vấn đề sau:\n\n    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số trận đấu được định dạng dưới dạng \"player_score:opponent_score\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong kết quả đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]"
    },
    "instruction_bertscore": {
      "es": "0.9827684171844614",
      "arb": "0.9636297840806068",
      "sw": "0.9746466195343259",
      "tr": "0.9602347936079585",
      "vi": "0.9545327112595899"
    },
    "level": "middle",
    "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()",
    "entry_point": "calculate_score",
    "signature": "def calculate_score(system: int, points: str) -> list:",
    "docstring": {
      "en": "\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    ",
      "es": "    Calcular la puntuación de una serie de juegos de ping-pong según el sistema de puntuación proporcionado.\n\n    Esta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntuaciones de juegos formateadas como \"puntuación_jugador:puntuación_oponente\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    la puntuación actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan la puntuación de cada juego.\n\n    Casos:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "arb": "    حساب نتيجة سلسلة من مباريات كرة الطاولة بناءً على نظام التسجيل المقدم.\n\n    تأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والخصم ('L'). \n    تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بتنسيق \"player_score:opponent_score\".\n\n    تعتبر المباراة منتهية عندما يصل أحد اللاعبين إلى عدد النقاط المطلوب من النظام \n    (11 أو 21) بفارق لا يقل عن نقطتين. إذا انتهى تسلسل النقاط في منتصف المباراة، \n    يتم تضمين النتيجة الحالية لتلك المباراة في الناتج أيضًا.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز بالمباراة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و'L' تمثل النقاط التي فاز بها اللاعب والخصم.\n\n    يعيد:\n    - list: قائمة من السلاسل النصية تمثل نتيجة كل مباراة.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "sw": "    Hesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mlolongo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayotakiwa \n    na mfumo (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mlolongo wa pointi unamalizika katikati ya mchezo, \n    alama ya sasa ya mchezo huo pia inajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayowakilisha pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "tr": "    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ve rakip ('L') tarafından kazanılan puanların dizisini temsil eden bir string alır. \n    Fonksiyon, stringi işler ve \"oyuncu_skoru:rakip_skoru\" formatında oyun skorlarının bir listesini döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun bitmiş sayılır. \n    Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut skoru da çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakip tarafından kazanılan puanları belirten 'W' ve 'L' karakterlerinden oluşan bir string.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden stringlerin bir listesi.\n\n    Durumlar:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "vi": "    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số trận đấu được định dạng dưới dạng \"điểm_người_chơi:điểm_đối_thủ\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]"
    },
    "docstring_bertscore": {
      "es": "0.9830844381206879",
      "arb": "0.9531238259669095",
      "sw": "0.9638254350059262",
      "tr": "0.9537079979175331",
      "vi": "0.9501809182414966"
    }
  },
  {
    "task_id": "Python/34",
    "prompt": {
      "en": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"",
      "es": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calcular el número de Catalan enésimo.\n\n    La función calcula el número de Catalan enésimo utilizando programación dinámica. Los números de Catalan son una secuencia \n    de números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de \n    caminos en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, \n    el número de diferentes maneras en que n+1 factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El número de Catalan enésimo.\n\n    Casos:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Nota:\n    El cálculo se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.\n    \"\"\"",
      "arb": "def catalan_number(n: int) -> int:\n    \"\"\"\n    حساب العدد النوني من أعداد كاتالان.\n\n    تقوم الدالة بحساب العدد النوني من أعداد كاتالان باستخدام البرمجة الديناميكية. أعداد كاتالان هي سلسلة من الأعداد الطبيعية \n    التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من المسارات الشبكية، \n    عدد التعبيرات التي تحتوي على n زوجًا من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن بها \n    تحويط n+1 عاملاً بشكل كامل، والمزيد.\n\n    يعيدالحجج:\n    - n (int): الموضع في سلسلة أعداد كاتالان للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد النوني من أعداد كاتالان.\n\n    حالات:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    ملاحظة:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث أن C(0) هو 1.\n    \"\"\"",
      "sw": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Kuhesabu nambari ya Catalan ya n.\n\n    Kazi hii inakokotoa nambari ya Catalan ya n kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    asilia ambazo zina matumizi mengi katika hesabu za mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    gridi, idadi ya maonyesho yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti \n    ambazo vipengele n+1 vinaweza kuwekwa mabano kikamilifu, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Hisabati inategemea kanuni ya kurudia:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.\n    \"\"\"",
      "tr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n. Katalan sayısını hesapla.\n\n    Fonksiyon, dinamik programlama kullanarak n. Katalan sayısını hesaplar. Katalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayıların bir dizisidir. Bunlar arasında belirli türdeki kafes yollarının sayılması, n çift parantez \n    içeren ifadelerin doğru şekilde eşleşmiş olması, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası bulunur.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Katalan sayısı dizisindeki konum (negatif olmamalıdır).\n\n    Dönüş:\n    - int: n. Katalan sayısı.\n\n    Durumlar:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanmaktadır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.\n    \"\"\"",
      "vi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng trong \n    toán học tổ hợp, bao gồm việc đếm số lượng các đường đi trong lưới nhất định, số lượng biểu thức chứa n cặp dấu ngoặc \n    được ghép đúng cách, số lượng cách khác nhau mà n+1 yếu tố có thể được ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9811901001767581",
      "arb": "0.966255677717888",
      "sw": "0.9604115746470795",
      "tr": "0.962537912876058",
      "vi": "0.9571647624386832"
    },
    "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]",
    "instruction": {
      "en": "Write a python function 'def catalan_number(n: int) -> int:' to solve the following problem:\n\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    ",
      "es": "Escribe una función de Python 'def catalan_number(n: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el enésimo número de Catalan.\n\n    La función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia de \n    números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de caminos \n    en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, el número \n    de diferentes maneras en que n+1 factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El enésimo número de Catalan.\n\n    Casos:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Nota:\n    El cálculo se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.",
      "arb": "اكتب دالة بايثون 'def catalan_number(n: int) -> int:' لحل المشكلة التالية:\n\n    حساب العدد الكاتالاني nth.\n\n    تقوم الدالة بحساب العدد الكاتالاني nth باستخدام البرمجة الديناميكية. الأعداد الكاتالانية هي سلسلة من الأعداد الطبيعية \n    التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من المسارات الشبكية، \n    عدد التعبيرات التي تحتوي على n زوج من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن بها \n    وضع n+1 عامل بين أقواس بشكل كامل، وأكثر.\n\n    يعيدالحجج:\n    - n (int): الموضع في سلسلة الأعداد الكاتالانية للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد الكاتالاني nth.\n\n    حالات:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    ملاحظة:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث أن C(0) هو 1.",
      "sw": "Andika kazi ya python 'def catalan_number(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu nambari ya Catalan ya nth.\n\n    Kazi inahesabu nambari ya Catalan ya nth kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    za asili ambazo zina matumizi mengi katika hisabati ya mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    lattice, idadi ya maneno yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti ambazo \n    n+1 vipengele vinaweza kuwekwa mabano kikamilifu, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya nth.\n\n    Kesi:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Kumbuka:\n    Hesabu inategemea fomula ya kurudi:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.",
      "tr": "Bir python fonksiyonu 'def catalan_number(n: int) -> int:' yazarak aşağıdaki problemi çözün:\n\n    n'inci Catalan sayısını hesaplayın.\n\n    Fonksiyon, dinamik programlama kullanarak n'inci Catalan sayısını hesaplar. Catalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayıların bir dizisidir. Bunlar arasında belirli türdeki kafes yollarının sayılması, n çift parantez içeren \n    ifadelerin doğru şekilde eşleşmiş olması, n+1 faktörünün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası bulunur.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Catalan sayısı dizisindeki pozisyon (negatif olmamalıdır).\n\n    Döndürür:\n    - int: n'inci Catalan sayısı.\n\n    Durumlar:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.",
      "vi": "Viết một hàm python 'def catalan_number(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n sử dụng lập trình động. Số Catalan là một dãy số tự nhiên có nhiều ứng dụng trong toán học tổ hợp, \n    bao gồm việc đếm số lượng các loại đường đi trên lưới, số lượng biểu thức chứa n cặp dấu ngoặc được ghép đúng, số lượng cách khác nhau mà n+1 \n    yếu tố có thể được ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1."
    },
    "instruction_bertscore": {
      "es": "0.9775950889104077",
      "arb": "0.9728692748848257",
      "sw": "0.982714985611963",
      "tr": "0.9683988995292545",
      "vi": "0.9612295345561812"
    },
    "level": "easy",
    "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()",
    "entry_point": "catalan_number",
    "signature": "def catalan_number(n: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    ",
      "es": "    Calcular el enésimo número de Catalan.\n\n    La función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia \n    de números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de \n    caminos en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, \n    el número de diferentes maneras en que n+1 factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El enésimo número de Catalan.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    La computación se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.",
      "arb": "    حساب العدد الكاتالاني nth.\n\n    تقوم الدالة بحساب العدد الكاتالاني nth باستخدام البرمجة الديناميكية. الأعداد الكاتالانية هي تسلسل من الأعداد الطبيعية التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من مسارات الشبكة، عدد التعبيرات التي تحتوي على n من الأزواج من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن فيها وضع الأقواس بالكامل لعوامل n+1، وأكثر من ذلك.\n\n    يعيدالحجج:\n    - n (int): الموضع في تسلسل الأعداد الكاتالانية للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد الكاتالاني nth.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث C(0) هو 1.",
      "sw": "    Hesabu nambari ya Catalan ya nth.\n\n    Kazi hii inahesabu nambari ya Catalan ya nth kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    za asili ambazo zina matumizi mengi katika hisabati ya mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    lattice, idadi ya maonyesho yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti \n    ambazo vipengele n+1 vinaweza kuwekwa mabano kabisa, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya nth.\n\n    Matukio:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Kumbuka:\n    Hesabu inategemea fomula ya kurudiarudia:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.",
      "tr": "    n. Katalan sayısını hesaplayın.\n\n    Fonksiyon, dinamik programlama kullanarak n. Katalan sayısını hesaplar. Katalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayı dizisidir; belirli türdeki kafes yollarının sayısı, n çift parantez içeren ve doğru eşleşen ifadelerin \n    sayısı, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası gibi.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Katalan sayısı dizisindeki konum (negatif olmamalıdır).\n\n    Döndürür:\n    - int: n. Katalan sayısı.\n\n    Örnekler:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.",
      "vi": "    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n bằng cách sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng \n    trong toán học tổ hợp, bao gồm việc đếm một số loại đường đi trên lưới, số biểu thức chứa n cặp dấu ngoặc được ghép đúng, \n    số cách khác nhau mà n+1 thừa số có thể được đặt dấu ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1."
    },
    "docstring_bertscore": {
      "es": "0.9811217713256821",
      "arb": "0.9737710568147241",
      "sw": "0.9737227896321325",
      "tr": "0.9631266533254454",
      "vi": "0.9625110977746183"
    }
  },
  {
    "task_id": "Python/35",
    "prompt": {
      "en": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "es": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calcular el número de manzanas que Tao Tao puede alcanzar.\n\n    Argumentos:\n    apple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\n    tao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\n    Devuelve:\n    int: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\n    Esta función itera sobre la lista de alturas de las manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\n    considerando un adicional de 30 cm que proporciona el taburete.\n\n    Casos de ejemplo:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> devuelve 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> devuelve 0\n    \"\"\"",
      "arb": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    حساب عدد التفاح الذي يمكن لـ تاو تاو الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لـ تاو تاو الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لـ تاو تاو الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بالتكرار على قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يقع ضمن مدى وصول تاو تاو،\n    مع الأخذ في الاعتبار 30 سم إضافية يوفرها الكرسي.\n\n    أمثلة الحالات:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0\n    \"\"\"",
      "sw": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Kuhesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\n    Hoja:\n    apple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\n    tao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ulionyoshwa juu (katika sentimita).\n\n    Inarejesha:\n    int: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha sentimita 30.\n\n    Kazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\n    ikizingatia sentimita 30 za ziada ambazo kigoda kinatoa.\n\n    Mifano ya kesi:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> inarejesha 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> inarejesha 0\n    \"\"\"",
      "tr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\n    Argümanlar:\n    apple_heights (List[int]): Elmaların yerden yüksekliği (santimetre cinsinden).\n    tao_reach (int): Tao Tao'nun elini yukarı doğru uzattığında ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\n    Döndürür:\n    int: Tao Tao'nun 30cm'lik bir tabureye çıkıp çıkmadan ulaşabileceği elma sayısı.\n\n    Bu fonksiyon, elma yükseklikleri listesini dolaşır ve taburenin sağladığı ek 30cm'yi dikkate alarak,\n    kaç tanesinin Tao Tao'nun erişim alanında olduğunu sayar.\n\n    Örnek durumlar:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür \n    \"\"\"",
      "vi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tính số lượng táo mà Tao Tao có thể với tới.\n\n    Tham số:\n    apple_heights (List[int]): Chiều cao của các quả táo từ mặt đất (tính bằng centimet).\n    tao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng centimet).\n\n    Trả về:\n    int: Số lượng táo mà Tao Tao có thể với tới có hoặc không đứng trên ghế đẩu cao 30cm.\n\n    Hàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả trong tầm với của Tao Tao,\n    xét thêm 30cm mà ghế đẩu cung cấp.\n\n    Ví dụ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9847084401160291",
      "arb": "0.9638953529000505",
      "sw": "0.9700459426487957",
      "tr": "0.9853273723833339",
      "vi": "0.968948509793578"
    },
    "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples",
    "instruction": {
      "en": "Write a python function 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' to solve the following problem:\n\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    ",
      "es": "Escribe una función de Python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el número de manzanas que Tao Tao puede alcanzar.\n\n    Argumentos:\n    apple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\n    tao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\n    Devuelve:\n    int: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\n    Esta función itera sobre la lista de alturas de las manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\n    considerando un adicional de 30 cm que proporciona el taburete.\n\n    Casos de ejemplo:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> devuelve 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> devuelve 0",
      "arb": "اكتب دالة بايثون 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' لحل المشكلة التالية:\n\n    احسب عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لـ Tao Tao الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يمكن الوصول إليه ضمن مدى Tao Tao،\n    مع الأخذ في الاعتبار 30 سم إضافية التي يوفرها الكرسي.\n\n    أمثلة الحالات:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0",
      "sw": "Andika kazi ya python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\n    Hoja:\n    apple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\n    tao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ukiwa umenyooka juu (katika sentimita).\n\n    Inarejesha:\n    int: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha sentimita 30.\n\n    Kazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\n    ikizingatia sentimita 30 za ziada ambazo kigoda kinatoa.\n\n    Mifano ya kesi:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> inarejesha 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> inarejesha 0",
      "tr": "Bir python fonksiyonu 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\n    Argümanlar:\n    apple_heights (List[int]): Elmaların yerden yüksekliği (santimetre cinsinden).\n    tao_reach (int): Tao Tao'nun elini yukarı doğru uzattığında ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\n    Döndürür:\n    int: Tao Tao'nun 30cm tabureye çıkmadan veya çıkmadan ulaşabileceği elma sayısı.\n\n    Bu fonksiyon, elma yükseklikleri listesini dolaşır ve taburenin sağladığı ek 30cm'yi dikkate alarak Tao Tao'nun erişebileceği kaç tanesini sayar.\n\n    Örnek durumlar:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür",
      "vi": "Viết một hàm python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính số lượng táo mà Tao Tao có thể với tới.\n\n    Tham số:\n    apple_heights (List[int]): Chiều cao của các quả táo tính từ mặt đất (tính bằng cm).\n    tao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng cm).\n\n    Trả về:\n    int: Số lượng táo mà Tao Tao có thể với tới, có hoặc không đứng trên ghế đẩu cao 30cm.\n\n    Hàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\n    bao gồm cả 30cm thêm mà ghế đẩu cung cấp.\n\n    Ví dụ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.9835831990074665",
      "arb": "0.9597441765668023",
      "sw": "0.974579482465536",
      "tr": "0.9735398510511994",
      "vi": "0.955938815726936"
    },
    "level": "easy",
    "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()",
    "entry_point": "count_apples_reachable",
    "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    ",
      "es": "Calcular el número de manzanas a las que Tao Tao puede alcanzar.\n\nArgumentos:\napple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\ntao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\nDevuelve:\nint: El número de manzanas a las que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\nEsta función itera sobre la lista de alturas de las manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\nconsiderando un adicional de 30 cm que proporciona el taburete.\n\nCasos de ejemplo:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> devuelve 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> devuelve 0",
      "arb": "    حساب عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لـ Tao Tao الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يمكن الوصول إليه من قبل Tao Tao،\n    مع الأخذ في الاعتبار 30 سم إضافية التي يوفرها الكرسي.\n\n    أمثلة الحالات:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0",
      "sw": "Hesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\nHoja:\napple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\ntao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa kunyoosha mkono wake juu (katika sentimita).\n\nInarejesha:\nint: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha sentimita 30.\n\nKazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\nikizingatia ongezeko la sentimita 30 ambalo kigoda kinatoa.\n\nMifano ya kesi:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> inarudisha 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> inarudisha 0",
      "tr": "Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\nArgümanlar:\napple_heights (List[int]): Yerden elmalara olan yükseklikler (santimetre cinsinden).\ntao_reach (int): Tao Tao'nun elini yukarı doğru uzattığında ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\nDöndürür:\nint: Tao Tao'nun 30cm'lik bir tabureye çıkıp çıkmamasına bakılmaksızın ulaşabileceği elma sayısı.\n\nBu fonksiyon, elma yükseklikleri listesini dolaşır ve bunlardan kaç tanesinin Tao Tao'nun ulaşabileceği mesafede olduğunu,\ntaburenin sağladığı ek 30cm'yi dikkate alarak sayar.\n\nÖrnek durumlar:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür",
      "vi": "Tính số lượng táo mà Tao Tao có thể với tới.\n\nTham số:\napple_heights (List[int]): Chiều cao của những quả táo tính từ mặt đất (tính bằng centimet).\ntao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng centimet).\n\nTrả về:\nint: Số lượng táo mà Tao Tao có thể với tới dù có hoặc không đứng trên ghế đẩu cao 30cm.\n\nHàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\nxét thêm 30cm mà ghế đẩu cung cấp.\n\nVí dụ trường hợp:\n   count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n   count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9817383200284144",
      "arb": "0.9569760635767001",
      "sw": "0.9549687049459615",
      "tr": "0.9596986902095453",
      "vi": "0.953405483847217"
    }
  },
  {
    "task_id": "Python/36",
    "prompt": {
      "en": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\n    La carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\n    Cada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\n    el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\n    Argumentos:\n    - l (int): La longitud de la carretera.\n    - areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n    \n    Devuelve:\n    - int: El número total de árboles restantes a lo largo de la carretera después de que se hayan despejado las áreas especificadas.\n    \n    Ejemplos:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20.\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    اكتب دالة بايثون 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يُمثل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    كل منطقة مجدولة للإزالة تُحدد كزوج من الأعداد الصحيحة (بداية، نهاية)، والتي تمثل\n    النطاق الشامل على طول الطريق حيث ستتم إزالة الأشجار.\n\n    الوسائط:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    أمثلة:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ستعيد 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ستعيد 20.\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kuhesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\n    Barabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti.\n    Kila eneo lililopangwa kusafishwa limeainishwa kama jozi ya nambari (kuanzia, mwisho), inayowakilisha\n    safu jumuishi kando ya barabara ambapo miti itaondolewa.\n\n    Hoja:\n    - l (int): Urefu wa barabara.\n    - areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n    \n    Inarejesha:\n    - int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n    \n    Mifano:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20.\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli alanlar temizlendikten sonra bir yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, ağaçların kaldırılacağı yol boyunca kapsayıcı aralığı temsil eden\n    iki tam sayı (başlangıç, bitiş) çifti olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir demetin yoldaki temizlenmiş bir alanı temsil ettiği demetlerin listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir.\n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir.\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán số lượng cây còn lại dọc theo con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bởi cây cối.\n    Mỗi khu vực được lên lịch dọn dẹp được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện\n    cho phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các cặp số nguyên mà mỗi cặp đại diện cho một khu vực đã được dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9911720713452854",
      "arb": "0.9583595241806081",
      "sw": "0.962919680468407",
      "tr": "0.9687804684912225",
      "vi": "0.9725598087511733"
    },
    "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees",
    "instruction": {
      "en": "Write a python function 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    ",
      "es": "Escribe una función de Python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' para resolver el siguiente problema:\n\n    Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\n    La carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\n    Cada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\n    el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\n    Argumentos:\n    - l (int): La longitud de la carretera.\n    - areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n    \n    Devuelve:\n    - int: El número total de árboles restantes a lo largo de la carretera después de que se hayan despejado las áreas especificadas.\n    \n    Ejemplos:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20.",
      "arb": "اكتب دالة بايثون 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يُمثل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    كل منطقة مجدولة للإزالة تُحدد كزوج من الأعداد الصحيحة (بداية، نهاية)، والتي تمثل\n    النطاق الشامل على طول الطريق حيث ستتم إزالة الأشجار.\n\n    الوسائط:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    أمثلة:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ستعيد 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ستعيد 20.",
      "sw": "Andika kazi ya python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\n    Barabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti.\n    Kila eneo lililopangwa kusafishwa limeainishwa kama jozi ya nambari (mwanzo, mwisho), inayowakilisha\n    safu jumuishi kando ya barabara ambapo miti itaondolewa.\n\n    Hoja:\n    - l (int): Urefu wa barabara.\n    - areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n    \n    Inarejesha:\n    - int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n    \n    Mifano:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20.",
      "tr": "Bir python fonksiyonu 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Belirli alanlar temizlendikten sonra yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\n    bir çift tamsayı (başlangıç, bitiş) olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir demetin yoldaki temizlenmiş bir alanı temsil ettiği demetlerin bir listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir.\n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir.",
      "vi": "Viết một hàm python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính số lượng cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bởi cây cối.\n    Mỗi khu vực dự kiến dọn dẹp được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện cho\n    phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ đại diện cho một khu vực đã được dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20."
    },
    "instruction_bertscore": {
      "es": "0.9958998716746779",
      "arb": "0.9625363238330097",
      "sw": "0.9748700787129901",
      "tr": "0.9854741602349186",
      "vi": "0.9745840509642999"
    },
    "level": "easy",
    "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()",
    "entry_point": "remaining_trees_after_clearing",
    "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    ",
      "es": "Calcula el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\nLa carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles. Cada área programada para despeje se especifica como un par de enteros (inicio, fin), que representa el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\nArgumentos:\n- l (int): La longitud de la carretera.\n- areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n\nDevuelve:\n- int: El número total de árboles restantes a lo largo de la carretera después de que las áreas especificadas hayan sido despejadas.\n\nEjemplos:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5\n- remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20.",
      "arb": "    حساب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يتم تمثيل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    يتم تحديد كل منطقة مبرمجة للإزالة كزوج من الأعداد الصحيحة (start, end)، والتي تمثل\n    النطاق الشامل على طول الطريق حيث سيتم إزالة الأشجار.\n\n    يعيدالحجج:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تم إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    امثله:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) سيعيد 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) سيعيد 20.",
      "sw": "Hesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nBarabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti. \nKila eneo lililopangwa kusafishwa limetajwa kama jozi ya nambari mbili (mwanzo, mwisho), inayowakilisha \neneo la pamoja kando ya barabara ambapo miti itaondolewa.\n\nHoja:\n- l (int): Urefu wa barabara.\n- areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n\nInarejesha:\n- int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nMifano:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5    \n- remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20.",
      "tr": "    Belirli alanlar temizlendikten sonra bir yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\n    bir çift tam sayı (başlangıç, bitiş) olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir çiftin yoldaki temizlenmiş bir alanı temsil ettiği bir demet listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir.    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir.",
      "vi": "    Tính số cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được phủ đầy cây.\n    Mỗi khu vực dự kiến dọn dẹp được chỉ định dưới dạng một cặp số nguyên (start, end), đại diện\n    cho phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các bộ giá trị mà mỗi bộ đại diện cho một khu vực đã dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20."
    },
    "docstring_bertscore": {
      "es": "0.9945215754606768",
      "arb": "0.959309573293098",
      "sw": "0.9473164695165924",
      "tr": "0.9668015140049719",
      "vi": "0.9771038759781084"
    }
  },
  {
    "task_id": "Python/37",
    "prompt": {
      "en": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "es": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociado.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "arb": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة على الأكثر وله تكلفة زمنية وقيمة مرتبطة به.\n\n    يعيدالحجج:\n    - T (int): الوقت الإجمالي المتاح لجمع الأعشاب.\n    - M (int): عدد الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    امثله:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "sw": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya muda uliowekwa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea iliyochumwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuchumwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa ajili ya kuchuma mimea.\n    - M (int): Idadi ya mimea tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili\n      zinazowakilisha muda unaohitajika kuchuma mmea na thamani ya mmea, mtawalia.\n\n    Inarejesha:\n    - int: Thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "tr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan\n    0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve\n    her birinin ilişkili bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her biri otu toplamak için gereken zamanı ve otun değerini\n      temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "vi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán giá trị tổng tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán ba lô 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    tối đa một lần và có chi phí thời gian và giá trị liên quan.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên\n      đại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Giá trị tổng tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9837989116012704",
      "arb": "0.9709781150269925",
      "sw": "0.9537250801303021",
      "tr": "0.9589011892296903",
      "vi": "0.9650817721659718"
    },
    "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]",
    "instruction": {
      "en": "Write a python function 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    ",
      "es": "Escribe una función en Python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' para resolver el siguiente problema:\n\n    Calcula el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociados.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "arb": "اكتب دالة بايثون 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' لحل المشكلة التالية:\n\n    احسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة على الأكثر وله تكلفة زمنية وقيمة مرتبطة به.\n\n    المعاملات:\n    - T (int): الوقت الإجمالي المتاح لجمع الأعشاب.\n    - M (int): عدد الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    أمثلة:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "sw": "Andika kazi ya python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu thamani ya juu kabisa ya jumla ya mimea ambayo inaweza kuchukuliwa ndani ya kikomo cha muda kilichopewa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea iliyochukuliwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuchukuliwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa ajili ya kuchukua mimea.\n    - M (int): Idadi ya mimea tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili za mzima\n      zinazowakilisha muda unaohitajika kuchukua mmea na thamani ya mmea, mtawalia.\n\n    Inarudisha:\n    - int: Thamani ya juu kabisa ya jumla ya mimea inayoweza kuchukuliwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "tr": "Bir Python fonksiyonu 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan\n    0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve\n    her birinin bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her bir demetin ot toplamak için gereken zamanı ve otun değerini\n      temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "vi": "Viết một hàm python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán cái túi 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    nhiều nhất một lần và có chi phí thời gian và giá trị tương ứng.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên\n      đại diện cho thời gian cần để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10"
    },
    "instruction_bertscore": {
      "es": "0.9826077252062042",
      "arb": "0.9615864733509009",
      "sw": "0.9575648040260876",
      "tr": "0.9525535581429583",
      "vi": "0.9653455533119861"
    },
    "level": "easy",
    "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()",
    "entry_point": "max_herb_value",
    "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    ",
      "es": "    Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociados.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "arb": "    حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة على الأكثر وله تكلفة زمنية وقيمة مرتبطة به.\n\n    يعيدالحجج:\n    - T (int): إجمالي الوقت المتاح لجمع الأعشاب.\n    - M (int): عدد الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    امثله:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "sw": "    Kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kuvunwa ndani ya kikomo cha muda kilichopewa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea iliyovunwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuvunwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa kuvuna mimea.\n    - M (int): Idadi ya mimea tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili\n      zinazowakilisha muda unaohitajika kuvuna mmea na thamani ya mmea, mtawalia.\n\n    Inarejesha:\n    - int: Thamani ya juu kabisa ya mimea ambayo inaweza kuvunwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "tr": "    Belirli bir zaman sınırı içinde toplanabilecek maksimum toplam ot değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini en üst düzeye çıkarmayı\n    amaçlayan 0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez\n    toplanabilir ve buna bağlı bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her bir demetin, otu toplamak için gereken zamanı ve\n      otun değerini temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "vi": "    Tính tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán cái túi 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    nhiều nhất một lần và có chi phí thời gian và giá trị liên quan.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên\n      đại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Tổng giá trị tối đa của các loại thảo mộc có thể hái trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10"
    },
    "docstring_bertscore": {
      "es": "0.9819343682144959",
      "arb": "0.961182856416638",
      "sw": "0.9490435606796909",
      "tr": "0.9578911537421279",
      "vi": "0.9574299339973649"
    }
  },
  {
    "task_id": "Python/38",
    "prompt": {
      "en": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "es": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que se puede ocupar\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "arb": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    حساب الحد الأدنى للمساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحجم الأقصى الذي يمكن شغله في الصندوق بواسطة أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الإجمالية للصندوق وهذا الحجم المشغول الأقصى، وهو الحد الأدنى للمساحة المتبقية.\n\n    يعيدالحجج:\n    - V (int): السعة الإجمالية للصندوق.\n    - n (int): عدد العناصر التي يجب أخذها بعين الاعتبار لوضعها في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى للمساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    امثله:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "sw": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Kuhesabu nafasi ndogo inayobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyopewa. Kisha inarejesha tofauti kati ya uwezo wa jumla wa sanduku\n    na huu ujazo wa juu uliotumika, ambayo ndiyo nafasi ndogo inayobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarejesha:\n    - int: Nafasi ndogo inayobaki kwenye sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "tr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Verilen hacimlere sahip bir dizi öğeyi sığdırmaya çalıştıktan sonra bir kutuda kalan minimum alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da kalan minimum alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutuda paketlemeyi düşünmek için öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin bir listesi.\n\n    Döndürür:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "vi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng đặt một số lượng đồ vật với các thể tích cho trước.\n\n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể được chiếm trong hộp\n    bởi bất kỳ tập hợp con nào của các đồ vật cho trước. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp\n    và thể tích chiếm tối đa này, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để đóng gói vào hộp.\n    - volumes (List[int]): Danh sách thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi đặt các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9951202474291159",
      "arb": "0.9747205100360709",
      "sw": "0.9704336691525759",
      "tr": "0.9785506996735666",
      "vi": "0.9669657813300877"
    },
    "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]",
    "instruction": {
      "en": "Write a python function 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' to solve the following problem:\n\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    ",
      "es": "Escribe una función de Python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' para resolver el siguiente problema:\n\n    Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "arb": "اكتب دالة بايثون 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' لحل المشكلة التالية:\n\n    احسب الحد الأدنى للمساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن شغله\n    في الصندوق بواسطة أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الكلية للصندوق\n    وهذا الحجم المشغول الأقصى، وهو الحد الأدنى للمساحة المتبقية.\n\n    الوسائط:\n    - V (int): السعة الكلية للصندوق.\n    - n (int): عدد العناصر المراد النظر فيها للتعبئة في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى للمساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    أمثلة:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "sw": "Andika kazi ya python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu nafasi ndogo zaidi iliyobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyotolewa. Kisha inarudisha tofauti kati ya uwezo wa jumla wa sanduku\n    na ujazo huu wa juu ulioshikiliwa, ambayo ni nafasi ndogo zaidi iliyobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarudisha:\n    - int: Nafasi ndogo zaidi iliyobaki kwenye sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "tr": "Bir python fonksiyonu 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    Verilen hacimlere sahip bir dizi öğeyi kutuya sığdırmaya çalıştıktan sonra kutuda kalan minimum alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımını kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da minimum kalan alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutuda paketlenmesi düşünülen öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin bir listesi.\n\n    Döndürür:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "vi": "Viết một hàm python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng xếp một số lượng đồ vật với các thể tích đã cho.\n    \n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể chiếm trong hộp bởi bất kỳ tập hợp con nào của các đồ vật đã cho. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp và thể tích tối đa đã chiếm, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để xếp vào hộp.\n    - volumes (List[int]): Một danh sách các thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi xếp các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5"
    },
    "instruction_bertscore": {
      "es": "0.9954301108235303",
      "arb": "0.9802483935402717",
      "sw": "0.9581263321132731",
      "tr": "0.9699506000658991",
      "vi": "0.9711991906410843"
    },
    "level": "easy",
    "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()",
    "entry_point": "min_remaining_space",
    "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:",
    "docstring": {
      "en": "\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    ",
      "es": "    Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "arb": "    حساب الحد الأدنى من المساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n    \n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن أن يشغله أي مجموعة فرعية من العناصر المعطاة في الصندوق. ثم تعيد الفرق بين السعة الإجمالية للصندوق وهذا الحجم المشغول الأقصى، وهو الحد الأدنى من المساحة المتبقية.\n\n    يعيدالحجج:\n    - V (int): السعة الإجمالية للصندوق.\n    - n (int): عدد العناصر التي يجب أخذها بعين الاعتبار لوضعها في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى من المساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    امثله:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "sw": "    Kuhesabu nafasi ndogo iliyobaki katika sanduku baada ya kujaribu kutoshea idadi ya vitu vyenye ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyotolewa. Kisha inarudisha tofauti kati ya uwezo wa jumla wa sanduku\n    na ujazo huu wa juu uliotumika, ambayo ni nafasi ndogo iliyobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarejesha:\n    - int: Nafasi ndogo iliyobaki katika sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "tr": "    Bir kutuya verilen hacimlere sahip bir dizi öğeyi sığdırmaya çalıştıktan sonra kalan minimum boş alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda kaplanabilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum dolu hacim arasındaki farkı döndürür, bu da minimum kalan alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutunun içine yerleştirilmesi düşünülen öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin listesi.\n\n    Döndürülenler:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum boş alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "vi": "    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng xếp một số lượng đồ vật với thể tích cho trước.\n    \n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể chiếm trong hộp bởi bất kỳ tập hợp con nào của các đồ vật cho trước. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp và thể tích tối đa đã chiếm này, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để xếp vào hộp.\n    - volumes (List[int]): Một danh sách thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi xếp các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5"
    },
    "docstring_bertscore": {
      "es": "0.9947988634726015",
      "arb": "0.9648461965340644",
      "sw": "0.9709852657207098",
      "tr": "0.948635176616283",
      "vi": "0.963704469103876"
    }
  },
  {
    "task_id": "Python/39",
    "prompt": {
      "en": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"",
      "es": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calcula el número de formas de organizar m macetas de flores utilizando hasta n tipos,\n    donde el tipo i puede tener como máximo a[i] macetas, y la disposición debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a organizar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\n    Devuelve:\n    - int: El número de disposiciones distintas módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.\n    \"\"\"",
      "arb": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    حساب عدد الطرق لترتيب m من الأواني الزهرية باستخدام ما يصل إلى n نوعًا،\n    حيث يمكن أن يحتوي النوع i على ما لا يزيد عن a[i] من الأواني، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الزهور.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الزهور المتاحة.\n    - m (int): العدد الإجمالي للأواني الزهرية لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهرة i.\n\n    يعيد:\n    - int: عدد الترتيبات المميزة مودولو (10^6 + 7).\n\n    امثله:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.\n    \"\"\"",
      "sw": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kupanga sufuria m za maua kwa kutumia hadi aina n,\n    ambapo aina ya i inaweza kuwa na sufuria a[i] kwa kiwango cha juu, na mpangilio lazima uwe\n    katika mpangilio wa kuongezeka wa aina za maua.\n\n    Hoja:\n    - n (int): Idadi ya aina za maua zinazopatikana.\n    - m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n    - a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya i ya maua.\n\n    Inarejesha:\n    - int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\n    Mifano:\n    - calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.\n    \"\"\"",
      "tr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    En fazla n türü kullanarak m çiçek saksısını düzenlemenin yollarını hesaplayın,\n    burada i'inci tür en fazla a[i] saksıya sahip olabilir ve düzenleme çiçek türlerinin\n    artan sırasına göre olmalıdır.\n\n    Argümanlar:\n    - n (int): Mevcut çiçek türlerinin sayısı.\n    - m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n    - a (list of int): a[i] i'inci çiçek türü için maksimum saksı sayısını belirten bir liste.\n\n    Döndürür:\n    - int: Farklı düzenlemelerin sayısı, (10^6 + 7) modunda.\n\n    Örnekler:\n    - calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.\n    \"\"\"",
      "vi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\n    trong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\n    thứ tự tăng dần của các loại hoa.\n\n    Tham số:\n    - n (int): Số loại hoa có sẵn.\n    - m (int): Tổng số chậu hoa cần sắp xếp.\n    - a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\n    Trả về:\n    - int: Số cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\n    Ví dụ:\n    - calculate_arrangements(2, 4, [3, 2]) trả về 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9634222153324253",
      "arb": "0.9286038985800578",
      "sw": "0.9582312089544596",
      "tr": "0.934947557059169",
      "vi": "0.9462919340112145"
    },
    "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]",
    "instruction": {
      "en": "Write a python function 'def calculate_arrangements(n, m, a) -> int:' to solve the following problem:\n\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    ",
      "es": "Escribe una función de Python 'def calculate_arrangements(n, m, a) -> int:' para resolver el siguiente problema:\n\n    Calcula el número de formas de arreglar m macetas de flores usando hasta n tipos,\n    donde el tipo i puede tener como máximo a[i] macetas, y el arreglo debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a arreglar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\n    Devuelve:\n    - int: El número de arreglos distintos módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.",
      "arb": "اكتب دالة بايثون 'def calculate_arrangements(n, m, a) -> int:' لحل المشكلة التالية:\n\n    احسب عدد الطرق لترتيب m من أواني الزهور باستخدام ما يصل إلى n أنواع،\n    حيث يمكن أن يحتوي النوع i على ما لا يزيد عن a[i] من الأواني، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الزهور.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الزهور المتاحة.\n    - m (int): العدد الإجمالي لأواني الزهور لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهور i.\n\n    يعيد:\n    - int: عدد الترتيبات المميزة موديولو (10^6 + 7).\n\n    امثله:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.",
      "sw": "Andika kazi ya python 'def calculate_arrangements(n, m, a) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ya njia za kupanga sufuria m za maua kwa kutumia hadi aina n,\n    ambapo aina ya ith inaweza kuwa na sufuria a[i] kwa zaidi, na mpangilio lazima uwe katika\n    mpangilio wa kuongezeka wa aina za maua.\n\n    Hoja:\n    - n (int): Idadi ya aina za maua zinazopatikana.\n    - m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n    - a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya ith ya maua.\n\n    Inarejesha:\n    - int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\n    Mifano:\n    - calculate_arrangements(2, 4, [3, 2]) inarejesha 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) inarejesha 6.",
      "tr": "Bir python fonksiyonu 'def calculate_arrangements(n, m, a) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    m çiçek saksısını, n türüne kadar kullanarak düzenlemenin yollarını hesaplayın,\n    burada i. tür en fazla a[i] saksıya sahip olabilir ve düzenleme\n    çiçek türlerinin artan sırasına göre olmalıdır.\n\n    Argümanlar:\n    - n (int): Mevcut çiçek türü sayısı.\n    - m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n    - a (list of int): a[i], i. tür çiçek için maksimum saksı sayısını belirten bir liste.\n\n    Döndürür:\n    - int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\n    Örnekler:\n    - calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.",
      "vi": "Viết một hàm python 'def calculate_arrangements(n, m, a) -> int:' để giải quyết vấn đề sau:\n\n    Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\n    trong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\n    thứ tự tăng dần của các loại hoa.\n\n    Tham số:\n    - n (int): Số loại hoa có sẵn.\n    - m (int): Tổng số chậu hoa cần sắp xếp.\n    - a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\n    Trả về:\n    - int: Số cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\n    Ví dụ:\n    - calculate_arrangements(2, 4, [3, 2]) trả về 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) trả về 6."
    },
    "instruction_bertscore": {
      "es": "0.9657849237148354",
      "arb": "0.9528381954789813",
      "sw": "0.9732409123277419",
      "tr": "0.9449152268402617",
      "vi": "0.9413714622122182"
    },
    "level": "easy",
    "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()",
    "entry_point": "calculate_arrangements",
    "signature": "def calculate_arrangements(n, m, a) -> int:",
    "docstring": {
      "en": "\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    ",
      "es": "    Calcular el número de formas de organizar m macetas de flores usando hasta n tipos,\n    donde el tipo i puede tener como máximo a[i] macetas, y la disposición debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a organizar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\n    Devuelve:\n    - int: El número de disposiciones distintas módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.",
      "arb": "    حساب عدد الطرق لترتيب m من الأواني الزهرية باستخدام ما يصل إلى n من الأنواع،\n    حيث يمكن أن يحتوي النوع i على a[i] من الأواني كحد أقصى، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الزهور.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الزهور المتاحة.\n    - m (int): العدد الإجمالي للأواني الزهرية لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو العدد الأقصى من الأواني لنوع الزهرة i.\n\n    يعيد:\n    - int: عدد الترتيبات المختلفة موديولو (10^6 + 7).\n\n    امثله:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.",
      "sw": "Hesabu idadi ya njia za kupanga sufuria m za maua kwa kutumia hadi aina n, ambapo aina ya ith inaweza kuwa na sufuria a[i] kwa zaidi, na mpangilio lazima uwe kwa mpangilio wa aina za maua unaoongezeka.\n\nHoja:\n- n (int): Idadi ya aina za maua zinazopatikana.\n- m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n- a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya ith ya maua.\n\nInarejesha:\n- int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\nMifano:\n- calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\n- calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.",
      "tr": "Çiçek türlerinin artan sırasına göre düzenlemenin gerektiği durumda, en fazla n türü kullanarak m çiçek saksısını düzenlemenin yollarının sayısını hesaplayın. Burada i'inci tür en fazla a[i] saksıya sahip olabilir.\n\nArgümanlar:\n- n (int): Mevcut çiçek türlerinin sayısı.\n- m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n- a (list of int): a[i], i'inci çiçek türü için maksimum saksı sayısını belirten bir listedir.\n\nDöndürür:\n- int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\nÖrnekler:\n- calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.",
      "vi": "Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\ntrong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\nthứ tự tăng dần của các loại hoa.\n\nTham số:\n- n (int): Số lượng loại hoa có sẵn.\n- m (int): Tổng số chậu hoa cần sắp xếp.\n- a (list of int): Danh sách mà a[i] là số lượng chậu tối đa cho loại hoa thứ i.\n\nTrả về:\n- int: Số lượng cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\nVí dụ:\n- calculate_arrangements(2, 4, [3, 2]) trả về 2.\n- calculate_arrangements(3, 3, [1, 2, 3]) trả về 6."
    },
    "docstring_bertscore": {
      "es": "0.9565732411639614",
      "arb": "0.9257771896275502",
      "sw": "0.9640729284606956",
      "tr": "0.9116551654271128",
      "vi": "0.9505291172994508"
    }
  },
  {
    "task_id": "Python/40",
    "prompt": {
      "en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "es": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con el cifrado de Vigenère utilizando la clave proporcionada.\n    \n    El cifrado de Vigenère es un método de cifrado de texto alfabético mediante el uso de una serie de\n    cifrados César basados en las letras de una palabra clave. Esta función revierte el proceso\n    para recuperar el texto original a partir del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto original.\n                   Esta clave debe consistir solo en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir solo en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "arb": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    يفك تشفير النص المشفر باستخدام شفرة فيجنير باستخدام المفتاح المقدم.\n    \n    شفرة فيجنير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): المفتاح المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح فقط من حروف أبجدية.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك تشفير.\n                          يجب أن يتكون النص المشفر فقط من حروف أبجدية.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره والذي يتوافق مع النص المشفر المدخل.\n\n    امثله:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "sw": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Inafungua maandishi ya siri yaliyofichwa kwa kutumia Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kuficha maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno la ufunguo. Kazi hii inarudisha mchakato\n    ili kurejesha maandishi asilia kutoka kwa maandishi ya siri.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji ulio tumika kuficha maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi ya siri yanayohitaji kufunguliwa.\n                          Maandishi ya siri yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi ya siri yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "tr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Sağlanan anahtarı kullanarak Vigenère şifreleme yöntemiyle şifrelenmiş bir şifreli metni çözer.\n    \n    Vigenère şifreleme, alfabetik metni bir anahtar kelimenin harflerine dayanan bir dizi Caesar şifresi kullanarak şifreleme yöntemidir.\n    Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için işlemi tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "vi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Giải mã một văn bản mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n    \n    Mật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt\n    các mật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\n    để khôi phục văn bản gốc từ văn bản mã hóa.\n\n    Tham số:\n        key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n                   Khóa này chỉ nên bao gồm các ký tự chữ cái.\n        ciphertext (str): Văn bản mã hóa cần được giải mã.\n                          Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\n    Trả về:\n        str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\n    Ví dụ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9726021170223337",
      "arb": "0.9637132088406415",
      "sw": "0.9688305233472433",
      "tr": "0.9898907067572293",
      "vi": "0.9597012724044988"
    },
    "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)",
    "instruction": {
      "en": "Write a python function 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' to solve the following problem:\n\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    ",
      "es": "Escribe una función de Python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' para resolver el siguiente problema:\n\n    Descifra un texto cifrado con el cifrado Vigenère utilizando la clave proporcionada.\n    \n    El cifrado Vigenère es un método de cifrado de texto alfabético que utiliza una serie de\n    cifrados César basados en las letras de una palabra clave. Esta función invierte el proceso\n    para recuperar el texto plano original del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto plano original.\n                   Esta clave debe consistir solo en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir solo en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto plano descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "arb": "اكتب دالة بايثون 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' لحل المشكلة التالية:\n\n    يفك تشفير النص المشفر باستخدام شفرة فيجينير باستخدام المفتاح المقدم.\n    \n    شفرة فيجينير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح فقط من حروف أبجدية.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك التشفير.\n                          يجب أن يتكون النص المشفر فقط من حروف أبجدية.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره الذي يتوافق مع النص المشفر المدخل.\n\n    أمثلة:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "sw": "Andika kazi ya python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' kutatua tatizo lifuatalo:\n\n    Kufungua maandishi yaliyofichwa kwa kutumia Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kuficha maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno la ufunguo. Kazi hii inarudisha mchakato\n    ili kupata maandishi asilia kutoka kwa maandishi yaliyofichwa.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji uliotumika kuficha maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi yaliyofichwa yanayohitaji kufunguliwa.\n                          Maandishi yaliyofichwa yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi yaliyofichwa yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "tr": "Bir python fonksiyonu 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' yazın ve aşağıdaki problemi çözün:\n\n    Sağlanan anahtarı kullanarak Vigenère şifreleme yöntemiyle şifrelenmiş bir şifreli metni çözmek.\n    \n    Vigenère şifresi, bir anahtar kelimenin harflerine dayanan bir dizi Sezar şifresi kullanarak alfabetik metni şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için süreci tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "vi": "Viết một hàm python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' để giải quyết vấn đề sau:\n\n    Giải mã một văn bản mã hóa được mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n    \n    Mật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt\n    mã hóa Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\n    để khôi phục văn bản gốc từ văn bản mã hóa.\n\n    Tham số:\n        key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n                   Khóa này chỉ nên bao gồm các ký tự chữ cái.\n        ciphertext (str): Văn bản mã hóa cần được giải mã.\n                          Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\n    Trả về:\n        str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\n    Ví dụ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'"
    },
    "instruction_bertscore": {
      "es": "0.982328450890469",
      "arb": "0.972449966150461",
      "sw": "0.9577870714224656",
      "tr": "0.9838795555359705",
      "vi": "0.9674603709788646"
    },
    "level": "hard",
    "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()",
    "entry_point": "vigenere_decrypt",
    "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:",
    "docstring": {
      "en": "\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    ",
      "es": "    Descifra un texto cifrado con el cifrado de Vigenère utilizando la clave proporcionada.\n    \n    El cifrado de Vigenère es un método de cifrado de texto alfabético mediante el uso de una serie de\n    cifrados de César basados en las letras de una palabra clave. Esta función revierte el proceso\n    para recuperar el texto original a partir del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto original.\n                   Esta clave debe consistir solo en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir solo en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "arb": "    يفك تشفير النص المشفر باستخدام شفرة فيجينير باستخدام المفتاح المقدم.\n    \n    شفرة فيجينير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح من حروف أبجدية فقط.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك تشفيره.\n                          يجب أن يتكون النص المشفر من حروف أبجدية فقط.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره والمطابق للنص المشفر المدخل.\n\n    امثله:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "sw": "    Inafungua maandishi yaliyofichwa kwa kutumia Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kuficha maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno kuu. Kazi hii inarudisha mchakato\n    ili kurejesha maandishi asilia kutoka kwenye maandishi yaliyofichwa.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji ulio tumika kuficha maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi yaliyofichwa ambayo yanahitaji kufunguliwa.\n                          Maandishi yaliyofichwa yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi yaliyofichwa yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "tr": "    Sağlanan anahtarı kullanarak Vigenère şifresiyle şifrelenmiş bir şifreli metni çözer.\n\n    Vigenère şifresi, bir anahtar kelimenin harflerine dayalı bir dizi Sezar şifresi kullanarak alfabetik metni şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için süreci tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "vi": "Giải mã một văn bản mã hóa được mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n\nMật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một chuỗi các mật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình để khôi phục văn bản gốc từ văn bản mã hóa.\n\nTham số:\n    key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n               Khóa này chỉ nên bao gồm các ký tự chữ cái.\n    ciphertext (str): Văn bản mã hóa cần được giải mã.\n                      Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\nTrả về:\n    str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\nVí dụ:\n    >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n    'Wherethereisawillthereisaway'\n\n    >>> vigenere_decrypt(\"ABC\", \"DEF\")\n    'DCB'"
    },
    "docstring_bertscore": {
      "es": "0.9634156605298512",
      "arb": "0.9515077691868097",
      "sw": "0.9437049719286161",
      "tr": "0.9919016407348266",
      "vi": "0.9554807740682695"
    }
  },
  {
    "task_id": "Python/41",
    "prompt": {
      "en": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "es": "def mod_inverse(a, b):\n    \"\"\"\n    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "arb": "def mod_inverse(a, b):\n    \"\"\"\n    حساب المعكوس الضربي المعياري لـ `a` بالنسبة لـ `b`.\n    \n    هذه الدالة تجد عدداً صحيحاً `x` بحيث يكون (a * x) % b == 1، بشرط أن يكون\n    `a` و `b` أوليين فيما بينهما (أي أن gcd(a, b) == 1). تستخدم خوارزمية\n    إقليدس الموسعة لحساب المعكوس. إذا لم يكن `a` و `b` أوليين فيما بينهما، فإن\n    المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يراد إيجاد معكوسه المعياري.\n      b (int): المودولوس الذي يُبحث بالنسبة له عن المعكوس.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة لـ `b` إذا كان موجوداً، وإلا `None`.\n    \n    امثله:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "sw": "def mod_inverse(a, b):\n    \"\"\"\n    Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata namba nzima `x` kama kwamba (a * x) % b == 1, mradi\n    `a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\n    Iliyoenea ili kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha moduli\n    hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Namba nzima ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarejesha:\n      int: Kinyume cha moduli cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "tr": "def mod_inverse(a, b):\n    \"\"\"\n    `a` sayısının `b` modülüne göre modüler çarpımsal tersini hesapla.\n    \n    Bu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, \n    `a` ve `b` aralarında asal olduğunda (yani, gcd(a, b) == 1). \n    Tersi hesaplamak için Genişletilmiş Öklid Algoritması'nı kullanır. \n    Eğer `a` ve `b` aralarında asal değilse, modüler ters yoktur ve \n    fonksiyon `None` döner.\n    \n    Argümanlar:\n      a (int): Modüler tersi bulunacak tamsayı.\n      b (int): Tersinin arandığı modül.\n    \n    Döndürür:\n      int: `a` sayısının `b` modülüne göre modüler tersi varsa, aksi takdirde `None`.\n    \n    Örnekler:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "vi": "def mod_inverse(a, b):\n    \"\"\"\n    Tính nghịch đảo nhân modulo của `a` modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải\n    là nguyên tố cùng nhau, nghịch đảo modulo không tồn tại, và hàm trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên cần tìm nghịch đảo modulo.\n      b (int): Modulus mà nghịch đảo được tìm kiếm.\n    \n    Trả về:\n      int: Nghịch đảo modulo của `a` modulo `b` nếu tồn tại, ngược lại `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9989367315703203",
      "arb": "0.9784821721921095",
      "sw": "0.9826228211151629",
      "tr": "0.9725419320168801",
      "vi": "0.986301853032691"
    },
    "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b",
    "instruction": {
      "en": "Write a python function 'def mod_inverse(a, b):' to solve the following problem:\n\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    ",
      "es": "Escribe una función de Python 'def mod_inverse(a, b):' para resolver el siguiente problema:\n\n    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "arb": "اكتب دالة بايثون 'def mod_inverse(a, b):' لحل المشكلة التالية:\n\n    حساب المعكوس الضربي المعياري لـ `a` بالنسبة إلى `b`.\n    \n    هذه الدالة تجد عددًا صحيحًا `x` بحيث يكون (a * x) % b == 1، بشرط أن\n    `a` و `b` هما عددان أوليان فيما بينهما (أي أن gcd(a, b) == 1). تستخدم\n    خوارزمية إقليدس الموسعة لحساب المعكوس. إذا لم يكن `a` و `b` أوليان فيما بينهما،\n    فإن المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يراد إيجاد معكوسه المعياري.\n      b (int): الموديلوس الذي يُبحث بالنسبة له عن المعكوس.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة إلى `b` إذا كان موجودًا، وإلا `None`.\n    \n    أمثلة:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "sw": "Andika kazi ya python 'def mod_inverse(a, b):' kutatua tatizo lifuatalo:\n\n    Hesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata nambari kamili `x` kama (a * x) % b == 1, mradi tu\n    `a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\n    Iliyopanuliwa kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha moduli hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Nambari kamili ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarejesha:\n      int: Kinyume cha moduli cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "tr": "Bir python fonksiyonu 'def mod_inverse(a, b):' yazın ve aşağıdaki problemi çözün:\n\n    `a` sayısının `b` modülüne göre modular çarpımsal tersini hesaplayın.\n    \n    Bu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, bu koşul\n    `a` ve `b` aralarında asal olduğunda sağlanır (yani, gcd(a, b) == 1). Tersi\n    hesaplamak için Genişletilmiş Öklid Algoritmasını kullanır. Eğer `a` ve `b`\n    aralarında asal değilse, modular ters mevcut değildir ve fonksiyon `None`\n    döndürür.\n    \n    Argümanlar:\n      a (int): Modular tersi bulunacak tamsayı.\n      b (int): Tersinin arandığı modül.\n    \n    Dönüş:\n      int: Eğer mevcutsa `a`'nın `b` modülüne göre modular tersi, aksi takdirde `None`.\n    \n    Örnekler:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "vi": "Viết một hàm python 'def mod_inverse(a, b):' để giải quyết vấn đề sau:\n\n    Tính nghịch đảo nhân modulo của `a` modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải là\n    nguyên tố cùng nhau, nghịch đảo modulo không tồn tại, và hàm trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên mà nghịch đảo modulo cần tìm.\n      b (int): Modulus mà nghịch đảo được tìm kiếm.\n    \n    Trả về:\n      int: Nghịch đảo modulo của `a` modulo `b` nếu tồn tại, nếu không thì `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None"
    },
    "instruction_bertscore": {
      "es": "0.9992237524709157",
      "arb": "0.9746394688406086",
      "sw": "0.9935294167074075",
      "tr": "0.9504343706076971",
      "vi": "0.9864402984082723"
    },
    "level": "easy",
    "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()",
    "entry_point": "mod_inverse",
    "signature": "def mod_inverse(a, b):",
    "docstring": {
      "en": "\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    ",
      "es": "    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "arb": "    حساب المعكوس الضربي المعياري لـ `a` بالنسبة إلى `b`.\n    \n    هذه الدالة تجد عددًا صحيحًا `x` بحيث أن (a * x) % b == 1، بشرط أن\n    `a` و `b` هما عددان أوليان فيما بينهما (أي، gcd(a, b) == 1). تستخدم\n    خوارزمية إقليدس الموسعة لحساب المعكوس. إذا لم يكن `a` و `b` عددان أوليان فيما بينهما، فإن\n    المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يُراد إيجاد معكوسه المعياري.\n      b (int): المقياس الذي يُراد إيجاد المعكوس بالنسبة له.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة إلى `b` إذا كان موجودًا، وإلا `None`.\n    \n    امثله:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "sw": "    Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata nambari nzima `x` kama kwamba (a * x) % b == 1, mradi\n    `a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\n    Iliyoenea ili kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha moduli\n    hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Nambari nzima ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarudisha:\n      int: Kinyume cha moduli cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "tr": "`a` sayısının `b` modülüne göre modüler çarpımsal tersini hesaplayın.\n\nBu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, bu koşul `a` ve `b` aralarında asal olduğunda (yani, gcd(a, b) == 1) sağlanır. Tersi hesaplamak için Genişletilmiş Öklid Algoritmasını kullanır. Eğer `a` ve `b` aralarında asal değilse, modüler ters mevcut değildir ve fonksiyon `None` döndürür.\n\nArgümanlar:\n  a (int): Modüler tersi bulunacak tamsayı.\n  b (int): Tersinin aranacağı modül.\n\nDöndürür:\n  int: Eğer mevcutsa `a` sayısının `b` modülüne göre modüler tersi, aksi takdirde `None`.\n\nÖrnekler:\n  >>> mod_inverse(3, 10)\n  7\n\n  >>> mod_inverse(42, 2017)\n  None",
      "vi": "    Tính nghịch đảo nhân theo modulo của `a` theo modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải là\n    nguyên tố cùng nhau, nghịch đảo theo modulo không tồn tại, và hàm trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên cần tìm nghịch đảo theo modulo.\n      b (int): Modulo theo đó nghịch đảo được tìm kiếm.\n    \n    Trả về:\n      int: Nghịch đảo theo modulo của `a` theo modulo `b` nếu tồn tại, ngược lại `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9636530238351879",
      "sw": "0.9854348314194737",
      "tr": "0.9592458129407858",
      "vi": "0.9733932618299956"
    }
  },
  {
    "task_id": "Python/42",
    "prompt": {
      "en": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "es": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calcula el día de la semana en que Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día.\n    La función encuentra el día en que su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de \n    máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la \n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el \n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana en que Jinjin está más infeliz (1-7 para lunes a domingo) o 0 \n             si nunca está infeliz.\n    \n    Casos:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "arb": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    حساب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها.\n    \n    جينجين تكون تعيسة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها في أقصى حد، وهو اليوم الذي تكون فيه الساعات\n    الإجمالية أبعد ما يكون عن العتبة. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع\n    اليوم الأسبق. إذا لم تكن جينجين تعيسة في أي يوم، تقوم الدالة بإرجاع 0.\n    \n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة من 7 مجموعات، حيث تمثل كل مجموعة عدد الساعات\n                                           التي تقضيها في المدرسة والدروس الإضافية لكل يوم من أيام\n                                           الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن تعيسة أبدًا.\n    \n    حالات:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "sw": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n    \n    Jinjin ana huzuni ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku.\n    Kazi hii inatafuta siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa\n    ni zaidi ya kiwango cha juu zaidi. Ikiwa kuna siku nyingi zenye kiwango sawa cha huzuni kubwa zaidi,\n    siku ya mapema zaidi inarejeshwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarejesha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya masaa yaliyotumika shuleni na katika madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hana huzuni kamwe.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "tr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesaplayın.\n    \n    Jinjin, bir günde okulda ve ek derslerde geçirilen toplam saatler 8 saati aştığında mutsuz olur.\n    Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur, bu da toplam saatlerin eşik değerin en fazla\n    üzerinde olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, en\n    erken gün döndürülür. Jinjin hiçbir gün mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir demetin haftanın her günü için okulda ve ek derslerde\n                                           geçirilen saat sayısını temsil ettiği 7 demetlik bir liste.\n                                           \n    Döndürür:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi'den Pazar'a 1-7) veya hiç mutsuz değilse 0.\n    \n    Örnekler:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "vi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm này tìm ngày mà sự không vui của cô ấy là lớn nhất, tức là ngày mà tổng số giờ vượt quá ngưỡng\n    nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về.\n    Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ đại diện cho số giờ\n                                           ở trường và lớp học thêm cho mỗi ngày trong tuần, tương ứng.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Trường hợp:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9837309800109565",
      "arb": "0.9703021758403307",
      "sw": "0.9664110066758573",
      "tr": "0.9665210479069506",
      "vi": "0.9650758132545408"
    },
    "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day",
    "instruction": {
      "en": "Write a python function 'def find_most_unhappy_day(schedule) -> int:' to solve the following problem:\n\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    ",
      "es": "Escribe una función en Python 'def find_most_unhappy_day(schedule) -> int:' para resolver el siguiente problema:\n\n    Calcula el día de la semana en que Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede las 8 horas en un día. \n    La función encuentra el día en que su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de \n    máxima infelicidad, se devuelve el día más temprano. Si Jinjin no está infeliz en ningún día, la \n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el \n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana en que Jinjin está más infeliz (1-7 para lunes a domingo) o 0 \n             si nunca está infeliz.\n    \n    Casos:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "arb": "اكتب دالة بايثون 'def find_most_unhappy_day(schedule) -> int:' لحل المشكلة التالية:\n\n    احسب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها الزمني.\n    \n    تكون جينجين غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تبحث الدالة عن اليوم الذي تكون فيه تعاستها هي الأكبر، وهو اليوم الذي يكون فيه إجمالي\n    الساعات هو الأبعد عن الحد الأدنى. إذا كان هناك عدة أيام بنفس مستوى\n    التعاسة القصوى، يتم إرجاع اليوم الأسبق. إذا لم تكن جينجين غير سعيدة في أي يوم،\n    تعيد الدالة 0.\n    \n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة من 7 مجموعات، حيث تمثل كل مجموعة\n                                           عدد الساعات التي تقضيها في المدرسة وفي الدروس الإضافية\n                                           لكل يوم من أيام الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن غير سعيدة أبدًا.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "sw": "Andika kazi ya python 'def find_most_unhappy_day(schedule) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n    \n    Jinjin ana huzuni ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku. \n    Kazi inapata siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa ni zaidi ya kiwango\n    cha juu. Ikiwa kuna siku nyingi zenye kiwango sawa cha huzuni ya juu, siku ya mapema zaidi inarudishwa. Ikiwa \n    Jinjin hana huzuni siku yoyote, kazi inarudisha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya masaa yaliyotumika shuleni na katika madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hajawahi kuwa na huzuni.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "tr": "Bir python fonksiyonu 'def find_most_unhappy_day(schedule) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesaplayın.\n    \n    Jinjin, bir gün içinde okulda ve ek derslerde geçirilen toplam saatler 8 saati aşıyorsa mutsuz olur. \n    Fonksiyon, mutsuzluğun en fazla olduğu günü bulur; bu, toplam saatlerin eşik değerin en fazla \n    üzerinde olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, en \n    erken gün döndürülür. Jinjin herhangi bir günde mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir gün için okulda ve ek derslerde geçirilen saat \n                                           sayısını temsil eden 7 demetlik bir liste.\n                                           \n    Döndürür:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi'den Pazar'a 1-7) veya hiç mutsuz \n             değilse 0.\n    \n    Durumlar:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "vi": "Viết một hàm python 'def find_most_unhappy_day(schedule) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm tìm ngày mà sự không vui của cô ấy là lớn nhất, đó là ngày khi tổng số giờ vượt quá ngưỡng nhiều nhất. \n    Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về. \n    Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ giá trị đại diện cho\n                                           số giờ ở trường và lớp học thêm cho mỗi ngày trong tuần, tương ứng.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Trường hợp:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0"
    },
    "instruction_bertscore": {
      "es": "0.9855472562151395",
      "arb": "0.9797516189573034",
      "sw": "0.9701714770496098",
      "tr": "0.9549323555862321",
      "vi": "0.9694591885032187"
    },
    "level": "easy",
    "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()",
    "entry_point": "find_most_unhappy_day",
    "signature": "def find_most_unhappy_day(schedule) -> int:",
    "docstring": {
      "en": "\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    ",
      "es": "    Calcular el día de la semana cuando Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día.\n    La función encuentra el día cuando su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de\n    máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la\n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el \n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana cuando Jinjin está más infeliz (1-7 para lunes a domingo) o 0 \n             si nunca está infeliz.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "arb": "    حساب اليوم الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها الزمني.\n    \n    تكون جينجين غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها في أقصى حد، وهو اليوم الذي يكون فيه إجمالي\n    الساعات أبعد ما يكون عن العتبة. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع اليوم\n    الأسبق. إذا لم تكن جينجين غير سعيدة في أي يوم، تقوم الدالة بإرجاع 0.\n    \n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة تحتوي على 7 مجموعات، حيث تمثل كل مجموعة\n                                           عدد الساعات التي تقضيها في المدرسة والدروس الإضافية\n                                           لكل يوم من أيام الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن غير سعيدة أبداً.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "sw": "    Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n    \n    Jinjin ana huzuni ikiwa jumla ya saa zilizotumika shuleni na madarasa ya ziada inazidi saa 8 kwa siku. \n    Kazi hii inapata siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya saa ni zaidi \n    ya kiwango cha juu zaidi. Ikiwa kuna siku nyingi zilizo na kiwango sawa cha huzuni ya juu zaidi, siku \n    ya mapema zaidi inarejeshwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarejesha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya saa zilizotumika shuleni na katika madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hana huzuni kamwe.\n    \n    Mifano:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "tr": "    Jinjin'in programına göre en mutsuz olduğu günü hesaplayın.\n    \n    Jinjin, okulda ve ek derslerde geçirilen toplam saatlerin bir günde 8 saati aşması durumunda mutsuz olur.\n    Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur, bu da toplam saatlerin eşik değerin en fazla üzerinde\n    olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, en erken gün döndürülür.\n    Jinjin herhangi bir günde mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir gün için sırasıyla okulda ve ek derslerde geçirilen\n                                           saatleri temsil eden 7 demetlik bir liste.\n                                           \n    Döndürür:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi için 1, Pazar için 7) veya hiç mutsuz\n             değilse 0.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "vi": "    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm này tìm ra ngày mà sự không vui của cô ấy là lớn nhất, đó là ngày mà tổng số giờ vượt quá\n    ngưỡng nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ\n    được trả về. Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm sẽ trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ đại diện cho\n                                           số giờ ở trường và lớp học thêm cho mỗi ngày trong tuần.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Ví dụ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9834161508570162",
      "arb": "0.9615727678546095",
      "sw": "0.9570936527622728",
      "tr": "0.9532487644765805",
      "vi": "0.9582115445467371"
    }
  },
  {
    "task_id": "Python/43",
    "prompt": {
      "en": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "es": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es más pequeño que el número que lo sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última \n    permutación (en orden descendente), la función devuelve False, indicando que no es posible una \n    siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada exitosamente, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "arb": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    يحول ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله مع أصغر رقم يكون أكبر ويأتي بعده. ثم تعكس \n    ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير \n    (بترتيب تنازلي)، تعيد الدالة False، مما يشير إلى أنه لا يوجد ترتيب تالي ممكن.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب الأخير.\n    \n    أمثلة:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "sw": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Hubadilisha mpangilio wa kuingiza kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi hii inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na kuibadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa ingizo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba za mzima zinazowakilisha mpangilio wa sasa.\n    \n    Inarejesha:\n    bool: True ikiwa mpangilio umebadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "tr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Girdi permütasyonunu sözlük sırasındaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve bunu, kendisinden sonra gelen ve daha büyük olan en küçük sayı ile değiştirir. Ardından, \n    orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi son permütasyon \n    ise (azalan sırada), fonksiyon False döndürerek bir sonraki permütasyonun mümkün olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "vi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n    \n    Hàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất \n    lớn hơn và đến sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. \n    Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có \n    hoán vị tiếp theo nào khả thi.\n    \n    Tham số:\n    perm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n    \n    Trả về:\n    bool: True nếu hoán vị được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n    \n    Ví dụ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9873033474138689",
      "arb": "0.9934877043273902",
      "sw": "0.9446337675903352",
      "tr": "0.9831891163314933",
      "vi": "0.974351057527346"
    },
    "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True",
    "instruction": {
      "en": "Write a python function 'def next_permutation(perm: list) -> bool:' to solve the following problem:\n\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    ",
      "es": "Escribe una función de Python 'def next_permutation(perm: list) -> bool:' para resolver el siguiente problema:\n\n    Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es más pequeño que el número que le sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última permutación \n    (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada con éxito, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "arb": "اكتب دالة بايثون 'def next_permutation(perm: list) -> bool:' لحل المشكلة التالية:\n\n    تحول التبديل المدخل إلى التبديل التالي بترتيب معجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله مع أصغر رقم يكون أكبر ويأتي بعده. ثم تعكس \n    ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان المدخل هو التبديل الأخير \n    (بترتيب تنازلي)، تعيد الدالة False، مشيرة إلى أنه لا يوجد تبديل تالي ممكن.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل التبديل الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل التبديل بنجاح، False إذا كان التبديل الأخير.\n    \n    أمثلة:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "sw": "Andika kazi ya python 'def next_permutation(perm: list) -> bool:' kutatua tatizo lifuatalo:\n\n    Inabadilisha mpangilio wa pembejeo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na inabadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa pembejeo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha kuwa hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba za integer zinazowakilisha mpangilio wa sasa.\n    \n    Inarejesha:\n    bool: True ikiwa mpangilio ulibadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "tr": "Bir python fonksiyonu 'def next_permutation(perm: list) -> bool:' yazarak aşağıdaki problemi çözün:\n\n    Girdi olarak verilen permütasyonu, sözlük sırasındaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve bunu, kendisinden sonra gelen ve daha büyük olan en küçük sayı ile değiştirir. Ardından, \n    orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Girdi, son permütasyon \n    ise (azalan sıradaysa), fonksiyon False döndürür, bu da bir sonraki permütasyonun mümkün olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "vi": "Viết một hàm python 'def next_permutation(perm: list) -> bool:' để giải quyết vấn đề sau:\n\n    Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n    \n    Hàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có hoán vị tiếp theo nào khả thi.\n    \n    Tham số:\n    perm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n    \n    Trả về:\n    bool: True nếu hoán vị đã được chuyển đổi thành công, False nếu nó là hoán vị cuối cùng.\n    \n    Ví dụ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]"
    },
    "instruction_bertscore": {
      "es": "0.9863042365972634",
      "arb": "0.9932880807944501",
      "sw": "0.9762672448131895",
      "tr": "0.9751700105883527",
      "vi": "0.9675370423059441"
    },
    "level": "middle",
    "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()",
    "entry_point": "next_permutation",
    "signature": "def next_permutation(perm: list) -> bool:",
    "docstring": {
      "en": "\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    ",
      "es": "    Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es menor que el número que le sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última \n    permutación (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada exitosamente, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "arb": "    يحول ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله بأصغر رقم يكون أكبر ويأتي بعده. ثم تعكس ترتيب \n    الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير \n    (بترتيب تنازلي)، فإن الدالة تُرجع False، مما يشير إلى عدم إمكانية وجود ترتيب تالي.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب هو الأخير.\n    \n    امثله:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "sw": "    Hubadilisha mpangilio wa ingizo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi hii inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na kuibadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa ingizo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba nzima inayowakilisha mpangilio wa sasa.\n    \n    Inarudisha:\n    bool: True ikiwa mpangilio ulibadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "tr": "    Girdi permütasyonunu sözlükbilimsel sıradaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve onu, kendisinden sonra gelen daha büyük olan en küçük sayıyla değiştirir. Ardından, \n    orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi son permütasyon \n    ise (azalan sırada), fonksiyon False döndürür, bu da başka bir sonraki permütasyonun mümkün \n    olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "vi": "Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n\nHàm tìm số đầu tiên từ cuối nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có hoán vị tiếp theo nào khả thi.\n\nTham số:\nperm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n\nTrả về:\nbool: True nếu hoán vị đã được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n\nVí dụ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]"
    },
    "docstring_bertscore": {
      "es": "0.9827173691765354",
      "arb": "0.9928818816652337",
      "sw": "0.9322892866697791",
      "tr": "0.9842933026196662",
      "vi": "0.9648167992376713"
    }
  },
  {
    "task_id": "Python/44",
    "prompt": {
      "en": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "es": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcula la cantidad total de dinero que Jinjin tendrá al final del año\n    después de seguir su plan de ahorros con su madre. Cada mes, puede ahorrar\n    múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener\n    al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20%\n    de interés al final del año.\n\n    Parámetros:\n    budgets (List[int]): Una lista de 12 enteros que representa el presupuesto mensual de Jinjin.\n\n    Devuelve:\n    int: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses.\n         Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de\n         ese mes (-X, donde X es el número del mes).\n\n    Ejemplos:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "arb": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير الخاصة بها مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشهري (300 شهريًا) إذا توقعت أن يكون لديها\n    على الأقل 100 وحدة متبقية بعد النفقات. الأموال المدخرة ستحصل على فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعلمات:\n    budgets (List[int]): قائمة تحتوي على 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\n\n    العوائد:\n    int: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفدت أموال جينجين في أي شهر معين، يتم إرجاع القيمة السلبية\n         لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "sw": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Inakokotoa jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kuwa\n    na angalau vitengo 100 vilivyobaki baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Vigezo:\n    budgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\n    Inarudisha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "tr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Jinjin'in annesiyle yaptığı tasarruf planını takip ettikten sonra yıl sonunda\n    ne kadar parası olacağını hesaplar. Her ay, masraflardan sonra en az 100 birim\n    kalacağını öngörürse, cep harçlığından (ayda 300) 100'ün katları kadar tasarruf\n    edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\n    Döndürür:\n    int: Faizden sonra yıl sonunda Jinjin'in sahip olacağı toplam para miktarı.\n         Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değeri döndürülür (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "vi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Tính tổng số tiền mà Jinjin sẽ có vào cuối năm\n    sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm\n    bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại\n    ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được lãi 20%\n    vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi có lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của\n         tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9955397547938616",
      "arb": "0.9727103705799978",
      "sw": "0.9794121596361148",
      "tr": "0.9676141108937856",
      "vi": "0.98042080471101"
    },
    "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money",
    "instruction": {
      "en": "Write a python function 'def jinjin_savings_plan(budgets: List[int]) -> int:' to solve the following problem:\n\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    ",
      "es": "Escribe una función de Python 'def jinjin_savings_plan(budgets: List[int]) -> int:' para resolver el siguiente problema:\n\nCalcula la cantidad total de dinero que Jinjin tendrá al final del año después de seguir su plan de ahorros con su madre. Cada mes, ella puede ahorrar múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un interés del 20% al final del año.\n\nParámetros:\nbudgets (List[int]): Una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n\nDevuelve:\nint: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses. Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de ese mes (-X, donde X es el número del mes).\n\nEjemplos:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580",
      "arb": "اكتب دالة بايثون 'def jinjin_savings_plan(budgets: List[int]) -> int:' لحل المشكلة التالية:\n\n    تحسب المبلغ الإجمالي من المال الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير الخاصة بها مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشهري (300 شهريًا) إذا توقعت بقاء\n    على الأقل 100 وحدة بعد النفقات. المال المدخر سيحصل على فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعاملات:\n    budgets (List[int]): قائمة مكونة من 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\n\n    يعيد:\n    int: المبلغ الإجمالي من المال الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفد المال من جينجين في أي شهر معين، يعيد القيمة السالبة لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "sw": "Andika kazi ya python 'def jinjin_savings_plan(budgets: List[int]) -> int:' kutatua tatizo lifuatalo:\n\n    Inahesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kuwa\n    na angalau vitengo 100 vilivyobaki baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Vigezo:\n    budgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\n    Inarudisha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "tr": "Bir python fonksiyonu 'def jinjin_savings_plan(budgets: List[int]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Jinjin'in annesiyle birlikte takip ettiği tasarruf planı sonucunda yıl sonunda\n    ne kadar parası olacağını hesaplar. Her ay, harcamalardan sonra en az 100 birim\n    kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları kadar\n    tasarruf edebilir. Tasarruf edilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tamsayıdan oluşan bir liste.\n\n    Döndürülenler:\n    int: Jinjin'in yıl sonunda faizle birlikte sahip olacağı toplam para miktarı.\n         Eğer Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değerini döndürür\n         (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "vi": "Viết một hàm python 'def jinjin_savings_plan(budgets: List[int]) -> int:' để giải quyết vấn đề sau:\n\n    Tính tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được hưởng lãi suất 20% vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi tính lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580"
    },
    "instruction_bertscore": {
      "es": "0.9932243204421379",
      "arb": "0.9803721402676565",
      "sw": "0.9761776625113427",
      "tr": "0.9670223909886827",
      "vi": "0.964131921683863"
    },
    "level": "middle",
    "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()",
    "entry_point": "jinjin_savings_plan",
    "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:",
    "docstring": {
      "en": "\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    ",
      "es": "Calcula la cantidad total de dinero que Jinjin tendrá al final del año después de seguir su plan de ahorros con su madre. Cada mes, puede ahorrar múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20% de interés al final del año.\n\nParámetros:\nbudgets (List[int]): Una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n\nDevuelve:\nint: La cantidad total de dinero que Jinjin tendrá al final del año después del interés. Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de ese mes (-X, donde X es el número del mes).\n\nEjemplos:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580",
      "arb": "    يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير الخاصة بها مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشخصي (300 شهريًا) إذا توقعت أن يكون لديها\n    على الأقل 100 وحدة متبقية بعد النفقات. الأموال المدخرة ستحصل على فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعاملات:\n    budgets (List[int]): قائمة مكونة من 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\n\n    العوائد:\n    int: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفدت أموال جينجين في أي شهر معين، يتم إرجاع القيمة السلبية\n         لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "sw": "    Inahesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kuwa na\n    angalau vitengo 100 vilivyobaki baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Parameters:\n    budgets (List[int]): Orodha ya namba 12 zinazoashiria bajeti ya kila mwezi ya Jinjin.\n\n    Inarejesha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "tr": "    Jinjin'in annesiyle yaptığı tasarruf planını takip ettikten sonra yıl sonunda sahip olacağı toplam para miktarını hesaplar. Her ay, en az 100 birim harcamalardan sonra kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları kadar tasarruf edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\n    Döndürür:\n    int: Faizden sonra yıl sonunda Jinjin'in sahip olacağı toplam para miktarı.\n         Eğer Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değerini döndürür\n         (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "vi": "    Tính tổng số tiền Jinjin sẽ có vào cuối năm\n    sau khi thực hiện kế hoạch tiết kiệm với mẹ của mình. Mỗi tháng, cô ấy có thể tiết kiệm\n    bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại\n    ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được hưởng lãi suất 20%\n    vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền Jinjin sẽ có vào cuối năm sau khi có lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của\n         tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580"
    },
    "docstring_bertscore": {
      "es": "0.9824633209191918",
      "arb": "0.9642195176818994",
      "sw": "0.9738785158508639",
      "tr": "0.9733398302574973",
      "vi": "0.9724124250084454"
    }
  },
  {
    "task_id": "Python/45",
    "prompt": {
      "en": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "es": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón.\n    El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza\n    un algoritmo voraz con un montículo mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero,\n    minimizando el costo total.\n\n    Parámetros:\n    fruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\n    Devuelve:\n    int: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\n    Ejemplos:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "arb": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة خوارزمية جشعة مع كومة صغيرة (قائمة انتظار ذات أولوية)\n    لضمان دمج أصغر الأكوام أولاً، مما يقلل التكلفة الإجمالية.\n\n    المعاملات:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\n    العوائد:\n    int: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\n    أمثلة:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "sw": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha mirundo mingi ya matunda kuwa rundo moja.\n    Gharama ya kuunganisha mirundo miwili ni sawa na jumla ya uzito wao. Kazi hii inatumia\n    algorithimu ya pupa na rundo la chini (foleni ya kipaumbele) kuhakikisha mirundo midogo inaunganishwa kwanza,\n    kupunguza gharama ya jumla.\n\n    Vigezo:\n    fruit_counts (List[int]): Orodha ya nambari zinazowakilisha idadi ya kila aina ya matunda.\n\n    Inarejesha:\n    int: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha mirundo yote ya matunda.\n\n    Mifano:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "tr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için gereken minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, en küçük yığınların önce birleştirilmesini\n    sağlamak ve toplam maliyeti en aza indirmek için min-heap (öncelik kuyruğu) ile bir açgözlü algoritma kullanır.\n\n    Parametreler:\n    fruit_counts (List[int]): Her tür meyvenin sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "vi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí để gộp hai đống bằng tổng trọng lượng của chúng. Hàm này sử dụng\n    thuật toán tham lam với một heap nhỏ nhất (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9629417284407019",
      "arb": "0.968630105292779",
      "sw": "0.9503300896576538",
      "tr": "0.9732603781050834",
      "vi": "0.9606620475575646"
    },
    "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost",
    "instruction": {
      "en": "Write a python function 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' to solve the following problem:\n\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    ",
      "es": "Escribe una función de Python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' para resolver el siguiente problema:\n\nCalcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón. El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza un algoritmo voraz con un montículo mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero, minimizando el costo total.\n\nParámetros:\nfruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\nDevuelve:\nint: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\nEjemplos:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .",
      "arb": "اكتب دالة بايثون 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' لحل المشكلة التالية:\n\n    تحسب التكلفة الإجمالية الدنيا لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة\n    خوارزمية جشعة مع كومة ذات أولوية (قائمة انتظار ذات أولوية) لضمان دمج الأصغر أولاً،\n    مما يقلل التكلفة الإجمالية.\n\n    المعاملات:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\n    العوائد:\n    int: التكلفة الإجمالية الدنيا المطلوبة لدمج جميع أكوام الفواكه.\n\n    أمثلة:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "sw": "Andika kazi ya python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' kutatua tatizo lifuatalo:\n\n    Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha marundo mengi ya matunda kuwa rundo moja.\n    Gharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia\n    algoriti ya pupa na min-heap (foleni ya kipaumbele) kuhakikisha marundo madogo yanaunganishwa kwanza,\n    kupunguza gharama ya jumla.\n\n    Vigezo:\n    fruit_counts (List[int]): Orodha ya namba zinazoashiria idadi ya kila aina ya tunda.\n\n    Inarudisha:\n    int: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha marundo yote ya matunda.\n\n    Mifano:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "tr": "Bir python fonksiyonu 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' yazarak aşağıdaki problemi çözün:\n\n    Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, toplam maliyeti\n    en aza indirmek için en küçük yığınların önce birleştirildiğinden emin olmak amacıyla bir min-heap\n    (öncelik kuyruğu) ile açgözlü bir algoritma kullanır.\n\n    Parametreler:\n    fruit_counts (List[int]): Her bir meyve türünün sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "vi": "Viết một hàm python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng\n    một thuật toán tham lam với một đống ưu tiên (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 ."
    },
    "instruction_bertscore": {
      "es": "0.9634798181429255",
      "arb": "0.9536112649219691",
      "sw": "0.954128697064565",
      "tr": "0.9662113831429172",
      "vi": "0.9547065128429955"
    },
    "level": "middle",
    "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()",
    "entry_point": "minimum_cost_to_merge_fruits",
    "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:",
    "docstring": {
      "en": "\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    ",
      "es": "Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón. El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza un algoritmo voraz con un montículo mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero, minimizando el costo total.\n\nParámetros:\nfruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\nDevuelve:\nint: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\nEjemplos:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .",
      "arb": "    يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة\n    خوارزمية جشعة مع كومة صغيرة (قائمة انتظار ذات أولوية) لضمان دمج أصغر الأكوام أولاً،\n    مما يقلل من التكلفة الإجمالية.\n\n    Parameters:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة التي تمثل عدد كل نوع من الفاكهة.\n\n    يعيد:\n    int: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\n    امثله:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "sw": "Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha marundo mengi ya matunda kuwa rundo moja. \nGharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia \nalgoriti ya pupa na min-heap (foleni ya kipaumbele) kuhakikisha marundo madogo yanaunganishwa kwanza, \nikidhibiti gharama ya jumla.\n\nVigezo:\nfruit_counts (List[int]): Orodha ya namba inayoonyesha idadi ya kila aina ya tunda.\n\nInarejesha:\nint: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha marundo yote ya matunda.\n\nMifano:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 .",
      "tr": "    Birden fazla meyve yığınını tek bir yığında birleştirmek için minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, toplam maliyeti\n    en aza indirmek için en küçük yığınların önce birleştirilmesini sağlayan bir min-yığın (öncelik kuyruğu)\n    ile açgözlü bir algoritma kullanır.\n\n    Parametreler:\n    fruit_counts (List[int]): Her tür meyvenin sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "vi": "    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng\n    một thuật toán tham lam với một min-heap (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 ."
    },
    "docstring_bertscore": {
      "es": "0.9566771248532426",
      "arb": "0.9627246254342308",
      "sw": "0.9420066821707679",
      "tr": "0.9510717755004381",
      "vi": "0.9569613649285035"
    }
  },
  {
    "task_id": "Python/46",
    "prompt": {
      "en": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"",
      "es": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calcular el número mínimo de estudiantes que deben salir para formar una formación de coro.\n    Se define una formación de coro tal que, para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que deben salir.\n    \"\"\"",
      "arb": "def minimum_students_to_leave(heights):\n    \"\"\"\n    حساب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه بالنسبة لموضع ما 'i'، تزداد أطوال الطلاب\n    من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.\n    \"\"\"",
      "sw": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Kuhesabu idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka ili kuunda safu ya kwaya.\n    Safu ya kwaya inafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    huongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa safu.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka.\n    \"\"\"",
      "tr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, bazı 'i' pozisyonu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar\n    arttığı ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.\n    \"\"\"",
      "vi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành một đội hợp xướng.\n    Một đội hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng từ đầu đến 'i' và giảm từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng học sinh tối thiểu cần rời đi.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9874620530883158",
      "arb": "0.9809070518837835",
      "sw": "0.9479483127586644",
      "tr": "0.9839874118328725",
      "vi": "0.9559284869471221"
    },
    "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length",
    "instruction": {
      "en": "Write a python function 'def minimum_students_to_leave(heights):' to solve the following problem:\n\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    ",
      "es": "Escribe una función de Python 'def minimum_students_to_leave(heights):' para resolver el siguiente problema:\n\n    Calcular el número mínimo de estudiantes que deben salir para formar una formación de coro.\n    Se define una formación de coro tal que para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de los estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que deben salir.",
      "arb": "اكتب دالة بايثون 'def minimum_students_to_leave(heights):' لحل المشكلة التالية:\n\n    احسب الحد الأدنى لعدد الطلاب الذين يحتاجون للمغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه لبعض المواضع 'i'، تزداد أطوال الطلاب من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون للمغادرة.",
      "sw": "Andika kazi ya python 'def minimum_students_to_leave(heights):' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka ili kuunda mpangilio wa kwaya.\n    Mpangilio wa kwaya unafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    unaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa mpangilio.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo zaidi ya wanafunzi wanaohitajika kuondoka.",
      "tr": "Bir python fonksiyonu 'def minimum_students_to_leave(heights):' yazın ve aşağıdaki problemi çözün:\n\n    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, bazı 'i' pozisyonu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar\n    arttığı ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının bir listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.",
      "vi": "Viết một hàm python 'def minimum_students_to_leave(heights):' để giải quyết vấn đề sau:\n\n    Tính toán số lượng tối thiểu học sinh cần rời đi để tạo thành một đội hình hợp xướng.\n    Một đội hình hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng từ đầu đến 'i' và giảm từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng tối thiểu học sinh cần rời đi."
    },
    "instruction_bertscore": {
      "es": "0.9903874813401976",
      "arb": "0.9817597721095662",
      "sw": "0.9708915121808612",
      "tr": "0.9837508430490599",
      "vi": "0.9794048103120165"
    },
    "level": "middle",
    "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()",
    "entry_point": "minimum_students_to_leave",
    "signature": "def minimum_students_to_leave(heights):",
    "docstring": {
      "en": "\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    ",
      "es": "    Calcular el número mínimo de estudiantes que necesitan salir para formar una formación de coro.\n    Se define una formación de coro tal que para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que necesitan salir.",
      "arb": "    حساب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه بالنسبة لموقع معين 'i'، تزداد أطوال الطلاب\n    من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.",
      "sw": "    Hesabu idadi ndogo ya wanafunzi wanaohitajika kuondoka ili kuunda mpangilio wa kwaya.\n    Mpangilio wa kwaya unafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    unaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa mpangilio.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo ya wanafunzi wanaohitajika kuondoka.",
      "tr": "    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, 'i' konumu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar arttığı\n    ve formasyonun sonuna kadar 'i'den azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının bir listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.",
      "vi": "    Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành một đội hợp xướng.\n    Một đội hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng từ đầu đến 'i' và giảm từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng học sinh tối thiểu cần rời đi."
    },
    "docstring_bertscore": {
      "es": "0.9967361055788347",
      "arb": "0.9676301999546495",
      "sw": "0.9550310748856065",
      "tr": "0.965725731861287",
      "vi": "0.9554084726095727"
    }
  },
  {
    "task_id": "Python/47",
    "prompt": {
      "en": "def sort_students(student_scores):\n    \"\"\"\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "es": "def sort_students(student_scores):\n    \"\"\"\n    Ordena una lista de estudiantes según sus puntajes. Los estudiantes se ordenan principalmente por su puntaje total (descendente),\n    luego por su puntaje en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n    \n    Argumentos:\n    student_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_estudiante, puntaje_total, puntaje_Chino).\n    \n    Devuelve:\n    list: Una lista de tuplas ordenadas según las reglas anteriores.\n    \n    Ejemplos:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "arb": "def sort_students(student_scores):\n    \"\"\"\n    يقوم بفرز قائمة الطلاب بناءً على درجاتهم. يتم فرز الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من الأزواج، حيث يتكون كل زوج من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من الأزواج مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    امثله:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "sw": "def sort_students(student_scores):\n    \"\"\"\n    Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa namba zao za mwanafunzi (kutoka chini kwenda juu) iwapo kuna sare.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (namba_ya_mwanafunzi, alama_jumla, alama_za_Kichina).\n    \n    Inarejesha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "tr": "def sort_students(student_scores):\n    \"\"\"\n    Öğrencileri puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan), \n    ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puanı) içerdiği demetlerden oluşan bir liste.\n    \n    Döndürür:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerden oluşan bir liste.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "vi": "def sort_students(student_scores):\n    \"\"\"\n    Sắp xếp danh sách học sinh dựa trên điểm số của họ. Các học sinh được sắp xếp chủ yếu theo tổng điểm (giảm dần),\n    sau đó theo điểm môn Ngữ văn (giảm dần), và cuối cùng theo số thứ tự học sinh (tăng dần) trong trường hợp bằng điểm.\n    \n    Tham số:\n    student_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ bao gồm (số_thứ_tự_học_sinh, tổng_điểm, điểm_Ngữ_văn).\n    \n    Trả về:\n    list: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n    \n    Ví dụ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9959910430195729",
      "arb": "0.9780618703058397",
      "sw": "0.9557830895082046",
      "tr": "0.9723001988431607",
      "vi": "0.9651977723084962"
    },
    "canonical_solution": "    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students",
    "instruction": {
      "en": "Write a python function 'def sort_students(student_scores):' to solve the following problem:\n\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    ",
      "es": "Escribe una función de Python 'def sort_students(student_scores):' para resolver el siguiente problema:\n\n    Ordena una lista de estudiantes basándose en sus puntuaciones. Los estudiantes se ordenan principalmente por su puntuación total (descendente),\n    luego por su puntuación en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n    \n    Argumentos:\n    student_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_de_estudiante, puntuación_total, puntuación_Chino).\n    \n    Devuelve:\n    list: Una lista de tuplas ordenadas de acuerdo con las reglas anteriores.\n    \n    Ejemplos:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "arb": "اكتب دالة بايثون 'def sort_students(student_scores):' لحل المشكلة التالية:\n\n    ترتيب قائمة الطلاب بناءً على درجاتهم. يتم ترتيب الطلاب أساسًا حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من المجموعات، حيث تتكون كل مجموعة من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من المجموعات مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    أمثلة:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "sw": "Andika kazi ya python 'def sort_students(student_scores):' kutatua tatizo lifuatalo:\n\n    Panga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao za jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa namba zao za mwanafunzi (kutoka chini kwenda juu) iwapo kuna usawa.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (namba ya mwanafunzi, alama ya jumla, alama ya Kichina).\n    \n    Inarejesha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "tr": "Bir python fonksiyonu 'def sort_students(student_scores):' yazarak aşağıdaki problemi çözün:\n\n    Öğrencilerin bir listesini puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan),\n    ardından Çin puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çin_puanı) içerdiği demetlerin bir listesi.\n    \n    Döndürür:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerin bir listesi.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "vi": "Viết một hàm python 'def sort_students(student_scores):' để giải quyết vấn đề sau:\n\n    Sắp xếp một danh sách sinh viên dựa trên điểm số của họ. Các sinh viên được sắp xếp chủ yếu theo tổng điểm (giảm dần),\n    sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số thứ tự sinh viên (tăng dần) trong trường hợp hòa điểm.\n    \n    Tham số:\n    student_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị bao gồm (số thứ tự sinh viên, tổng điểm, điểm tiếng Trung).\n    \n    Trả về:\n    list: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n    \n    Ví dụ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]"
    },
    "instruction_bertscore": {
      "es": "0.9921080177007218",
      "arb": "0.9758254908457679",
      "sw": "0.9654774438849933",
      "tr": "0.9713292935406622",
      "vi": "0.9732226383326867"
    },
    "level": "easy",
    "test": "def test_sort_students():\n    # Test case 1\n    input_scores = [(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)]\n    expected_output = [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 1 failed\"\n\n    # Test case 2\n    input_scores = [(1, 258, 80), (2, 264, 88), (3, 258, 90), (4, 244, 87), (5, 258, 78), (6, 264, 88), (7, 220, 67), (8, 265, 78)]\n    expected_output = [(8, 265, 78), (2, 264, 88), (6, 264, 88), (3, 258, 90), (1, 258, 80), (5, 258, 78), (4, 244, 87), (7, 220, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 2 failed\"\n\n    # Test case 3\n    input_scores = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    expected_output = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    assert sort_students(input_scores) == expected_output, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_sort_students()",
    "entry_point": "sort_students",
    "signature": "def sort_students(student_scores):",
    "docstring": {
      "en": "\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    ",
      "es": "Ordena una lista de estudiantes en función de sus puntuaciones. Los estudiantes se ordenan principalmente por su puntuación total (descendente), luego por su puntuación en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n\nArgumentos:\nstudent_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_de_estudiante, puntuación_total, puntuación_Chino).\n\nDevuelve:\nlist: Una lista de tuplas ordenadas según las reglas anteriores.\n\nEjemplos:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "arb": "    يقوم بترتيب قائمة الطلاب بناءً على درجاتهم. يتم ترتيب الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من الأزواج، حيث يتكون كل زوج من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من الأزواج مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    امثله:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "sw": "    Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa nambari zao za mwanafunzi (kutoka chini kwenda juu) iwapo kuna usawa.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (nambari_ya_mwanafunzi, alama_jumla, alama_ya_Kichina).\n    \n    Inarudisha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "tr": "    Öğrencilerin bir listesini puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan),\n    ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puan) içeren demetlerden oluşan bir liste.\n    \n    Döndürülenler:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerden oluşan bir liste.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "vi": "Sắp xếp danh sách sinh viên dựa trên điểm số của họ. Các sinh viên được sắp xếp chủ yếu theo tổng điểm (giảm dần), sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số thứ tự sinh viên (tăng dần) trong trường hợp điểm bằng nhau.\n\nTham số:\nstudent_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị bao gồm (số_thứ_tự_sinh_viên, tổng_điểm, điểm_tiếng_Trung).\n\nTrả về:\nlist: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n\nVí dụs:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]"
    },
    "docstring_bertscore": {
      "es": "0.9904057553352529",
      "arb": "0.9744134274669909",
      "sw": "0.9481614431575148",
      "tr": "0.9699212027695059",
      "vi": "0.9728500077378652"
    }
  },
  {
    "task_id": "Python/48",
    "prompt": {
      "en": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "es": "def min_groups(w, n, prices):\n    \"\"\"\n    Determina el número mínimo de grupos necesarios para distribuir recuerdos con una restricción en el precio total del grupo.\n    \n    Los recuerdos se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. \n    La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n    \n    Argumentos:\n    w (int): La suma máxima permitida de precios para cualquier grupo de recuerdos.\n    n (int): El número total de recuerdos.\n    prices (list): Una lista de enteros que representa el precio de cada recuerdo.\n    \n    Devuelve:\n    int: El número mínimo de grupos necesarios para distribuir todos los recuerdos.\n\n    Ejemplos:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "arb": "def min_groups(w, n, prices):\n    \"\"\"\n    يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات مع وجود قيد على السعر الإجمالي للمجموعة.\n    \n    يتم تجميع التذكارات في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`. \n    تهدف الدالة إلى تقليل عدد المجموعات التي تم إنشاؤها تحت هذا القيد.\n    \n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من التذكارات.\n    n (int): العدد الإجمالي للتذكارات.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل تذكار.\n    \n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع التذكارات.\n\n    امثله:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "sw": "def min_groups(w, n, prices):\n    \"\"\"\n    Inabainisha idadi ndogo ya makundi yanayohitajika kugawa zawadi zenye kizuizi kwenye jumla ya bei ya kundi.\n\n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kundi isizidi kikomo `w`.\n    Kazi hii inalenga kupunguza idadi ya makundi yanayoundwa chini ya kizuizi hiki.\n\n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kundi lolote la zawadi.\n    n (int): Jumla ya idadi ya zawadi.\n    prices (list): Orodha ya namba ambazo zinawakilisha bei ya kila zawadi.\n\n    Inarejesha:\n    int: Idadi ndogo ya makundi yanayohitajika kugawa zawadi zote.\n\n    Mifano:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "tr": "def min_groups(w, n, prices):\n    \"\"\"\n    Hatıra eşyalarını, grubun toplam fiyatı üzerinde bir kısıtlama ile dağıtmak için gereken minimum grup sayısını belirler.\n    \n    Hatıra eşyaları, her bir grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hatıra eşyası grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hatıra eşyası sayısı.\n    prices (list): Her bir hatıra eşyasının fiyatını temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    int: Tüm hatıra eşyalarını dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "vi": "def min_groups(w, n, prices):\n    \"\"\"\n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n    \n    Các quà lưu niệm được nhóm thành từng cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. \n    Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n    \n    Tham số:\n    w (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\n    n (int): Tổng số quà lưu niệm.\n    prices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n    \n    Trả về:\n    int: Số nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\n    Ví dụ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.984195576472197",
      "arb": "0.9861294418619527",
      "sw": "0.9395476380535559",
      "tr": "0.979185125110592",
      "vi": "0.9588559015028143"
    },
    "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups",
    "instruction": {
      "en": "Write a python function 'def min_groups(w, n, prices):' to solve the following problem:\n\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "es": "Escribe una función en Python 'def min_groups(w, n, prices):' para resolver el siguiente problema:\n\n    Determina el número mínimo de grupos necesarios para distribuir los souvenirs con una restricción en el precio total del grupo.\n    \n    Los souvenirs se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. \n    La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n    \n    Argumentos:\n    w (int): La suma máxima permitida de precios para cualquier grupo de souvenirs.\n    n (int): El número total de souvenirs.\n    prices (list): Una lista de enteros que representa el precio de cada souvenir.\n    \n    Devuelve:\n    int: El número mínimo de grupos necesarios para distribuir todos los souvenirs.\n\n    Ejemplos:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "arb": "اكتب دالة بايثون 'def min_groups(w, n, prices):' لحل المشكلة التالية:\n\n    تحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع الهدايا التذكارية مع وجود قيد على السعر الإجمالي للمجموعة.\n    \n    يتم تجميع الهدايا التذكارية في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`.\n    تهدف الدالة إلى تقليل عدد المجموعات التي يتم إنشاؤها تحت هذا القيد.\n    \n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من الهدايا التذكارية.\n    n (int): العدد الإجمالي للهدايا التذكارية.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل هدية تذكارية.\n    \n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع الهدايا التذكارية.\n\n    أمثلة:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "sw": "Andika kazi ya python 'def min_groups(w, n, prices):' kutatua tatizo lifuatalo:\n\n    Inabainisha idadi ndogo zaidi ya vikundi vinavyohitajika kugawa zawadi zikiwa na kizuizi kwenye jumla ya bei ya kikundi.\n    \n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \n    Kazi inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n    \n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\n    n (int): Jumla ya zawadi.\n    prices (list): Orodha ya namba nzima inayowakilisha bei ya kila zawadi.\n    \n    Inarejesha:\n    int: Idadi ndogo zaidi ya vikundi vinavyohitajika kugawa zawadi zote.\n\n    Mifano:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "tr": "Bir python fonksiyonu 'def min_groups(w, n, prices):' yazarak aşağıdaki problemi çözün:\n\n    Hediyelik eşyaların grup toplam fiyatı üzerinde bir kısıtlama ile dağıtılması için gereken minimum grup sayısını belirler.\n    \n    Hediyelik eşyalar, her grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hediyelik eşya grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hediyelik eşya sayısı.\n    prices (list): Her bir hediyelik eşyanın fiyatını temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    int: Tüm hediyelik eşyaları dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "vi": "Viết một hàm python 'def min_groups(w, n, prices):' để giải quyết vấn đề sau:\n\n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một ràng buộc về tổng giá của nhóm.\n\n    Các món quà lưu niệm được nhóm thành từng cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`.\n    Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới ràng buộc này.\n\n    Tham số:\n    w (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\n    n (int): Tổng số quà lưu niệm.\n    prices (list): Một danh sách các số nguyên đại diện cho giá của từng món quà lưu niệm.\n\n    Trả về:\n    int: Số nhóm tối thiểu cần thiết để phân phối tất cả các món quà lưu niệm.\n\n    Ví dụ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9779359386442635",
      "arb": "0.9851787968583198",
      "sw": "0.9496795751597645",
      "tr": "0.9683818173164854",
      "vi": "0.9736363854163824"
    },
    "level": "easy",
    "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()",
    "entry_point": "min_groups",
    "signature": "def min_groups(w, n, prices):",
    "docstring": {
      "en": "\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "es": "Determina el número mínimo de grupos necesarios para distribuir recuerdos con una restricción en el precio total del grupo.\n\nLos recuerdos se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n\nArgumentos:\nw (int): La suma máxima permitida de precios para cualquier grupo de recuerdos.\nn (int): El número total de recuerdos.\nprices (list): Una lista de enteros que representa el precio de cada recuerdo.\n\nDevuelve:\nint: El número mínimo de grupos necesarios para distribuir todos los recuerdos.\n\nEjemplos:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "arb": "    يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع الهدايا التذكارية مع وجود قيد على السعر الإجمالي للمجموعة.\n    \n    يتم تجميع الهدايا التذكارية في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`. \n    تهدف الدالة إلى تقليل عدد المجموعات التي يتم إنشاؤها تحت هذا القيد.\n    \n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من الهدايا التذكارية.\n    n (int): العدد الإجمالي للهدايا التذكارية.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل هدية تذكارية.\n    \n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع الهدايا التذكارية.\n\n    امثله:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "sw": "    Huamua idadi ndogo ya vikundi vinavyohitajika kugawa zawadi kwa kizuizi kwenye jumla ya bei ya kikundi.\n    \n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \n    Kazi inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n    \n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\n    n (int): Jumla ya idadi ya zawadi.\n    prices (list): Orodha ya namba nzima inayoonyesha bei ya kila zawadi.\n    \n    Inarejesha:\n    int: Idadi ndogo ya vikundi vinavyohitajika kugawa zawadi zote.\n\n    Mifano:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "tr": "    Hatıraların toplam fiyatı üzerinde bir sınırlama ile dağıtılması için gereken minimum grup sayısını belirler.\n    \n    Hatıralar, her grubun toplam fiyatı `w` sınırını aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hatıra grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hatıra sayısı.\n    prices (list): Her hatıranın fiyatını temsil eden tamsayıların listesi.\n    \n    Döndürür:\n    int: Tüm hatıraları dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "vi": "Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n\nCác quà lưu niệm được nhóm thành các cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n\nTham số:\nw (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\nn (int): Tổng số quà lưu niệm.\nprices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n\nTrả về:\nint: Số lượng nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\nVí dụ:\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2"
    },
    "docstring_bertscore": {
      "es": "0.9820990328003738",
      "arb": "0.9853686875025891",
      "sw": "0.9366684906804552",
      "tr": "0.96808903613484",
      "vi": "0.9690925168198283"
    }
  },
  {
    "task_id": "Python/49",
    "prompt": {
      "en": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    \"\"\"",
      "es": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calcular el número mínimo de movimientos requeridos para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n    \n    Esta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n    2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo un disco \n    puede moverse a la vez y ningún disco puede colocarse sobre un disco más pequeño. La función utiliza una relación recursiva conocida \n    y calcula iterativamente el número total de movimientos para n pares de discos.\n    \n    Argumentos:\n    n (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\n    Devuelve:\n    int: El número mínimo de movimientos requeridos para transferir todos los discos del poste A al poste C.\n\n    Casos:\n    - Para n=1, la función debe devolver 2.\n    - Para n=2, la función debe devolver 6.\n    - Para n=3, la función debe devolver 14.\n    \"\"\"",
      "arb": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    حساب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات الأقراص المزدوجة لعدد n من أزواج الأقراص.\n    \n    تقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n قرصًا من العمود A إلى العمود C \n    في إعداد أبراج هانوي ذات الأقراص المزدوجة، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة \n    ولا يجوز وضع أي قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات \n    لعدد n من أزواج الأقراص.\n    \n    يعيدالحجج:\n    n (int): عدد أزواج الأقراص (كل زوج من قرصين متطابقين) على العمود A.\n\n    يعيد:\n    int: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\n    حالات:\n    - لـ n=1، يجب أن تعيد الدالة 2.\n    - لـ n=2، يجب أن تعيد الدالة 6.\n    - لـ n=3، يجب أن تعيد الدالة 14.\n    \"\"\"",
      "sw": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Hesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la minara ya Hanoi ya diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa minara ya Hanoi ya diski mbili, kufuata sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili zinazofanana) kwenye nguzo A.\n\n    Inarejesha:\n    int: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\n    Cases:\n    - Kwa n=1, kazi inapaswa kurudisha 2.\n    - Kwa n=2, kazi inapaswa kurudisha 6.\n    - Kwa n=3, kazi inapaswa kurudisha 14.\n    \"\"\"",
      "tr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Çift diskli Hanoi Kuleleri problemini n çift disk için çözmek üzere gereken minimum hamle sayısını hesaplar.\n    \n    Bu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine aktarmak için gereken minimum \n    hamle sayısını belirlemek üzere iteratif bir algoritma uygular. Kurallara göre, aynı anda yalnızca bir disk \n    taşınabilir ve hiçbir disk daha küçük bir diskin üzerine yerleştirilemez. Fonksiyon, bilinen bir özyinelemeli \n    ilişkiyi kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A direğinde bulunan disk çiftlerinin sayısı (her biri iki özdeş diskten oluşur).\n\n    Döndürür:\n    int: Tüm diskleri A direğinden C direğine aktarmak için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir.\n    - n=2 için, fonksiyon 6 döndürmelidir.\n    - n=3 için, fonksiyon 14 döndürmelidir.\n    \"\"\"",
      "vi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội hai đĩa cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cột A sang cột C trong cấu hình Tháp Hà Nội hai đĩa, tuân theo các quy tắc chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào có thể được đặt lên trên một đĩa nhỏ hơn. Hàm sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp đi lặp lại tổng số lần di chuyển cho n cặp đĩa.\n    \n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống nhau) trên cột A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\n    Trường hợp:\n    - Với n=1, hàm sẽ trả về 2.\n    - Với n=2, hàm sẽ trả về 6.\n    - Với n=3, hàm sẽ trả về 14.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9480170388705025",
      "arb": "0.9518210092977016",
      "sw": "0.9086856412306412",
      "tr": "0.9245196606852184",
      "vi": "0.9311024701430956"
    },
    "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
    "instruction": {
      "en": "Write a python function 'def hanoi_double_iterative(n: int) -> int:' to solve the following problem:\n\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    ",
      "es": "Escribe una función en Python 'def hanoi_double_iterative(n: int) -> int:' para resolver el siguiente problema:\n\n    Calcular el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n    \n    Esta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n    2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo se puede mover un disco \n    a la vez y ningún disco puede colocarse sobre uno más pequeño. La función utiliza una relación recursiva conocida \n    y calcula iterativamente el número total de movimientos para n pares de discos.\n    \n    Argumentos:\n    n (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\n    Döndürür:\n    int: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\n    Casos:\n    - Para n=1, la función debería devolver 2.\n    - Para n=2, la función debería devolver 6.\n    - Para n=3, la función debería devolver 14.",
      "arb": "اكتب دالة بايثون 'def hanoi_double_iterative(n: int) -> int:' لحل المشكلة التالية:\n\nاحسب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات الأقراص المزدوجة لعدد n من أزواج الأقراص.\n\nتقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n من الأقراص من العمود A إلى العمود C في إعداد أبراج هانوي ذات الأقراص المزدوجة، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة ولا يجوز وضع قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات لعدد n من أزواج الأقراص.\n\nالمعاملات:\nn (int): عدد أزواج الأقراص (كل زوج مكون من قرصين متطابقين) على العمود A.\n\nالقيم المعادة:\nint: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\nالحالات:\n- بالنسبة لـ n=1، يجب أن تعيد الدالة 2.\n- بالنسبة لـ n=2، يجب أن تعيد الدالة 6.\n- بالنسبة لـ n=3، يجب أن تعيد الدالة 14.",
      "sw": "Andika kazi ya python 'def hanoi_double_iterative(n: int) -> int:' kutatua tatizo lifuatalo:\n\n    Hesabu idadi ndogo zaidi ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo zaidi ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo ya A hadi nguzo ya C katika mpangilio wa Hanoi Towers wenye diski mbili, ikifuata sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na kwa kurudia huhesabu jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili zinazofanana) kwenye nguzo ya A.\n\n    Inarejesha:\n    int: Idadi ndogo zaidi ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo ya A hadi nguzo ya C.\n\n    Matukio:\n    - Kwa n=1, kazi inapaswa kurudisha 2.\n    - Kwa n=2, kazi inapaswa kurudisha 6.\n    - Kwa n=3, kazi inapaswa kurudisha 14.",
      "tr": "Bir python fonksiyonu 'def hanoi_double_iterative(n: int) -> int:' yazın ve aşağıdaki problemi çözün:\n\n    n çift disk için çift diskli Hanoi Kuleleri problemini çözmek için gereken minimum hamle sayısını hesaplayın.\n    \n    Bu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine aktarmak için gerekli\n    minimum hamle sayısını belirlemek üzere bir iteratif algoritma uygular. Kurallar, aynı anda yalnızca bir diskin \n    hareket ettirilebileceğini ve hiçbir diskin daha küçük bir diskin üzerine yerleştirilemeyeceğini belirtir. Fonksiyon,\n    bilinen bir özyinelemeli ilişkiyi kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A direğinde bulunan disk çiftlerinin (her biri iki özdeş diskten oluşan) sayısı.\n\n    Döndürür:\n    int: Tüm diskleri A direğinden C direğine aktarmak için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir.\n    - n=2 için, fonksiyon 6 döndürmelidir.\n    - n=3 için, fonksiyon 14 döndürmelidir.",
      "vi": "Viết một hàm python 'def hanoi_double_iterative(n: int) -> int:' để giải quyết vấn đề sau:\n\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội đĩa đôi cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cọc A sang cọc C trong thiết lập Tháp Hà Nội đĩa đôi, tuân theo các quy tắc rằng chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào có thể được đặt lên trên một đĩa nhỏ hơn. Hàm này sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp đi lặp lại tổng số lần di chuyển cho n cặp đĩa.\n    \n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống hệt nhau) trên cọc A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cọc A sang cọc C.\n\n    Các trường hợp:\n    - Với n=1, hàm nên trả về 2.\n    - Với n=2, hàm nên trả về 6.\n    - Với n=3, hàm nên trả về 14."
    },
    "instruction_bertscore": {
      "es": "0.944842925381565",
      "arb": "0.9448989391490168",
      "sw": "0.910045464819206",
      "tr": "0.9214244034575517",
      "vi": "0.9283645489709107"
    },
    "level": "easy",
    "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()",
    "entry_point": "hanoi_double_iterative",
    "signature": "def hanoi_double_iterative(n: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    ",
      "es": "Calcular el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n\nEsta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir 2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo se puede mover un disco a la vez y ningún disco puede ser colocado sobre un disco más pequeño. La función utiliza una relación recursiva conocida y calcula iterativamente el número total de movimientos para n pares de discos.\n\nArgumentos:\nn (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\nDevuelve:\nint: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\nCases:\n- Para n=1, la función debería devolver 2.\n- Para n=2, la función debería devolver 6.\n- Para n=3, la función debería devolver 14.",
      "arb": "    حساب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات القرص المزدوج لعدد n من أزواج الأقراص.\n    \n    تقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n من الأقراص من العمود A إلى العمود C في إعداد أبراج هانوي ذات القرص المزدوج، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة ولا يجوز وضع أي قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب تكرارياً العدد الإجمالي للحركات لعدد n من أزواج الأقراص.\n    \n    يعيدالحجج:\n    n (int): عدد أزواج الأقراص (كل زوج يتكون من قرصين متطابقين) على العمود A.\n\n    يعيد:\n    int: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\n    Cases:\n    - بالنسبة لـ n=1، يجب أن تعيد الدالة 2.\n    - بالنسبة لـ n=2، يجب أن تعيد الدالة 6.\n    - بالنسبة لـ n=3، يجب أن تعيد الدالة 14.",
      "sw": "    Hesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa Hanoi Towers wenye diski mbili, kufuatia sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili zinazofanana) kwenye nguzo A.\n\n    Inarejesha:\n    int: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\n    Matukio:\n    - Kwa n=1, kazi inapaswa kurejesha 2.\n    - Kwa n=2, kazi inapaswa kurejesha 6.\n    - Kwa n=3, kazi inapaswa kurejesha 14.",
      "tr": "    Çift diskli Hanoi Kuleleri problemini n çift disk için çözmek üzere gereken minimum hamle sayısını hesaplayın.\n    \n    Bu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine aktarmak için gereken minimum \n    hamle sayısını belirlemek üzere iteratif bir algoritma uygular. Kurallar, yalnızca bir diskin bir seferde \n    taşınabileceğini ve hiçbir diskin daha küçük bir diskin üzerine yerleştirilemeyeceğini belirtir. Fonksiyon, bilinen \n    bir özyinelemeli ilişkiyi kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A direğinde bulunan disk çiftlerinin (her biri iki özdeş diskten oluşan) sayısı.\n\n    Döndürür:\n    int: Tüm diskleri A direğinden C direğine aktarmak için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir.\n    - n=2 için, fonksiyon 6 döndürmelidir.\n    - n=3 için, fonksiyon 14 döndürmelidir.",
      "vi": "    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội hai đĩa cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cột A sang cột C trong thiết lập Tháp Hà Nội hai đĩa, tuân theo các quy tắc chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào có thể được đặt lên trên một đĩa nhỏ hơn. Hàm này sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp đi lặp lại tổng số lần di chuyển cho n cặp đĩa.\n\n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống hệt nhau) trên cột A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\n    Trường hợp:\n    - Với n=1, hàm nên trả về 2.\n    - Với n=2, hàm nên trả về 6.\n    - Với n=3, hàm nên trả về 14."
    },
    "docstring_bertscore": {
      "es": "0.9266724167548744",
      "arb": "0.9533339769100444",
      "sw": "0.8867894225468793",
      "tr": "0.92533186031327",
      "vi": "0.9110523222206719"
    }
  },
  {
    "task_id": "Python/50",
    "prompt": {
      "en": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "es": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "arb": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة للتبادل للحصول على سيجارة جديدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "sw": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n    Peter anaanza na sigara n na anaweza kubadilisha vipande k vya sigara kwa sigara mpya moja.\n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\n    na k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\n    Kazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\n    Mfano:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "tr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken sigara izmariti sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "vi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k tàn thuốc để lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số tàn thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9864426819728448",
      "arb": "0.9806398940212915",
      "sw": "0.9963054749127511",
      "tr": "0.998855491744477",
      "vi": "0.9787086108264893"
    },
    "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total",
    "instruction": {
      "en": "Write a python function 'def total_smoked_cigarettes(n, k):' to solve the following problem:\n\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ",
      "es": "Escribe una función de Python 'def total_smoked_cigarettes(n, k):' para resolver el siguiente problema:\n\n    Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "arb": "اكتب دالة بايثون 'def total_smoked_cigarettes(n, k):' لحل المشكلة التالية:\n\n    تحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة واحدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة لتبادلها بسيجارة جديدة واحدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "sw": "Andika kazi ya python 'def total_smoked_cigarettes(n, k):' kutatua tatizo lifuatalo:\n\n    Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n    Peter anaanza na sigara n na anaweza kubadilisha vishungi k kwa sigara mpya moja.\n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\n    na k ni idadi ya vishungi vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\n    Kazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\n    Mfano:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ",
      "tr": "Bir python fonksiyonu 'def total_smoked_cigarettes(n, k):' yazın ve aşağıdaki problemi çözün:\n\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter, n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "vi": "Viết một hàm python 'def total_smoked_cigarettes(n, k):' để giải quyết vấn đề sau:\n\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k đầu lọc lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số đầu lọc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    "
    },
    "instruction_bertscore": {
      "es": "0.9861187158213769",
      "arb": "0.9973049829901186",
      "sw": "0.9887922807501064",
      "tr": "0.9936100606421077",
      "vi": "0.9665033698030385"
    },
    "level": "easy",
    "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k):",
    "docstring": {
      "en": "\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar.\nPeter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\nLa función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\ny k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\nLa función devuelve el número total de cigarrillos que Peter puede fumar.\nEjemplo:\n>>> total_smoked_cigarettes(4, 3)\n    5\n>>> total_smoked_cigarettes(10, 3)\n    14",
      "arb": "    يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة واحدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة لتبادلها بسيجارة جديدة واحدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.\nPeter anaanza na sigara n na anaweza kubadilisha vipande k vya sigara kwa sigara mpya moja.\nKazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\nna k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\nKazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.\nMfano:\n>>> total_smoked_cigarettes(4, 3)\n    5\n>>> total_smoked_cigarettes(10, 3)\n    14",
      "tr": "    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter, n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ",
      "vi": "    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k đầu mẩu thuốc lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số đầu mẩu thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    "
    },
    "docstring_bertscore": {
      "es": "0.9842972752272869",
      "arb": "0.9872485254287033",
      "sw": "0.9866041684726261",
      "tr": "0.9882307526629208",
      "vi": "0.9757206140045814"
    }
  }
]