[
  {
    "task_id": "TypeScript/1",
    "prompt": {
      "en": "\n// return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "es": "// devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "arb": "// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "sw": "// rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "tr": "// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" rudisha",
      "vi": "// trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string"
    },
    "prompt_bertscore": {
      "es": "0.9927952788191026",
      "arb": "0.9955175081911857",
      "sw": "1",
      "tr": "0.857273345185857",
      "vi": "1"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "Write a TypeScript function `function hello_mmcodeeval(): string` to solve the following problem:\nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "es": "Escribe una función de TypeScript `function hello_mmcodeeval(): string` para resolver el siguiente problema:  \nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "arb": "اكتب دالة TypeScript `function hello_mmcodeeval(): string` لحل المشكلة التالية:  \nإرجاع \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "sw": "Andika kazi ya TypeScript `function hello_mmcodeeval(): string` kutatua tatizo lifuatalo:  \nrudisha \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "tr": "Aşağıdaki problemi çözmek için bir TypeScript fonksiyonu `function hello_mmcodeeval(): string` yazın:\n\"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\" döndürün.",
      "vi": "Viết một hàm TypeScript `function hello_mmcodeeval(): string` để giải quyết vấn đề sau:  \ntrả về \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\""
    },
    "instruction_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9949188362227466",
      "sw": "0.9999996027392379",
      "tr": "0.9914283045368204",
      "vi": "0.9999996027392379"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(hello_mmcodeeval() === \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n})();",
    "entry_point": "hello_mmcodeeval",
    "signature": "function hello_mmcodeeval(): string",
    "docstring": {
      "en": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "es": "devuelve \"Hello, MMCODEEVAL: Evaluación de Código Masivamente Multilingüe\"",
      "arb": "إرجاع \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "sw": "rudisha \"Hello, MMCODEEVAL: Tathmini ya Nambari ya Lugha Nyingi kwa Wingi\"",
      "tr": "\"Hello, MMCODEEVAL: Kapsamlı Çok Dilli Kod Değerlendirmesi\" rudisha",
      "vi": "trả về \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9606042461166834",
      "tr": "0.9531041615591871",
      "vi": "1"
    }
  },
  {
    "task_id": "TypeScript/2",
    "prompt": {
      "en": "\n/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param a - Length of side 'a'.\n * @param b - Length of side 'b'.\n * @param c - Length of side 'c'.\n * @returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n *          Otherwise, return \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "es": "/**\n * Calcular el área de un triángulo dados sus tres lados.\n * \n * @param a - Longitud del lado 'a'.\n * @param b - Longitud del lado 'b'.\n * @param c - Longitud del lado 'c'.\n * @returns Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\n *          De lo contrario, devuelve \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "arb": "/**\n * حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n * \n * @param a - طول الضلع 'a'.\n * @param b - طول الضلع 'b'.\n * @param c - طول الضلع 'c'.\n * @returns إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقتين عشريتين.\n *          خلاف ذلك، يتم إرجاع \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "sw": "/**\n * Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n * \n * @param a - Urefu wa upande 'a'.\n * @param b - Urefu wa upande 'b'.\n * @param c - Urefu wa upande 'c'.\n * @returns Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\n *          Vinginevyo, rudisha \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "tr": "/**\n * Üç kenarı verilen bir üçgenin alanını hesapla.\n * \n * @param a - 'a' kenarının uzunluğu.\n * @param b - 'b' kenarının uzunluğu.\n * @param c - 'c' kenarının uzunluğu.\n * @returns Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndür.\n *          Aksi takdirde, \"-1\" döndür.\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "vi": "/**\n * Tính diện tích của một tam giác khi biết ba cạnh của nó.\n * \n * @param a - Độ dài của cạnh 'a'.\n * @param b - Độ dài của cạnh 'b'.\n * @param c - Độ dài của cạnh 'c'.\n * @returns Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\n *          Nếu không, trả về \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number"
    },
    "prompt_bertscore": {
      "es": "0.980443249944067",
      "arb": "0.9833192192310711",
      "sw": "0.9965164203774102",
      "tr": "0.9965164203774102",
      "vi": "0.9948095895131773"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        const s: number = (a + b + c) / 2.0;\n        return parseFloat(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateTriangleArea(a: number, b: number, c: number): number` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\n@param a - Length of side 'a'.\n@param b - Length of side 'b'.\n@param c - Length of side 'c'.\n@returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n         Otherwise, return \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "es": "Escribe una función de TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n\n@param a - Longitud del lado 'a'.\n@param b - Longitud del lado 'b'.\n@param c - Longitud del lado 'c'.\n@returns Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\n         De lo contrario, devuelve \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "arb": "اكتب دالة TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` لحل المشكلة التالية:\nاحسب مساحة المثلث المعطى أضلاعه الثلاثة.\n\n@param a - طول الضلع 'a'.\n@param b - طول الضلع 'b'.\n@param c - طول الضلع 'c'.\n@returns إذا كانت الأضلاع المقدمة تشكل مثلثًا، ارجع المساحة المحسوبة مع دقتين عشريتين.\n         خلاف ذلك، ارجع \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "sw": "Andika kazi ya TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n\n@param a - Urefu wa upande 'a'.\n@param b - Urefu wa upande 'b'.\n@param c - Urefu wa upande 'c'.\n@returns Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\n         Vinginevyo, rudisha \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "tr": "Bir TypeScript fonksiyonu `function calculateTriangleArea(a: number, b: number, c: number): number` yazın ve aşağıdaki problemi çözün:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n\n@param a - 'a' kenarının uzunluğu.\n@param b - 'b' kenarının uzunluğu.\n@param c - 'c' kenarının uzunluğu.\n@returns Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\n         Aksi takdirde, \"-1\" döndürün.\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "vi": "Viết một hàm TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n\n@param a - Độ dài cạnh 'a'.\n@param b - Độ dài cạnh 'b'.\n@param c - Độ dài cạnh 'c'.\n@returns Nếu các cạnh cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\n         Ngược lại, trả về \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6"
    },
    "instruction_bertscore": {
      "es": "0.9839655624909587",
      "arb": "0.9930187379977667",
      "sw": "0.9968620372404108",
      "tr": "0.9940835954704949",
      "vi": "0.9887173970964562"
    },
    "level": "easy",
    "test": "(() => {\n    let area: number;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculateTriangleArea(3, 5, 4);\n    console.assert(Math.abs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should return \"-1\"\n    area = calculateTriangleArea(1, 1, 4);\n    console.assert(area === -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculateTriangleArea(7, 24, 25);\n    console.assert(Math.abs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculateTriangleArea(10.5, 6.2, 7.3);\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    console.assert(Math.abs(area - 22.15) < 1e-2);\n\n    // console.log(\"All tests passed successfully.\");\n})();",
    "entry_point": "calculateTriangleArea",
    "signature": "function calculateTriangleArea(a: number, b: number, c: number): number",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\n@param a - Length of side 'a'.\n@param b - Length of side 'b'.\n@param c - Length of side 'c'.\n@returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n         Otherwise, return \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "es": "Calcular el área de un triángulo dados sus tres lados.\n\n@param a - Longitud del lado 'a'.\n@param b - Longitud del lado 'b'.\n@param c - Longitud del lado 'c'.\n@returns Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\n         De lo contrario, devuelve \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "arb": "احسب مساحة المثلث المعطى أطوال أضلاعه الثلاثة.\n\n@param a - طول الضلع 'a'.\n@param b - طول الضلع 'b'.\n@param c - طول الضلع 'c'.\n@returns إذا كانت الأضلاع المقدمة تشكل مثلثًا، ارجع المساحة المحسوبة بدقة منزلتين عشريتين.\n         خلاف ذلك، ارجع \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n\n@param a - Urefu wa upande 'a'.\n@param b - Urefu wa upande 'b'.\n@param c - Urefu wa upande 'c'.\n@returns Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\n         Vinginevyo, rudisha \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n\n@param a - 'a' kenarının uzunluğu.\n@param b - 'b' kenarının uzunluğu.\n@param c - 'c' kenarının uzunluğu.\n@returns Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\n         Aksi takdirde, \"-1\" döndürün.\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n\n@param a - Độ dài của cạnh 'a'.\n@param b - Độ dài của cạnh 'b'.\n@param c - Độ dài của cạnh 'c'.\n@returns Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\n         Ngược lại, trả về \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6"
    },
    "docstring_bertscore": {
      "es": "0.9774328078891023",
      "arb": "0.9765924027469436",
      "sw": "0.9953987272233268",
      "tr": "0.9953987272233268",
      "vi": "0.9831946779821622"
    }
  },
  {
    "task_id": "TypeScript/3",
    "prompt": {
      "en": "\n/**\n * Calculate the value of the function for a given input.\n * \n * Parameters:\n * - x (number): Input value for the function.\n * \n * Returns:\n * - string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n * \n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Example usage:\n * calculateFunctionValue(40); // Returns \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "es": "/**\n * Calcular el valor de la función para una entrada dada.\n * \n * Parámetros:\n * - x (number): Valor de entrada para la función.\n * \n * Devuelve:\n * - string: Si x no está en el dominio definido, devuelve \"Not define\".\n *   De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n * \n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Ejemplo de uso:\n * calculateFunctionValue(40); // Devuelve \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "arb": "/**\n * حساب قيمة الدالة لمدخل معين.\n * \n * المعاملات:\n * - x (number): قيمة المدخل للدالة.\n * \n * يعيد:\n * - string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n *   خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n * \n * تعريفات الدالة:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * مثال على الاستخدام:\n * calculateFunctionValue(40); // Returns \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "sw": "/**\n * Hesabu thamani ya kazi kwa ingizo lililopewa.\n * \n * Vigezo:\n * - x (nambari): Thamani ya ingizo kwa kazi.\n * \n * Inarudisha:\n * - string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\n *   Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa ikizungushwa hadi sehemu 5 za desimali.\n * \n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Mfano wa matumizi:\n * calculateFunctionValue(40); // Inarudisha \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "tr": "/**\n * Belirtilen bir giriş için fonksiyonun değerini hesaplayın.\n * \n * Parametreler:\n * - x (sayı): Fonksiyon için giriş değeri.\n * \n * Döner:\n * - string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\n *   Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n * \n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * \n * Örnek kullanım:\n * calculateFunctionValue(40); // \"Not define\" döner\n */\nfunction calculateFunctionValue(x: number): string",
      "vi": "/**\n * Tính giá trị của hàm cho một đầu vào nhất định.\n * \n * Tham số:\n * - x (number): Giá trị đầu vào cho hàm.\n * \n * Trả về:\n * - string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n *   Ngược lại, trả về giá trị hàm đã tính toán làm tròn đến 5 chữ số thập phân.\n * \n * Định nghĩa hàm:\n * - Đối với 0 <= x < 10: y = cos(x + 3.0)\n * - Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Ví dụ sử dụng:\n * calculateFunctionValue(40); // Returns \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string"
    },
    "prompt_bertscore": {
      "es": "0.974260084812832",
      "arb": "0.9842911176854748",
      "sw": "0.9899010355370432",
      "tr": "0.9864585724033276",
      "vi": "0.9943279108391677"
    },
    "canonical_solution": "{\n    let y: number;\n\n    if (0 <= x && x < 10) {\n        y = Math.cos(x + 3.0);\n        return y.toFixed(5);\n    } else if (10 <= x && x < 20) {\n        y = Math.cos(x + 7.5);\n        return (y * y).toFixed(5);\n    } else if (20 <= x && x < 30) {\n        y = Math.cos(x + 4.0);\n        return Math.pow(y, 4).toFixed(5);\n    } else {\n        return \"Not define\";\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateFunctionValue(x: number): string` to solve the following problem:\nCalculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\n  Otherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample usage:\ncalculateFunctionValue(40); // Returns \"Not define\"\n",
      "es": "Escribe una función de TypeScript `function calculateFunctionValue(x: number): string` para resolver el siguiente problema:\nCalcula el valor de la función para una entrada dada.\n\nParámetros:\n- x (number): Valor de entrada para la función.\n\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\n  De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\nEjemplo de uso:\ncalculateFunctionValue(40); // Returns \"Not define\"",
      "arb": "اكتب دالة TypeScript `function calculateFunctionValue(x: number): string` لحل المشكلة التالية:\nاحسب قيمة الدالة لمدخل معين.\n\nالمعطيات:\n- x (number): قيمة المدخل للدالة.\n\nالمخرجات:\n- string: إذا لم يكن x في النطاق المحدد، تعود \"Not define\".\n  خلاف ذلك، تعود قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\nمثال على الاستخدام:\ncalculateFunctionValue(40); // Returns \"Not define\"",
      "sw": "Andika kazi ya TypeScript `function calculateFunctionValue(x: number): string` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (number): Thamani ya pembejeo kwa kazi.\n\nRudisha:\n- string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\n  Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMfano wa matumizi:\ncalculateFunctionValue(40); // Inarudisha \"Not define\"",
      "tr": "Bir TypeScript fonksiyonu `function calculateFunctionValue(x: number): string` yazın ve aşağıdaki problemi çözün:\nVerilen bir girdi için fonksiyonun değerini hesaplayın.\n\nParametreler:\n- x (number): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\n  Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnek kullanım:\ncalculateFunctionValue(40); // \"Not define\" döner",
      "vi": "Viết một hàm TypeScript `function calculateFunctionValue(x: number): string` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào cho trước.\n\nTham số:\n- x (number): Giá trị đầu vào cho hàm.\n\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n  Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ sử dụng:\ncalculateFunctionValue(40); // Trả về \"Not define\""
    },
    "instruction_bertscore": {
      "es": "0.9755462165300328",
      "arb": "0.9673842955429283",
      "sw": "0.9710388959235892",
      "tr": "0.9821643821957343",
      "vi": "0.9896559256468461"
    },
    "level": "middle",
    "test": "function testCalculateFunctionValue(): void {\n    console.assert(calculateFunctionValue(40) === \"Not define\", \"Test failed: x = 40 should be 'Not define'\");\n    console.assert(calculateFunctionValue(5) === \"-0.14550\", \"Test failed: x = 5 should be '-0.14550'\");\n    console.assert(calculateFunctionValue(15) === \"0.76266\", \"Test failed: x = 15 should be '0.76266'\");\n    console.assert(calculateFunctionValue(25) === \"0.31314\", \"Test failed: x = 25 should be '0.31314'\");\n    console.assert(calculateFunctionValue(-1) === \"Not define\", \"Test failed: x = -1 should be 'Not define'\");\n}\n\ntestCalculateFunctionValue();",
    "entry_point": "calculateFunctionValue",
    "signature": "function calculateFunctionValue(x: number): string",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\n  Otherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample usage:\ncalculateFunctionValue(40); // Returns \"Not define\"\n",
      "es": "Calcular el valor de la función para una entrada dada.\n\nParámetros:\n- x (number): Valor de entrada para la función.\n\nDevuelve:\n- string: Si x no está en el dominio definido, devuelve \"Not define\".\n  De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\nDefiniciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n\nEjemplo de uso:\ncalculateFunctionValue(40); // Devuelve \"Not define\"",
      "arb": "احسب قيمة الدالة لقيمة مدخلة معينة.\n\nالمعطيات:\n- x (رقم): قيمة المدخل للدالة.\n\nالقيم المعادة:\n- سلسلة نصية: إذا لم تكن x ضمن النطاق المحدد، تعيد \"غير معرف\".\n  خلاف ذلك، تعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\nتعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n\nمثال على الاستخدام:\ncalculateFunctionValue(40); // تعيد \"غير معرف\"",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (nambari): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- string: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarejesha \"Not define\".\n  Vinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu 5 za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMfano wa matumizi:\ncalculateFunctionValue(40); // Inarejesha \"Not define\"",
      "tr": "Fonksiyonun belirli bir giriş için değerini hesaplayın.\n\nParametreler:\n- x (sayı): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\n  Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnek kullanım:\ncalculateFunctionValue(40); // \"Not define\" döner",
      "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n\nTham số:\n- x (number): Giá trị đầu vào cho hàm.\n\nTrả về:\n- string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n  Ngược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ sử dụng:\ncalculateFunctionValue(40); // Trả về \"Not define\""
    },
    "docstring_bertscore": {
      "es": "0.9744773864496841",
      "arb": "0.9430079779215647",
      "sw": "0.9856310782359362",
      "tr": "0.9800986262329714",
      "vi": "0.9852318311700561"
    }
  },
  {
    "task_id": "TypeScript/4",
    "prompt": {
      "en": "\n/**\n * Find the maximum and minimum of three distinct integers.\n *\n * @param a - The first integer.\n * @param b - The second integer.\n * @param c - The third integer.\n * @returns A tuple containing the maximum and minimum values respectively.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "es": "/**\n * Encuentra el máximo y el mínimo de tres enteros distintos.\n *\n * @param a - El primer entero.\n * @param b - El segundo entero.\n * @param c - El tercer entero.\n * @returns Una tupla que contiene los valores máximo y mínimo respectivamente.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "arb": "/**\n * إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\n *\n * @param a - العدد الصحيح الأول.\n * @param b - العدد الصحيح الثاني.\n * @param c - العدد الصحيح الثالث.\n * @returns زوج يحتوي على القيمتين القصوى والدنيا على التوالي.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "sw": "/**\n * Pata kubwa na ndogo kati ya nambari tatu tofauti.\n *\n * @param a - Nambari ya kwanza.\n * @param b - Nambari ya pili.\n * @param c - Nambari ya tatu.\n * @returns Jozi inayojumuisha thamani kubwa na ndogo mtawalia.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "tr": "/**\n * Üç farklı tamsayının maksimum ve minimumunu bulun.\n *\n * @param a - Birinci tamsayı.\n * @param b - İkinci tamsayı.\n * @param c - Üçüncü tamsayı.\n * @returns Sırasıyla maksimum ve minimum değerleri içeren bir demet.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "vi": "/**\n * Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n *\n * @param a - Số nguyên thứ nhất.\n * @param b - Số nguyên thứ hai.\n * @param c - Số nguyên thứ ba.\n * @returns Một bộ giá trị chứa giá trị lớn nhất và nhỏ nhất tương ứng.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]"
    },
    "prompt_bertscore": {
      "es": "0.9952727955617507",
      "arb": "0.9847300908275619",
      "sw": "0.9350117146722432",
      "tr": "0.9816733678938161",
      "vi": "0.9764986492070952"
    },
    "canonical_solution": "{\n    let max: number;\n    let min: number;\n\n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = b < c ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = a < c ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return [max, min];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function findMaxMin(a: number, b: number, c: number): [number, number]` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\n@param a - The first integer.\n@param b - The second integer.\n@param c - The third integer.\n@returns A tuple containing the maximum and minimum values respectively.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "es": "Escribe una función de TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` para resolver el siguiente problema:\nEncuentra el máximo y mínimo de tres enteros distintos.\n\n@param a - El primer entero.\n@param b - El segundo entero.\n@param c - El tercer entero.\n@returns Una tupla que contiene los valores máximo y mínimo respectivamente.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "arb": "اكتب دالة TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` لحل المشكلة التالية:\nالعثور على القيمتين العظمى والصغرى لثلاثة أعداد صحيحة متميزة.\n\n@param a - العدد الصحيح الأول.\n@param b - العدد الصحيح الثاني.\n@param c - العدد الصحيح الثالث.\n@returns زوج يحتوي على القيمتين العظمى والصغرى على التوالي.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "sw": "Andika kazi ya TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` kutatua tatizo lifuatalo:\nPata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\n@param a - Nambari ya kwanza.\n@param b - Nambari ya pili.\n@param c - Nambari ya tatu.\n@returns Jozi inayojumuisha thamani kubwa na ndogo mtawalia.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "tr": "Bir TypeScript fonksiyonu `function findMaxMin(a: number, b: number, c: number): [number, number]` yazarak aşağıdaki problemi çözün:\nÜç farklı tamsayının maksimum ve minimumunu bulun.\n\n@param a - Birinci tamsayı.\n@param b - İkinci tamsayı.\n@param c - Üçüncü tamsayı.\n@returns Sırasıyla maksimum ve minimum değerleri içeren bir demet.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "vi": "Viết một hàm TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\n@param a - Số nguyên thứ nhất.\n@param b - Số nguyên thứ hai.\n@param c - Số nguyên thứ ba.\n@returns Một bộ giá trị chứa giá trị lớn nhất và nhỏ nhất tương ứng.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9864037504181619",
      "sw": "0.9528840790970003",
      "tr": "0.9829080543423289",
      "vi": "0.9927168198185937"
    },
    "level": "middle",
    "test": "(() => {\n    let max: number, min: number, result: [number, number];\n\n    result = findMaxMin(1, 2, 3);\n    [max, min] = result;\n    console.assert(max === 3 && min === 1, 'Test failed for input (1, 2, 3)');\n\n    // Additional tests\n    result = findMaxMin(5, 3, 4);\n    [max, min] = result;\n    console.assert(max === 5 && min === 3, 'Test failed for input (5, 3, 4)');\n\n    result = findMaxMin(10, -2, 7);\n    [max, min] = result;\n    console.assert(max === 10 && min === -2, 'Test failed for input (10, -2, 7)');\n\n    result = findMaxMin(-1, -3, -2);\n    [max, min] = result;\n    console.assert(max === -1 && min === -3, 'Test failed for input (-1, -3, -2)');\n})();",
    "entry_point": "findMaxMin",
    "signature": "function findMaxMin(a: number, b: number, c: number): [number, number]",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\n\n@param a - The first integer.\n@param b - The second integer.\n@param c - The third integer.\n@returns A tuple containing the maximum and minimum values respectively.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "es": "Encontrar el máximo y el mínimo de tres enteros distintos.\n\n@param a - El primer entero.\n@param b - El segundo entero.\n@param c - El tercer entero.\n@returns Una tupla que contiene los valores máximo y mínimo respectivamente.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\n\n@param a - العدد الصحيح الأول.\n@param b - العدد الصحيح الثاني.\n@param c - العدد الصحيح الثالث.\n@returns زوج يحتوي على القيمتين القصوى والدنيا على التوالي.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "sw": "Find the maximum and minimum of three distinct integers.\n\n@param a - Integer ya kwanza.\n@param b - Integer ya pili.\n@param c - Integer ya tatu.\n@returns Tuple inayojumuisha thamani za juu na za chini mtawalia.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.\n\n@param a - Birinci tam sayı.\n@param b - İkinci tam sayı.\n@param c - Üçüncü tam sayı.\n@returns Sırasıyla maksimum ve minimum değerleri içeren bir demet.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\n\n@param a - Số nguyên thứ nhất.\n@param b - Số nguyên thứ hai.\n@param c - Số nguyên thứ ba.\n@returns Một bộ giá trị chứa giá trị lớn nhất và nhỏ nhất tương ứng.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9751982161024597",
      "sw": "0.9716890131607163",
      "tr": "0.9787233094746859",
      "vi": "0.9756502988496951"
    }
  },
  {
    "task_id": "TypeScript/5",
    "prompt": {
      "en": "\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * @param xa - x-coordinate of point A\n * @param ya - y-coordinate of point A\n * @param xb - x-coordinate of point B\n * @param yb - y-coordinate of point B\n * @returns The distance between points A and B\n * \n * Example:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "es": "/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n * \n * @param xa - coordenada x del punto A\n * @param ya - coordenada y del punto A\n * @param xb - coordenada x del punto B\n * @param yb - coordenada y del punto B\n * @returns La distancia entre los puntos A y B\n * \n * Ejemplo:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "arb": "/**\n * حساب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n * \n * @param xa - الإحداثي السيني للنقطة A\n * @param ya - الإحداثي الصادي للنقطة A\n * @param xb - الإحداثي السيني للنقطة B\n * @param yb - الإحداثي الصادي للنقطة B\n * @returns المسافة بين النقطتين A و B\n * \n * مثال:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "sw": "/**\n * Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n * \n * @param xa - x-kiwianishi cha pointi A\n * @param ya - y-kiwianishi cha pointi A\n * @param xb - x-kiwianishi cha pointi B\n * @param yb - y-kiwianishi cha pointi B\n * @returns Umbali kati ya pointi A na B\n * \n * Mfano:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "tr": "/**\n * İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n * \n * @param xa - A noktasının x-koordinatı\n * @param ya - A noktasının y-koordinatı\n * @param xb - B noktasının x-koordinatı\n * @param yb - B noktasının y-koordinatı\n * @returns A ve B noktaları arasındaki mesafe\n * \n * Örnek:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "vi": "/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n * \n * @param xa - tọa độ x của điểm A\n * @param ya - tọa độ y của điểm A\n * @param xb - tọa độ x của điểm B\n * @param yb - tọa độ y của điểm B\n * @returns Khoảng cách giữa điểm A và B\n * \n * Ví dụ:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9654973069230968",
      "arb": "0.972711959623046",
      "sw": "0.9944564246956973",
      "tr": "0.9999996027392379",
      "vi": "0.962037165685469"
    },
    "canonical_solution": "{\n    return Math.sqrt((xa - xb) ** 2 + (ya - yb) ** 2);\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - x-coordinate of point A\n@param ya - y-coordinate of point A\n@param xb - x-coordinate of point B\n@param yb - y-coordinate of point B\n@returns The distance between points A and B\n\nExample:\ncalculateDistance(0, 0, 3, 4) === 5",
      "es": "Escribe una función de TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\n@param xa - coordenada x del punto A\n@param ya - coordenada y del punto A\n@param xb - coordenada x del punto B\n@param yb - coordenada y del punto B\n@returns La distancia entre los puntos A y B\n\nEjemplo:\ncalculateDistance(0, 0, 3, 4) === 5",
      "arb": "اكتب دالة TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` لحل المشكلة التالية:\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\n@param xa - الإحداثي السيني للنقطة A\n@param ya - الإحداثي الصادي للنقطة A\n@param xb - الإحداثي السيني للنقطة B\n@param yb - الإحداثي الصادي للنقطة B\n@returns المسافة بين النقطتين A و B\n\nمثال:\ncalculateDistance(0, 0, 3, 4) === 5",
      "sw": "Andika kazi ya TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` kutatua tatizo lifuatalo:\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\n@param xa - x-kiwianishi cha pointi A\n@param ya - y-kiwianishi cha pointi A\n@param xb - x-kiwianishi cha pointi B\n@param yb - y-kiwianishi cha pointi B\n@returns Umbali kati ya pointi A na B\n\nMfano:\ncalculateDistance(0, 0, 3, 4) === 5",
      "tr": "Bir TypeScript fonksiyonu `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` yazın ve aşağıdaki problemi çözün:\nA (xa, ya) ve B (xb, yb) noktaları arasındaki mesafeyi hesaplayın.\n\n@param xa - A noktasının x koordinatı\n@param ya - A noktasının y koordinatı\n@param xb - B noktasının x koordinatı\n@param yb - B noktasının y koordinatı\n@returns A ve B noktaları arasındaki mesafe\n\nÖrnek:\ncalculateDistance(0, 0, 3, 4) === 5",
      "vi": "Viết một hàm TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\n@param xa - tọa độ x của điểm A\n@param ya - tọa độ y của điểm A\n@param xb - tọa độ x của điểm B\n@param yb - tọa độ y của điểm B\n@returns Khoảng cách giữa điểm A và B\n\nVí dụ:\ncalculateDistance(0, 0, 3, 4) === 5"
    },
    "instruction_bertscore": {
      "es": "0.9693469623379339",
      "arb": "0.9730273846681294",
      "sw": "1",
      "tr": "0.9619716176597276",
      "vi": "0.9648934705647507"
    },
    "level": "easy",
    "test": "const testCalculateDistance = (): void => {\n    console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6);\n    console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6);\n    console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    // console.log(\"All test cases passed!\");\n};\n\ntestCalculateDistance();",
    "entry_point": "calculateDistance",
    "signature": "function calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - x-coordinate of point A\n@param ya - y-coordinate of point A\n@param xb - x-coordinate of point B\n@param yb - y-coordinate of point B\n@returns The distance between points A and B\n\nExample:\ncalculateDistance(0, 0, 3, 4) === 5",
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\n@param xa - coordenada x del punto A\n@param ya - coordenada y del punto A\n@param xb - coordenada x del punto B\n@param yb - coordenada y del punto B\n@returns La distancia entre los puntos A y B\n\nEjemplo:\ncalculateDistance(0, 0, 3, 4) === 5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\n@param xa - الإحداثي السيني للنقطة A\n@param ya - الإحداثي الصادي للنقطة A\n@param xb - الإحداثي السيني للنقطة B\n@param yb - الإحداثي الصادي للنقطة B\n@returns المسافة بين النقطتين A و B\n\nمثال:\ncalculateDistance(0, 0, 3, 4) === 5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\n@param xa - x-kiwianishi cha pointi A\n@param ya - y-kiwianishi cha pointi A\n@param xb - x-kiwianishi cha pointi B\n@param yb - y-kiwianishi cha pointi B\n@returns Umbali kati ya pointi A na B\n\nMfano:\ncalculateDistance(0, 0, 3, 4) === 5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\n@param xa - A noktasının x-koordinatı\n@param ya - A noktasının y-koordinatı\n@param xb - B noktasının x-koordinatı\n@param yb - B noktasının y-koordinatı\n@returns A ve B noktaları arasındaki mesafe\n\nÖrnek:\ncalculateDistance(0, 0, 3, 4) === 5",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\n@param xa - tọa độ x của điểm A\n@param ya - tọa độ y của điểm A\n@param xb - tọa độ x của điểm B\n@param yb - tọa độ y của điểm B\n@returns Khoảng cách giữa các điểm A và B\n\nVí dụ:\ncalculateDistance(0, 0, 3, 4) === 5"
    },
    "docstring_bertscore": {
      "es": "0.9512012825088728",
      "arb": "0.9915943595353656",
      "sw": "0.9941902599851106",
      "tr": "1",
      "vi": "0.9512012825088728"
    }
  },
  {
    "task_id": "TypeScript/6",
    "prompt": {
      "en": "\n/**\n * Finds the factorial of N and applies modulo 10007 to the result.\n *\n * Parameters:\n * - N (number): A non-negative integer (N <= 10000).\n *\n * Returns:\n * - number: The factorial of N modulo 10007.\n *\n * Examples:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number",
      "es": "/**\n * Encuentra el factorial de N y aplica el módulo 10007 al resultado.\n *\n * Parámetros:\n * - N (número): Un entero no negativo (N <= 10000).\n *\n * Devuelve:\n * - número: El factorial de N módulo 10007.\n *\n * Ejemplos:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number",
      "arb": "/**\n * يجد العامل المضاعف لـ N ويطبق باقي القسمة 10007 على النتيجة.\n *\n * المعلمات:\n * - N (عدد): عدد صحيح غير سالب (N <= 10000).\n *\n * يعيد:\n * - عدد: العامل المضاعف لـ N باقي القسمة 10007.\n *\n * أمثلة:\n * processRequest(1) // يعيد 1\n * processRequest(2) // يعيد 2\n * processRequest(10) // يعيد 6266\n */\nfunction processRequest(n: number): number",
      "sw": "/**\n * Inapata faktoria ya N na kutumia modulo 10007 kwenye matokeo.\n *\n * Vigezo:\n * - N (nambari): Nambari isiyo hasi (N <= 10000).\n *\n * Inarudisha:\n * - nambari: Faktoria ya N modulo 10007.\n *\n * Mifano:\n * processRequest(1) // inarudisha 1\n * processRequest(2) // inarudisha 2\n * processRequest(10) // inarudisha 6266\n */\nfunction processRequest(n: number): number",
      "tr": "/**\n * N'in faktöriyelini bulur ve sonuca 10007 modunu uygular.\n *\n * Parametreler:\n * - N (sayı): Negatif olmayan bir tam sayı (N <= 10000).\n *\n * Döndürür:\n * - sayı: N'in faktöriyelinin 10007 modunu döndürür.\n *\n * Örnekler:\n * processRequest(1) // 1 döndürür\n * processRequest(2) // 2 döndürür\n * processRequest(10) // 6266 döndürür\n */\nfunction processRequest(n: number): number",
      "vi": "/**\n * Tìm giai thừa của N và áp dụng phép chia dư 10007 cho kết quả.\n *\n * Tham số:\n * - N (number): Một số nguyên không âm (N <= 10000).\n *\n * Trả về:\n * - number: Giai thừa của N chia dư 10007.\n *\n * Ví dụ:\n * processRequest(1) // trả về 1\n * processRequest(2) // trả về 2\n * processRequest(10) // trả về 6266\n */\nfunction processRequest(n: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9930068201749047",
      "arb": "0.9406367284327702",
      "sw": "0.9956495973945739",
      "tr": "0.9873976968448605",
      "vi": "0.9911947152087234"
    },
    "canonical_solution": "{\n    let a: number[] = Array(10001).fill(0);\n    a[0] = 1;\n    a[1] = 1;\n    for (let i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function processRequest(n: number): number` to solve the following problem:\nFinds the factorial of N and applies modulo 10007 to the result.\n\nParameters:\n- N (number): A non-negative integer (N <= 10000).\n\nReturns:\n- number: The factorial of N modulo 10007.\n\nExamples:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "es": "Escribe una función de TypeScript `function processRequest(n: number): number` para resolver el siguiente problema:\nEncuentra el factorial de N y aplica el módulo 10007 al resultado.\n\nParámetros:\n- N (number): Un entero no negativo (N <= 10000).\n\nDevuelve:\n- number: El factorial de N módulo 10007.\n\nEjemplos:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "arb": "اكتب دالة TypeScript `function processRequest(n: number): number` لحل المشكلة التالية:\nإيجاد مضروب N وتطبيق باقي القسمة 10007 على النتيجة.\n\nالمعطيات:\n- N (number): عدد صحيح غير سالب (N <= 10000).\n\nالقيم المعادة:\n- number: مضروب N باقي القسمة 10007.\n\nأمثلة:\nprocessRequest(1) // يعيد 1\nprocessRequest(2) // يعيد 2\nprocessRequest(10) // يعيد 6266",
      "sw": "Andika kazi ya TypeScript `function processRequest(n: number): number` kutatua tatizo lifuatalo:\nInapata factorial ya N na inatumia modulo 10007 kwenye matokeo.\n\nVigezo:\n- N (number): Nambari isiyo hasi (N <= 10000).\n\nInarejesha:\n- number: Factorial ya N modulo 10007.\n\nMifano:\nprocessRequest(1) // inarejesha 1\nprocessRequest(2) // inarejesha 2\nprocessRequest(10) // inarejesha 6266",
      "tr": "Bir TypeScript fonksiyonu `function processRequest(n: number): number` yazın ve aşağıdaki problemi çözün:\nN'in faktöriyelini bulur ve sonuca 10007 modunu uygular.\n\nParametreler:\n- N (number): Negatif olmayan bir tam sayı (N <= 10000).\n\nDöndürülen:\n- number: N'in faktöriyelinin 10007 modundaki değeri.\n\nÖrnekler:\nprocessRequest(1) // 1 döndürür\nprocessRequest(2) // 2 döndürür\nprocessRequest(10) // 6266 döndürür",
      "vi": "Viết một hàm TypeScript `function processRequest(n: number): number` để giải quyết vấn đề sau:\nTìm giai thừa của N và áp dụng modulo 10007 cho kết quả.\n\nTham số:\n- N (number): Một số nguyên không âm (N <= 10000).\n\nTrả về:\n- number: Giai thừa của N modulo 10007.\n\nVí dụ:\nprocessRequest(1) // trả về 1\nprocessRequest(2) // trả về 2\nprocessRequest(10) // trả về 6266"
    },
    "instruction_bertscore": {
      "es": "0.9931160668844738",
      "arb": "0.9396384121376888",
      "sw": "0.9799280027356625",
      "tr": "0.9758121826102386",
      "vi": "0.9903811251680045"
    },
    "level": "easy",
    "test": "const testProcessRequest = () => {\n    console.assert(processRequest(0) === 1, \"processRequest(0) should return 1\"); // Added test for boundary condition\n    console.assert(processRequest(1) === 1, \"processRequest(1) should return 1\");\n    console.assert(processRequest(2) === 2, \"processRequest(2) should return 2\");\n    console.assert(processRequest(3) === 6, \"processRequest(3) should return 6\");\n    console.assert(processRequest(4) === 24, \"processRequest(4) should return 24\");\n    console.assert(processRequest(10) === 6266, \"processRequest(10) should return 6266\"); // 10! % 10007 = 3628800 % 10007 = 6266\n    console.assert(processRequest(10000) === 6991, \"processRequest(10000) should return 6991\"); // Added a test for upper boundary condition\n};\n\ntestProcessRequest();",
    "entry_point": "processRequest",
    "signature": "function processRequest(n: number): number",
    "docstring": {
      "en": "Finds the factorial of N and applies modulo 10007 to the result.\n\nParameters:\n- N (number): A non-negative integer (N <= 10000).\n\nReturns:\n- number: The factorial of N modulo 10007.\n\nExamples:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "es": "Encuentra el factorial de N y aplica el módulo 10007 al resultado.\n\nParámetros:\n- N (number): Un entero no negativo (N <= 10000).\n\nDevuelve:\n- number: El factorial de N módulo 10007.\n\nEjemplos:\nprocessRequest(1) // devuelve 1\nprocessRequest(2) // devuelve 2\nprocessRequest(10) // devuelve 6266",
      "arb": "يجد العامل لـ N ويطبق باقي القسمة 10007 على النتيجة.\n\nالمعلمات:\n- N (number): عدد صحيح غير سالب (N <= 10000).\n\nالقيم المعادة:\n- number: العامل لـ N باقي القسمة 10007.\n\nأمثلة:\nprocessRequest(1) // يعيد 1\nprocessRequest(2) // يعيد 2\nprocessRequest(10) // يعيد 6266",
      "sw": "Inapata faktoria ya N na inatumia modulo 10007 kwenye matokeo.\n\nVigezo:\n- N (nambari): Nambari isiyo hasi (N <= 10000).\n\nRudisha:\n- nambari: Faktoria ya N modulo 10007.\n\nMifano:\nprocessRequest(1) // inarudisha 1\nprocessRequest(2) // inarudisha 2\nprocessRequest(10) // inarudisha 6266",
      "tr": "N'nin faktöriyelini bulur ve sonuca 10007 modunu uygular.\n\nParametreler:\n- N (number): Negatif olmayan bir tamsayı (N <= 10000).\n\nDöndürür:\n- number: N'nin faktöriyelinin 10007 modundaki değeri.\n\nÖrnekler:\nprocessRequest(1) // 1 döndürür\nprocessRequest(2) // 2 döndürür\nprocessRequest(10) // 6266 döndürür",
      "vi": "Tìm giai thừa của N và áp dụng modulo 10007 cho kết quả.\n\nTham số:\n- N (number): Một số nguyên không âm (N <= 10000).\n\nTrả về:\n- number: Giai thừa của N modulo 10007.\n\nVí dụ:\nprocessRequest(1) // trả về 1\nprocessRequest(2) // trả về 2\nprocessRequest(10) // trả về 6266"
    },
    "docstring_bertscore": {
      "es": "0.9731670218259969",
      "arb": "0.9328619380583026",
      "sw": "0.9876608820997317",
      "tr": "0.9668400482988927",
      "vi": "0.9874483475920244"
    }
  },
  {
    "task_id": "TypeScript/7",
    "prompt": {
      "en": "\n/**\n * Calculate the area of a triangle given its base and height.\n * \n * @param base The base length of the triangle.\n * @param height The height of the triangle.\n * \n * @returns The calculated area of the triangle, rounded to one decimal place.\n * \n * Examples:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "es": "/**\n * Calcular el área de un triángulo dado su base y altura.\n * \n * @param base La longitud de la base del triángulo.\n * @param height La altura del triángulo.\n * \n * @returns El área calculada del triángulo, redondeada a un decimal.\n * \n * Ejemplos:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "arb": "/**\n * احسب مساحة المثلث المعطى قاعدته وارتفاعه.\n * \n * @param base طول قاعدة المثلث.\n * @param height ارتفاع المثلث.\n * \n * @returns المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n * \n * أمثلة:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "sw": "/**\n * Hesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n * \n * @param base Urefu wa msingi wa pembetatu.\n * @param height Urefu wa pembetatu.\n * \n * @returns Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n * \n * Mifano:\n * calculateTriangleArea(1, 2) inarudisha 1.0\n * calculateTriangleArea(3, 4) inarudisha 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "tr": "/**\n * Üçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\n * \n * @param base Üçgenin taban uzunluğu.\n * @param height Üçgenin yüksekliği.\n * \n * @returns Hesaplanan üçgenin alanı, bir ondalık basamağa yuvarlanmış olarak.\n * \n * Örnekler:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "vi": "/**\n * Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n * \n * @param base Chiều dài đáy của tam giác.\n * @param height Chiều cao của tam giác.\n * \n * @returns Diện tích đã được tính của tam giác, làm tròn đến một chữ số thập phân.\n * \n * Ví dụ:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9885896777614509",
      "arb": "0.9920871615107132",
      "sw": "0.990275851066056",
      "tr": "0.9922252096255324",
      "vi": "0.9784319187057077"
    },
    "canonical_solution": "{\n    return (base * height) / 2.0;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateTriangleArea(base: number, height: number): number` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n\n@param base The base length of the triangle.\n@param height The height of the triangle.\n\n@returns The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0\n",
      "es": "Escribe una función de TypeScript `function calculateTriangleArea(base: number, height: number): number` para resolver el siguiente problema:\nCalcular el área de un triángulo dada su base y altura.\n\n@param base La longitud de la base del triángulo.\n@param height La altura del triángulo.\n\n@returns El área calculada del triángulo, redondeada a un decimal.\n\nEjemplos:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "arb": "اكتب دالة TypeScript `function calculateTriangleArea(base: number, height: number): number` لحل المشكلة التالية:\nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.\n\n@param base طول قاعدة المثلث.\n@param height ارتفاع المثلث.\n\n@returns المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n\nأمثلة:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "sw": "Andika kazi ya TypeScript `function calculateTriangleArea(base: number, height: number): number` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukitumia msingi wake na urefu.\n\n@param base Urefu wa msingi wa pembetatu.\n@param height Urefu wa pembetatu.\n\n@returns Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\nMifano:\ncalculateTriangleArea(1, 2) inarudisha 1.0\ncalculateTriangleArea(3, 4) inarudisha 6.0",
      "tr": "Bir TypeScript fonksiyonu `function calculateTriangleArea(base: number, height: number): number` yazın ve aşağıdaki problemi çözün:\nÜçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\n\n@param base Üçgenin taban uzunluğu.\n@param height Üçgenin yüksekliği.\n\n@returns Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n\nÖrnekler:\ncalculateTriangleArea(1, 2) 1.0 döndürür\ncalculateTriangleArea(3, 4) 6.0 döndürür",
      "vi": "Viết một hàm TypeScript `function calculateTriangleArea(base: number, height: number): number` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n\n@param base Độ dài đáy của tam giác.\n@param height Chiều cao của tam giác.\n\n@returns Diện tích đã tính của tam giác, được làm tròn đến một chữ số thập phân.\n\nVí dụ:\ncalculateTriangleArea(1, 2) trả về 1.0\ncalculateTriangleArea(3, 4) trả về 6.0"
    },
    "instruction_bertscore": {
      "es": "0.9882972938405675",
      "arb": "0.9913824209188014",
      "sw": "0.9858823456679453",
      "tr": "0.9912018659024406",
      "vi": "0.9856914618717708"
    },
    "level": "easy",
    "test": "const testCalculateTriangleArea = () => {\n    // The equivalent of C's assertion with a floating-point comparison in TypeScript.\n    const assertCloseTo = (value: number, expected: number, tolerance: number = 1e-6) => {\n        console.assert(Math.abs(value - expected) < tolerance);\n    };\n\n    assertCloseTo(calculateTriangleArea(1, 2), 1.0);\n    assertCloseTo(calculateTriangleArea(3, 4), 6.0);\n    assertCloseTo(calculateTriangleArea(5, 8), 20.0);\n    assertCloseTo(calculateTriangleArea(7, 3), 10.5);\n    assertCloseTo(calculateTriangleArea(10, 10), 50.0);\n\n    // Uncomment to log the outcome to the console.\n    // console.log(\"All tests passed.\");\n};\n\ntestCalculateTriangleArea();",
    "entry_point": "calculateTriangleArea",
    "signature": "function calculateTriangleArea(base: number, height: number): number",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n\n@param base The base length of the triangle.\n@param height The height of the triangle.\n\n@returns The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0\n",
      "es": "Calcular el área de un triángulo dado su base y altura.\n\n@param base La longitud de la base del triángulo.\n@param height La altura del triángulo.\n\n@returns El área calculada del triángulo, redondeada a un decimal.\n\nEjemplos:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "arb": "احسب مساحة المثلث المعطى قاعدته وارتفاعه.\n\n@param base طول قاعدة المثلث.\n@param height ارتفاع المثلث.\n\n@returns المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n\nأمثلة:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "sw": "Hesabu eneo la pembetatu ukitumia msingi wake na urefu.\n\n@param base Urefu wa msingi wa pembetatu.\n@param height Urefu wa pembetatu.\n\n@returns Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\nMifano:\ncalculateTriangleArea(1, 2) inarudisha 1.0\ncalculateTriangleArea(3, 4) inarudisha 6.0",
      "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n\n@param base Üçgenin taban uzunluğu.\n@param height Üçgenin yüksekliği.\n\n@returns Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\nÖrnekler:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n\n@param base Chiều dài đáy của tam giác.\n@param height Chiều cao của tam giác.\n\n@returns Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\nVí dụ:\ncalculateTriangleArea(1, 2) trả về 1.0\ncalculateTriangleArea(3, 4) trả về 6.0"
    },
    "docstring_bertscore": {
      "es": "0.9855998932661137",
      "arb": "0.9689777084595901",
      "sw": "0.9669715416111377",
      "tr": "1",
      "vi": "0.9742094340656681"
    }
  },
  {
    "task_id": "TypeScript/8",
    "prompt": {
      "en": "\n/**\n * Calculate the Hamming distance between two integers in binary representation.\n * Parameters:\n * - x (number): The first positive integer (x <= 1,000,000,000).\n * - y (number): The second positive integer (y <= 1,000,000,000).\n * Returns:\n * - number: The Hamming distance between x and y, i.e., the number of bits\n *           that need to be flipped to transform x into y in binary.\n * Example usage:\n *   hamming_distance(1, 2); // returns 2\n *   hamming_distance(4, 7); // returns 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "es": "/**\n * Calcular la distancia de Hamming entre dos enteros en representación binaria.\n * Parámetros:\n * - x (number): El primer entero positivo (x <= 1,000,000,000).\n * - y (number): El segundo entero positivo (y <= 1,000,000,000).\n * Devuelve:\n * - number: La distancia de Hamming entre x e y, es decir, el número de bits\n *           que necesitan ser cambiados para transformar x en y en binario.\n * Ejemplo de uso:\n *   hamming_distance(1, 2); // returns 2\n *   hamming_distance(4, 7); // returns 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "arb": "/**\n * حساب مسافة هامنج بين عددين في التمثيل الثنائي.\n * المعطيات:\n * - x (عدد): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n * - y (عدد): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n * يعيد:\n * - عدد: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى التبديل لتحويل x إلى y في الثنائي.\n * مثال على الاستخدام:\n *   hamming_distance(1, 2); // يعيد 2\n *   hamming_distance(4, 7); // يعيد 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "sw": "/**\n * Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n * Vigezo:\n * - x (nambari): Nambari ya kwanza chanya (x <= 1,000,000,000).\n * - y (nambari): Nambari ya pili chanya (y <= 1,000,000,000).\n * Inarudisha:\n * - nambari: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti\n *           zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n * Mfano wa matumizi:\n *   hamming_distance(1, 2); // inarudisha 2\n *   hamming_distance(4, 7); // inarudisha 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "tr": "/**\n * İki tamsayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n * Parametreler:\n * - x (number): İlk pozitif tamsayı (x <= 1,000,000,000).\n * - y (number): İkinci pozitif tamsayı (y <= 1,000,000,000).\n * Döndürür:\n * - number: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için\n *           çevrilmesi gereken bit sayısı.\n * Örnek kullanım:\n *   hamming_distance(1, 2); // 2 döndürür\n *   hamming_distance(4, 7); // 2 döndürür\n */\nfunction hamming_distance(x: number, y: number): number",
      "vi": "/**\n * Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n * Tham số:\n * - x (number): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n * - y (number): Số nguyên dương thứ hai (y <= 1,000,000,000).\n * Trả về:\n * - number: Khoảng cách Hamming giữa x và y, tức là số bit\n *           cần phải lật để biến đổi x thành y trong nhị phân.\n * Ví dụ sử dụng:\n *   hamming_distance(1, 2); // trả về 2\n *   hamming_distance(4, 7); // trả về 2\n */\nfunction hamming_distance(x: number, y: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9901616385969609",
      "arb": "0.9818962311813372",
      "sw": "0.9832375821444658",
      "tr": "0.9858583113918401",
      "vi": "0.9921972027418064"
    },
    "canonical_solution": "{\n    let distance = 0;\n    let xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n\n    // Count the number of bits set in xor_result\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>>= 1;\n    }\n\n    return distance;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function hamming_distance(x: number, y: number): number` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): The first positive integer (x <= 1,000,000,000).\n- y (number): The second positive integer (y <= 1,000,000,000).\nReturns:\n- number: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "es": "Escribe una función de TypeScript `function hamming_distance(x: number, y: number): number` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\nParámetros:\n- x (number): El primer entero positivo (x <= 1,000,000,000).\n- y (number): El segundo entero positivo (y <= 1,000,000,000).\nDevuelve:\n- number: La distancia de Hamming entre x e y, es decir, el número de bits que deben cambiarse para transformar x en y en binario.\nEjemplo de uso:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "arb": "اكتب دالة TypeScript `function hamming_distance(x: number, y: number): number` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\nالمعطيات:\n- x (number): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (number): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\nالمخرجات:\n- number: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى التغيير لتحويل x إلى y في النظام الثنائي.\nمثال على الاستخدام:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "sw": "Andika kazi ya TypeScript `function hamming_distance(x: number, y: number): number` kutatua tatizo lifuatalo:\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\nVigezo:\n- x (number): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (number): Nambari ya pili chanya (y <= 1,000,000,000).\nInarudisha:\n- number: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y katika binary.\nMfano wa matumizi:\n  hamming_distance(1, 2); // inarudisha 2\n  hamming_distance(4, 7); // inarudisha 2",
      "tr": "Bir TypeScript fonksiyonu `function hamming_distance(x: number, y: number): number` yazın ve aşağıdaki problemi çözün:\nİki tam sayının ikili gösteriminde Hamming mesafesini hesaplayın.\nParametreler:\n- x (number): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (number): İkinci pozitif tam sayı (y <= 1,000,000,000).\nDöndürülenler:\n- number: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için değiştirilmesi gereken bit sayısı.\nÖrnek kullanım:\n  hamming_distance(1, 2); // 2 döndürür\n  hamming_distance(4, 7); // 2 döndürür",
      "vi": "Viết một hàm TypeScript `function hamming_distance(x: number, y: number): number` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\nTham số:\n- x (number): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (number): Số nguyên dương thứ hai (y <= 1,000,000,000).\nTrả về:\n- number: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi để biến đổi x thành y trong nhị phân.\nVí dụ sử dụng:\n  hamming_distance(1, 2); // trả về 2\n  hamming_distance(4, 7); // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9880029236158738",
      "arb": "0.9730516175746157",
      "sw": "0.976321669537593",
      "tr": "0.9704747856414501",
      "vi": "0.9849326938162175"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(hamming_distance(1, 2) === 2, '01 and 10 have 2 different bits');\n    console.assert(hamming_distance(4, 7) === 2, '100 and 111 have 2 different bits');\n    console.assert(hamming_distance(25, 30) === 3, '11001 and 11110 have 3 different bits');\n    console.assert(hamming_distance(0, 0) === 0, 'Same numbers have 0 different bits');\n    console.assert(hamming_distance(0xFFFFFFF, 0) === 28, 'Max unsigned int and 0 have 28 different bits');\n\n    // If no assertion fails, log success message to the console\n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "hamming_distance",
    "signature": "function hamming_distance(x: number, y: number): number",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): The first positive integer (x <= 1,000,000,000).\n- y (number): The second positive integer (y <= 1,000,000,000).\nReturns:\n- number: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\nParámetros:\n- x (número): El primer entero positivo (x <= 1,000,000,000).\n- y (número): El segundo entero positivo (y <= 1,000,000,000).\nDevuelve:\n- número: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados para transformar x en y en binario.\nEjemplo de uso:\n  hamming_distance(1, 2); // devuelve 2\n  hamming_distance(4, 7); // devuelve 2",
      "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\nالمعلمات:\n- x (number): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (number): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\nالقيم المعادة:\n- number: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى تغيير لتحويل x إلى y في النظام الثنائي.\nمثال على الاستخدام:\n  hamming_distance(1, 2); // يعيد 2\n  hamming_distance(4, 7); // يعيد 2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\nVigezo:\n- x (nambari): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (nambari): Nambari ya pili chanya (y <= 1,000,000,000).\nRudisha:\n- nambari: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\nMfano wa matumizi:\n  hamming_distance(1, 2); // inarudisha 2\n  hamming_distance(4, 7); // inarudisha 2",
      "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\nParametreler:\n- x (number): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (number): İkinci pozitif tamsayı (y <= 1,000,000,000).\nDöndürür:\n- number: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\nÖrnek kullanım:\n  hamming_distance(1, 2); // 2 döndürür\n  hamming_distance(4, 7); // 2 döndürür",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.  \nTham số:  \n- x (number): Số nguyên dương đầu tiên (x <= 1,000,000,000).  \n- y (number): Số nguyên dương thứ hai (y <= 1,000,000,000).  \nTrả về:  \n- number: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.  \nVí dụ sử dụng:  \n  hamming_distance(1, 2); // trả về 2  \n  hamming_distance(4, 7); // trả về 2  "
    },
    "docstring_bertscore": {
      "es": "0.9866413123538796",
      "arb": "0.9777853768154391",
      "sw": "0.9747401744437932",
      "tr": "0.9961414062180163",
      "vi": "0.9882188348400587"
    }
  },
  {
    "task_id": "TypeScript/9",
    "prompt": {
      "en": "\n/**\n * Counts the number of odd integers in a given list of numbers.\n * \n * @param count - The count of numbers to evaluate.\n * @param numbers - A list of integers to be checked for oddness.\n * @returns The count of odd numbers in the input list.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "es": "/**\n * Cuenta el número de enteros impares en una lista dada de números.\n * \n * @param count - La cantidad de números a evaluar.\n * @param numbers - Una lista de enteros que se comprobarán para imparidad.\n * @returns La cantidad de números impares en la lista de entrada.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "arb": "/**\n * يحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n * \n * @param count - عدد الأرقام التي سيتم تقييمها.\n * @param numbers - قائمة من الأعداد الصحيحة التي سيتم التحقق من فرديتها.\n * @returns عدد الأعداد الفردية في قائمة الإدخال.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "sw": "/**\n * Inahesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n * \n * @param count - Idadi ya nambari za kutathmini.\n * @param numbers - Orodha ya nambari za kuangaliwa kama ni zisizo za kawaida.\n * @returns Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "tr": "/**\n * Verilen bir sayı listesindeki tek sayıların sayısını hesaplar.\n * \n * @param count - Değerlendirilecek sayıların sayısı.\n * @param numbers - Teklik açısından kontrol edilecek tamsayıların listesi.\n * @returns Girdi listesindeki tek sayıların sayısı.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "vi": "/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n * \n * @param count - Số lượng số cần đánh giá.\n * @param numbers - Một danh sách các số nguyên cần kiểm tra tính lẻ.\n * @returns Số lượng số lẻ trong danh sách đầu vào.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // trả về 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.986785915271273",
      "arb": "0.9804704623062688",
      "sw": "0.9682813103436818",
      "tr": "0.9836048497189993",
      "vi": "0.9809362505497956"
    },
    "canonical_solution": "{\n    let ans = 0;\n    numbers.slice(0, count).forEach(num => {\n        if (num % 2 === 1)\n            ans++;\n    });\n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countOddNumbers(count: number, numbers: number[]): number` to solve the following problem:\nCounts the number of odd integers in a given list of numbers.\n\n@param count - The count of numbers to evaluate.\n@param numbers - A list of integers to be checked for oddness.\n@returns The count of odd numbers in the input list.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "es": "Escribe una función de TypeScript `function countOddNumbers(count: number, numbers: number[]): number` para resolver el siguiente problema:\nCuenta el número de enteros impares en una lista dada de números.\n\n@param count - La cantidad de números a evaluar.\n@param numbers - Una lista de enteros que se comprobarán para imparidad.\n@returns La cantidad de números impares en la lista de entrada.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "arb": "اكتب دالة TypeScript `function countOddNumbers(count: number, numbers: number[]): number` لحل المشكلة التالية:\nتحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\n@param count - عدد الأرقام التي سيتم تقييمها.\n@param numbers - قائمة من الأعداد الصحيحة التي سيتم التحقق من فرديتها.\n@returns عدد الأعداد الفردية في القائمة المدخلة.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "sw": "Andika kazi ya TypeScript `function countOddNumbers(count: number, numbers: number[]): number` kutatua tatizo lifuatalo:\nHesabu idadi ya nambari zisizo za jozi katika orodha iliyotolewa ya nambari.\n\n@param count - Idadi ya nambari za kutathmini.\n@param numbers - Orodha ya nambari za kuangaliwa kama sio za jozi.\n@returns Idadi ya nambari zisizo za jozi katika orodha ya ingizo.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "tr": "Bir TypeScript fonksiyonu `function countOddNumbers(count: number, numbers: number[]): number` yazın:\nVerilen bir sayı listesindeki tek sayıların sayısını sayar.\n\n@param count - Değerlendirilecek sayıların sayısı.\n@param numbers - Tek olup olmadıkları kontrol edilecek tam sayıların listesi.\n@returns Girdi listesindeki tek sayıların sayısı.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "vi": "Viết một hàm TypeScript `function countOddNumbers(count: number, numbers: number[]): number` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\n@param count - Số lượng số cần đánh giá.\n@param numbers - Một danh sách các số nguyên cần kiểm tra tính lẻ.\n@returns Số lượng số lẻ trong danh sách đầu vào.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```"
    },
    "instruction_bertscore": {
      "es": "0.9888314109351704",
      "arb": "0.9796036393234325",
      "sw": "0.9675173778982217",
      "tr": "0.9665421027273403",
      "vi": "0.9835154660475336"
    },
    "level": "easy",
    "test": "const testCountOddNumbers = (): void => {\n    console.assert(countOddNumbers(5, [1, 4, 3, 2, 5]) === 3, \"Test 1 failed\");\n    console.assert(countOddNumbers(4, [2, 2, 0, 0]) === 0, \"Test 2 failed\");\n    console.assert(countOddNumbers(6, [7, 7, 8, 1, 9, 10]) === 4, \"Test 3 failed\");\n    // console.log(\"All tests passed!\");\n};\n\ntestCountOddNumbers();",
    "entry_point": "countOddNumbers",
    "signature": "function countOddNumbers(count: number, numbers: number[]): number",
    "docstring": {
      "en": "Counts the number of odd integers in a given list of numbers.\n\n@param count - The count of numbers to evaluate.\n@param numbers - A list of integers to be checked for oddness.\n@returns The count of odd numbers in the input list.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "es": "Cuenta el número de enteros impares en una lista dada de números.\n\n@param count - La cantidad de números a evaluar.\n@param numbers - Una lista de enteros que se verificarán para imparidad.\n@returns La cantidad de números impares en la lista de entrada.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "arb": "يحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n\n@param count - عدد الأرقام التي سيتم تقييمها.\n@param numbers - قائمة من الأعداد الصحيحة التي سيتم التحقق من فرديتها.\n@returns عدد الأعداد الفردية في القائمة المدخلة.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n\n@param count - Idadi ya nambari za kutathmini.\n@param numbers - Orodha ya nambari za kipekee za kuangaliwa kama ni zisizo za kawaida.\n@returns Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "tr": "Verilen bir sayı listesindeki tek sayıların sayısını sayar.\n\n@param count - Değerlendirilecek sayıların sayısı.\n@param numbers - Tek olup olmadıkları kontrol edilecek tamsayıların listesi.\n@returns Girdi listesindeki tek sayıların sayısı.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n\n@param count - Số lượng số cần đánh giá.\n@param numbers - Một danh sách các số nguyên cần được kiểm tra tính lẻ.\n@returns Số lượng số lẻ trong danh sách đầu vào.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```"
    },
    "docstring_bertscore": {
      "es": "0.9830544449331516",
      "arb": "0.9714808485213918",
      "sw": "0.9510652206978639",
      "tr": "0.9850788857766593",
      "vi": "0.9844236041496252"
    }
  },
  {
    "task_id": "TypeScript/10",
    "prompt": {
      "en": "\n/**\n * Calculate the sum of even numbers in a given list.\n * \n * @param numbers An array of integers.\n * @param size The size of the array.\n * @returns The sum of even numbers in the input array.\n * \n * Examples:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Returns 4\n * calculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "es": "/**\n * Calcular la suma de números pares en una lista dada.\n * \n * @param numbers Un arreglo de enteros.\n * @param size El tamaño del arreglo.\n * @returns La suma de los números pares en el arreglo de entrada.\n * \n * Ejemplos:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Devuelve 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Devuelve 4\n * calculateEvenSum([7, 11, 19], 3); // Devuelve 0 (sin números pares)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "arb": "/**\n * حساب مجموع الأعداد الزوجية في قائمة معينة.\n * \n * @param numbers مصفوفة من الأعداد الصحيحة.\n * @param size حجم المصفوفة.\n * @returns مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * \n * أمثلة:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Returns 4\n * calculateEvenSum([7, 11, 19], 3); // Returns 0 (لا توجد أعداد زوجية)\n */",
      "sw": "/**\n * Hesabu jumla ya nambari shufwa katika orodha iliyotolewa.\n * \n * @param numbers Mfululizo wa nambari za mzima.\n * @param size Ukubwa wa mfululizo.\n * @returns Jumla ya nambari shufwa katika mfululizo wa ingizo.\n * \n * Mifano:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Inarudisha 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Inarudisha 4\n * calculateEvenSum([7, 11, 19], 3); // Inarudisha 0 (hakuna nambari shufwa)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "tr": "/**\n * Verilen bir listedeki çift sayıların toplamını hesapla.\n * \n * @param numbers Bir tamsayı dizisi.\n * @param size Dizinin boyutu.\n * @returns Girdi dizisindeki çift sayıların toplamı.\n * \n * Örnekler:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // 6 döndürür\n * calculateEvenSum([2, 2, 0, 0], 4); // 4 döndürür\n * calculateEvenSum([7, 11, 19], 3); // 0 döndürür (çift sayı yok)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "vi": "/**\n * Tính tổng các số chẵn trong một danh sách cho trước.\n * \n * @param numbers Một mảng các số nguyên.\n * @param size Kích thước của mảng.\n * @returns Tổng các số chẵn trong mảng đầu vào.\n * \n * Ví dụ:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Trả về 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Trả về 4\n * calculateEvenSum([7, 11, 19], 3); // Trả về 0 (không có số chẵn nào)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number"
    },
    "prompt_bertscore": {
      "es": "0.996623482152788",
      "arb": "0.9382124446322394",
      "sw": "0.9743359616183873",
      "tr": "0.9979133878472285",
      "vi": "0.9985609228894022"
    },
    "canonical_solution": "{\n    let sum = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            sum += numbers[i];\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateEvenSum(numbers: number[], size: number): number` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n\n@param numbers An array of integers.\n@param size The size of the array.\n@returns The sum of even numbers in the input array.\n\nExamples:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)",
      "es": "Escribe una función de TypeScript `function calculateEvenSum(numbers: number[], size: number): number` para resolver el siguiente problema:\nCalcular la suma de los números pares en una lista dada.\n\n@param numbers Un arreglo de enteros.\n@param size El tamaño del arreglo.\n@returns La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Devuelve 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Devuelve 4\ncalculateEvenSum([7, 11, 19], 3); // Devuelve 0 (no hay números pares)",
      "arb": "اكتب دالة TypeScript `function calculateEvenSum(numbers: number[], size: number): number` لحل المشكلة التالية:\nاحسب مجموع الأعداد الزوجية في قائمة معينة.\n\n@param numbers مصفوفة من الأعداد الصحيحة.\n@param size حجم المصفوفة.\n@returns مجموع الأعداد الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)",
      "sw": "Andika kazi ya TypeScript `function calculateEvenSum(numbers: number[], size: number): number` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\n\n@param numbers Mfululizo wa namba nzima.\n@param size Ukubwa wa mfululizo.\n@returns Jumla ya namba shufwa katika mfululizo wa ingizo.\n\nMifano:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Inarudisha 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Inarudisha 4\ncalculateEvenSum([7, 11, 19], 3); // Inarudisha 0 (hakuna namba shufwa)",
      "tr": "Bir TypeScript fonksiyonu `function calculateEvenSum(numbers: number[], size: number): number` yazın ve aşağıdaki problemi çözün:\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\n\n@param numbers Bir tamsayı dizisi.\n@param size Dizinin boyutu.\n@returns Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 6 döndürür\ncalculateEvenSum([2, 2, 0, 0], 4); // 4 döndürür\ncalculateEvenSum([7, 11, 19], 3); // 0 döndürür (çift sayı yok)",
      "vi": "Viết một hàm TypeScript `function calculateEvenSum(numbers: number[], size: number): number` để giải quyết vấn đề sau:\nTính tổng các số chẵn trong một danh sách cho trước.\n\n@param numbers Một mảng các số nguyên.\n@param size Kích thước của mảng.\n@returns Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Trả về 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Trả về 4\ncalculateEvenSum([7, 11, 19], 3); // Trả về 0 (không có số chẵn nào)"
    },
    "instruction_bertscore": {
      "es": "0.9906663583951706",
      "arb": "1",
      "sw": "0.9966401671047949",
      "tr": "0.995849816818657",
      "vi": "0.9989119027726909"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6, \"Test 1 failed\");\n    console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4, \"Test 2 failed\");\n    console.assert(calculateEvenSum([7, 11, 19], 3) === 0, \"Test 3 failed - no even numbers\");\n    console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20), \"Test 4 failed - all even numbers\");\n    // console.log(\"All tests passed successfully.\");\n})();",
    "entry_point": "calculateEvenSum",
    "signature": "function calculateEvenSum(numbers: number[], size: number): number",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\n\n@param numbers An array of integers.\n@param size The size of the array.\n@returns The sum of even numbers in the input array.\n\nExamples:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)",
      "es": "Calcular la suma de números pares en una lista dada.\n\n@param numbers Un arreglo de enteros.\n@param size El tamaño del arreglo.\n@returns La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Devuelve 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Devuelve 4\ncalculateEvenSum([7, 11, 19], 3); // Devuelve 0 (no hay números pares)",
      "arb": "احسب مجموع الأعداد الزوجية في قائمة معينة.\n\n@param numbers مصفوفة من الأعداد الصحيحة.\n@param size حجم المصفوفة.\n@returns مجموع الأعداد الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // يعيد 6\ncalculateEvenSum([2, 2, 0, 0], 4); // يعيد 4\ncalculateEvenSum([7, 11, 19], 3); // يعيد 0 (لا توجد أعداد زوجية)",
      "sw": "Hesabu jumla ya nambari za jozi katika orodha iliyotolewa.\n\n@param numbers Mfululizo wa nambari za mzima.\n@param size Ukubwa wa mfululizo.\n@returns Jumla ya nambari za jozi katika mfululizo wa ingizo.\n\nMifano:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Inarudisha 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Inarudisha 4\ncalculateEvenSum([7, 11, 19], 3); // Inarudisha 0 (hakuna nambari za jozi)",
      "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.\n\n@param numbers Bir tamsayı dizisi.\n@param size Dizinin boyutu.\n@returns Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 6 döndürür\ncalculateEvenSum([2, 2, 0, 0], 4); // 4 döndürür\ncalculateEvenSum([7, 11, 19], 3); // 0 döndürür (çift sayı yok)",
      "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\n\n@param numbers Một mảng các số nguyên.\n@param size Kích thước của mảng.\n@returns Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Trả về 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Trả về 4\ncalculateEvenSum([7, 11, 19], 3); // Trả về 0 (không có số chẵn)"
    },
    "docstring_bertscore": {
      "es": "0.9959954128879556",
      "arb": "0.9976412642252107",
      "sw": "0.9259378816058075",
      "tr": "0.9976412642252107",
      "vi": "0.9988999849498288"
    }
  },
  {
    "task_id": "TypeScript/11",
    "prompt": {
      "en": "\n/**\n * Determine if two closed intervals intersect.\n * Args:\n *    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n *    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true if the intervals intersect, false otherwise.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "es": "/**\n * Determinar si dos intervalos cerrados se intersectan.\n * Args:\n *    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n *    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n * Returns:\n *    booleano: true si los intervalos se intersectan, false en caso contrario.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "arb": "/**\n * تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n * Args:\n *    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n *    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true إذا كانت الفترات تتقاطع، false خلاف ذلك.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "sw": "/**\n * Tambua kama vipindi viwili vilivyofungwa vinakatana.\n * Args:\n *    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n *    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: kweli ikiwa vipindi vinakatana, vinginevyo si kweli.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "tr": "/**\n * İki kapalı aralığın kesişip kesişmediğini belirleyin.\n * Args:\n *    a, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\n *    c, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: Aralıklar kesişiyorsa true, aksi takdirde false.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "vi": "/**\n * Xác định xem hai khoảng đóng có giao nhau không.\n * Tham số:\n *    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\n *    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n * Trả về:\n *    boolean: true nếu các khoảng giao nhau, false nếu không.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9678629947612223",
      "sw": "0.983557178427551",
      "tr": "0.9842795971233748",
      "vi": "0.9504486719951316"
    },
    "canonical_solution": "{\n    return (c <= a && b <= d) ||\n           (a <= c && c <= b && b <= d) ||\n           (a <= c && d <= b) ||\n           (c <= a && a <= d && d <= b);\n}",
    "instruction": {
      "en": "Write a TypeScript function `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` to solve the following problem:\nDetermine if two closed intervals intersect.\nArgs:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\n    boolean: true if the intervals intersect, false otherwise.",
      "es": "Escribe una función de TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` para resolver el siguiente problema:\nDeterminar si dos intervalos cerrados se intersectan.\nArgs:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\nReturns:\n    boolean: true si los intervalos se intersectan, false en caso contrario.",
      "arb": "اكتب دالة TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` لحل المشكلة التالية:\nتحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\nArgs:\n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\nReturns:\n    boolean: true إذا كانت الفترات تتقاطع، false خلاف ذلك.",
      "sw": "Andika kazi ya TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` kutatua tatizo lifuatalo:\nTambua kama vipindi viwili vilivyofungwa vinakatana.\nArgs:\n    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\nReturns:\n    boolean: true ikiwa vipindi vinakatana, false vinginevyo.",
      "tr": "TypeScript fonksiyonu `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` yazın:\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\nArgs:\n    a, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\nReturns:\n    boolean: Aralıklar kesişiyorsa true, aksi takdirde false.",
      "vi": "Viết một hàm TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\nArgs:\n    a, b: Đại diện cho đoạn đóng thứ nhất [a, b] với điều kiện 0 <= a <= b <= 1000.\n    c, d: Đại diện cho đoạn đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\nReturns:\n    boolean: true nếu các đoạn giao nhau, false nếu không."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9799466739914797",
      "sw": "0.9890473221593552",
      "tr": "0.9475331752623015",
      "vi": "0.9739146665802123"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === false);\n    // Additional test cases\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === true);\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === true);\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === false);\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === true);\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === false);\n})();",
    "entry_point": "areIntervalsIntersecting",
    "signature": "function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\nArgs:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\n    boolean: true if the intervals intersect, false otherwise.",
      "es": "Determinar si dos intervalos cerrados se intersectan.\nArgs:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\nReturns:\n    boolean: true si los intervalos se intersectan, false en caso contrario.",
      "arb": "تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\nArgs:\n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\nReturns:\n    boolean: صحيح إذا كانت الفترات تتقاطع، خطأ خلاف ذلك.",
      "sw": "Tambua kama vipindi viwili vilivyofungwa vinakatana. \nArgs:  \n    a, b: Inawakilisha kipengele cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.  \n    c, d: Inawakilisha kipengele cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.  \nReturns:  \n    boolean: kweli ikiwa vipengele vinakatana, vinginevyo si kweli.",
      "tr": "İki kapalı aralığın kesişip kesişmediğini belirleyin.  \nArgs:  \n    a, b: İlk kapalı aralığı temsil eden [a, b] burada 0 <= a <= b <= 1000.  \n    c, d: İkinci kapalı aralığı temsil eden [c, d] burada 0 <= c <= d <= 1000.  \nReturns:  \n    boolean: Aralıklar kesişiyorsa true, aksi takdirde false.",
      "vi": "Xác định xem hai đoạn đóng có giao nhau hay không.  \nTham số:  \n    a, b: Đại diện cho đoạn đóng đầu tiên [a, b] với 0 <= a <= b <= 1000.  \n    c, d: Đại diện cho đoạn đóng thứ hai [c, d] với 0 <= c <= d <= 1000.  \nTrả về:  \n    boolean: true nếu các đoạn giao nhau, false nếu không.  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.957117687038378",
      "sw": "0.9765610191467401",
      "tr": "0.9753032915740272",
      "vi": "0.939041130581917"
    }
  },
  {
    "task_id": "TypeScript/12",
    "prompt": {
      "en": "\n/**\n * You are given three digits a, b, c. Two of them are equal, but the third one\n * is different from the other two. Find the value that occurs exactly once.\n * \n * Examples:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "es": "/**\n * Se te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero\n * es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n * \n * Ejemplos:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "arb": "/**\n * لديك ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث\n * يختلف عن الاثنين الآخرين. ابحث عن القيمة التي تظهر مرة واحدة فقط.\n * \n * أمثلة:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "sw": "/**\n * Umepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu\n * ni tofauti na hizo mbili nyingine. Tafuta thamani inayotokea mara moja tu.\n * \n * Mifano:\n * ```\n * extraNumber(0, 0, 1) // inarudisha 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "tr": "/**\n * Üç basamaklı a, b, c sayıları verilir. Bunlardan ikisi eşittir, ancak üçüncüsü\n * diğer ikisinden farklıdır. Tam olarak bir kez geçen değeri bulun.\n * \n * Örnekler:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "vi": "/**\n * Bạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba\n * khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n * \n * Ví dụ:\n * ```\n * extraNumber(0, 0, 1) // trả về 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9873514159660793",
      "arb": "0.9692480444081786",
      "sw": "0.9806800173582606",
      "tr": "0.9763171010388293",
      "vi": "0.9702203401233443"
    },
    "canonical_solution": "{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function extraNumber(a: number, b: number, c: number): number` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one\nis different from the other two. Find the value that occurs exactly once.\n\nExamples:\nextraNumber(0, 0, 1) // returns 1\n",
      "es": "Escribe una función de TypeScript `function extraNumber(a: number, b: number, c: number): number` para resolver el siguiente problema:\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n\nEjemplos:\nextraNumber(0, 0, 1) // returns 1",
      "arb": "اكتب دالة TypeScript `function extraNumber(a: number, b: number, c: number): number` لحل المشكلة التالية:\nأنت معطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. جد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\nextraNumber(0, 0, 1) // returns 1",
      "sw": "Andika kazi ya TypeScript `function extraNumber(a: number, b: number, c: number): number` kutatua tatizo lifuatalo:\nUmepewa tarakimu tatu a, b, c. Mbili kati yao ni sawa, lakini ya tatu ni tofauti na zile mbili. Tafuta thamani inayotokea mara moja tu.\n\nMifano:\nextraNumber(0, 0, 1) // inarudisha 1",
      "tr": "Bir TypeScript fonksiyonu `function extraNumber(a: number, b: number, c: number): number` yazın ve aşağıdaki problemi çözün:\nÜç rakam verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez ortaya çıkan değeri bulun.\n\nÖrnekler:\nextraNumber(0, 0, 1) // returns 1",
      "vi": "Viết một hàm TypeScript `function extraNumber(a: number, b: number, c: number): number` để giải quyết vấn đề sau:  \nBạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng số thứ ba khác với hai số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n\nVí dụ:  \nextraNumber(0, 0, 1) // trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9900513987354866",
      "arb": "0.978815076710724",
      "sw": "0.9782728157704987",
      "tr": "0.9739661118489004",
      "vi": "0.986290928361734"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(extraNumber(2, 7, 2) === 7, \"Test 1 failed\");\n    console.assert(extraNumber(3, 2, 2) === 3, \"Test 2 failed\");\n    console.assert(extraNumber(5, 5, 1) === 1, \"Test 3 failed\");\n    console.assert(extraNumber(500000000, 3, 500000000) === 3, \"Test 4 failed\");\n    console.assert(extraNumber(500000000, 500000000, 3) === 3, \"Test 5 failed\");\n\n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "extraNumber",
    "signature": "function extraNumber(a: number, b: number, c: number): number",
    "docstring": {
      "en": "You are given three digits a, b, c. Two of them are equal, but the third one\nis different from the other two. Find the value that occurs exactly once.\n\nExamples:\nextraNumber(0, 0, 1) // returns 1\n",
      "es": "Se te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n\nEjemplos:\nextraNumber(0, 0, 1) // devuelve 1",
      "arb": "أنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الرقم الثالث يختلف عن الاثنين الآخرين. اعثر على القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\nextraNumber(0, 0, 1) // يعيد 1",
      "sw": "Unapewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n\nMifano:\nextraNumber(0, 0, 1) // inarudisha 1",
      "tr": "Üç basamaklı sayılar a, b, c verilmektedir. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez geçen değeri bulun.\n\nÖrnekler:\nextraNumber(0, 0, 1) // 1 döndürür",
      "vi": "Bạn được cung cấp ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện đúng một lần.\n\nVí dụ:\nextraNumber(0, 0, 1) // trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9835398975844009",
      "arb": "0.9639593118827436",
      "sw": "0.9735168099269994",
      "tr": "0.964774888227273",
      "vi": "0.9681772280240195"
    }
  },
  {
    "task_id": "TypeScript/13",
    "prompt": {
      "en": "\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n * @param score1 - The score for the first subject.\n * @param score2 - The score for the second subject.\n * @param score3 - The score for the third subject.\n * @param score4 - The score for the fourth subject.\n * @param score5 - The score for the fifth subject.\n * @returns The total score obtained by summing up the scores in all subjects.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "es": "/**\n * Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n * @param score1 - La puntuación para la primera materia.\n * @param score2 - La puntuación para la segunda materia.\n * @param score3 - La puntuación para la tercera materia.\n * @param score4 - La puntuación para la cuarta materia.\n * @param score5 - La puntuación para la quinta materia.\n * @returns La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "arb": "/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n * @param score1 - الدرجة للموضوع الأول.\n * @param score2 - الدرجة للموضوع الثاني.\n * @param score3 - الدرجة للموضوع الثالث.\n * @param score4 - الدرجة للموضوع الرابع.\n * @param score5 - الدرجة للموضوع الخامس.\n * @returns المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "sw": "/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n * @param score1 - Alama kwa somo la kwanza.\n * @param score2 - Alama kwa somo la pili.\n * @param score3 - Alama kwa somo la tatu.\n * @param score4 - Alama kwa somo la nne.\n * @param score5 - Alama kwa somo la tano.\n * @returns Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "tr": "/**\n * Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesapla.\n * @param score1 - Birinci dersin puanı.\n * @param score2 - İkinci dersin puanı.\n * @param score3 - Üçüncü dersin puanı.\n * @param score4 - Dördüncü dersin puanı.\n * @param score5 - Beşinci dersin puanı.\n * @returns Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // 500 döndürür\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "vi": "/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n * @param score1 - Điểm số cho môn học thứ nhất.\n * @param score2 - Điểm số cho môn học thứ hai.\n * @param score3 - Điểm số cho môn học thứ ba.\n * @param score4 - Điểm số cho môn học thứ tư.\n * @param score5 - Điểm số cho môn học thứ năm.\n * @returns Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // trả về 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9915236471197172",
      "arb": "0.9929253817186804",
      "sw": "0.9724827401633318",
      "tr": "0.9684384269750804",
      "vi": "0.9682981939260698"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n@param score1 - The score for the first subject.\n@param score2 - The score for the second subject.\n@param score3 - The score for the third subject.\n@param score4 - The score for the fourth subject.\n@param score5 - The score for the fifth subject.\n@returns The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "es": "Escribe una función de TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` para resolver el siguiente problema:\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n@param score1 - La puntuación para la primera materia.\n@param score2 - La puntuación para la segunda materia.\n@param score3 - La puntuación para la tercera materia.\n@param score4 - La puntuación para la cuarta materia.\n@param score5 - La puntuación para la quinta materia.\n@returns La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "arb": "اكتب دالة TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n@param score1 - الدرجة للموضوع الأول.\n@param score2 - الدرجة للموضوع الثاني.\n@param score3 - الدرجة للموضوع الثالث.\n@param score4 - الدرجة للموضوع الرابع.\n@param score5 - الدرجة للموضوع الخامس.\n@returns المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "sw": "Andika kazi ya TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n@param score1 - Alama kwa somo la kwanza.\n@param score2 - Alama kwa somo la pili.\n@param score3 - Alama kwa somo la tatu.\n@param score4 - Alama kwa somo la nne.\n@param score5 - Alama kwa somo la tano.\n@returns Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "tr": "Bir TypeScript fonksiyonu `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` yazın, aşağıdaki problemi çözmek için:\nFarklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n@param score1 - Birinci dersin puanı.\n@param score2 - İkinci dersin puanı.\n@param score3 - Üçüncü dersin puanı.\n@param score4 - Dördüncü dersin puanı.\n@param score5 - Beşinci dersin puanı.\n@returns Tüm derslerdeki puanların toplamını alarak elde edilen toplam puan.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "vi": "Viết một hàm TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n@param score1 - Điểm số cho môn học thứ nhất.\n@param score2 - Điểm số cho môn học thứ hai.\n@param score3 - Điểm số cho môn học thứ ba.\n@param score4 - Điểm số cho môn học thứ tư.\n@param score5 - Điểm số cho môn học thứ năm.\n@returns Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500"
    },
    "instruction_bertscore": {
      "es": "0.9924671414296329",
      "arb": "0.9977763328843144",
      "sw": "0.9766672864005937",
      "tr": "0.9777561781494271",
      "vi": "0.9766672864005937"
    },
    "level": "easy",
    "test": "const testCalculateTotalScore = (): void => {\n    console.assert(calculateTotalScore(100, 100, 100, 100, 100) === 500);\n    console.assert(calculateTotalScore(0, 0, 0, 0, 0) === 0);\n    console.assert(calculateTotalScore(20, 30, 40, 10, 50) === 150);\n    console.assert(calculateTotalScore(23, 45, 67, 89, 12) === 236);\n    console.assert(calculateTotalScore(5, 5, 5, 5, 5) === 25);\n};\n\ntestCalculateTotalScore();",
    "entry_point": "calculateTotalScore",
    "signature": "function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n@param score1 - The score for the first subject.\n@param score2 - The score for the second subject.\n@param score3 - The score for the third subject.\n@param score4 - The score for the fourth subject.\n@param score5 - The score for the fifth subject.\n@returns The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "es": "Calcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n@param score1 - La puntuación para la primera materia.\n@param score2 - La puntuación para la segunda materia.\n@param score3 - La puntuación para la tercera materia.\n@param score4 - La puntuación para la cuarta materia.\n@param score5 - La puntuación para la quinta materia.\n@returns La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n@param score1 - الدرجة للمادة الأولى.\n@param score2 - الدرجة للمادة الثانية.\n@param score3 - الدرجة للمادة الثالثة.\n@param score4 - الدرجة للمادة الرابعة.\n@param score5 - الدرجة للمادة الخامسة.\n@returns المجموع الكلي للدرجات الذي يتم الحصول عليه بجمع الدرجات في جميع المواد.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n@param score1 - Alama ya somo la kwanza.\n@param score2 - Alama ya somo la pili.\n@param score3 - Alama ya somo la tatu.\n@param score4 - Alama ya somo la nne.\n@param score5 - Alama ya somo la tano.\n@returns Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "tr": "Öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n@param score1 - Birinci dersin puanı.\n@param score2 - İkinci dersin puanı.\n@param score3 - Üçüncü dersin puanı.\n@param score4 - Dördüncü dersin puanı.\n@param score5 - Beşinci dersin puanı.\n@returns Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // 500 döndürür",
      "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n@param score1 - Điểm số cho môn học thứ nhất.\n@param score2 - Điểm số cho môn học thứ hai.\n@param score3 - Điểm số cho môn học thứ ba.\n@param score4 - Điểm số cho môn học thứ tư.\n@param score5 - Điểm số cho môn học thứ năm.\n@returns Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500"
    },
    "docstring_bertscore": {
      "es": "0.9902665154381474",
      "arb": "0.9786462408868444",
      "sw": "0.9625242073797666",
      "tr": "0.9783185007581368",
      "vi": "0.9689810851760677"
    }
  },
  {
    "task_id": "TypeScript/14",
    "prompt": {
      "en": "\n/**\n * Decode a series of numbers to reveal the pattern and understand the actual values\n * each digit represents.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parameters:\n * - dataStr: A string representing a series of numbers. Length does not exceed 100.\n *\n * Returns:\n * number: The result of each data string corresponding to the right-hand side of the equation.\n *\n * Example usage:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "es": "/**\n * Decodificar una serie de números para revelar el patrón y entender los valores reales\n * que representa cada dígito.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parámetros:\n * - dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n *\n * Devuelve:\n * number: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n *\n * Ejemplo de uso:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "arb": "/**\n * فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية\n * التي يمثلها كل رقم.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * المعاملات:\n * - dataStr: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n *\n * يعيد:\n * number: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n *\n * مثال على الاستخدام:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */ \nfunction decodeNumbers(dataStr: string): number",
      "sw": "/**\n * Fafanua mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi\n * kila tarakimu inawakilisha.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Vigezo:\n * - dataStr: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n *\n * Inarudisha:\n * number: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n *\n * Mfano wa matumizi:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "tr": "/**\n * Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın\n * temsil ettiği gerçek değerleri anlayın.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parametreler:\n * - dataStr: Bir dizi sayıyı temsil eden bir dize. Uzunluğu 100'ü geçmez.\n *\n * Döndürür:\n * number: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n *\n * Örnek kullanım:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "vi": "/**\n * Giải mã một chuỗi các số để tiết lộ mô hình và hiểu các giá trị thực tế\n * mỗi chữ số đại diện.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Tham số:\n * - dataStr: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n *\n * Trả về:\n * number: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n *\n * Ví dụ sử dụng:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number"
    },
    "prompt_bertscore": {
      "es": "0.9874878750378503",
      "arb": "0.9703307786151998",
      "sw": "0.9583537638995581",
      "tr": "0.9594708611624984",
      "vi": "0.9875540189547349"
    },
    "canonical_solution": "{\n    const a: number[] = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans: number = 0;\n    \n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[parseInt(dataStr[i])];\n    }\n    \n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function decodeNumbers(dataStr: string): number` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values\n each digit represents.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameters:\n - dataStr: A string representing a series of numbers. Length does not exceed 100.\n\n Returns:\n number: The result of each data string corresponding to the right-hand side of the equation.\n\n Example usage:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "es": "Escriba una función de TypeScript `function decodeNumbers(dataStr: string): number` para resolver el siguiente problema:\nDecodificar una serie de números para revelar el patrón y entender los valores reales que cada dígito representa.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parámetros:\n - dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\n Devuelve:\n number: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\n Ejemplo de uso:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "arb": "اكتب دالة TypeScript `function decodeNumbers(dataStr: string): number` لحل المشكلة التالية:\n فك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n المعاملات:\n - dataStr: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\n يعيد:\n number: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\n مثال على الاستخدام:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "sw": "Andika kazi ya TypeScript `function decodeNumbers(dataStr: string): number` kutatua tatizo lifuatalo:\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- dataStr: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarudisha:\nnambari: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlingano.\n\nMfano wa matumizi:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "tr": "Bir TypeScript fonksiyonu `function decodeNumbers(dataStr: string): number` yazın. Aşağıdaki problemi çözmek için:\nBir dizi sayıyı çözerek kalıbı ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parametreler:\n - dataStr: Bir dizi sayıyı temsil eden bir string. Uzunluğu 100'ü geçmez.\n\n Döndürür:\n number: Her bir veri stringinin denklemdeki sağ tarafa karşılık gelen sonucu.\n\n Örnek kullanım:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "vi": "Viết một hàm TypeScript `function decodeNumbers(dataStr: string): number` để giải quyết vấn đề sau:\nGiải mã một chuỗi các số để tiết lộ mô hình và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n\n Tham số:\n - dataStr: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\n Trả về:\n number: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\n Ví dụ sử dụng:\n console.assert(decodeNumbers(\"0000\") === 4);"
    },
    "instruction_bertscore": {
      "es": "0.9857198660162588",
      "arb": "0.977272711801988",
      "sw": "0.9654039506440104",
      "tr": "0.9593777035137929",
      "vi": "0.8733457210976759"
    },
    "level": "easy",
    "test": "const testDecodeNumbers = (): void => {\n    console.assert(decodeNumbers(\"0000\") === 4);\n    console.assert(decodeNumbers(\"8888\") === 8);\n    console.assert(decodeNumbers(\"1234\") === 1);\n    console.assert(decodeNumbers(\"5678\") === 3);\n    console.assert(decodeNumbers(\"9012\") === 2);\n    console.assert(decodeNumbers(\"1357\") === 0);\n    console.assert(decodeNumbers(\"2468\") === 4);\n\n    // Additional test samples\n    console.assert(decodeNumbers(\"9999\") === 4);\n    console.assert(decodeNumbers(\"1111\") === 0);\n    console.assert(decodeNumbers(\"2222\") === 0);\n    console.assert(decodeNumbers(\"3333\") === 0);\n    console.assert(decodeNumbers(\"4444\") === 4);\n    console.assert(decodeNumbers(\"5555\") === 0);\n    console.assert(decodeNumbers(\"6666\") === 4);\n    console.assert(decodeNumbers(\"7777\") === 0);\n    console.assert(decodeNumbers(\"0001\") === 3);\n    console.assert(decodeNumbers(\"2301\") === 1);\n};\n\ntestDecodeNumbers();",
    "entry_point": "decodeNumbers",
    "signature": "function decodeNumbers(dataStr: string): number",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values\n each digit represents.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameters:\n - dataStr: A string representing a series of numbers. Length does not exceed 100.\n\n Returns:\n number: The result of each data string corresponding to the right-hand side of the equation.\n\n Example usage:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "es": "Decode una serie de números para revelar el patrón y comprender los valores reales que representa cada dígito.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parámetros:\n - dataStr: Una cadena que representa una serie de números. La longitud no excede 100.\n\n Devuelve:\n number: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\n Ejemplo de uso:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "arb": "فك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.  \n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- dataStr: سلسلة تمثل مجموعة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nnumber: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "sw": "Fasiri mfululizo wa nambari ili kufichua mpangilio na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Vigezo:\n - dataStr: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\n Inarejesha:\n number: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlingano.\n\n Mfano wa matumizi:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parametreler:\n - dataStr: Bir dizi sayıyı temsil eden bir dize. Uzunluk 100'ü geçmez.\n\n Döndürür:\n number: Her bir veri dizisinin eşitliğin sağ tarafına karşılık gelen sonucu.\n\n Örnek kullanım:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "vi": "Giải mã một chuỗi các số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Tham số:\n - dataStr: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\n Trả về:\n number: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\n Ví dụ sử dụng:\n console.assert(decodeNumbers(\"0000\") === 4);"
    },
    "docstring_bertscore": {
      "es": "0.9811954631970461",
      "arb": "0.9648936691951318",
      "sw": "0.9531309766606267",
      "tr": "0.941142044122123",
      "vi": "0.9857911743230503"
    }
  },
  {
    "task_id": "TypeScript/15",
    "prompt": {
      "en": "\n/**\n * Counts the number of different coloring methods for `n` squares with `m` colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * Args:\n * - n (number): The number of squares.\n * - m (number): The number of colors.\n * \n * Returns:\n * - number: The count of different coloring methods satisfying the specified conditions.\n *           The result is modulo 1000003.\n * \n * Example calls:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "es": "/**\n * Cuenta el número de diferentes métodos de coloreado para `n` cuadrados con `m` colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * \n * Argumentos:\n * - n (número): El número de cuadrados.\n * - m (número): El número de colores.\n * \n * Devuelve:\n * - número: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n *           El resultado es módulo 1000003.\n * \n * Llamadas de ejemplo:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "arb": "/**\n * يحسب عدد طرق التلوين المختلفة لـ `n` من المربعات باستخدام `m` من الألوان،\n * مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * \n * Args:\n * - n (number): عدد المربعات.\n * - m (number): عدد الألوان.\n * \n * Returns:\n * - number: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n *           النتيجة تكون موديولو 1000003.\n * \n * أمثلة على الاستدعاء:\n * ```\n * countColoringMethods(1, 1) // يعيد 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "sw": "/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi `n` miraba kwa `m` rangi,\n * kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\n * lazima iwe na rangi tofauti.\n * \n * Hoja:\n * - n (nambari): Idadi ya miraba.\n * - m (nambari): Idadi ya rangi.\n * \n * Inarudisha:\n * - nambari: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa.\n *           Matokeo ni modulo 1000003.\n * \n * Mifano ya miito:\n * ```\n * countColoringMethods(1, 1) // inarudisha 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "tr": "/**\n * `n` kare için `m` renk ile farklı boyama yöntemlerinin sayısını sayar,\n * bitişik kareler ve ilk/son karelerin farklı renklere sahip olması\n * gerekliliğini göz önünde bulundurarak.\n * \n * Argümanlar:\n * - n (number): Karelerin sayısı.\n * - m (number): Renklerin sayısı.\n * \n * Döndürür:\n * - number: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n *           Sonuç 1000003 ile mod alınır.\n * \n * Örnek çağrılar:\n * ```\n * countColoringMethods(1, 1) // 1 döndürür\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "vi": "/**\n * Đếm số lượng phương pháp tô màu khác nhau cho `n` ô vuông với `m` màu,\n * xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\n * phải có màu khác nhau.\n * \n * Tham số:\n * - n (number): Số lượng ô vuông.\n * - m (number): Số lượng màu sắc.\n * \n * Trả về:\n * - number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n *           Kết quả được lấy modulo 1000003.\n * \n * Ví dụ gọi:\n * ```\n * countColoringMethods(1, 1) // trả về 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {"
    },
    "prompt_bertscore": {
      "es": "0.9877524507053888",
      "arb": "0.9635735716827739",
      "sw": "0.9606904517020525",
      "tr": "0.971459197809859",
      "vi": "0.9686892971463275"
    },
    "canonical_solution": "const MOD = 1000003;\n    let f: number[] = new Array(n + 1); // Array to store results\n\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD + (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n\n    return f[n];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countColoringMethods(n: number, m: number): number` to solve the following problem:\nCounts the number of different coloring methods for `n` squares with `m` colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (number): The number of squares.\n- m (number): The number of colors.\n\nReturns:\n- number: The count of different coloring methods satisfying the specified conditions.\nThe result is modulo 1000003.\n\nExample calls:\ncountColoringMethods(1, 1) // returns 1\n",
      "es": "Escribe una función de TypeScript `function countColoringMethods(n: number, m: number): number` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para `n` cuadrados con `m` colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\n\nArgs:\n- n (number): El número de cuadrados.\n- m (number): El número de colores.\n\nReturns:\n- number: La cuenta de diferentes métodos de coloreo que satisfacen las condiciones especificadas.\nEl resultado es módulo 1000003.\n\nLlamadas de ejemplo:\ncountColoringMethods(1, 1) // devuelve 1",
      "arb": "اكتب دالة TypeScript `function countColoringMethods(n: number, m: number): number` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ `n` من المربعات باستخدام `m` من الألوان،\nمع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة\nيجب أن تكون بألوان مختلفة.\n\nالمعاملات:\n- n (number): عدد المربعات.\n- m (number): عدد الألوان.\n\nالإرجاع:\n- number: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\nالنتيجة هي باقي القسمة على 1000003.\n\nأمثلة على الاستدعاء:\ncountColoringMethods(1, 1) // يعيد 1",
      "sw": "Andika kazi ya TypeScript `function countColoringMethods(n: number, m: number): number` kutatua tatizo lifuatalo:\nHesabu idadi ya mbinu tofauti za kupaka rangi kwa `n` miraba kwa kutumia `m` rangi,\nukizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\nArgs:\n- n (number): Idadi ya miraba.\n- m (number): Idadi ya rangi.\n\nInarudisha:\n- number: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa.\nMatokeo ni modulo 1000003.\n\nMifano ya miito:\ncountColoringMethods(1, 1) // inarudisha 1",
      "tr": "Bir TypeScript fonksiyonu `function countColoringMethods(n: number, m: number): number` yazın ve aşağıdaki problemi çözün:\n`n` kare için `m` renk ile farklı boyama yöntemlerinin sayısını sayar,\nkomşu karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını dikkate alarak.\n\nArgs:\n- n (number): Karelerin sayısı.\n- m (number): Renklerin sayısı.\n\nReturns:\n- number: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\nSonuç 1000003 ile mod alınır.\n\nÖrnek çağrılar:\ncountColoringMethods(1, 1) // 1 döndürür",
      "vi": "Viết một hàm TypeScript `function countColoringMethods(n: number, m: number): number` để giải quyết vấn đề sau:\nĐếm số lượng phương pháp tô màu khác nhau cho `n` ô vuông với `m` màu,\nxét đến yêu cầu rằng các ô vuông liền kề và các ô vuông đầu/cuối\nphải có màu khác nhau.\n\nTham số:\n- n (number): Số lượng ô vuông.\n- m (number): Số lượng màu.\n\nTrả về:\n- number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\nKết quả là modulo 1000003.\n\nVí dụ gọi hàm:\ncountColoringMethods(1, 1) // trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9944451027639784",
      "arb": "0.9356302496787858",
      "sw": "0.9654838000571865",
      "tr": "0.9669641922870394",
      "vi": "0.9678927893183775"
    },
    "level": "middle",
    "test": "function runTests() {\n    console.assert(countColoringMethods(1, 1) === 1);\n    console.assert(countColoringMethods(2, 2) === 2);\n    console.assert(countColoringMethods(3, 3) === 6);\n    console.assert(countColoringMethods(4, 2) === 2);\n    // The expected result for this case is not provided in the C code, but it is required to pass the test\n    console.assert(countColoringMethods(1000, 10) === 566585); \n\n    // Additional test cases.\n    console.assert(countColoringMethods(2, 3) === 6);\n    console.assert(countColoringMethods(1000, 1000) === 67911);\n    console.assert(countColoringMethods(999, 66) === 501817);\n    console.assert(countColoringMethods(5, 3) === 30); // Example of an expected output\n\n}\n\nrunTests();",
    "entry_point": "countColoringMethods",
    "signature": "function countColoringMethods(n: number, m: number): number",
    "docstring": {
      "en": "Counts the number of different coloring methods for `n` squares with `m` colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (number): The number of squares.\n- m (number): The number of colors.\n\nReturns:\n- number: The count of different coloring methods satisfying the specified conditions.\nThe result is modulo 1000003.\n\nExample calls:\ncountColoringMethods(1, 1) // returns 1\n",
      "es": "Cuenta el número de diferentes métodos de coloreado para `n` cuadrados con `m` colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\n\nArgs:\n- n (number): El número de cuadrados.\n- m (number): El número de colores.\n\nReturns:\n- number: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\nEl resultado es módulo 1000003.\n\nEjemplos de llamadas:\ncountColoringMethods(1, 1) // devuelve 1",
      "arb": "يحسب عدد طرق التلوين المختلفة لـ `n` من المربعات باستخدام `m` من الألوان، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة بألوان مختلفة.\n\nالمعطيات:\n- n (number): عدد المربعات.\n- m (number): عدد الألوان.\n\nالقيم المعادة:\n- number: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة على الاستدعاء:\ncountColoringMethods(1, 1) // يعيد 1",
      "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa `n` miraba na `m` rangi, ukizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\nArgs:\n- n (nambari): Idadi ya miraba.\n- m (nambari): Idadi ya rangi.\n\nReturns:\n- nambari: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n\nMfano wa miito:\ncountColoringMethods(1, 1) // inarudisha 1",
      "tr": "`n` kareyi `m` renk ile boyamak için farklı boyama yöntemlerinin sayısını,\nbitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini\ndikkate alarak sayar.\n\nArgs:\n- n (number): Karelerin sayısı.\n- m (number): Renklerin sayısı.\n\nReturns:\n- number: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\nSonuç 1000003 ile mod alınmıştır.\n\nÖrnek çağrılar:\ncountColoringMethods(1, 1) // 1 döndürür",
      "vi": "Đếm số lượng phương pháp tô màu khác nhau cho `n` ô vuông với `m` màu sắc, xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/ô cuối phải có màu khác nhau.\n\nTham số:\n- n (number): Số lượng ô vuông.\n- m (number): Số lượng màu sắc.\n\nTrả về:\n- number: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n\nVí dụ gọi:\ncountColoringMethods(1, 1) // trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9904436937380305",
      "arb": "0.9011650977438983",
      "sw": "0.9541324710418047",
      "tr": "0.952785161167245",
      "vi": "0.957966236026159"
    }
  },
  {
    "task_id": "TypeScript/16",
    "prompt": {
      "en": "\n/**\n * Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n * \n * @param n - The number of coin tosses.\n * @returns The count of valid sequences.\n * \n * Examples:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "es": "/**\n * Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n * \n * @param n - El número de lanzamientos de moneda.\n * @returns El conteo de secuencias válidas.\n * \n * Ejemplos:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "arb": "/**\n * يحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\n * \n * @param n - عدد رميات العملة.\n * @returns عدد التسلسلات الصحيحة.\n * \n * أمثلة:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "sw": "/**\n * Inahesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha mara n.\n * \n * @param n - Idadi ya kurusha sarafu.\n * @returns Idadi ya mfuatano halali.\n * \n * Mifano:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "tr": "/**\n * Ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını n atışta sayar.\n * \n * @param n - Madeni para atışlarının sayısı.\n * @returns Geçerli dizilerin sayısı.\n * \n * Örnekler:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "vi": "/**\n * Đếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n * \n * @param n - Số lần tung đồng xu.\n * @returns Số lượng chuỗi hợp lệ.\n * \n * Ví dụ:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9902492345949974",
      "arb": "0.9725284251509698",
      "sw": "0.9716679583403266",
      "tr": "0.9963589064852495",
      "vi": "0.9716318076109783"
    },
    "canonical_solution": "{\n    let a: number[][] = Array.from({ length: n + 1 }, () => Array(2).fill(0));\n    a[1][0] = a[1][1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countValidCoinTossSequences(n: number): number` to solve the following problem:\nCounts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - The number of coin tosses.\n@returns The count of valid sequences.\n\nExamples:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3\n",
      "es": "Escribe una función de TypeScript `function countValidCoinTossSequences(n: number): number` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\n@param n - El número de lanzamientos de moneda.\n@returns El conteo de secuencias válidas.\n\nEjemplos:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "arb": "اكتب دالة TypeScript `function countValidCoinTossSequences(n: number): number` لحل المشكلة التالية:\nتحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\n@param n - عدد رميات العملة.\n@returns عدد التسلسلات الصحيحة.\n\nأمثلة:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "sw": "Andika kazi ya TypeScript `function countValidCoinTossSequences(n: number): number` kutatua tatizo lifuatalo:\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n\n@param n - Idadi ya kurusha sarafu.\n@returns Idadi ya mfuatano halali.\n\nMifano:\ncountValidCoinTossSequences(1) inarudisha 2\ncountValidCoinTossSequences(2) inarudisha 3",
      "tr": "Bir TypeScript fonksiyonu `function countValidCoinTossSequences(n: number): number` yazın ve aşağıdaki problemi çözün:\nn atışında ardışık yazı olmayan geçerli para atışı dizilerinin sayısını sayar.\n\n@param n - Para atışlarının sayısı.\n@returns Geçerli dizilerin sayısı.\n\nÖrnekler:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "vi": "Viết một hàm TypeScript `function countValidCoinTossSequences(n: number): number` để giải quyết vấn đề sau:\nĐếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\n@param n - Số lần tung đồng xu.\n@returns Số lượng dãy hợp lệ.\n\nVí dụ:\ncountValidCoinTossSequences(1) trả về 2\ncountValidCoinTossSequences(2) trả về 3"
    },
    "instruction_bertscore": {
      "es": "0.9911541946109923",
      "arb": "0.9823066015485553",
      "sw": "0.9772021980167207",
      "tr": "0.9922095178254307",
      "vi": "0.9908179133759002"
    },
    "level": "easy",
    "test": "const testCountValidCoinTossSequences = (): void => {\n    console.assert(countValidCoinTossSequences(1) === 2);\n    console.assert(countValidCoinTossSequences(2) === 3);\n    console.assert(countValidCoinTossSequences(3) === 5);\n    console.assert(countValidCoinTossSequences(4) === 8); // Additional test\n    console.assert(countValidCoinTossSequences(5) === 13); // Additional test\n    // Feel free to add more tests here\n    console.assert(countValidCoinTossSequences(40) === 267914296); // Additional test\n    console.assert(countValidCoinTossSequences(39) === 165580141);\n    console.assert(countValidCoinTossSequences(38) === 102334155);\n    // Uncomment the next line to log a message on successful test pass\n    // console.log(\"All tests passed!\");\n};\n\ntestCountValidCoinTossSequences();",
    "entry_point": "countValidCoinTossSequences",
    "signature": "function countValidCoinTossSequences(n: number): number",
    "docstring": {
      "en": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - The number of coin tosses.\n@returns The count of valid sequences.\n\nExamples:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3\n",
      "es": "Cuenta el número de secuencias válidas de lanzamientos de monedas sin caras consecutivas en n lanzamientos.\n\n@param n - El número de lanzamientos de moneda.\n@returns La cuenta de secuencias válidas.\n\nEjemplos:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "arb": "يحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n\n@param n - عدد رميات العملة.\n@returns عدد التسلسلات الصحيحة.\n\nأمثلة:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n\n@param n - Idadi ya kurusha sarafu.\n@returns Hesabu ya mfuatano halali.\n\nMifano:\ncountValidCoinTossSequences(1) inarudisha 2\ncountValidCoinTossSequences(2) inarudisha 3",
      "tr": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - Yazı tura atışlarının sayısı.\n@returns Geçerli dizilerin sayısı.\n\nÖrnekler:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "vi": "Đếm số lượng chuỗi tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n\n@param n - Số lần tung đồng xu.\n@returns Số lượng chuỗi hợp lệ.\n\nVí dụ:\ncountValidCoinTossSequences(1) trả về 2\ncountValidCoinTossSequences(2) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9829420201374859",
      "arb": "0.9610106438762808",
      "sw": "0.9681210156261867",
      "tr": "0.9949422746077087",
      "vi": "0.9701893537839029"
    }
  },
  {
    "task_id": "TypeScript/17",
    "prompt": {
      "en": "\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n *\n * Parameters:\n * - n (number): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n *\n * Examples:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "es": "/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n *\n * Parámetros:\n * - n (number): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n *\n * Devuelve:\n * - number: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n *\n * Ejemplos:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "arb": "/**\n * إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * المعطيات:\n * - n (رقم): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n *\n * يعيد:\n * - رقم: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n *\n * أمثلة:\n * extraNumber(7) يعيد 3\n * extraNumber(13) يعيد 2\n * extraNumber(12345) يعيد 3\n * extraNumber(0b11011101111) يعيد 4\n * extraNumber(0xFFFFFFFF) يعيد 32\n * extraNumber(0) يعيد 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "sw": "/**\n * Pata urefu wa mlolongo mrefu zaidi wa 1s mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n *\n * Vigezo:\n * - n (nambari): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n *\n * Inarudisha:\n * - nambari: Urefu wa mlolongo mrefu zaidi wa 1s mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n *\n * Mifano:\n * extraNumber(7) inarudisha 3\n * extraNumber(13) inarudisha 2\n * extraNumber(12345) inarudisha 3\n * extraNumber(0b11011101111) inarudisha 4\n * extraNumber(0xFFFFFFFF) inarudisha 32\n * extraNumber(0) inarudisha 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "tr": "/**\n * Bir negatif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n *\n * Parametreler:\n * - n (sayı): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n *\n * Döndürür:\n * - sayı: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n *\n * Örnekler:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "vi": "/**\n * Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n *\n * Tham số:\n * - n (number): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n *\n * Trả về:\n * - number: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n *\n * Ví dụ:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9960629472175074",
      "arb": "0.9977592506715455",
      "sw": "0.9785683777774786",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1) {\n            ans++;\n        } else {\n            if (ans > max) {\n                max = ans;\n            }\n            ans = 0;\n        }\n        n >>>= 1; // In TypeScript, >>> is used for unsigned right shift\n    }\n    if (ans > max) {\n        max = ans;\n    }\n    return max;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function findLongestConsecutiveOnesLength(n: number): number` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0\n",
      "es": "Escribe una función de TypeScript `function findLongestConsecutiveOnesLength(n: number): number` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (number): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- number: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número dado.\n\nEjemplos:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "arb": "اكتب دالة TypeScript `function findLongestConsecutiveOnesLength(n: number): number` لحل المشكلة التالية:\nابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعطيات:\n- n (number): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالمخرجات:\n- number: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "sw": "Andika kazi ya TypeScript `function findLongestConsecutiveOnesLength(n: number): number` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (number): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n- number: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\nextraNumber(7) inarejesha 3\nextraNumber(13) inarejesha 2\nextraNumber(12345) inarejesha 3\nextraNumber(0b11011101111) inarejesha 4\nextraNumber(0xFFFFFFFF) inarejesha 32\nextraNumber(0) inarejesha 0",
      "tr": "Bir TypeScript fonksiyonu `function findLongestConsecutiveOnesLength(n: number): number` yazarak aşağıdaki problemi çözün:\nBir negatif olmayan tam sayının ikili gösteriminde en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (number): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürülenler:\n- number: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "vi": "Viết một hàm TypeScript `function findLongestConsecutiveOnesLength(n: number): number` để giải quyết vấn đề sau:\nTìm độ dài của chuỗi liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (number): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- number: Độ dài của chuỗi liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0"
    },
    "instruction_bertscore": {
      "es": "0.9964671600429135",
      "arb": "0.9804623184606464",
      "sw": "0.9806100994641362",
      "tr": "1",
      "vi": "1"
    },
    "level": "middle",
    "test": "const testFindLongestConsecutiveOnesLength = (): void => {\n    console.assert(findLongestConsecutiveOnesLength(7) === 3, \"Failed on input 7\");\n    console.assert(findLongestConsecutiveOnesLength(13) === 2, \"Failed on input 13\");\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3, \"Failed on input 12345\");\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4, \"Failed on input 0b11011101111\");\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32, \"Failed on input 0xFFFFFFFF\");\n    console.assert(findLongestConsecutiveOnesLength(0) === 0, \"Failed on input 0\");\n\n    // console.log(\"All tests passed!\");\n};\n\ntestFindLongestConsecutiveOnesLength();",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "function findLongestConsecutiveOnesLength(n: number): number",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0\n",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (number): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- number: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número dado.\n\nEjemplos:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "arb": "البحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعطيات:\n- n (عدد): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- عدد: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\nextraNumber(7) يعيد 3\nextraNumber(13) يعيد 2\nextraNumber(12345) يعيد 3\nextraNumber(0b11011101111) يعيد 4\nextraNumber(0xFFFFFFFF) يعيد 32\nextraNumber(0) يعيد 0",
      "sw": "Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo na alama hasi.\n\nVigezo:\n- n (number): Nambari isiyo na alama hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n- number: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\nextraNumber(7) inarejesha 3\nextraNumber(13) inarejesha 2\nextraNumber(12345) inarejesha 3\nextraNumber(0b11011101111) inarejesha 4\nextraNumber(0xFFFFFFFF) inarejesha 32\nextraNumber(0) inarejesha 0",
      "tr": " Bir negatif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (number): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürür:\n- number: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (number): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- number: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\nextraNumber(7) trả về 3\nextraNumber(13) trả về 2\nextraNumber(12345) trả về 3\nextraNumber(0b11011101111) trả về 4\nextraNumber(0xFFFFFFFF) trả về 32\nextraNumber(0) trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9959892553461436",
      "arb": "0.9546707593744092",
      "sw": "0.9861087843023251",
      "tr": "1",
      "vi": "0.9986479229962956"
    }
  },
  {
    "task_id": "TypeScript/18",
    "prompt": {
      "en": "\n/**\n * Creates an ID by combining two words in a specific manner.\n * Parameters:\n * - word1 (string): The first word to be used in the ID.\n * - word2 (string): The second word to be used in the ID.\n * Returns:\n *  string: A unique ID formed by reversing every other character of the second\n *          word and combining it with the first word.\n * e.g.:\n *      createId('fish', 'cat')  // returns 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "es": "/**\n * Crea un ID combinando dos palabras de una manera específica.\n * Parámetros:\n * - word1 (string): La primera palabra que se usará en el ID.\n * - word2 (string): La segunda palabra que se usará en el ID.\n * Devuelve:\n *  string: Un ID único formado invirtiendo cada otro carácter de la segunda\n *          palabra y combinándolo con la primera palabra.\n * p.ej.:\n *      createId('fish', 'cat')  // devuelve 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "arb": "/**\n * ينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\n * المعلمات:\n * - word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n * - word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\n * يعيد:\n *  string: معرف فريد يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\n * مثال:\n *      createId('fish', 'cat')  // يعيد 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "sw": "/**\n * Inaunda kitambulisho kwa kuchanganya maneno mawili kwa njia maalum.\n * Vigezo:\n * - word1 (string): Neno la kwanza litakalotumika katika kitambulisho.\n * - word2 (string): Neno la pili litakalotumika katika kitambulisho.\n * Inarudisha:\n *  string: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya\n *          neno la pili na kukiunganisha na neno la kwanza.\n * e.g.:\n *      createId('fish', 'cat')  // inarudisha 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "tr": "/**\n * İki kelimeyi belirli bir şekilde birleştirerek bir kimlik oluşturur.\n * Parametreler:\n * - word1 (string): Kimlikte kullanılacak birinci kelime.\n * - word2 (string): Kimlikte kullanılacak ikinci kelime.\n * Döndürür:\n *  string: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle birleştirerek oluşturulan benzersiz bir kimlik.\n * örn.:\n *      createId('fish', 'cat')  // 'ftiasch' döndürür\n */\nfunction createId(word1: string, word2: string): string",
      "vi": "/**\n * Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\n * Tham số:\n * - word1 (string): Từ đầu tiên được sử dụng trong ID.\n * - word2 (string): Từ thứ hai được sử dụng trong ID.\n * Trả về:\n *  string: Một ID duy nhất được tạo bằng cách đảo ngược mỗi ký tự thứ hai của từ thứ hai\n *          và kết hợp nó với từ đầu tiên.\n * ví dụ:\n *      createId('fish', 'cat')  // trả về 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string"
    },
    "prompt_bertscore": {
      "es": "0.9978402918670076",
      "arb": "0.9621378712886538",
      "sw": "0.9572173994896575",
      "tr": "0.9703544156305429",
      "vi": "0.95846738047751"
    },
    "canonical_solution": "{\n    let result: string[] = [];\n    let j: number = 0;\n    let k: number = word2.length - 1;\n\n    for (let i = 0; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            // Take character from word1\n            result.push(word1[j++]);\n        } else {\n            // Take character from word2 in reverse\n            result.push(word2[k--]);\n        }\n    }\n    return result.join('');\n}",
    "instruction": {
      "en": "Write a TypeScript function `function createId(word1: string, word2: string): string` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\n string: A unique ID formed by reversing every other character of the second\n         word and combining it with the first word.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'\n",
      "es": "Escribe una función de TypeScript `function createId(word1: string, word2: string): string` para resolver el siguiente problema:\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra que se usará en el ID.\n- word2 (string): La segunda palabra que se usará en el ID.\nDevuelve:\n string: Un ID único formado invirtiendo cada otro carácter de la segunda\n         palabra y combinándolo con la primera palabra.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'",
      "arb": "اكتب دالة TypeScript `function createId(word1: string, word2: string): string` لحل المشكلة التالية:\nإنشاء معرف عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالإرجاع:\n string: معرف فريد يتم تشكيله عن طريق عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n     createId('fish', 'cat')  // returns 'ftiasch'",
      "sw": "Andika kazi ya TypeScript `function createId(word1: string, word2: string): string` kutatua tatizo lifuatalo:\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\nVigezo:\n- word1 (string): Neno la kwanza litakalotumika kwenye kitambulisho.\n- word2 (string): Neno la pili litakalotumika kwenye kitambulisho.\nInarudisha:\n string: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.\nmfano:\n     createId('fish', 'cat')  // inarudisha 'ftiasch'",
      "tr": "Bir TypeScript fonksiyonu `function createId(word1: string, word2: string): string` yazın:\nBelirli bir şekilde iki kelimeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (string): ID'de kullanılacak ilk kelime.\n- word2 (string): ID'de kullanılacak ikinci kelime.\nDöndürür:\n string: İkinci kelimenin her iki karakterini ters çevirerek ve bunu ilk kelimeyle birleştirerek oluşturulan benzersiz bir ID.\nörneğin:\n     createId('fish', 'cat')  // 'ftiasch' döndürür",
      "vi": "Viết một hàm TypeScript `function createId(word1: string, word2: string): string` để giải quyết vấn đề sau:\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (string): Từ đầu tiên được sử dụng trong ID.\n- word2 (string): Từ thứ hai được sử dụng trong ID.\nTrả về:\n string: Một ID duy nhất được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp nó với từ đầu tiên.\nví dụ:\n     createId('fish', 'cat')  // trả về 'ftiasch'"
    },
    "instruction_bertscore": {
      "es": "0.9913649414452703",
      "arb": "0.9673117954538505",
      "sw": "0.9563475970511057",
      "tr": "0.962731776127948",
      "vi": "0.9656605810963075"
    },
    "level": "middle",
    "test": "const testCreateId = (): void => {\n    let id: string;\n\n    id = createId(\"fish\", \"cat\");\n    console.assert(id === \"ftiasch\", `Test failed: Expected ftiasch, got ${id}`);\n  \n    id = createId(\"icpc\", \"acm\");\n    console.assert(id === \"imccpac\", `Test failed: Expected imccpac, got ${id}`);\n  \n    id = createId(\"oo\", \"w\");\n    console.assert(id === \"owo\", `Test failed: Expected owo, got ${id}`);\n  \n    id = createId(\"hello\", \"world\");\n    console.assert(id === \"hdellrloow\", `Test failed: Expected hdellrloow, got ${id}`);\n  \n    id = createId(\"abc\", \"def\");\n    console.assert(id === \"afbecd\", `Test failed: Expected afbecd, got ${id}`);\n  \n    id = createId(\"buaanb\", \"nbbuaa\");\n    console.assert(id === \"bauaauabnbbn\", `Test failed: Expected bauaauabnbbn, got ${id}`);\n    \n    id = createId(\"xtuisgood\", \"ilovextu\");\n    console.assert(id === \"xuttuxiesvgooloid\", `Test failed: Expected xuttuxiesvgooloid, got ${id}`);\n};\n\ntestCreateId();",
    "entry_point": "createId",
    "signature": "function createId(word1: string, word2: string): string",
    "docstring": {
      "en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\n string: A unique ID formed by reversing every other character of the second\n         word and combining it with the first word.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'\n",
      "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (string): La primera palabra que se usará en el ID.\n- word2 (string): La segunda palabra que se usará en el ID.\nDevuelve:\n string: Un ID único formado invirtiendo cada otro carácter de la segunda\n         palabra y combinándolo con la primera palabra.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'",
      "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (string): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (string): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\n string: معرف فريد يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n     createId('fish', 'cat')  // يعيد 'ftiasch'",
      "sw": "Inaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum. \nVigezo:  \n  - word1 (string): Neno la kwanza litakalotumika katika kitambulisho. \n  - word2 (string): Neno la pili litakalotumika katika kitambulisho. \nInarudisha:  \nstring: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.  \nmfano: \n     createId('fish', 'cat')  // inarudisha 'ftiasch'",
      "tr": "İki kelimeyi belirli bir şekilde birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (string): Kimlikte kullanılacak ilk kelime.\n- word2 (string): Kimlikte kullanılacak ikinci kelime.\nDöndürülen:\n string: İkinci kelimenin her iki karakterinden birini ters çevirerek ve ilk kelimeyle birleştirerek oluşturulan benzersiz bir kimlik.\nörneğin:\n     createId('fish', 'cat')  // 'ftiasch' döndürür",
      "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (string): Từ đầu tiên được sử dụng trong ID.  \n- word2 (string): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \n string: Một ID duy nhất được tạo bằng cách đảo ngược mỗi ký tự thứ hai của từ thứ hai và kết hợp với từ đầu tiên.  \nvd.:  \n     createId('fish', 'cat')  // trả về 'ftiasch'  "
    },
    "docstring_bertscore": {
      "es": "0.9884063419197556",
      "arb": "0.9470443458945746",
      "sw": "0.6736757086484512",
      "tr": "0.9789874878814623",
      "vi": "0.958029003226566"
    }
  },
  {
    "task_id": "TypeScript/19",
    "prompt": {
      "en": "\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "es": "/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (número): Longitud de la cadena binaria.\n- m (número): Número de '1's en la cadena binaria.\n\nDevuelve:\nnúmero: El número total de diferentes esquemas de permutación.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "arb": "/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (number): طول السلسلة الثنائية.\n- m (number): عدد '1's في السلسلة الثنائية.\n\nالإرجاع:\nnumber: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "sw": "/*\nHesabu idadi ya mipango tofauti ya upangaji wa mfuatano wa binary wa urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (nambari): Urefu wa mfuatano wa binary.\n- m (nambari): Idadi ya '1's katika mfuatano wa binary.\n\nInarudisha:\nnambari: Jumla ya idadi ya mipango tofauti ya upangaji.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "tr": "/*\nBir ikili dizgenin uzunluğu n olan, '1'lerin sayısı m ve '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (number): İkili dizgenin uzunluğu.\n- m (number): İkili dizgedeki '1'lerin sayısı.\n\nDöndürür:\nnumber: Farklı permütasyon şemalarının toplam sayısı.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "vi": "/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (number): Độ dài của chuỗi nhị phân.\n- m (number): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nnumber: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9954116381980941",
      "arb": "0.9910596465496196",
      "sw": "0.9404788172798475",
      "tr": "0.9521453727099316",
      "vi": "0.996590112248774"
    },
    "canonical_solution": "{\n    let factorial = 1.0;\n    let i: number;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countPermutationsOfBinaryString(n: number, m: number): number` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.",
      "es": "Escribe una función de TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (number): Longitud de la cadena binaria.\n- m (number): Número de '1's en la cadena binaria.\n\nDevuelve:\nnumber: El número total de diferentes esquemas de permutación.",
      "arb": "اكتب دالة TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (number): طول السلسلة الثنائية.\n- m (number): عدد '1's في السلسلة الثنائية.\n\nيعيد:\nnumber: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Andika kazi ya TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (number): Urefu wa kamba ya binary.\n- m (number): Idadi ya '1's katika kamba ya binary.\n\nInarudisha:\nnumber: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "Bir TypeScript fonksiyonu `function countPermutationsOfBinaryString(n: number, m: number): number` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (number): İkili dizginin uzunluğu.\n- m (number): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\nnumber: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Viết một hàm TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (number): Độ dài của chuỗi nhị phân.\n- m (number): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nnumber: Tổng số các sơ đồ hoán vị khác nhau."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.990907892938509",
      "sw": "0.9889523768372206",
      "tr": "0.9785113708581217",
      "vi": "0.9936025126876283"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2);\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3);\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0);\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675);\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4);\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1);\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156);\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1);\n    // Add more test cases if necessary\n})();",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "function countPermutationsOfBinaryString(n: number, m: number): number",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.",
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (número): Longitud de la cadena binaria.\n- m (número): Número de '1's en la cadena binaria.\n\nDevuelve:\nnúmero: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (عدد): طول السلسلة الثنائية.\n- m (عدد): عدد '1's في السلسلة الثنائية.\n\nيعيد:\nعدد: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n\nVigezo:\n- n (nambari): Urefu wa kamba ya binary.\n- m (nambari): Idadi ya '1's katika kamba ya binary.\n\nInarejesha:\nnambari: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizginin uzunluğu n olan, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını hesaplayın.\n\nParametreler:\n- n (number): İkili dizginin uzunluğu.\n- m (number): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\nnumber: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (number): Độ dài của chuỗi nhị phân.\n- m (number): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\nnumber: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9530620519184076",
      "sw": "0.9754679561599051",
      "tr": "0.9750842022637457",
      "vi": "0.9964161120349875"
    }
  },
  {
    "task_id": "TypeScript/20",
    "prompt": {
      "en": "\n/**\n * Answer a series of questions by providing choices A, B, C, or D for each question.\n * Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n * Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n * Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n * Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n * \n * You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nfunction answerQuestions(): string",
      "es": "/**\n * Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n * Pregunta 1:\n *  ¿A qué tipo de dato pertenecen constantes como 1e6?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Pregunta 2:\n *  Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Ninguna de las anteriores\n * Pregunta 3:\n *  ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *      A. Las expresiones de nombres de variables son valores a la izquierda.\n *      B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *      C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *      D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n * Pregunta 4:\n *  ¿Cuál afirmación sobre las funciones es incorrecta?\n *      A. Los parámetros formales de una función son variables locales.\n *      B. Las variables locales se asignan espacio en la pila.\n *      C. El tipo de función es el mismo que el tipo de valor de retorno.\n *      D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n * Pregunta 5:\n *  ¿Cuál afirmación sobre los punteros es incorrecta?\n *      A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *      B. La desreferencia de punteros implica resolver según el tipo del puntero.\n *      C. int *p[4], p es un arreglo de punteros a int.\n *      D. Los nombres de funciones se pueden asignar a punteros de funciones.\n * \n * Se supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nfunction answerQuestions(): string",
      "arb": "/**\n * أجب عن سلسلة من الأسئلة من خلال تقديم اختيارات A، B، C، أو D لكل سؤال.\n * السؤال 1:\n *  الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * السؤال 2:\n *  بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. لا شيء مما سبق\n * السؤال 3:\n *  أي عبارة حول القيم اليسارية في التعبيرات غير صحيحة؟\n *      A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *      B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *      C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *      D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n * السؤال 4:\n *  أي عبارة حول الدوال غير صحيحة؟\n *      A. المعاملات الشكلية للدالة هي متغيرات محلية.\n *      B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *      C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n *      D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n * السؤال 5:\n *  أي عبارة حول المؤشرات غير صحيحة؟\n *      A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *      B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *      C. int *p[4]، p هو مصفوفة من مؤشرات int.\n *      D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n * \n * من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.\n */\nfunction answerQuestions(): string",
      "sw": "/**\n * Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n * Swali la 1:\n *  Vigezo kama 1e6 vinahusiana na aina gani ya data?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Swali la 2:\n *  Ukipewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inayoweza kutumika kuhifadhi thamani hii?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Hakuna kati ya haya\n * Swali la 3:\n *  Ni kauli gani kuhusu thamani za kushoto katika maneno ni isiyo sahihi?\n *      A. Maneno ya majina ya vigezo ni thamani za kushoto.\n *      B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *      C. Maneno ya kufuta pointer ni thamani za kushoto.\n *      D. Maneno ya operesheni ya kuongeza awali ni thamani za kushoto.\n * Swali la 4:\n *  Ni kauli gani kuhusu kazi ni isiyo sahihi?\n *      A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *      B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n *      C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *      D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n * Swali la 5:\n *  Ni kauli gani kuhusu pointers ni isiyo sahihi?\n *      A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n *      B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *      C. int *p[4], p ni safu ya pointers za int.\n *      D. Majina ya kazi yanaweza kupewa pointers za kazi.\n * \n * Unatakiwa kurudisha tu mistari kama \"AAAAA\", ambayo inawakilisha chaguo za swali.\n */\nfunction answerQuestions(): string",
      "tr": "/**\n * Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n * Soru 1:\n *  1e6 gibi sabitler hangi veri türüne aittir?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Soru 2:\n *  21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Yukarıdakilerin hiçbiri\n * Soru 3:\n *  İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *      A. Değişken adı ifadeleri sol değerlerdir.\n *      B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n *      C. Gösterici çözme ifadeleri sol değerlerdir.\n *      D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n * Soru 4:\n *  Fonksiyonlar hakkında hangi ifade yanlıştır?\n *      A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *      B. Yerel değişkenler yığında alan tahsis edilir.\n *      C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *      D. Bir fonksiyon kendi gövdesinden kendisini çağırabilir.\n * Soru 5:\n *  Göstericiler hakkında hangi ifade yanlıştır?\n *      A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n *      B. Gösterici çözme, göstericinin türüne göre çözmeyi içerir.\n *      C. int *p[4], p bir int gösterici dizisidir.\n *      D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n * \n * Soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n */\nfunction answerQuestions(): string",
      "vi": "/**\n * Trả lời một loạt câu hỏi bằng cách cung cấp các lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n * Câu hỏi 1:\n *  Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Câu hỏi 2:\n *  Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Không có lựa chọn nào ở trên\n * Câu hỏi 3:\n *  Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *      A. Biểu thức tên biến là giá trị bên trái.\n *      B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n *      C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *      D. Biểu thức phép toán tăng trước là giá trị bên trái.\n * Câu hỏi 4:\n *  Câu nào về hàm là không đúng?\n *      A. Tham số hình thức của một hàm là biến cục bộ.\n *      B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *      C. Kiểu của hàm là giống với kiểu giá trị trả về.\n *      D. Một hàm có thể tự gọi lại từ bên trong thân của nó.\n * Câu hỏi 5:\n *  Câu nào về con trỏ là không đúng?\n *      A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *      B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *      C. int *p[4], p là một mảng các con trỏ int.\n *      D. Tên hàm có thể được gán cho con trỏ hàm.\n * \n * Bạn được yêu cầu chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n */\nfunction answerQuestions(): string"
    },
    "prompt_bertscore": {
      "es": "0.9542476766628049",
      "arb": "0.9487394575663264",
      "sw": "0.9235974198260734",
      "tr": "0.9592325047052565",
      "vi": "0.9390663566403084"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "Write a TypeScript function `function answerQuestions(): string` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "es": "Escribe una función de TypeScript `function answerQuestions(): string` para resolver el siguiente problema:\nResponde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\nPregunta 1:\n¿Las constantes como 1e6 pertenecen a qué tipo de dato?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\nPregunta 3:\n¿Cuál afirmación sobre los valores izquierdos en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores izquierdos.\n    B. La operación de incremento requiere que el operando sea un valor izquierdo.\n    C. Las expresiones de desreferencia de punteros son valores izquierdos.\n    D. Las expresiones de operación de incremento prefijo son valores izquierdos.\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver según el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "اكتب دالة TypeScript `function answerQuestions(): string` لحل المشكلة التالية:\nالإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nالسؤال 2:\nبما أن 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\nالسؤال 3:\nأي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n    C. تعبيرات إلغاء المؤشر هي قيم يسرى.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. يتضمن إلغاء المؤشر الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\nمن المفترض أن تعود فقط بسلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Andika kazi ya TypeScript `function answerQuestions(): string` kutatua tatizo lifuatalo: \nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1: \nKonstant kama 1e6 ni ya aina gani ya data? \n    A. unsigned int \n    B. int \n    C. float \n    D. double \n\nSwali la 2: \nKwa kuwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii? \n    A. int \n    B. long long \n    C. double \n    D. Hakuna kati ya hapo juu \n\nSwali la 3: \nNi kauli gani kuhusu thamani za kushoto katika misemo si sahihi? \n    A. Misemo ya majina ya vigezo ni thamani za kushoto. \n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto. \n    C. Misemo ya kufuta pointer ni thamani za kushoto. \n    D. Misemo ya operesheni ya kuongeza awali ni thamani za kushoto. \n\nSwali la 4: \nNi kauli gani kuhusu kazi si sahihi? \n    A. Vigezo rasmi vya kazi ni vigezo vya ndani. \n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack. \n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi. \n    D. Kazi inaweza kujita kutoka ndani ya mwili wake. \n\nSwali la 5: \nNi kauli gani kuhusu pointer si sahihi? \n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao. \n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer. \n    C. int *p[4], p ni safu ya pointer za int. \n    D. Majina ya kazi yanaweza kupewa pointer za kazi. \n\nUnatakiwa kurudisha tu mistari kama \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir TypeScript fonksiyonu `function answerQuestions(): string` yazın ve aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerlerle ilgili hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Pointer dereference ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlarla ilgili hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında alan tahsis edilir.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, kendi gövdesinden kendisini çağırabilir.\nSoru 5:\nPointer'larla ilgili hangi ifade yanlıştır?\n    A. İki pointer'ın çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Pointer dereference, pointer'ın türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int pointer dizisidir.\n    D. Fonksiyon adları, fonksiyon pointer'larına atanabilir.\n\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.",
      "vi": "Viết một hàm TypeScript `function answerQuestions(): string` để giải quyết vấn đề sau:\nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có loại nào ở trên\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Toán tử tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức toán tử tăng tiền tố là giá trị bên trái.\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể tự gọi từ trong thân của nó.\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác nhau trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\nBạn được yêu cầu chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "instruction_bertscore": {
      "es": "0.9584628119787463",
      "arb": "0.9489218002561164",
      "sw": "0.9418831340737641",
      "tr": "0.9565271589155613",
      "vi": "0.9378509373387559"
    },
    "level": "easy",
    "test": "function testAnswerQuestions(): void {\n    const expectedAnswers = \"DDDBA\";\n    console.assert(answerQuestions() === expectedAnswers, `Expected answers string '${expectedAnswers}' does not match the result.`);\n}\n\ntestAnswerQuestions();",
    "entry_point": "answerQuestions",
    "signature": "function answerQuestions(): string",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "es": "Responde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones se pueden asignar a punteros de función.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "الإجابة على سلسلة من الأسئلة بتقديم اختيارات A، B، C، أو D لكل سؤال.  \nالسؤال 1:  \nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nالسؤال 2:  \nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟  \n    A. int  \n    B. long long  \n    C. double  \n    D. لا شيء مما سبق  \nالسؤال 3:  \nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟  \n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.  \n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.  \n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.  \n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.  \nالسؤال 4:  \nأي عبارة عن الدوال غير صحيحة؟  \n    A. المعاملات الشكلية للدالة هي متغيرات محلية.  \n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.  \n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.  \n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.  \nالسؤال 5:  \nأي عبارة عن المؤشرات غير صحيحة؟  \n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.  \n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.  \n    C. int *p[4]، p هو مصفوفة من مؤشرات int.  \n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.  \n\nمن المفترض أن تعود فقط بسلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maneno ni isiyo sahihi?\n    A. Maneno ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maneno ya kufuta pointer ni thamani za kushoto.\n    D. Maneno ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi ni isiyo sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers ni isiyo sahihi?\n    A. Kuondoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\nUnapaswa kurudisha tu misururu kama \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir dizi soruya her soru için A, B, C veya D seçeneklerini sağlayarak cevap verin.\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Pointer çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında alan tahsis edilir.\n    C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\nSoru 5:\nPointerlar hakkında hangi ifade yanlıştır?\n    A. İki pointer çıkarmak, adres değerlerindeki farkı eşittir.\n    B. Pointer çözme, pointer'ın tipine göre çözümlemeyi içerir.\n    C. int *p[4], p bir int pointer dizisidir.\n    D. Fonksiyon adları, fonksiyon pointerlarına atanabilir.\n\nSoruların cevapları için \"AAAAA\" gibi sadece harflerden oluşan bir dizi döndürmeniz bekleniyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có lựa chọn nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng tiền tố là giá trị bên trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\nBạn được yêu cầu chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9469515855066314",
      "arb": "0.9458513718260791",
      "sw": "0.9410868248761952",
      "tr": "0.9357957087861879",
      "vi": "0.9395496243573662"
    }
  },
  {
    "task_id": "TypeScript/21",
    "prompt": {
      "en": "\n/**\n * Determines if it is possible to assemble wooden squares from a number of buckets\n * into a single larger square. Each bucket contains a set number of squares,\n * with each square having a side length of 1.\n * \n * @param length - The number of buckets.\n * @param squares - An array where each element represents the number of squares in a bucket.\n * @returns A boolean indicating whether it is possible to form a larger square.\n *\n * Examples:\n *   IsSquare(1, [9]) returns true.\n *   IsSquare(2, [14, 2]) returns true.\n *   IsSquare(2, [7, 7]) returns false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "es": "/**\n * Determina si es posible ensamblar cuadrados de madera de un número de cubos\n * en un cuadrado más grande. Cada cubo contiene un número determinado de cuadrados,\n * con cada cuadrado teniendo un lado de longitud 1.\n * \n * @param length - El número de cubos.\n * @param squares - Un arreglo donde cada elemento representa el número de cuadrados en un cubo.\n * @returns Un booleano que indica si es posible formar un cuadrado más grande.\n *\n * Ejemplos:\n *   IsSquare(1, [9]) devuelve true.\n *   IsSquare(2, [14, 2]) devuelve true.\n *   IsSquare(2, [7, 7]) devuelve false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "arb": "/**\n * يحدد ما إذا كان من الممكن تجميع مربعات خشبية من عدد من الدلاء\n * في مربع أكبر واحد. يحتوي كل دلو على عدد معين من المربعات،\n * حيث أن لكل مربع طول جانب يساوي 1.\n * \n * @param length - عدد الدلاء.\n * @param squares - مصفوفة حيث يمثل كل عنصر عدد المربعات في دلو.\n * @returns قيمة منطقية تشير إلى ما إذا كان من الممكن تشكيل مربع أكبر.\n *\n * أمثلة:\n *   IsSquare(1, [9]) returns true.\n *   IsSquare(2, [14, 2]) returns true.\n *   IsSquare(2, [7, 7]) returns false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "sw": "/**\n * Huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwa idadi ya ndoo\n * kuwa mraba mmoja mkubwa. Kila ndoo ina idadi fulani ya miraba,\n * ambapo kila mraba una urefu wa upande wa 1.\n * \n * @param length - Idadi ya ndoo.\n * @param squares - Kundi ambapo kila kipengele kinaonyesha idadi ya miraba katika ndoo.\n * @returns Boolean inayoonyesha ikiwa inawezekana kuunda mraba mkubwa.\n *\n * Mifano:\n *   IsSquare(1, [9]) inarudisha kweli.\n *   IsSquare(2, [14, 2]) inarudisha kweli.\n *   IsSquare(2, [7, 7]) inarudisha uongo.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "tr": "/**\n * Bir dizi kovadan tek bir büyük kare oluşturmanın mümkün olup olmadığını belirler.\n * Her kova belirli sayıda kare içerir ve her karenin bir kenar uzunluğu 1'dir.\n * \n * @param length - Kova sayısı.\n * @param squares - Her bir elemanın bir kovadaki kare sayısını temsil ettiği bir dizi.\n * @returns Daha büyük bir kare oluşturmanın mümkün olup olmadığını belirten bir boolean.\n *\n * Örnekler:\n *   IsSquare(1, [9]) true döner.\n *   IsSquare(2, [14, 2]) true döner.\n *   IsSquare(2, [7, 7]) false döner.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "vi": "/**\n * Xác định xem có thể lắp ráp các hình vuông bằng gỗ từ một số xô\n * thành một hình vuông lớn hơn hay không. Mỗi xô chứa một số lượng hình vuông nhất định,\n * với mỗi hình vuông có cạnh dài 1.\n * \n * @param length - Số lượng xô.\n * @param squares - Một mảng mà mỗi phần tử đại diện cho số lượng hình vuông trong một xô.\n * @returns Một giá trị boolean cho biết có thể tạo thành một hình vuông lớn hơn hay không.\n *\n * Ví dụ:\n *   IsSquare(1, [9]) trả về true.\n *   IsSquare(2, [14, 2]) trả về true.\n *   IsSquare(2, [7, 7]) trả về false.\n */\nfunction isSquare(length: number, squares: number[]): boolean"
    },
    "prompt_bertscore": {
      "es": "0.9712309715020498",
      "arb": "0.983972911815057",
      "sw": "0.9665695137199232",
      "tr": "0.9567027481723961",
      "vi": "0.9746426469267051"
    },
    "canonical_solution": "{\n    let sum: number = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Sum the squares\n    }\n    let root: number = Math.floor(Math.sqrt(sum));\n    return root * root === sum; // Check if sum is a perfect square\n}",
    "instruction": {
      "en": "Write a TypeScript function `function isSquare(length: number, squares: number[]): boolean` to solve the following problem:\nDetermines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - The number of buckets.\n- squares - An array where each element represents the number of squares in a bucket.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.",
      "es": "Escribe una función de TypeScript `function isSquare(length: number, squares: number[]): boolean` para resolver el siguiente problema:\nDetermina si es posible ensamblar cuadrados de madera de un número de cubos en un solo cuadrado más grande. Cada cubo contiene un número determinado de cuadrados, con cada cuadrado teniendo un lado de longitud 1.\n\nParámetros:\n- length - El número de cubos.\n- squares - Un arreglo donde cada elemento representa el número de cuadrados en un cubo.\n\nDevuelve un booleano que indica si es posible formar un cuadrado más grande.\n\nEjemplos:\n  IsSquare(1, [9]) devuelve true.\n  IsSquare(2, [14, 2]) devuelve true.\n  IsSquare(2, [7, 7]) devuelve false.",
      "arb": "اكتب دالة TypeScript `function isSquare(length: number, squares: number[]): boolean` لحل المشكلة التالية:\nتحديد ما إذا كان من الممكن تجميع مربعات خشبية من عدد من الدلاء لتشكيل مربع أكبر واحد. يحتوي كل دلو على عدد معين من المربعات، حيث يكون لكل مربع طول ضلع يساوي 1.\n\nالمعلمات:\n- length - عدد الدلاء.\n- squares - مصفوفة حيث يمثل كل عنصر عدد المربعات في دلو.\n\nيعيد قيمة منطقية تشير إلى ما إذا كان من الممكن تشكيل مربع أكبر.\n\nأمثلة:\n  IsSquare(1, [9]) يعيد true.\n  IsSquare(2, [14, 2]) يعيد true.\n  IsSquare(2, [7, 7]) يعيد false.",
      "sw": "Andika kazi ya TypeScript `function isSquare(length: number, squares: number[]): boolean` kutatua tatizo lifuatalo:\nInabainisha kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo kadhaa kuwa mraba mmoja mkubwa. Kila ndoo ina idadi fulani ya miraba, ambapo kila mraba una urefu wa upande wa 1.\n\nVigezo:\n- length - Idadi ya ndoo.\n- squares - Kifurushi ambapo kila kipengele kinawakilisha idadi ya miraba katika ndoo.\n\nInarudisha Boolean inayoonyesha kama inawezekana kuunda mraba mkubwa.\n\nMifano:\n  IsSquare(1, [9]) inarudisha true.\n  IsSquare(2, [14, 2]) inarudisha true.\n  IsSquare(2, [7, 7]) inarudisha false.",
      "tr": "Bir TypeScript fonksiyonu `function isSquare(length: number, squares: number[]): boolean` yazın ve aşağıdaki problemi çözün:\nAhşap kareleri bir dizi kovadan tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler. Her kova belirli sayıda kare içerir ve her karenin kenar uzunluğu 1'dir.\n\nParametreler:\n- length - Kova sayısı.\n- squares - Her bir elemanın bir kovadaki kare sayısını temsil ettiği bir dizi.\n\nDöndürür: Daha büyük bir kare oluşturmanın mümkün olup olmadığını belirten bir boolean.\n\nÖrnekler:\n  IsSquare(1, [9]) true döndürür.\n  IsSquare(2, [14, 2]) true döndürür.\n  IsSquare(2, [7, 7]) false döndürür.",
      "vi": "Viết một hàm TypeScript `function isSquare(length: number, squares: number[]): boolean` để giải quyết vấn đề sau:\nXác định xem có thể lắp ráp các hình vuông gỗ từ một số xô thành một hình vuông lớn hơn duy nhất hay không. Mỗi xô chứa một số lượng hình vuông nhất định, với mỗi hình vuông có cạnh dài 1.\n\nTham số:\n- length - Số lượng xô.\n- squares - Một mảng mà mỗi phần tử đại diện cho số lượng hình vuông trong một xô.\n\nTrả về Một giá trị boolean cho biết liệu có thể tạo thành một hình vuông lớn hơn hay không.\n\nVí dụ:\n  IsSquare(1, [9]) trả về true.\n  IsSquare(2, [14, 2]) trả về true.\n  IsSquare(2, [7, 7]) trả về false."
    },
    "instruction_bertscore": {
      "es": "0.9648215663668162",
      "arb": "0.973241508218885",
      "sw": "0.9653586629171345",
      "tr": "0.9783576309432006",
      "vi": "0.9867936618561334"
    },
    "level": "easy",
    "test": "const testIsSquare = (): void => {\n    console.assert(isSquare(1, [9]) === true, \"Test 1 failed\");\n    console.assert(isSquare(2, [14, 2]) === true, \"Test 2 failed\");\n    console.assert(isSquare(2, [7, 7]) === false, \"Test 3 failed\");\n    console.assert(isSquare(7, [1, 2, 3, 4, 5, 6, 7]) === false, \"Test 4 failed\");\n    console.assert(isSquare(6, [1, 3, 5, 7, 9, 11]) === true, \"Test 5 failed\");\n    console.assert(isSquare(4, [2, 2, 2, 2]) === false, \"Test 6 failed\");\n    \n    // Additional test cases\n    console.assert(isSquare(3, [4, 5, 6]) === false, \"Additional Test 1 failed\");\n    console.assert(isSquare(4, [16, 9, 4, 1]) === false, \"Additional Test 2 failed\");\n    console.assert(isSquare(5, [1, 1, 1, 1, 1]) === false, \"Additional Test 3 failed\");\n    console.assert(isSquare(2, [25, 25]) === false, \"Additional Test 4 failed\");\n    console.assert(isSquare(3, [10, 10, 5]) === true, \"Additional Test 5 failed\");\n    \n    // console.info(\"All tests passed!\");\n};\n\ntestIsSquare();",
    "entry_point": "isSquare",
    "signature": "function isSquare(length: number, squares: number[]): boolean",
    "docstring": {
      "en": "Determines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - The number of buckets.\n- squares - An array where each element represents the number of squares in a bucket.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.",
      "es": "Determina si es posible ensamblar cuadrados de madera a partir de un número de cubos en un cuadrado más grande. Cada cubo contiene un número determinado de cuadrados, y cada cuadrado tiene un lado de longitud 1.\n\nParámetros:\n- length - El número de cubos.\n- squares - Un array donde cada elemento representa el número de cuadrados en un cubo.\n\nDevuelve Un booleano que indica si es posible formar un cuadrado más grande.\n\nEjemplos:\n  IsSquare(1, [9]) devuelve true.\n  IsSquare(2, [14, 2]) devuelve true.\n  IsSquare(2, [7, 7]) devuelve false.",
      "arb": "يحدد ما إذا كان من الممكن تجميع مربعات خشبية من عدد من الدلاء في مربع أكبر واحد. يحتوي كل دلو على عدد محدد من المربعات، حيث يكون لكل مربع طول ضلع يساوي 1.\n\nالمعلمات:\n- length - عدد الدلاء.\n- squares - مصفوفة حيث يمثل كل عنصر عدد المربعات في دلو.\n\nيعيد قيمة منطقية تشير إلى ما إذا كان من الممكن تشكيل مربع أكبر.\n\nأمثلة:\n  IsSquare(1, [9]) يعيد true.\n  IsSquare(2, [14, 2]) يعيد true.\n  IsSquare(2, [7, 7]) يعيد false.",
      "sw": "Inabainisha kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo kadhaa kuwa mraba mmoja mkubwa. Kila ndoo ina idadi fulani ya miraba, ambapo kila mraba una urefu wa upande wa 1.\n\nParameters:\n- length - Idadi ya ndoo.\n- squares - Kiasi ambapo kila kipengele kinawakilisha idadi ya miraba katika ndoo.\n\nInarejesha boolean inayoonyesha ikiwa inawezekana kuunda mraba mkubwa zaidi.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.",
      "tr": "Tek bir büyük kare oluşturmak için bir dizi kovadan ahşap karelerin birleştirilip birleştirilemeyeceğini belirler. Her kova belirli sayıda kare içerir ve her karenin bir kenar uzunluğu 1'dir.\n\nParametreler:\n- length - Kova sayısı.\n- squares - Her bir elemanın bir kovadaki kare sayısını temsil ettiği bir dizi.\n\nDöndürülen Bir büyük kare oluşturmanın mümkün olup olmadığını belirten bir boolean.\n\nÖrnekler:\n  IsSquare(1, [9]) true döndürür.\n  IsSquare(2, [14, 2]) true döndürür.\n  IsSquare(2, [7, 7]) false döndürür.",
      "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ một số xô thành một hình vuông lớn hơn duy nhất hay không. Mỗi xô chứa một số lượng hình vuông nhất định, với mỗi hình vuông có độ dài cạnh là 1.\n\nTham số:\n- length - Số lượng xô.\n- squares - Một mảng mà mỗi phần tử đại diện cho số lượng hình vuông trong một xô.\n\nTrả về Một giá trị boolean cho biết liệu có thể tạo thành một hình vuông lớn hơn hay không.\n\nVí dụ:\n  IsSquare(1, [9]) trả về true.\n  IsSquare(2, [14, 2]) trả về true.\n  IsSquare(2, [7, 7]) trả về false."
    },
    "docstring_bertscore": {
      "es": "0.9481123814533993",
      "arb": "0.979053830428728",
      "sw": "0.994414513685299",
      "tr": "0.9575936054313375",
      "vi": "0.9815802102451107"
    }
  },
  {
    "task_id": "TypeScript/22",
    "prompt": {
      "en": "\n/**\n * Given integers c and d, where a + b = c and a * b = d, find and return the\n * possible value of a (a <= b). If there are multiple pairs, output the pair with\n * the smallest a.\n * \n * @param c - The sum of a and b.\n * @param d - The product of a and b.\n * @returns A possible value of a or -1 if valid values do not exist.\n *\n * Examples:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "es": "/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el\n * valor posible de a (a <= b). Si hay múltiples pares, devuelve el par con\n * el menor a.\n * \n * @param c - La suma de a y b.\n * @param d - El producto de a y b.\n * @returns Un valor posible de a o -1 si no existen valores válidos.\n *\n * Ejemplos:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "arb": "/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد\n * القيمة المحتملة لـ a (حيث a <= b). إذا كانت هناك أزواج متعددة، قم بإخراج الزوج\n * الذي يحتوي على أصغر قيمة لـ a.\n * \n * @param c - مجموع a و b.\n * @param d - حاصل ضرب a و b.\n * @returns قيمة محتملة لـ a أو -1 إذا لم تكن هناك قيم صالحة موجودة.\n *\n * أمثلة:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */ \nfunction findIntegers(c: number, d: number): number",
      "sw": "/**\n * Kwa kupewa nambari nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha\n * thamani inayowezekana ya a (a <= b). Ikiwa kuna jozi nyingi, toa jozi yenye\n * a ndogo zaidi.\n * \n * @param c - Jumla ya a na b.\n * @param d - Bidhaa ya a na b.\n * @returns Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n *\n * Mifano:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "tr": "/**\n * a ve b'nin toplamı c ve çarpımı d olan tamsayılar c ve d verildiğinde, \n * a'nın (a <= b) olası değerini bulun ve döndürün. Birden fazla çift varsa, \n * en küçük a'ya sahip çifti çıktılayın.\n * \n * @param c - a ve b'nin toplamı.\n * @param d - a ve b'nin çarpımı.\n * @returns a'nın olası bir değeri veya geçerli değerler yoksa -1.\n *\n * Örnekler:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "vi": "/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về\n * giá trị có thể có của a (a <= b). Nếu có nhiều cặp, xuất cặp với\n * a nhỏ nhất.\n * \n * @param c - Tổng của a và b.\n * @param d - Tích của a và b.\n * @returns Một giá trị có thể có của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n *\n * Ví dụ:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9903948306642959",
      "arb": "0.9687296191136775",
      "sw": "0.969011078363604",
      "tr": "0.9510632343940536",
      "vi": "0.9798112080716139"
    },
    "canonical_solution": "{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a TypeScript function `function findIntegers(c: number, d: number): number` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the\npossible value of a (a <= b). If there are multiple pairs, output the pair with\nthe smallest a.\n\n@param c - The sum of a and b.\n@param d - The product of a and b.\n@returns A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "es": "Escribe una función de TypeScript `function findIntegers(c: number, d: number): number` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el\nvalor posible de a (a <= b). Si hay múltiples pares, muestra el par con\nel menor a.\n\n@param c - La suma de a y b.\n@param d - El producto de a y b.\n@returns Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "arb": "اكتب دالة TypeScript `function findIntegers(c: number, d: number): number` لحل المشكلة التالية:\nمعطى عددين صحيحين c و d، حيث a + b = c و a * b = d، جد وأرجع\nالقيمة الممكنة لـ a (حيث a <= b). إذا كان هناك أزواج متعددة، أخرج الزوج الذي يحتوي على\nأصغر قيمة لـ a.\n\n@param c - مجموع a و b.\n@param d - حاصل ضرب a و b.\n@returns قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صحيحة.\n\nأمثلة:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "sw": "Andika kazi ya TypeScript `function findIntegers(c: number, d: number): number` kutatua tatizo lifuatalo:\nUkipiwa namba nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha\nthamani inayowezekana ya a (a <= b). Ikiwa kuna jozi nyingi, toa jozi yenye\na ndogo zaidi.\n\n@param c - Jumla ya a na b.\n@param d - Bidhaa ya a na b.\n@returns Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n\nMifano:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "tr": "Bir TypeScript fonksiyonu `function findIntegers(c: number, d: number): number` yazın ve aşağıdaki problemi çözün:\nVerilen c ve d tamsayıları için, a + b = c ve a * b = d olduğunda, a'nın (a <= b) olası değerini bulun ve döndürün. Birden fazla çift varsa, en küçük a'ya sahip olan çifti çıkartın.\n\n@param c - a ve b'nin toplamı.\n@param d - a ve b'nin çarpımı.\n@returns a'nın olası bir değeri veya geçerli değerler yoksa -1.\n\nÖrnekler:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "vi": "Viết một hàm TypeScript `function findIntegers(c: number, d: number): number` để giải quyết vấn đề sau:\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về\ngiá trị có thể của a (a <= b). Nếu có nhiều cặp, xuất ra cặp với\na nhỏ nhất.\n\n@param c - Tổng của a và b.\n@param d - Tích của a và b.\n@returns Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2"
    },
    "instruction_bertscore": {
      "es": "0.9922405041648721",
      "arb": "0.9710353205767306",
      "sw": "0.98666633978189",
      "tr": "0.9701879633712357",
      "vi": "0.995319870962056"
    },
    "level": "easy",
    "test": "const testFindIntegers = () => {\n    console.assert(findIntegers(5, 6) === 2, 'Test 1 failed');\n    console.assert(findIntegers(6, 9) === 3, 'Test 2 failed');\n    console.assert(findIntegers(7, 12) === 3, 'Test 3 failed');\n    console.assert(findIntegers(7, 11) === -1, 'Test 4 failed');\n    console.assert(findIntegers(9, 8) === 1, 'Test 5 failed');\n    console.assert(findIntegers(10, 25) === 5, 'Test 6 failed');\n    console.assert(findIntegers(10000, 8765) === -1, 'Test 7 failed');\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestFindIntegers();",
    "entry_point": "findIntegers",
    "signature": "function findIntegers(c: number, d: number): number",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the\npossible value of a (a <= b). If there are multiple pairs, output the pair with\nthe smallest a.\n\n@param c - The sum of a and b.\n@param d - The product of a and b.\n@returns A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el\nvalor posible de a (a <= b). Si hay múltiples pares, devuelve el par con\nel menor a.\n\n@param c - La suma de a y b.\n@param d - El producto de a y b.\n@returns Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "arb": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - مجموع a و b.\n@param d - حاصل ضرب a و b.\n@returns قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة موجودة.\n\nأمثلة:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "sw": "Kwa kuzingatia nambari kamili c na d, ambapo a + b = c na a * b = d, tafuta na rudisha\nthamani inayowezekana ya a (a <= b). Ikiwa kuna jozi nyingi, toa jozi yenye\na ndogo zaidi.\n\n@param c - Jumla ya a na b.\n@param d - Bidhaa ya a na b.\n@returns Thamani inayowezekana ya a au -1 ikiwa thamani halali hazipo.\n\nMifano:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla çift varsa, en küçük a'ya sahip çifti çıkartın.\n\n@param c - a ve b'nin toplamı.\n@param d - a ve b'nin çarpımı.\n@returns a'nın olası bir değeri veya geçerli değerler yoksa -1.\n\nÖrnekler:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều cặp, xuất cặp với a nhỏ nhất.\n\n@param c - Tổng của a và b.\n@param d - Tích của a và b.\n@returns Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2"
    },
    "docstring_bertscore": {
      "es": "0.9897264394321135",
      "arb": "0.9929128680046752",
      "sw": "0.9890884386482295",
      "tr": "0.8656704445441068",
      "vi": "0.9793076800556906"
    }
  },
  {
    "task_id": "TypeScript/23",
    "prompt": {
      "en": "\n/**\n * Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n * \n * @param edges An array of integers representing the lengths of the edges.\n * @returns The count of distinct acute-angled triangles that can be formed.\n * \n * Examples:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "es": "/**\n * Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n * \n * @param edges Un arreglo de enteros que representa las longitudes de los lados.\n * @returns El conteo de triángulos acutángulos distintos que se pueden formar.\n * \n * Ejemplos:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "arb": "/**\n * احسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n * \n * @param edges مصفوفة من الأعداد الصحيحة تمثل أطوال الحواف.\n * @returns عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n * \n * أمثلة:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "sw": "/**\n * Hesabu idadi ya pembetatu kali ambazo zinaweza kuundwa kwa kuchagua pande zozote 3 kutoka kwenye seti iliyotolewa ya pande.\n * \n * @param edges Mfululizo wa nambari za mzima zinazowakilisha urefu wa pande.\n * @returns Idadi ya pembetatu kali tofauti ambazo zinaweza kuundwa.\n * \n * Mifano:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // inarudisha 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "tr": "/**\n * Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı olmayan üçgenlerin sayısını sayar.\n * \n * @param edges Kenarların uzunluklarını temsil eden bir tamsayı dizisi.\n * @returns Oluşturulabilecek farklı dik açılı olmayan üçgenlerin sayısı.\n * \n * Örnekler:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // 4 döner\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "vi": "/**\n * Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n * \n * @param edges Một mảng số nguyên đại diện cho độ dài của các cạnh.\n * @returns Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n * \n * Ví dụ:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // trả về 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9585551751059275",
      "arb": "0.977784979554677",
      "sw": "0.9493740816337328",
      "tr": "0.9512511387345126",
      "vi": "0.9590034838759233"
    },
    "canonical_solution": "{\n    // Sort the edges in non-decreasing order\n    edges.sort((a, b) => a - b);\n\n    let sum = 0;\n    for (let i = 0; i < edges.length - 2; i++) {\n        for (let j = i + 1; j < edges.length - 1; j++) {\n            for (let k = j + 1; k < edges.length; k++) {\n                let x = edges[i], y = edges[j], z = edges[k];\n                // Check if the edges form an acute-angled triangle\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    return sum;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countAcuteTriangles(edges: number[]): number` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges An array of integers representing the lengths of the edges.\n@returns The count of distinct acute-angled triangles that can be formed.\n\nExamples:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "es": "Escribe una función de TypeScript `function countAcuteTriangles(edges: number[]): number` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\n@param edges Un arreglo de enteros que representa las longitudes de los lados.\n@returns La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\ncountAcuteTriangles([1, 1, 1, 1])\n// devuelve 4",
      "arb": "اكتب دالة TypeScript `function countAcuteTriangles(edges: number[]): number` لحل المشكلة التالية:\nعد عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\n@param edges مصفوفة من الأعداد الصحيحة تمثل أطوال الحواف.\n@returns عدد المثلثات الحادة الزوايا المتميزة التي يمكن تشكيلها.\n\nأمثلة:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "sw": "Andika kazi ya TypeScript `function countAcuteTriangles(edges: number[]): number` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 kutoka kwenye seti ya kingo zilizotolewa.\n\n@param edges Mfululizo wa namba nzima zinazowakilisha urefu wa kingo.\n@returns Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\ncountAcuteTriangles([1, 1, 1, 1])\n// inarudisha 4",
      "tr": "Bir TypeScript fonksiyonu `function countAcuteTriangles(edges: number[]): number` yazın ve aşağıdaki problemi çözün:\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayın.\n\n@param edges Kenarların uzunluklarını temsil eden bir tamsayı dizisi.\n@returns Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n\nÖrnekler:\ncountAcuteTriangles([1, 1, 1, 1])\n// 4 döndürür",
      "vi": "Viết một hàm TypeScript `function countAcuteTriangles(edges: number[]): number` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\n@param edges Một mảng số nguyên đại diện cho độ dài của các cạnh.\n@returns Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\ncountAcuteTriangles([1, 1, 1, 1])\n// trả về 4"
    },
    "instruction_bertscore": {
      "es": "0.9610215685472376",
      "arb": "0.9739853789958607",
      "sw": "0.9696111407447103",
      "tr": "0.9646346551782623",
      "vi": "0.967821481011586"
    },
    "level": "hard",
    "test": "(() => {\n    // Test function using console.assert for validation\n    console.assert(countAcuteTriangles([1, 1, 1, 1]) === 4, \"Test 1 Failed\");\n    console.assert(countAcuteTriangles([1, 2, 3]) === 0, \"Test 2 Failed\");\n    // Additional tests to ensure correctness\n    console.assert(countAcuteTriangles([3, 4, 5, 7, 10]) === 0, \"Test 3 Failed\");\n    console.assert(countAcuteTriangles([6, 8, 10, 5, 5, 5]) === 4, \"Test 4 Failed\");\n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "countAcuteTriangles",
    "signature": "function countAcuteTriangles(edges: number[]): number",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges An array of integers representing the lengths of the edges.\n@returns The count of distinct acute-angled triangles that can be formed.\n\nExamples:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\n@param edges Un arreglo de enteros que representa las longitudes de los lados.\n@returns El conteo de triángulos acutángulos distintos que se pueden formar.\n\nEjemplos:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "arb": "حساب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\n@param edges مصفوفة من الأعداد الصحيحة تمثل أطوال الحواف.\n@returns عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\ncountAcuteTriangles([1, 1, 1, 1])\n// يعيد 4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti iliyotolewa ya pande.\n\n@param edges Mfululizo wa nambari za mzima zinazoonyesha urefu wa pande.\n@returns Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nMifano:\ncountAcuteTriangles([1, 1, 1, 1])\n// inarejesha 4",
      "tr": "Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\n@param edges Kenarların uzunluklarını temsil eden bir tamsayı dizisi.\n@returns Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\ncountAcuteTriangles([1, 1, 1, 1])\n// 4 döndürür",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\n@param edges Một mảng các số nguyên đại diện cho độ dài của các cạnh.\n@returns Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n\nVí dụ:\ncountAcuteTriangles([1, 1, 1, 1])\n// trả về 4"
    },
    "docstring_bertscore": {
      "es": "0.9474412093958824",
      "arb": "0.974881003383947",
      "sw": "0.9213616362571446",
      "tr": "0.9707425393950851",
      "vi": "0.9577511193234982"
    }
  },
  {
    "task_id": "TypeScript/24",
    "prompt": {
      "en": "\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * @param integer_value The input integer.\n * @param char_value The input character.\n * @returns A string containing the integer and character separated by a comma.\n * @example\n * processIntegerAndChar(234, 'H')  // Returns \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "es": "/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * @param integer_value El entero de entrada.\n * @param char_value El carácter de entrada.\n * @returns Una cadena que contiene el entero y el carácter separados por una coma.\n * @example\n * processIntegerAndChar(234, 'H')  // Devuelve \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "arb": "/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n * @param integer_value العدد الصحيح المدخل.\n * @param char_value الحرف المدخل.\n * @returns سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * @example\n * processIntegerAndChar(234, 'H')  // Returns \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "sw": "/**\n * Husoma nambari nzima na herufi, kisha inazirejesha kama mfuatano wa maandishi uliopangwa ukitenganishwa na koma.\n * @param integer_value Nambari nzima ya ingizo.\n * @param char_value Herufi ya ingizo.\n * @returns Mfuatano wa maandishi unaojumuisha nambari nzima na herufi iliyotenganishwa na koma.\n * @example\n * processIntegerAndChar(234, 'H')  // Inarejesha \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "tr": "/**\n * Bir tamsayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * @param integer_value Girdi tamsayısı.\n * @param char_value Girdi karakteri.\n * @returns Virgülle ayrılmış tamsayı ve karakter içeren bir dize.\n * @example\n * processIntegerAndChar(234, 'H')  // \"234,H\" döndürür\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "vi": "/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bằng dấu phẩy.\n * @param integer_value Số nguyên đầu vào.\n * @param char_value Ký tự đầu vào.\n * @returns Một chuỗi chứa số nguyên và ký tự được ngăn cách bằng dấu phẩy.\n * @example\n * processIntegerAndChar(234, 'H')  // Trả về \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string"
    },
    "prompt_bertscore": {
      "es": "0.9960305704653988",
      "arb": "1",
      "sw": "0.9726412472073976",
      "tr": "0.9717331091053061",
      "vi": "0.9744605028672961"
    },
    "canonical_solution": "{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function processIntegerAndChar(integer_value: number, char_value: string): string` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value The input integer.\n@param char_value The input character.\n@returns A string containing the integer and character separated by a comma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "es": "Escribe una función de TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` para resolver el siguiente problema:\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n@param integer_value El entero de entrada.\n@param char_value El carácter de entrada.\n@returns Una cadena que contiene el entero y el carácter separados por una coma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "arb": "اكتب دالة TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\n@param integer_value العدد الصحيح المدخل.\n@param char_value الحرف المدخل.\n@returns سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "sw": "Andika kazi ya TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` kutatua tatizo lifuatalo:\nSoma nambari nzima na herufi, kisha zirudishe kama kamba iliyopangwa kwa koma.\n@param integer_value Nambari nzima ya pembejeo.\n@param char_value Herufi ya pembejeo.\n@returns Kamba inayojumuisha nambari nzima na herufi zikitenganishwa na koma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "tr": "Bir TypeScript fonksiyonu `function processIntegerAndChar(integer_value: number, char_value: string): string` yazın ve aşağıdaki problemi çözün:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n@param integer_value Girdi tam sayısı.\n@param char_value Girdi karakteri.\n@returns Virgülle ayrılmış bir şekilde tam sayı ve karakter içeren bir dize.\n@example\nprocessIntegerAndChar(234, 'H')  // \"234,H\" döndürür.",
      "vi": "Viết một hàm TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n@param integer_value Số nguyên đầu vào.\n@param char_value Ký tự đầu vào.\n@returns Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n@example\nprocessIntegerAndChar(234, 'H')  // Trả về \"234,H\""
    },
    "instruction_bertscore": {
      "es": "0.9932884780552121",
      "arb": "0.9953381449571111",
      "sw": "0.9635930374601154",
      "tr": "0.9781228498328174",
      "vi": "0.9775474176189594"
    },
    "level": "easy",
    "test": "const testProcessIntegerAndChar = (): void => {\n    console.assert(processIntegerAndChar(234, 'H') === \"234,H\", \"Test 1 Failed\");\n    console.assert(processIntegerAndChar(123, 'A') === \"123,A\", \"Test 2 Failed\");\n    console.assert(processIntegerAndChar(0, 'Z') === \"0,Z\", \"Test 3 Failed\");\n    \n    // Additional tests can be added here with different input values\n    // Example:\n    console.assert(processIntegerAndChar(567, 'X') === \"567,X\", \"Example Test Failed\");\n};\n\ntestProcessIntegerAndChar();",
    "entry_point": "processIntegerAndChar",
    "signature": "function processIntegerAndChar(integer_value: number, char_value: string): string",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value The input integer.\n@param char_value The input character.\n@returns A string containing the integer and character separated by a comma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n@param integer_value El número entero de entrada.\n@param char_value El carácter de entrada.\n@returns Una cadena que contiene el número entero y el carácter separados por una coma.\n@example\nprocessIntegerAndChar(234, 'H')  // Devuelve \"234,H\"",
      "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n@param integer_value العدد الصحيح المدخل.\n@param char_value الحرف المدخل.\n@returns سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "sw": "Husoma nambari kamili na herufi, kisha inazirejesha kama kamba iliyopangwa ikitenganishwa na koma.\n@param integer_value Nambari kamili ya pembejeo.\n@param char_value Herufi ya pembejeo.\n@returns Kamba inayojumuisha nambari kamili na herufi ikitenganishwa na koma.\n@example\nprocessIntegerAndChar(234, 'H')  // Inarejesha \"234,H\"",
      "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n@param integer_value Girdi tam sayısı.\n@param char_value Girdi karakteri.\n@returns Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n@example\nprocessIntegerAndChar(234, 'H')  // \"234,H\" döndürür",
      "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n@param integer_value Số nguyên đầu vào.\n@param char_value Ký tự đầu vào.\n@returns Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n@example\nprocessIntegerAndChar(234, 'H')  // Trả về \"234,H\""
    },
    "docstring_bertscore": {
      "es": "0.986768634428123",
      "arb": "1",
      "sw": "0.965003114535082",
      "tr": "0.9581587088653818",
      "vi": "0.9625885636232219"
    }
  },
  {
    "task_id": "TypeScript/25",
    "prompt": {
      "en": "\n/**\n * Shifts all characters by 5 positions in alphabetical order. Only letters\n * are replaced, and all letters are in uppercase.\n * \n * @param text The input text to be processed.\n * @returns The transformed text with characters shifted by 5 positions.\n * \n * Example:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "es": "/**\n * Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n * \n * @param text El texto de entrada a ser procesado.\n * @returns El texto transformado con caracteres desplazados por 5 posiciones.\n * \n * Ejemplo:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "arb": "/**\n * يحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط،\n * وجميع الحروف تكون بأحرف كبيرة.\n * \n * @param text النص المدخل ليتم معالجته.\n * @returns النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n * \n * مثال:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "sw": "/**\n * Inahamisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi\n * tu ndizo zinabadilishwa, na herufi zote ziko katika herufi kubwa.\n * \n * @param text Maandishi ya ingizo yanayopaswa kushughulikiwa.\n * @returns Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n * \n * Mfano:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "tr": "/**\n * Tüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler\n * değiştirilir ve tüm harfler büyük harfle yazılır.\n * \n * @param text İşlenecek giriş metni.\n * @returns Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n * \n * Örnek:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "vi": "/**\n * Dịch chuyển tất cả các ký tự 5 vị trí theo thứ tự bảng chữ cái. Chỉ có các chữ cái\n * được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n * \n * @param text Văn bản đầu vào cần được xử lý.\n * @returns Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n * \n * Ví dụ:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string"
    },
    "prompt_bertscore": {
      "es": "0.9883789309271729",
      "arb": "0.9926343882104642",
      "sw": "0.9694075446041496",
      "tr": "0.9655366357385418",
      "vi": "0.9662322393329259"
    },
    "canonical_solution": "{\n    let result = \"\";\n    for (let i = 0; i < text.length; ++i) {\n        let charCode = text.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 69) { // 'A'.charCodeAt(0) == 65, 'E'.charCodeAt(0) == 69\n            result += String.fromCharCode(charCode + 21); // 'V'.charCodeAt(0) == 86; 'V' - 'A' = 21\n        } else if (charCode >= 70 && charCode <= 90) { // 'F'.charCodeAt(0) == 70, 'Z'.charCodeAt(0) == 90\n            result += String.fromCharCode(charCode - 5);\n        } else {\n            result += text[i];\n        }\n    }\n    return result;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function shiftCharacters(text: string): string` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text The input text to be processed.\n@returns The transformed text with characters shifted by 5 positions.\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "es": "Escribe una función de TypeScript `function shiftCharacters(text: string): string` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n\n@param text El texto de entrada a ser procesado.\n@returns El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "اكتب دالة TypeScript `function shiftCharacters(text: string): string` لحل المشكلة التالية:\nتحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\n@param text النص المدخل ليتم معالجته.\n@returns النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n\nمثال:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Andika kazi ya TypeScript `function shiftCharacters(text: string): string` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo zinabadilishwa, na herufi zote ni za herufi kubwa.\n\n@param text Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n@returns Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\nMfano:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\ninarudisha \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Bir TypeScript fonksiyonu `function shiftCharacters(text: string): string` yazın:\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harf olarak kalır.\n\n@param text İşlenecek giriş metni.\n@returns Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\nÖrnek:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" döndürür.",
      "vi": "Viết một hàm TypeScript `function shiftCharacters(text: string): string` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\n@param text Văn bản đầu vào cần được xử lý.\n@returns Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\nVí dụ:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\ntrả về \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "es": "0.9814930115078364",
      "arb": "0.9948439525690964",
      "sw": "0.9825318484006488",
      "tr": "0.9639418324092126",
      "vi": "0.9840952681297744"
    },
    "level": "hard",
    "test": "function testShiftCharacters() {\n    let test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    let test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    let test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    console.assert(shiftCharacters(test1) === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\", \"Test 1 failed\");\n    console.assert(shiftCharacters(test2) === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\", \"Test 2 failed\");\n    console.assert(shiftCharacters(test3) === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\", \"Test 3 failed\");\n}\n\ntestShiftCharacters();",
    "entry_point": "shiftCharacters",
    "signature": "function shiftCharacters(text: string): string",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text The input text to be processed.\n@returns The transformed text with characters shifted by 5 positions.\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n\n@param text El texto de entrada a ser procesado.\n@returns El texto transformado con caracteres desplazados 5 posiciones.\n\nEjemplo:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بأحرف كبيرة.\n\n@param text النص المدخل ليتم معالجته.\n@returns النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\nمثال:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text Maandishi ya kuingiza yanayopaswa kushughulikiwa.\n@returns Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\nMfano:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\n@param text İşlenecek giriş metni.\n@returns Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\nÖrnek:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Dịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\n@param text Văn bản đầu vào cần được xử lý.\n@returns Văn bản đã được biến đổi với các ký tự được dịch chuyển theo 5 vị trí.\n\nVí dụ:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9753430176502341",
      "arb": "0.9913079345259133",
      "sw": "0.9782348773677211",
      "tr": "0.9408474752670483",
      "vi": "0.9742541259014009"
    }
  },
  {
    "task_id": "TypeScript/26",
    "prompt": {
      "en": "\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n *\n * @param x - The string representation of the integer to be classified.\n * @returns The class to which the integer x belongs.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "es": "/**\n * Clasificar el entero x basado en el siguiente método:\n * Si x es un número de un solo dígito, x pertenece a su propia clase.\n * De lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n *\n * @param x - La representación en cadena del entero a clasificar.\n * @returns La clase a la que pertenece el entero x.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "arb": "/**\n * صنف العدد الصحيح x بناءً على الطريقة التالية:\n * إذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\n * خلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n *\n * @param x - التمثيل النصي للعدد الصحيح المراد تصنيفه.\n * @returns الفئة التي ينتمي إليها العدد الصحيح x.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "sw": "/**\n * Tambua nambari x kulingana na njia ifuatayo:\n * Ikiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\n * Vinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n *\n * @param x - Uwakilishi wa kamba wa nambari nzima inayotakiwa kutambuliwa.\n * @returns Darasa ambalo nambari x inahusishwa.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "tr": "/**\n * x tamsayısını aşağıdaki yönteme göre sınıflandır:\n * Eğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\n * Aksi takdirde, x'in basamaklarını topla, yeni bir x elde et ve sınıf belirlenene kadar yinele.\n *\n * @param x - Sınıflandırılacak tamsayının string gösterimi.\n * @returns x tamsayısının ait olduğu sınıf.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "vi": "/**\n * Phân loại số nguyên x dựa trên phương pháp sau:\n * Nếu x là một số có một chữ số, x thuộc về lớp của chính nó.\n * Nếu không, cộng các chữ số của x, nhận một x mới, và lặp lại cho đến khi lớp được xác định.\n *\n * @param x - Biểu diễn chuỗi của số nguyên cần phân loại.\n * @returns Lớp mà số nguyên x thuộc về.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number"
    },
    "prompt_bertscore": {
      "es": "0.9952849120149938",
      "arb": "0.9769278894605116",
      "sw": "0.9524695374917805",
      "tr": "0.9887807601880064",
      "vi": "0.9849998308850073"
    },
    "canonical_solution": "{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i]);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function classifyInteger(x: string): number` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The string representation of the integer to be classified.\n\nReturns:\nThe class to which the integer x belongs.\n\nExample:\nclassifyInteger(\"24\") // returns 6",
      "es": "Escribe una función de TypeScript `function classifyInteger(x: string): number` para resolver el siguiente problema:\nClasifica el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): La representación en cadena del entero a clasificar.\n\nDevuelve:\nLa clase a la que pertenece el entero x.\n\nEjemplo:\nclassifyInteger(\"24\") // returns 6",
      "arb": "اكتب دالة TypeScript `function classifyInteger(x: string): number` لحل المشكلة التالية:\nصنّف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقماً مكوناً من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): التمثيل النصي للعدد الصحيح الذي سيتم تصنيفه.\n\nالإرجاع:\nالفئة التي ينتمي إليها العدد الصحيح x.\n\nمثال:\nclassifyInteger(\"24\") // returns 6",
      "sw": "Andika kazi ya TypeScript `function classifyInteger(x: string): number` kutatua tatizo lifuatalo:\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusishwa na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (string): Uwakilishi wa kamba wa nambari ambayo inatakiwa kutambuliwa.\n\nRudisha:\nDarasa ambalo nambari x inahusishwa.\n\nMfano:\nclassifyInteger(\"24\") // inarudisha 6",
      "tr": "TypeScript fonksiyonu `function classifyInteger(x: string): number` yazın ve aşağıdaki problemi çözün:\nAşağıdaki yönteme göre tam sayıyı sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tam sayının string gösterimi.\n\nDöndürülen:\nTam sayı x'in ait olduğu sınıf.\n\nÖrnek:\nclassifyInteger(\"24\") // 6 döndürür",
      "vi": "Viết một hàm TypeScript `function classifyInteger(x: string): number` để giải quyết vấn đề sau:  \nPhân loại số nguyên x dựa trên phương pháp sau:  \nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.  \nNgược lại, tổng các chữ số của x, lấy một x mới và lặp lại cho đến khi lớp được xác định.\n\nTham số:  \n- x (string): Biểu diễn chuỗi của số nguyên cần phân loại.\n\nTrả về:  \nLớp mà số nguyên x thuộc về.\n\nVí dụ:  \nclassifyInteger(\"24\") // trả về 6"
    },
    "instruction_bertscore": {
      "es": "0.9930568750309254",
      "arb": "0.9729207201535137",
      "sw": "0.9463632423180061",
      "tr": "0.9672430693420124",
      "vi": "0.9792486868325232"
    },
    "level": "easy",
    "test": "const testClassifyInteger = (): void => {\n    console.assert(classifyInteger(\"24\") === 6, \"Test failed for input '24'\");\n    console.assert(classifyInteger(\"39\") === 3, \"Test failed for input '39'\");\n    console.assert(classifyInteger(\"123456789\") === 9, \"Test failed for input '123456789'\");\n    console.assert(classifyInteger(\"123456789012345678901234567890\") === 9, \"Test failed for input '123456789012345678901234567890'\");\n    console.assert(classifyInteger(\"12345\") === 6, \"Test failed for input '12345'\");\n    console.assert(classifyInteger(\"999999999\") === 9, \"Test failed for input '999999999'\");\n};\n\ntestClassifyInteger();",
    "entry_point": "classifyInteger",
    "signature": "function classifyInteger(x: string): number",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The string representation of the integer to be classified.\n\nReturns:\nThe class to which the integer x belongs.\n\nExample:\nclassifyInteger(\"24\") // returns 6",
      "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (string): La representación en cadena del entero a clasificar.\n\nDevuelve:\nLa clase a la que pertenece el entero x.\n\nEjemplo:\nclassifyInteger(\"24\") // returns 6",
      "arb": "صنف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (string): تمثيل السلسلة النصية للعدد الصحيح الذي سيتم تصنيفه.\n\nالإرجاع:\nالفئة التي ينتمي إليها العدد الصحيح x.\n\nمثال:\nclassifyInteger(\"24\") // يعيد 6",
      "sw": "Tambua nambari x kulingana na mbinu ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake mwenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\n\nVigezo:\n- x (string): Uwakilishi wa kamba wa nambari nzima inayopaswa kuainishwa.\n\nInarudisha:\nDarasa ambalo nambari x inahusiana nalo.\n\nMfano:\nclassifyInteger(\"24\") // inarudisha 6",
      "tr": "Tamsayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (string): Sınıflandırılacak tamsayının string gösterimi.\n\nDöndürür:\nTamsayı x'in ait olduğu sınıf.\n\nÖrnek:\nclassifyInteger(\"24\") // 6 döndürür",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (string): Biểu diễn dưới dạng chuỗi của số nguyên cần phân loại.\n\nTrả về:\nLớp mà số nguyên x thuộc về.\n\nVí dụ:\nclassifyInteger(\"24\") // trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9933778617266779",
      "arb": "0.9686773793234654",
      "sw": "0.9456211592144597",
      "tr": "0.9715791705600041",
      "vi": "0.9766511973397299"
    }
  },
  {
    "task_id": "TypeScript/27",
    "prompt": {
      "en": "\n/**\n * Transforms the case of a given letter.\n * \n * Parameters:\n * - letter (string): The input letter to be transformed.\n * \n * Returns:\n * - string: The letter with its case reversed. If the input is lowercase, \n *           it returns the uppercase version, and if the input is uppercase, \n *           it returns the lowercase version.\n * \n * Examples:\n * transformLetterCase('b') // Returns 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "es": "/**\n * Transforma el caso de una letra dada.\n * \n * Parámetros:\n * - letter (string): La letra de entrada a ser transformada.\n * \n * Devuelve:\n * - string: La letra con su caso invertido. Si la entrada es minúscula,\n *           devuelve la versión en mayúscula, y si la entrada es mayúscula,\n *           devuelve la versión en minúscula.\n * \n * Ejemplos:\n * transformLetterCase('b') // Devuelve 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "arb": "/**\n * يحول حالة حرف معين.\n * \n * المعاملات:\n * - letter (string): الحرف المدخل الذي سيتم تحويله.\n * \n * يعيد:\n * - string: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، \n *           فإنه يعيد النسخة الكبيرة، وإذا كان المدخل بحروف كبيرة، \n *           فإنه يعيد النسخة الصغيرة.\n * \n * أمثلة:\n * transformLetterCase('b') // Returns 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "sw": "/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * \n * Vigezo:\n * - letter (string): Herufi ya kuingiza inayopaswa kubadilishwa.\n * \n * Inarudisha:\n * - string: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo,\n *           inarudisha toleo la herufi kubwa, na ikiwa ingizo ni herufi kubwa,\n *           inarudisha toleo la herufi ndogo.\n * \n * Mifano:\n * transformLetterCase('b') // Inarudisha 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "tr": "/**\n * Verilen bir harfin büyük/küçük harfini değiştirir.\n * \n * Parametreler:\n * - letter (string): Dönüştürülecek giriş harfi.\n * \n * Döndürür:\n * - string: Harfin büyük/küçük harfi ters çevrilmiş hali. Eğer giriş küçük harfse, \n *           büyük harf versiyonunu döndürür ve eğer giriş büyük harfse, \n *           küçük harf versiyonunu döndürür.\n * \n * Örnekler:\n * transformLetterCase('b') // 'B' döndürür\n */\nfunction transformLetterCase(letter: string): string",
      "vi": "/**\n * Chuyển đổi kiểu chữ của một chữ cái cho trước.\n * \n * Tham số:\n * - letter (string): Chữ cái đầu vào cần được chuyển đổi.\n * \n * Trả về:\n * - string: Chữ cái với kiểu chữ đã được đảo ngược. Nếu đầu vào là chữ thường,\n *           nó trả về phiên bản chữ hoa, và nếu đầu vào là chữ hoa,\n *           nó trả về phiên bản chữ thường.\n * \n * Ví dụ:\n * transformLetterCase('b') // Trả về 'B'\n */\nfunction transformLetterCase(letter: string): string"
    },
    "prompt_bertscore": {
      "es": "0.9972479760707617",
      "arb": "0.9749576747110265",
      "sw": "0.9676540356003737",
      "tr": "0.9731954259704849",
      "vi": "0.9789406111115381"
    },
    "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter.toLowerCase();\n    } else if (letter >= 'a' && letter <= 'z') {\n        return letter.toUpperCase();\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function transformLetterCase(letter: string): string` to solve the following problem:\nTransforms the case of a given letter.\n\nParameters:\n- letter (string): The input letter to be transformed.\n\nReturns:\n- string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'",
      "es": "Escribe una función de TypeScript `function transformLetterCase(letter: string): string` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n\nParámetros:\n- letter (string): La letra de entrada a transformar.\n\nDevuelve:\n- string: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula, y si la entrada es mayúscula, devuelve la versión en minúscula.\n\nEjemplos:\ntransformLetterCase('b') // Devuelve 'B'",
      "arb": "اكتب دالة TypeScript `function transformLetterCase(letter: string): string` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n\nالمعلمات:\n- letter (string): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- string: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة، وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n\nأمثلة:\ntransformLetterCase('b') // Returns 'B'",
      "sw": "Andika kazi ya TypeScript `function transformLetterCase(letter: string): string` kutatua tatizo lifuatalo:  \nHubadilisha herufi ya ingizo.\n\nVigezo:\n- letter (string): Herufi ya ingizo inayopaswa kubadilishwa.\n\nInarejesha:\n- string: Herufi ikiwa na kisa chake kimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n\nMifano:\ntransformLetterCase('b') // Inarejesha 'B'",
      "tr": "Bir TypeScript fonksiyonu `function transformLetterCase(letter: string): string` yazın:\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nParametreler:\n- letter (string): Dönüştürülecek giriş harfi.\n\nDöndürür:\n- string: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\ntransformLetterCase('b') // 'B' döndürür",
      "vi": "Viết một hàm TypeScript `function transformLetterCase(letter: string): string` để giải quyết vấn đề sau:  \nChuyển đổi kiểu chữ của một chữ cái đã cho.\n\nTham số:\n- letter (string): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- string: Chữ cái với kiểu chữ đã được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa, và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\ntransformLetterCase('b') // Trả về 'B'"
    },
    "instruction_bertscore": {
      "es": "0.9739267830334554",
      "arb": "0.9861506953127235",
      "sw": "0.9678028097557687",
      "tr": "0.9714464854654727",
      "vi": "0.9761927584203014"
    },
    "level": "easy",
    "test": "const testTransformLetterCase = (): void => {\n    console.assert(transformLetterCase('b') === 'B', 'Test failed: transformLetterCase(\\'b\\') should return \\'B\\'');\n    console.assert(transformLetterCase('B') === 'b', 'Test failed: transformLetterCase(\\'B\\') should return \\'b\\'');\n    console.assert(transformLetterCase('z') === 'Z', 'Test failed: transformLetterCase(\\'z\\') should return \\'Z\\'');\n    console.assert(transformLetterCase('Z') === 'z', 'Test failed: transformLetterCase(\\'Z\\') should return \\'z\\'');\n    console.assert(transformLetterCase('m') === 'M', 'Test failed: transformLetterCase(\\'m\\') should return \\'M\\'');\n    console.assert(transformLetterCase('M') === 'm', 'Test failed: transformLetterCase(\\'M\\') should return \\'m\\'');\n    console.assert(transformLetterCase('1') === '1', 'Test failed: transformLetterCase(\\'1\\') should return \\'1\\' (unchanged)');\n    console.assert(transformLetterCase('!') === '!', 'Test failed: transformLetterCase(\\'!\\') should return \\'!\\' (unchanged)');\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestTransformLetterCase();",
    "entry_point": "transformLetterCase",
    "signature": "function transformLetterCase(letter: string): string",
    "docstring": {
      "en": "Transforms the case of a given letter.\n\nParameters:\n- letter (string): The input letter to be transformed.\n\nReturns:\n- string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'",
      "es": "Transforma el caso de una letra dada.\n\nParámetros:\n- letter (string): La letra de entrada a ser transformada.\n\nDevuelve:\n- string: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula, y si la entrada es mayúscula, devuelve la versión en minúscula.\n\nEjemplos:\ntransformLetterCase('b') // Devuelve 'B'",
      "arb": "يحول حالة حرف معين.\n\nالمعطيات:\n- letter (string): الحرف المدخل الذي سيتم تحويله.\n\nالقيم المعادة:\n- string: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة، وإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n\nأمثلة:\ntransformLetterCase('b') // يعيد 'B'",
      "sw": "Hubadilisha herufi ya herufi iliyotolewa.\n\nVigezo:\n- letter (string): Herufi ya kuingiza itakayobadilishwa.\n\nInarejesha:\n- string: Herufi ikiwa na herufi zake zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa, na ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n\nMifano:\ntransformLetterCase('b') // Inarejesha 'B'",
      "tr": "Verilen bir harfin büyük-küçük harf durumunu değiştirir.\n\nParametreler:\n- letter (string): Dönüştürülecek giriş harfi.\n\nDöndürülenler:\n- string: Harfin büyük-küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür ve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n\nÖrnekler:\ntransformLetterCase('b') // 'B' döndürür",
      "vi": "Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n\nTham số:\n- letter (string): Chữ cái đầu vào cần được chuyển đổi.\n\nTrả về:\n- string: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa, và nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n\nVí dụ:\ntransformLetterCase('b') // Trả về 'B'"
    },
    "docstring_bertscore": {
      "es": "0.9965297286129394",
      "arb": "0.9552801573834242",
      "sw": "0.9764503820245036",
      "tr": "0.9796743517390809",
      "vi": "0.9746182153898378"
    }
  },
  {
    "task_id": "TypeScript/28",
    "prompt": {
      "en": "\n/**\n * Display the ASCII information for a given character.\n * \n * Parameters:\n * - character (string): The input character for which ASCII information is to be displayed.\n *    \n * Returns:\n * - number: corresponding ASCII code\n *    \n * Examples:\n * ```\n * console.log(display_ascii_info('A'));\n * // expected output: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "es": "/**\n * Muestra la información ASCII para un carácter dado.\n * \n * Parámetros:\n * - character (string): El carácter de entrada para el cual se mostrará la información ASCII.\n *    \n * Devuelve:\n * - number: código ASCII correspondiente\n *    \n * Ejemplos:\n * ```\n * console.log(display_ascii_info('A'));\n * // expected output: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "arb": "/**\n * عرض معلومات ASCII لحرف معين.\n * \n * المعلمات:\n * - character (string): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n *    \n * يعيد:\n * - number: كود ASCII المقابل\n *    \n * أمثلة:\n * ```\n * console.log(display_ascii_info('A'));\n * // expected output: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "sw": "/**\n * Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n * \n * Vigezo:\n * - character (string): Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n *    \n * Inarudisha:\n * - number: nambari ya ASCII inayolingana\n *    \n * Mifano:\n * ```\n * console.log(display_ascii_info('A'));\n * // matokeo yanayotarajiwa: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "tr": "/**\n * Belirtilen bir karakter için ASCII bilgisini görüntüler.\n * \n * Parametreler:\n * - character (string): ASCII bilgisinin görüntüleneceği giriş karakteri.\n *    \n * Döndürür:\n * - number: karşılık gelen ASCII kodu\n *    \n * Örnekler:\n * ```\n * console.log(display_ascii_info('A'));\n * // beklenen çıktı: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "vi": "/**\n * Hiển thị thông tin ASCII cho một ký tự được cho.\n * \n * Tham số:\n * - character (string): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n *    \n * Trả về:\n * - number: mã ASCII tương ứng\n *    \n * Ví dụ:\n * ```\n * console.log(display_ascii_info('A'));\n * // kết quả mong đợi: 65\n * ```\n */\nfunction display_ascii_info(character: string): number"
    },
    "prompt_bertscore": {
      "es": "0.9865316683835483",
      "arb": "0.9812254563845824",
      "sw": "0.9797688998004536",
      "tr": "0.976565984906266",
      "vi": "0.9740171598568262"
    },
    "canonical_solution": "{\n    return character.charCodeAt(0);\n}",
    "instruction": {
      "en": "Write a TypeScript function `function display_ascii_info(character: string): number` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n- character (string): The input character for which ASCII information is to be displayed.\n\nReturns:\n- number: corresponding ASCII code\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```\n",
      "es": "Escribe una función de TypeScript `function display_ascii_info(character: string): number` para resolver el siguiente problema:\nMuestra la información ASCII para un carácter dado.\n\nParámetros:\n- character (string): El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n- number: código ASCII correspondiente\n\nEjemplos:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "arb": "اكتب دالة TypeScript `function display_ascii_info(character: string): number` لحل المشكلة التالية:  \nعرض معلومات ASCII للحرف المعطى.\n\nالمعطيات:\n- character (string): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n- number: رمز ASCII المقابل\n\nأمثلة:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "sw": "Andika kazi ya TypeScript `function display_ascii_info(character: string): number` kutatua tatizo lifuatalo:\nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character (string): Herufi ya pembejeo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarejesha:\n- number: msimbo wa ASCII unaolingana\n\nMifano:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "tr": "Bir TypeScript fonksiyonu `function display_ascii_info(character: string): number` yazın:\nVerilen bir karakter için ASCII bilgisini görüntüleyin.\n\nParametreler:\n- character (string): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\nDöndürülenler:\n- number: Karşılık gelen ASCII kodu\n\nÖrnekler:\n```\nconsole.log(display_ascii_info('A'));\n// beklenen çıktı: 65\n```",
      "vi": "Viết một hàm TypeScript `function display_ascii_info(character: string): number` để giải quyết vấn đề sau:\nHiển thị thông tin ASCII cho một ký tự đã cho.\n\nTham số:\n- character (string): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:\n- number: mã ASCII tương ứng\n\nVí dụ:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```"
    },
    "instruction_bertscore": {
      "es": "0.9867714152534575",
      "arb": "0.9666169863809905",
      "sw": "0.9785501037824235",
      "tr": "0.9606070269420178",
      "vi": "0.9874839024302297"
    },
    "level": "easy",
    "test": "const testDisplayAsciiInfo = (): void => {\n    console.assert(display_ascii_info('A') === 65);\n    console.assert(display_ascii_info('B') === 66); // Additional test case\n    console.assert(display_ascii_info('0') === 48); // Additional test case\n    console.assert(display_ascii_info(' ') === 32); // Additional test case\n    // console.log(\"All tests passed.\");\n};\n\ntestDisplayAsciiInfo();",
    "entry_point": "display_ascii_info",
    "signature": "function display_ascii_info(character: string): number",
    "docstring": {
      "en": "Display the ASCII information for a given character.\n\nParameters:\n- character (string): The input character for which ASCII information is to be displayed.\n\nReturns:\n- number: corresponding ASCII code\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```\n",
      "es": "Mostrar la información ASCII para un carácter dado.\n\nParámetros:\n- character (string): El carácter de entrada para el cual se mostrará la información ASCII.\n\nDevuelve:\n- number: código ASCII correspondiente\n\nEjemplos:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "arb": "عرض معلومات ASCII لحرف معين.\n\nالمعلمات:\n- character (string): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\nالقيم المعادة:\n- number: رمز ASCII المقابل\n\nأمثلة:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "sw": "Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n\nVigezo:\n- character (string): Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\nInarejesha:\n- number: nambari ya ASCII inayolingana\n\nMifano:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "tr": "Belirtilen karakter için ASCII bilgisini görüntüleyin.\n\nParametreler:\n- character (string): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\nDöndürülenler:\n- number: karşılık gelen ASCII kodu\n\nÖrnekler:\n```\nconsole.log(display_ascii_info('A'));\n// beklenen çıktı: 65\n```",
      "vi": "Hiển thị thông tin ASCII cho một ký tự đã cho.\n\nTham số:\n- character (string): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\nTrả về:\n- number: mã ASCII tương ứng\n\nVí dụ:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```"
    },
    "docstring_bertscore": {
      "es": "0.983939144650281",
      "arb": "0.9644016617413084",
      "sw": "0.9592567376117427",
      "tr": "0.9727103705799978",
      "vi": "0.9818632585380854"
    }
  },
  {
    "task_id": "TypeScript/29",
    "prompt": {
      "en": "\n/**\n * Evaluate the grade for an input integer.\n * @param score - The integer score to be evaluated.\n * @returns The grade corresponding to the input score.\n *          If the score is between 90 and 100 (inclusive), returns 'A'.\n *          Otherwise, returns 'B'.\n * \n * Examples:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "es": "/**\n * Evaluar la calificación para un entero de entrada.\n * @param score - La puntuación entera que se va a evaluar.\n * @returns La calificación correspondiente a la puntuación de entrada.\n *          Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n *          De lo contrario, devuelve 'B'.\n * \n * Ejemplos:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "arb": "/**\n * تقييم الدرجة لعدد صحيح مدخل.\n * @param score - الدرجة الصحيحة التي سيتم تقييمها.\n * @returns الدرجة المقابلة للدرجة المدخلة.\n *          إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n *          خلاف ذلك، تعيد 'B'.\n * \n * أمثلة:\n * evaluateIntegerGrade(90) // تعيد 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "sw": "/**\n * Tambua alama kwa nambari tamu ya ingizo.\n * @param score - Alama ya nambari tamu itakayotambuliwa.\n * @returns Alama inayolingana na alama ya ingizo.\n *          Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n *          Vinginevyo, inarudisha 'B'.\n * \n * Mifano:\n * evaluateIntegerGrade(90) // inarudisha 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "tr": "/**\n * Bir tamsayı notunu değerlendir.\n * @param score - Değerlendirilecek tamsayı notu.\n * @returns Girdi notuna karşılık gelen harf notu.\n *          Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n *          Aksi takdirde, 'B' döner.\n * \n * Örnekler:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "vi": "/**\n * Đánh giá điểm cho một số nguyên đầu vào.\n * @param score - Điểm số nguyên cần được đánh giá.\n * @returns Điểm tương ứng với điểm số đầu vào.\n *          Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n *          Ngược lại, trả về 'B'.\n * \n * Ví dụ:\n * evaluateIntegerGrade(90) // trả về 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9871925116612514",
      "sw": "0.9497067875219664",
      "tr": "0.9755998467329122",
      "vi": "0.9695652571266913"
    },
    "canonical_solution": "{\n    return (score >= 90 && score <= 100) ? 'A' : 'B';\n}",
    "instruction": {
      "en": "Write a TypeScript function `function evaluateIntegerGrade(score: number): string` to solve the following problem:\nEvaluate the grade for an input integer.\n@param score - The integer score to be evaluated.\n@returns The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\nExamples:\n evaluateIntegerGrade(90) // returns 'A'\n\n",
      "es": "Escribe una función de TypeScript `function evaluateIntegerGrade(score: number): string` para resolver el siguiente problema:\nEvalúa la calificación para un entero de entrada.\n@param score - La puntuación entera a evaluar.\n@returns La calificación correspondiente a la puntuación de entrada.\n         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n         De lo contrario, devuelve 'B'.\n\nEjemplos:\n evaluateIntegerGrade(90) // returns 'A'",
      "arb": "اكتب دالة TypeScript `function evaluateIntegerGrade(score: number): string` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n@param score - الدرجة الصحيحة التي سيتم تقييمها.\n@returns الدرجة المقابلة للدرجة المدخلة.\n         إذا كانت الدرجة بين 90 و 100 (شاملاً)، تعيد 'A'.\n         خلاف ذلك، تعيد 'B'.\n\nأمثلة:\n evaluateIntegerGrade(90) // يعيد 'A'",
      "sw": "Andika kazi ya TypeScript `function evaluateIntegerGrade(score: number): string` kutatua tatizo lifuatalo:\nTambua alama kwa namba kamili iliyoingizwa.\n@param score - Alama ya namba kamili inayopaswa kutathminiwa.\n@returns Alama inayolingana na alama iliyoingizwa.\n         Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n         Vinginevyo, inarudisha 'B'.\n\nMifano:\n evaluateIntegerGrade(90) // inarudisha 'A'",
      "tr": "Bir TypeScript fonksiyonu `function evaluateIntegerGrade(score: number): string` yazın:\nBir tam sayı notunu değerlendirin.\n@param score - Değerlendirilecek tam sayı notu.\n@returns Girdi notuna karşılık gelen harf notu.\n         Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n         Aksi takdirde, 'B' döner.\n\nÖrnekler:\n evaluateIntegerGrade(90) // returns 'A'",
      "vi": "Viết một hàm TypeScript `function evaluateIntegerGrade(score: number): string` để giải quyết vấn đề sau:\nĐánh giá điểm cho một số nguyên đầu vào.\n@param score - Điểm số nguyên cần được đánh giá.\n@returns Điểm tương ứng với điểm số đầu vào.\n         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n         Ngược lại, trả về 'B'.\n\nVí dụ:\n evaluateIntegerGrade(90) // trả về 'A'"
    },
    "instruction_bertscore": {
      "es": "0.9908310229810485",
      "arb": "0.9954128299803803",
      "sw": "0.9674925491005922",
      "tr": "0.9547237936861456",
      "vi": "0.9770937458286757"
    },
    "level": "easy",
    "test": "const testEvaluateIntegerGrade = (): void => {\n    console.assert(evaluateIntegerGrade(90) === 'A', \"Expected 'A' for score 90\");\n    console.assert(evaluateIntegerGrade(89) === 'B', \"Expected 'B' for score 89\");\n    console.assert(evaluateIntegerGrade(95) === 'A', \"Expected 'A' for score 95\");\n    console.assert(evaluateIntegerGrade(100) === 'A', \"Expected 'A' for score 100\");\n    console.assert(evaluateIntegerGrade(101) === 'B', \"Expected 'B' for score 101\");\n    \n    // console.log(\"All tests passed\");\n};\n\ntestEvaluateIntegerGrade();",
    "entry_point": "evaluateIntegerGrade",
    "signature": "function evaluateIntegerGrade(score: number): string",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n@param score - The integer score to be evaluated.\n@returns The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\nExamples:\n evaluateIntegerGrade(90) // returns 'A'\n\n",
      "es": "Evaluar la calificación para un entero de entrada.\n@param score - El puntaje entero a ser evaluado.\n@returns La calificación correspondiente al puntaje de entrada.\n         Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n         De lo contrario, devuelve 'B'.\n\nEjemplos:\n evaluateIntegerGrade(90) // devuelve 'A'",
      "arb": "تقييم الدرجة لعدد صحيح مدخل.\n@param score - الدرجة الصحيحة التي سيتم تقييمها.\n@returns الدرجة المقابلة للدرجة المدخلة.\n         إذا كانت الدرجة بين 90 و 100 (شاملة)، تُرجع 'A'.\n         خلاف ذلك، تُرجع 'B'.\n\nأمثلة:\n evaluateIntegerGrade(90) // تُرجع 'A'",
      "sw": "Tambua alama kwa nambari kamili iliyoingizwa.\n@param score - Alama ya nambari kamili itakayopimwa.\n@returns Alama inayolingana na alama iliyoingizwa.\n         Ikiwa alama iko kati ya 90 na 100 (pamoja), inarejesha 'A'.\n         Vinginevyo, inarejesha 'B'.\n\nMifano:\n evaluateIntegerGrade(90) // inarejesha 'A'",
      "tr": "Bir tam sayı notunu değerlendirin.\n@param score - Değerlendirilecek tamsayı puanı.\n@returns Girdi puanına karşılık gelen notu döndürür.\n         Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n         Aksi takdirde, 'B' döndürür.\n\nÖrnekler:\n evaluateIntegerGrade(90) // 'A' döndürür",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n@param score - Điểm số nguyên cần được đánh giá.\n@returns Điểm tương ứng với điểm đầu vào.\n         Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n         Ngược lại, trả về 'B'.\n\nVí dụ:\n evaluateIntegerGrade(90) // trả về 'A'"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9800302973818954",
      "sw": "0.9592746143460359",
      "tr": "0.9481916349754321",
      "vi": "0.9644660179847637"
    }
  },
  {
    "task_id": "TypeScript/30",
    "prompt": {
      "en": "\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n *\n * @param str The three-character string to be checked.\n * @return Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n * \n * Examples:\n *  checkTwoEqualDigits(\"112\") // Returns 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "es": "/**\n * Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n *\n * @param str La cadena de tres caracteres a verificar.\n * @return Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n * \n * Ejemplos:\n *  checkTwoEqualDigits(\"112\") // Devuelve 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "arb": "/**\n * يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n *\n * @param str السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n * @return يعيد 'Yes' إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n * \n * أمثلة:\n *  checkTwoEqualDigits(\"112\") // Returns 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "sw": "/**\n * Hukagua kama mfuatano wa herufi tatu una herufi mbili tu ambazo ni sawa.\n *\n * @param str Mfuatano wa herufi tatu unaohitaji kukaguliwa.\n * @return Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n * \n * Mifano:\n *  checkTwoEqualDigits(\"112\") // Inarudisha 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "tr": "/**\n * Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n *\n * @param str Kontrol edilecek üç karakterli dizge.\n * @return Girdi tam olarak iki eşit karakter içeriyorsa 'Yes' döner, aksi takdirde 'No' döner.\n * \n * Örnekler:\n *  checkTwoEqualDigits(\"112\") // 'Yes' döner\n */\nfunction checkTwoEqualDigits(str: string): string",
      "vi": "/**\n * Kiểm tra xem một chuỗi có ba ký tự có chính xác hai ký tự giống nhau hay không.\n *\n * @param str Chuỗi ba ký tự cần được kiểm tra.\n * @return Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về 'No'.\n * \n * Ví dụ:\n *  checkTwoEqualDigits(\"112\") // Trả về 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string"
    },
    "prompt_bertscore": {
      "es": "0.9882079101691018",
      "arb": "0.9744048863606064",
      "sw": "0.9485753888715915",
      "tr": "0.964832292407392",
      "vi": "0.9544894098365243"
    },
    "canonical_solution": "{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function checkTwoEqualDigits(str: string): string` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'",
      "es": "Escribe una función de TypeScript `function checkTwoEqualDigits(str: string): string` para resolver el siguiente problema:\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nParámetros:\n- str: La cadena de tres caracteres a verificar.\n\nDevuelve:\n- Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\nEjemplos:\n- checkTwoEqualDigits(\"112\") // Devuelve 'Yes'",
      "arb": "اكتب دالة TypeScript `function checkTwoEqualDigits(str: string): string` لحل المشكلة التالية:\nالتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متساويين بالضبط.\n\nالمعلمات:\n- str: السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n- تعيد 'Yes' إذا كان المدخل يحتوي على حرفين متساويين بالضبط، وإلا تعيد 'No'.\n\nأمثلة:\n- checkTwoEqualDigits(\"112\") // تعيد 'Yes'",
      "sw": "Andika kazi ya TypeScript `function checkTwoEqualDigits(str: string): string` kutatua tatizo lifuatalo:\nInakagua kama mfuatano wa herufi tatu una herufi mbili zilizo sawa.\n\nVigezo:\n- str: Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n\nInarejesha:\n- Inarejesha 'Yes' ikiwa ingizo lina herufi mbili zilizo sawa, vinginevyo 'No'.\n\nMifano:\n- checkTwoEqualDigits(\"112\") // Inarejesha 'Yes'",
      "tr": "Bir TypeScript fonksiyonu `function checkTwoEqualDigits(str: string): string` yazın ve aşağıdaki problemi çözün:\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n- str: Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n- Girdi tam olarak iki eşit karakter içeriyorsa 'Yes' döndürür, aksi takdirde 'No'.\n\nÖrnekler:\n- checkTwoEqualDigits(\"112\") // 'Yes' döndürür",
      "vi": "Viết một hàm TypeScript `function checkTwoEqualDigits(str: string): string` để giải quyết vấn đề sau:\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n- str: Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n- Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, nếu không thì 'No'.\n\nVí dụ:\n- checkTwoEqualDigits(\"112\") // Trả về 'Yes'"
    },
    "instruction_bertscore": {
      "es": "0.9810079561173491",
      "arb": "0.9657626771121595",
      "sw": "0.9469708526535917",
      "tr": "0.9744398453076685",
      "vi": "0.9720161573982808"
    },
    "level": "easy",
    "test": "function testCheckTwoEqualDigits(): void {\n    // Testing the logic with various cases.\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\");\n\n    // Additional test cases to cover more scenarios\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\n\n    // Uncomment the next line if you wish to print to console upon successful tests\n    //console.log(\"All tests passed successfully.\");\n}\n\n// Run the tests\ntestCheckTwoEqualDigits();",
    "entry_point": "checkTwoEqualDigits",
    "signature": "function checkTwoEqualDigits(str: string): string",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'",
      "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nParámetros:\n- str: La cadena de tres caracteres que se va a verificar.\n\nDevuelve:\n- Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\nEjemplos:\n- checkTwoEqualDigits(\"112\") // Devuelve 'Yes'",
      "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعلمات:\n- str: السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n- تعيد 'Yes' إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا تعيد 'No'.\n\nأمثلة:\n- checkTwoEqualDigits(\"112\") // تعيد 'Yes'",
      "sw": "Hukagua ikiwa mfuatano wa herufi tatu una herufi mbili ambazo ni sawa.\n\nVigezo:\n- str: Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n\nRudisha:\n- Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n\nMifano:\n- checkTwoEqualDigits(\"112\") // Inarudisha 'Yes'",
      "tr": "Checks if a three-character string has exactly two characters that are the same.\n\nParametreler:\n- str: Kontrol edilecek üç karakterli dize.\n\nDöndürülenler:\n- Girdi tam olarak iki eşit karaktere sahipse 'Evet', aksi takdirde 'Hayır' döner.\n\nÖrnekler:\n- checkTwoEqualDigits(\"112\") // 'Evet' döner",
      "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n- str: Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n- Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại 'No'.\n\nVí dụ:\n- checkTwoEqualDigits(\"112\") // Trả về 'Yes'"
    },
    "docstring_bertscore": {
      "es": "0.9852697695728337",
      "arb": "0.9541565053179099",
      "sw": "0.9455871934193028",
      "tr": "0.9832246711696985",
      "vi": "0.9662171434239673"
    }
  },
  {
    "task_id": "TypeScript/31",
    "prompt": {
      "en": "\n/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * \n * @param s The input string.\n * @returns The minimum number of rounds to make all characters in the string the same.\n * \n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "es": "/**\n * Dada una cadena que consiste en letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro\n * en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena\n * esté compuesta por el mismo carácter.\n * \n * @param s La cadena de entrada.\n * @returns El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n * \n * Ejemplos:\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "arb": "/**\n * بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر\n * في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة\n * مكونة من نفس الحرف.\n * \n * @param s السلسلة المدخلة.\n * @returns الحد الأدنى لعدد الجولات لجعل جميع الأحرف في السلسلة متشابهة.\n * \n * أمثلة:\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "sw": "/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine\n * katika kila mzunguko. Kazi hii inakokotoa idadi ndogo ya mizunguko inayohitajika kufanya kamba\n * iwe na herufi sawa.\n * \n * @param s Kamba ya ingizo.\n * @returns Idadi ndogo ya mizunguko ya kufanya herufi zote katika kamba kuwa sawa.\n * \n * Mifano:\n * minRoundsToSameChar(\"aab\") // inarudisha 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "tr": "/**\n * Küçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karaktere değiştirebilirsiniz.\n * Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n * \n * @param s Girdi dizisi.\n * @returns Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n * \n * Örnekler:\n * minRoundsToSameChar(\"aab\") // 1 döndürür\n */\nfunction minRoundsToSameChar(s: string): number",
      "vi": "/**\n * Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác\n * trong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi\n * bao gồm cùng một ký tự.\n * \n * @param s Chuỗi đầu vào.\n * @returns Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n * \n * Ví dụ:\n * minRoundsToSameChar(\"aab\") // trả về 1\n */\nfunction minRoundsToSameChar(s: string): number"
    },
    "prompt_bertscore": {
      "es": "0.984707645594505",
      "arb": "0.9941503352785226",
      "sw": "0.9657428140740559",
      "tr": "0.9715477869598006",
      "vi": "0.9731862889729573"
    },
    "canonical_solution": "{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function minRoundsToSameChar(s: string): number` to solve the following problem:\nGiven a string consisting of lowercase English letters, you can change one character to another\nin each round. This function calculates the minimum number of rounds needed to make the string\ncomposed of the same character.\n\n@param s The input string.\n@returns The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1",
      "es": "Escribe una función de TypeScript `function minRoundsToSameChar(s: string): number` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter.\n\n@param s La cadena de entrada.\n@returns El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n\nEjemplos:\nminRoundsToSameChar(\"aab\") // returns 1",
      "arb": "اكتب دالة TypeScript `function minRoundsToSameChar(s: string): number` لحل المشكلة التالية:\nبالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف.\n\n@param s السلسلة المدخلة.\n@returns الحد الأدنى لعدد الجولات لجعل جميع الحروف في السلسلة متشابهة.\n\nأمثلة:\nminRoundsToSameChar(\"aab\") // returns 1",
      "sw": "Andika kazi ya TypeScript `function minRoundsToSameChar(s: string): number` kutatua tatizo lifuatalo:\nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine\nkatika kila raundi. Kazi hii inahesabu idadi ndogo ya raundi zinazohitajika kufanya kamba\niwe na herufi sawa.\n\n@param s Kamba ya ingizo.\n@returns Idadi ndogo ya raundi za kufanya herufi zote kwenye kamba ziwe sawa.\n\nMifano:\nminRoundsToSameChar(\"aab\") // inarudisha 1",
      "tr": "Bir TypeScript fonksiyonu `function minRoundsToSameChar(s: string): number` yazın. Aşağıdaki problemi çözmek için:\nKüçük harflerden oluşan bir dize verildiğinde, her turda bir karakteri başka bir karaktere değiştirebilirsiniz. Bu fonksiyon, dizenin aynı karakterden oluşması için gereken minimum tur sayısını hesaplar.\n\n@param s Girdi dizisi.\n@returns Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n\nÖrnekler:\nminRoundsToSameChar(\"aab\") // 1 döndürür",
      "vi": "Viết một hàm TypeScript `function minRoundsToSameChar(s: string): number` để giải quyết vấn đề sau:\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác\ntrong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi\nbao gồm cùng một ký tự.\n\n@param s Chuỗi đầu vào.\n@returns Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n\nVí dụ:\nminRoundsToSameChar(\"aab\") // trả về 1"
    },
    "instruction_bertscore": {
      "es": "0.9843783164227492",
      "arb": "0.9960695020200816",
      "sw": "0.9699946960104887",
      "tr": "0.9740499338696971",
      "vi": "0.9859188936580557"
    },
    "level": "middle",
    "test": "const testMinRoundsToSameChar = (): void => {\n    console.assert(minRoundsToSameChar(\"aab\") === 1, \"Expected 1 round for 'aab'\");\n    console.assert(minRoundsToSameChar(\"abc\") === 2, \"Expected 2 rounds for 'abc'\");\n    console.assert(minRoundsToSameChar(\"aaa\") === 0, \"Expected 0 rounds for 'aaa'\");\n    console.assert(minRoundsToSameChar(\"abab\") === 1, \"Expected 1 round for 'abab'\");\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0, \"Expected 0 rounds for 'zzzzz'\");\n};\n\ntestMinRoundsToSameChar();",
    "entry_point": "minRoundsToSameChar",
    "signature": "function minRoundsToSameChar(s: string): number",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, you can change one character to another\nin each round. This function calculates the minimum number of rounds needed to make the string\ncomposed of the same character.\n\n@param s The input string.\n@returns The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1",
      "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, puedes cambiar un carácter por otro en cada ronda. Esta función calcula el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter.\n\n@param s La cadena de entrada.\n@returns El número mínimo de rondas para hacer que todos los caracteres en la cadena sean iguales.\n\nEjemplos:\nminRoundsToSameChar(\"aab\") // returns 1",
      "arb": "بالنظر إلى سلسلة تتكون من حروف إنجليزية صغيرة، يمكنك تغيير حرف واحد إلى آخر في كل جولة. تقوم هذه الدالة بحساب الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف.\n\n@param s السلسلة المدخلة.\n@returns الحد الأدنى لعدد الجولات لجعل جميع الأحرف في السلسلة متشابهة.\n\nأمثلة:\nminRoundsToSameChar(\"aab\") // returns 1",
      "sw": "Ukipiwa kamba inayojumuisha herufi ndogo za Kiingereza, unaweza kubadilisha herufi moja kuwa nyingine\nkatika kila raundi. Kazi hii inahesabu idadi ndogo ya raundi zinazohitajika kufanya kamba\niwe na herufi sawa.\n\n@param s Mlolongo wa ingizo.\n@returns Idadi ndogo ya raundi zinazohitajika kufanya herufi zote kwenye mlolongo kuwa sawa.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1",
      "tr": "Verilen küçük harflerden oluşan bir dize, her turda bir karakteri başka bir karaktere değiştirebilirsiniz. Bu fonksiyon, diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısını hesaplar.\n\n@param s Girdi dizisi.\n@returns Dizideki tüm karakterleri aynı yapmak için gereken minimum tur sayısı.\n\nÖrnekler:\nminRoundsToSameChar(\"aab\") // 1 döndürür",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, bạn có thể thay đổi một ký tự thành ký tự khác\ntrong mỗi vòng. Hàm này tính toán số vòng tối thiểu cần thiết để làm cho chuỗi\nbao gồm cùng một ký tự.\n\n@param s Chuỗi đầu vào.\n@returns Số vòng tối thiểu để làm cho tất cả các ký tự trong chuỗi giống nhau.\n\nVí dụ:\nminRoundsToSameChar(\"aab\") // trả về 1"
    },
    "docstring_bertscore": {
      "es": "0.9827853007668493",
      "arb": "0.9879411495673719",
      "sw": "0.986899730479606",
      "tr": "0.9751632571553975",
      "vi": "0.9788518233312155"
    }
  },
  {
    "task_id": "TypeScript/32",
    "prompt": {
      "en": "\n/**\n * Calculates the year Y_n when the n-th event occurs, considering that each\n * event has a periodicity of a_i years. The countdown for event i+1 starts\n * the year after event i occurs.\n *\n * @param n - the total number of events\n * @param signs - an array representing the periodicities of the events\n * @returns The year when the n-th event occurs\n * \n * Example:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "es": "/**\n * Calcula el año Y_n cuando ocurre el enésimo evento, considerando que cada\n * evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza\n * el año después de que ocurre el evento i.\n *\n * @param n - el número total de eventos\n * @param signs - un arreglo que representa las periodicidades de los eventos\n * @returns El año en que ocurre el enésimo evento\n * \n * Ejemplo:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "arb": "/**\n * يحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن كل\n * حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1\n * في السنة التي تلي حدوث الحدث i.\n *\n * @param n - العدد الإجمالي للأحداث\n * @param signs - مصفوفة تمثل دوريات الأحداث\n * @returns السنة التي يحدث فيها الحدث n\n * \n * مثال:\n * apocalypseYear(6, [3,2,4,5,9,18]) // يعيد 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "sw": "/**\n * Inahesabu mwaka Y_n ambapo tukio la n linatokea, ikizingatiwa kwamba kila\n * tukio lina kipindi cha a_i miaka. Hesabu ya tukio i+1 inaanza\n * mwaka baada ya tukio i kutokea.\n *\n * @param n - jumla ya idadi ya matukio\n * @param signs - safu inayowakilisha vipindi vya matukio\n * @returns Mwaka ambapo tukio la n linatokea\n * \n * Mfano:\n * apocalypseYear(6, [3,2,4,5,9,18]) // inarudisha 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "tr": "/**\n * n-inci olay meydana geldiğinde Y_n yılını hesaplar, her bir\n * olayın a_i yıllık bir periyodunun olduğunu dikkate alarak. i+1 olayının geri sayımı,\n * i olayı meydana geldikten sonraki yıl başlar.\n *\n * @param n - olayların toplam sayısı\n * @param signs - olayların periyotlarını temsil eden bir dizi\n * @returns n-inci olayın meydana geldiği yıl\n * \n * Örnek:\n * apocalypseYear(6, [3,2,4,5,9,18]) // 36 döndürür\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "vi": "/**\n * Tính toán năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng mỗi\n * sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu\n * vào năm sau khi sự kiện i xảy ra.\n *\n * @param n - tổng số sự kiện\n * @param signs - một mảng đại diện cho chu kỳ của các sự kiện\n * @returns Năm khi sự kiện thứ n xảy ra\n * \n * Ví dụ:\n * apocalypseYear(6, [3,2,4,5,9,18]) // trả về 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9862351132246633",
      "arb": "0.9628501598350448",
      "sw": "0.9579400168158624",
      "tr": "0.9736018237300823",
      "vi": "0.9605647186708575"
    },
    "canonical_solution": "{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function apocalypseYear(n: number, signs: number[]): number` to solve the following problem:\nCalculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n\nParameters:\n- n - the total number of events\n- signs - an array representing the periodicities of the events\n\nReturns The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n",
      "es": "Escribe una función de TypeScript `function apocalypseYear(n: number, signs: number[]): number` para resolver el siguiente problema:\nCalcula el año Y_n cuando ocurre el n-ésimo evento, considerando que cada evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza el año después de que ocurre el evento i.\n\nParámetros:\n- n - el número total de eventos\n- signs - un arreglo que representa las periodicidades de los eventos\n\nDevuelve El año en que ocurre el n-ésimo evento\n\nEjemplo:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36",
      "arb": "اكتب دالة TypeScript `function apocalypseYear(n: number, signs: number[]): number` لحل المشكلة التالية:\nتحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن كل حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1 في السنة التي تلي حدوث الحدث i.\n\nالمعطيات:\n- n - العدد الإجمالي للأحداث\n- signs - مصفوفة تمثل دوريات الأحداث\n\nتُرجع السنة التي يحدث فيها الحدث n\n\nمثال:\napocalypseYear(6, [3,2,4,5,9,18]) // يعيد 36",
      "sw": "Andika kazi ya TypeScript `function apocalypseYear(n: number, signs: number[]): number` kutatua tatizo lifuatalo:\nHesabu mwaka Y_n wakati tukio la n linapotokea, ukizingatia kwamba kila tukio lina kipindi cha a_i miaka. Muda wa kuhesabu kwa tukio i+1 huanza mwaka baada ya tukio i kutokea.\n\nVigezo:\n- n - jumla ya idadi ya matukio\n- signs - safu inayowakilisha vipindi vya matukio\n\nInarudisha Mwaka ambapo tukio la n linatokea\n\nMfano:\napocalypseYear(6, [3,2,4,5,9,18]) // inarudisha 36",
      "tr": "Bir TypeScript fonksiyonu `function apocalypseYear(n: number, signs: number[]): number` yazın ve aşağıdaki problemi çözün:\nHer bir olayın a_i yıl periyoduna sahip olduğunu dikkate alarak, n'inci olayın gerçekleştiği Y_n yılını hesaplar. i+1'inci olayın geri sayımı, i'inci olay gerçekleştiği yılın ardından başlar.\n\nParametreler:\n- n - toplam olay sayısı\n- signs - olayların periyodlarını temsil eden bir dizi\n\nDöndürülen Değer n'inci olayın gerçekleştiği yıl\n\nÖrnek:\napocalypseYear(6, [3,2,4,5,9,18]) // 36 değerini döndürür",
      "vi": "Viết một hàm TypeScript `function apocalypseYear(n: number, signs: number[]): number` để giải quyết vấn đề sau:\nTính toán năm Y_n khi sự kiện thứ n xảy ra, với giả định rằng mỗi sự kiện có chu kỳ a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu vào năm sau khi sự kiện i xảy ra.\n\nTham số:\n- n - tổng số sự kiện\n- signs - một mảng đại diện cho chu kỳ của các sự kiện\n\nTrả về Năm khi sự kiện thứ n xảy ra\n\nVí dụ:\napocalypseYear(6, [3,2,4,5,9,18]) // trả về 36"
    },
    "instruction_bertscore": {
      "es": "0.9934589029221401",
      "arb": "0.948105032129301",
      "sw": "0.9427261214108762",
      "tr": "0.9455466728215716",
      "vi": "0.9533633742064376"
    },
    "level": "easy",
    "test": "const testApocalypseYear = (): void => {\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36);\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5);\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5);\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012);\n    console.assert(apocalypseYear(2, [1, 2]) === 2);\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6);\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13);\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10);\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15);\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14);\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800);\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6);\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998);\n};\n\ntestApocalypseYear();",
    "entry_point": "apocalypseYear",
    "signature": "function apocalypseYear(n: number, signs: number[]): number",
    "docstring": {
      "en": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n\nParameters:\n- n - the total number of events\n- signs - an array representing the periodicities of the events\n\nReturns The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n",
      "es": "Calcula el año Y_n cuando ocurre el n-ésimo evento, considerando que cada evento tiene una periodicidad de a_i años. La cuenta regresiva para el evento i+1 comienza el año después de que ocurre el evento i.\n\nParámetros:\n- n - el número total de eventos\n- signs - un arreglo que representa las periodicidades de los eventos\n\nDevuelve El año en que ocurre el n-ésimo evento\n\nEjemplo:\napocalypseYear(6, [3,2,4,5,9,18]) // devuelve 36",
      "arb": "يحسب السنة Y_n عندما يحدث الحدث n، مع الأخذ في الاعتبار أن كل حدث له دورية a_i سنوات. يبدأ العد التنازلي للحدث i+1 في السنة التي تلي حدوث الحدث i.\n\nالمعلمات:\n- n - العدد الإجمالي للأحداث\n- signs - مصفوفة تمثل دوريات الأحداث\n\nيعيد السنة التي يحدث فيها الحدث n\n\nمثال:\napocalypseYear(6, [3,2,4,5,9,18]) // يعيد 36",
      "sw": "Hesabu mwaka Y_n ambapo tukio la n linatokea, ukizingatia kwamba kila tukio lina kipindi cha a_i miaka. Muda wa kuhesabu kwa tukio la i+1 huanza mwaka mmoja baada ya tukio la i kutokea.\n\nVigezo:\n- n - jumla ya idadi ya matukio\n- signs - safu inayowakilisha vipindi vya matukio\n\nInarejesha Mwaka ambapo tukio la n linatokea\n\nMfano:\napocalypseYear(6, [3,2,4,5,9,18]) // inarejesha 36",
      "tr": "Y_n yılını hesaplar, n'inci olayın gerçekleştiği yıl, her olayın a_i yıl periyoduna sahip olduğunu dikkate alarak. i+1 olayının geri sayımı, i olayı gerçekleştiği yılın ardından başlar.\n\nParametreler:\n- n - toplam olay sayısı\n- signs - olayların periyotlarını temsil eden bir dizi\n\nDöndürür n'inci olayın gerçekleştiği yılı\n\nÖrnek:\napocalypseYear(6, [3,2,4,5,9,18]) // 36 döndürür",
      "vi": "Tính toán năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng mỗi sự kiện có chu kỳ là a_i năm. Đếm ngược cho sự kiện i+1 bắt đầu vào năm sau khi sự kiện i xảy ra.\n\nTham số:\n- n - tổng số sự kiện\n- signs - một mảng đại diện cho chu kỳ của các sự kiện\n\nTrả về Năm khi sự kiện thứ n xảy ra\n\nVí dụ:\napocalypseYear(6, [3,2,4,5,9,18]) // trả về 36"
    },
    "docstring_bertscore": {
      "es": "0.9926536553574247",
      "arb": "0.9502681169787709",
      "sw": "0.9180586116509155",
      "tr": "0.9414334348911011",
      "vi": "0.940316933519304"
    }
  },
  {
    "task_id": "TypeScript/33",
    "prompt": {
      "en": "\n/**\n * This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\n * Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\n * Then the result is the remainder of x' divided by y.\n * For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Given a prime number p, there will be several queries. For each query, an integer n is given,\n * and you need to compute the value of n! ⊕ p, where n! is the factorial of n,\n * i.e. the product of all positive integers less than or equal to n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "es": "/**\n * Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.\n * De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.\n * Entonces el resultado es el resto de x' dividido por y.\n * Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,\n * y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,\n * es decir, el producto de todos los enteros positivos menores o iguales a n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "arb": "/**\n * هذه المسألة تقدم عملية باقي جديدة، يرمز لها بالرمز \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y.\n * وإلا، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى القيمة النهائية بـ x'.\n * ثم تكون النتيجة هي باقي قسمة x' على y.\n * على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\n * بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،\n * وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n،\n * أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "sw": "/**\n * Shida hii inatambulisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y.\n * Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'.\n * Kisha matokeo ni baki ya x' iliyogawanywa na y.\n * Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa,\n * na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n,\n * yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "tr": "/**\n * Bu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtır.\n * x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\n * Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\n * Sonra sonuç x' in y'ye bölümünden kalan olur.\n * Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Verilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir\n * ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\n * yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımı.\n * \n * @example\n * newModuloFactorial(3, 7); // 6 döndürür\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "vi": "/**\n * Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y.\n * Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'.\n * Sau đó kết quả là phần dư của x' chia cho y.\n * Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho,\n * và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n,\n * tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n * \n * @example\n * newModuloFactorial(3, 7); // trả về 6\n */\nfunction newModuloFactorial(n: number, p: number): number {"
    },
    "prompt_bertscore": {
      "es": "0.9949847815092501",
      "arb": "0.993190751907743",
      "sw": "0.9826824102294732",
      "tr": "0.9751165790158544",
      "vi": "0.982976780454167"
    },
    "canonical_solution": "const pj: number[] = new Array(p).fill(1);\n    for (let i = 2; i < p; i++) pj[i] = (i * pj[i - 1]) % p;\n    \n    let ans = 1;\n    while (n > 0) {\n        ans = (ans * pj[n % p]) % p;\n        ans = ((n / p) & 1) ? p - ans : ans;\n        n = Math.floor(n / p);\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function newModuloFactorial(n: number, p: number): number` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol '⊕'.\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y.\nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "es": "Escribe una función de TypeScript `function newModuloFactorial(n: number, p: number): number` para resolver el siguiente problema:\nEste problema introduce una nueva operación de módulo, denotada por el símbolo '⊕'.\nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.\nDe lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.\nEntonces, el resultado es el resto de x' dividido por y.\nPor ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,\ny necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,\nes decir, el producto de todos los enteros positivos menores o iguales a n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "arb": "اكتب دالة TypeScript `function newModuloFactorial(n: number, p: number): number` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية جديدة للمودولو، يرمز لها بالرمز '⊕'.\nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y.\nوإلا، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع الإشارة إلى القيمة النهائية كـ x'.\nثم تكون النتيجة هي باقي قسمة x' على y.\nعلى سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،\nوتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n،\nأي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n\n@example\nnewModuloFactorial(3, 7); // يعيد 6",
      "sw": "Andika kazi ya TypeScript `function newModuloFactorial(n: number, p: number): number` kutatua tatizo lifuatalo:\nTatizo hili linaanzisha operesheni mpya ya modulo, inayowakilishwa na alama '⊕'.\nWakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y.\nVinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'.\nKisha matokeo ni baki ya x' iliyogawanywa na y.\nKwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa,\nna unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n,\nyaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "tr": "Bir TypeScript fonksiyonu `function newModuloFactorial(n: number, p: number): number` yazın ve aşağıdaki problemi çözün:\nBu problem, '⊕' sembolüyle belirtilen yeni bir modül işlemi tanıtmaktadır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\nAksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\nDaha sonra sonuç, x' in y'ye bölümünden kalan olur.\nÖrneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nBir asal sayı p verildiğinde, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir,\nve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\nyani n'den küçük veya eşit olan tüm pozitif tamsayıların çarpımıdır.\n\n@example\nnewModuloFactorial(3, 7); // 6 döndürür",
      "vi": "Viết một hàm TypeScript `function newModuloFactorial(n: number, p: number): number` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng '⊕'.\nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y.\nNgược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'.\nSau đó kết quả là phần dư của x' chia cho y.\nVí dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho,\nvà bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n,\ntức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6"
    },
    "instruction_bertscore": {
      "es": "0.9928806898829475",
      "arb": "0.9875965258562764",
      "sw": "0.9822100671833723",
      "tr": "0.9785945969877753",
      "vi": "0.987018908708227"
    },
    "level": "easy",
    "test": "(function testNewModuloFactorial(): void {\n    console.assert(newModuloFactorial(3, 7) === 6, 'Test at n=3, p=7 failed');\n    console.assert(newModuloFactorial(10, 3) === 1, 'Test at n=10, p=3 failed');\n    console.assert(newModuloFactorial(11, 7) === 4, 'Test at n=11, p=7 failed');\n    console.assert(newModuloFactorial(45, 7) === 1, 'Test at n=45, p=7 failed');\n    console.assert(newModuloFactorial(14, 7) === 2, 'Test at n=14, p=7 failed');\n    console.assert(newModuloFactorial(1919, 10007) === 3152, 'Test at n=1919, p=10007 failed');\n    console.assert(newModuloFactorial(810, 10007) === 3679, 'Test at n=810, p=10007 failed');\n    console.assert(newModuloFactorial(1, 2) === 1, 'Test at n=1, p=2 failed');\n    console.assert(newModuloFactorial(5, 11) === 10, 'Test at n=5, p=11 failed');\n    console.assert(newModuloFactorial(6, 13) === 5, 'Test at n=6, p=13 failed');\n    console.assert(newModuloFactorial(8, 17) === 13, 'Test at n=8, p=17 failed');\n    console.assert(newModuloFactorial(15, 19) === 16, 'Test at n=15, p=19 failed');\n    console.assert(newModuloFactorial(21, 23) === 1, 'Test at n=21, p=23 failed');\n    console.assert(newModuloFactorial(30, 29) === 28, 'Test at n=30, p=29 failed');\n    console.assert(newModuloFactorial(100, 101) === 100, 'Test at n=100, p=101 failed');\n})();",
    "entry_point": "newModuloFactorial",
    "signature": "function newModuloFactorial(n: number, p: number): number",
    "docstring": {
      "en": "This problem introduces a new modulo operation, denoted by the symbol '⊕'.\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y.\nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo '⊕'.  \nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y.  \nDe lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'.  \nEntonces el resultado es el resto de x' dividido por y.  \nPor ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n,  \ny necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n,  \nes decir, el producto de todos los enteros positivos menores o iguales a n.\n\n@example\nnewModuloFactorial(3, 7); // devuelve 6",
      "arb": "هذه المشكلة تقدم عملية جديدة للباقي، يرمز لها بالرمز '⊕'.  \nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y.  \nوإلا، يتم قسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، ويتم الإشارة إلى القيمة النهائية بـ x'.  \nثم تكون النتيجة هي باقي قسمة x' على y.  \nعلى سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.  \nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n،  \nويجب عليك حساب قيمة n! ⊕ p، حيث n! هو مضروب n،  \nأي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n\n@example  \nnewModuloFactorial(3, 7); // يعيد 6",
      "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayowakilishwa na alama '⊕'. Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isibaki kuwa kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya msingi p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n\n@example\nnewModuloFactorial(3, 7); // inarudisha 6",
      "tr": "Bu problem, '⊕' sembolüyle gösterilen yeni bir modül işlemi tanıtmaktadır.\nx ⊕ y hesaplanırken, eğer x y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur.\nAksi takdirde, x y'nin katı olmadığı sürece x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin.\nSonra sonuç, x' in y'ye bölümünden kalan olur.\nÖrneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir,\nve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir,\nyani n'den küçük veya eşit olan tüm pozitif tamsayıların çarpımıdır.\n\n@example\nnewModuloFactorial(3, 7); // 6 döndürür",
      "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng '⊕'. Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n\n@example\nnewModuloFactorial(3, 7); // trả về 6"
    },
    "docstring_bertscore": {
      "es": "0.9932056491863206",
      "arb": "0.9805407774611551",
      "sw": "0.9817428885271783",
      "tr": "0.9723546235675643",
      "vi": "0.9833883426036713"
    }
  },
  {
    "task_id": "TypeScript/34",
    "prompt": {
      "en": "\n/**\n * You are given an array a of n integers. You can perform at most one operation where\n * you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n * with x, at a cost of (j - i + 1).\n * Find the minimum cost to make all elements in the array equal.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "es": "/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j]\n * con x, a un costo de (j - i + 1).\n * Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "arb": "/**\n * لديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث\n * تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j]\n * بـ x، بتكلفة (j - i + 1).\n * جد الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "sw": "/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\n * unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\n * na x, kwa gharama ya (j - i + 1).\n * Pata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "tr": "/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları\n * x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\n * Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "vi": "/**\n * Bạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác trong đó\n * bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j]\n * bằng x, với chi phí là (j - i + 1).\n * Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9891156510104312",
      "sw": "0.9845090152134701",
      "tr": "0.9394924188076282",
      "vi": "0.9832860479574383"
    },
    "canonical_solution": "let j = 0, p = 1, q = 0, c, d;\n  let k = n;\n  for (p = 1; p < k; p++) {\n      if (a[p] !== a[p - 1])\n          break;\n  }\n  for (q = k - 1; q > p; q--) {\n      if (a[q] !== a[p - 1])\n          break;\n  }\n  for (d = k - 2; d >= 0; d--) {\n      if (a[d] !== a[d + 1])\n          break;\n  }\n  for (c = 0; c < d; c++) {\n      if (a[c] !== a[c + 1])\n          break;\n  }\n  if (q - p + 1 < d - c + 1)\n      return q - p + 1;\n  else\n      return d - c + 1;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function makeEqualAgain(n: number, a: number[]): number` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "es": "Escribe una función de TypeScript `function makeEqualAgain(n: number, a: number[]): number` para resolver el siguiente problema:\nSe te da un array a de n enteros. Puedes realizar como máximo una operación donde\nseleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j]\ncon x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.",
      "arb": "اكتب دالة TypeScript `function makeEqualAgain(n: number, a: number[]): number` لحل المشكلة التالية:\nأنت مُعطى مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث\nتختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j]\nبـ x، بتكلفة (j - i + 1).\nاعثر على الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.",
      "sw": "Andika kazi ya TypeScript `function makeEqualAgain(n: number, a: number[]): number` kutatua tatizo lifuatalo:\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo\nunachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j]\nna x, kwa gharama ya (j - i + 1).\nPata gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.",
      "tr": "Bir TypeScript fonksiyonu `function makeEqualAgain(n: number, a: number[]): number` yazın ve aşağıdaki problemi çözün:\nn tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.",
      "vi": "Viết một hàm TypeScript `function makeEqualAgain(n: number, a: number[]): number` để giải quyết vấn đề sau:\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác trong đó\nbạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j]\nbằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9956897207315429",
      "sw": "0.9698161272979384",
      "tr": "0.9531786479520751",
      "vi": "0.990560289771698"
    },
    "level": "middle",
    "test": "function testMakeEqualAgain(): void {\n  console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4);\n  console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0);\n  console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2);\n  console.assert(makeEqualAgain(3, [1, 2, 3]) === 2);\n  console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6);\n  console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7);\n  \n  console.assert(makeEqualAgain(3, [1, 2, 1]) === 1);\n  console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1);\n  console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0);\n  console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1);\n  console.assert(makeEqualAgain(1, [1]) === 0);\n  console.assert(makeEqualAgain(2, [1, 2]) === 1);\n  console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2);\n  console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2);\n  console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3);\n  console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5);\n\n};\n\ntestMakeEqualAgain();",
    "entry_point": "makeEqualAgain",
    "signature": "function makeEqualAgain(n: number, a: number[]): number",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.",
      "arb": "تم إعطاؤك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).  \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.",
      "sw": "Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). \nPata gharama ndogo zaidi ya kufanya vipengele vyote kwenye safu kuwa sawa.",
      "tr": "Bir n tam sayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz; bu işlemde i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) kadardır. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau."
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.993584040062192",
      "sw": "0.9802819620746667",
      "tr": "0.9333432194715502",
      "vi": "0.9758252922153868"
    }
  },
  {
    "task_id": "TypeScript/35",
    "prompt": {
      "en": "\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\n * this function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\n * and they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\n * Movement is done in positive numbers. The player forced to only move stones in the last pile loses.\n * Assuming optimal play, the function determines the winner.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "es": "/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras,\n * esta función identifica al ganador de un juego jugado por Charlie y Dan. El juego comienza con Charlie,\n * y ellos alternan turnos moviendo piedras desde la pila más a la izquierda no vacía a la pila adyacente a la derecha.\n * El movimiento se realiza en números positivos. El jugador obligado a mover piedras solo en la última pila pierde.\n * Suponiendo un juego óptimo, la función determina el ganador.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "arb": "/**\n * بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد إيجابي من الحجارة،\n * تحدد هذه الدالة الفائز في لعبة يلعبها تشارلي ودان. تبدأ اللعبة مع تشارلي،\n * ويتناوبان الأدوار في نقل الحجارة من الكومة غير الفارغة الأقصى إلى اليسار إلى الكومة المجاورة على اليمين.\n * يتم التحرك بأعداد إيجابية. اللاعب الذي يُجبر على نقل الحجارة فقط في الكومة الأخيرة يخسر.\n * بافتراض اللعب الأمثل، تحدد الدالة الفائز.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */",
      "sw": "/**\n * Ukipewa mlolongo wa marundo N ya mawe yaliyopewa namba kutoka 1 hadi N, kila moja likiwa na idadi chanya ya mawe,\n * kazi hii inatambua mshindi wa mchezo unaochezwa na Charlie na Dan. Mchezo unaanza na Charlie,\n * na wanabadilishana zamu kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu.\n * Uhamishaji unafanywa kwa namba chanya. Mchezaji anayelazimika kuhamisha mawe tu kwenye rundo la mwisho anapoteza.\n * Kwa kudhani uchezaji bora, kazi hii inaamua mshindi.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // inarudisha \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "tr": "/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içeren,\n * bu fonksiyon Charlie ve Dan tarafından oynanan bir oyunun kazananını belirler. Oyun Charlie ile başlar\n * ve taşları soldaki en dolu olmayan yığından bitişik sağ yığına hareket ettirerek sırayla oynarlar.\n * Hareket pozitif sayılarla yapılır. Sadece son yığındaki taşları hareket ettirmek zorunda kalan oyuncu kaybeder.\n * Optimal oyun varsayılarak, fonksiyon kazananı belirler.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // \"Dan\" döndürür\n */\nfunction gameWinner(piles: number[]): string",
      "vi": "/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương,\n * hàm này xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Trò chơi bắt đầu với Charlie,\n * và họ lần lượt di chuyển đá từ đống không rỗng bên trái nhất sang đống liền kề bên phải.\n * Việc di chuyển được thực hiện với số lượng dương. Người chơi bị buộc phải chỉ di chuyển đá trong đống cuối cùng sẽ thua.\n * Giả sử chơi tối ưu, hàm xác định người chiến thắng.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // trả về \"Dan\"\n */\nfunction gameWinner(piles: number[]): string"
    },
    "prompt_bertscore": {
      "es": "0.9711417864609653",
      "arb": "0.9522287974699662",
      "sw": "0.9520516191700832",
      "tr": "0.9612599250044795",
      "vi": "0.9599153959552544"
    },
    "canonical_solution": "{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    // With only two piles, Charlie always wins.\n    if (n === 2) {\n        return \"Charlie\";\n    }\n    // If the first pile has only one stone, Dan wins.\n    if (firstPileStones === 1) {\n        return \"Dan\";\n    }\n    // In all other cases, Charlie wins.\n    return \"Charlie\";\n}",
    "instruction": {
      "en": "Write a TypeScript function `function gameWinner(piles: number[]): string` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\nthis function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\nand they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\nMovement is done in positive numbers. The player forced to only move stones in the last pile loses.\nAssuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"\n",
      "es": "Escribe una función de TypeScript `function gameWinner(piles: number[]): string` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras,\nesta función identifica al ganador de un juego jugado por Charlie y Dan. El juego comienza con Charlie,\ny ellos alternan turnos moviendo piedras desde la pila no vacía más a la izquierda hacia la pila adyacente a la derecha.\nEl movimiento se realiza en números positivos. El jugador obligado a mover piedras solo en la última pila pierde.\nAsumiendo un juego óptimo, la función determina el ganador.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "arb": "اكتب دالة TypeScript `function gameWinner(piles: number[]): string` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N من أكوام الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد موجب من الحجارة،\nتحدد هذه الدالة الفائز في لعبة يلعبها تشارلي ودان. تبدأ اللعبة مع تشارلي،\nويتناوبون الأدوار في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين.\nيتم النقل بأعداد موجبة. اللاعب الذي يُجبر على نقل الحجارة فقط في الكومة الأخيرة يخسر.\nبافتراض اللعب الأمثل، تحدد الدالة الفائز.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "sw": "Andika kazi ya TypeScript `function gameWinner(piles: number[]): string` kutatua tatizo lifuatalo:\nUkipiwa mlolongo wa N wa marundo ya mawe yaliyohesabiwa kutoka 1 hadi N, kila moja likiwa na idadi chanya ya mawe,\nkazi hii inatambua mshindi wa mchezo unaochezwa na Charlie na Dan. Mchezo unaanza na Charlie,\nna wanabadilisha zamu wakihamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu.\nUhamishaji unafanywa kwa idadi chanya. Mchezaji anayelazimishwa kuhamisha mawe tu kwenye rundo la mwisho anapoteza.\nKwa kudhani uchezaji bora, kazi inabainisha mshindi.\n\n@example\ngameWinner([3, 1, 2, 2]) // inarudisha \"Dan\"",
      "tr": "Bir TypeScript fonksiyonu `function gameWinner(piles: number[]): string` yazın ve aşağıdaki problemi çözün:\n1'den N'ye kadar numaralandırılmış, her biri pozitif sayıda taş içeren N taş yığını dizisi verildiğinde,\nbu fonksiyon Charlie ve Dan tarafından oynanan bir oyunun kazananını belirler. Oyun Charlie ile başlar\nve sırayla taşları en soldaki boş olmayan yığından bitişik sağ yığına hareket ettirirler.\nHareket pozitif sayılarla yapılır. Sadece son yığındaki taşları hareket ettirmek zorunda kalan oyuncu kaybeder.\nOptimal oyun varsayılarak, fonksiyon kazananı belirler.\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" döndürür",
      "vi": "Viết một hàm TypeScript `function gameWinner(piles: number[]): string` để giải quyết vấn đề sau:\nCho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương,\nhàm này xác định người chiến thắng của một trò chơi được chơi bởi Charlie và Dan. Trò chơi bắt đầu với Charlie,\nvà họ lần lượt di chuyển đá từ đống không rỗng bên trái nhất sang đống liền kề bên phải.\nViệc di chuyển được thực hiện với số lượng dương. Người chơi bị buộc phải chỉ di chuyển đá trong đống cuối cùng sẽ thua.\nGiả sử chơi tối ưu, hàm xác định người chiến thắng.\n\n@example\ngameWinner([3, 1, 2, 2]) // trả về \"Dan\""
    },
    "instruction_bertscore": {
      "es": "0.9840785831777675",
      "arb": "0.9725959594805217",
      "sw": "0.9605315473972246",
      "tr": "0.9663671093616486",
      "vi": "0.9703399156127274"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\", \"Test 1 failed\");\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\", \"Test 2 failed\");\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\", \"Test 3 failed\");\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\", \"Test 4 failed\");\n    console.assert(gameWinner([1, 1]) === \"Charlie\", \"Test 5 failed\");\n    console.assert(gameWinner([2, 1]) === \"Charlie\", \"Test 6 failed\");\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\", \"Test 7 failed\");\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\", \"Test 8 failed\");\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\", \"Test 9 failed\");\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\", \"Test 10 failed\");\n})();",
    "entry_point": "gameWinner",
    "signature": "function gameWinner(piles: number[]): string",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\nthis function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\nand they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\nMovement is done in positive numbers. The player forced to only move stones in the last pile loses.\nAssuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"\n",
      "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, esta función identifica al ganador de un juego jugado por Charlie y Dan. El juego comienza con Charlie, y ellos alternan turnos moviendo piedras desde la pila más a la izquierda que no esté vacía hacia la pila adyacente a la derecha. El movimiento se realiza en números positivos. El jugador obligado a mover piedras solo en la última pila pierde. Asumiendo un juego óptimo, la función determina el ganador.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "arb": "تُعطى سلسلة من N أكوام من الحجارة مرقمة من 1 إلى N، تحتوي كل منها على عدد موجب من الحجارة، تحدد هذه الدالة الفائز في لعبة يلعبها تشارلي ودان. تبدأ اللعبة مع تشارلي، ويتناوبان الأدوار في نقل الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. يتم النقل بأعداد موجبة. اللاعب الذي يُجبر على نقل الحجارة فقط في الكومة الأخيرة يخسر. بافتراض اللعب الأمثل، تحدد الدالة الفائز.\n\n@example\ngameWinner([3, 1, 2, 2]) // يعيد \"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyoorodheshwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, kazi hii inatambua mshindi wa mchezo unaochezwa na Charlie na Dan. Mchezo unaanza na Charlie, na wanabadilishana zamu wakihamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo jirani. Uhamishaji unafanywa kwa namba chanya. Mchezaji anayelazimishwa kuhamisha mawe tu kwenye rundo la mwisho anapoteza. Kwa kudhani uchezaji bora, kazi hii inabainisha mshindi.\n\n@example\ngameWinner([3, 1, 2, 2]) // inarudisha \"Dan\"",
      "tr": "Verilen 1'den N'ye kadar numaralandırılmış N taş yığını dizisinde, her biri pozitif sayıda taş içeren bu fonksiyon, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirler. Oyun Charlie ile başlar ve sırayla taşları en soldaki boş olmayan yığından bitişik sağ yığına hareket ettirirler. Hareket pozitif sayılarla yapılır. Sadece son yığındaki taşları hareket ettirmek zorunda kalan oyuncu kaybeder. Optimal oyun varsayıldığında, fonksiyon kazananı belirler.\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" döndürür",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, hàm này xác định người chiến thắng của một trò chơi được chơi bởi Charlie và Dan. Trò chơi bắt đầu với Charlie, và họ lần lượt di chuyển đá từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Việc di chuyển được thực hiện với số lượng dương. Người chơi bị buộc phải chỉ di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi tối ưu, hàm xác định người chiến thắng.\n\n@example\ngameWinner([3, 1, 2, 2]) // trả về \"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9698979630149248",
      "arb": "0.96248070732632",
      "sw": "0.9467881127030396",
      "tr": "0.9624517072906889",
      "vi": "0.9662477325026466"
    }
  },
  {
    "task_id": "TypeScript/36",
    "prompt": {
      "en": "\n/**\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps\n * to the right and then open the door at that position. It is guaranteed that\n * C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "es": "/**\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos\n * a la derecha y luego abrir la puerta en esa posición. Se garantiza que\n * C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n *\n * Ejemplo:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "arb": "/**\n * بالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات\n * إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن\n * C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n *\n * مثال:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */ \nfunction minTotalCost(n: number, C: number[]): number",
      "sw": "/**\n * Ukiwa na milango n iliyopangwa kwa mduara, mchezaji anaanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusogea hatua i\n * kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa\n * C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kuamua gharama ya chini kabisa inayohitajika kufungua milango yote.\n *\n * Mfano:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */ \nfunction minTotalCost(n: number, C: number[]): number",
      "tr": "/**\n * n kapıdan oluşan bir daire verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa gitmek ve ardından o konumdaki\n * kapıyı açmak için bir maliyet C_i öder. C_i >= C_{i+1} olduğu garanti edilir\n * 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n *\n * Örnek:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "vi": "/**\n * Cho n cánh cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước\n * sang phải và sau đó mở cửa ở vị trí đó. Đảm bảo rằng\n * C_i >= C_{i+1} cho 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n *\n * Ví dụ:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9938819856337444",
      "arb": "0.9942242257802675",
      "sw": "0.9963811530879254",
      "tr": "0.9786371038893168",
      "vi": "0.9854052354926995"
    },
    "canonical_solution": "{\n   return C[n-2] * (n - 1) + C[n-1];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function minTotalCost(n: number, C: number[]): number` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "es": "Escribe una función de TypeScript `function minTotalCost(n: number, C: number[]): number` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos\na la derecha y luego abrir la puerta en esa posición. Se garantiza que\nC_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "arb": "اكتب دالة TypeScript `function minTotalCost(n: number, C: number[]): number` لحل المشكلة التالية:\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات\nإلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن\nC_i >= C_{i+1} لكل 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "sw": "Andika kazi ya TypeScript `function minTotalCost(n: number, C: number[]): number` kutatua tatizo lifuatalo:\nUkipiwa milango n iliyopangwa kwa mduara, mchezaji huanza mbele ya mlango wa 1.\nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i\nkulia na kisha kufungua mlango katika nafasi hiyo. Imedhamiriwa kuwa\nC_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "tr": "Bir TypeScript fonksiyonu `function minTotalCost(n: number, C: number[]): number` yazın ve aşağıdaki problemi çözün:\nn kapısı bir daire şeklinde düzenlenmiştir, oyuncu kapı 1'in önünde başlar.\nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir.\nC_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "vi": "Viết một hàm TypeScript `function minTotalCost(n: number, C: number[]): number` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước\nsang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cánh cửa.\n\nVí dụ:\n    > minTotalCost(3, [1, 1, 1])\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9940029515357947",
      "arb": "0.9895264186384114",
      "sw": "0.9863513119975686",
      "tr": "0.9711417864609653",
      "vi": "0.9849007143248709"
    },
    "level": "easy",
    "test": "function testMinTotalCost(): void {\n    console.assert(minTotalCost(5, [4, 3, 3, 3, 3]) === 15);\n    console.assert(minTotalCost(3, [1, 1, 1]) === 3);\n    console.assert(minTotalCost(4, [5, 4, 3, 2]) === 11);\n    console.assert(minTotalCost(4, [100, 99, 98, 97]) === 391);\n    console.assert(minTotalCost(6, [10, 9, 8, 7, 6, 5]) === 35);\n    console.assert(minTotalCost(7, [2, 2, 2, 2, 2, 2, 2]) === 14);\n    console.assert(minTotalCost(8, [9, 7, 7, 7, 7, 7, 7, 7]) === 56);\n    console.assert(minTotalCost(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]) === 18);\n    console.assert(minTotalCost(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]) === 50);\n    console.assert(minTotalCost(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === 11);\n}\n\ntestMinTotalCost();",
    "entry_point": "minTotalCost",
    "signature": "function minTotalCost(n: number, C: number[]): number",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nEn cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos  \na la derecha y luego abrir la puerta en esa posición. Se garantiza que  \nC_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.  \n\nEjemplo:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "arb": "بالنظر إلى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "sw": "Kwa kuzingatia milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ya chini kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} için 1 <= i < n olduğu garanti edilmiştir. Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "vi": "Với n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.  \nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.  \nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  "
    },
    "docstring_bertscore": {
      "es": "0.9858314962904003",
      "arb": "0.9927710459126163",
      "sw": "0.9964178997084169",
      "tr": "0.971027176731108",
      "vi": "0.9847638579923379"
    }
  },
  {
    "task_id": "TypeScript/37",
    "prompt": {
      "en": "\n/**\n * Calculates the total number of handshakes in a classroom where each student shakes\n * hands with every student already in the room with a smaller student ID. The student\n * IDs range from 0 to N-1, and the sequence of ID entries represents the order in which\n * they enter the classroom.\n * \n * @param n - the number of students\n * @param order - the sequence of student IDs entering the classroom\n * @returns the total number of handshakes\n * \n * Examples:\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "es": "/**\n * Calcula el número total de apretones de manos en un aula donde cada estudiante se da la mano\n * con cada estudiante que ya está en la sala con un ID de estudiante más pequeño. Los IDs de los estudiantes\n * van de 0 a N-1, y la secuencia de entradas de ID representa el orden en el que\n * entran al aula.\n * \n * @param n - el número de estudiantes\n * @param order - la secuencia de IDs de estudiantes que entran al aula\n * @returns el número total de apretones de manos\n * \n * Ejemplos:\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "arb": "/**\n * يحسب العدد الإجمالي للمصافحات في الفصل حيث يصافح كل طالب\n * كل طالب موجود بالفعل في الغرفة مع رقم تعريف أصغر. تتراوح أرقام\n * تعريف الطلاب من 0 إلى N-1، وتمثل تسلسل إدخال الأرقام الترتيب الذي\n * يدخلون فيه الفصل.\n * \n * @param n - عدد الطلاب\n * @param order - تسلسل أرقام تعريف الطلاب الذين يدخلون الفصل\n * @returns العدد الإجمالي للمصافحات\n * \n * أمثلة:\n *    countHandshakes(3, [2, 1, 0])  // يعيد 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "sw": "/**\n * Inahesabu jumla ya mikono iliyoshikana katika darasa ambapo kila mwanafunzi anashikana\n * mikono na kila mwanafunzi ambaye tayari yuko darasani na ana kitambulisho kidogo. Vitambulisho vya wanafunzi\n * vinatoka 0 hadi N-1, na mpangilio wa kuingia kwa vitambulisho unawakilisha mpangilio ambao\n * wanaingia darasani.\n * \n * @param n - idadi ya wanafunzi\n * @param order - mpangilio wa vitambulisho vya wanafunzi wanaoingia darasani\n * @returns jumla ya mikono iliyoshikana\n * \n * Mifano:\n *    countHandshakes(3, [2, 1, 0])  // inarudisha 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "tr": "/**\n * Her öğrencinin, sınıfa kendisinden daha küçük öğrenci kimliğine sahip her öğrenciyle\n * tokalaştığı bir sınıfta toplam tokalaşma sayısını hesaplar. Öğrenci kimlikleri 0'dan\n * N-1'e kadar sıralanır ve kimlik giriş sırası, sınıfa giriş sırasını temsil eder.\n * \n * @param n - öğrenci sayısı\n * @param order - sınıfa giren öğrenci kimliklerinin sırası\n * @returns toplam tokalaşma sayısı\n * \n * Örnekler:\n *    countHandshakes(3, [2, 1, 0])  // 0 döndürür\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "vi": "/**\n * Tính tổng số cái bắt tay trong một lớp học nơi mỗi học sinh bắt tay\n * với mọi học sinh đã có mặt trong phòng với ID nhỏ hơn. Các ID học sinh\n * có phạm vi từ 0 đến N-1, và thứ tự của các ID đại diện cho thứ tự mà\n * họ vào lớp học.\n * \n * @param n - số lượng học sinh\n * @param order - thứ tự của các ID học sinh vào lớp học\n * @returns tổng số cái bắt tay\n * \n * Ví dụ:\n *    countHandshakes(3, [2, 1, 0])  // trả về 0\n */\nfunction countHandshakes(n: number, order: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9951472611609367",
      "arb": "0.9624229058854388",
      "sw": "0.9600741016297013",
      "tr": "0.9293271117974058",
      "vi": "0.9725556375131715"
    },
    "canonical_solution": "{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function countHandshakes(n: number, order: number[]): number` to solve the following problem:\nCalculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - the number of students\n@param order - the sequence of student IDs entering the classroom\n@returns the total number of handshakes\n\nExamples:\n   countHandshakes(3, [2, 1, 0])  // returns 0\n",
      "es": "Escribe una función de TypeScript `function countHandshakes(n: number, order: number[]): number` para resolver el siguiente problema:\nCalcula el número total de apretones de manos en un aula donde cada estudiante se da la mano con cada estudiante que ya está en la sala con un ID de estudiante más pequeño. Los IDs de los estudiantes van de 0 a N-1, y la secuencia de entradas de ID representa el orden en que entran al aula.\n\n@param n - el número de estudiantes\n@param order - la secuencia de IDs de estudiantes que entran al aula\n@returns el número total de apretones de manos\n\nEjemplos:\n   countHandshakes(3, [2, 1, 0])  // returns 0",
      "arb": "اكتب دالة TypeScript `function countHandshakes(n: number, order: number[]): number` لحل المشكلة التالية:\nتحسب العدد الإجمالي للمصافحات في الفصل حيث يصافح كل طالب كل طالب موجود بالفعل في الغرفة برقم تعريف أصغر. تتراوح أرقام تعريف الطلاب من 0 إلى N-1، وتمثل تسلسل دخول أرقام التعريف الترتيب الذي يدخلون به إلى الفصل.\n\n@param n - عدد الطلاب\n@param order - تسلسل أرقام تعريف الطلاب الذين يدخلون الفصل\n@returns العدد الإجمالي للمصافحات\n\nأمثلة:\n   countHandshakes(3, [2, 1, 0])  // يعيد 0",
      "sw": "Andika kazi ya TypeScript `function countHandshakes(n: number, order: number[]): number` kutatua tatizo lifuatalo:\nHesabu jumla ya mikono iliyoshikwa katika darasa ambapo kila mwanafunzi anashikana mikono na kila mwanafunzi aliyepo tayari darasani mwenye kitambulisho kidogo cha mwanafunzi. Vitambulisho vya wanafunzi vinatoka 0 hadi N-1, na mlolongo wa vitambulisho unaonyesha mpangilio ambao wanaingia darasani.\n\n@param n - idadi ya wanafunzi\n@param order - mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani\n@returns jumla ya mikono iliyoshikwa\n\nMifano:\n   countHandshakes(3, [2, 1, 0])  // inarudisha 0",
      "tr": "Bir TypeScript fonksiyonu `function countHandshakes(n: number, order: number[]): number` yazın. Aşağıdaki problemi çözmek için:\nHer öğrencinin, sınıfa kendisinden daha küçük öğrenci kimliğine sahip olan her öğrenciyle tokalaştığı bir sınıftaki toplam tokalaşma sayısını hesaplar. Öğrenci kimlikleri 0'dan N-1'e kadar sıralanır ve kimlik giriş sırası, sınıfa giriş sırasını temsil eder.\n\n@param n - öğrenci sayısı\n@param order - sınıfa giren öğrenci kimliklerinin sırası\n@returns toplam tokalaşma sayısı\n\nÖrnekler:\n   countHandshakes(3, [2, 1, 0])  // 0 döndürür",
      "vi": "Viết một hàm TypeScript `function countHandshakes(n: number, order: number[]): number` để giải quyết vấn đề sau:\nTính tổng số cái bắt tay trong một lớp học nơi mỗi học sinh bắt tay với mọi học sinh đã có mặt trong phòng với ID học sinh nhỏ hơn. Các ID học sinh nằm trong khoảng từ 0 đến N-1, và dãy số ID đại diện cho thứ tự mà họ vào lớp.\n\n@param n - số lượng học sinh\n@param order - dãy số ID học sinh vào lớp\n@returns tổng số cái bắt tay\n\nVí dụ:\n   countHandshakes(3, [2, 1, 0])  // trả về 0"
    },
    "instruction_bertscore": {
      "es": "0.9927964706013888",
      "arb": "0.9673586722237748",
      "sw": "0.9707939846637731",
      "tr": "0.9340072408353498",
      "vi": "0.9788063369739585"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2, \"Test 1 failed\");\n    console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15, \"Test 2 failed\");\n    console.assert(countHandshakes(3, [1, 2, 0]) === 1, \"Test 3 failed\");\n    console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0, \"Test 4 failed\");\n    console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6, \"Test 5 failed\");\n    console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0, \"Test 6 failed\");\n    console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5, \"Test 7 failed\");\n    console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3, \"Test 8 failed\");\n    console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4, \"Test 9 failed\");\n    console.assert(countHandshakes(3, [2, 0, 1]) === 1, \"Test 10 failed\");\n    console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7, \"Test 11 failed\");\n    console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0, \"Test 12 failed\");\n})();",
    "entry_point": "countHandshakes",
    "signature": "function countHandshakes(n: number, order: number[]): number",
    "docstring": {
      "en": "Calculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - the number of students\n@param order - the sequence of student IDs entering the classroom\n@returns the total number of handshakes\n\nExamples:\n   countHandshakes(3, [2, 1, 0])  // returns 0\n",
      "es": "Calcula el número total de apretones de manos en un aula donde cada estudiante se da la mano con cada estudiante que ya está en la sala con un ID de estudiante más pequeño. Los IDs de los estudiantes van de 0 a N-1, y la secuencia de entradas de ID representa el orden en que entran al aula.\n\n@param n - el número de estudiantes\n@param order - la secuencia de IDs de estudiantes que entran al aula\n@returns el número total de apretones de manos\n\nEjemplos:\n   countHandshakes(3, [2, 1, 0])  // devuelve 0",
      "arb": "يحسب العدد الإجمالي للمصافحات في الفصل الدراسي حيث يقوم كل طالب بمصافحة كل طالب موجود بالفعل في الغرفة برقم تعريف أصغر. تتراوح أرقام تعريف الطلاب من 0 إلى N-1، وتمثل تسلسل أرقام التعريف ترتيب دخولهم إلى الفصل.\n\n@param n - عدد الطلاب\n@param order - تسلسل أرقام تعريف الطلاب الذين يدخلون الفصل\n@returns العدد الإجمالي للمصافحات\n\nأمثلة:\n   countHandshakes(3, [2, 1, 0])  // يعيد 0",
      "sw": "Hesabu jumla ya mikono iliyoshikwa katika darasa ambapo kila mwanafunzi anashikana mikono na kila mwanafunzi ambaye tayari yuko darasani na ana kitambulisho kidogo. Vitambulisho vya wanafunzi vinaanzia 0 hadi N-1, na mfuatano wa vitambulisho unaonyesha mpangilio ambao wanaingia darasani.\n\n@param n - idadi ya wanafunzi\n@param order - mfuatano wa vitambulisho vya wanafunzi wanaoingia darasani\n@returns jumla ya mikono iliyoshikwa\n\nMifano:\n   countHandshakes(3, [2, 1, 0])  // inarudisha 0",
      "tr": "Sınıfa giren her öğrencinin, sınıfta zaten bulunan ve daha küçük öğrenci kimliğine sahip her öğrenciyle tokalaştığı bir sınıfta toplam tokalaşma sayısını hesaplar. Öğrenci kimlikleri 0'dan N-1'e kadar sıralanır ve kimlik giriş sırası, sınıfa giriş sırasını temsil eder.\n\n@param n - öğrenci sayısı\n@param order - sınıfa giren öğrenci kimliklerinin sırası\n@returns toplam tokalaşma sayısı\n\nÖrnekler:\n   countHandshakes(3, [2, 1, 0])  // 0 döndürür",
      "vi": "Tính tổng số lần bắt tay trong một lớp học nơi mỗi học sinh bắt tay với mọi học sinh đã có mặt trong phòng với ID học sinh nhỏ hơn. Các ID học sinh nằm trong khoảng từ 0 đến N-1, và thứ tự của các ID đại diện cho thứ tự mà họ vào lớp.\n\n@param n - số lượng học sinh\n@param order - thứ tự của các ID học sinh vào lớp\n@returns tổng số lần bắt tay\n\nVí dụ:\n   countHandshakes(3, [2, 1, 0])  // trả về 0"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9592037033000064",
      "sw": "0.950860631405398",
      "tr": "0.9279809937051323",
      "vi": "0.9635715853789636"
    }
  },
  {
    "task_id": "TypeScript/38",
    "prompt": {
      "en": "\n/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "es": "/**\n * Dado n números enteros positivos que representan la cantidad de cada número de 1 a n,\n * encuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de\n * una secuencia construida a partir de estos números. La moda es el número más grande\n * entre los elementos más frecuentes en una secuencia.\n * Por ejemplo:\n *   maxModeSum(3, [1, 2, 3])\n *   Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "arb": "/**\n * معطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n * على سبيل المثال:\n *   maxModeSum(3, [1, 2, 3])\n *   تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "sw": "/**\n * Ukipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, \n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \n * mlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi \n * kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * Kwa mfano:\n *   maxModeSum(3, [1, 2, 3])\n *   Mlolongo unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "tr": "/**\n * 1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık rastlanan eleman) \n * maksimum toplamını bulun. Mod, bir dizideki en sık rastlanan elemanlar arasında en büyük sayıdır.\n * Örneğin:\n *   maxModeSum(3, [1, 2, 3])\n *   Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] şeklindedir ve toplam 17'dir.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "vi": "/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\n * một dãy được tạo thành từ các số này. Mode là số lớn nhất\n * trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n * Ví dụ:\n *   maxModeSum(3, [1, 2, 3])\n *   Một dãy đạt giá trị lớn nhất là [3, 2, 3, 1, 2, 2], và tổng là 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9947448360089599",
      "arb": "0.9806005652058466",
      "sw": "0.9564026176666524",
      "tr": "0.958472544867417",
      "vi": "0.9715545403927557"
    },
    "canonical_solution": "{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n  \n  for (let i = 0; i < n; ++i) {\n    f[i] = 0;\n  }\n  \n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function maxModeSum(n: number, counts: number[]): number` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "es": "Escribe una función de TypeScript `function maxModeSum(n: number, counts: number[]): number` para resolver el siguiente problema:\nDado n enteros positivos que representan la cantidad de cada número del 1 al n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia.\nPor ejemplo:\n  maxModeSum(3, [1, 2, 3])\n  Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.",
      "arb": "اكتب دالة TypeScript `function maxModeSum(n: number, counts: number[]): number` لحل المشكلة التالية:\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\nعلى سبيل المثال:\n  maxModeSum(3, [1, 2, 3])\n  تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.",
      "sw": "Andika kazi ya TypeScript `function maxModeSum(n: number, counts: number[]): number` kutatua tatizo lifuatalo:\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa awali zote za mlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\nKwa mfano:\n  maxModeSum(3, [1, 2, 3])\n  Mlolongo unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.",
      "tr": "Bir TypeScript fonksiyonu `function maxModeSum(n: number, counts: number[]): number` yazın ve aşağıdaki problemi çözün:\n1'den n'e kadar her sayının sayısını temsil eden n pozitif tam sayı verildiğinde, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\nÖrneğin:\n  maxModeSum(3, [1, 2, 3])\n  Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] olup, toplam 17'dir.",
      "vi": "Viết một hàm TypeScript `function maxModeSum(n: number, counts: number[]): number` để giải quyết vấn đề sau:\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo thành từ những số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\nVí dụ:\n  maxModeSum(3, [1, 2, 3])\n  Một dãy đạt giá trị tối đa là [3, 2, 3, 1, 2, 2], và tổng là 17."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9874674161086038",
      "sw": "0.9598635534258043",
      "tr": "0.9687393520023483",
      "vi": "0.9740819133610437"
    },
    "level": "easy",
    "test": "(function testMaxModeSum(): void {\n  console.assert(maxModeSum(3, [1, 3, 2]) === 17, 'Test case 1 failed');\n  console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37, 'Test case 2 failed');\n  console.assert(maxModeSum(2, [1, 1]) === 4, 'Test case 3 failed');\n  console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75, 'Test case 4 failed');\n  console.assert(maxModeSum(1, [100000]) === 100000, 'Test case 5 failed');\n  console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62, 'Test case 6 failed');\n  console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000, 'Test case 7 failed');\n  console.assert(maxModeSum(3, [2, 2, 5]) === 27, 'Test case 8 failed');\n  console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64, 'Test case 9 failed');\n  console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126, 'Test case 10 failed');\n  console.assert(maxModeSum(3, [3, 1, 2]) === 16, 'Test case 11 failed');\n})();",
    "entry_point": "maxModeSum",
    "signature": "function maxModeSum(n: number, counts: number[]): number",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "es": "Dado n números enteros positivos que representan el conteo de cada número de 1 a n, encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. El modo es el número más grande entre los elementos más frecuentes en una secuencia.\nPor ejemplo:\n  maxModeSum(3, [1, 2, 3])\n  Una secuencia que alcanza su valor máximo es [3, 2, 3, 1, 2, 2], y la suma es 17.",
      "arb": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، ابحث عن أكبر مجموع للنمط (العنصر الأكثر تكرارًا) لجميع البادئات لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n\nعلى سبيل المثال:\n  maxModeSum(3, [1, 2, 3])\n  تسلسل يصل إلى قيمته القصوى هو [3, 2, 3, 1, 2, 2]، والمجموع هو 17.",
      "sw": "Kwa kuzingatia n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa awali zote za mfuatano uliotengenezwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mfuatano.\n\nKwa mfano:\n  maxModeSum(3, [1, 2, 3])\n  Mfuatano unaofikia thamani yake ya juu zaidi ni [3, 2, 3, 1, 2, 2], na jumla ni 17.",
      "tr": "Verilen n pozitif tamsayı, 1'den n'e kadar her bir sayının sayısını temsil eder, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\nÖrneğin:\n  maxModeSum(3, [1, 2, 3])\n  Maksimum değerine ulaşan bir dizi [3, 2, 3, 1, 2, 2] ve toplam 17'dir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo ra từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.  \nVí dụ:  \n  maxModeSum(3, [1, 2, 3])  \n  Một dãy đạt giá trị tối đa là [3, 2, 3, 1, 2, 2], và tổng là 17."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9445795414963127",
      "tr": "0.9465575028306582",
      "vi": "0.9599904782392856"
    }
  },
  {
    "task_id": "TypeScript/39",
    "prompt": {
      "en": "\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "es": "/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Ejemplo:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // devuelve 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "arb": "/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع عملية XOR لجميع المصفوفات الفرعية.\n * يتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\n * مجموع XOR لمصفوفة فرعية هو نتيجة عملية XOR لجميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n *\n * مثال:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // يعيد 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "sw": "/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\n * Sehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= urefu wa safu.\n * Jumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n *\n * Mfano:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // inarudisha 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "tr": "/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= dizinin uzunluğu olacak şekilde bir (L, R) indeks çifti ile tanımlanır.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\n * Nihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 döndürür\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "vi": "/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng.\n * Tổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Ví dụ:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // trả về 39\n */\nfunction sumOfXorSubarrays(A: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9882943143848519",
      "arb": "0.9746597291394742",
      "sw": "0.9781915759446554",
      "tr": "0.982874684438315",
      "vi": "0.9882140677109139"
    },
    "canonical_solution": "{\n    const n: number = A.length;\n    let q: number[] = new Array(n + 1).fill(0);\n    let w: number[][] = Array.from({ length: 21 }, () => [0, 0]);\n    let ans: number = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function sumOfXorSubarrays(A: number[]): number` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "es": "Escribe una función de TypeScript `function sumOfXorSubarrays(A: number[]): number` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nEjemplo:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39",
      "arb": "اكتب دالة TypeScript `function sumOfXorSubarrays(A: number[]): number` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة.\nمجموع XOR للمصفوفة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نواتج XOR لجميع المصفوفات الفرعية الممكنة.\n\nمثال:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // يعيد 39",
      "sw": "Andika kazi ya TypeScript `function sumOfXorSubarrays(A: number[]): number` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari, kazi ni kuhesabu jumla ya XOR ya vipande vyote vya safu.\nKipande cha safu kinafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= urefu wa safu.\nJumla ya XOR ya kipande cha safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipande vyote vinavyowezekana.\n\nMfano:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // inarejesha 39",
      "tr": "Bir TypeScript fonksiyonu `function sumOfXorSubarrays(A: number[]): number` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve 1 <= L <= R <= dizinin uzunluğu olacak şekilde tanımlanır.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucu elde edilir.\nSonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 döndürür",
      "vi": "Viết một hàm TypeScript `function sumOfXorSubarrays(A: number[]): number` để giải quyết vấn đề sau:\nCho một mảng A của các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nVí dụ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // trả về 39"
    },
    "instruction_bertscore": {
      "es": "0.9930805120462687",
      "arb": "0.9669886238239067",
      "sw": "0.9853762354570684",
      "tr": "0.9700791139224286",
      "vi": "0.9960728787365593"
    },
    "level": "middle",
    "test": "const testSumOfXorSubarrays = (): void => {\n    console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39);\n    console.assert(sumOfXorSubarrays([1, 1, 1]) === 4);\n    console.assert(sumOfXorSubarrays([2, 3, 1]) === 9);\n    console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74);\n    console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0);\n    console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72);\n    console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125);\n    console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390);\n    console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192);\n    console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192);\n    console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218);\n};\n\ntestSumOfXorSubarrays();",
    "entry_point": "sumOfXorSubarrays",
    "signature": "function sumOfXorSubarrays(A: number[]): number",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "es": "Dado un arreglo A de enteros, la tarea es calcular la suma del XOR de todos los subarreglos.  \nUn subarreglo se define por un par de índices (L, R) tal que 1 <= L <= R <= la longitud del arreglo.  \nLa suma XOR de un subarreglo es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarreglos posibles.\n\nEjemplo:  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // devuelve 39",
      "arb": "المهمة هي حساب مجموع القيم الناتجة عن عملية XOR لجميع القطع الفرعية لمصفوفة A من الأعداد الصحيحة. يتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= طول المصفوفة. مجموع XOR للقطعة الفرعية هو نتيجة عملية XOR لجميع العناصر من L إلى R. النتيجة النهائية هي مجموع قيم XOR لجميع القطع الفرعية الممكنة.\n\nمثال:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // يعيد 39",
      "sw": "Ukipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= urefu wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMfano:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // inarejesha 39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= dizinin uzunluğu olacak şekilde bir (L, R) indeks çifti ile tanımlanır.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucu elde edilir.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 döndürür",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= độ dài của mảng. \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.\n\nVí dụ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // trả về 39"
    },
    "docstring_bertscore": {
      "es": "0.9871480184558996",
      "arb": "0.9292466664930866",
      "sw": "0.9723536304156591",
      "tr": "0.9724716168619938",
      "vi": "0.9933027794426467"
    }
  },
  {
    "task_id": "TypeScript/40",
    "prompt": {
      "en": "\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n * and b >= k. Different legal representations of the same number are counted only once.\n * Example:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "es": "/**\n * Dado dos enteros positivos n y k, encuentra la cantidad de enteros positivos x,\n * donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos\n * y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\n * Ejemplo:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "arb": "/**\n * معطى عددين صحيحين موجبين n و k، جد عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبين\n * و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n * مثال:\n *   countPowerNumbers(99, 1) يعيد 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "sw": "/**\n * Ukipewa nambari mbili chanya n na k, tafuta idadi ya nambari chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya\n * na b >= k. Uwakilishi tofauti wa kisheria wa nambari ile ile unahesabiwa mara moja tu.\n * Mfano:\n *   countPowerNumbers(99, 1) inarudisha 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "tr": "/**\n * Verilen iki pozitif tam sayı n ve k için, 1 <= x <= n aralığında,\n * x = a^b şeklinde ifade edilebilen pozitif tam sayıların sayısını bulun,\n * burada a ve b pozitif tam sayılardır ve b >= k. Aynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n * Örnek:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "vi": "/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương\n * và b >= k. Các cách biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n * Ví dụ:\n *   countPowerNumbers(99, 1) trả về 99\n */\nfunction countPowerNumbers(n: number, k: number): number {"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9928842652298062",
      "sw": "0.985584201466012",
      "tr": "0.9409634754095726",
      "vi": "0.9764835532981365"
    },
    "canonical_solution": "let count = 0;\n    let x = 0;\n    const mp: boolean[] = new Array(n + 1).fill(false);\n    \n    for (let i = 2; i <= Math.cbrt(n); ++i) {\n        let t = i * i;\n        let m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if (Math.pow(Math.floor(Math.sqrt(t)), 2) === t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k === 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += Math.floor(Math.sqrt(n)) - x;\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countPowerNumbers(n: number, k: number): number` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99",
      "es": "Escribe una función de TypeScript `function countPowerNumbers(n: number, k: number): number` para resolver el siguiente problema:\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\nEjemplo:\n  countPowerNumbers(99, 1) returns 99",
      "arb": "اكتب دالة TypeScript `function countPowerNumbers(n: number, k: number): number` لحل المشكلة التالية:\nمعطى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b حيث a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\nمثال:\n  countPowerNumbers(99, 1) يعيد 99",
      "sw": "Andika kazi ya TypeScript `function countPowerNumbers(n: number, k: number): number` kutatua tatizo lifuatalo:\nUkipiwa nambari mbili za mzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b na a na b wakiwa nambari za mzima chanya na b >= k. Uwakilishi tofauti wa kisheria wa nambari sawa huhesabiwa mara moja tu.\nMfano:\n  countPowerNumbers(99, 1) inarudisha 99",
      "tr": "Bir TypeScript fonksiyonu `function countPowerNumbers(n: number, k: number): number` yazın ve aşağıdaki problemi çözün:\nİki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun. Burada a ve b pozitif tamsayılardır ve b >= k'dir. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\nÖrnek:\n  countPowerNumbers(99, 1) 99 döndürür.",
      "vi": "Viết một hàm TypeScript `function countPowerNumbers(n: number, k: number): number` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các cách biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.  \nVí dụ:  \n  countPowerNumbers(99, 1) trả về 99"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9888097602236375",
      "sw": "0.9927019225400161",
      "tr": "0.9359959282102711",
      "vi": "0.9846591797815325"
    },
    "level": "hard",
    "test": "const testCountPowerNumbers = (): void => {\n    console.assert(countPowerNumbers(99, 1) === 99, `Expected 99, got ${countPowerNumbers(99, 1)}`);\n    console.assert(countPowerNumbers(99, 3) === 7, `Expected 7, got ${countPowerNumbers(99, 3)}`);\n    console.assert(countPowerNumbers(99, 2) === 12, `Expected 12, got ${countPowerNumbers(99, 2)}`);\n    console.assert(countPowerNumbers(10, 1) === 10, `Expected 10, got ${countPowerNumbers(10, 1)}`);\n    console.assert(countPowerNumbers(10, 2) === 4, `Expected 4, got ${countPowerNumbers(10, 2)}`);\n    console.assert(countPowerNumbers(500, 1) === 500, `Expected 500, got ${countPowerNumbers(500, 1)}`);\n    console.assert(countPowerNumbers(500, 2) === 30, `Expected 30, got ${countPowerNumbers(500, 2)}`);\n    console.assert(countPowerNumbers(500, 3) === 13, `Expected 13, got ${countPowerNumbers(500, 3)}`);\n    console.assert(countPowerNumbers(1000, 1) === 1000, `Expected 1000, got ${countPowerNumbers(1000, 1)}`);\n    console.assert(countPowerNumbers(1000, 2) === 41, `Expected 41, got ${countPowerNumbers(1000, 2)}`);\n    console.assert(countPowerNumbers(1000, 3) === 17, `Expected 17, got ${countPowerNumbers(1000, 3)}`);\n    console.assert(countPowerNumbers(1000, 93) === 1, `Expected 1, got ${countPowerNumbers(1000, 93)}`);\n    console.assert(countPowerNumbers(50, 2) === 10, `Expected 10, got ${countPowerNumbers(50, 2)}`);\n    console.assert(countPowerNumbers(50, 3) === 5, `Expected 5, got ${countPowerNumbers(50, 3)}`);\n    console.assert(countPowerNumbers(2, 3) === 1, `Expected 1, got ${countPowerNumbers(2, 3)}`);\n};\n\ntestCountPowerNumbers();",
    "entry_point": "countPowerNumbers",
    "signature": "function countPowerNumbers(n: number, k: number): number",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99",
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales del mismo número se cuentan solo una vez.\nEjemplo:\n  countPowerNumbers(99, 1) devuelve 99",
      "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبين و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\nمثال:\n  countPowerNumbers(99, 1) returns 99",
      "sw": "Kwa kuzingatia nambari mbili nzima chanya n na k, pata idadi ya nambari nzima chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. Uwakilishi tofauti halali wa nambari hiyo hiyo huhesabiwa mara moja tu.\n\nMfano:\n  countPowerNumbers(99, 1) inarejesha 99",
      "tr": "Verilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayıların sayısını bulun. Burada a ve b pozitif tamsayılar ve b >= k olacak şekilde. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\nÖrnek:\n  countPowerNumbers(99, 1) 99 döndürür.",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n\nVí dụ:\n  countPowerNumbers(99, 1) trả về 99"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9904204539834495",
      "sw": "0.9904204539834495",
      "tr": "0.9338699872420547",
      "vi": "0.9688317151295295"
    }
  },
  {
    "task_id": "TypeScript/41",
    "prompt": {
      "en": "\n/**\n * Computes the number of sequences consisting of n '(' and m ')', such that the longest balanced\n * subsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Example:\n *   countBalancedSubsequences(2, 2, 2) returns 2\n *\n * @param n The number of '(' characters.\n * @param m The number of ')' characters.\n * @param k The half-length of the longest balanced subsequence.\n * @returns The number of valid sequences modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "es": "/**\n * Calcula el número de secuencias que consisten en n '(' y m ')', de tal manera que la subsecuencia\n * balanceada más larga sea de longitud 2 * k, módulo 1,000,000,007 (10^9 + 7).\n * \n * Ejemplo:\n *   countBalancedSubsequences(2, 2, 2) devuelve 2\n *\n * @param n El número de caracteres '('.\n * @param m El número de caracteres ')'.\n * @param k La mitad de la longitud de la subsecuencia balanceada más larga.\n * @returns El número de secuencias válidas módulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "arb": "/**\n * يحسب عدد المتتاليات المكونة من n '(' و m ')', بحيث يكون أطول متتالية متوازنة\n * بطول 2 * k, موديولو 1,000,000,007 (10^9 + 7).\n * \n * مثال:\n *   countBalancedSubsequences(2, 2, 2) returns 2\n *\n * @param n عدد الأحرف '('.\n * @param m عدد الأحرف ')'.\n * @param k نصف طول أطول متتالية متوازنة.\n * @returns عدد المتتاليات الصالحة موديولو 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "sw": "/**\n * Inahesabu idadi ya misururu inayojumuisha n '(' na m ')', kiasi kwamba mfuatano mrefu zaidi ulio sawa\n * una urefu wa 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Mfano:\n *   countBalancedSubsequences(2, 2, 2) inarudisha 2\n *\n * @param n Idadi ya herufi '('.\n * @param m Idadi ya herufi ')'.\n * @param k Nusu ya urefu wa mfuatano mrefu zaidi ulio sawa.\n * @returns Idadi ya misururu halali modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "tr": "/**\n * En uzun dengeli alt dizinin uzunluğu 2 * k olan, n '(' ve m ')' karakterlerinden oluşan dizilerin\n * sayısını 1,000,000,007 (10^9 + 7) modunda hesaplar.\n * \n * Örnek:\n *   countBalancedSubsequences(2, 2, 2) 2 döndürür\n *\n * @param n '(' karakterlerinin sayısı.\n * @param m ')' karakterlerinin sayısı.\n * @param k En uzun dengeli alt dizinin yarı uzunluğu.\n * @returns Geçerli dizilerin sayısını 10^9 + 7 modunda döndürür.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "vi": "/**\n * Tính số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k, theo modulo 1,000,000,007 (10^9 + 7).\n * \n * Ví dụ:\n *   countBalancedSubsequences(2, 2, 2) trả về 2\n *\n * @param n Số lượng ký tự '('.\n * @param m Số lượng ký tự ')'.\n * @param k Nửa độ dài của dãy con cân bằng dài nhất.\n * @returns Số lượng dãy hợp lệ theo modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {"
    },
    "prompt_bertscore": {
      "es": "0.989609446137684",
      "arb": "0.9653531012664655",
      "sw": "0.9593405596325394",
      "tr": "0.9536062991624432",
      "vi": "0.9706648749161004"
    },
    "canonical_solution": "const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n \n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n \n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countBalancedSubsequences(n: number, m: number, k: number): number` to solve the following problem:\nComputes the number of sequences consisting of n '(' and m ')', such that the longest balanced\nsubsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExample:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n The number of '(' characters.\n@param m The number of ')' characters.\n@param k The half-length of the longest balanced subsequence.\n@returns The number of valid sequences modulo 10^9 + 7.",
      "es": "Escribe una función de TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` para resolver el siguiente problema:\nCalcula el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k, módulo 1,000,000,007 (10^9 + 7).\n\nEjemplo:\ncountBalancedSubsequences(2, 2, 2) devuelve 2\n\n@param n El número de caracteres '('.\n@param m El número de caracteres ')'.\n@param k La mitad de la longitud de la subsecuencia balanceada más larga.\n@returns El número de secuencias válidas módulo 10^9 + 7.",
      "arb": "اكتب دالة TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` لحل المشكلة التالية:\nتحسب عدد التسلسلات المكونة من n من '(' و m من ')', بحيث يكون أطول تسلسل متوازن بطول 2 * k، مع الباقي 1,000,000,007 (10^9 + 7).\n\nمثال:\ncountBalancedSubsequences(2, 2, 2) يعيد 2\n\n@param n عدد الأحرف '('.\n@param m عدد الأحرف ')'.\n@param k نصف طول أطول تسلسل متوازن.\n@returns عدد التسلسلات الصحيحة مع الباقي 10^9 + 7.",
      "sw": "Andika kazi ya TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` kutatua tatizo lifuatalo:\nInahesabu idadi ya misururu inayojumuisha n '(' na m ')', kiasi kwamba mfuatano mrefu zaidi ulio na usawa una urefu wa 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nMfano:\ncountBalancedSubsequences(2, 2, 2) inarudisha 2\n\n@param n Idadi ya herufi '('.\n@param m Idadi ya herufi ')'.\n@param k Nusu ya urefu wa mfuatano mrefu zaidi ulio na usawa.\n@returns Idadi ya misururu sahihi modulo 10^9 + 7.",
      "tr": "Bir TypeScript fonksiyonu `function countBalancedSubsequences(n: number, m: number, k: number): number` yazın ve aşağıdaki problemi çözün:\nEn uzun dengeli alt dizinin uzunluğu 2 * k olan, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını, 1,000,000,007 (10^9 + 7) modunda hesaplar.\n\nÖrnek:\ncountBalancedSubsequences(2, 2, 2) 2 döndürür\n\n@param n '(' karakterlerinin sayısı.\n@param m ')' karakterlerinin sayısı.\n@param k En uzun dengeli alt dizinin yarı uzunluğu.\n@returns Geçerli dizilerin sayısı mod 10^9 + 7.",
      "vi": "Viết một hàm TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` để giải quyết vấn đề sau:\nTính toán số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\ncountBalancedSubsequences(2, 2, 2) trả về 2\n\n@param n Số lượng ký tự '('.\n@param m Số lượng ký tự ')'.\n@param k Nửa độ dài của dãy con cân bằng dài nhất.\n@returns Số lượng dãy hợp lệ theo modulo 10^9 + 7."
    },
    "instruction_bertscore": {
      "es": "0.9845431796390081",
      "arb": "0.9422964838966977",
      "sw": "0.9656333687341058",
      "tr": "0.9529965038926661",
      "vi": "0.9845431796390081"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2, 'Test case 1 failed');\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0, 'Test case 2 failed');\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4, 'Test case 3 failed');\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14, 'Test case 4 failed');\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35, 'Test case 5 failed');\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6, 'Test case 6 failed');\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6, 'Test case 7 failed');\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27, 'Test case 8 failed');\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110, 'Test case 9 failed');\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659, 'Test case 10 failed');\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648, 'Test case 11 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531, 'Test case 12 failed');\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485, 'Test case 13 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024, 'Test case 14 failed');\n})();",
    "entry_point": "countBalancedSubsequences",
    "signature": "function countBalancedSubsequences(n: number, m: number, k: number): number",
    "docstring": {
      "en": "Computes the number of sequences consisting of n '(' and m ')', such that the longest balanced\nsubsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExample:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n The number of '(' characters.\n@param m The number of ')' characters.\n@param k The half-length of the longest balanced subsequence.\n@returns The number of valid sequences modulo 10^9 + 7.",
      "es": "Calcula el número de secuencias que consisten en n '(' y m ')', de tal manera que la subsecuencia balanceada más larga sea de longitud 2 * k, módulo 1,000,000,007 (10^9 + 7).\n\nEjemplo:\ncountBalancedSubsequences(2, 2, 2) devuelve 2\n\n@param n El número de caracteres '('.\n@param m El número de caracteres ')'.\n@param k La mitad de la longitud de la subsecuencia balanceada más larga.\n@returns El número de secuencias válidas módulo 10^9 + 7.",
      "arb": "يحسب عدد التسلسلات التي تتكون من n من '(' و m من ')', بحيث يكون أطول تسلسل متوازن بطول 2 * k, موديولو 1,000,000,007 (10^9 + 7).\n\nمثال:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n عدد الأحرف '('.\n@param m عدد الأحرف ')'.\n@param k نصف طول أطول تسلسل متوازن.\n@returns عدد التسلسلات الصالحة موديولو 10^9 + 7.",
      "sw": "Hesabu idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio sawa una urefu wa 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nMfano:\ncountBalancedSubsequences(2, 2, 2) inarejesha 2\n\n@param n Idadi ya herufi '('.\n@param m Idadi ya herufi ')'.\n@param k Nusu ya urefu wa mlolongo mrefu zaidi ulio sawa.\n@returns Idadi ya milolongo halali modulo 10^9 + 7.",
      "tr": "n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını hesaplar, öyle ki en uzun dengeli alt dizinin uzunluğu 2 * k olur, 1,000,000,007 (10^9 + 7) modunda.\n\nÖrnek:\ncountBalancedSubsequences(2, 2, 2) 2 döndürür\n\n@param n '(' karakterlerinin sayısı.\n@param m ')' karakterlerinin sayısı.\n@param k En uzun dengeli alt dizinin yarı uzunluğu.\n@returns Geçerli dizilerin sayısı 10^9 + 7 modunda.",
      "vi": "Tính số lượng dãy gồm n ký tự '(' và m ký tự ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k, theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\ncountBalancedSubsequences(2, 2, 2) trả về 2\n\n@param n Số lượng ký tự '('.\n@param m Số lượng ký tự ')'.\n@param k Nửa độ dài của dãy con cân bằng dài nhất.\n@returns Số lượng dãy hợp lệ theo modulo 10^9 + 7."
    },
    "docstring_bertscore": {
      "es": "0.9831406505185207",
      "arb": "0.9440668764828617",
      "sw": "0.9485287107320484",
      "tr": "0.9582669624230459",
      "vi": "0.9450415557625998"
    }
  },
  {
    "task_id": "TypeScript/42",
    "prompt": {
      "en": "\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\n * corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations\n * to cut the paper such that the remaining area is less than k. In each operation, a line is randomly\n * chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through\n * (not just touching the edge) the paper. The bottom or right part of the paper along this line is then\n * discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *    expectedCuts(3, 3, 4) // returns 3\n *    expectedCuts(5, 5, 12) // returns 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "es": "/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda\n * en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones\n * para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea\n * que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo tocando el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces\n * descartada. La respuesta debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *    expectedCuts(3, 3, 4) // devuelve 3\n *    expectedCuts(5, 5, 12) // devuelve 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "arb": "/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود زاويتها السفلية اليسرى عند (0,0)\n * وزاويتها العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\n * في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة.\n * يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *    expectedCuts(3, 3, 4) // يعيد 3\n *    expectedCuts(5, 5, 12) // يعيد 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "sw": "/**\n * Ukiwa na karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege\n * na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi\n * inayotarajiwa ya operesheni za kukata karatasi hiyo ili eneo linalobaki liwe chini ya k. Katika kila operesheni,\n * mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari\n * kamili, na unakata (si kugusa tu ukingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari\n * huo kisha inatupwa. Jibu linapaswa kuwa moduli ya 10^9+7.\n *\n * Kwa mfano:\n *    expectedCuts(3, 3, 4) // inarudisha 3\n *    expectedCuts(5, 5, 12) // inarudisha 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "tr": "/**\n * Boyutu n x m olan bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir düzlem\n * Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olması için gereken\n * beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel olan, tam sayı\n * koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele\n * seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n *\n * Örneğin:\n *    expectedCuts(3, 3, 4) // 3 döndürür\n *    expectedCuts(5, 5, 12) // 2 döndürür\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "vi": "/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái\n * tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác kỳ vọng\n * để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên\n * song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua\n * (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó\n * bị loại bỏ. Kết quả cần được lấy modulo 10^9+7.\n *\n * Ví dụ:\n *    expectedCuts(3, 3, 4) // trả về 3\n *    expectedCuts(5, 5, 12) // trả về 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number"
    },
    "prompt_bertscore": {
      "es": "0.9828758762206012",
      "arb": "0.9433829920809585",
      "sw": "0.9620137273005069",
      "tr": "0.9426993063094364",
      "vi": "0.95318341508122"
    },
    "canonical_solution": "{\n    const MD: number = 1000000007;\n    const N: number = 1000000;\n    let vv: number[] = new Array(N * 2 + 2).fill(0);\n    let ans: number = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function expectedCuts(n: number, m: number, k: number): number` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n   expectedCuts(3, 3, 4) // returns 3\n   expectedCuts(5, 5, 12) // returns 2\n",
      "es": "Escribe una función de TypeScript `function expectedCuts(n: number, m: number, k: number): number` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n   expectedCuts(3, 3, 4) // devuelve 3\n   expectedCuts(5, 5, 12) // devuelve 2",
      "arb": "اكتب دالة TypeScript `function expectedCuts(n: number, m: number, k: number): number` لحل المشكلة التالية:\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود زاويتها السفلية اليسرى عند (0,0) وزاويتها العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع للعمليات لقص الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n   expectedCuts(3, 3, 4) // يعيد 3\n   expectedCuts(5, 5, 12) // يعيد 2",
      "sw": "Andika kazi ya TypeScript `function expectedCuts(n: number, m: number, k: number): number` kutatua tatizo lifuatalo:\nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona yake ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (si kugusa tu kingo) karatasi. Sehemu ya chini au kulia ya karatasi kando ya mstari huu kisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n   expectedCuts(3, 3, 4) // inarudisha 3\n   expectedCuts(5, 5, 12) // inarudisha 2",
      "tr": "Bir TypeScript fonksiyonu `function expectedCuts(n: number, m: number, k: number): number` aşağıdaki problemi çözmek için yazın:\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olacak şekilde bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı daha sonra atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n   expectedCuts(3, 3, 4) // 3 döndürür\n   expectedCuts(5, 5, 12) // 2 döndürür",
      "vi": "Viết một hàm TypeScript `function expectedCuts(n: number, m: number, k: number): number` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được lấy theo modulo 10^9+7.\n\nVí dụ:\n   expectedCuts(3, 3, 4) // trả về 3\n   expectedCuts(5, 5, 12) // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9839756926403914",
      "arb": "0.9638997227684332",
      "sw": "0.9664656300306419",
      "tr": "0.9590682373801406",
      "vi": "0.9545456222343572"
    },
    "level": "hard",
    "test": "function testExpectedCuts(): void {\n    console.assert(expectedCuts(2, 4, 10) === 0, 'Test 1 failed');\n    console.assert(expectedCuts(2, 4, 8) === 1, 'Test 2 failed');\n    console.assert(expectedCuts(2, 4, 2) === 833333342, 'Test 3 failed');\n    console.assert(expectedCuts(2, 4, 6) === 250000003, 'Test 4 failed');\n    console.assert(expectedCuts(3, 3, 4) === 666666673, 'Test 5 failed');\n    console.assert(expectedCuts(5, 5, 12) === 666666673, 'Test 6 failed');\n    console.assert(expectedCuts(6, 7, 20) === 722222229, 'Test 7 failed');\n    console.assert(expectedCuts(10, 10, 50) === 714285721, 'Test 9 failed');\n    console.assert(expectedCuts(1, 10, 5) === 945634929, 'Test 10 failed');\n    console.assert(expectedCuts(10, 1, 5) === 945634929, 'Test 11 failed');\n}\n\ntestExpectedCuts();",
    "entry_point": "expectedCuts",
    "signature": "function expectedCuts(n: number, m: number, k: number): number",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n   expectedCuts(3, 3, 4) // returns 3\n   expectedCuts(5, 5, 12) // returns 2\n",
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n   expectedCuts(3, 3, 4) // devuelve 3\n   expectedCuts(5, 5, 12) // devuelve 2",
      "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازي للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n   expectedCuts(3, 3, 4) // يعيد 3\n   expectedCuts(5, 5, 12) // يعيد 2",
      "sw": "Kwa kuzingatia karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (sio kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha inatupiliwa mbali. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n   expectedCuts(3, 3, 4) // inarudisha 3\n   expectedCuts(5, 5, 12) // inarudisha 2",
      "tr": "Verilen bir n x m boyutunda dikdörtgen kağıt, düzlem Kartezyen koordinat sistemine yerleştirilmiş ve sol alt köşesi (0,0) ve sağ üst köşesi (n,m) noktasında bulunmaktadır. Kalan alanın k'dan küçük olması için kağıdı kesmek için beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 ile mod alınmış olarak verilmelidir.\n\nÖrneğin:\n   expectedCuts(3, 3, 4) // 3 döndürür\n   expectedCuts(5, 5, 12) // 2 döndürür",
      "vi": "Cho một tờ giấy hình chữ nhật có kích thước n x m được đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt kỳ vọng để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả trả về phải theo modulo 10^9+7.\n\nVí dụ:\n   expectedCuts(3, 3, 4) // trả về 3\n   expectedCuts(5, 5, 12) // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.974926291110823",
      "arb": "0.9516686597954479",
      "sw": "0.9723999112944403",
      "tr": "0.9580194689682764",
      "vi": "0.9333316989094501"
    }
  },
  {
    "task_id": "TypeScript/43",
    "prompt": {
      "en": "\n/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "es": "/**\n * Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos\n * tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener\n * dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1\n * puntos de corte 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]).\n * El resultado debe ser módulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "arb": "/**\n * بالنظر إلى تبديل q من n عنصرًا وعدد صحيح k، ابحث عن عدد التبديلات p من n عنصرًا\n * بحيث يكون f(p) = q، حيث أن f(p) هو التبديل الأصغر لغويًا الذي يمكن الحصول عليه عن طريق\n * تقسيم p إلى k مقاطع متجاورة غير فارغة تمامًا وترتيب كل مقطع (أي، اختر k-1\n * نقاط توقف 1 <= x1 < x2 < ... < x(k-1) < n، وقسمه إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]).\n * يجب أن تكون النتيجة موديولو 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */",
      "sw": "/**\n * Ukipewa permutation q ya vipengele n na nambari k, pata idadi ya permutations p ya vipengele n\n * kama kwamba f(p) = q, ambapo f(p) ni permutation ndogo zaidi kwa mpangilio wa lexicographically ambayo inaweza kupatikana kwa\n * kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua k-1\n * sehemu za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Matokeo yanapaswa kuwa modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "tr": "/**\n * n elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, n elemanlı p permütasyonlarının sayısını bulun\n * öyle ki f(p) = q, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak\n * elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n, \n * ve bunu [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün).\n * Sonuç 998244353 ile mod alınmalıdır.\n *\n * @örnek\n * countPermutations(2, 1, [1, 2]) // 2 döndürür\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "vi": "/**\n * Cho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử\n * sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách\n * chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1\n * điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia nó thành [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Kết quả nên được lấy modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number"
    },
    "prompt_bertscore": {
      "es": "0.9891502126967313",
      "arb": "0.9591884087606667",
      "sw": "0.975723196199535",
      "tr": "0.9638840309683314",
      "vi": "0.992923196784489"
    },
    "canonical_solution": "{\n    const P = 998244353;\n    let dp: number[][] = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc: number[] = new Array(n + 1).fill(0);\n    let f: number[] = new Array(n + 1).fill(0);\n\n    dp[0][0] = f[0] = jc[0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n\n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n\n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n\n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n\n    return ans;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function countPermutations(n: number, k: number, q: number[]): number` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "es": "Escribe una función de TypeScript `function countPermutations(n: number, k: number, q: number[]): number` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]). El resultado debe ser módulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "arb": "اكتب دالة TypeScript `function countPermutations(n: number, k: number, q: number[]): number` لحل المشكلة التالية:\nبالنظر إلى ترتيب q مكون من n عنصر وعدد صحيح k، ابحث عن عدد الترتيبات p المكونة من n عنصر بحيث يكون f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط توقف 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]). يجب أن تكون النتيجة موديولو 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "sw": "Andika kazi ya TypeScript `function countPermutations(n: number, k: number, q: number[]): number` kutatua tatizo lifuatalo:\nKwa kupewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu za mfululizo na kupanga kila sehemu (yaani, chagua sehemu za kuvunja k-1 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // inarejesha 2",
      "tr": "TypeScript fonksiyonu `function countPermutations(n: number, k: number, q: number[]): number` yazın ve aşağıdaki problemi çözün:\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n ve [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n@example\ncountPermutations(2, 1, [1, 2]) // 2 döndürür",
      "vi": "Viết một hàm TypeScript `function countPermutations(n: number, k: number, q: number[]): number` để giải quyết vấn đề sau:\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liền kề không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia nó thành [1, x1], (x1, x2], ..., (x(k-1), n]). Kết quả nên được lấy modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // trả về 2"
    },
    "instruction_bertscore": {
      "es": "0.9924985250298364",
      "arb": "0.9847843169215844",
      "sw": "0.9788103095815791",
      "tr": "0.9585339216551567",
      "vi": "0.9845477481377719"
    },
    "level": "hard",
    "test": "console.assert(countPermutations(2, 1, [1, 2]) === 2, 'Test failed for input ([1, 2])');\nconsole.assert(countPermutations(3, 3, [3, 1, 2]) === 1, 'Test failed for input ([3, 1, 2])');\nconsole.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13, 'Test failed for input ([1, 2, 3, 6, 5, 4])');\nconsole.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720, 'Test failed for input ([1, 2, 3, 4, 5, 6])');\nconsole.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0, 'Test failed for input ([1, 2, 5, 3, 4, 5])');\nconsole.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1, 'Test failed for input ([1, 2, 3, 4, 5, 6, 7, 8, 9])');\nconsole.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093);",
    "entry_point": "countPermutations",
    "signature": "function countPermutations(n: number, k: number, q: number[]): number",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x1 < x2 < ... < x(k-1) < n, y divídelo en [1, x1], (x1, x2], ..., (x(k-1), n]). El resultado debe ser módulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // devuelve 2",
      "arb": "إعطاء ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصر بحيث f(p) = q، حيث f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط توقف 1 <= x1 < x2 < ... < x(k-1) < n، وتقسيمها إلى [1, x1]، (x1, x2]، ...، (x(k-1), n]). يجب أن تكون النتيجة موديولو 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "sw": "Kut given permutation q ya vipengele n na namba nzima k, pata idadi ya permutations p ya vipengele n kama f(p) = q, ambapo f(p) ni permutation ndogo zaidi kwa mpangilio wa lexicographical ambayo inaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kuzipanga kila sehemu (yaani, chagua k-1 pointi za kuvunja 1 <= x1 < x2 < ... < x(k-1) < n, na igawanye katika [1, x1], (x1, x2], ..., (x(k-1), n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n@mfano\ncountPermutations(2, 1, [1, 2]) // inarudisha 2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x1 < x2 < ... < x(k-1) < n, ve [1, x1], (x1, x2], ..., (x(k-1), n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n@örnek\ncountPermutations(2, 1, [1, 2]) // 2 döndürür",
      "vi": "Đưa ra một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liền kề không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x1 < x2 < ... < x(k-1) < n, và chia nó thành [1, x1], (x1, x2], ..., (x(k-1), n]). Kết quả nên được lấy theo modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9971722978955874",
      "arb": "0.9930912380868445",
      "sw": "0.9738805021546743",
      "tr": "0.9767715673506371",
      "vi": "0.9808093257363143"
    }
  },
  {
    "task_id": "TypeScript/44",
    "prompt": {
      "en": "\n/**\n * Determines the number of ways to choose a triplet (a, b, c)\n * from an array of distinct integers representing heights such that the\n * greatest common divisor (GCD) of the maximum and minimum values\n * of the triplet is 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights: number[]): number",
      "es": "/**\n * Determina el número de formas de elegir un triplete (a, b, c)\n * de un arreglo de enteros distintos que representan alturas tal que el\n * máximo común divisor (MCD) de los valores máximo y mínimo\n * del triplete es 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Devuelve: 1\n */\nfunction countTriplets(heights: number[]): number",
      "arb": "/**\n * يحدد عدد الطرق لاختيار ثلاثية (a, b, c)\n * من مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون\n * القاسم المشترك الأكبر (GCD) للقيم القصوى والدنيا\n * للثلاثية هو 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights: number[]): number",
      "sw": "/**\n * Huamua idadi ya njia za kuchagua tatu (a, b, c)\n * kutoka kwenye safu ya nambari tofauti zinazoashiria urefu ili\n * kigezo cha mgawanyiko mkubwa zaidi (GCD) wa thamani ya juu na ya chini\n * ya tatu hiyo iwe 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Inarudisha: 1\n */\nfunction countTriplets(heights: number[]): number",
      "tr": "/**\n * Bir dizideki farklı tamsayıları temsil eden yüksekliklerden\n * bir üçlü (a, b, c) seçmenin yollarını belirler, öyle ki\n * üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1'dir.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Döndürür: 1\n */\nfunction countTriplets(heights: number[]): number",
      "vi": "/**\n * Xác định số cách để chọn một bộ ba (a, b, c)\n * từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho\n * ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất\n * của bộ ba là 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Trả về: 1\n */\nfunction countTriplets(heights: number[]): number"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9288621180754031",
      "tr": "0.9542641629844307",
      "vi": "0.9849716253709003"
    },
    "canonical_solution": "{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a: number, b: number): number {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countTriplets(heights: number[]): number` to solve the following problem:\nDetermines the number of ways to choose a triplet (a, b, c)\nfrom an array of distinct integers representing heights such that the\ngreatest common divisor (GCD) of the maximum and minimum values\nof the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "es": "Escribe una función de TypeScript `function countTriplets(heights: number[]): number` para resolver el siguiente problema:\nDetermina el número de formas de elegir un triplete (a, b, c)\nde un arreglo de enteros distintos que representan alturas tal que el\nmáximo común divisor (GCD) de los valores máximo y mínimo\ndel triplete sea 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "arb": "اكتب دالة TypeScript `function countTriplets(heights: number[]): number` لحل المشكلة التالية:\nتحديد عدد الطرق لاختيار ثلاثية (a, b, c)\nمن مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون\nأكبر قاسم مشترك (GCD) للقيم القصوى والدنيا\nللثلاثية هو 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "sw": "Andika kazi ya TypeScript `function countTriplets(heights: number[]): number` kutatua tatizo lifuatalo:\nInabainisha idadi ya njia za kuchagua tatu (a, b, c)\nkutoka kwenye safu ya nambari tofauti zinazowakilisha urefu ili\nkiwango cha juu cha mgawanyiko (GCD) wa thamani ya juu na ya chini\nya tatu hiyo ni 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Inarudisha: 1",
      "tr": "Bir TypeScript fonksiyonu `function countTriplets(heights: number[]): number` yazın:\nBir diziden (a, b, c) üçlüsünü seçmenin kaç yolu olduğunu belirler\nyükseklikleri temsil eden farklı tamsayılar dizisinden böylece\nüçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olur.\n\n@example\ncountTriplets([1, 5, 7])\n// Döndürür: 1",
      "vi": "Viết một hàm TypeScript `function countTriplets(heights: number[]): number` để giải quyết vấn đề sau:\nXác định số cách để chọn một bộ ba (a, b, c)\ntừ một mảng các số nguyên phân biệt đại diện cho chiều cao sao cho\nước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất\ncủa bộ ba là 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Trả về: 1"
    },
    "instruction_bertscore": {
      "es": "0.9889970686729534",
      "arb": "0.9889970686729534",
      "sw": "0.9255803469199446",
      "tr": "0.9646286962668312",
      "vi": "0.9889970686729534"
    },
    "level": "hard",
    "test": "const main = (): void => {\n    console.assert(countTriplets([1, 5, 7]) === 1);\n    console.assert(countTriplets([1, 6, 2, 3]) === 3);\n    console.assert(countTriplets([16, 4, 8, 2]) === 0);\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77);\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7);\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104);\n    console.assert(countTriplets([3, 7, 11, 13]) === 4);\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10);\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87);\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122);\n}\n\nmain();",
    "entry_point": "countTriplets",
    "signature": "function countTriplets(heights: number[]): number",
    "docstring": {
      "en": "Determines the number of ways to choose a triplet (a, b, c)\nfrom an array of distinct integers representing heights such that the\ngreatest common divisor (GCD) of the maximum and minimum values\nof the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "es": "Determina el número de formas de elegir un triplete (a, b, c) de un arreglo de enteros distintos que representan alturas tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Devuelve: 1",
      "arb": "يحدد عدد الطرق لاختيار ثلاثية (a, b, c) من مصفوفة من الأعداد الصحيحة المميزة التي تمثل الارتفاعات بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى للثلاثية هو 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "sw": "Inabainisha idadi ya njia za kuchagua tatu (a, b, c) kutoka kwenye safu ya nambari tofauti zinazowakilisha urefu ili kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD) wa thamani za juu na za chini za tatu ni 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Inarudisha: 1",
      "tr": "Üçlü bir grup (a, b, c) seçmenin yollarını belirler\nyükseklikleri temsil eden farklı tamsayıların bulunduğu bir diziden, öyle ki\nüçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1'dir.\n\n@example\ncountTriplets([1, 5, 7])\n// Döndürür: 1",
      "vi": "Xác định số cách chọn một bộ ba (a, b, c) từ một mảng các số nguyên khác nhau đại diện cho chiều cao sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Trả về: 1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9012795088433744",
      "tr": "0.9626441801299117",
      "vi": "0.9843580561238836"
    }
  },
  {
    "task_id": "TypeScript/45",
    "prompt": {
      "en": "\n/**\n * Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\n * connected pixels of the same color to a chosen color, where two pixels are connected if they are\n * adjacent and have the same color. The goal is to find the minimum number of operations required\n * to make all pixels the same color.\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *    minOperations(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "es": "/**\n * Dada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un entero. Puedes cambiar todos\n * los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son\n * adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones requeridas\n * para hacer que todos los píxeles sean del mismo color.\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n *\n * Ejemplos:\n *    minOperations(5, [1, 2, 3, 2, 1]) devuelve 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "arb": "/**\n * بالنظر إلى صورة بحجم 1 في n بكسل، كل بكسل له لون ممثل بعدد صحيح. يمكنك تغيير جميع\n * البكسلات المتصلة ذات اللون نفسه إلى لون مختار، حيث يكون البكسلان متصلان إذا كانا\n * متجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى من العمليات المطلوبة\n * لجعل جميع البكسلات بنفس اللون.\n * ملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n *\n * أمثلة:\n *    minOperations(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "sw": "/**\n * Ukipewa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kubadilisha pikseli zote\n * zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa ziko\n * karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika\n * kufanya pikseli zote ziwe na rangi sawa.\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n *\n * Mifano:\n *    minOperations(5, [1, 2, 3, 2, 1]) inarudisha 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "tr": "/**\n * 1'e n piksel boyutunda bir görüntü verildiğinde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. \n * Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel, bitişik ve aynı renkte \n * olduklarında bağlı kabul edilir. Amaç, tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulmaktır.\n * Not: Her renk için en fazla 20 piksel vardır.\n *\n * Örnekler:\n *    minOperations(5, [1, 2, 3, 2, 1]) 2 döndürür\n */ \nfunction minOperations(n: number, pixels: number[]): number",
      "vi": "/**\n * Cho một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả\n * các pixel kết nối có cùng màu sang một màu đã chọn, nơi hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết\n * để làm cho tất cả các pixel có cùng màu.\n * Lưu ý: Đối với mỗi màu, có nhiều nhất 20 pixel của màu đó.\n *\n * Ví dụ:\n *    minOperations(5, [1, 2, 3, 2, 1]) trả về 2\n */ \nfunction minOperations(n: number, pixels: number[]): number"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9780128086017241",
      "sw": "0.97598518967212",
      "tr": "0.9679267551135345",
      "vi": "0.9919117708842593"
    },
    "canonical_solution": "{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function minOperations(n: number, pixels: number[]): number` to solve the following problem:\nGiven a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\nconnected pixels of the same color to a chosen color, where two pixels are connected if they are\nadjacent and have the same color. The goal is to find the minimum number of operations required\nto make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2\n",
      "es": "Escribe una función de TypeScript `function minOperations(n: number, pixels: number[]): number` para resolver el siguiente problema:\nDada una imagen de 1 por n píxeles, cada píxel tiene un color representado por un entero. Puedes cambiar todos los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n   minOperations(5, [1, 2, 3, 2, 1]) devuelve 2",
      "arb": "اكتب دالة TypeScript `function minOperations(n: number, pixels: number[]): number` لحل المشكلة التالية:\nبالنظر إلى صورة بكسل بحجم 1 في n، كل بكسل له لون ممثل بعدد صحيح. يمكنك تغيير جميع\nالبكسلات المتصلة بنفس اللون إلى لون مختار، حيث يعتبر بكسلان متصلان إذا كانا\nمتجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى لعدد العمليات المطلوبة\nلجعل جميع البكسلات بنفس اللون.\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2",
      "sw": "Andika kazi ya TypeScript `function minOperations(n: number, pixels: number[]): number` kutatua tatizo lifuatalo:\nUkipiwa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote kuwa na rangi sawa.\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n   minOperations(5, [1, 2, 3, 2, 1]) inarudisha 2",
      "tr": "Bir TypeScript fonksiyonu `function minOperations(n: number, pixels: number[]): number` yazın ve aşağıdaki problemi çözün:\n1'e n piksel görüntü verildiğinde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz, burada iki piksel, bitişik ve aynı renkte ise bağlı kabul edilir. Amacınız, tüm pikselleri aynı renge dönüştürmek için gereken minimum işlem sayısını bulmaktır.\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n   minOperations(5, [1, 2, 3, 2, 1]) 2 döndürür",
      "vi": "Viết một hàm TypeScript `function minOperations(n: number, pixels: number[]): number` để giải quyết vấn đề sau:\nCho một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thay đổi tất cả các pixel kết nối cùng màu thành một màu đã chọn, trong đó hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\nLưu ý: Đối với mỗi màu, có nhiều nhất 20 pixel của màu đó.\n\nVí dụ:\n   minOperations(5, [1, 2, 3, 2, 1]) trả về 2"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9679964743772778",
      "sw": "0.9784408570728542",
      "tr": "0.9650772036672081",
      "vi": "0.9952624667819369"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2);\n    console.assert(minOperations(4, [1, 1, 2, 2]) === 1);\n    console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3);\n    console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0);\n    console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1);\n    console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2);\n    console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1);\n    console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8);\n    console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5);\n    console.assert(minOperations(3, [3, 3, 3]) === 0);\n    console.assert(minOperations(4, [2, 1, 1, 2]) === 1);\n})();",
    "entry_point": "minOperations",
    "signature": "function minOperations(n: number, pixels: number[]): number",
    "docstring": {
      "en": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\nconnected pixels of the same color to a chosen color, where two pixels are connected if they are\nadjacent and have the same color. The goal is to find the minimum number of operations required\nto make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2\n",
      "es": "Dado una imagen de 1 por n píxeles, cada píxel tiene un color representado por un entero. Puedes cambiar todos los píxeles conectados del mismo color a un color elegido, donde dos píxeles están conectados si son adyacentes y tienen el mismo color. El objetivo es encontrar el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n   minOperations(5, [1, 2, 3, 2, 1]) devuelve 2",
      "arb": "نظرًا لصورة مكونة من 1 في n بكسل، كل بكسل له لون ممثل برقم صحيح. يمكنك تغيير جميع البكسلات المتصلة بنفس اللون إلى لون مختار، حيث يتم اعتبار بكسلين متصلين إذا كانا متجاورين ولهما نفس اللون. الهدف هو إيجاد الحد الأدنى من العمليات المطلوبة لجعل جميع البكسلات بنفس اللون. \nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n   minOperations(5, [1, 2, 3, 2, 1]) يعيد 2",
      "sw": "Kwa kupewa picha ya pikseli 1 kwa n, kila pikseli ina rangi inayoonyeshwa na namba nzima. Unaweza kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa, ambapo pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Lengo ni kupata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n   minOperations(5, [1, 2, 3, 2, 1]) inarudisha 2",
      "tr": "Verilen 1'e n piksel bir görüntüde, her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Aynı renkteki tüm bağlı pikselleri seçilen bir renge değiştirebilirsiniz; burada iki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Amaç, tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulmaktır.\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n   minOperations(5, [1, 2, 3, 2, 1]) 2 döndürür",
      "vi": "Cho trước một hình ảnh 1 x n pixel, mỗi pixel có một màu được biểu diễn bởi một số nguyên. Bạn có thể thay đổi tất cả các pixel kết nối có cùng màu sang một màu đã chọn, trong đó hai pixel được kết nối nếu chúng liền kề và có cùng màu. Mục tiêu là tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu..  \nLưu ý: Đối với mỗi màu, có nhiều nhất 20 pixel của màu đó. \nVí dụ:\n \n   minOperations(5, [1, 2, 3, 2, 1]) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9990942454624809",
      "arb": "0.9569927485287071",
      "sw": "0.9869219770822819",
      "tr": "0.9589423057185644",
      "vi": "1"
    }
  },
  {
    "task_id": "TypeScript/46",
    "prompt": {
      "en": "\n/**\n * Given an integer n, write a function to compute the sum of all numbers from 1 to n\n * that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\n * it should only be counted once.\n * \n * For example:\n *     sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "es": "/**\n * Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n\n * que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5,\n * debe contarse solo una vez.\n * \n * Por ejemplo:\n *     sumOfMultiples(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "arb": "/**\n * معطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n\n * التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5،\n * يجب أن يُحسب مرة واحدة فقط.\n * \n * على سبيل المثال:\n *     sumOfMultiples(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "sw": "/**\n * Ukipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n\n * ambazo ni maradufu ya ama 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5,\n * inapaswa kuhesabiwa mara moja tu.\n * \n * Kwa mfano:\n *     sumOfMultiples(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "tr": "/**\n * Bir tamsayı n verildiğinde, 1'den n'e kadar olan sayılardan\n * 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın.\n * Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n * \n * Örneğin:\n *     sumOfMultiples(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "vi": "/**\n * Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n\n * mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5,\n * nó chỉ nên được tính một lần.\n * \n * Ví dụ:\n *     sumOfMultiples(10); // trả về 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {"
    },
    "prompt_bertscore": {
      "es": "0.9916982432246468",
      "arb": "0.9962139063070939",
      "sw": "0.9962139063070939",
      "tr": "0.9808357435769919",
      "vi": "0.986871326335118"
    },
    "canonical_solution": "let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function sumOfMultiples(n: number): number` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "es": "Escribe una función de TypeScript `function sumOfMultiples(n: number): number` para resolver el siguiente problema:\nDado un número entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\n\nPor ejemplo:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "arb": "اكتب دالة TypeScript `function sumOfMultiples(n: number): number` لحل المشكلة التالية:\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأعداد من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5. إذا كان العدد مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\n\nعلى سبيل المثال:\n    sumOfMultiples(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)",
      "sw": "Andika kazi ya TypeScript `function sumOfMultiples(n: number): number` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni nyingi za 3 au 5. Ikiwa nambari ni nyingi za 3 na 5, inapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n    sumOfMultiples(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)",
      "tr": "Bir TypeScript fonksiyonu `function sumOfMultiples(n: number): number` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı n için, 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n    sumOfMultiples(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)",
      "vi": "Viết một hàm TypeScript `function sumOfMultiples(n: number): number` để giải quyết vấn đề sau:  \nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\n\nVí dụ:  \n    sumOfMultiples(10); // trả về 33 (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "es": "0.9918221885824127",
      "arb": "0.9950276856715536",
      "sw": "0.9911277767703146",
      "tr": "0.9611220755200414",
      "vi": "0.9877770808726372"
    },
    "level": "easy",
    "test": "const testSumOfMultiples = (): void => {\n    console.assert(sumOfMultiples(10) === 33, 'Test case n=10 failed');\n    console.assert(sumOfMultiples(15) === 60, 'Test case n=15 failed');\n    console.assert(sumOfMultiples(20) === 98, 'Test case n=20 failed');\n    console.assert(sumOfMultiples(5) === 8, 'Test case n=5 failed');\n    console.assert(sumOfMultiples(3) === 3, 'Test case n=3 failed');\n    console.assert(sumOfMultiples(6) === 14, 'Test case n=6 failed');\n    console.assert(sumOfMultiples(9) === 23, 'Test case n=9 failed');\n    console.assert(sumOfMultiples(12) === 45, 'Test case n=12 failed');\n    console.assert(sumOfMultiples(17) === 60, 'Test case n=17 failed');\n    console.assert(sumOfMultiples(21) === 119, 'Test case n=21 failed');\n    console.assert(sumOfMultiples(25) === 168, 'Test case n=25 failed');\n};\n\ntestSumOfMultiples();",
    "entry_point": "sumOfMultiples",
    "signature": "function sumOfMultiples(n: number): number",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\n\nPor ejemplo:\n    sumOfMultiples(10); // devuelve 33 (3 + 5 + 6 + 9 + 10)",
      "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما للعدد 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، يجب أن يُحسب مرة واحدة فقط.\n\nعلى سبيل المثال:\n    sumOfMultiples(10); // يعيد 33 (3 + 5 + 6 + 9 + 10)",
      "sw": "Ukipewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\n\nKwa mfano:\n    sumOfMultiples(10); // inarudisha 33 (3 + 5 + 6 + 9 + 10)",
      "tr": "Verilen bir tam sayı n için, 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\n\nÖrneğin:\n    sumOfMultiples(10); // 33 döndürür (3 + 5 + 6 + 9 + 10)",
      "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\n\nVí dụ:\n    sumOfMultiples(10); // trả về 33 (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "es": "0.9898460149214965",
      "arb": "0.9941972120484468",
      "sw": "0.9887452053498011",
      "tr": "0.9823630125767692",
      "vi": "0.9861052089554665"
    }
  },
  {
    "task_id": "TypeScript/47",
    "prompt": {
      "en": "\n/**\n * Determine if a given string is a palindrome.\n * A palindrome is a word, phrase, number, or other sequence of characters\n * that reads the same forward and backward (ignoring spaces, punctuation,\n * and capitalization).\n * \n * Examples:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean",
      "es": "/**\n * Determinar si una cadena dada es un palíndromo.\n * Un palíndromo es una palabra, frase, número u otra secuencia de caracteres\n * que se lee igual de adelante hacia atrás (ignorando espacios, puntuación\n * y mayúsculas).\n * \n * Ejemplos:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean",
      "arb": "/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة.\n * الكلمة المتطابقة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف\n * الذي يقرأ بنفس الطريقة للأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم،\n * والحروف الكبيرة والصغيرة).\n * \n * أمثلة:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean",
      "sw": "/**\n * Tambua kama string iliyopewa ni palindrome.\n * Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi\n * ambao unasomwa sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji,\n * na herufi kubwa na ndogo).\n * \n * Mifano:\n * isPalindrome(\"racecar\") // inarudisha true\n */\nfunction isPalindrome(str: string): boolean",
      "tr": "/**\n * Belirtilen bir dizgenin palindrom olup olmadığını belirleyin.\n * Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri\n * ve büyük/küçük harf dikkate alınmadan) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n * \n * Örnekler:\n * isPalindrome(\"racecar\") // true döndürür\n */\nfunction isPalindrome(str: string): boolean",
      "vi": "/**\n * Xác định xem một chuỗi cho trước có phải là palindrome hay không.\n * Palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác\n * mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu,\n * và chữ hoa chữ thường).\n * \n * Ví dụ:\n * isPalindrome(\"racecar\") // trả về true\n */\nfunction isPalindrome(str: string): boolean"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9859095580301471",
      "sw": "0.997420983132643",
      "tr": "0.9884784447480713",
      "vi": "0.9972531404606685"
    },
    "canonical_solution": "{\n  let start: number = 0;\n  let end: number = str.length - 1;\n\n  while (start < end) {\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while (!isalnum(str[start]) && start < end) start++;\n    while (!isalnum(str[end]) && start < end) end--;\n    if (str[start].toLowerCase() !== str[end].toLowerCase())\n      return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\n// Helper function to check if a character is alphanumeric\nfunction isalnum(char: string): boolean {\n  let code: number = char.charCodeAt(0);\n  return (code > 47 && code < 58) || // numeric (0-9)\n         (code > 64 && code < 91) || // upper alpha (A-Z)\n         (code > 96 && code < 123);  // lower alpha (a-z)\n}",
    "instruction": {
      "en": "Write a TypeScript function `function isPalindrome(str: string): boolean` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\n",
      "es": "Escribe una función de TypeScript `function isPalindrome(str: string): boolean` para resolver el siguiente problema:\nDeterminar si una cadena dada es un palíndromo.\nUn palíndromo es una palabra, frase, número u otra secuencia de caracteres\nque se lee igual de adelante hacia atrás (ignorando espacios, puntuación\ny mayúsculas).\n\nEjemplos:\nisPalindrome(\"racecar\") // returns true",
      "arb": "اكتب دالة TypeScript `function isPalindrome(str: string): boolean` لحل المشكلة التالية:\nتحديد ما إذا كانت السلسلة المعطاة هي كلمة متناظرة.\nالكلمة المتناظرة هي كلمة أو عبارة أو رقم أو أي تسلسل آخر من الأحرف\nيقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات وعلامات الترقيم\nوحالة الأحرف).\n\nأمثلة:\nisPalindrome(\"racecar\") // returns true",
      "sw": "Andika kazi ya TypeScript `function isPalindrome(str: string): boolean` kutatua tatizo lifuatalo:  \nTambua kama mfuatano wa herufi uliotolewa ni palindrome.  \nPalindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi  \nambao unasomwa sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji,  \nna herufi kubwa na ndogo).\n\nMifano:  \nisPalindrome(\"racecar\") // inarudisha true",
      "tr": "Bir TypeScript fonksiyonu `function isPalindrome(str: string): boolean` yazın:\nVerilen bir dizgenin bir palindrom olup olmadığını belirleyin.\nPalindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n\nÖrnekler:\nisPalindrome(\"racecar\") // true döndürür",
      "vi": "Viết một hàm TypeScript `function isPalindrome(str: string): boolean` để giải quyết vấn đề sau:\nXác định xem một chuỗi đã cho có phải là palindrome hay không.\nPalindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác\nmà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu,\nvà chữ hoa chữ thường).\n\nVí dụ:\nisPalindrome(\"racecar\") // trả về true"
    },
    "instruction_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9817003816256368",
      "sw": "0.9871535801065686",
      "tr": "0.960880739607084",
      "vi": "0.9943962396902437"
    },
    "level": "hard",
    "test": "const testIsPalindrome = (): void => {\n  console.assert(isPalindrome(\"A man a plan a canal Panama\") === true, \"Test 1 failed\");\n  console.assert(isPalindrome(\"No lemon, no melon\") === true, \"Test 2 failed\");\n  console.assert(isPalindrome(\"Was it a car or a cat I saw\") === true, \"Test 3 failed\");\n  console.assert(isPalindrome(\"Madam, in Eden, I'm Adam\") === true, \"Test 4 failed\");\n  console.assert(isPalindrome(\"Never odd or even\") === true, \"Test 5 failed\");\n  console.assert(isPalindrome(\"Eva, can I see bees in a cave\") === true, \"Test 6 failed\");\n  console.assert(isPalindrome(\"hello\") === false, \"Test 7 failed\");\n  console.assert(isPalindrome(\"GitHub\") === false, \"Test 8 failed\");\n  console.assert(isPalindrome(\"programming\") === false, \"Test 9 failed\");\n};\n\ntestIsPalindrome();",
    "entry_point": "isPalindrome",
    "signature": "function isPalindrome(str: string): boolean",
    "docstring": {
      "en": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\n",
      "es": "Determinar si una cadena dada es un palíndromo.  \nUn palíndromo es una palabra, frase, número u otra secuencia de caracteres  \nque se lee igual de adelante hacia atrás (ignorando espacios, puntuación  \ny capitalización).  \n\nEjemplos:  \nisPalindrome(\"racecar\") // devuelve true  ",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة.\nالكلمة المتطابقة هي كلمة أو عبارة أو رقم أو أي تسلسل آخر من الأحرف\nالتي تُقرأ بنفس الطريقة من الأمام إلى الخلف ومن الخلف إلى الأمام (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\nأمثلة:\nisPalindrome(\"racecar\") // يعيد true",
      "sw": "Tambua kama mfuatano wa herufi uliotolewa ni palindrome.  \nPalindromu ni neno, kifungu cha maneno, nambari, au mlolongo mwingine wa herufi  \nambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji,  \nna herufi kubwa na ndogo).\n\nMifano:  \nisPalindrome(\"racecar\") // inarudisha kweli",
      "tr": "Verilen bir dizgenin bir palindrom olup olmadığını belirleyin.\nBir dizgenin palindrom olup olmadığını belirleyin.\nA palindrome is a word, phrase, number, or other sequence of characters\nPalindrom, ileri ve geri doğru okunduğunda aynı olan bir kelime, ifade, sayı veya başka bir karakter dizisidir\nthat reads the same forward and backward (ignoring spaces, punctuation,\n(boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek).\n\nÖrnekler:\nisPalindrome(\"racecar\") // true döndürür",
      "vi": "Xác định xem một chuỗi đã cho có phải là một chuỗi palindrome hay không.  \nMột chuỗi palindrome là một từ, cụm từ, số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\nVí dụ:\nisPalindrome(\"racecar\") // trả về true"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9924160934217069",
      "sw": "0.9999996027392379",
      "tr": "0.8666236717426933",
      "vi": "0.9958736524643812"
    }
  },
  {
    "task_id": "TypeScript/48",
    "prompt": {
      "en": "\n/**\n * Given a non-negative integer num, repeatedly add all its digits until\n * the result has only one digit. \n * For example:\n *   addDigits(38)  // returns 2\n *   Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n */\nfunction addDigits(num: number): number {",
      "es": "/**\n * Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta\n * que el resultado tenga solo un dígito. \n * Por ejemplo:\n *   addDigits(38)  // devuelve 2\n *   Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n */\nfunction addDigits(num: number): number {",
      "arb": "/**\n * معطى عدد صحيح غير سالب، قم بجمع جميع أرقامه بشكل متكرر حتى\n * يكون الناتج رقمًا واحدًا فقط.\n * على سبيل المثال:\n *   addDigits(38)  // يعيد 2\n *   التوضيح: 3 + 8 = 11، و1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.\n */\nfunction addDigits(num: number): number {",
      "sw": "/**\n * Ukipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi\n * matokeo yawe na tarakimu moja tu.\n * Kwa mfano:\n *   addDigits(38)  // inarudisha 2\n *   Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n */\nfunction addDigits(num: number): number {",
      "tr": "/**\n * Verilen bir negatif olmayan tamsayı num için, sonucu tek basamaklı olana kadar\n * tüm basamaklarını tekrar tekrar toplayın. \n * Örneğin:\n *   addDigits(38)  // 2 döndürür\n *   Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.\n */\nfunction addDigits(num: number): number {",
      "vi": "/**\n * Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi\n * kết quả chỉ còn một chữ số.\n * Ví dụ:\n *   addDigits(38)  // trả về 2\n *   Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n */\nfunction addDigits(num: number): number {"
    },
    "prompt_bertscore": {
      "es": "0.9930866695880807",
      "arb": "0.9806688940569226",
      "sw": "0.9936897114249026",
      "tr": "0.9573701462526734",
      "vi": "0.9639684488802713"
    },
    "canonical_solution": "while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function addDigits(num: number): number` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "es": "Escribe una función de TypeScript `function addDigits(num: number): number` para resolver el siguiente problema:\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n  addDigits(38)  // devuelve 2\n  Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "اكتب دالة TypeScript `function addDigits(num: number): number` لحل المشكلة التالية:\nمعطى عدد صحيح غير سالب num، قم بجمع جميع أرقامه بشكل متكرر حتى يكون الناتج عبارة عن رقم واحد فقط.\nعلى سبيل المثال:\n  addDigits(38)  // يعيد 2\n  الشرح: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Andika kazi ya TypeScript `function addDigits(num: number): number` kutatua tatizo lifuatalo:\nUkipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n  addDigits(38)  // inarudisha 2\n  Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Bir TypeScript fonksiyonu `function addDigits(num: number): number` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tam sayı num için, sonucu tek bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n  addDigits(38)  // 2 döndürür\n  Açıklama: 3 + 8 = 11, ve 1 + 1 = 2. 2 sadece bir basamağa sahip olduğundan, sonuç 2'dir.",
      "vi": "Viết một hàm TypeScript `function addDigits(num: number): number` để giải quyết vấn đề sau:\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n  addDigits(38)  // trả về 2\n  Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.9852558654461613",
      "sw": "0.9940730680602999",
      "tr": "0.9840507749244226",
      "vi": "0.9707657791496662"
    },
    "level": "easy",
    "test": "const testAddDigits = (): void => {\n    console.assert(addDigits(38) === 2, 'Test 1 failed');\n    console.assert(addDigits(0) === 0, 'Test 2 failed');\n    console.assert(addDigits(9) === 9, 'Test 3 failed');\n    console.assert(addDigits(123) === 6, 'Test 4 failed');\n    console.assert(addDigits(456) === 6, 'Test 5 failed');\n    console.assert(addDigits(9999) === 9, 'Test 6 failed');\n    console.assert(addDigits(100) === 1, 'Test 7 failed');\n    console.assert(addDigits(1010) === 2, 'Test 8 failed');\n    console.assert(addDigits(1234) === 1, 'Test 9 failed');\n    console.assert(addDigits(9876) === 3, 'Test 10 failed');\n    console.assert(addDigits(199) === 1, 'Test 11 failed');\n};\n\ntestAddDigits();",
    "entry_point": "addDigits",
    "signature": "function addDigits(num: number): number",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.  \nPor ejemplo:  \n  addDigits(38)  // devuelve 2  \n  Explicación: 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "بالنظر إلى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n  addDigits(38)  // يعيد 2\n  التفسير: 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Kwa kupewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n  addDigits(38)  // inarudisha 2\n  Maelezo: 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Verilen bir negatif olmayan tam sayı num için, sonuç tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n  addDigits(38)  // 2 döndürür\n  Açıklama: 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamağa sahip olduğundan, sonuç 2'dir.",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n  addDigits(38)  // trả về 2  \n  Giải thích: 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "docstring_bertscore": {
      "es": "0.9903282894866492",
      "arb": "0.965771814109687",
      "sw": "0.9912318590899769",
      "tr": "0.9704767719452604",
      "vi": "0.9937028210300509"
    }
  },
  {
    "task_id": "TypeScript/49",
    "prompt": {
      "en": "\n/**\n * You are playing a game called Nim. In this game, you start with a pile\n * of n stones, and you and your opponent take turns to remove 1 to 3\n * stones from the pile. The one who removes the last stone wins the game.\n * Given the number of stones n, determine if you can win the game if both\n * you and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *   canWinNim(1) // returns true\n */\nfunction canWinNim(n: number): boolean",
      "es": "/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con una pila\n * de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3\n * piedras de la pila. Quien quite la última piedra gana el juego.\n * Dado el número de piedras n, determina si puedes ganar el juego si tanto\n * tú como tu oponente juegan de manera óptima.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *   canWinNim(1) // devuelve true\n */\nfunction canWinNim(n: number): boolean",
      "arb": "/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة،\n * وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل\n * الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان يمكنك\n * الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * هنا بعض الحالات:\n *   canWinNim(1) // يعيد true\n */",
      "sw": "/**\n * Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo\n * la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3\n * kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo.\n * Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote\n * wewe na mpinzani wako mna cheza kwa ustadi.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hapa kuna baadhi ya kesi:\n *   canWinNim(1) // inarudisha true\n */\nfunction canWinNim(n: number): boolean",
      "tr": "/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşından oluşan bir yığınla\n * başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız.\n * Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de\n * rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *   canWinNim(1) // true döndürür\n */\nfunction canWinNim(n: number): boolean",
      "vi": "/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với\n * một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên\n * đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi.\n * Cho số viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả\n * bạn và đối thủ đều chơi tối ưu.\n * Lưu ý: Bạn luôn đi trước.\n *\n * Đây là một số trường hợp:\n *   canWinNim(1) // trả về true\n */\nfunction canWinNim(n: number): boolean"
    },
    "prompt_bertscore": {
      "es": "0.9887074655774045",
      "arb": "0.9462337353095713",
      "sw": "0.9958992757835348",
      "tr": "0.9680326251066261",
      "vi": "0.978354055596342"
    },
    "canonical_solution": "{\n    return n % 4 !== 0;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function canWinNim(n: number): boolean` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true\n",
      "es": "Escribe una función de TypeScript `function canWinNim(n: number): boolean` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. El que quita la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n  canWinNim(1) // returns true",
      "arb": "اكتب دالة TypeScript `function canWinNim(n: number): boolean` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n  canWinNim(1) // returns true",
      "sw": "Andika kazi ya TypeScript `function canWinNim(n: number): boolean` kutatua tatizo lifuatalo:\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo.\nUkipatiwa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n  canWinNim(1) // inarudisha true",
      "tr": "Aşağıdaki problemi çözmek için bir TypeScript fonksiyonu `function canWinNim(n: number): boolean` yazın:\nNim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşla başlıyorsunuz ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarıyorsunuz. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n  canWinNim(1) // true döndürür",
      "vi": "Viết một hàm TypeScript `function canWinNim(n: number): boolean` để giải quyết vấn đề sau:\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của mình lần lượt loại bỏ từ 1 đến 3 viên đá khỏi đống. Người loại bỏ viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n  canWinNim(1) // trả về true"
    },
    "instruction_bertscore": {
      "es": "0.9964230640983237",
      "arb": "0.9816175527567452",
      "sw": "0.9926216758660781",
      "tr": "0.966227472203781",
      "vi": "0.9858940648604264"
    },
    "level": "easy",
    "test": "function testCanWinNim(): void {\n    console.assert(canWinNim(1) === true, \"Test case 1 failed\");\n    console.assert(canWinNim(2) === true, \"Test case 2 failed\");\n    console.assert(canWinNim(3) === true, \"Test case 3 failed\");\n    console.assert(canWinNim(4) === false, \"Test case 4 failed\");\n    console.assert(canWinNim(5) === true, \"Test case 5 failed\");\n    console.assert(canWinNim(6) === true, \"Test case 6 failed\");\n    console.assert(canWinNim(7) === true, \"Test case 7 failed\");\n    console.assert(canWinNim(8) === false, \"Test case 8 failed\");\n    console.assert(canWinNim(9) === true, \"Test case 9 failed\");\n    console.assert(canWinNim(10) === true, \"Test case 10 failed\");\n    console.assert(canWinNim(11) === true, \"Test case 11 failed\");\n    console.assert(canWinNim(12) === false, \"Test case 12 failed\");\n    console.assert(canWinNim(13) === true, \"Test case 13 failed\");\n    console.assert(canWinNim(14) === true, \"Test case 14 failed\");\n    console.assert(canWinNim(15) === true, \"Test case 15 failed\");\n    console.assert(canWinNim(16) === false, \"Test case 16 failed\");\n    console.assert(canWinNim(17) === true, \"Test case 17 failed\");\n    console.assert(canWinNim(18) === true, \"Test case 18 failed\");\n    console.assert(canWinNim(19) === true, \"Test case 19 failed\");\n    console.assert(canWinNim(20) === false, \"Test case 20 failed\");\n}\ntestCanWinNim();",
    "entry_point": "canWinNim",
    "signature": "function canWinNim(n: number): boolean",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true\n",
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quita la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima. \nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n  canWinNim(1) // devuelve true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n  canWinNim(1) // يعيد true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaocheza kwa umahiri.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n  canWinNim(1) // inarudisha kweli",
      "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlıyorsunuz ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alıyorsunuz. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n  canWinNim(1) // true döndürür",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n  canWinNim(1) // trả về true"
    },
    "docstring_bertscore": {
      "es": "0.9948608361514844",
      "arb": "0.9779158769757791",
      "sw": "0.9843024396171938",
      "tr": "0.964485285131724",
      "vi": "0.9766168342838109"
    }
  },
  {
    "task_id": "TypeScript/50",
    "prompt": {
      "en": "\n/**\n * Given two integers a and b, return the sum if the sum is even,\n * or return the product of a and b if the sum is odd.\n * Examples:\n *   evenSumOrOddProduct(2, 3) returns 6\n *   evenSumOrOddProduct(5, 5) returns 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "es": "/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par,\n * o devuelve el producto de a y b si la suma es impar.\n * Ejemplos:\n *   evenSumOrOddProduct(2, 3) returns 6\n *   evenSumOrOddProduct(5, 5) returns 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "arb": "/**\n * بالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا،\n * أو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *   evenSumOrOddProduct(2, 3) returns 6\n *   evenSumOrOddProduct(5, 5) returns 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "sw": "/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa,\n * au rudisha bidhaa ya a na b ikiwa jumla ni witiri.\n * Mifano:\n *   evenSumOrOddProduct(2, 3) inarudisha 6\n *   evenSumOrOddProduct(5, 5) inarudisha 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "tr": "/**\n * İki tam sayı a ve b verildiğinde, eğer toplam çift ise toplamı döndür,\n * veya eğer toplam tek ise a ve b'nin çarpımını döndür.\n * Örnekler:\n *   evenSumOrOddProduct(2, 3) 6 döndürür\n *   evenSumOrOddProduct(5, 5) 10 döndürür\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "vi": "/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\n * hoặc trả về tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *   evenSumOrOddProduct(2, 3) trả về 6\n *   evenSumOrOddProduct(5, 5) trả về 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9912463591077925",
      "tr": "0.9733239398270145",
      "vi": "0.9975677709842278"
    },
    "canonical_solution": "let sum = a + b;\n    if (sum % 2 === 0) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function evenSumOrOddProduct(a: number, b: number): number` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even,\nor return the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10\n",
      "es": "Escribe una función de TypeScript `function evenSumOrOddProduct(a: number, b: number): number` para resolver el siguiente problema:\nDado dos enteros a y b, devuelve la suma si la suma es par,\no devuelve el producto de a y b si la suma es impar.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "arb": "اكتب دالة TypeScript `function evenSumOrOddProduct(a: number, b: number): number` لحل المشكلة التالية:\nبالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا،\nأو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sw": "Andika kazi ya TypeScript `function evenSumOrOddProduct(a: number, b: number): number` kutatua tatizo lifuatalo:\nUkipiwa namba mbili za mzima a na b, rudisha jumla ikiwa jumla ni namba shufwa,\nau rudisha bidhaa ya a na b ikiwa jumla ni namba witiri.\nMifano:\nevenSumOrOddProduct(2, 3) inarudisha 6\nevenSumOrOddProduct(5, 5) inarudisha 10",
      "tr": "Bir TypeScript fonksiyonu `function evenSumOrOddProduct(a: number, b: number): number` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, eğer toplam çift ise toplamı döndürün,\nya da eğer toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nevenSumOrOddProduct(2, 3) 6 döndürür\nevenSumOrOddProduct(5, 5) 10 döndürür",
      "vi": "Viết một hàm TypeScript `function evenSumOrOddProduct(a: number, b: number): number` để giải quyết vấn đề sau:\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn,\nhoặc trả về tích của a và b nếu tổng là số lẻ.\nVí dụ:\nevenSumOrOddProduct(2, 3) trả về 6\nevenSumOrOddProduct(5, 5) trả về 10"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9805713665398345",
      "tr": "0.9641805861272166",
      "vi": "0.9983269363005431"
    },
    "level": "easy",
    "test": "const testEvenSumOrOddProduct = (): void => {\n    console.assert(evenSumOrOddProduct(2, 3) === 6, 'Test Case 1 Failed');\n    console.assert(evenSumOrOddProduct(5, 5) === 10, 'Test Case 2 Failed');\n    console.assert(evenSumOrOddProduct(1, 1) === 2, 'Test Case 3 Failed');\n    console.assert(evenSumOrOddProduct(0, 0) === 0, 'Test Case 4 Failed');\n    console.assert(evenSumOrOddProduct(-1, -1) === -2, 'Test Case 5 Failed');\n    console.assert(evenSumOrOddProduct(100, 200) === 300, 'Test Case 6 Failed');\n    console.assert(evenSumOrOddProduct(3, 4) === 12, 'Test Case 7 Failed');\n    console.assert(evenSumOrOddProduct(-5, 5) === 0, 'Test Case 8 Failed');\n    console.assert(evenSumOrOddProduct(7, 8) === 56, 'Test Case 9 Failed');\n    console.assert(evenSumOrOddProduct(9, 10) === 90, 'Test Case 10 Failed');\n    console.assert(evenSumOrOddProduct(11, 14) === 154, 'Test Case 11 Failed');\n};\n\ntestEvenSumOrOddProduct();",
    "entry_point": "evenSumOrOddProduct",
    "signature": "function evenSumOrOddProduct(a: number, b: number): number",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even,\nor return the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10\n",
      "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\nEjemplos:\nevenSumOrOddProduct(2, 3) devuelve 6\nevenSumOrOddProduct(5, 5) devuelve 10",
      "arb": "نظرًا لعددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sw": "Ukipiwa namba mbili za mzima a na b, rudisha jumla ikiwa jumla ni namba shufwa,\nau rudisha bidhaa ya a na b ikiwa jumla ni namba witiri.  \nMifano:  \nevenSumOrOddProduct(2, 3) inarejesha 6  \nevenSumOrOddProduct(5, 5) inarejesha 10  ",
      "tr": "Verilen iki tam sayı a ve b için, eğer toplam çift ise toplamı döndürün,\nya da eğer toplam tek ise a ve b'nin çarpımını döndürün.  \nÖrnekler:  \nevenSumOrOddProduct(2, 3) 6 döndürür  \nevenSumOrOddProduct(5, 5) 10 döndürür  ",
      "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ. \nVí dụ: \nevenSumOrOddProduct(2, 3) trả về 6 \nevenSumOrOddProduct(5, 5) trả về 10"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.9977828876868886"
    }
  }
]