[
  {
    "task_id": "Swift/1",
    "prompt": {
      "en": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "es": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nVerifica si en el array dado de números, hay dos números que están más cerca uno del otro que\nel umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "arb": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nتحقق مما إذا كان في المصفوفة المعطاة من الأرقام، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "sw": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nAngalia kama katika safu iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi na kila mmoja kuliko\nkizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "tr": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nVerilen sayı dizisinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol et.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "vi": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nKiểm tra xem trong mảng số đã cho, có bất kỳ hai số nào gần nhau hơn\nngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9832638013547624",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.9805548802182086",
      "vi": "0.9800402289009472"
    },
    "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}",
    "instruction": {
      "en": "Write a Swift function `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` to solve the following problem:\n\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "es": "Escribe una función en Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` para resolver el siguiente problema:\n\nVerifica si en el array dado de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "اكتب دالة Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` لحل المشكلة التالية:\n\nتحقق مما إذا كان في المصفوفة المعطاة من الأرقام، أي رقمين أقرب لبعضهما البعض من العتبة المعطاة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Andika kazi ya Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` kutatua tatizo lifuatalo:\n\nAngalia kama katika safu iliyotolewa ya namba, namba zozote mbili ziko karibu zaidi kuliko\nkizingiti kilichopewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Bir Swift fonksiyonu `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` yazın:\n\nVerilen sayı dizisinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "vi": "Viết một hàm Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` để giải quyết vấn đề sau:\n\nKiểm tra xem trong mảng số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "instruction_bertscore": {
      "es": "0.980682202292452",
      "arb": "0.9999996027392379",
      "sw": "0.9820799642837944",
      "tr": "0.966284081862376",
      "vi": "0.9920474354345061"
    },
    "level": "easy",
    "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)",
    "entry_point": "hasCloseElements",
    "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {",
    "docstring": {
      "en": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "es": "Verifica si en el array dado de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "تحقق مما إذا كان في المصفوفة المعطاة من الأرقام، أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia kama katika safu iliyopewa ya nambari, nambari yoyote mbili ziko karibu zaidi kuliko kizingiti kilichopewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı dizisinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong mảng số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không. \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "es": "0.9806885584646451",
      "arb": "0.9948238909006119",
      "sw": "0.9757720592732695",
      "tr": "0.9703013813188066",
      "vi": "0.693550068683659"
    }
  },
  {
    "task_id": "Swift/2",
    "prompt": {
      "en": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "es": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nEncuentra y devuelve la primera cadena palíndromo en el arreglo dado de palabras.\nSi no se encuentra ninguna cadena palíndromo, devuelve una cadena vacía \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "arb": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nيعثر ويعيد أول سلسلة نصية متطابقة في المصفوفة المعطاة من الكلمات.\nإذا لم يتم العثور على سلسلة نصية متطابقة، يعيد سلسلة فارغة \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "sw": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nInapata na kurudisha neno la kwanza la palindrome katika safu iliyotolewa ya maneno.\nKama hakuna neno la palindrome linalopatikana, inarudisha kamba tupu \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "tr": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nVerilen kelime dizisinde ilk palindromik kelimeyi bulur ve döndürür.\nEğer palindromik bir kelime bulunamazsa, boş bir string \"\" döndürür.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "vi": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nTìm và trả về chuỗi palindrome đầu tiên trong mảng từ đã cho.\nNếu không tìm thấy chuỗi palindrome nào, trả về chuỗi rỗng \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9999994041088569",
      "arb": "0.9999994041088569",
      "sw": "0.9888953699178635",
      "tr": "0.9703691142787395",
      "vi": "0.9915280169881"
    },
    "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}",
    "instruction": {
      "en": "Write a Swift function `func firstPalindrome(_ words: [String]) -> String {` to solve the following problem:\n\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n",
      "es": "Escribe una función en Swift `func firstPalindrome(_ words: [String]) -> String {` para resolver el siguiente problema:\n\nEncuentra y devuelve la primera cadena de texto que sea un palíndromo en el arreglo dado de palabras.\nSi no se encuentra ninguna cadena de texto que sea un palíndromo, devuelve una cadena vacía \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "arb": "اكتب دالة Swift `func firstPalindrome(_ words: [String]) -> String {` لحل المشكلة التالية:\n\nتجد وتعيد أول سلسلة نصية متطابقة في المصفوفة المعطاة من الكلمات. إذا لم يتم العثور على سلسلة نصية متطابقة، تعيد سلسلة فارغة \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "sw": "Andika kazi ya Swift `func firstPalindrome(_ words: [String]) -> String {` kutatua tatizo lifuatalo:\n\nInapata na kurudisha neno la kwanza lenye palindrome katika safu iliyotolewa ya maneno.\nKama hakuna neno lenye palindrome linalopatikana, inarudisha kamba tupu \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "tr": "Bir Swift fonksiyonu `func firstPalindrome(_ words: [String]) -> String {` yazın:\n\nVerilen kelime dizisinde ilk palindrom olan kelimeyi bulur ve döndürür.\nEğer palindrom bir kelime bulunamazsa, boş bir string \"\" döndürür.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "vi": "Viết một hàm Swift `func firstPalindrome(_ words: [String]) -> String {` để giải quyết vấn đề sau:\n\nTìm và trả về chuỗi palindrome đầu tiên trong mảng từ đã cho.\nNếu không tìm thấy chuỗi palindrome nào, trả về một chuỗi rỗng \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\""
    },
    "instruction_bertscore": {
      "es": "0.962207193291635",
      "arb": "0.9843413711718767",
      "sw": "0.9852755298538838",
      "tr": "0.9657990264718889",
      "vi": "0.9941630476229087"
    },
    "level": "easy",
    "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)",
    "entry_point": "firstPalindrome",
    "signature": "func firstPalindrome(_ words: [String]) -> String {",
    "docstring": {
      "en": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n",
      "es": "Encuentra y devuelve la primera cadena palíndroma en el arreglo dado de palabras.  \nSi no se encuentra ninguna cadena palíndroma, devuelve una cadena vacía \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "arb": "يعثر ويعيد أول سلسلة نصية متطابقة في المصفوفة المعطاة من الكلمات. إذا لم يتم العثور على سلسلة نصية متطابقة، يعيد سلسلة فارغة \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "sw": "Inapata na kurudisha neno la kwanza lenye palindrome katika safu iliyotolewa ya maneno. Ikiwa hakuna neno lenye palindrome linalopatikana, inarudisha kamba tupu \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "tr": "Verilen kelime dizisinde ilk palindromik dizgiyi bulur ve döndürür.\nEğer palindromik bir dizgi bulunamazsa, boş bir dizgi \"\" döndürür.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "vi": "Tìm và trả về chuỗi palindrome đầu tiên trong mảng từ đã cho. Nếu không tìm thấy chuỗi palindrome nào, trả về chuỗi rỗng \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\""
    },
    "docstring_bertscore": {
      "es": "0.9789948372055606",
      "arb": "0.9577397973917793",
      "sw": "0.9851223858301058",
      "tr": "0.9848063648938793",
      "vi": "0.9892757470975454"
    }
  },
  {
    "task_id": "Swift/3",
    "prompt": {
      "en": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "es": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nDevuelve el número máximo de palabras encontradas en cualquier oración dentro del arreglo dado de oraciones.\nUna oración está compuesta por palabras separadas por un solo espacio, y no hay espacios al principio o al final.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "arb": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nيعيد العدد الأقصى من الكلمات الموجودة في أي جملة واحدة ضمن مصفوفة الجمل المعطاة.\nتتكون الجملة من كلمات مفصولة بمسافة واحدة، ولا توجد مسافات في البداية أو النهاية.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "sw": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nInarejesha idadi kubwa zaidi ya maneno yaliyopatikana katika sentensi yoyote moja ndani ya safu iliyotolewa ya sentensi.\nSentensi inaundwa na maneno yaliyotenganishwa na nafasi moja, na hakuna nafasi mwanzoni au mwishoni.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "tr": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nVerilen cümleler dizisindeki herhangi bir tek cümlede bulunan maksimum kelime sayısını döndürür.\nBir cümle, tek bir boşlukla ayrılmış kelimelerden oluşur ve başta veya sonda boşluk yoktur.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "vi": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nTrả về số lượng từ tối đa được tìm thấy trong bất kỳ câu nào trong mảng câu đã cho.\nMột câu được tạo thành từ các từ cách nhau bởi một khoảng trắng đơn, và không có khoảng trắng ở đầu hoặc cuối.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9744305096797599",
      "arb": "0.981513669067464",
      "sw": "0.9856098247851655",
      "tr": "0.970104538611201",
      "vi": "0.9840561379447106"
    },
    "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}",
    "instruction": {
      "en": "Write a Swift function `func maxWordCount(_ sentences: [String]) -> Int {` to solve the following problem:\n\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n",
      "es": "Escribe una función Swift `func maxWordCount(_ sentences: [String]) -> Int {` para resolver el siguiente problema:\n\nDevuelve el número máximo de palabras encontradas en cualquier oración individual dentro del array dado de oraciones.\nUna oración está compuesta por palabras separadas por un solo espacio, y no hay espacios al principio ni al final.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "arb": "اكتب دالة Swift `func maxWordCount(_ sentences: [String]) -> Int {` لحل المشكلة التالية:\n\nتعيد العدد الأقصى من الكلمات الموجودة في أي جملة واحدة داخل مصفوفة الجمل المعطاة.\nتتكون الجملة من كلمات مفصولة بمسافة واحدة، ولا توجد مسافات في البداية أو النهاية.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "sw": "Andika kazi ya Swift `func maxWordCount(_ sentences: [String]) -> Int {` kutatua tatizo lifuatalo:\n\nRudisha idadi kubwa zaidi ya maneno yaliyopatikana katika sentensi yoyote moja ndani ya safu iliyotolewa ya sentensi. Sentensi inaundwa na maneno yaliyotenganishwa na nafasi moja, na hakuna nafasi za mwanzo au mwisho.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "tr": "Bir Swift fonksiyonu `func maxWordCount(_ sentences: [String]) -> Int {` yazın:\n\nVerilen cümleler dizisindeki herhangi bir tek cümlede bulunan maksimum kelime sayısını döndürür.\nBir cümle, tek bir boşlukla ayrılmış kelimelerden oluşur ve başında ya da sonunda boşluk yoktur.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "vi": "Viết một hàm Swift `func maxWordCount(_ sentences: [String]) -> Int {` để giải quyết vấn đề sau:\n\nTrả về số lượng từ tối đa được tìm thấy trong bất kỳ câu đơn nào trong mảng các câu đã cho.\nMột câu được tạo thành từ các từ được ngăn cách bởi một khoảng trắng đơn, và không có khoảng trắng ở đầu hoặc cuối.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5"
    },
    "instruction_bertscore": {
      "es": "0.8364503264508265",
      "arb": "0.9829958489707463",
      "sw": "0.9918345036660368",
      "tr": "0.9500293632607669",
      "vi": "0.9923096275374722"
    },
    "level": "easy",
    "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)",
    "entry_point": "maxWordCount",
    "signature": "func maxWordCount(_ sentences: [String]) -> Int {",
    "docstring": {
      "en": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n",
      "es": "Devuelve el número máximo de palabras encontradas en cualquier oración dentro del array dado de oraciones.  \nUna oración está compuesta por palabras separadas por un solo espacio, y no hay espacios al principio ni al final.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "arb": "يعيد العدد الأقصى من الكلمات الموجودة في أي جملة واحدة داخل المصفوفة المعطاة من الجمل.  \nتتكون الجملة من كلمات مفصولة بمسافة واحدة، ولا توجد مسافات في البداية أو النهاية.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "sw": "Inarudisha idadi kubwa zaidi ya maneno yaliyopatikana katika sentensi yoyote moja ndani ya safu uliyopewa ya sentensi.  \nSentensi inaundwa na maneno yaliyotenganishwa na nafasi moja, na hakuna nafasi za mwanzo au mwisho.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "tr": "Verilen cümleler dizisindeki herhangi bir tek cümlede bulunan maksimum kelime sayısını döndürür.  \nBir cümle, tek bir boşlukla ayrılmış kelimelerden oluşur ve başta veya sonda boşluk yoktur.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "vi": "Trả về số lượng từ tối đa được tìm thấy trong bất kỳ câu nào trong mảng câu đã cho.  \nMột câu được tạo thành từ các từ cách nhau bằng một khoảng trắng đơn, và không có khoảng trắng ở đầu hoặc cuối.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  "
    },
    "docstring_bertscore": {
      "es": "0.9713988141740244",
      "arb": "0.9697334970594279",
      "sw": "0.977989568847143",
      "tr": "0.9664155751746211",
      "vi": "0.9685244339300685"
    }
  },
  {
    "task_id": "Swift/4",
    "prompt": {
      "en": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "es": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nVerifica si la matriz `n x n` dada es una matriz válida. Una matriz es válida si cada fila y \ncolumna contiene todos los enteros del 1 al n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "arb": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nيتحقق مما إذا كانت المصفوفة `n x n` المعطاة مصفوفة صالحة. تكون المصفوفة صالحة إذا كانت كل صف وعمود تحتوي على جميع الأعداد الصحيحة من 1 إلى n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "sw": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nHukagua kama matrix iliyotolewa ya `n x n` ni matrix halali. Matrix ni halali ikiwa kila safu na \nsafu wima ina nambari zote kutoka 1 hadi n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "tr": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nVerilen `n x n` matrisin geçerli bir matris olup olmadığını kontrol eder. Bir matris, her satır ve sütun 1'den n'e kadar tüm tam sayıları içeriyorsa geçerlidir.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "vi": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nKiểm tra xem ma trận `n x n` đã cho có phải là ma trận hợp lệ hay không. Một ma trận hợp lệ nếu mỗi hàng và cột chứa tất cả các số nguyên từ 1 đến n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.998503121448521",
      "sw": "0.9948272676170894",
      "tr": "1",
      "vi": "0.9969788319044594"
    },
    "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}",
    "instruction": {
      "en": "Write a Swift function `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` to solve the following problem:\n\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n",
      "es": "Escribe una función de Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` para resolver el siguiente problema:\n\nVerifica si la matriz `n x n` dada es una matriz válida. Una matriz es válida si cada fila y columna contiene todos los enteros del 1 al n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "arb": "اكتب دالة Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` لحل المشكلة التالية:\n\nالتحقق مما إذا كانت المصفوفة `n x n` المعطاة مصفوفة صالحة. تكون المصفوفة صالحة إذا كانت كل صف وعمود يحتويان على جميع الأعداد الصحيحة من 1 إلى n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "sw": "Andika kazi ya Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` kutatua tatizo lifuatalo:\n\nHukagua kama `n x n` matrix iliyotolewa ni matrix halali. Matrix ni halali ikiwa kila safu na safu wima ina namba zote kutoka 1 hadi n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "tr": "Bir Swift fonksiyonu `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` yazın ve aşağıdaki problemi çözün:\n\nVerilen `n x n` matrisin geçerli bir matris olup olmadığını kontrol eder. Bir matris, her satır ve sütunun 1'den n'e kadar tüm tam sayıları içermesi durumunda geçerlidir.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "vi": "Viết một hàm Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` để giải quyết vấn đề sau:\n\nKiểm tra xem ma trận `n x n` đã cho có phải là ma trận hợp lệ hay không. Một ma trận là hợp lệ nếu mỗi hàng và cột chứa tất cả các số nguyên từ 1 đến n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse"
    },
    "instruction_bertscore": {
      "es": "0.9980099222124115",
      "arb": "0.9980099222124115",
      "sw": "0.9931063339958032",
      "tr": "0.9957429536736603",
      "vi": "0.9980099222124115"
    },
    "level": "middle",
    "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)",
    "entry_point": "isValidMatrix",
    "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {",
    "docstring": {
      "en": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n",
      "es": "Verifica si la matriz `n x n` dada es una matriz válida. Una matriz es válida si cada fila y columna contiene todos los enteros del 1 al n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "arb": "يتحقق مما إذا كانت المصفوفة `n x n` المعطاة مصفوفة صالحة. تكون المصفوفة صالحة إذا كان كل صف وعمود يحتويان على جميع الأعداد الصحيحة من 1 إلى n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "sw": "Hukagua kama matriki ya `n x n` iliyotolewa ni matriki halali. Matriksi ni halali ikiwa kila safu na kila safu wima ina namba zote kutoka 1 hadi n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "tr": "Verilen `n x n` matrisinin geçerli bir matris olup olmadığını kontrol eder. Bir matris, her satır ve sütun 1'den n'e kadar tüm tam sayıları içeriyorsa geçerlidir.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "vi": "Kiểm tra xem ma trận `n x n` đã cho có phải là ma trận hợp lệ hay không. Một ma trận là hợp lệ nếu mỗi hàng và cột chứa tất cả các số nguyên từ 1 đến n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse"
    },
    "docstring_bertscore": {
      "es": "0.9952827270808025",
      "arb": "1",
      "sw": "0.9813494017423482",
      "tr": "0.9950993912391073",
      "vi": "0.9952827270808025"
    }
  },
  {
    "task_id": "Swift/5",
    "prompt": {
      "en": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/",
      "es": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalcula el costo total mínimo para adquirir todos los caramelos bajo una promoción donde\ncomprar dos caramelos te da un caramelo gratis (con su precio menor o igual al menor de los dos comprados).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Compra caramelos que cuestan 4 y 3, obtén 2 gratis; paga por 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Compra ambos caramelos, no hay caramelos gratis disponibles.\n*/",
      "arb": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nيحسب الحد الأدنى للتكلفة الإجمالية للحصول على جميع الحلوى تحت عرض ترويجي حيث\nشراء حبتين من الحلوى يمنحك حبة مجانية (بسعر أقل من أو يساوي الأقل من الحبتين المشتراتين).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // شراء الحلوى التي تكلف 4 و 3، الحصول على 2 مجانًا؛ الدفع مقابل 1.\n>>> minCostToBuyCandies([1, 2])\n3 // شراء كلا الحبتين، لا توجد حلوى مجانية متاحة.\n*/",
      "sw": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nHesabu gharama ndogo kabisa ya kununua pipi zote chini ya ofa ambapo\nkununua pipi mbili unapata pipi moja bure (ikiwa na bei ndogo au sawa na ile ya pipi mbili ulizonunua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Nunua pipi zenye gharama ya 4 na 3, pata 2 bure; lipa kwa 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Nunua pipi zote mbili, hakuna pipi za bure zinazopatikana.\n*/",
      "tr": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nTüm şekerleri satın almak için, iki şeker alındığında bir bedava şeker (alınan iki şekerden daha düşük veya eşit fiyata sahip olan) verilen bir promosyon altında minimum toplam maliyeti hesaplar.\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 ve 3 maliyetli şekerleri satın alın, 2 bedava; 1 için ödeme yapın.\n>>> minCostToBuyCandies([1, 2])\n3 // Her iki şekeri de satın alın, bedava şeker yok.\n*/",
      "vi": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nTính tổng chi phí tối thiểu để mua tất cả kẹo theo khuyến mãi mua hai kẹo được một kẹo miễn phí (với giá của kẹo miễn phí nhỏ hơn hoặc bằng kẹo có giá thấp hơn trong hai kẹo đã mua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Mua kẹo giá 4 và 3, nhận kẹo giá 2 miễn phí; trả tiền cho kẹo giá 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Mua cả hai kẹo, không có kẹo miễn phí.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9908775024902107",
      "arb": "0.9750416953622042",
      "sw": "0.959588648978452",
      "tr": "0.9339828092984825",
      "vi": "0.9152193889844028"
    },
    "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}",
    "instruction": {
      "en": "Write a Swift function `func minCostToBuyCandies(_ costs: [Int]) -> Int {` to solve the following problem:\n\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n",
      "es": "Escribe una función en Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` para resolver el siguiente problema:\n\nCalcula el costo total mínimo para adquirir todos los dulces bajo una promoción donde al comprar dos dulces se obtiene uno gratis (con su precio menor o igual al menor de los dos comprados).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Comprar dulces que cuestan 4 y 3, obtener 2 gratis; pagar por 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Comprar ambos dulces, no hay dulces gratis disponibles.",
      "arb": "اكتب دالة Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` لحل المشكلة التالية:\n\nتحسب التكلفة الإجمالية الدنيا للحصول على جميع الحلوى تحت عرض ترويجي حيث شراء حبتين من الحلوى يمنحك حبة مجانية (بسعر أقل من أو يساوي الأقل من الحبتين المشتراتين).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // شراء الحلوى التي تكلف 4 و 3، الحصول على 2 مجانًا؛ دفع ثمن 1.\n>>> minCostToBuyCandies([1, 2])\n3 // شراء كلا الحبتين، لا توجد حلوى مجانية متاحة.",
      "sw": "Andika kazi ya Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu gharama ndogo zaidi ya jumla ya kupata pipi zote chini ya ofa ambapo\nkununua pipi mbili unapata pipi moja bure (ikiwa na bei ndogo au sawa na ile ya chini kati ya zile mbili ulizonunua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Nunua pipi zenye gharama 4 na 3, pata 2 bure; lipa kwa 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Nunua pipi zote mbili, hakuna pipi za bure zinazopatikana.",
      "tr": "Bir Swift fonksiyonu `func minCostToBuyCandies(_ costs: [Int]) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nİki şekerleme alındığında bir şekerlemenin bedava olduğu (bedava olanın fiyatı alınan iki şekerlemeden daha düşük veya eşit olmalı) bir promosyon altında tüm şekerlemeleri edinmenin minimum toplam maliyetini hesaplar.\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 ve 3 maliyetli şekerlemeleri satın alın, 2 bedava; 1 için ödeme yapın.\n>>> minCostToBuyCandies([1, 2])\n3 // Her iki şekerlemeyi de satın alın, bedava şekerleme yok.",
      "vi": "Viết một hàm Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nTính toán tổng chi phí tối thiểu để mua tất cả kẹo theo một chương trình khuyến mãi mà khi mua hai viên kẹo sẽ được tặng một viên kẹo miễn phí (với giá của viên kẹo miễn phí nhỏ hơn hoặc bằng giá của viên kẹo rẻ hơn trong hai viên đã mua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Mua kẹo có giá 4 và 3, được tặng 2 miễn phí; trả tiền cho 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Mua cả hai viên kẹo, không có kẹo miễn phí."
    },
    "instruction_bertscore": {
      "es": "0.9867352645241091",
      "arb": "0.9661384857930775",
      "sw": "0.9593447308705412",
      "tr": "0.9318312450111126",
      "vi": "0.9349572899478397"
    },
    "level": "easy",
    "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)",
    "entry_point": "minCostToBuyCandies",
    "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n",
      "es": "Calcula el costo total mínimo para adquirir todos los caramelos bajo una promoción donde al comprar dos caramelos se obtiene uno gratis (con un precio menor o igual al menor de los dos comprados).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Comprar caramelos que cuestan 4 y 3, obtener 2 gratis; pagar por 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Comprar ambos caramelos, no hay caramelos gratis disponibles.",
      "arb": "يحسب الحد الأدنى للتكلفة الإجمالية للحصول على جميع الحلوى تحت عرض ترويجي حيث شراء حبتين من الحلوى يمنح حبة حلوى مجانية (بسعر أقل من أو يساوي الأقل من الحبتين المشتراتين).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // شراء الحلوى التي تكلف 4 و 3، الحصول على 2 مجانًا؛ الدفع مقابل 1.\n>>> minCostToBuyCandies([1, 2])\n3 // شراء كلا الحبتين من الحلوى، لا تتوفر حلوى مجانية.",
      "sw": "Hesabu gharama ndogo kabisa ya kupata pipi zote chini ya ofa ambapo\nkununua pipi mbili unapata pipi moja bure (ikiwa na bei ndogo au sawa na ile ya pipi mbili ulizonunua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Nunua pipi zenye gharama ya 4 na 3, pata 2 bure; lipa kwa 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Nunua pipi zote mbili, hakuna pipi za bure zinazopatikana.",
      "tr": "Tüm şekerleri bir promosyon altında satın almak için minimum toplam maliyeti hesaplar. Bu promosyonda iki şeker alındığında, bir şeker bedava verilir (bedava şekerin fiyatı, satın alınan iki şekerden daha ucuz veya eşit olmalıdır).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 ve 3 maliyetli şekerleri satın alın, 2 bedava; 1 için ödeme yapın.\n>>> minCostToBuyCandies([1, 2])\n3 // Her iki şekeri de satın alın, bedava şeker yok.",
      "vi": "Tính tổng chi phí tối thiểu để mua tất cả kẹo theo chương trình khuyến mãi mà khi mua hai viên kẹo sẽ được tặng một viên miễn phí (với giá nhỏ hơn hoặc bằng giá của viên rẻ hơn trong hai viên đã mua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Mua kẹo giá 4 và 3, được tặng 2 miễn phí; trả tiền cho 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Mua cả hai viên kẹo, không có kẹo miễn phí."
    },
    "docstring_bertscore": {
      "es": "0.9782976445681281",
      "arb": "0.9667091508777906",
      "sw": "0.9570261184327209",
      "tr": "0.9228930764949237",
      "vi": "0.9411388660360264"
    }
  },
  {
    "task_id": "Swift/6",
    "prompt": {
      "en": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n*/",
      "es": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCuenta el número de elementos en el arreglo que tienen al menos uno estrictamente menor y \nuno estrictamente mayor.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como uno mayor (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como uno mayor (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // No hay elementos con tanto un elemento menor como uno mayor.\n*/",
      "arb": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nيحسب عدد العناصر في المصفوفة التي لديها على الأقل عنصر واحد أصغر بشكل صارم وعنصر واحد أكبر بشكل صارم.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // لا توجد عناصر لديها عنصر أصغر وعنصر أكبر.\n*/",
      "sw": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nInahesabu idadi ya vipengele katika safu ambayo ina angalau moja ndogo kabisa na \nmoja kubwa kabisa.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Ni kipengele '2' pekee kilicho na kipengele kidogo (1) na kikubwa (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Ni kipengele '2' pekee kilicho na kipengele kidogo (1) na kikubwa (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hakuna vipengele vyenye kipengele kidogo na kikubwa.\n*/",
      "tr": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nDizide en az bir tane kesinlikle daha küçük ve bir tane kesinlikle daha büyük elemanı olan elemanların sayısını sayar.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hem daha küçük hem de daha büyük bir elemanı olan hiçbir eleman yoktur.\n*/",
      "vi": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nĐếm số lượng phần tử trong mảng có ít nhất một phần tử nhỏ hơn nghiêm ngặt và \nmột phần tử lớn hơn nghiêm ngặt.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và phần tử lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và phần tử lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Không có phần tử nào có cả phần tử nhỏ hơn và lớn hơn.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9772903899059002",
      "arb": "0.9567484331600341",
      "sw": "0.9575781122616168",
      "tr": "0.9758326415394851",
      "vi": "0.9758646210308318"
    },
    "canonical_solution": "guard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}",
    "instruction": {
      "en": "Write a Swift function `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` to solve the following problem:\n\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n",
      "es": "Escribe una función Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` para resolver el siguiente problema:\n\nCuenta el número de elementos en el arreglo que tienen al menos uno estrictamente menor y uno estrictamente mayor.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como un elemento mayor (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como un elemento mayor (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // No hay elementos con tanto un elemento menor como uno mayor.",
      "arb": "اكتب دالة Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` لحل المشكلة التالية:\n\nتحسب عدد العناصر في المصفوفة التي لديها على الأقل عنصر واحد أصغر بشكل صارم وعنصر واحد أكبر بشكل صارم.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // لا توجد عناصر لديها عنصر أصغر وعنصر أكبر.",
      "sw": "Andika kazi ya Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya vipengele kwenye safu ambavyo vina angalau kimoja kidogo zaidi na kimoja kikubwa zaidi.\n\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Ni kipengele '2' pekee chenye kipengele kidogo zaidi (1) na kikubwa zaidi (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Ni kipengele '2' pekee chenye kipengele kidogo zaidi (1) na kikubwa zaidi (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hakuna vipengele vyenye kipengele kidogo zaidi na kikubwa zaidi.",
      "tr": "Bir Swift fonksiyonu `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nDizide en az bir tane kesinlikle daha küçük ve bir tane kesinlikle daha büyük elemana sahip olan elemanların sayısını sayar.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hem daha küçük hem de daha büyük bir elemana sahip olan hiçbir eleman yoktur.",
      "vi": "Viết một hàm Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nĐếm số lượng phần tử trong mảng có ít nhất một phần tử nhỏ hơn và một phần tử lớn hơn một cách nghiêm ngặt.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Không có phần tử nào có cả phần tử nhỏ hơn và lớn hơn."
    },
    "instruction_bertscore": {
      "es": "0.9790232413500486",
      "arb": "0.9608038696496235",
      "sw": "0.9633582563497322",
      "tr": "0.9924973332475502",
      "vi": "0.9757466345844971"
    },
    "level": "easy",
    "test": "func checkCountElementsWithStrictBounds(_ countElementsWithStrictBounds: ([Int]) -> Int) {\nassert(countElementsWithStrictBounds([2, 1, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 2, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 1, 1]) == 0)\nassert(countElementsWithStrictBounds([3, 3, 5, 2, 2, 7, 4]) == 4)\nassert(countElementsWithStrictBounds([10, 5, 9, 1, 7, 6, 8]) == 5)\nassert(countElementsWithStrictBounds([-2, -1, 0, 1, 2]) == 3)\nassert(countElementsWithStrictBounds([]) == 0)\n}\n\ncheckCountElementsWithStrictBounds(countElementsWithStrictBounds)",
    "entry_point": "countElementsWithStrictBounds",
    "signature": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n",
      "es": "Cuenta el número de elementos en el arreglo que tienen al menos un elemento estrictamente menor y uno estrictamente mayor.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como uno mayor (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como uno mayor (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // No hay elementos con tanto un elemento menor como uno mayor.",
      "arb": "يحسب عدد العناصر في المصفوفة التي لديها على الأقل عنصر واحد أصغر بشكل صارم وعنصر واحد أكبر بشكل صارم.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // لا توجد عناصر لديها عنصر أصغر وعنصر أكبر.",
      "sw": "Hesabu idadi ya vipengele katika safu ambayo ina angalau kipengele kimoja kilicho kidogo zaidi na kimoja kilicho kikubwa zaidi.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Ni kipengele '2' pekee kilicho na kipengele kidogo zaidi (1) na kikubwa zaidi (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Ni kipengele '2' pekee kilicho na kipengele kidogo zaidi (1) na kikubwa zaidi (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hakuna vipengele vyenye kipengele kidogo zaidi na kikubwa zaidi.",
      "tr": "Dizide, en az bir tane kesinlikle daha küçük ve bir tane kesinlikle daha büyük elemana sahip olan elemanların sayısını sayar.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hem daha küçük hem de daha büyük bir elemana sahip olan hiçbir eleman yoktur.",
      "vi": "Đếm số lượng phần tử trong mảng có ít nhất một phần tử nhỏ hơn và một phần tử lớn hơn nghiêm ngặt.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Không có phần tử nào có cả phần tử nhỏ hơn và lớn hơn."
    },
    "docstring_bertscore": {
      "es": "0.9655396151942572",
      "arb": "0.954721211491192",
      "sw": "0.9500933222434602",
      "tr": "0.9854713794095842",
      "vi": "0.9720231094616171"
    }
  },
  {
    "task_id": "Swift/7",
    "prompt": {
      "en": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/",
      "es": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nDuplica continuamente el valor de 'original' si se encuentra en el array 'nums'.\nDevuelve el valor final de 'original' después de repetir este proceso.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 se encuentra, se convierte en 6; 6 se encuentra, se convierte en 12; 12 se encuentra, se convierte en 24; 24 no se encuentra.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 no se encuentra, original permanece 4.\n*/",
      "arb": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nيضاعف قيمة 'original' باستمرار إذا تم العثور عليها في المصفوفة 'nums'.\nيعيد القيمة النهائية لـ 'original' بعد تكرار هذه العملية.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // تم العثور على 3، تصبح 6؛ تم العثور على 6، تصبح 12؛ تم العثور على 12، تصبح 24؛ 24 لم يتم العثور عليها.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 لم يتم العثور عليها، تبقى original كما هي 4.\n*/",
      "sw": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nInazidisha mara mbili thamani ya 'original' kila inapopatikana kwenye orodha 'nums'.\nInarudisha thamani ya mwisho ya 'original' baada ya kurudia mchakato huu.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 inapatikana, inakuwa 6; 6 inapatikana, inakuwa 12; 12 inapatikana, inakuwa 24; 24 haipatikani.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 haipatikani, original inabaki 4.\n*/",
      "tr": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n'original' değerini 'nums' dizisinde bulundukça sürekli iki katına çıkarır.\nBu işlemi tekrarladıktan sonra 'original' değerinin son halini döndürür.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 bulundu, 6 oldu; 6 bulundu, 12 oldu; 12 bulundu, 24 oldu; 24 bulunamadı.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 bulunamadı, original 4 olarak kalır.\n*/",
      "vi": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nLiên tục nhân đôi giá trị của 'original' nếu nó được tìm thấy trong mảng 'nums'.\nTrả về giá trị cuối cùng của 'original' sau khi lặp lại quá trình này.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 được tìm thấy, trở thành 6; 6 được tìm thấy, trở thành 12; 12 được tìm thấy, trở thành 24; 24 không được tìm thấy.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 không được tìm thấy, original vẫn là 4.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9982113334187809",
      "arb": "0.9955733233282564",
      "sw": "0.9783145281505161",
      "tr": "0.9468121469791448",
      "vi": "0.996322159864758"
    },
    "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}",
    "instruction": {
      "en": "Write a Swift function `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` to solve the following problem:\n\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n",
      "es": "Escribe una función en Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` para resolver el siguiente problema:\n\nDuplica continuamente el valor de 'original' si se encuentra en el array 'nums'.\nDevuelve el valor final de 'original' después de repetir este proceso.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 se encuentra, se convierte en 6; 6 se encuentra, se convierte en 12; 12 se encuentra, se convierte en 24; 24 no se encuentra.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 no se encuentra, original permanece 4.",
      "arb": "اكتب دالة Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` لحل المشكلة التالية:\n\nيضاعف قيمة 'original' باستمرار إذا تم العثور عليها في المصفوفة 'nums'.\nيعيد القيمة النهائية لـ 'original' بعد تكرار هذه العملية.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // تم العثور على 3، تصبح 6؛ تم العثور على 6، تصبح 12؛ تم العثور على 12، تصبح 24؛ 24 لم يتم العثور عليها.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 لم يتم العثور عليها، تبقى original كما هي 4.",
      "sw": "Andika kazi ya Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` kutatua tatizo lifuatalo:\n\nInazidisha mara mbili thamani ya 'original' endapo inapatikana kwenye orodha 'nums'.\nInarejesha thamani ya mwisho ya 'original' baada ya kurudia mchakato huu.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 inapatikana, inakuwa 6; 6 inapatikana, inakuwa 12; 12 inapatikana, inakuwa 24; 24 haipatikani.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 haipatikani, original inabaki 4.",
      "tr": "Bir Swift fonksiyonu `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\n\n'Eğer 'original' değeri 'nums' dizisinde bulunursa, sürekli olarak 'original' değerini iki katına çıkarır.\nBu işlemi tekrarladıktan sonra 'original' değerinin son halini döndürür.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 bulundu, 6 oldu; 6 bulundu, 12 oldu; 12 bulundu, 24 oldu; 24 bulunamadı.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 bulunamadı, original 4 olarak kaldı.",
      "vi": "Viết một hàm Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` để giải quyết vấn đề sau:\n\nLiên tục nhân đôi giá trị của 'original' nếu nó được tìm thấy trong mảng 'nums'.\nTrả về giá trị cuối cùng của 'original' sau khi lặp lại quá trình này.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 được tìm thấy, trở thành 6; 6 được tìm thấy, trở thành 12; 12 được tìm thấy, trở thành 24; 24 không được tìm thấy.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 không được tìm thấy, original vẫn là 4."
    },
    "instruction_bertscore": {
      "es": "0.9895699186918581",
      "arb": "0.9949641239496225",
      "sw": "0.9862776201262048",
      "tr": "0.9318350189883522",
      "vi": "0.9956495973945739"
    },
    "level": "easy",
    "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)",
    "entry_point": "findFinalValue",
    "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {",
    "docstring": {
      "en": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n",
      "es": "Duplica continuamente el valor de 'original' si se encuentra en el array 'nums'.\nDevuelve el valor final de 'original' después de repetir este proceso.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 se encuentra, se convierte en 6; 6 se encuentra, se convierte en 12; 12 se encuentra, se convierte en 24; 24 no se encuentra.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 no se encuentra, original permanece 4.",
      "arb": "يضاعف باستمرار قيمة 'original' إذا تم العثور عليها في المصفوفة 'nums'.  \nيعيد القيمة النهائية لـ 'original' بعد تكرار هذه العملية.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // تم العثور على 3، تصبح 6؛ تم العثور على 6، تصبح 12؛ تم العثور على 12، تصبح 24؛ لم يتم العثور على 24.\n>>> findFinalValue([2, 7, 9], 4)\n4 // لم يتم العثور على 4، تبقى original كما هي 4.",
      "sw": "Inazidisha mara mbili thamani ya 'original' endapo inapatikana katika safu 'nums'.\nInarejesha thamani ya mwisho ya 'original' baada ya kurudia mchakato huu.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 inapatikana, inakuwa 6; 6 inapatikana, inakuwa 12; 12 inapatikana, inakuwa 24; 24 haipatikani.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 haipatikani, original inabaki 4.",
      "tr": "Sürekli olarak 'original' değerini, 'nums' dizisinde bulunursa iki katına çıkarır.\nBu işlemi tekrarladıktan sonra 'original' değerinin son halini döndürür.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 bulundu, 6 oldu; 6 bulundu, 12 oldu; 12 bulundu, 24 oldu; 24 bulunamadı.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 bulunamadı, original 4 olarak kalır.",
      "vi": "Liên tục nhân đôi giá trị của 'original' nếu nó được tìm thấy trong mảng 'nums'.  \nTrả về giá trị cuối cùng của 'original' sau khi lặp lại quá trình này.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 được tìm thấy, trở thành 6; 6 được tìm thấy, trở thành 12; 12 được tìm thấy, trở thành 24; 24 không được tìm thấy.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 không được tìm thấy, original vẫn là 4."
    },
    "docstring_bertscore": {
      "es": "0.9930783271120772",
      "arb": "0.9775770135457336",
      "sw": "0.9851853516608939",
      "tr": "0.9407159819548031",
      "vi": "0.9930783271120772"
    }
  },
  {
    "task_id": "Swift/8",
    "prompt": {
      "en": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "es": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReordena el array 'nums' ordenando los índices impares en orden no creciente y los índices pares en orden no decreciente.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Índices pares (0, 2) ordenados como [2, 4], índices impares (1, 3) ordenados como [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "arb": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nإعادة ترتيب المصفوفة 'nums' عن طريق ترتيب الفهارس الفردية بترتيب غير متزايد والفهارس الزوجية بترتيب غير تناقصي.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // الفهارس الزوجية (0, 2) مرتبة كـ [2, 4]، الفهارس الفردية (1, 3) مرتبة كـ [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "sw": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nHupanga upya safu 'nums' kwa kupanga faharasa za nambari zisizo za kawaida kwa mpangilio usiopungua na faharasa za nambari za kawaida kwa mpangilio usiopungua.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Faharasa za kawaida (0, 2) zimepangwa kama [2, 4], faharasa zisizo za kawaida (1, 3) zimepangwa kama [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "tr": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\n'nums' dizisini, tek indeksleri azalan düzende ve çift indeksleri artan düzende sıralayarak yeniden düzenler.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Çift indeksler (0, 2) [2, 4] olarak sıralanır, tek indeksler (1, 3) [3, 1] olarak sıralanır.\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "vi": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nSắp xếp lại mảng 'nums' bằng cách sắp xếp các chỉ số lẻ theo thứ tự không tăng và các chỉ số chẵn theo thứ tự không giảm.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Chỉ số chẵn (0, 2) được sắp xếp thành [2, 4], chỉ số lẻ (1, 3) được sắp xếp thành [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9899256657042915",
      "arb": "0.9884915543532196",
      "sw": "0.9635682086624859",
      "tr": "0.9505086583702042",
      "vi": "0.9743943589504115"
    },
    "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}",
    "instruction": {
      "en": "Write a Swift function `func reorderArray(_ nums: [Int]) -> [Int] {` to solve the following problem:\n\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n",
      "es": "Escribe una función Swift `func reorderArray(_ nums: [Int]) -> [Int] {` para resolver el siguiente problema:\n\nReordena el array 'nums' ordenando los índices impares en orden no creciente y los índices pares en orden no decreciente.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Índices pares (0, 2) ordenados como [2, 4], índices impares (1, 3) ordenados como [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "arb": "اكتب دالة Swift `func reorderArray(_ nums: [Int]) -> [Int] {` لحل المشكلة التالية:\n\nإعادة ترتيب المصفوفة 'nums' عن طريق ترتيب الفهارس الفردية بترتيب غير متزايد والفهارس الزوجية بترتيب غير تناقصي.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // الفهارس الزوجية (0, 2) مرتبة كـ [2, 4]، الفهارس الفردية (1, 3) مرتبة كـ [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "sw": "Andika kazi ya Swift `func reorderArray(_ nums: [Int]) -> [Int] {` kutatua tatizo lifuatalo:\n\nPanga upya safu 'nums' kwa kupanga faharasa za nambari zisizo za kawaida kwa mpangilio usiopungua na faharasa za nambari za kawaida kwa mpangilio usiopungua.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Faharasa za kawaida (0, 2) zimepangwa kama [2, 4], faharasa zisizo za kawaida (1, 3) zimepangwa kama [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "tr": "Bir Swift fonksiyonu `func reorderArray(_ nums: [Int]) -> [Int] {` yazın:\n\nDizi 'nums'u, tek indeksleri azalan düzende ve çift indeksleri artan düzende sıralayarak yeniden düzenler.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Çift indeksler (0, 2) [2, 4] olarak sıralandı, tek indeksler (1, 3) [3, 1] olarak sıralandı.\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "vi": "Viết một hàm Swift `func reorderArray(_ nums: [Int]) -> [Int] {` để giải quyết vấn đề sau:\n\nSắp xếp lại mảng 'nums' bằng cách sắp xếp các chỉ số lẻ theo thứ tự không tăng và các chỉ số chẵn theo thứ tự không giảm.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Các chỉ số chẵn (0, 2) được sắp xếp thành [2, 4], các chỉ số lẻ (1, 3) được sắp xếp thành [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]"
    },
    "instruction_bertscore": {
      "es": "0.9882770335417019",
      "arb": "0.9882770335417019",
      "sw": "0.9628358584476103",
      "tr": "0.9535365798987",
      "vi": "0.9754522643598034"
    },
    "level": "middle",
    "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)",
    "entry_point": "reorderArray",
    "signature": "func reorderArray(_ nums: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n",
      "es": "Reordena el array 'nums' ordenando los índices impares en orden no creciente y los índices pares en orden no decreciente.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Índices pares (0, 2) ordenados como [2, 4], índices impares (1, 3) ordenados como [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "arb": "يعيد ترتيب المصفوفة 'nums' عن طريق فرز الفهارس الفردية بترتيب غير متزايد والفهارس الزوجية بترتيب غير تناقصي.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // الفهارس الزوجية (0, 2) مرتبة كـ [2, 4]، الفهارس الفردية (1, 3) مرتبة كـ [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "sw": "Inapangilia upya safu 'nums' kwa kupanga faharasa za nambari zisizo za kawaida kwa mpangilio usiopungua na faharasa za nambari za kawaida kwa mpangilio usiopanda.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Faharasa za kawaida (0, 2) zimepangwa kama [2, 4], faharasa zisizo za kawaida (1, 3) zimepangwa kama [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "tr": "Diziyi 'nums', tek indeksleri azalmayan sırada ve çift indeksleri artmayan sırada sıralayarak yeniden düzenler.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Çift indeksler (0, 2) [2, 4] olarak sıralandı, tek indeksler (1, 3) [3, 1] olarak sıralandı.\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "vi": "Sắp xếp lại mảng 'nums' bằng cách sắp xếp các chỉ số lẻ theo thứ tự không tăng và các chỉ số chẵn theo thứ tự không giảm.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Các chỉ số chẵn (0, 2) được sắp xếp thành [2, 4], các chỉ số lẻ (1, 3) được sắp xếp thành [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]"
    },
    "docstring_bertscore": {
      "es": "0.9846132961635135",
      "arb": "0.9804017361944307",
      "sw": "0.9567774331956652",
      "tr": "0.9846420975687635",
      "vi": "0.960152163369448"
    }
  },
  {
    "task_id": "Swift/9",
    "prompt": {
      "en": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/",
      "es": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCuenta el número de pares (i, j) en el array 'nums' donde nums[i] == nums[j] y (i * j) es divisible por 'k'.\nCondiciones: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Los pares (0, 3) satisfacen las condiciones.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Todos los pares satisfacen las condiciones ya que cada (i * j) es divisible por 1.\n*/",
      "arb": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nيحسب عدد الأزواج (i, j) في المصفوفة 'nums' حيث nums[i] == nums[j] و (i * j) قابل للقسمة على 'k'.\nالشروط: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // الأزواج (0, 3) تحقق الشروط.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // جميع الأزواج تحقق الشروط لأن كل (i * j) قابل للقسمة على 1.\n*/",
      "sw": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nInahesabu idadi ya jozi (i, j) katika safu 'nums' ambapo nums[i] == nums[j] na (i * j) inagawanyika kwa 'k'.\nMasharti: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Jozi (0, 3) inakidhi masharti.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Jozi zote zinakidhi masharti kwa kuwa kila (i * j) inagawanyika kwa 1.\n*/",
      "tr": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nDizideki 'nums' içinde nums[i] == nums[j] ve (i * j) 'k' ile bölünebilir olduğunda çiftlerin (i, j) sayısını sayar.\nKoşullar: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftler (0, 3) koşulları sağlar.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tüm çiftler koşulları sağlar çünkü her (i * j) 1'e bölünebilir.\n*/",
      "vi": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nĐếm số cặp (i, j) trong mảng 'nums' sao cho nums[i] == nums[j] và (i * j) chia hết cho 'k'.\nĐiều kiện: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Cặp (0, 3) thỏa mãn điều kiện.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tất cả các cặp đều thỏa mãn điều kiện vì mọi (i * j) đều chia hết cho 1.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9879800811220548",
      "arb": "0.9812993468863274",
      "sw": "0.9864476477323706",
      "tr": "0.9876749848567852",
      "vi": "0.9788532137438827"
    },
    "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}",
    "instruction": {
      "en": "Write a Swift function `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` to solve the following problem:\n\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n",
      "es": "Escribe una función de Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` para resolver el siguiente problema:\n\nCuenta el número de pares (i, j) en el arreglo 'nums' donde nums[i] == nums[j] y (i * j) es divisible por 'k'.\nCondiciones: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Los pares (0, 3) satisfacen las condiciones.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Todos los pares satisfacen las condiciones ya que cada (i * j) es divisible por 1.",
      "arb": "اكتب دالة Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` لحل المشكلة التالية:\n\nتحسب عدد الأزواج (i, j) في المصفوفة 'nums' حيث nums[i] == nums[j] و(i * j) قابل للقسمة على 'k'.\nالشروط: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // الأزواج (0, 3) تحقق الشروط.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // جميع الأزواج تحقق الشروط لأن كل (i * j) قابل للقسمة على 1.",
      "sw": "Andika kazi ya Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya jozi (i, j) katika safu 'nums' ambapo nums[i] == nums[j] na (i * j) inagawanyika kwa 'k'.\nMasharti: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Jozi (0, 3) inakidhi masharti.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Jozi zote zinakidhi masharti kwa kuwa kila (i * j) inagawanyika kwa 1.",
      "tr": "Bir Swift fonksiyonu `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nDizideki 'nums' üzerinde nums[i] == nums[j] ve (i * j) 'k' ile bölünebilir olan çiftlerin (i, j) sayısını sayar.\nKoşullar: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // (0, 3) çiftleri koşulları sağlar.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tüm çiftler koşulları sağlar çünkü her (i * j) 1 ile bölünebilir.",
      "vi": "Viết một hàm Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` để giải quyết vấn đề sau:\n\nĐếm số lượng cặp (i, j) trong mảng 'nums' sao cho nums[i] == nums[j] và (i * j) chia hết cho 'k'.\nĐiều kiện: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Các cặp (0, 3) thỏa mãn điều kiện.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tất cả các cặp đều thỏa mãn điều kiện vì mọi (i * j) đều chia hết cho 1."
    },
    "instruction_bertscore": {
      "es": "0.9855214342656049",
      "arb": "0.9851190091136283",
      "sw": "0.9837460759199151",
      "tr": "0.98799259483606",
      "vi": "0.9802968593532443"
    },
    "level": "easy",
    "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)",
    "entry_point": "countDivisiblePairs",
    "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n",
      "es": "Cuenta el número de pares (i, j) en el array 'nums' donde nums[i] == nums[j] y (i * j) es divisible por 'k'.\nCondiciones: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Los pares (0, 3) satisfacen las condiciones.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Todos los pares satisfacen las condiciones ya que cada (i * j) es divisible por 1.",
      "arb": "يحسب عدد الأزواج (i, j) في المصفوفة 'nums' حيث nums[i] == nums[j] و (i * j) قابل للقسمة على 'k'.\nالشروط: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // الأزواج (0, 3) تحقق الشروط.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // جميع الأزواج تحقق الشروط لأن كل (i * j) قابل للقسمة على 1.",
      "sw": "Hesabu idadi ya jozi (i, j) katika safu 'nums' ambapo nums[i] == nums[j] na (i * j) inagawanyika kwa 'k'. Masharti: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Jozi (0, 3) inakidhi masharti.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Jozi zote zinakidhi masharti kwa kuwa kila (i * j) inagawanyika kwa 1.",
      "tr": "Dizideki 'nums' içinde nums[i] == nums[j] ve (i * j) 'k' ile bölünebilir olduğunda çiftlerin (i, j) sayısını sayar.\nKoşullar: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftler (0, 3) koşulları sağlar.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tüm çiftler koşulları sağlar çünkü her (i * j) 1 ile bölünebilir.",
      "vi": "Đếm số cặp (i, j) trong mảng 'nums' sao cho nums[i] == nums[j] và (i * j) chia hết cho 'k'.\nĐiều kiện: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Các cặp (0, 3) thỏa mãn điều kiện.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tất cả các cặp đều thỏa mãn điều kiện vì mọi (i * j) đều chia hết cho 1."
    },
    "docstring_bertscore": {
      "es": "0.9793549540863768",
      "arb": "0.9749316541311109",
      "sw": "0.9772306021612087",
      "tr": "0.9837937472113635",
      "vi": "0.9755501891376536"
    }
  },
  {
    "task_id": "Swift/10",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n*/",
      "es": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCuenta el número de cadenas en el arreglo 'words' que comienzan con el prefijo 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" y \"application\" comienzan con \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Solo \"hello\" comienza con \"he\".\n*/",
      "arb": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nيحسب عدد السلاسل النصية في المصفوفة 'words' التي تبدأ بالمقدمة 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"، \"app\"، و\"application\" تبدأ بـ \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // فقط \"hello\" تبدأ بـ \"he\".\n*/",
      "sw": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nInahesabu idadi ya mistari katika safu 'words' inayooanza na kiambishi 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", na \"application\" zinaanza na \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Ni \"hello\" pekee inayooanza na \"he\".\n*/",
      "tr": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nDizideki 'words' içinde 'pref' öneki ile başlayan dizelerin sayısını sayar.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" ve \"application\" \"app\" ile başlar.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sadece \"hello\" \"he\" ile başlar.\n*/",
      "vi": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nĐếm số lượng chuỗi trong mảng 'words' bắt đầu với tiền tố 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", và \"application\" bắt đầu với \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Chỉ có \"hello\" bắt đầu với \"he\".\n*/"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9928926077058097",
      "sw": "0.999999801369619",
      "tr": "0.999999801369619",
      "vi": "0.995046555557752"
    },
    "canonical_solution": "return words.filter { $0.hasPrefix(pref) }.count\n}",
    "instruction": {
      "en": "Write a Swift function `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` to solve the following problem:\n\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n",
      "es": "Escribe una función Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` para resolver el siguiente problema:\n\nCuenta el número de cadenas en el arreglo 'words' que comienzan con el prefijo 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" y \"application\" comienzan con \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Solo \"hello\" comienza con \"he\".",
      "arb": "اكتب دالة Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` لحل المشكلة التالية:\n\nتحسب عدد السلاسل النصية في المصفوفة 'words' التي تبدأ بالبادئة 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"، \"app\"، و\"application\" تبدأ بـ \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // فقط \"hello\" تبدأ بـ \"he\".",
      "sw": "Andika kazi ya Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya misururu katika safu 'words' inayooanza na kiambishi 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", na \"application\" zinaanza na \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Ni \"hello\" pekee inayooanza na \"he\".",
      "tr": "Bir Swift fonksiyonu `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` yazın:\n\n'words' dizisindeki 'pref' önekiyle başlayan dizelerin sayısını sayar.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" ve \"application\" \"app\" ile başlar.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sadece \"hello\" \"he\" ile başlar.",
      "vi": "Viết một hàm Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` để giải quyết vấn đề sau:\n\nĐếm số lượng chuỗi trong mảng 'words' bắt đầu với tiền tố 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", và \"application\" bắt đầu với \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Chỉ có \"hello\" bắt đầu với \"he\"."
    },
    "instruction_bertscore": {
      "es": "0.9919709627378077",
      "arb": "0.9911873658846251",
      "sw": "0.9943400272924109",
      "tr": "0.9635835032018256",
      "vi": "0.9943400272924109"
    },
    "level": "easy",
    "test": "func checkCountPrefixStrings(_ countPrefixStrings: ([String], String) -> Int) {\nassert(countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\") == 3)\nassert(countPrefixStrings([\"hello\", \"world\"], \"he\") == 1)\nassert(countPrefixStrings([\"python\", \"php\", \"perl\", \"java\"], \"p\") == 3)\nassert(countPrefixStrings([\"swift\", \"scala\"], \"s\") == 2)\nassert(countPrefixStrings([\"go\", \"rust\", \"ruby\"], \"c\") == 0)\nassert(countPrefixStrings([], \"test\") == 0)\nassert(countPrefixStrings([\"prefix\", \"preference\", \"preliminary\"], \"pre\") == 3)\n}\n\ncheckCountPrefixStrings(countPrefixStrings)",
    "entry_point": "countPrefixStrings",
    "signature": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n",
      "es": "Cuenta el número de cadenas en el arreglo 'words' que comienzan con el prefijo 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" y \"application\" comienzan con \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Solo \"hello\" comienza con \"he\".",
      "arb": "يحسب عدد السلاسل النصية في المصفوفة 'words' التي تبدأ بالمقطع 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"، \"app\"، و\"application\" تبدأ بـ \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // فقط \"hello\" تبدأ بـ \"he\".",
      "sw": "Inahesabu idadi ya misururu katika safu 'words' inayotangulia na kiambishi 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", na \"application\" zinaanza na \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Ni \"hello\" pekee inayotangulia na \"he\".",
      "tr": "Dizi 'words' içindeki, 'pref' öneki ile başlayan dizgilerin sayısını sayar.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" ve \"application\" \"app\" ile başlar.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sadece \"hello\" \"he\" ile başlar.",
      "vi": "Đếm số lượng chuỗi trong mảng 'words' bắt đầu với tiền tố 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", và \"application\" bắt đầu với \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Chỉ có \"hello\" bắt đầu với \"he\"."
    },
    "docstring_bertscore": {
      "es": "0.9926357786231316",
      "arb": "0.9889732330272292",
      "sw": "0.999999801369619",
      "tr": "0.999999801369619",
      "vi": "0.9926357786231316"
    }
  },
  {
    "task_id": "Swift/11",
    "prompt": {
      "en": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/",
      "es": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nElimina repetidamente un elemento de 'words' en el índice 'i' si 'words[i]' y 'words[i - 1]' son anagramas,\nhasta que no queden tales pares. Devuelve el array 'words' modificado.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" y \"dc\" se eliminan ya que son anagramas de sus elementos anteriores.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La eliminación secuencial de anagramas resulta en [\"abc\", \"bac\"], luego [\"abc\"].\n*/",
      "arb": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nيزيل بشكل متكرر عنصراً من 'words' عند الفهرس 'i' إذا كانت 'words[i]' و 'words[i - 1]' متشابهتين،\nحتى لا تبقى أي أزواج من هذا النوع. يعيد مصفوفة 'words' المعدلة.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // يتم إزالة \"ba\" و \"dc\" لأنها متشابهة مع العناصر السابقة لها.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // يؤدي الإزالة المتسلسلة للمتشابهات إلى [\"abc\", \"bac\"]، ثم [\"abc\"].\n*/",
      "sw": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nHuondoa mara kwa mara kipengele kutoka 'words' katika faharasa 'i' ikiwa 'words[i]' na 'words[i - 1]' ni anagramu,\nmpaka hakuna jozi kama hizo zilizobaki. Inarudisha safu iliyorekebishwa ya 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" na \"dc\" zinaondolewa kwa kuwa ni anagramu za vipengele vyao vya awali.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Kuondolewa kwa mfululizo wa anagramu kunasababisha [\"abc\", \"bac\"], kisha [\"abc\"].\n*/",
      "tr": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n'words' listesinden 'i' indeksindeki bir öğe, 'words[i]' ve 'words[i - 1]' anagram ise tekrar tekrar kaldırılır,\nböyle bir çift kalmayana kadar. Değiştirilmiş 'words' dizisini döndürür.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" ve \"dc\" önceki öğelerinin anagramı oldukları için kaldırılır.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Anagramların ardışık olarak kaldırılması [\"abc\", \"bac\"], ardından [\"abc\"] ile sonuçlanır.\n*/",
      "vi": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nLiên tục loại bỏ một phần tử khỏi 'words' tại chỉ số 'i' nếu 'words[i]' và 'words[i - 1]' là các từ đồng âm,\ncho đến khi không còn cặp nào như vậy. Trả về mảng 'words' đã được chỉnh sửa.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" và \"dc\" bị loại bỏ vì chúng là các từ đồng âm của các phần tử trước đó.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Loại bỏ tuần tự các từ đồng âm dẫn đến [\"abc\", \"bac\"], sau đó [\"abc\"].\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9919509010693233",
      "arb": "0.9889273494092101",
      "sw": "0.9905922692630446",
      "tr": "0.9687679547772173",
      "vi": "0.9795833790245669"
    },
    "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}",
    "instruction": {
      "en": "Write a Swift function `func removeAnagramWords(_ words: [String]) -> [String] {` to solve the following problem:\n\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n",
      "es": "Escribe una función Swift `func removeAnagramWords(_ words: [String]) -> [String] {` para resolver el siguiente problema:\n\nRepetidamente elimina un elemento de 'words' en el índice 'i' si 'words[i]' y 'words[i - 1]' son anagramas,\nhasta que no queden tales pares. Devuelve el arreglo 'words' modificado.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" y \"dc\" se eliminan ya que son anagramas de sus elementos anteriores.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La eliminación secuencial de anagramas resulta en [\"abc\", \"bac\"], luego [\"abc\"].",
      "arb": "اكتب دالة Swift `func removeAnagramWords(_ words: [String]) -> [String] {` لحل المشكلة التالية:\n\nيقوم بإزالة عنصر من 'words' عند الفهرس 'i' إذا كانت 'words[i]' و 'words[i - 1]' متشابهتين في الحروف،\nحتى لا تبقى أي أزواج من هذا النوع. يعيد مصفوفة 'words' المعدلة.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // تمت إزالة \"ba\" و \"dc\" لأنهما متشابهتان في الحروف مع العناصر السابقة لهما.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // يؤدي الإزالة المتتابعة للكلمات المتشابهة في الحروف إلى [\"abc\", \"bac\"]، ثم [\"abc\"].",
      "sw": "Andika kazi ya Swift `func removeAnagramWords(_ words: [String]) -> [String] {` kutatua tatizo lifuatalo:\n\nHuondoa mara kwa mara kipengele kutoka 'words' katika index 'i' ikiwa 'words[i]' na 'words[i - 1]' ni anagramu,\nmpaka hakuna jozi kama hizo zilizosalia. Inarudisha safu iliyobadilishwa ya 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" na \"dc\" zinaondolewa kwa kuwa ni anagramu za vipengele vyao vya awali.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Kuondolewa kwa anagramu mfululizo kunasababisha [\"abc\", \"bac\"], kisha [\"abc\"].",
      "tr": "Bir Swift fonksiyonu `func removeAnagramWords(_ words: [String]) -> [String] {` yazın ve aşağıdaki problemi çözün:\n\n'words' dizisinden 'i' indeksindeki bir elemanı, 'words[i]' ve 'words[i - 1]' anagram ise tekrar tekrar kaldırır,\nbu tür çiftler kalmayana kadar devam eder. Değiştirilmiş 'words' dizisini döndürür.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" ve \"dc\" önceki elemanlarının anagramı oldukları için kaldırılır.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Anagramların ardışık olarak kaldırılması sonucu [\"abc\", \"bac\"], ardından [\"abc\"] kalır.",
      "vi": "Viết một hàm Swift `func removeAnagramWords(_ words: [String]) -> [String] {` để giải quyết vấn đề sau:\n\nLiên tục loại bỏ một phần tử khỏi 'words' tại chỉ số 'i' nếu 'words[i]' và 'words[i - 1]' là các từ đồng âm, cho đến khi không còn cặp nào như vậy. Trả về mảng 'words' đã được sửa đổi.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" và \"dc\" bị loại bỏ vì chúng là từ đồng âm của các phần tử trước đó.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Loại bỏ tuần tự các từ đồng âm dẫn đến [\"abc\", \"bac\"], sau đó [\"abc\"]."
    },
    "instruction_bertscore": {
      "es": "0.9924876003588795",
      "arb": "0.9686714204120344",
      "sw": "0.9733932618299956",
      "tr": "0.9612883291489676",
      "vi": "0.9801270303774594"
    },
    "level": "middle",
    "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)",
    "entry_point": "removeAnagramWords",
    "signature": "func removeAnagramWords(_ words: [String]) -> [String] {",
    "docstring": {
      "en": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n",
      "es": "Elimina repetidamente un elemento de 'words' en el índice 'i' si 'words[i]' y 'words[i - 1]' son anagramas, hasta que no queden tales pares. Devuelve el array 'words' modificado.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" y \"dc\" se eliminan ya que son anagramas de sus elementos anteriores.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La eliminación secuencial de anagramas resulta en [\"abc\", \"bac\"], luego [\"abc\"].",
      "arb": "يزيل بشكل متكرر عنصرًا من 'words' عند الفهرس 'i' إذا كان 'words[i]' و 'words[i - 1]' متشابهين في ترتيب الحروف، حتى لا يتبقى أي أزواج من هذا القبيل. يعيد مصفوفة 'words' المعدلة.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // تمت إزالة \"ba\" و \"dc\" لأنها متشابهة في ترتيب الحروف مع العناصر السابقة لها.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // يؤدي الإزالة المتتابعة للمتشابهات في ترتيب الحروف إلى [\"abc\", \"bac\"]، ثم [\"abc\"].",
      "sw": "Huondoa mara kwa mara kipengele kutoka 'words' katika index 'i' ikiwa 'words[i]' na 'words[i - 1]' ni anagramu, hadi hakuna jozi kama hizo zilizobaki. Inarejesha safu iliyobadilishwa ya 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" na \"dc\" zimeondolewa kwa kuwa ni anagramu za vipengele vyao vya awali.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Kuondolewa kwa mfululizo wa anagramu kunasababisha [\"abc\", \"bac\"], kisha [\"abc\"].",
      "tr": "'words' listesinden, 'words[i]' ve 'words[i - 1]' anagram ise 'i' indeksindeki elemanı tekrar tekrar kaldırır, \nta ki böyle çiftler kalmayana kadar. Değiştirilmiş 'words' dizisini döndürür.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" ve \"dc\" önceki elemanlarının anagramı oldukları için kaldırılır.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Anagramların ardışık olarak kaldırılması [\"abc\", \"bac\"], ardından [\"abc\"] ile sonuçlanır.",
      "vi": "Liên tục loại bỏ một phần tử khỏi 'words' tại chỉ số 'i' nếu 'words[i]' và 'words[i - 1]' là các từ đồng âm, cho đến khi không còn cặp nào như vậy. Trả về mảng 'words' đã được sửa đổi.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" và \"dc\" bị loại bỏ vì chúng là từ đồng âm của các phần tử trước đó.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Loại bỏ liên tiếp các từ đồng âm dẫn đến [\"abc\", \"bac\"], sau đó [\"abc\"]."
    },
    "docstring_bertscore": {
      "es": "0.9879367796989892",
      "arb": "0.9405469475005425",
      "sw": "0.970462867818588",
      "tr": "0.9554297260603435",
      "vi": "0.9709872520245201"
    }
  },
  {
    "task_id": "Swift/12",
    "prompt": {
      "en": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/",
      "es": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nEncuentra el entero 'target' que aparece con más frecuencia inmediatamente después del 'key' especificado en el arreglo 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // El número 2 aparece dos veces después del 1, más frecuentemente que cualquier otro número.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // El número 1 aparece una vez después del 1, que es el más frecuente.\n*/",
      "arb": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nيعثر على العدد الصحيح 'target' الذي يظهر بشكل متكرر مباشرة بعد 'key' المحدد في المصفوفة 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // يظهر الرقم 2 مرتين بعد 1، بشكل أكثر تكرارًا من أي رقم آخر.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // يظهر الرقم 1 مرة واحدة بعد 1، وهو الأكثر تكرارًا.\n*/",
      "sw": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nInapata nambari 'target' ambayo inaonekana mara nyingi mara moja baada ya 'key' maalum katika safu 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Nambari 2 inaonekana mara mbili baada ya 1, mara nyingi zaidi kuliko nambari nyingine yoyote.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Nambari 1 inaonekana mara moja baada ya 1, ambayo ndiyo mara nyingi zaidi.\n*/",
      "tr": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nDizideki 'key' belirtilen öğeden hemen sonra en sık görünen 'target' tamsayısını bulur.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 1'den sonra 2 sayısı iki kez görünür, diğer sayılardan daha sık.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 1'den sonra 1 sayısı bir kez görünür, bu en sık olanıdır.\n*/",
      "vi": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nTìm số nguyên 'target' xuất hiện thường xuyên nhất ngay sau 'key' được chỉ định trong mảng 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Số 2 xuất hiện hai lần sau 1, thường xuyên hơn bất kỳ số nào khác.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Số 1 xuất hiện một lần sau 1, đây là số xuất hiện nhiều nhất.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9992896977574193",
      "arb": "0.9936166154446818",
      "sw": "0.9801804619499578",
      "tr": "0.9685172832363512",
      "vi": "0.9871466280432324"
    },
    "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}",
    "instruction": {
      "en": "Write a Swift function `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` to solve the following problem:\n\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n",
      "es": "Escribe una función Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` para resolver el siguiente problema:\n\nEncuentra el entero 'target' que aparece con mayor frecuencia inmediatamente después del 'key' especificado en el array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // El número 2 aparece dos veces después del 1, más frecuentemente que cualquier otro número.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // El número 1 aparece una vez después del 1, que es el más frecuente.",
      "arb": "اكتب دالة في لغة Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` لحل المشكلة التالية:\n\nتجد العدد الصحيح 'target' الذي يظهر بشكل متكرر مباشرة بعد 'key' المحدد في المصفوفة 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // يظهر الرقم 2 مرتين بعد 1، بشكل أكثر تكرارًا من أي رقم آخر.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // يظهر الرقم 1 مرة واحدة بعد 1، وهو الأكثر تكرارًا.",
      "sw": "Andika kazi ya Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` kutatua tatizo lifuatalo:\n\nInapata namba 'target' ambayo inaonekana mara nyingi zaidi mara moja baada ya 'key' iliyotajwa katika safu 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Namba 2 inaonekana mara mbili baada ya 1, mara nyingi zaidi kuliko namba nyingine yoyote.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Namba 1 inaonekana mara moja baada ya 1, ambayo ndiyo mara nyingi zaidi.",
      "tr": "Bir Swift fonksiyonu `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` yazarak aşağıdaki problemi çözün:\n\n'Nums' dizisinde belirtilen 'key'den hemen sonra en sık görünen 'target' tam sayısını bulur.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 1'den sonra 2 sayısı iki kez görünür, diğer sayılardan daha sık.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 1'den sonra 1 sayısı bir kez görünür, bu en sık olanıdır.",
      "vi": "Viết một hàm Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` để giải quyết vấn đề sau:\n\nTìm số nguyên 'target' xuất hiện thường xuyên nhất ngay sau 'key' được chỉ định trong mảng 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Số 2 xuất hiện hai lần sau 1, thường xuyên hơn bất kỳ số nào khác.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Số 1 xuất hiện một lần sau 1, là số xuất hiện thường xuyên nhất."
    },
    "instruction_bertscore": {
      "es": "0.9952716037794644",
      "arb": "0.9888171095477358",
      "sw": "0.9867525453672592",
      "tr": "0.9743701260439253",
      "vi": "0.9899548643703037"
    },
    "level": "hard",
    "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)",
    "entry_point": "mostFrequentTargetAfterKey",
    "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {",
    "docstring": {
      "en": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n",
      "es": "Encuentra el entero 'target' que aparece con mayor frecuencia inmediatamente después del 'key' especificado en el array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // El número 2 aparece dos veces después del 1, más frecuentemente que cualquier otro número.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // El número 1 aparece una vez después del 1, que es el más frecuente.",
      "arb": "يجد العدد الصحيح 'target' الذي يظهر بشكل متكرر مباشرة بعد 'key' المحدد في المصفوفة 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // يظهر الرقم 2 مرتين بعد 1، بشكل أكثر تكرارًا من أي رقم آخر.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // يظهر الرقم 1 مرة واحدة بعد 1، وهو الأكثر تكرارًا.",
      "sw": "Inapata nambari nzima 'target' inayojitokeza mara nyingi zaidi mara moja baada ya 'key' maalum katika safu 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Nambari 2 inaonekana mara mbili baada ya 1, mara nyingi zaidi kuliko nambari nyingine yoyote.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Nambari 1 inaonekana mara moja baada ya 1, ambayo ndiyo mara nyingi zaidi.",
      "tr": "Belirtilen 'key' değerinden hemen sonra dizide en sık görünen 'target' tamsayısını bulur.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 2 sayısı, 1'den sonra iki kez görünür, diğer sayılardan daha sık.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 1 sayısı, 1'den sonra bir kez görünür ve en sık olanıdır.",
      "vi": "Tìm số nguyên 'target' xuất hiện thường xuyên nhất ngay sau 'key' được chỉ định trong mảng 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Số 2 xuất hiện hai lần sau 1, thường xuyên hơn bất kỳ số nào khác.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Số 1 xuất hiện một lần sau 1, đây là số xuất hiện nhiều nhất."
    },
    "docstring_bertscore": {
      "es": "0.9920345244597389",
      "arb": "0.9851768105545095",
      "sw": "0.9859115443339574",
      "tr": "0.9428963476474231",
      "vi": "0.9805312432028654"
    }
  },
  {
    "task_id": "Swift/13",
    "prompt": {
      "en": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/",
      "es": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nDevuelve una lista ordenada de todos los índices de vecinos cercanos K en el array 'nums'.\nUn índice i de vecino cercano K satisface al menos un índice j tal que |i - j| <= k y nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Cada índice está dentro de 2 pasos de un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Los índices 1, 2, 3 están dentro de 1 paso de un '3'.\n*/",
      "arb": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nيعيد قائمة مرتبة لجميع مؤشرات الجيران القريبة K في المصفوفة 'nums'.\nمؤشر الجار القريب K i يلبي على الأقل مؤشر واحد j بحيث |i - j| <= k و nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // كل مؤشر يقع ضمن خطوتين من '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // المؤشرات 1، 2، 3 تقع ضمن خطوة واحدة من '3'.\n*/",
      "sw": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nInarudisha orodha iliyopangwa ya faharasa zote za majirani wa karibu K katika safu 'nums'.\nFaharasa ya jirani wa karibu K i inakidhi angalau faharasa moja j kama |i - j| <= k na nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kila faharasa iko ndani ya hatua 2 za '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Faharasa 1, 2, 3 ziko ndani ya hatua 1 ya '3'.\n*/",
      "tr": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nDizideki tüm K yakın komşu indekslerinin sıralı bir listesini döndürür.\nBir K yakın komşu indeksi i, |i - j| <= k ve nums[j] == key olan en az bir j indeksi sağlar.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Her bir indeks bir '2'ye 2 adım mesafededir.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // İndeksler 1, 2, 3 bir '3'e 1 adım mesafededir.\n*/",
      "vi": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nTrả về một danh sách đã sắp xếp của tất cả các chỉ số hàng xóm gần K trong mảng 'nums'.\nMột chỉ số hàng xóm gần K i thỏa mãn ít nhất một chỉ số j sao cho |i - j| <= k và nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Mỗi chỉ số nằm trong 2 bước của một '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Các chỉ số 1, 2, 3 nằm trong 1 bước của một '3'.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9777091027491217",
      "arb": "0.9825749511933334",
      "sw": "0.976588827400085",
      "tr": "0.9728263707225221",
      "vi": "0.9630487902160797"
    },
    "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}",
    "instruction": {
      "en": "Write a Swift function `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` to solve the following problem:\n\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n",
      "es": "Escribe una función Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` para resolver el siguiente problema:\n\nDevuelve una lista ordenada de todos los índices de vecinos cercanos K en el arreglo 'nums'.\nUn índice de vecino cercano K i satisface al menos un índice j tal que |i - j| <= k y nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Cada índice está dentro de 2 pasos de un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Los índices 1, 2, 3 están dentro de 1 paso de un '3'.",
      "arb": "اكتب دالة Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` لحل المشكلة التالية:\n\nتعيد قائمة مرتبة لجميع مؤشرات الجيران القريبة K في المصفوفة 'nums'.\nمؤشر الجار القريب K i يحقق على الأقل مؤشر واحد j بحيث |i - j| <= k و nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // كل مؤشر يقع ضمن خطوتين من '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // المؤشرات 1، 2، 3 تقع ضمن خطوة واحدة من '3'.",
      "sw": "Andika kazi ya Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` kutatua tatizo lifuatalo:\n\nInarudisha orodha iliyopangwa ya viashiria vyote vya majirani wa karibu K katika safu 'nums'.\nKiashiria cha jirani wa karibu K i kinakidhi angalau kiashiria kimoja j ambapo |i - j| <= k na nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kila kiashiria kiko ndani ya hatua 2 za '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Viashiria 1, 2, 3 viko ndani ya hatua 1 ya '3'.",
      "tr": "Bir Swift fonksiyonu `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` yazarak aşağıdaki problemi çözün:\n\nDizideki 'nums' içinde tüm K yakın komşu indekslerinin sıralanmış bir listesini döndürür.\nBir K yakın komşu indeksi i, |i - j| <= k ve nums[j] == key koşulunu sağlayan en az bir j indeksi için geçerlidir.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Her bir indeks bir '2'ye 2 adım mesafededir.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // İndeksler 1, 2, 3 bir '3'e 1 adım mesafededir.",
      "vi": "Viết một hàm Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` để giải quyết vấn đề sau:\n\nTrả về một danh sách đã sắp xếp của tất cả các chỉ số láng giềng gần K trong mảng 'nums'. \nMột chỉ số láng giềng gần K i thỏa mãn ít nhất một chỉ số j sao cho |i - j| <= k và nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Mỗi chỉ số nằm trong 2 bước của một '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Các chỉ số 1, 2, 3 nằm trong 1 bước của một '3'."
    },
    "instruction_bertscore": {
      "es": "0.9977564698462109",
      "arb": "0.9917477021895246",
      "sw": "0.9641841614740752",
      "tr": "0.9704199636562845",
      "vi": "0.9640486955542094"
    },
    "level": "middle",
    "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)",
    "entry_point": "kCloseNeighbors",
    "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {",
    "docstring": {
      "en": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n",
      "es": "Devuelve una lista ordenada de todos los índices de vecinos cercanos K en el array 'nums'.  \nUn índice i de vecino cercano K satisface al menos un índice j tal que |i - j| <= k y nums[j] == key.  \n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)  \n[0, 1, 2, 3, 4, 5, 6] // Cada índice está a 2 pasos de un '2'.  \n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)  \n[1, 2, 3] // Los índices 1, 2, 3 están a 1 paso de un '3'.  ",
      "arb": "يعيد قائمة مرتبة تحتوي على جميع مؤشرات الجيران القريبة K في المصفوفة 'nums'.\nمؤشر الجار القريب K i يحقق على الأقل مؤشر واحد j بحيث أن |i - j| <= k و nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // كل مؤشر يقع ضمن خطوتين من '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // المؤشرات 1، 2، 3 تقع ضمن خطوة واحدة من '3'.",
      "sw": "Inarudisha orodha iliyopangwa ya faharasa zote za majirani wa karibu K katika safu 'nums'. \nFaharasa ya jirani wa karibu K i inakidhi angalau faharasa moja j kama |i - j| <= k na nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kila faharasa iko ndani ya hatua 2 za '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Faharasa 1, 2, 3 ziko ndani ya hatua 1 ya '3'.",
      "tr": "Dizideki 'nums' içinde K yakın komşu indekslerinin sıralı bir listesini döndürür.\nBir K yakın komşu indeksi i, |i - j| <= k ve nums[j] == key olacak şekilde en az bir j indeksi sağlar.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Her bir indeks bir '2'ye 2 adım mesafededir.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // İndeksler 1, 2, 3 bir '3'e 1 adım mesafededir.",
      "vi": "Trả về một danh sách đã sắp xếp của tất cả các chỉ số hàng xóm gần K trong mảng 'nums'.\nMột chỉ số hàng xóm gần K i thỏa mãn ít nhất một chỉ số j sao cho |i - j| <= k và nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Mỗi chỉ số nằm trong 2 bước của một '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Các chỉ số 1, 2, 3 nằm trong 1 bước của một '3'."
    },
    "docstring_bertscore": {
      "es": "0.9541066490922702",
      "arb": "0.9680612278814952",
      "sw": "0.9542534369438549",
      "tr": "0.9707993476840611",
      "vi": "0.9556937058367388"
    }
  },
  {
    "task_id": "Swift/14",
    "prompt": {
      "en": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/",
      "es": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermina si el arreglo 'nums' se puede dividir en pares de manera que cada par consista en elementos iguales.\nCada elemento debe pertenecer exactamente a un par.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Se puede dividir en pares (1,1) y (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // No se pueden formar pares con elementos iguales.\n*/",
      "arb": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nيحدد ما إذا كان يمكن تقسيم المصفوفة 'nums' إلى أزواج بحيث يتكون كل زوج من عناصر متساوية.\nيجب أن ينتمي كل عنصر إلى زوج واحد فقط.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // يمكن تقسيمها إلى أزواج (1,1) و (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // لا يمكن تشكيل أزواج بعناصر متساوية.\n*/",
      "sw": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nHuamua kama safu 'nums' inaweza kugawanywa katika jozi ambapo kila jozi inajumuisha vipengele sawa.\nKila kipengele lazima kiwe sehemu ya jozi moja tu.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Inaweza kugawanywa katika jozi (1,1) na (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Haiwezi kuunda jozi zenye vipengele sawa.\n*/",
      "tr": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDizinin 'nums' her biri eşit elemanlardan oluşan çiftlere bölünüp bölünemeyeceğini belirler.\nHer eleman tam olarak bir çifte ait olmalıdır.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // (1,1) ve (2,2) çiftlerine bölünebilir.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Eşit elemanlarla çiftler oluşturulamaz.\n*/",
      "vi": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nXác định xem mảng 'nums' có thể được chia thành các cặp sao cho mỗi cặp bao gồm các phần tử bằng nhau hay không.\nMỗi phần tử phải thuộc về chính xác một cặp.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Có thể được chia thành các cặp (1,1) và (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Không thể tạo thành các cặp với các phần tử bằng nhau.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9992130264303398",
      "arb": "1",
      "sw": "0.9823947934377347",
      "tr": "0.9674144873608456",
      "vi": "0.993970574783686"
    },
    "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}",
    "instruction": {
      "en": "Write a Swift function `func canFormPairs(_ nums: [Int]) -> Bool {` to solve the following problem:\n\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n",
      "es": "Escribe una función Swift `func canFormPairs(_ nums: [Int]) -> Bool {` para resolver el siguiente problema:\n\nDetermina si el array 'nums' se puede dividir en pares de tal manera que cada par consista en elementos iguales.\nCada elemento debe pertenecer exactamente a un par.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Se puede dividir en pares (1,1) y (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // No se pueden formar pares con elementos iguales.",
      "arb": "اكتب دالة Swift `func canFormPairs(_ nums: [Int]) -> Bool {` لحل المشكلة التالية:\n\nتحديد ما إذا كان يمكن تقسيم المصفوفة 'nums' إلى أزواج بحيث يتكون كل زوج من عناصر متساوية.\nيجب أن ينتمي كل عنصر إلى زوج واحد فقط.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // يمكن تقسيمها إلى أزواج (1,1) و (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // لا يمكن تكوين أزواج بعناصر متساوية.",
      "sw": "Andika kazi ya Swift `func canFormPairs(_ nums: [Int]) -> Bool {` kutatua tatizo lifuatalo:\n\nInabainisha kama safu 'nums' inaweza kugawanywa katika jozi ili kila jozi iwe na vipengele sawa.\nKila kipengele lazima kiwe katika jozi moja tu.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Inaweza kugawanywa katika jozi (1,1) na (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Haiwezi kuunda jozi zenye vipengele sawa.",
      "tr": "Bir Swift fonksiyonu `func canFormPairs(_ nums: [Int]) -> Bool {` yazın ve aşağıdaki problemi çözün:\n\n'nums' dizisinin her biri eşit elemanlardan oluşan çiftlere bölünüp bölünemeyeceğini belirler.\nHer eleman tam olarak bir çifte ait olmalıdır.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // (1,1) ve (2,2) çiftlerine bölünebilir.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Eşit elemanlarla çiftler oluşturulamaz.",
      "vi": "Viết một hàm Swift `func canFormPairs(_ nums: [Int]) -> Bool {` để giải quyết vấn đề sau:\n\nXác định xem mảng 'nums' có thể được chia thành các cặp sao cho mỗi cặp gồm các phần tử bằng nhau hay không.\nMỗi phần tử phải thuộc về chính xác một cặp.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Có thể được chia thành các cặp (1,1) và (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Không thể tạo thành các cặp với các phần tử bằng nhau."
    },
    "instruction_bertscore": {
      "es": "0.9915039827119947",
      "arb": "0.9924297989179983",
      "sw": "0.9728758296873998",
      "tr": "0.9767715673506371",
      "vi": "0.9915039827119947"
    },
    "level": "easy",
    "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)",
    "entry_point": "canFormPairs",
    "signature": "func canFormPairs(_ nums: [Int]) -> Bool {",
    "docstring": {
      "en": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n",
      "es": "Determina si el arreglo 'nums' se puede dividir en pares de manera que cada par consista en elementos iguales.  \nCada elemento debe pertenecer a exactamente un par.  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // Se puede dividir en pares (1,1) y (2,2).  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // No se pueden formar pares con elementos iguales.  ",
      "arb": "يحدد ما إذا كان يمكن تقسيم المصفوفة 'nums' إلى أزواج بحيث يتكون كل زوج من عناصر متساوية. \nيجب أن ينتمي كل عنصر إلى زوج واحد فقط.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // يمكن تقسيمها إلى أزواج (1,1) و (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // لا يمكن تشكيل أزواج بعناصر متساوية.",
      "sw": "Inabainisha kama safu 'nums' inaweza kugawanywa katika jozi ambapo kila jozi inajumuisha vipengele vilivyo sawa.\nKila kipengele lazima kiwe sehemu ya jozi moja tu.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Inaweza kugawanywa katika jozi (1,1) na (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Haiwezi kuunda jozi zenye vipengele vilivyo sawa.",
      "tr": "Dizinin 'nums', her çift eşit elemanlardan oluşacak şekilde çiftlere ayrılıp ayrılamayacağını belirler.\nHer eleman tam olarak bir çifte ait olmalıdır.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Çiftlere ayrılabilir (1,1) ve (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Eşit elemanlarla çiftler oluşturulamaz.",
      "vi": "Xác định xem mảng 'nums' có thể được chia thành các cặp sao cho mỗi cặp bao gồm các phần tử bằng nhau hay không.  \nMỗi phần tử phải thuộc về chính xác một cặp.  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // Có thể được chia thành các cặp (1,1) và (2,2).  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // Không thể tạo cặp với các phần tử bằng nhau.  "
    },
    "docstring_bertscore": {
      "es": "0.9988106012783631",
      "arb": "0.9830782805788758",
      "sw": "0.9872709706617602",
      "tr": "0.9910250848633196",
      "vi": "0.9893375211460472"
    }
  },
  {
    "task_id": "Swift/15",
    "prompt": {
      "en": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/",
      "es": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nDevuelve dos listas: una con enteros únicos en 'nums1' que no están en 'nums2', y otra con enteros únicos en 'nums2' que no están en 'nums1'.\nLos enteros en cada lista se devuelven en orden ascendente.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 es único en nums1, 4 es único en nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 son únicos en nums1; 4, 5 son únicos en nums2.\n*/",
      "arb": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nيعيد قائمتين: واحدة تحتوي على الأعداد الصحيحة الفريدة في 'nums1' غير الموجودة في 'nums2'، وأخرى تحتوي على الأعداد الصحيحة الفريدة في 'nums2' غير الموجودة في 'nums1'.\nيتم إرجاع الأعداد الصحيحة في كل قائمة بترتيب تصاعدي.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 فريد لـ nums1، 4 فريد لـ nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1، 2 فريدان لـ nums1؛ 4، 5 فريدان لـ nums2.\n*/",
      "sw": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nInarudisha orodha mbili: moja ikiwa na namba za kipekee katika 'nums1' ambazo hazipo katika 'nums2', na nyingine ikiwa na namba za kipekee katika 'nums2' ambazo hazipo katika 'nums1'.\nNamba katika kila orodha zinarudishwa kwa mpangilio wa kupanda.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ni ya kipekee kwa nums1, 4 ni ya kipekee kwa nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 ni za kipekee kwa nums1; 4, 5 ni za kipekee kwa nums2.\n*/",
      "tr": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\n'nums1' içinde olup 'nums2' içinde olmayan benzersiz tamsayılarla bir liste ve 'nums2' içinde olup 'nums1' içinde olmayan benzersiz tamsayılarla başka bir liste döndürür.\nHer listedeki tamsayılar artan sırayla döndürülür.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 için benzersizdir, 4 nums2 için benzersizdir.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 için benzersizdir; 4, 5 nums2 için benzersizdir.\n*/",
      "vi": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nTrả về hai danh sách: một danh sách với các số nguyên duy nhất trong 'nums1' không có trong 'nums2', và một danh sách khác với các số nguyên duy nhất trong 'nums2' không có trong 'nums1'.\nCác số nguyên trong mỗi danh sách được trả về theo thứ tự tăng dần.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 là duy nhất trong nums1, 4 là duy nhất trong nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 là duy nhất trong nums1; 4, 5 là duy nhất trong nums2.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9777792192736271",
      "arb": "0.9770504444056101",
      "sw": "0.9745588249059084",
      "tr": "0.9671085965740518",
      "vi": "0.976492293034902"
    },
    "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}",
    "instruction": {
      "en": "Write a Swift function `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` to solve the following problem:\n\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n",
      "es": "Escribe una función Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` para resolver el siguiente problema:\n\nDevuelve dos listas: una con enteros únicos en 'nums1' que no están en 'nums2', y otra con enteros únicos en 'nums2' que no están en 'nums1'.\nLos enteros en cada lista se devuelven en orden ascendente.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 es único en nums1, 4 es único en nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 son únicos en nums1; 4, 5 son únicos en nums2.",
      "arb": "اكتب دالة Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` لحل المشكلة التالية:\n\nتعيد قائمتين: واحدة تحتوي على الأعداد الصحيحة الفريدة في 'nums1' غير الموجودة في 'nums2'، والأخرى تحتوي على الأعداد الصحيحة الفريدة في 'nums2' غير الموجودة في 'nums1'.\nالأعداد الصحيحة في كل قائمة تُعاد بترتيب تصاعدي.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 فريد في nums1، 4 فريد في nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1، 2 فريدة في nums1؛ 4، 5 فريدة في nums2.",
      "sw": "Andika kazi ya Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` kutatua tatizo lifuatalo:\n\nInarudisha orodha mbili: moja yenye namba za kipekee katika 'nums1' ambazo hazipo katika 'nums2', na nyingine yenye namba za kipekee katika 'nums2' ambazo hazipo katika 'nums1'.\nNamba katika kila orodha zinarudishwa kwa mpangilio wa kupanda.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ni ya kipekee kwa nums1, 4 ni ya kipekee kwa nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 ni za kipekee kwa nums1; 4, 5 ni za kipekee kwa nums2.",
      "tr": "Bir Swift fonksiyonu `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` yazarak aşağıdaki problemi çözün:\n\n'nums1' içinde olup 'nums2' içinde olmayan benzersiz tamsayılarla bir liste ve 'nums2' içinde olup 'nums1' içinde olmayan benzersiz tamsayılarla başka bir liste döndürür.\nHer listedeki tamsayılar artan sırayla döndürülür.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1'e özgüdür, 4 nums2'ye özgüdür.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1'e özgüdür; 4, 5 nums2'ye özgüdür.",
      "vi": "Viết một hàm Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` để giải quyết vấn đề sau:\n\nTrả về hai danh sách: một danh sách chứa các số nguyên duy nhất trong 'nums1' mà không có trong 'nums2', và danh sách khác chứa các số nguyên duy nhất trong 'nums2' mà không có trong 'nums1'.\nCác số nguyên trong mỗi danh sách được trả về theo thứ tự tăng dần.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 là duy nhất trong nums1, 4 là duy nhất trong nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 là duy nhất trong nums1; 4, 5 là duy nhất trong nums2."
    },
    "instruction_bertscore": {
      "es": "0.9770001909192082",
      "arb": "0.9720258902869515",
      "sw": "0.9725699389006061",
      "tr": "0.9704761760541173",
      "vi": "0.9691594552582371"
    },
    "level": "easy",
    "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)",
    "entry_point": "findUniqueElements",
    "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {",
    "docstring": {
      "en": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n",
      "es": "Devuelve dos listas: una con enteros únicos en 'nums1' que no están en 'nums2', y otra con enteros únicos en 'nums2' que no están en 'nums1'.  \nLos enteros en cada lista se devuelven en orden ascendente.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 es único en nums1, 4 es único en nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 son únicos en nums1; 4, 5 son únicos en nums2.",
      "arb": "يعيد قائمتين: واحدة تحتوي على الأعداد الصحيحة الفريدة في 'nums1' غير الموجودة في 'nums2'، والأخرى تحتوي على الأعداد الصحيحة الفريدة في 'nums2' غير الموجودة في 'nums1'. يتم إرجاع الأعداد الصحيحة في كل قائمة بترتيب تصاعدي.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 فريد لـ nums1، 4 فريد لـ nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 فريدة لـ nums1; 4, 5 فريدة لـ nums2.",
      "sw": "Rudisha orodha mbili: moja ikiwa na nambari za kipekee katika 'nums1' ambazo hazipo katika 'nums2', na nyingine ikiwa na nambari za kipekee katika 'nums2' ambazo hazipo katika 'nums1'. Nambari katika kila orodha zinarudishwa kwa mpangilio wa kupanda.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ni ya kipekee kwa nums1, 4 ni ya kipekee kwa nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 ni za kipekee kwa nums1; 4, 5 ni za kipekee kwa nums2.",
      "tr": "'nums1' içinde olup 'nums2' içinde olmayan benzersiz tamsayılarla bir liste ve 'nums2' içinde olup 'nums1' içinde olmayan benzersiz tamsayılarla başka bir liste döndürür. Her listedeki tamsayılar artan sırayla döndürülür.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1, nums1'e özgüdür; 4, nums2'ye özgüdür.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1'e özgüdür; 4, 5 nums2'ye özgüdür.",
      "vi": "Trả về hai danh sách: một danh sách với các số nguyên duy nhất trong 'nums1' không có trong 'nums2', và một danh sách khác với các số nguyên duy nhất trong 'nums2' không có trong 'nums1'.  \nCác số nguyên trong mỗi danh sách được trả về theo thứ tự tăng dần.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 là duy nhất trong nums1, 4 là duy nhất trong nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 là duy nhất trong nums1; 4, 5 là duy nhất trong nums2."
    },
    "docstring_bertscore": {
      "es": "0.9747099826258759",
      "arb": "0.9736465155658152",
      "sw": "0.9682497281130973",
      "tr": "0.9648080595009058",
      "vi": "0.9733271179131111"
    }
  },
  {
    "task_id": "Swift/16",
    "prompt": {
      "en": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/",
      "es": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nDevuelve el número en el arreglo 'nums' que está más cerca de cero.\nSi hay múltiples números así, devuelve el más grande.\n>>> closestToZero([2, -1, 1])\n1 // 1 y -1 están igualmente cerca de cero, pero 1 es más grande.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 está más cerca de cero.\n*/",
      "arb": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nيعيد الرقم في المصفوفة 'nums' الذي يكون الأقرب إلى الصفر.\nإذا كان هناك عدة أرقام كذلك، يعيد الأكبر منها.\n>>> closestToZero([2, -1, 1])\n1 // 1 و -1 متساويان في القرب من الصفر، ولكن 1 أكبر.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 هو الأقرب إلى الصفر.\n*/",
      "sw": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nInarejesha nambari katika safu 'nums' ambayo iko karibu zaidi na sifuri.\nIkiwa kuna nambari nyingi kama hizo, inarejesha kubwa zaidi.\n>>> closestToZero([2, -1, 1])\n1 // 1 na -1 ziko karibu sawa na sifuri, lakini 1 ni kubwa zaidi.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 iko karibu zaidi na sifuri.\n*/",
      "tr": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\n'nums' dizisindeki sıfıra en yakın sayıyı döndürür.\nEğer birden fazla böyle sayı varsa, en büyüğünü döndürür.\n>>> closestToZero([2, -1, 1])\n1 // 1 ve -1 sıfıra eşit derecede yakın, ancak 1 daha büyük.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 sıfıra en yakın.\n*/",
      "vi": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nTrả về số trong mảng 'nums' gần với số không nhất.\nNếu có nhiều số như vậy, trả về số lớn nhất.\n>>> closestToZero([2, -1, 1])\n1 // 1 và -1 đều gần với số không, nhưng 1 lớn hơn.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 là gần với số không nhất.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9985023269269969",
      "arb": "0.991426119602629",
      "sw": "0.9917647844022935",
      "tr": "0.9801550372611854",
      "vi": "0.9781595964533089"
    },
    "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}",
    "instruction": {
      "en": "Write a Swift function `func closestToZero(_ nums: [Int]) -> Int {` to solve the following problem:\n\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n",
      "es": "Escribe una función en Swift `func closestToZero(_ nums: [Int]) -> Int {` para resolver el siguiente problema:\n\nDevuelve el número en el arreglo 'nums' que está más cercano a cero.  \nSi hay múltiples números así, devuelve el más grande.\n>>> closestToZero([2, -1, 1])\n1 // 1 y -1 están igualmente cerca de cero, pero 1 es más grande.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 está más cercano a cero.",
      "arb": "اكتب دالة Swift `func closestToZero(_ nums: [Int]) -> Int {` لحل المشكلة التالية:\n\nتعيد الرقم في المصفوفة 'nums' الذي يكون الأقرب إلى الصفر.\nإذا كان هناك عدة أرقام متساوية في القرب من الصفر، تعيد الأكبر منها.\n>>> closestToZero([2, -1, 1])\n1 // 1 و -1 متساويان في القرب من الصفر، لكن 1 أكبر.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 هو الأقرب إلى الصفر.",
      "sw": "Andika kazi ya Swift `func closestToZero(_ nums: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nRudisha nambari katika safu 'nums' ambayo iko karibu zaidi na sifuri.\nIkiwa kuna nambari nyingi kama hizo, rudisha ile kubwa zaidi.\n>>> closestToZero([2, -1, 1])\n1 // 1 na -1 ziko karibu sawa na sifuri, lakini 1 ni kubwa zaidi.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 iko karibu zaidi na sifuri.",
      "tr": "Bir Swift fonksiyonu `func closestToZero(_ nums: [Int]) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nDizi 'nums' içindeki sıfıra en yakın sayıyı döndürür.\nEğer birden fazla böyle sayı varsa, en büyüğünü döndürür.\n>>> closestToZero([2, -1, 1])\n1 // 1 ve -1 sıfıra eşit derecede yakın, ancak 1 daha büyük.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 sıfıra en yakın.",
      "vi": "Viết một hàm Swift `func closestToZero(_ nums: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nTrả về số trong mảng 'nums' gần với số không nhất.  \nNếu có nhiều số như vậy, trả về số lớn nhất.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 và -1 đều gần với số không, nhưng 1 lớn hơn.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 gần với số không nhất.  "
    },
    "instruction_bertscore": {
      "es": "0.992769655499949",
      "arb": "0.9805151541420016",
      "sw": "0.9974615037303741",
      "tr": "0.9805880514918414",
      "vi": "0.9815857718957797"
    },
    "level": "easy",
    "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)",
    "entry_point": "closestToZero",
    "signature": "func closestToZero(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n",
      "es": "Devuelve el número en el array 'nums' que está más cercano a cero.  \nSi hay múltiples números así, devuelve el más grande.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 y -1 están igualmente cerca de cero, pero 1 es más grande.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 está más cerca de cero.  ",
      "arb": "يعيد الرقم في المصفوفة 'nums' الذي يكون الأقرب إلى الصفر.\nإذا كان هناك عدة أرقام كهذه، يعيد الأكبر منها.\n>>> closestToZero([2, -1, 1])\n1 // 1 و -1 متساويان في القرب من الصفر، لكن 1 أكبر.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 هو الأقرب إلى الصفر.",
      "sw": "Inarudisha nambari katika safu 'nums' ambayo iko karibu zaidi na sifuri. Ikiwa kuna nambari nyingi kama hizo, inarudisha kubwa zaidi.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 na -1 ziko karibu sawa na sifuri, lakini 1 ni kubwa zaidi.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 iko karibu zaidi na sifuri.  ",
      "tr": "Dizideki 'nums' içinde sıfıra en yakın olan sayıyı döndürür.  \nEğer birden fazla böyle sayı varsa, en büyüğünü döndürür.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 ve -1 sıfıra eşit derecede yakın, ama 1 daha büyük.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 sıfıra en yakın olan.  ",
      "vi": "Trả về số trong mảng 'nums' gần với số không nhất.  \nNếu có nhiều số như vậy, trả về số lớn nhất.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 và -1 đều gần với số không, nhưng 1 lớn hơn.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 gần với số không nhất.  "
    },
    "docstring_bertscore": {
      "es": "0.9895323775498425",
      "arb": "0.9955945767790272",
      "sw": "0.9888224725680237",
      "tr": "0.9717946845234269",
      "vi": "0.9677744056112808"
    }
  },
  {
    "task_id": "Swift/17",
    "prompt": {
      "en": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/",
      "es": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nDevuelve un arreglo de elementos que aparecen en todos los arreglos dentro del arreglo bidimensional 'nums'.\nCada arreglo en 'nums' consiste en enteros positivos distintos.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Solo '3' aparece en todos los arreglos.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Solo '2' aparece en todos los arreglos.\n*/",
      "arb": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nيعيد مصفوفة من العناصر التي تظهر في جميع المصفوفات داخل المصفوفة الثنائية الأبعاد 'nums'.\nكل مصفوفة في 'nums' تتكون من أعداد صحيحة موجبة ومميزة.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // يظهر فقط '3' في جميع المصفوفات.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // يظهر فقط '2' في جميع المصفوفات.\n*/",
      "sw": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nInarejesha safu ya vipengele vinavyoonekana katika safu zote ndani ya safu mbili-dimensional 'nums'.\nKila safu katika 'nums' ina nambari za kipekee zisizo hasi.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Ni '3' pekee inayoonekana katika safu zote.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Ni '2' pekee inayoonekana katika safu zote.\n*/",
      "tr": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\n'nums' içindeki iki boyutlu dizideki tüm dizilerde görünen elemanları döndüren bir dizi döndürür.\n'nums' içindeki her dizi, farklı pozitif tam sayılardan oluşur.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sadece '3' tüm dizilerde görünür.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sadece '2' tüm dizilerde görünür.\n*/",
      "vi": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nTrả về một mảng các phần tử xuất hiện trong tất cả các mảng trong mảng hai chiều 'nums'.\nMỗi mảng trong 'nums' bao gồm các số nguyên dương khác nhau.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Chỉ có '3' xuất hiện trong tất cả các mảng.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Chỉ có '2' xuất hiện trong tất cả các mảng.\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9922093191950496",
      "sw": "0.9854743588652997",
      "tr": "0.9976317299669211",
      "vi": "0.9976317299669211"
    },
    "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}",
    "instruction": {
      "en": "Write a Swift function `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` to solve the following problem:\n\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n",
      "es": "Escribe una función Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` para resolver el siguiente problema:\n\nDevuelve un arreglo de elementos que aparecen en todos los arreglos dentro del arreglo bidimensional 'nums'.\nCada arreglo en 'nums' consta de enteros positivos distintos.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Solo '3' aparece en todos los arreglos.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Solo '2' aparece en todos los arreglos.",
      "arb": "اكتب دالة Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` لحل المشكلة التالية:\n\nتعيد مصفوفة من العناصر التي تظهر في جميع المصفوفات داخل المصفوفة الثنائية الأبعاد 'nums'.\nكل مصفوفة في 'nums' تتكون من أعداد صحيحة موجبة ومتميزة.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // يظهر فقط '3' في جميع المصفوفات.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // يظهر فقط '2' في جميع المصفوفات.",
      "sw": "Andika kazi ya Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` kutatua tatizo lifuatalo:\n\nRudisha safu ya vipengele vinavyoonekana katika safu zote ndani ya safu mbili-dimensionali 'nums'.\nKila safu katika 'nums' inajumuisha nambari za kipekee zisizo hasi.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Ni '3' pekee inayojitokeza katika safu zote.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Ni '2' pekee inayojitokeza katika safu zote.",
      "tr": "Bir Swift fonksiyonu `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` yazarak aşağıdaki problemi çözün:\n\nİki boyutlu dizi 'nums' içindeki tüm dizilerde görünen elemanlardan oluşan bir dizi döndürür.\n'nums' içindeki her dizi, birbirinden farklı pozitif tam sayılardan oluşur.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sadece '3' tüm dizilerde görünür.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sadece '2' tüm dizilerde görünür.",
      "vi": "Viết một hàm Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` để giải quyết vấn đề sau:\n\nTrả về một mảng các phần tử xuất hiện trong tất cả các mảng trong mảng hai chiều 'nums'.\nMỗi mảng trong 'nums' bao gồm các số nguyên dương khác nhau.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Chỉ có '3' xuất hiện trong tất cả các mảng.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Chỉ có '2' xuất hiện trong tất cả các mảng."
    },
    "instruction_bertscore": {
      "es": "0.998929580876603",
      "arb": "0.9957393783268016",
      "sw": "0.9841465147680815",
      "tr": "0.9954038916132337",
      "vi": "0.998929580876603"
    },
    "level": "easy",
    "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)",
    "entry_point": "commonElementsInAllArrays",
    "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {",
    "docstring": {
      "en": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n",
      "es": "Devuelve un arreglo de elementos que aparecen en todos los arreglos dentro del arreglo bidimensional 'nums'.  \nCada arreglo en 'nums' consiste en enteros positivos distintos.  \n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])  \n[3] // Solo '3' aparece en todos los arreglos.  \n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])  \n[2] // Solo '2' aparece en todos los arreglos.  ",
      "arb": "يعيد مصفوفة من العناصر التي تظهر في جميع المصفوفات داخل المصفوفة ثنائية الأبعاد 'nums'. \nكل مصفوفة في 'nums' تتكون من أعداد صحيحة موجبة ومتميزة.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // يظهر فقط '3' في جميع المصفوفات.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // يظهر فقط '2' في جميع المصفوفات.",
      "sw": "Rudisha safu ya vipengele vinavyoonekana katika safu zote ndani ya safu mbili-dimensionali 'nums'. Kila safu katika 'nums' ina nambari za kipekee zisizo hasi.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Ni '3' pekee inayojitokeza katika safu zote.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Ni '2' pekee inayojitokeza katika safu zote.",
      "tr": "Tüm dizilerde görünen elemanlardan oluşan bir dizi döndürür.\n'nums' içindeki her dizi, farklı pozitif tam sayılardan oluşur.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sadece '3' tüm dizilerde görünür.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sadece '2' tüm dizilerde görünür.",
      "vi": "Trả về một mảng các phần tử xuất hiện trong tất cả các mảng trong mảng hai chiều 'nums'.  \nMỗi mảng trong 'nums' bao gồm các số nguyên dương khác nhau.  \n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])  \n[3] // Chỉ có '3' xuất hiện trong tất cả các mảng.  \n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])  \n[2] // Chỉ có '2' xuất hiện trong tất cả các mảng.  "
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9948364046146171",
      "sw": "0.9787062272619169",
      "tr": "0.9607115065224422",
      "vi": "0.9970249141528594"
    }
  },
  {
    "task_id": "Swift/18",
    "prompt": {
      "en": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/",
      "es": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nRealiza el algoritmo especificado en el arreglo 'nums' hasta que solo quede un número.\nLa longitud de 'nums' es una potencia de 2. Para índices pares, toma el mínimo de los pares; para índices impares, toma el máximo.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Número final después de aplicar repetidamente el algoritmo.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Número final después de aplicar el algoritmo.\n*/",
      "arb": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nينفذ الخوارزمية المحددة على المصفوفة 'nums' حتى يبقى رقم واحد فقط.\nطول 'nums' هو قوة العدد 2. بالنسبة للفهارس الزوجية، يتم أخذ الحد الأدنى من الأزواج؛ بالنسبة للفهارس الفردية، يتم أخذ الحد الأقصى.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // الرقم النهائي بعد تطبيق الخوارزمية بشكل متكرر.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // الرقم النهائي بعد تطبيق الخوارزمية.\n*/",
      "sw": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nInafanya algoriti maalum kwenye safu 'nums' hadi namba moja tu ibaki.\nUrefu wa 'nums' ni nguvu ya 2. Kwa faharasa za jozi, chukua kiwango cha chini cha jozi; kwa faharasa zisizo za jozi, chukua kiwango cha juu.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Namba ya mwisho baada ya kutumia algoriti mara kwa mara.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Namba ya mwisho baada ya kutumia algoriti.\n*/",
      "tr": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\n'nums' dizisi üzerinde belirtilen algoritmayı yalnızca bir sayı kalana kadar uygular.\n'nums' dizisinin uzunluğu 2'nin bir kuvvetidir. Çift indeksler için çiftlerin minimumunu alın; tek indeksler için maksimumunu alın.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Algoritmayı tekrar tekrar uyguladıktan sonra elde edilen son sayı.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Algoritmayı uyguladıktan sonra elde edilen son sayı.\n*/",
      "vi": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nThực hiện thuật toán được chỉ định trên mảng 'nums' cho đến khi chỉ còn lại một số.\nĐộ dài của 'nums' là lũy thừa của 2. Đối với các chỉ số chẵn, lấy giá trị nhỏ nhất của các cặp; đối với các chỉ số lẻ, lấy giá trị lớn nhất.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Số cuối cùng sau khi áp dụng thuật toán nhiều lần.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Số cuối cùng sau khi áp dụng thuật toán.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9943328765986936",
      "arb": "0.9785401722633718",
      "sw": "0.9772599994576019",
      "tr": "0.9552930683581915",
      "vi": "0.9715871157752455"
    },
    "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}",
    "instruction": {
      "en": "Write a Swift function `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` to solve the following problem:\n\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n",
      "es": "Escribe una función Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` para resolver el siguiente problema:\n\nRealiza el algoritmo especificado en el arreglo 'nums' hasta que solo quede un número.\nLa longitud de 'nums' es una potencia de 2. Para los índices pares, toma el mínimo de los pares; para los índices impares, toma el máximo.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Número final después de aplicar repetidamente el algoritmo.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Número final después de aplicar el algoritmo.",
      "arb": "اكتب دالة Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` لحل المشكلة التالية:\n\nتنفذ الخوارزمية المحددة على المصفوفة 'nums' حتى يتبقى رقم واحد فقط.\nطول 'nums' هو قوة العدد 2. للمؤشرات الزوجية، خذ الحد الأدنى من الأزواج؛ للمؤشرات الفردية، خذ الحد الأقصى.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // الرقم النهائي بعد تطبيق الخوارزمية بشكل متكرر.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // الرقم النهائي بعد تطبيق الخوارزمية.",
      "sw": "Andika kazi ya Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nInatekeleza algoriti maalum kwenye safu 'nums' hadi nambari moja tu ibaki.\nUrefu wa 'nums' ni nguvu ya 2. Kwa faharasa za jozi, chukua kiwango cha chini cha jozi; kwa faharasa za witiri, chukua kiwango cha juu.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nambari ya mwisho baada ya kutumia algoriti mara kwa mara.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nambari ya mwisho baada ya kutumia algoriti.",
      "tr": "Bir Swift fonksiyonu `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` yazın ve aşağıdaki problemi çözün:\n\n'nums' dizisi üzerinde belirtilen algoritmayı sadece bir sayı kalana kadar uygular.\n'nums' uzunluğu 2'nin bir kuvvetidir. Çift indeksler için çiftlerin minimumunu alın; tek indeksler için maksimumunu alın.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Algoritmayı tekrar tekrar uyguladıktan sonra kalan son sayı.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Algoritmayı uyguladıktan sonra kalan son sayı.",
      "vi": "Viết một hàm Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nThực hiện thuật toán được chỉ định trên mảng 'nums' cho đến khi chỉ còn lại một số duy nhất.\nĐộ dài của 'nums' là lũy thừa của 2. Đối với các chỉ số chẵn, lấy giá trị nhỏ nhất của các cặp; đối với các chỉ số lẻ, lấy giá trị lớn nhất.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Số cuối cùng sau khi áp dụng thuật toán lặp đi lặp lại.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Số cuối cùng sau khi áp dụng thuật toán."
    },
    "instruction_bertscore": {
      "es": "0.9903241182486475",
      "arb": "0.9862398803538082",
      "sw": "0.978541562676039",
      "tr": "0.9703967239017034",
      "vi": "0.9764644847815571"
    },
    "level": "middle",
    "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)",
    "entry_point": "performAlgorithmOnNums",
    "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n",
      "es": "Realiza el algoritmo especificado en el array 'nums' hasta que solo quede un número.\nLa longitud de 'nums' es una potencia de 2. Para los índices pares, toma el mínimo de los pares; para los índices impares, toma el máximo.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Número final después de aplicar repetidamente el algoritmo.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Número final después de aplicar el algoritmo.",
      "arb": "ينفذ الخوارزمية المحددة على المصفوفة 'nums' حتى يتبقى رقم واحد فقط. طول 'nums' هو قوة العدد 2. بالنسبة للفهارس الزوجية، خذ الحد الأدنى من الأزواج؛ بالنسبة للفهارس الفردية، خذ الحد الأقصى.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // الرقم النهائي بعد تطبيق الخوارزمية بشكل متكرر.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // الرقم النهائي بعد تطبيق الخوارزمية.",
      "sw": "Inafanya algoriti maalum kwenye safu 'nums' hadi namba moja tu ibaki.\nUrefu wa 'nums' ni nguvu ya 2. Kwa fahirisi za namba shufwa, chukua kiwango cha chini cha jozi; kwa fahirisi za namba witiri, chukua kiwango cha juu.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Namba ya mwisho baada ya kutumia algoriti mara kwa mara.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Namba ya mwisho baada ya kutumia algoriti.",
      "tr": "Belirtilen algoritmayı 'nums' dizisi üzerinde yalnızca bir sayı kalana kadar uygular.\n'nums'un uzunluğu 2'nin bir kuvvetidir. Çift indeksler için çiftlerin minimumunu alın; tek indeksler için maksimumunu alın.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Algoritmayı tekrar tekrar uyguladıktan sonra kalan son sayı.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Algoritmayı uyguladıktan sonra kalan son sayı.",
      "vi": "Thực hiện thuật toán được chỉ định trên mảng 'nums' cho đến khi chỉ còn lại một số. \nĐộ dài của 'nums' là lũy thừa của 2. Đối với các chỉ số chẵn, lấy giá trị nhỏ nhất của các cặp; đối với các chỉ số lẻ, lấy giá trị lớn nhất.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Số cuối cùng sau khi áp dụng thuật toán lặp đi lặp lại.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Số cuối cùng sau khi áp dụng thuật toán."
    },
    "docstring_bertscore": {
      "es": "0.9932610670626294",
      "arb": "0.9771511500087947",
      "sw": "0.953172093149501",
      "tr": "0.9426154842886397",
      "vi": "0.963033694307121"
    }
  },
  {
    "task_id": "Swift/19",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n*/",
      "es": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCuenta el número de cadenas en 'words' que son prefijos de la cadena 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" y \"abc\" son prefijos de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" y \"hell\" son prefijos de \"hello\".\n*/",
      "arb": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nيحسب عدد السلاسل النصية في 'words' التي تكون بادئات للسلسلة النصية 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"، \"ab\"، و\"abc\" هي بادئات لـ \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" و\"hell\" هما بادئات لـ \"hello\".\n*/",
      "sw": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nInahesabu idadi ya maneno katika 'words' ambayo ni viambishi awali vya neno 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", na \"abc\" ni viambishi awali vya \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" na \"hell\" ni viambishi awali vya \"hello\".\n*/",
      "tr": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n'words' içindeki kaç tane stringin 's' stringinin ön eki olduğunu sayar.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" ve \"abc\" \"abc\"nin ön ekleridir.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" ve \"hell\" \"hello\"nun ön ekleridir.\n*/",
      "vi": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nĐếm số lượng chuỗi trong 'words' là tiền tố của chuỗi 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", và \"abc\" là tiền tố của \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" và \"hell\" là tiền tố của \"hello\".\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9970501402112508",
      "arb": "0.9938980746946082",
      "sw": "0.9881366018623102",
      "tr": "0.9848399334282743",
      "vi": "0.9937804855090355"
    },
    "canonical_solution": "return words.filter { s.hasPrefix($0) }.count\n}",
    "instruction": {
      "en": "Write a Swift function `func countPrefixes(_ words: [String], _ s: String) -> Int {` to solve the following problem:\n\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n",
      "es": "Escribe una función en Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` para resolver el siguiente problema:\n\nCuenta el número de cadenas en 'words' que son prefijos de la cadena 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" y \"abc\" son prefijos de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" y \"hell\" son prefijos de \"hello\".",
      "arb": "اكتب دالة Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` لحل المشكلة التالية:\n\nتحسب عدد السلاسل النصية في 'words' التي هي بادئات للسلسلة النصية 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"، \"ab\"، و\"abc\" هي بادئات لـ \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" و\"hell\" هما بادئتان لـ \"hello\".",
      "sw": "Andika kazi ya Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya mistari katika 'words' ambayo ni viambishi awali vya kamba 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", na \"abc\" ni viambishi awali vya \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" na \"hell\" ni viambishi awali vya \"hello\".",
      "tr": "Bir Swift fonksiyonu `func countPrefixes(_ words: [String], _ s: String) -> Int {` yazın ve aşağıdaki problemi çözün:\n\n's' stringinin ön eki olan 'words' içindeki stringlerin sayısını sayar.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" ve \"abc\", \"abc\"nin ön ekleridir.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" ve \"hell\", \"hello\"nun ön ekleridir.",
      "vi": "Viết một hàm Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` để giải quyết vấn đề sau:\n\nĐếm số lượng chuỗi trong 'words' là tiền tố của chuỗi 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", và \"abc\" là tiền tố của \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" và \"hell\" là tiền tố của \"hello\"."
    },
    "instruction_bertscore": {
      "es": "0.9904903718775737",
      "arb": "0.9924697236245864",
      "sw": "0.9960567896756954",
      "tr": "0.9974410448011275",
      "vi": "0.9960567896756954"
    },
    "level": "easy",
    "test": "func checkCountPrefixes(_ countPrefixes: ([String], String) -> Int) {\nassert(countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\") == 2)\nassert(countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\") == 2)\nassert(countPrefixes([\"app\", \"apple\", \"apricot\", \"ap\"], \"apple\") == 3)\nassert(countPrefixes([\"blue\", \"blues\", \"blueberry\"], \"blue\") == 1)\nassert(countPrefixes([\"no\", \"match\"], \"yes\") == 0)\nassert(countPrefixes([], \"empty\") == 0)\nassert(countPrefixes([\"full\", \"fullest\", \"ful\"], \"fullest\") == 3)\n}\n\ncheckCountPrefixes(countPrefixes)",
    "entry_point": "countPrefixes",
    "signature": "func countPrefixes(_ words: [String], _ s: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n",
      "es": "Cuenta el número de cadenas en 'words' que son prefijos de la cadena 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" y \"abc\" son prefijos de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" y \"hell\" son prefijos de \"hello\".",
      "arb": "يحسب عدد السلاسل النصية في 'words' التي هي بادئات للسلسلة النصية 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"، \"ab\"، و\"abc\" هي بادئات لـ \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" و\"hell\" هما بادئتان لـ \"hello\".",
      "sw": "Inahesabu idadi ya maneno katika 'words' ambayo ni viambishi awali vya kamba 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", na \"abc\" ni viambishi awali vya \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" na \"hell\" ni viambishi awali vya \"hello\".",
      "tr": "'words' içindeki dizgilerin 's' dizgisinin önekleri olduğu sayısını sayar.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" ve \"abc\", \"abc\"nin önekleridir.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" ve \"hell\", \"hello\"nun önekleridir.",
      "vi": "Đếm số lượng chuỗi trong 'words' là tiền tố của chuỗi 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", và \"abc\" là tiền tố của \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" và \"hell\" là tiền tố của \"hello\"."
    },
    "docstring_bertscore": {
      "es": "0.9853369066416235",
      "arb": "0.9877862178701647",
      "sw": "0.9944655616932249",
      "tr": "0.9758074154810937",
      "vi": "0.9889259589965429"
    }
  },
  {
    "task_id": "Swift/20",
    "prompt": {
      "en": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "es": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nEncuentra dos números en 'nums' cuya suma es igual a 'target', y devuelve sus índices.\nSupone que cada entrada tiene exactamente una solución, y el mismo elemento no puede usarse dos veces.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "arb": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nيجد رقمين في 'nums' يكون مجموعهما مساويًا لـ 'target'، ويعيد مؤشراتهما.\nيفترض أن كل إدخال يحتوي على حل واحد بالضبط، ولا يمكن استخدام نفس العنصر مرتين.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "sw": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nInapata namba mbili katika 'nums' ambazo jumla yao ni sawa na 'target', na inarejesha faharasa zao.\nInadhani kwamba kila ingizo lina suluhisho moja tu, na kipengele sawa hakiwezi kutumika mara mbili.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "tr": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n'nums' içinde toplamı 'target' olan iki sayıyı bulur ve bunların indekslerini döndürür.\nHer girdinin tam olarak bir çözümü olduğunu varsayar ve aynı eleman iki kez kullanılamaz.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "vi": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nTìm hai số trong 'nums' có tổng bằng 'target', và trả về chỉ số của chúng.\nGiả sử rằng mỗi đầu vào có chính xác một giải pháp, và cùng một phần tử không thể được sử dụng hai lần.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9890044179970517",
      "arb": "0.9823483139285726",
      "sw": "0.9908925983991693",
      "tr": "0.9905400294728324",
      "vi": "0.9933810398127744"
    },
    "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}",
    "instruction": {
      "en": "Write a Swift function `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` to solve the following problem:\n\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n",
      "es": "Escribe una función Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` para resolver el siguiente problema:\n\nEncuentra dos números en 'nums' cuya suma sea igual a 'target', y devuelve sus índices.\nSupone que cada entrada tiene exactamente una solución, y el mismo elemento no puede ser usado dos veces.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "arb": "اكتب دالة Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` لحل المشكلة التالية:\n\nتجد رقمين في 'nums' يكون مجموعهما يساوي 'target' وتعيد مؤشراتهما. \nتفترض أن كل إدخال له حل واحد بالضبط، ولا يمكن استخدام نفس العنصر مرتين.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "sw": "Andika kazi ya Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` kutatua tatizo lifuatalo:\n\nInapata namba mbili katika 'nums' ambazo jumla yake ni sawa na 'target', na inarudisha faharasa zao.\nInadhani kwamba kila ingizo lina suluhisho moja tu, na kipengele kilekile hakiwezi kutumika mara mbili.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "tr": "Bir Swift fonksiyonu `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` yazarak aşağıdaki problemi çözün:\n\n'nums' içinde toplamı 'target' olan iki sayıyı bulun ve bunların indekslerini döndürün.\nHer girdinin tam olarak bir çözümü olduğunu varsayar ve aynı eleman iki kez kullanılamaz.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "vi": "Viết một hàm Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` để giải quyết vấn đề sau:\n\nTìm hai số trong 'nums' có tổng bằng 'target', và trả về chỉ số của chúng. Giả sử rằng mỗi đầu vào có chính xác một giải pháp, và cùng một phần tử không thể được sử dụng hai lần.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6"
    },
    "instruction_bertscore": {
      "es": "0.9899087821219036",
      "arb": "0.9917183048931314",
      "sw": "0.9831599176654812",
      "tr": "0.9800402289009472",
      "vi": "0.9935411358998886"
    },
    "level": "easy",
    "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)",
    "entry_point": "twoSum",
    "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {",
    "docstring": {
      "en": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n",
      "es": "Encuentra dos números en 'nums' cuya suma es igual a 'target', y devuelve sus índices. Supone que cada entrada tiene exactamente una solución, y el mismo elemento no puede ser utilizado dos veces.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "arb": "يعثر على رقمين في 'nums' يكون مجموعهما مساويًا لـ 'target' ويعيد مؤشراتهما. \nيفترض أن كل إدخال له حل واحد بالضبط، ولا يمكن استخدام نفس العنصر مرتين.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "sw": "Inapata nambari mbili katika 'nums' ambazo jumla yake ni sawa na 'target', na inarejesha faharasa zao. Inadhani kwamba kila ingizo lina suluhisho moja tu, na kipengele sawa hakiwezi kutumika mara mbili.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "tr": "'nums' içinde toplamı 'target' olan iki sayıyı bulur ve bunların indekslerini döndürür.\nHer girdinin tam olarak bir çözümü olduğu varsayılır ve aynı eleman iki kez kullanılamaz.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "vi": "Tìm hai số trong 'nums' có tổng bằng 'target', và trả về chỉ số của chúng. Giả sử rằng mỗi đầu vào có chính xác một giải pháp, và cùng một phần tử không thể được sử dụng hai lần.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6"
    },
    "docstring_bertscore": {
      "es": "0.9829779722364532",
      "arb": "0.9748112841202038",
      "sw": "0.9885813352854473",
      "tr": "0.9834354180039765",
      "vi": "0.9763832449557138"
    }
  },
  {
    "task_id": "Swift/21",
    "prompt": {
      "en": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "es": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermina las coordenadas del cuarto vértice de un rectángulo cuando se dan las coordenadas de tres vértices.\nSe asume que los lados del rectángulo son paralelos a los ejes de coordenadas.\n\n- Parámetros:\n- vertex1: Una tupla que representa las coordenadas del primer vértice.\n- vertex2: Una tupla que representa las coordenadas del segundo vértice.\n- vertex3: Una tupla que representa las coordenadas del tercer vértice.\n\n- Retorna: Una tupla que representa las coordenadas del cuarto vértice.\n\nEjemplo de uso:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "arb": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nيحدد إحداثيات الرأس الرابع لمستطيل عند إعطاء إحداثيات ثلاثة رؤوس.\nمن المفترض أن تكون جوانب المستطيل موازية لمحاور الإحداثيات.\n\n- Parameters:\n- vertex1: زوج يمثل إحداثيات الرأس الأول.\n- vertex2: زوج يمثل إحداثيات الرأس الثاني.\n- vertex3: زوج يمثل إحداثيات الرأس الثالث.\n\n- Returns: زوج يمثل إحداثيات الرأس الرابع.\n\nمثال على الاستخدام:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "sw": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nHuamua kuratibu za kipeo cha nne cha mstatili unapopewa kuratibu za vilele vitatu.\nUpande wa mstatili unadhaniwa kuwa sambamba na mhimili wa kuratibu.\n\n- Parameters:\n- vertex1: Jozi inayowakilisha kuratibu za kipeo cha kwanza.\n- vertex2: Jozi inayowakilisha kuratibu za kipeo cha pili.\n- vertex3: Jozi inayowakilisha kuratibu za kipeo cha tatu.\n\n- Returns: Jozi inayowakilisha kuratibu za kipeo cha nne.\n\nMfano wa matumizi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "tr": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nÜç köşenin koordinatları verildiğinde bir dikdörtgenin dördüncü köşesinin koordinatlarını belirler.\nDikdörtgenin kenarlarının koordinat eksenlerine paralel olduğu varsayılır.\n\n- Parametreler:\n- vertex1: İlk köşenin koordinatlarını temsil eden bir ikili.\n- vertex2: İkinci köşenin koordinatlarını temsil eden bir ikili.\n- vertex3: Üçüncü köşenin koordinatlarını temsil eden bir ikili.\n\n- Döndürür: Dördüncü köşenin koordinatlarını temsil eden bir ikili.\n\nÖrnek kullanım:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "vi": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nXác định tọa độ của đỉnh thứ tư của một hình chữ nhật khi biết tọa độ của ba đỉnh.\nCác cạnh của hình chữ nhật được giả định là song song với các trục tọa độ.\n\n- Tham số:\n- vertex1: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ nhất.\n- vertex2: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ hai.\n- vertex3: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ ba.\n\n- Trả về: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ tư.\n\nVí dụ sử dụng:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9806130789198518",
      "arb": "0.9745987496124964",
      "sw": "0.9796366119666843",
      "tr": "0.9746160304556465",
      "vi": "0.9902228167543197"
    },
    "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}",
    "instruction": {
      "en": "Write a Swift function `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` to solve the following problem:\n\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n",
      "es": "Escribe una función Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` para resolver el siguiente problema:\n\nDetermina las coordenadas del cuarto vértice de un rectángulo cuando se dan las coordenadas de tres vértices. Se asume que los lados del rectángulo son paralelos a los ejes de coordenadas.\n\n- Parámetros:\n- vertex1: Una tupla que representa las coordenadas del primer vértice.\n- vertex2: Una tupla que representa las coordenadas del segundo vértice.\n- vertex3: Una tupla que representa las coordenadas del tercer vértice.\n\n- Retorna: Una tupla que representa las coordenadas del cuarto vértice.\n\nEjemplo de uso:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "arb": "اكتب دالة Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` لحل المشكلة التالية:\n\nتحديد إحداثيات الرأس الرابع لمستطيل عند إعطاء إحداثيات ثلاثة رؤوس.\nمن المفترض أن تكون جوانب المستطيل موازية لمحاور الإحداثيات.\n\n- المعاملات:\n- vertex1: زوج يمثل إحداثيات الرأس الأول.\n- vertex2: زوج يمثل إحداثيات الرأس الثاني.\n- vertex3: زوج يمثل إحداثيات الرأس الثالث.\n\n- العائدات: زوج يمثل إحداثيات الرأس الرابع.\n\nمثال على الاستخدام:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "sw": "Andika kazi ya Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` kutatua tatizo lifuatalo:\n\nInabaini kuratibu za kipeo cha nne cha mstatili unapopewa kuratibu za vilele vitatu.\nUpande wa mstatili unadhaniwa kuwa sambamba na mhimili wa kuratibu.\n\n- Vigezo:\n- vertex1: Jozi inayoonyesha kuratibu za kipeo cha kwanza.\n- vertex2: Jozi inayoonyesha kuratibu za kipeo cha pili.\n- vertex3: Jozi inayoonyesha kuratibu za kipeo cha tatu.\n\n- Inarejesha: Jozi inayoonyesha kuratibu za kipeo cha nne.\n\nMfano wa matumizi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "tr": "Bir Swift fonksiyonu `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` yazın ve aşağıdaki problemi çözün:\n\nÜç köşenin koordinatları verildiğinde bir dikdörtgenin dördüncü köşesinin koordinatlarını belirler.\nDikdörtgenin kenarlarının koordinat eksenlerine paralel olduğu varsayılır.\n\n- Parametreler:\n- vertex1: İlk köşenin koordinatlarını temsil eden bir demet.\n- vertex2: İkinci köşenin koordinatlarını temsil eden bir demet.\n- vertex3: Üçüncü köşenin koordinatlarını temsil eden bir demet.\n\n- Döndürür: Dördüncü köşenin koordinatlarını temsil eden bir demet.\n\nÖrnek kullanım:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "vi": "Viết một hàm Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` để giải quyết vấn đề sau:\n\nXác định tọa độ của đỉnh thứ tư của một hình chữ nhật khi biết tọa độ của ba đỉnh. Các cạnh của hình chữ nhật được giả định là song song với các trục tọa độ.\n\n- Tham số:\n- vertex1: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ nhất.\n- vertex2: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ hai.\n- vertex3: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ ba.\n\n- Trả về: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ tư.\n\nVí dụ sử dụng:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)"
    },
    "instruction_bertscore": {
      "es": "0.9826689033635629",
      "arb": "0.974921126720916",
      "sw": "0.9812868331723221",
      "tr": "0.9894743774785802",
      "vi": "0.9890898290608967"
    },
    "level": "hard",
    "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)",
    "entry_point": "findFourthVertex",
    "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {",
    "docstring": {
      "en": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n",
      "es": "Determina las coordenadas del cuarto vértice de un rectángulo cuando se dan las coordenadas de tres vértices. Se asume que los lados del rectángulo son paralelos a los ejes de coordenadas.\n\n- Parámetros:\n- vertex1: Una tupla que representa las coordenadas del primer vértice.\n- vertex2: Una tupla que representa las coordenadas del segundo vértice.\n- vertex3: Una tupla que representa las coordenadas del tercer vértice.\n\n- Devuelve: Una tupla que representa las coordenadas del cuarto vértice.\n\nEjemplo de uso:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "arb": "يحدد إحداثيات الرأس الرابع لمستطيل عند إعطاء إحداثيات ثلاثة رؤوس.\nمن المفترض أن تكون جوانب المستطيل موازية لمحاور الإحداثيات.\n\n- المعاملات:\n- vertex1: زوج يمثل إحداثيات الرأس الأول.\n- vertex2: زوج يمثل إحداثيات الرأس الثاني.\n- vertex3: زوج يمثل إحداثيات الرأس الثالث.\n\n- يعيد: زوج يمثل إحداثيات الرأس الرابع.\n\nمثال على الاستخدام:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "sw": "Inabainisha kuratibu za kipeo cha nne cha mstatili unapopewa kuratibu za vilele vitatu.\nUpande wa mstatili unadhaniwa kuwa sambamba na mhimili wa kuratibu.\n\n- Vigezo:\n- vertex1: Jozi inayoashiria kuratibu za kipeo cha kwanza.\n- vertex2: Jozi inayoashiria kuratibu za kipeo cha pili.\n- vertex3: Jozi inayoashiria kuratibu za kipeo cha tatu.\n\n- Inarejesha: Jozi inayoashiria kuratibu za kipeo cha nne.\n\nMfano wa matumizi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "tr": "Dikdörtgenin üç köşesinin koordinatları verildiğinde, dördüncü köşenin koordinatlarını belirler. Dikdörtgenin kenarlarının koordinat eksenlerine paralel olduğu varsayılır.\n\n- Parametreler:\n- vertex1: İlk köşenin koordinatlarını temsil eden bir demet.\n- vertex2: İkinci köşenin koordinatlarını temsil eden bir demet.\n- vertex3: Üçüncü köşenin koordinatlarını temsil eden bir demet.\n\n- Döndürür: Dördüncü köşenin koordinatlarını temsil eden bir demet.\n\nÖrnek kullanım:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "vi": "Xác định tọa độ của đỉnh thứ tư của một hình chữ nhật khi biết tọa độ của ba đỉnh. Các cạnh của hình chữ nhật được giả định là song song với các trục tọa độ.\n\n- Tham số:\n- vertex1: Một bộ đại diện cho tọa độ của đỉnh thứ nhất.\n- vertex2: Một bộ đại diện cho tọa độ của đỉnh thứ hai.\n- vertex3: Một bộ đại diện cho tọa độ của đỉnh thứ ba.\n\n- Trả về: Một bộ đại diện cho tọa độ của đỉnh thứ tư.\n\nVí dụ sử dụng:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)"
    },
    "docstring_bertscore": {
      "es": "0.9675966314202545",
      "arb": "0.9698578396779557",
      "sw": "0.9567551865929893",
      "tr": "0.969791099869928",
      "vi": "0.9820861218256065"
    }
  },
  {
    "task_id": "Swift/22",
    "prompt": {
      "en": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/",
      "es": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nEsta función calcula el número de piezas de ajedrez que necesitan ser añadidas o removidas para completar un conjunto estándar de ajedrez. Un conjunto completo consta de 1 Rey, 1 Reina, 2 Torres, 2 Alfiles, 2 Caballos y 8 Peones.\n\nLa entrada es un arreglo de seis enteros que representa el conteo de cada pieza en el orden: Rey, Reina, Torre, Alfil, Caballo, Peón. Cada número está entre 0 y 10 inclusive.\n\nLa función devuelve un arreglo de seis enteros que indica cuántas piezas de cada tipo necesitan ser añadidas (número positivo) o removidas (número negativo) para completar el conjunto.\n\nEjemplo:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // El conjunto ya está completo\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Añadir 1 Rey, remover 1 Reina, añadir 1 Torre, añadir 3 Peones\n*/",
      "arb": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nهذه الدالة تحسب عدد قطع الشطرنج التي تحتاج إلى إضافتها أو إزالتها لإكمال مجموعة شطرنج قياسية. تتكون المجموعة الكاملة من 1 ملك، 1 ملكة، 2 قلعة، 2 فيل، 2 حصان، و8 جنود.\n\nالإدخال هو مصفوفة تحتوي على ستة أعداد صحيحة تمثل عدد كل قطعة بالترتيب: ملك، ملكة، قلعة، فيل، حصان، جندي. كل رقم يتراوح بين 0 و10 شامل.\n\nترجع الدالة مصفوفة من ستة أعداد صحيحة تشير إلى عدد القطع من كل نوع التي تحتاج إلى إضافتها (رقم موجب) أو إزالتها (رقم سالب) لإكمال المجموعة.\n\nمثال:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // المجموعة مكتملة بالفعل\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // إضافة 1 ملك، إزالة 1 ملكة، إضافة 1 قلعة، إضافة 3 جنود\n*/",
      "sw": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nKazi ya hii ni kuhesabu idadi ya vipande vya chess ambavyo vinahitaji kuongezwa au kuondolewa ili kukamilisha seti ya kawaida ya chess. Seti kamili ina King 1, Queen 1, Rooks 2, Bishops 2, Knights 2, na Pawns 8.\n\nIngizo ni safu ya namba sita za mzima zinazowakilisha idadi ya kila kipande kwa mpangilio: King, Queen, Rook, Bishop, Knight, Pawn. Kila namba iko kati ya 0 na 10 ikijumuishwa.\n\nKazi inarudisha safu ya namba sita za mzima zinazoonyesha ni vipande vingapi vya kila aina vinahitaji kuongezwa (namba chanya) au kuondolewa (namba hasi) ili kukamilisha seti.\n\nMfano:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti tayari imekamilika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ongeza King 1, ondoa Queen 1, ongeza Rook 1, ongeza Pawns 3\n*/",
      "tr": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nBu fonksiyon, standart bir satranç setini tamamlamak için eklenmesi veya çıkarılması gereken satranç taşlarının sayısını hesaplar. Tam bir set, 1 Şah, 1 Vezir, 2 Kale, 2 Fil, 2 At ve 8 Piyon içerir.\n\nGirdi, Şah, Vezir, Kale, Fil, At, Piyon sırasıyla her bir taşın sayısını temsil eden altı tam sayıdan oluşan bir dizidir. Her sayı 0 ile 10 arasında (dahil) olabilir.\n\nFonksiyon, seti tamamlamak için her türden kaç taşın eklenmesi (pozitif sayı) veya çıkarılması (negatif sayı) gerektiğini belirten altı tam sayıdan oluşan bir dizi döndürür.\n\nÖrnek:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Set zaten tamamlanmış\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 Şah ekle, 1 Vezir çıkar, 1 Kale ekle, 3 Piyon ekle\n*/",
      "vi": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nHàm này tính toán số lượng quân cờ cần thêm vào hoặc bớt đi để hoàn thành một bộ cờ tiêu chuẩn. Một bộ cờ hoàn chỉnh bao gồm 1 Vua, 1 Hậu, 2 Xe, 2 Tượng, 2 Mã, và 8 Tốt.\n\nĐầu vào là một mảng gồm sáu số nguyên đại diện cho số lượng của mỗi quân cờ theo thứ tự: Vua, Hậu, Xe, Tượng, Mã, Tốt. Mỗi số nằm trong khoảng từ 0 đến 10 bao gồm cả hai đầu.\n\nHàm trả về một mảng gồm sáu số nguyên chỉ ra cần thêm (số dương) hay bớt đi (số âm) bao nhiêu quân cờ của mỗi loại để hoàn thành bộ cờ.\n\nVí dụ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Bộ cờ đã hoàn chỉnh\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Thêm 1 Vua, bớt 1 Hậu, thêm 1 Xe, thêm 3 Tốt\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9587782370238297",
      "sw": "0.9843908301367543",
      "tr": "0.984411686326763",
      "vi": "0.9872707720313791"
    },
    "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}",
    "instruction": {
      "en": "Write a Swift function `func adjustChessPieces(_ counts: [Int]) -> [Int] {` to solve the following problem:\n\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n",
      "es": "Escribe una función en Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` para resolver el siguiente problema:\n\nEsta función calcula el número de piezas de ajedrez que necesitan ser añadidas o removidas para completar un conjunto estándar de ajedrez. Un conjunto completo consiste en 1 Rey, 1 Reina, 2 Torres, 2 Alfiles, 2 Caballos y 8 Peones.\n\nLa entrada es un arreglo de seis enteros que representa la cantidad de cada pieza en el orden: Rey, Reina, Torre, Alfil, Caballo, Peón. Cada número está entre 0 y 10 inclusive.\n\nLa función devuelve un arreglo de seis enteros que indica cuántas piezas de cada tipo necesitan ser añadidas (número positivo) o removidas (número negativo) para completar el conjunto.\n\nEjemplo:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // El conjunto ya está completo\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Añadir 1 Rey, remover 1 Reina, añadir 1 Torre, añadir 3 Peones",
      "arb": "اكتب دالة Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` لحل المشكلة التالية:\n\nتحسب هذه الدالة عدد قطع الشطرنج التي تحتاج إلى إضافتها أو إزالتها لإكمال مجموعة شطرنج قياسية. تتكون المجموعة الكاملة من 1 ملك، 1 ملكة، 2 قلعة، 2 فيل، 2 حصان، و8 جنود.\n\nالمدخل هو مصفوفة تحتوي على ستة أعداد صحيحة تمثل عدد كل قطعة بالترتيب: ملك، ملكة، قلعة، فيل، حصان، جندي. كل رقم يكون بين 0 و10 شامل.\n\nتعيد الدالة مصفوفة تحتوي على ستة أعداد صحيحة تشير إلى عدد القطع من كل نوع التي تحتاج إلى إضافتها (رقم موجب) أو إزالتها (رقم سالب) لإكمال المجموعة.\n\nمثال:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // المجموعة مكتملة بالفعل\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // أضف 1 ملك، أزل 1 ملكة، أضف 1 قلعة، أضف 3 جنود",
      "sw": "Andika kazi ya Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` kutatua tatizo lifuatalo:\n\nKazi hii inahesabu idadi ya vipande vya chess vinavyohitajika kuongezwa au kuondolewa ili kukamilisha seti ya kawaida ya chess. Seti kamili inajumuisha Mfalme 1, Malkia 1, Majumba 2, Maaskofu 2, Farasi 2, na Piyade 8.\n\nIngizo ni safu ya nambari sita za mzima zinazoonyesha idadi ya kila kipande kwa mpangilio: Mfalme, Malkia, Jumba, Askofu, Farasi, Piyade. Kila nambari iko kati ya 0 na 10 ikijumuisha.\n\nKazi inarudisha safu ya nambari sita za mzima zinazoonyesha ni vipande vingapi vya kila aina vinavyohitajika kuongezwa (nambari chanya) au kuondolewa (nambari hasi) ili kukamilisha seti.\n\nMfano:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti tayari imekamilika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ongeza Mfalme 1, ondoa Malkia 1, ongeza Jumba 1, ongeza Piyade 3",
      "tr": "Bir Swift fonksiyonu `func adjustChessPieces(_ counts: [Int]) -> [Int] {` yazın ve aşağıdaki problemi çözün:\n\nBu fonksiyon, standart bir satranç setini tamamlamak için eklenmesi veya çıkarılması gereken satranç taşlarının sayısını hesaplar. Tam bir set, 1 Şah, 1 Vezir, 2 Kale, 2 Fil, 2 At ve 8 Piyon içerir.\n\nGirdi, her bir taşın sayısını sırasıyla temsil eden altı tam sayıdan oluşan bir dizidir: Şah, Vezir, Kale, Fil, At, Piyon. Her sayı 0 ile 10 arasında (dahil) olabilir.\n\nFonksiyon, seti tamamlamak için her türden kaç taşın eklenmesi (pozitif sayı) veya çıkarılması (negatif sayı) gerektiğini belirten altı tam sayıdan oluşan bir dizi döndürür.\n\nÖrnek:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Set zaten tamamlanmış\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 Şah ekle, 1 Vezir çıkar, 1 Kale ekle, 3 Piyon ekle",
      "vi": "Viết một hàm Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` để giải quyết vấn đề sau:\n\nHàm này tính toán số lượng quân cờ cần thêm vào hoặc bớt đi để hoàn thành một bộ cờ tiêu chuẩn. Một bộ cờ hoàn chỉnh bao gồm 1 Vua, 1 Hậu, 2 Xe, 2 Tượng, 2 Mã, và 8 Tốt.\n\nĐầu vào là một mảng gồm sáu số nguyên đại diện cho số lượng của mỗi quân cờ theo thứ tự: Vua, Hậu, Xe, Tượng, Mã, Tốt. Mỗi số nằm trong khoảng từ 0 đến 10 bao gồm cả hai.\n\nHàm trả về một mảng gồm sáu số nguyên chỉ ra cần thêm (số dương) hay bớt đi (số âm) bao nhiêu quân cờ của mỗi loại để hoàn thành bộ cờ.\n\nVí dụ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Bộ cờ đã hoàn chỉnh\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Thêm 1 Vua, bớt 1 Hậu, thêm 1 Xe, thêm 3 Tốt"
    },
    "instruction_bertscore": {
      "es": "0.9927082787122092",
      "arb": "0.9892302607402884",
      "sw": "0.9953075558784318",
      "tr": "0.9879494920433755",
      "vi": "0.9862517981766702"
    },
    "level": "middle",
    "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()",
    "entry_point": "adjustChessPieces",
    "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n",
      "es": "Esta función calcula el número de piezas de ajedrez que necesitan ser añadidas o removidas para completar un conjunto estándar de ajedrez. Un conjunto completo consta de 1 Rey, 1 Reina, 2 Torres, 2 Alfiles, 2 Caballos y 8 Peones.\n\nLa entrada es un arreglo de seis enteros que representa la cantidad de cada pieza en el orden: Rey, Reina, Torre, Alfil, Caballo, Peón. Cada número está entre 0 y 10 inclusive.\n\nLa función devuelve un arreglo de seis enteros que indica cuántas piezas de cada tipo necesitan ser añadidas (número positivo) o removidas (número negativo) para completar el conjunto.\n\nEjemplo:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // El conjunto ya está completo\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Añadir 1 Rey, remover 1 Reina, añadir 1 Torre, añadir 3 Peones",
      "arb": "هذه الدالة تحسب عدد قطع الشطرنج التي تحتاج إلى إضافتها أو إزالتها لإكمال مجموعة شطرنج قياسية. تتكون المجموعة الكاملة من 1 ملك، 1 ملكة، 2 قلعة، 2 فيل، 2 حصان، و8 جنود.\n\nالإدخال هو مصفوفة مكونة من ستة أعداد صحيحة تمثل عدد كل قطعة بالترتيب: ملك، ملكة، قلعة، فيل، حصان، جندي. كل رقم يكون بين 0 و10 شامل.\n\nالدالة تعيد مصفوفة من ستة أعداد صحيحة تشير إلى عدد القطع من كل نوع التي تحتاج إلى إضافتها (رقم موجب) أو إزالتها (رقم سالب) لإكمال المجموعة.\n\nمثال:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // المجموعة مكتملة بالفعل\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // أضف 1 ملك، أزل 1 ملكة، أضف 1 قلعة، أضف 3 جنود",
      "sw": "Kazi hii inahesabu idadi ya vipande vya mchezo wa chess vinavyohitajika kuongezwa au kuondolewa ili kukamilisha seti ya kawaida ya chess. Seti kamili inajumuisha Mfalme 1, Malkia 1, Majumba 2, Maaskofu 2, Farasi 2, na Pioni 8.\n\nIngizo ni safu ya nambari sita za mzima zinazoashiria idadi ya kila kipande kwa mpangilio: Mfalme, Malkia, Jumba, Askofu, Farasi, Pioni. Kila nambari iko kati ya 0 na 10 ikijumuisha.\n\nKazi inarudisha safu ya nambari sita za mzima inayoonyesha ni vipande vingapi vya kila aina vinavyohitajika kuongezwa (nambari chanya) au kuondolewa (nambari hasi) ili kukamilisha seti.\n\nMfano:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti tayari imekamilika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ongeza Mfalme 1, ondoa Malkia 1, ongeza Jumba 1, ongeza Pioni 3",
      "tr": "Bu fonksiyon, standart bir satranç setini tamamlamak için eklenmesi veya çıkarılması gereken satranç taşlarının sayısını hesaplar. Tam bir set, 1 Şah, 1 Vezir, 2 Kale, 2 Fil, 2 At ve 8 Piyon içerir.\n\nGirdi, taşların sayısını şu sırayla temsil eden altı tam sayıdan oluşan bir dizidir: Şah, Vezir, Kale, Fil, At, Piyon. Her sayı 0 ile 10 arasında (dahil) bir değerdir.\n\nFonksiyon, seti tamamlamak için her türden kaç taşın eklenmesi (pozitif sayı) veya çıkarılması (negatif sayı) gerektiğini belirten altı tam sayıdan oluşan bir dizi döndürür.\n\nÖrnek:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Set zaten tamamlanmış\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 Şah ekle, 1 Vezir çıkar, 1 Kale ekle, 3 Piyon ekle",
      "vi": "Hàm này tính toán số lượng quân cờ cần thêm vào hoặc bớt đi để hoàn thành một bộ cờ tiêu chuẩn. Một bộ cờ hoàn chỉnh bao gồm 1 Vua, 1 Hậu, 2 Xe, 2 Tượng, 2 Mã, và 8 Tốt.\n\nĐầu vào là một mảng gồm sáu số nguyên đại diện cho số lượng của mỗi quân cờ theo thứ tự: Vua, Hậu, Xe, Tượng, Mã, Tốt. Mỗi số nằm trong khoảng từ 0 đến 10 bao gồm cả hai đầu.\n\nHàm trả về một mảng gồm sáu số nguyên chỉ ra số lượng quân cờ của mỗi loại cần thêm vào (số dương) hoặc bớt đi (số âm) để hoàn thành bộ cờ.\n\nVí dụ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Bộ cờ đã hoàn chỉnh\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Thêm 1 Vua, bớt 1 Hậu, thêm 1 Xe, thêm 3 Tốt"
    },
    "docstring_bertscore": {
      "es": "0.9970270990870508",
      "arb": "0.959156032008558",
      "sw": "0.9884262049578592",
      "tr": "0.9773215748757227",
      "vi": "0.9729536927967655"
    }
  },
  {
    "task_id": "Swift/23",
    "prompt": {
      "en": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "es": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalcula el número máximo de piezas en las que se puede dividir un tablero de ajedrez rectangular con 'n' cortes rectos,\ndonde todos los cortes son paralelos a los lados del rectángulo.\n\nLa fórmula para calcular el número máximo de piezas es (n^2 + n + 2)/2.\n\n- Parámetros:\n- n: El número de cortes que se realizarán en el tablero de ajedrez.\n- Devuelve: El número máximo de piezas en las que se puede dividir el tablero de ajedrez.\n\nEjemplos:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "arb": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nتحسب أقصى عدد من القطع التي يمكن تقسيم لوحة شطرنج مستطيلة إليها باستخدام 'n' من القطوع المستقيمة،\nحيث تكون جميع القطوع موازية لجوانب المستطيل.\n\nالصيغة لحساب أقصى عدد من القطع هي (n^2 + n + 2)/2.\n\n- Parameters:\n- n: عدد القطوع التي سيتم إجراؤها على لوحة الشطرنج.\n- Returns: أقصى عدد من القطع التي يمكن تقسيم لوحة الشطرنج إليها.\n\nأمثلة:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "sw": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nInahesabu idadi kubwa zaidi ya vipande ambavyo ubao wa chess wa mstatili unaweza kugawanywa kwa 'n' vipande vya moja kwa moja, \nambapo vipande vyote ni sambamba na pande za mstatili.\n\nKanuni ya kuhesabu idadi kubwa zaidi ya vipande ni (n^2 + n + 2)/2.\n\n- Vigezo:\n- n: Idadi ya vipande vitakavyofanywa kwenye ubao wa chess.\n- Inarejesha: Idadi kubwa zaidi ya vipande ambavyo ubao wa chess unaweza kugawanywa.\n\nMifano:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "tr": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nDikdörtgen bir satranç tahtasının, kenarlarına paralel 'n' düz kesim ile en fazla kaç parçaya bölünebileceğini hesaplar.\n\nMaksimum parça sayısını hesaplamak için formül (n^2 + n + 2)/2'dir.\n\n- Parametreler:\n- n: Satranç tahtasında yapılacak kesim sayısı.\n- Döndürülen: Satranç tahtasının bölünebileceği maksimum parça sayısı.\n\nÖrnekler:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "vi": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nTính toán số lượng miếng tối đa mà một bàn cờ hình chữ nhật có thể được chia thành với 'n' đường cắt thẳng, \ntrong đó tất cả các đường cắt đều song song với các cạnh của hình chữ nhật.\n\nCông thức để tính số lượng miếng tối đa là (n^2 + n + 2)/2.\n\n- Tham số:\n- n: Số lượng đường cắt sẽ được thực hiện trên bàn cờ.\n- Trả về: Số lượng miếng tối đa mà bàn cờ có thể được chia thành.\n\nVí dụ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9857272153403571",
      "arb": "0.9957576523218569",
      "sw": "0.9801447084813716",
      "tr": "0.977886876940148",
      "vi": "0.9804303389692998"
    },
    "canonical_solution": "if n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}",
    "instruction": {
      "en": "Write a Swift function `func maxChessboardSlices(_ n: Int) -> Int {` to solve the following problem:\n\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n",
      "es": "Escribe una función Swift `func maxChessboardSlices(_ n: Int) -> Int {` para resolver el siguiente problema:\n\nCalcula el número máximo de piezas en las que se puede dividir un tablero de ajedrez rectangular con 'n' cortes rectos, donde todos los cortes son paralelos a los lados del rectángulo.\n\nLa fórmula para calcular el número máximo de piezas es (n^2 + n + 2)/2.\n\n- Parámetros:\n- n: El número de cortes que se harán en el tablero de ajedrez.\n- Retorna: El número máximo de piezas en las que se puede dividir el tablero de ajedrez.\n\nEjemplos:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "arb": "اكتب دالة Swift `func maxChessboardSlices(_ n: Int) -> Int {` لحل المشكلة التالية:\n\nتحسب الحد الأقصى لعدد القطع التي يمكن تقسيم لوحة شطرنج مستطيلة إليها باستخدام 'n' من القطع المستقيمة، حيث تكون جميع القطع موازية لجوانب المستطيل.\n\nالصيغة لحساب الحد الأقصى لعدد القطع هي (n^2 + n + 2)/2.\n\n- المعاملات:\n- n: عدد القطع التي سيتم إجراؤها على لوحة الشطرنج.\n- الإرجاع: الحد الأقصى لعدد القطع التي يمكن تقسيم لوحة الشطرنج إليها.\n\nأمثلة:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "sw": "Andika kazi ya Swift `func maxChessboardSlices(_ n: Int) -> Int {` kutatua tatizo lifuatalo:\n\nInakokotoa idadi kubwa zaidi ya vipande ambavyo ubao wa chess wa mstatili unaweza kugawanywa kwa kutumia 'n' vipande vya moja kwa moja, ambapo vipande vyote ni sambamba na pande za mstatili.\n\nFomula ya kukokotoa idadi kubwa zaidi ya vipande ni (n^2 + n + 2)/2.\n\n- Vigezo:\n- n: Idadi ya vipande vitakavyofanywa kwenye ubao wa chess.\n- Inarudisha: Idadi kubwa zaidi ya vipande ambavyo ubao wa chess unaweza kugawanywa.\n\nMifano:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "tr": "Bir Swift fonksiyonu `func maxChessboardSlices(_ n: Int) -> Int {` yazarak aşağıdaki problemi çözün:\n\nBir dikdörtgen satranç tahtasının, tüm kesimlerin dikdörtgenin kenarlarına paralel olduğu 'n' düz kesimle en fazla kaç parçaya bölünebileceğini hesaplar.\n\nMaksimum parça sayısını hesaplamak için formül (n^2 + n + 2)/2'dir.\n\n- Parametreler:\n- n: Satranç tahtasında yapılacak kesim sayısı.\n- Döndürür: Satranç tahtasının bölünebileceği maksimum parça sayısı.\n\nÖrnekler:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "vi": "Viết một hàm Swift `func maxChessboardSlices(_ n: Int) -> Int {` để giải quyết vấn đề sau:\n\nTính toán số lượng tối đa các mảnh mà một bàn cờ hình chữ nhật có thể được chia thành với 'n' đường cắt thẳng, \ntrong đó tất cả các đường cắt đều song song với các cạnh của hình chữ nhật.\n\nCông thức để tính toán số lượng tối đa các mảnh là (n^2 + n + 2)/2.\n\n- Tham số:\n- n: Số lượng đường cắt sẽ được thực hiện trên bàn cờ.\n- Trả về: Số lượng tối đa các mảnh mà bàn cờ có thể được chia thành.\n\nVí dụ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n"
    },
    "instruction_bertscore": {
      "es": "0.9882017526272897",
      "arb": "0.9950888638289124",
      "sw": "0.992296517932324",
      "tr": "0.9960393102021643",
      "vi": "0.9849672555025176"
    },
    "level": "easy",
    "test": "func testMaxChessboardSlices() {\nassert(maxChessboardSlices(0) == 1)\nassert(maxChessboardSlices(2) == 4)\nassert(maxChessboardSlices(4) == 9)\nassert(maxChessboardSlices(5) == 12)\nassert(maxChessboardSlices(6) == 16)\nassert(maxChessboardSlices(7) == 20)\n}\n\ntestMaxChessboardSlices()",
    "entry_point": "maxChessboardSlices",
    "signature": "func maxChessboardSlices(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n",
      "es": "Calcula el número máximo de piezas en las que se puede dividir un tablero de ajedrez rectangular con 'n' cortes rectos, donde todos los cortes son paralelos a los lados del rectángulo.\n\nLa fórmula para calcular el número máximo de piezas es (n^2 + n + 2)/2.\n\n- Parámetros:\n- n: El número de cortes que se realizarán en el tablero de ajedrez.\n- Devuelve: El número máximo de piezas en las que se puede dividir el tablero de ajedrez.\n\nEjemplos:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "arb": "يحسب الحد الأقصى لعدد القطع التي يمكن تقسيم لوح الشطرنج المستطيل إليها باستخدام 'n' من القطع المستقيمة، حيث تكون جميع القطع موازية لجوانب المستطيل.\n\nالصيغة لحساب الحد الأقصى لعدد القطع هي (n^2 + n + 2)/2.\n\n- المعلمات:\n- n: عدد القطع التي سيتم إجراؤها على لوح الشطرنج.\n- العوائد: الحد الأقصى لعدد القطع التي يمكن تقسيم لوح الشطرنج إليها.\n\nأمثلة:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "sw": "Hesabu idadi kubwa zaidi ya vipande ambavyo ubao wa chess wa mstatili unaweza kugawanywa kwa 'n' vipande vya moja kwa moja, ambapo vipande vyote ni sambamba na pande za mstatili.\n\nFomula ya kuhesabu idadi kubwa zaidi ya vipande ni (n^2 + n + 2)/2.\n\n- Vigezo:\n- n: Idadi ya vipande vitakavyofanywa kwenye ubao wa chess.\n- Inarejesha: Idadi kubwa zaidi ya vipande ambavyo ubao wa chess unaweza kugawanywa.\n\nMifano:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "tr": "Dikdörtgen bir satranç tahtasının, tüm kesimlerin dikdörtgenin kenarlarına paralel olduğu 'n' düz kesimle en fazla kaç parçaya bölünebileceğini hesaplar.\n\nMaksimum parça sayısını hesaplamak için formül (n^2 + n + 2)/2'dir.\n\n- Parametreler:\n- n: Satranç tahtasında yapılacak kesim sayısı.\n- Döndürür: Satranç tahtasının bölünebileceği maksimum parça sayısı.\n\nÖrnekler:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "vi": "Tính toán số lượng tối đa các mảnh mà một bàn cờ hình chữ nhật có thể được chia thành với 'n' đường cắt thẳng, \ntrong đó tất cả các đường cắt đều song song với các cạnh của hình chữ nhật.\n\nCông thức để tính số lượng tối đa các mảnh là (n^2 + n + 2)/2.\n\n- Tham số:\n- n: Số lượng đường cắt sẽ được thực hiện trên bàn cờ.\n- Trả về: Số lượng tối đa các mảnh mà bàn cờ có thể được chia thành.\n\nVí dụ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9"
    },
    "docstring_bertscore": {
      "es": "0.9775666847659197",
      "arb": "0.9954787752668839",
      "sw": "0.9899129533599053",
      "tr": "0.995206055753723",
      "vi": "0.9935741085431403"
    }
  },
  {
    "task_id": "Swift/24",
    "prompt": {
      "en": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "es": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nEncuentra la palabra lexicográficamente más pequeña en una matriz dada de caracteres. \nLa matriz consiste en letras minúsculas y '#'. Una palabra se define como una secuencia \nde letras ya sea horizontalmente de izquierda a derecha o verticalmente de arriba a abajo, \nsin cruzar '#'. La palabra debe tener al menos 2 caracteres de largo y estar delimitada por '#' \no el borde de la matriz en ambos extremos.\n\nEjemplo:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "arb": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nيعثر على الكلمة الأصغر ترتيبًا في معجم الكلمات في مصفوفة معينة من الأحرف.\nتتكون المصفوفة من حروف صغيرة و '#'. تُعرّف الكلمة على أنها سلسلة من الأحرف \nإما أفقيًا من اليسار إلى اليمين أو عموديًا من الأعلى إلى الأسفل، دون عبور '#'. \nيجب أن تكون الكلمة على الأقل مكونة من حرفين وأن تكون محاطة بـ '#' أو حافة المصفوفة \nمن كلا الطرفين.\n\nمثال:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "sw": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nInapata neno dogo zaidi kwa mpangilio wa alfabeti katika matriki iliyotolewa ya herufi.\nMatriki inajumuisha herufi ndogo na '#'. Neno linafafanuliwa kama mlolongo \nwa herufi ama kwa usawa kutoka kushoto kwenda kulia au kwa wima kutoka juu kwenda chini, \nbila kuvuka '#'. Neno lazima liwe na urefu wa angalau herufi 2 na lipungwe na '#' \nau ukingo wa matriki kwenye pande zote mbili.\n\nMfano:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "tr": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nVerilen bir karakter matrisinde sözlük sırasına göre en küçük kelimeyi bulur.\nMatris, küçük harfler ve '#' karakterlerinden oluşur. Bir kelime, soldan sağa yatay \nveya yukarıdan aşağıya dikey olarak, '#' karakterini geçmeden oluşan bir harf dizisidir. \nKelime en az 2 karakter uzunluğunda olmalı ve her iki ucunda '#' veya matrisin kenarı \nile sınırlanmalıdır.\n\nÖrnek:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "vi": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nTìm từ nhỏ nhất theo thứ tự từ điển trong một ma trận ký tự cho trước.\nMa trận bao gồm các chữ cái thường và '#'. Một từ được định nghĩa là một chuỗi \ncác chữ cái theo chiều ngang từ trái sang phải hoặc theo chiều dọc từ trên xuống dưới, \nkhông vượt qua '#'. Từ phải có ít nhất 2 ký tự và được giới hạn bởi '#' \nhoặc cạnh của ma trận ở cả hai đầu.\n\nVí dụ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.990862605211633",
      "sw": "0.9778262946739323",
      "tr": "0.9482458610694547",
      "vi": "0.958364092679372"
    },
    "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}",
    "instruction": {
      "en": "Write a Swift function `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` to solve the following problem:\n\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n",
      "es": "Escribe una función Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` para resolver el siguiente problema:\n\nEncuentra la palabra lexicográficamente más pequeña en una matriz dada de caracteres. \nLa matriz consiste en letras minúsculas y '#'. Una palabra se define como una secuencia \nde letras ya sea horizontalmente de izquierda a derecha o verticalmente de arriba a abajo, \nsin cruzar '#'. La palabra debe tener al menos 2 caracteres de largo y estar delimitada por '#' \no el borde de la matriz en ambos extremos.\n\nEjemplo:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "arb": "اكتب دالة Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` لحل المشكلة التالية:\n\nتجد الكلمة الأصغر ترتيبًا لغويًا في مصفوفة معينة من الأحرف. \nتتكون المصفوفة من أحرف صغيرة و '#'. تُعرّف الكلمة على أنها تسلسل \nمن الأحرف إما أفقيًا من اليسار إلى اليمين أو عموديًا من الأعلى إلى الأسفل، \nدون عبور '#'. يجب أن تكون الكلمة مكونة من حرفين على الأقل وأن تكون محاطة بـ '#' \nأو حافة المصفوفة من كلا الطرفين.\n\nمثال:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "sw": "Andika kazi ya Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` kutatua tatizo lifuatalo:\n\nInapata neno dogo zaidi kwa mpangilio wa alfabeti katika matriki uliyopewa ya herufi. \nMatriki inajumuisha herufi ndogo na '#'. Neno linafafanuliwa kama mfuatano \nwa herufi ama kwa usawa kutoka kushoto kwenda kulia au kwa wima kutoka juu kwenda chini, \nbila kuvuka '#'. Neno lazima liwe na urefu wa angalau herufi 2 na liwe limezungukwa na '#' \nau kingo za matriki pande zote mbili.\n\nMfano:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "tr": "Bir Swift fonksiyonu `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` yazarak aşağıdaki problemi çözün:\n\nVerilen bir karakter matrisinde sözlük sırasına göre en küçük kelimeyi bulur. \nMatris, küçük harflerden ve '#' karakterinden oluşur. Bir kelime, soldan sağa yatay \nveya yukarıdan aşağıya dikey olarak, '#' karakterini geçmeden oluşan bir harf dizisi \nolarak tanımlanır. Kelime en az 2 karakter uzunluğunda olmalı ve her iki uçta da '#' \nveya matrisin kenarı ile sınırlanmalıdır.\n\nÖrnek:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "vi": "Viết một hàm Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` để giải quyết vấn đề sau:\n\nTìm từ nhỏ nhất theo thứ tự từ điển trong một ma trận ký tự cho trước. \nMa trận bao gồm các chữ cái thường và '#'. Một từ được định nghĩa là một dãy \nchữ cái theo chiều ngang từ trái sang phải hoặc theo chiều dọc từ trên xuống dưới, \nkhông vượt qua '#'. Từ phải dài ít nhất 2 ký tự và được giới hạn bởi '#' \nhoặc cạnh của ma trận ở cả hai đầu.\n\nVí dụ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\""
    },
    "instruction_bertscore": {
      "es": "0.9887708286689547",
      "arb": "0.9824281633417487",
      "sw": "0.9747642087198984",
      "tr": "0.950376767797197",
      "vi": "0.9800604891998127"
    },
    "level": "hard",
    "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()",
    "entry_point": "findSmallestWordInMatrix",
    "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {",
    "docstring": {
      "en": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n",
      "es": "Encuentra la palabra lexicográficamente más pequeña en una matriz dada de caracteres. \nLa matriz consiste en letras minúsculas y '#'. Una palabra se define como una secuencia \nde letras ya sea horizontalmente de izquierda a derecha o verticalmente de arriba a abajo, \nsin cruzar '#'. La palabra debe tener al menos 2 caracteres de largo y estar delimitada por '#' \no el borde de la matriz en ambos extremos.\n\nEjemplo:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "arb": "يعثر على أصغر كلمة حسب الترتيب المعجمي في مصفوفة معينة من الأحرف. \nتتكون المصفوفة من حروف صغيرة و '#'. تُعرّف الكلمة على أنها تسلسل \nمن الحروف إما أفقيًا من اليسار إلى اليمين أو عموديًا من الأعلى إلى الأسفل، \nدون عبور '#'. يجب أن تكون الكلمة مكونة من حرفين على الأقل ومحددة بـ '#' \nأو حافة المصفوفة في كلا الطرفين.\n\nمثال:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "sw": "Inapata neno dogo zaidi kwa mpangilio wa alfabeti katika matriki iliyotolewa ya herufi. \nMatriki inajumuisha herufi ndogo na '#'. Neno linafafanuliwa kama mlolongo \nwa herufi ama kwa usawa kutoka kushoto kwenda kulia au kwa wima kutoka juu kwenda chini, \nbila kuvuka '#'. Neno lazima liwe na urefu wa angalau herufi 2 na liwe limezungukwa na '#' \nau ukingo wa matriki kwenye pande zote mbili.\n\nMfano:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "tr": "Verilen bir karakter matrisinde sözlük sırasına göre en küçük kelimeyi bulur. \nMatris, küçük harfler ve '#' karakterlerinden oluşur. Bir kelime, soldan sağa yatay \nveya yukarıdan aşağıya dikey olarak, '#' karakterine çarpmadan oluşan harfler dizisi \nolarak tanımlanır. Kelime en az 2 karakter uzunluğunda olmalı ve her iki uçta da \n'#' veya matrisin kenarı ile sınırlı olmalıdır.\n\nÖrnek:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "vi": "Tìm từ nhỏ nhất theo thứ tự từ điển trong một ma trận ký tự đã cho. Ma trận bao gồm các chữ cái thường và '#'. Một từ được định nghĩa là một chuỗi các chữ cái theo chiều ngang từ trái sang phải hoặc theo chiều dọc từ trên xuống dưới, không vượt qua '#'. Từ phải dài ít nhất 2 ký tự và được giới hạn bởi '#' hoặc cạnh của ma trận ở cả hai đầu.\n\nVí dụ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\""
    },
    "docstring_bertscore": {
      "es": "0.9946816715477909",
      "arb": "0.9802180030919734",
      "sw": "0.9557248908065613",
      "tr": "0.9414499212127271",
      "vi": "0.9718542736377374"
    }
  },
  {
    "task_id": "Swift/25",
    "prompt": {
      "en": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/",
      "es": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nEncuentra el número faltante en una secuencia que originalmente era una progresión aritmética.\n\nLa entrada es un arreglo de tres enteros, que representan los números restantes de la secuencia después de que se pierde un número. La función devuelve el número faltante. La secuencia original de cuatro números estaba en progresión aritmética.\n\nEjemplos:\n- Si la entrada es [3, 7, 5], la función devuelve 1 o 9, ya que la secuencia podría haber sido [1, 3, 5, 7] o [3, 5, 7, 9].\n- Si la entrada es [20, 14, 8], la función devuelve 26 o 2, ya que la secuencia podría haber sido [2, 8, 14, 20] o [8, 14, 20, 26].\n*/",
      "arb": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nيجد الرقم المفقود في تسلسل كان في الأصل متتالية حسابية.\n\nالإدخال هو مصفوفة تحتوي على ثلاثة أعداد صحيحة، تمثل الأرقام المتبقية من التسلسل بعد فقدان رقم واحد. تقوم الدالة بإرجاع الرقم المفقود. كان التسلسل الأصلي المكون من أربعة أرقام في متتالية حسابية.\n\nأمثلة:\n- إذا كان الإدخال هو [3, 7, 5]، فإن الدالة تعيد 1 أو 9، حيث يمكن أن يكون التسلسل [1, 3, 5, 7] أو [3, 5, 7, 9].\n- إذا كان الإدخال هو [20, 14, 8]، فإن الدالة تعيد 26 أو 2، حيث يمكن أن يكون التسلسل [2, 8, 14, 20] أو [8, 14, 20, 26].\n*/",
      "sw": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nInapata nambari inayokosekana katika mlolongo ambao awali ulikuwa ni mfululizo wa hesabu.\n\nIngizo ni safu ya nambari tatu za mzima, zinazoashiria nambari zilizobaki za mlolongo baada ya nambari moja kupotea. Kazi inarejesha nambari inayokosekana. Mlolongo wa awali wa nambari nne ulikuwa katika mfululizo wa hesabu.\n\nMifano:\n- Ikiwa ingizo ni [3, 7, 5], kazi inarejesha 1 au 9, kwa kuwa mlolongo ungeweza kuwa [1, 3, 5, 7] au [3, 5, 7, 9].\n- Ikiwa ingizo ni [20, 14, 8], kazi inarejesha 26 au 2, kwa kuwa mlolongo ungeweza kuwa [2, 8, 14, 20] au [8, 14, 20, 26].\n*/",
      "tr": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nBir aritmetik dizide eksik olan sayıyı bulur.\n\nGirdi, dizide bir sayı kaybolduktan sonra kalan sayıların temsil edildiği üç tam sayıdan oluşan bir dizidir. Fonksiyon, eksik olan sayıyı döndürür. Orijinal dört sayılık dizi aritmetik bir diziydi.\n\nÖrnekler:\n- Eğer girdi [3, 7, 5] ise, fonksiyon 1 veya 9 döndürür, çünkü dizi [1, 3, 5, 7] veya [3, 5, 7, 9] olabilirdi.\n- Eğer girdi [20, 14, 8] ise, fonksiyon 26 veya 2 döndürür, çünkü dizi [2, 8, 14, 20] veya [8, 14, 20, 26] olabilirdi.\n*/",
      "vi": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nTìm số bị thiếu trong một dãy số ban đầu là một cấp số cộng.\n\nĐầu vào là một mảng gồm ba số nguyên, đại diện cho các số còn lại của dãy sau khi một số bị mất. Hàm trả về số bị thiếu. Dãy số gốc gồm bốn số là một cấp số cộng.\n\nVí dụ:\n- Nếu đầu vào là [3, 7, 5], hàm trả về 1 hoặc 9, vì dãy số có thể đã là [1, 3, 5, 7] hoặc [3, 5, 7, 9].\n- Nếu đầu vào là [20, 14, 8], hàm trả về 26 hoặc 2, vì dãy số có thể đã là [2, 8, 14, 20] hoặc [8, 14, 20, 26].\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9960988993164748",
      "arb": "0.9872957994593896",
      "sw": "0.9903304744208407",
      "tr": "0.9583994488871961",
      "vi": "0.9791845292194489"
    },
    "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func findMissingNumber(in numbers: [Int]) -> Int {` to solve the following problem:\n\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n",
      "es": "Escribe una función en Swift `func findMissingNumber(in numbers: [Int]) -> Int {` para resolver el siguiente problema:\n\nEncuentra el número que falta en una secuencia que originalmente era una progresión aritmética.\n\nLa entrada es un arreglo de tres enteros, que representa los números restantes de la secuencia después de que se pierde un número. La función devuelve el número que falta. La secuencia original de cuatro números estaba en progresión aritmética.\n\nEjemplos:\n- Si la entrada es [3, 7, 5], la función devuelve 1 o 9, ya que la secuencia podría haber sido [1, 3, 5, 7] o [3, 5, 7, 9].\n- Si la entrada es [20, 14, 8], la función devuelve 26 o 2, ya que la secuencia podría haber sido [2, 8, 14, 20] o [8, 14, 20, 26].",
      "arb": "اكتب دالة Swift `func findMissingNumber(in numbers: [Int]) -> Int {` لحل المشكلة التالية:\n\nتجد الرقم المفقود في تسلسل كان في الأصل متتابعة حسابية.\n\nالمدخل هو مصفوفة تحتوي على ثلاثة أعداد صحيحة، تمثل الأرقام المتبقية من التسلسل بعد فقدان رقم واحد. تقوم الدالة بإرجاع الرقم المفقود. كان التسلسل الأصلي المكون من أربعة أرقام في متتابعة حسابية.\n\nأمثلة:\n- إذا كان المدخل هو [3, 7, 5]، فإن الدالة تعيد 1 أو 9، حيث يمكن أن يكون التسلسل [1, 3, 5, 7] أو [3, 5, 7, 9].\n- إذا كان المدخل هو [20, 14, 8]، فإن الدالة تعيد 26 أو 2، حيث يمكن أن يكون التسلسل [2, 8, 14, 20] أو [8, 14, 20, 26].",
      "sw": "Andika kazi ya Swift `func findMissingNumber(in numbers: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nInapata namba inayokosekana katika mlolongo ambao awali ulikuwa ni mfululizo wa hesabu.\n\nIngizo ni safu ya namba tatu za mzima, zinazoashiria namba zilizobaki za mlolongo baada ya namba moja kupotea. Kazi inarudisha namba inayokosekana. Mlolongo wa awali wa namba nne ulikuwa katika mfululizo wa hesabu.\n\nMifano:\n- Ikiwa ingizo ni [3, 7, 5], kazi inarudisha 1 au 9, kwa kuwa mlolongo ungeweza kuwa [1, 3, 5, 7] au [3, 5, 7, 9].\n- Ikiwa ingizo ni [20, 14, 8], kazi inarudisha 26 au 2, kwa kuwa mlolongo ungeweza kuwa [2, 8, 14, 20] au [8, 14, 20, 26].",
      "tr": "Bir Swift fonksiyonu `func findMissingNumber(in numbers: [Int]) -> Int {` yazarak aşağıdaki problemi çözün:\n\nBaşlangıçta aritmetik bir dizi olan bir dizide eksik olan sayıyı bulur.\n\nGirdi, diziden bir sayı kaybolduktan sonra dizinin kalan sayıları olan üç tam sayıdan oluşan bir dizidir. Fonksiyon eksik olan sayıyı döndürür. Orijinal dört sayılık dizi aritmetik bir diziydi.\n\nÖrnekler:\n- Eğer girdi [3, 7, 5] ise, fonksiyon 1 veya 9 döndürür, çünkü dizi [1, 3, 5, 7] veya [3, 5, 7, 9] olabilirdi.\n- Eğer girdi [20, 14, 8] ise, fonksiyon 26 veya 2 döndürür, çünkü dizi [2, 8, 14, 20] veya [8, 14, 20, 26] olabilirdi.",
      "vi": "Viết một hàm Swift `func findMissingNumber(in numbers: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nTìm số bị thiếu trong một dãy số ban đầu là một cấp số cộng.\n\nĐầu vào là một mảng gồm ba số nguyên, đại diện cho các số còn lại của dãy sau khi một số bị mất. Hàm trả về số bị thiếu. Dãy số gốc gồm bốn số là một cấp số cộng.\n\nVí dụ:\n- Nếu đầu vào là [3, 7, 5], hàm trả về 1 hoặc 9, vì dãy số có thể là [1, 3, 5, 7] hoặc [3, 5, 7, 9].\n- Nếu đầu vào là [20, 14, 8], hàm trả về 26 hoặc 2, vì dãy số có thể là [2, 8, 14, 20] hoặc [8, 14, 20, 26]."
    },
    "instruction_bertscore": {
      "es": "0.991744722733809",
      "arb": "0.979509687153203",
      "sw": "0.9857405235758864",
      "tr": "0.9695366543518223",
      "vi": "0.9821985466212723"
    },
    "level": "hard",
    "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()",
    "entry_point": "findMissingNumber",
    "signature": "func findMissingNumber(in numbers: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n",
      "es": "Encuentra el número que falta en una secuencia que originalmente era una progresión aritmética.\n\nLa entrada es un arreglo de tres enteros, que representan los números restantes de la secuencia después de que se pierde un número. La función devuelve el número que falta. La secuencia original de cuatro números estaba en progresión aritmética.\n\nEjemplos:\n- Si la entrada es [3, 7, 5], la función devuelve 1 o 9, ya que la secuencia podría haber sido [1, 3, 5, 7] o [3, 5, 7, 9].\n- Si la entrada es [20, 14, 8], la función devuelve 26 o 2, ya que la secuencia podría haber sido [2, 8, 14, 20] o [8, 14, 20, 26].",
      "arb": "يعثر على الرقم المفقود في تسلسل كان في الأصل متتابعة حسابية.\n\nالمدخل هو مصفوفة تحتوي على ثلاثة أعداد صحيحة، تمثل الأرقام المتبقية من التسلسل بعد فقدان رقم واحد. تُرجع الدالة الرقم المفقود. كان التسلسل الأصلي المكون من أربعة أرقام في متتابعة حسابية.\n\nأمثلة:\n- إذا كان المدخل هو [3, 7, 5]، تُرجع الدالة 1 أو 9، حيث يمكن أن يكون التسلسل [1, 3, 5, 7] أو [3, 5, 7, 9].\n- إذا كان المدخل هو [20, 14, 8]، تُرجع الدالة 26 أو 2، حيث يمكن أن يكون التسلسل [2, 8, 14, 20] أو [8, 14, 20, 26].",
      "sw": "Inapata nambari iliyokosekana katika mlolongo ambao awali ulikuwa ni mfululizo wa hesabu.\n\nIngizo ni safu ya nambari tatu za mzima, zinazoashiria nambari zilizobaki za mlolongo baada ya nambari moja kupotea. Kazi inarejesha nambari iliyokosekana. Mlolongo wa awali wa nambari nne ulikuwa katika mfululizo wa hesabu.\n\nMifano:\n- Ikiwa ingizo ni [3, 7, 5], kazi inarejesha 1 au 9, kwa kuwa mlolongo ungeweza kuwa [1, 3, 5, 7] au [3, 5, 7, 9].\n- Ikiwa ingizo ni [20, 14, 8], kazi inarejesha 26 au 2, kwa kuwa mlolongo ungeweza kuwa [2, 8, 14, 20] au [8, 14, 20, 26].",
      "tr": "Eksik sayıyı başlangıçta bir aritmetik dizi olan bir dizide bulur.\n\nGirdi, bir sayının kaybolmasından sonra dizinin kalan sayılarını temsil eden üç tam sayıdan oluşan bir dizidir. Fonksiyon eksik olan sayıyı döndürür. Dört sayıdan oluşan orijinal dizi aritmetik bir diziydi.\n\nÖrnekler:\n- Girdi [3, 7, 5] ise, fonksiyon 1 veya 9 döndürür, çünkü dizi [1, 3, 5, 7] veya [3, 5, 7, 9] olabilirdi.\n- Girdi [20, 14, 8] ise, fonksiyon 26 veya 2 döndürür, çünkü dizi [2, 8, 14, 20] veya [8, 14, 20, 26] olabilirdi.",
      "vi": "Tìm số bị thiếu trong một dãy số ban đầu là một cấp số cộng.\n\nĐầu vào là một mảng gồm ba số nguyên, đại diện cho các số còn lại của dãy sau khi một số bị mất. Hàm trả về số bị thiếu. Dãy số gốc gồm bốn số là một cấp số cộng.\n\nVí dụ:\n- Nếu đầu vào là [3, 7, 5], hàm trả về 1 hoặc 9, vì dãy số có thể đã là [1, 3, 5, 7] hoặc [3, 5, 7, 9].\n- Nếu đầu vào là [20, 14, 8], hàm trả về 26 hoặc 2, vì dãy số có thể đã là [2, 8, 14, 20] hoặc [8, 14, 20, 26]."
    },
    "docstring_bertscore": {
      "es": "0.9920778258828045",
      "arb": "0.98428635055633",
      "sw": "0.9956629056301032",
      "tr": "0.979799886139895",
      "vi": "0.9794705569681391"
    }
  },
  {
    "task_id": "Swift/26",
    "prompt": {
      "en": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "es": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCuenta el número de veces que las madres son recordadas del comportamiento de un niño.\nUna madre es recordada si el número de porciones de comida que un niño ha tomado\n(excluyendo la actual) es mayor que el número total de porciones de comida\ntomadas por otros niños.\n\nEjemplo:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "arb": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nاحسب عدد المرات التي يتم فيها تذكير الأمهات بسلوك الطفل.\nيتم تذكير الأم إذا كان عدد حصص الطعام التي أخذها الطفل\n(باستثناء الحصة الحالية) أكبر من إجمالي عدد حصص الطعام\nالتي أخذها الأطفال الآخرون.\n\nمثال:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "sw": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nHesabu idadi ya mara ambazo mama anakumbushwa tabia ya mtoto.\nMama anakumbushwa ikiwa idadi ya sehemu za chakula ambazo mtoto amechukua\n(ukiondoa ya sasa) ni kubwa kuliko jumla ya sehemu za chakula\nzilizochukuliwa na watoto wengine.\n\nMfano:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "tr": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nAnnelerin bir çocuğun davranışını hatırladığı zamanların sayısını sayın.\nBir anne, bir çocuğun aldığı yemek porsiyonlarının sayısı\n(mevcut olan hariç) diğer çocuklar tarafından alınan toplam yemek porsiyonlarından\ndaha büyükse hatırlanır.\n\nÖrnek:\nGirdi: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nÇıktı: 1\n*/",
      "vi": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nĐếm số lần các bà mẹ được nhắc nhở về hành vi của một đứa trẻ.\nMột bà mẹ được nhắc nhở nếu số phần ăn mà một đứa trẻ đã lấy\n(ngoại trừ phần hiện tại) lớn hơn tổng số phần ăn\nđược lấy bởi các đứa trẻ khác.\n\nVí dụ:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9919586476541836",
      "arb": "0.9715362663977005",
      "sw": "0.9888492876694635",
      "tr": "0.9407952354768361",
      "vi": "0.9730677066354795"
    },
    "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}",
    "instruction": {
      "en": "Write a Swift function `func countUnfairReminders(_ children: [String]) -> Int {` to solve the following problem:\n\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n",
      "es": "Escribe una función de Swift `func countUnfairReminders(_ children: [String]) -> Int {` para resolver el siguiente problema:\n\nCuenta el número de veces que las madres son recordadas del comportamiento de un niño.\nUna madre es recordada si el número de porciones de comida que un niño ha tomado\n(excluyendo la actual) es mayor que el número total de porciones de comida\ntomadas por otros niños.\n\nEjemplo:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "arb": "اكتب دالة Swift `func countUnfairReminders(_ children: [String]) -> Int {` لحل المشكلة التالية:\n\nاحسب عدد المرات التي يتم فيها تذكير الأمهات بسلوك الطفل.\nيتم تذكير الأم إذا كان عدد حصص الطعام التي أخذها الطفل\n(باستثناء الحصة الحالية) أكبر من العدد الإجمالي لحصص الطعام\nالتي أخذها الأطفال الآخرون.\n\nمثال:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "sw": "Andika kazi ya Swift `func countUnfairReminders(_ children: [String]) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya mara ambazo mama anakumbushwa kuhusu tabia ya mtoto.\nMama anakumbushwa ikiwa idadi ya sehemu za chakula ambazo mtoto amechukua\n(ukiondoa ya sasa) ni kubwa kuliko jumla ya sehemu za chakula\nzilizochukuliwa na watoto wengine.\n\nMfano:\nIngizo: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nMatokeo: 1",
      "tr": "Bir Swift fonksiyonu `func countUnfairReminders(_ children: [String]) -> Int {` yazarak aşağıdaki problemi çözün:\n\nAnnelerin bir çocuğun davranışını hatırladığı zamanların sayısını sayın.\nBir anne, bir çocuğun aldığı yemek porsiyonlarının sayısı\n(mevcut olan hariç) diğer çocukların aldığı toplam yemek porsiyonlarından\nfazla olduğunda hatırlanır.\n\nÖrnek:\nGirdi: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nÇıktı: 1",
      "vi": "Viết một hàm Swift `func countUnfairReminders(_ children: [String]) -> Int {` để giải quyết vấn đề sau:\n\nĐếm số lần các bà mẹ bị nhắc nhở về hành vi của một đứa trẻ. \nMột bà mẹ bị nhắc nhở nếu số phần ăn mà một đứa trẻ đã lấy \n(ngoại trừ phần hiện tại) lớn hơn tổng số phần ăn \nđược lấy bởi các đứa trẻ khác.\n\nVí dụ:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1"
    },
    "instruction_bertscore": {
      "es": "0.9938525883373512",
      "arb": "0.9800757837391524",
      "sw": "0.9883038486431417",
      "tr": "0.9482724775405134",
      "vi": "0.9750496405774456"
    },
    "level": "middle",
    "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()",
    "entry_point": "countUnfairReminders",
    "signature": "func countUnfairReminders(_ children: [String]) -> Int {",
    "docstring": {
      "en": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n",
      "es": "Cuenta el número de veces que las madres son recordadas del comportamiento de un niño.  \nUna madre es recordada si el número de porciones de comida que un niño ha tomado  \n(excluyendo la actual) es mayor que el número total de porciones de comida  \ntomadas por otros niños.\n\nEjemplo:  \nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nOutput: 1  ",
      "arb": "احسب عدد المرات التي يتم فيها تذكير الأمهات بسلوك الطفل. \nيتم تذكير الأم إذا كان عدد حصص الطعام التي أخذها الطفل \n(باستثناء الحصة الحالية) أكبر من العدد الإجمالي لحصص الطعام \nالتي أخذها الأطفال الآخرون.\n\nمثال:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "sw": "Hesabu idadi ya mara ambazo mama wanakumbushwa kuhusu tabia ya mtoto.\nMama anakumbushwa ikiwa idadi ya sehemu za chakula ambazo mtoto amechukua\n(ukiondoa ya sasa) ni kubwa kuliko jumla ya sehemu za chakula\nzilizochukuliwa na watoto wengine.\n\nMfano:\nIngizo: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nMatokeo: 1",
      "tr": "Bir çocuğun davranışını hatırlatıldığı zamanların sayısını sayın.\nBir anne, bir çocuğun aldığı yemek porsiyonlarının sayısı (mevcut olan hariç), diğer çocuklar tarafından alınan toplam yemek porsiyonlarının sayısından fazla olduğunda hatırlatılır.\n\nÖrnek:\nGirdi: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nÇıktı: 1",
      "vi": "Đếm số lần các bà mẹ được nhắc nhở về hành vi của một đứa trẻ.  \nMột bà mẹ được nhắc nhở nếu số phần ăn mà một đứa trẻ đã lấy  \n(ngoại trừ phần hiện tại) lớn hơn tổng số phần ăn  \nmà các đứa trẻ khác đã lấy.\n\nVí dụ:  \nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nOutput: 1  "
    },
    "docstring_bertscore": {
      "es": "0.9916009143379397",
      "arb": "0.9766412658206782",
      "sw": "0.9864625450109482",
      "tr": "0.9604385883789003",
      "vi": "0.9602363826510067"
    }
  },
  {
    "task_id": "Swift/27",
    "prompt": {
      "en": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "es": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalcula el número de manzanas completas restantes después de un cierto período de tiempo.\nComer una manzana toma una cierta cantidad de tiempo y solo puedes comer una manzana a la vez.\nLa función toma tres parámetros:\n- m: el número total de manzanas.\n- t: el tiempo que toma comer una manzana.\n- s: el tiempo total transcurrido.\nLa función devuelve el número de manzanas completas que quedan.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "arb": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nاحسب عدد التفاح الكامل المتبقي بعد مرور فترة زمنية معينة.\nتناول تفاحة يستغرق وقتًا معينًا ويمكنك تناول تفاحة واحدة فقط في كل مرة.\nتأخذ الدالة ثلاثة معلمات:\n- m: العدد الإجمالي للتفاح.\n- t: الوقت الذي يستغرقه تناول تفاحة واحدة.\n- s: إجمالي الوقت المنقضي.\nتعيد الدالة عدد التفاح الكامل المتبقي.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "sw": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nHesabu idadi ya tufaha kamili zilizobaki baada ya muda fulani.\nKula tufaha moja kunachukua muda fulani na unaweza kula tufaha moja tu kwa wakati mmoja.\nKazi hii inachukua vigezo vitatu:\n- m: jumla ya idadi ya tufaha.\n- t: muda unaochukua kula tufaha moja.\n- s: jumla ya muda uliopita.\nKazi hii inarudisha idadi ya tufaha kamili zilizobaki.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "tr": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nBelirli bir süre geçtikten sonra kalan bütün elma sayısını hesaplayın.\nBir elmayı yemek belirli bir zaman alır ve aynı anda sadece bir elma yiyebilirsiniz.\nFonksiyon üç parametre alır:\n- m: toplam elma sayısı.\n- t: bir elmayı yemek için geçen süre.\n- s: geçen toplam süre.\nFonksiyon, kalan bütün elma sayısını döndürür.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "vi": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nTính số lượng táo nguyên còn lại sau một khoảng thời gian nhất định.\nĂn một quả táo mất một khoảng thời gian nhất định và bạn chỉ có thể ăn một quả táo một lần.\nHàm nhận ba tham số:\n- m: tổng số táo.\n- t: thời gian để ăn một quả táo.\n- s: tổng thời gian đã trôi qua.\nHàm trả về số lượng táo nguyên còn lại.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/"
    },
    "prompt_bertscore": {
      "es": "0.980443448574448",
      "arb": "0.9812345933821099",
      "sw": "0.9587087163904674",
      "tr": "0.9640620037897387",
      "vi": "0.9609415205036806"
    },
    "canonical_solution": "let eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}",
    "instruction": {
      "en": "Write a Swift function `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` to solve the following problem:\n\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "es": "Escribe una función en Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` para resolver el siguiente problema:\n\nCalcular el número de manzanas completas restantes después de un cierto período de tiempo.\nComer una manzana toma una cierta cantidad de tiempo y solo puedes comer una manzana a la vez.\nLa función toma tres parámetros:\n- m: el número total de manzanas.\n- t: el tiempo que toma comer una manzana.\n- s: el tiempo total transcurrido.\nLa función devuelve el número de manzanas completas que quedan.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "arb": "اكتب دالة Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` لحل المشكلة التالية:\n\nاحسب عدد التفاح الكامل المتبقي بعد مرور فترة زمنية معينة. \nتناول تفاحة يستغرق وقتًا معينًا ولا يمكنك تناول أكثر من تفاحة واحدة في نفس الوقت.\nتأخذ الدالة ثلاثة معلمات:\n- m: العدد الإجمالي للتفاح.\n- t: الوقت الذي يستغرقه تناول تفاحة واحدة.\n- s: إجمالي الوقت المنقضي.\nتعيد الدالة عدد التفاح الكامل المتبقي.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "sw": "Andika kazi ya Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya maapulo kamili yaliyobaki baada ya muda fulani.\nKula apulo moja kunachukua muda fulani na unaweza kula apulo moja tu kwa wakati mmoja.\nKazi inachukua vigezo vitatu:\n- m: jumla ya idadi ya maapulo.\n- t: muda unaochukua kula apulo moja.\n- s: jumla ya muda uliopita.\nKazi inarudisha idadi ya maapulo kamili yaliyobaki.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "tr": "Bir Swift fonksiyonu `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nBelirli bir süre sonra kalan bütün elma sayısını hesaplayın.\nBir elmayı yemek belirli bir süre alır ve aynı anda sadece bir elma yiyebilirsiniz.\nFonksiyon üç parametre alır:\n- m: toplam elma sayısı.\n- t: bir elmayı yemek için geçen süre.\n- s: geçen toplam süre.\nFonksiyon, kalan bütün elma sayısını döndürür.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "vi": "Viết một hàm Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` để giải quyết vấn đề sau:\n\nTính số lượng táo nguyên còn lại sau một khoảng thời gian nhất định. \nĂn một quả táo mất một khoảng thời gian nhất định và bạn chỉ có thể ăn một quả táo mỗi lần. \nHàm nhận ba tham số:\n- m: tổng số lượng táo.\n- t: thời gian cần để ăn một quả táo.\n- s: tổng thời gian đã trôi qua.\nHàm trả về số lượng táo nguyên còn lại.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0"
    },
    "instruction_bertscore": {
      "es": "0.976589026030466",
      "arb": "0.9677068712817289",
      "sw": "0.9724660552113248",
      "tr": "0.9647689293158419",
      "vi": "0.965583512508466"
    },
    "level": "easy",
    "test": "func check(_ remainingApples: (Int, Int, Int) -> Int) {\nassert(remainingApples(50, 10, 200) == 30)\nassert(remainingApples(100, 5, 1000) == 0)\nassert(remainingApples(75, 15, 300) == 55)\nassert(remainingApples(20, 20, 400) == 0)\nassert(remainingApples(30, 10, 300) == 0)\nassert(remainingApples(40, 15, 600) == 0)\nassert(remainingApples(60, 10, 600) == 0)\n}\n\ncheck(remainingApples)",
    "entry_point": "remainingApples",
    "signature": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {",
    "docstring": {
      "en": "\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "es": "Calcular el número de manzanas enteras restantes después de un cierto período de tiempo. Comer una manzana lleva un cierto tiempo y solo se puede comer una manzana a la vez. La función toma tres parámetros:\n- m: el número total de manzanas.\n- t: el tiempo que lleva comer una manzana.\n- s: el tiempo total transcurrido.\nLa función devuelve el número de manzanas enteras que quedan.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "arb": "احسب عدد التفاح الكامل المتبقي بعد مرور فترة زمنية معينة. \nتناول تفاحة يستغرق وقتًا معينًا ويمكنك تناول تفاحة واحدة فقط في كل مرة. \nتأخذ الدالة ثلاثة معلمات:\n- m: العدد الإجمالي للتفاح.\n- t: الوقت الذي يستغرقه تناول تفاحة واحدة.\n- s: إجمالي الوقت المنقضي.\nتعيد الدالة عدد التفاح الكامل المتبقي.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "sw": "Hesabu idadi ya maapulo kamili yaliyobaki baada ya muda fulani.\nKula tofaa moja huchukua muda fulani na unaweza kula tofaa moja tu kwa wakati mmoja.\nKazi inachukua vigezo vitatu:\n- m: jumla ya idadi ya maapulo.\n- t: muda unaochukua kula tofaa moja.\n- s: jumla ya muda uliopita.\nKazi inarudisha idadi ya maapulo kamili yaliyobaki.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "tr": "Tam elmaların belirli bir süre sonra kalan sayısını hesaplayın.  \nBir elmayı yemek belirli bir zaman alır ve aynı anda yalnızca bir elma yiyebilirsiniz.  \nFonksiyon üç parametre alır:  \n- m: toplam elma sayısı.  \n- t: bir elmayı yemek için gereken süre.  \n- s: geçen toplam süre.  \nFonksiyon, kalan tam elma sayısını döndürür.  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  ",
      "vi": "Tính số lượng táo nguyên còn lại sau một khoảng thời gian nhất định.  \nĂn một quả táo mất một khoảng thời gian nhất định và bạn chỉ có thể ăn một quả táo một lần.  \nHàm nhận ba tham số:  \n- m: tổng số lượng táo.  \n- t: thời gian để ăn một quả táo.  \n- s: tổng thời gian đã trôi qua.  \nHàm trả về số lượng táo nguyên còn lại.  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.9649592172208733",
      "arb": "0.9760523267409097",
      "sw": "0.9530916478451819",
      "tr": "0.9592436280065944",
      "vi": "0.9601893072507015"
    }
  },
  {
    "task_id": "Swift/28",
    "prompt": {
      "en": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "es": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nVerifica si el entero dado es del agrado de las cuatro personas:\n- A la Persona A le gusta el entero si es par y está entre 4 y 12 (inclusive).\n- A la Persona U le gusta el entero si es par o está entre 4 y 12 (inclusive).\n- A la Persona H le gusta el entero si tiene exactamente una de las dos propiedades (par o entre 4 y 12).\n- A la Persona G le gusta el entero si no tiene ambas propiedades (par y entre 4 y 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "arb": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nيتحقق مما إذا كان العدد الصحيح المعطى محبوبًا من قبل الأفراد الأربعة:\n- الشخص A يحب العدد إذا كان زوجيًا وبين 4 و 12 (شامل).\n- الشخص U يحب العدد إذا كان إما زوجيًا أو بين 4 و 12 (شامل).\n- الشخص H يحب العدد إذا كان يمتلك خاصية واحدة فقط من الخاصيتين (زوجي أو بين 4 و 12).\n- الشخص G يحب العدد إذا لم يكن لديه كلا الخاصيتين (زوجي وبين 4 و 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "sw": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nHukagua kama namba nzima iliyotolewa inapendwa na watu wanne:\n- Mtu A anapenda namba hiyo ikiwa ni shufwa na iko kati ya 4 na 12 (pamoja na 4 na 12).\n- Mtu U anapenda namba hiyo ikiwa ni shufwa au iko kati ya 4 na 12 (pamoja na 4 na 12).\n- Mtu H anapenda namba hiyo ikiwa ina sifa moja tu kati ya mbili (shufwa au kati ya 4 na 12).\n- Mtu G anapenda namba hiyo ikiwa haina sifa zote mbili (shufwa na kati ya 4 na 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "tr": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nVerilen tam sayının dört kişi tarafından beğenilip beğenilmediğini kontrol eder:\n- Kişi A, tam sayı hem çift hem de 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi U, tam sayı ya çift ya da 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi H, tam sayı tam olarak iki özelliğinden birine sahipse (çift veya 4 ile 12 arasında) tam sayıyı beğenir.\n- Kişi G, tam sayı her iki özelliğe de sahip değilse (çift ve 4 ile 12 arasında) tam sayıyı beğenir.\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "vi": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nKiểm tra xem số nguyên đã cho có được bốn người thích hay không:\n- Người A thích số nguyên nếu nó vừa là số chẵn và nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người U thích số nguyên nếu nó là số chẵn hoặc nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người H thích số nguyên nếu nó có chính xác một trong hai thuộc tính (chẵn hoặc nằm trong khoảng từ 4 đến 12).\n- Người G thích số nguyên nếu nó không có cả hai thuộc tính (chẵn và nằm trong khoảng từ 4 đến 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9653481355069397",
      "arb": "0.955119664035548",
      "sw": "0.9448836446096771",
      "tr": "0.9795317351254978",
      "vi": "0.9255751825300378"
    },
    "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}",
    "instruction": {
      "en": "Write a Swift function `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` to solve the following problem:\n\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n",
      "es": "Escribe una función Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` para resolver el siguiente problema:\n\nVerifica si el entero dado es del agrado de las cuatro personas:\n- A la Persona A le gusta el entero si es par y está entre 4 y 12 (inclusive).\n- A la Persona U le gusta el entero si es par o está entre 4 y 12 (inclusive).\n- A la Persona H le gusta el entero si tiene exactamente una de las dos propiedades (par o entre 4 y 12).\n- A la Persona G le gusta el entero si no tiene ambas propiedades (par y entre 4 y 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "arb": "اكتب دالة Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` لحل المشكلة التالية:\n\nيتحقق مما إذا كان العدد الصحيح المعطى محبوبًا من قبل الأفراد الأربعة:\n- الشخص A يحب العدد الصحيح إذا كان زوجيًا وبين 4 و 12 (شامل).\n- الشخص U يحب العدد الصحيح إذا كان إما زوجيًا أو بين 4 و 12 (شامل).\n- الشخص H يحب العدد الصحيح إذا كان يملك بالضبط واحدة من الخاصيتين (زوجي أو بين 4 و 12).\n- الشخص G يحب العدد الصحيح إذا لم يكن لديه كلتا الخاصيتين (زوجي وبين 4 و 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "sw": "Andika kazi ya Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` kutatua tatizo lifuatalo:\n\nHukagua kama nambari kamili iliyotolewa inapendwa na watu wanne:\n- Mtu A anapenda nambari kamili ikiwa ni shufwa na kati ya 4 na 12 (ikijumuishwa).\n- Mtu U anapenda nambari kamili ikiwa ni shufwa au kati ya 4 na 12 (ikijumuishwa).\n- Mtu H anapenda nambari kamili ikiwa ina sifa moja tu kati ya mbili (shufwa au kati ya 4 na 12).\n- Mtu G anapenda nambari kamili ikiwa haina sifa zote mbili (shufwa na kati ya 4 na 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "tr": "Bir Swift fonksiyonu `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` yazın ve aşağıdaki problemi çözün:\n\nVerilen tamsayının dört kişi tarafından beğenilip beğenilmediğini kontrol eder:\n- Kişi A, tamsayı hem çift hem de 4 ile 12 arasında (dahil) ise tamsayıyı beğenir.\n- Kişi U, tamsayı ya çift ya da 4 ile 12 arasında (dahil) ise tamsayıyı beğenir.\n- Kişi H, tamsayı tam olarak iki özelliğin birine sahipse (çift veya 4 ile 12 arasında) tamsayıyı beğenir.\n- Kişi G, tamsayı her iki özelliğe de sahip değilse (çift ve 4 ile 12 arasında) tamsayıyı beğenir.\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "vi": "Viết một hàm Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` để giải quyết vấn đề sau:\n\nKiểm tra xem số nguyên đã cho có được bốn cá nhân thích hay không:\n- Người A thích số nguyên nếu nó vừa là số chẵn và nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người U thích số nguyên nếu nó là số chẵn hoặc nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người H thích số nguyên nếu nó chính xác là một trong hai thuộc tính (số chẵn hoặc nằm trong khoảng từ 4 đến 12).\n- Người G thích số nguyên nếu nó không có cả hai thuộc tính (số chẵn và nằm trong khoảng từ 4 đến 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)"
    },
    "instruction_bertscore": {
      "es": "0.9662697804749415",
      "arb": "0.9791108373480849",
      "sw": "0.9591172990842562",
      "tr": "0.9748712704952763",
      "vi": "0.9261367106172234"
    },
    "level": "hard",
    "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)",
    "entry_point": "checkLikes",
    "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {",
    "docstring": {
      "en": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n",
      "es": "Verifica si el entero dado es del agrado de las cuatro personas:\n- A la Persona A le gusta el entero si es par y está entre 4 y 12 (inclusive).\n- A la Persona U le gusta el entero si es par o está entre 4 y 12 (inclusive).\n- A la Persona H le gusta el entero si tiene exactamente una de las dos propiedades (par o entre 4 y 12).\n- A la Persona G le gusta el entero si no tiene ambas propiedades (par y entre 4 y 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "arb": "يتحقق مما إذا كان العدد الصحيح المعطى محببًا للأربعة أفراد:\n- الشخص A يحب العدد الصحيح إذا كان زوجيًا وبين 4 و 12 (شامل).\n- الشخص U يحب العدد الصحيح إذا كان إما زوجيًا أو بين 4 و 12 (شامل).\n- الشخص H يحب العدد الصحيح إذا كان يحقق بالضبط واحدة من الخاصيتين (زوجي أو بين 4 و 12).\n- الشخص G يحب العدد الصحيح إذا لم يكن لديه كلا الخاصيتين (زوجي وبين 4 و 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "sw": "Hukagua ikiwa nambari kamili iliyotolewa inapendwa na watu wanne:\n- Mtu A anapenda nambari hiyo ikiwa ni shufwa na iko kati ya 4 na 12 (ikijumuishwa).\n- Mtu U anapenda nambari hiyo ikiwa ni shufwa au iko kati ya 4 na 12 (ikijumuishwa).\n- Mtu H anapenda nambari hiyo ikiwa ina moja tu ya sifa mbili (shufwa au kati ya 4 na 12).\n- Mtu G anapenda nambari hiyo ikiwa haina sifa zote mbili (shufwa na kati ya 4 na 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "tr": "Verilen tam sayının dört kişi tarafından beğenilip beğenilmediğini kontrol eder:\n- Kişi A, tam sayı hem çift hem de 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi U, tam sayı ya çift ya da 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi H, tam sayı tam olarak iki özelliğinden birine sahipse (çift veya 4 ile 12 arasında) tam sayıyı beğenir.\n- Kişi G, tam sayı her iki özelliğe de sahip değilse (çift ve 4 ile 12 arasında) tam sayıyı beğenir.\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "vi": "Kiểm tra xem số nguyên đã cho có được bốn cá nhân thích hay không:\n- Người A thích số nguyên nếu nó vừa là số chẵn và nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người U thích số nguyên nếu nó là số chẵn hoặc nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người H thích số nguyên nếu nó có chính xác một trong hai thuộc tính (số chẵn hoặc nằm trong khoảng từ 4 đến 12).\n- Người G thích số nguyên nếu nó không có cả hai thuộc tính (số chẵn và nằm trong khoảng từ 4 đến 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9648245458225316",
      "arb": "0.9594140528735223",
      "sw": "0.9296502834273496",
      "tr": "0.9584266612493979",
      "vi": "0.9052817123908463"
    }
  },
  {
    "task_id": "Swift/29",
    "prompt": {
      "en": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "es": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDeterminar si un año dado es un año bisiesto.\nUn año bisiesto es exactamente divisible por 4, excepto los años de fin de siglo que deben ser divisibles por 400.\nEsto significa que el año 2000 fue un año bisiesto, aunque 1900 no lo fue.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "arb": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nتحديد ما إذا كانت السنة المعطاة سنة كبيسة.\nالسنة الكبيسة تقبل القسمة تمامًا على 4 باستثناء السنوات التي تنتهي بالقرن والتي يجب أن تقبل القسمة على 400.\nهذا يعني أن سنة 2000 كانت سنة كبيسة، على الرغم من أن سنة 1900 لم تكن كذلك.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "sw": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nTambua kama mwaka fulani ni mwaka wa kuruka.\nMwaka wa kuruka hugawanyika kwa 4 isipokuwa miaka ya mwisho wa karne ambayo lazima yagawanyike kwa 400.\nHii inamaanisha kuwa mwaka 2000 ulikuwa mwaka wa kuruka, ingawa 1900 haukuwa.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "tr": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nBelirtilen bir yılın artık yıl olup olmadığını belirleyin.\nArtık yıl, yüzyıl sonu yılları hariç tam olarak 4'e bölünebilen bir yıldır ve bu yıllar 400'e bölünebilmelidir.\nBu, 2000 yılının artık yıl olduğu anlamına gelir, ancak 1900 yılı değildir.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "vi": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nXác định xem một năm cho trước có phải là năm nhuận hay không.\nMột năm nhuận chia hết cho 4, ngoại trừ các năm cuối thế kỷ phải chia hết cho 400.\nĐiều này có nghĩa là năm 2000 là năm nhuận, mặc dù năm 1900 không phải.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9980685181748168",
      "arb": "0.9847253236984171",
      "sw": "0.9945803700534631",
      "tr": "0.9739351255094588",
      "vi": "0.9861153391048992"
    },
    "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func isLeapYear(_ year: Int) -> Int {` to solve the following problem:\n\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "es": "Escribe una función Swift `func isLeapYear(_ year: Int) -> Int {` para resolver el siguiente problema:\n\nDeterminar si un año dado es un año bisiesto.\nUn año bisiesto es exactamente divisible por 4, excepto los años de fin de siglo que deben ser divisibles por 400.\nEsto significa que el año 2000 fue un año bisiesto, aunque 1900 no lo fue.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "arb": "اكتب دالة Swift `func isLeapYear(_ year: Int) -> Int {` لحل المشكلة التالية:\n\nتحديد ما إذا كانت السنة المعطاة سنة كبيسة.\nالسنة الكبيسة تقبل القسمة تمامًا على 4 باستثناء السنوات التي تنتهي بقرن والتي يجب أن تقبل القسمة على 400.\nهذا يعني أن سنة 2000 كانت سنة كبيسة، على الرغم من أن سنة 1900 لم تكن كذلك.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "sw": "Andika kazi ya Swift `func isLeapYear(_ year: Int) -> Int {` kutatua tatizo lifuatalo:\n\nTambua ikiwa mwaka uliotolewa ni mwaka wa kuruka.\nMwaka wa kuruka unagawanyika kabisa kwa 4 isipokuwa kwa miaka ya mwisho wa karne ambayo lazima yagawanyike kwa 400.\nHii inamaanisha kwamba mwaka 2000 ulikuwa mwaka wa kuruka, ingawa 1900 haukuwa.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "tr": "Bir Swift fonksiyonu `func isLeapYear(_ year: Int) -> Int {` yazın:\n\nVerilen bir yılın artık yıl olup olmadığını belirleyin.\nArtık yıl, 4 ile tam bölünebilir, ancak yüzyılın sonundaki yıllar 400 ile bölünebilir olmalıdır.\nBu, 2000 yılının artık yıl olduğu anlamına gelir, ancak 1900 yılı değildir.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "vi": "Viết một hàm Swift `func isLeapYear(_ year: Int) -> Int {` để giải quyết vấn đề sau:\n\nXác định xem một năm cho trước có phải là năm nhuận hay không.  \nMột năm nhuận chia hết cho 4 ngoại trừ những năm cuối thế kỷ phải chia hết cho 400.  \nĐiều này có nghĩa là năm 2000 là một năm nhuận, mặc dù năm 1900 thì không.  \n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n"
    },
    "instruction_bertscore": {
      "es": "0.9973099487496445",
      "arb": "0.9880517866896084",
      "sw": "0.992843546001694",
      "tr": "0.9481086074761595",
      "vi": "0.9891762332766468"
    },
    "level": "easy",
    "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)",
    "entry_point": "isLeapYear",
    "signature": "func isLeapYear(_ year: Int) -> Int {",
    "docstring": {
      "en": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "es": "Determinar si un año dado es un año bisiesto.  \nUn año bisiesto es exactamente divisible por 4, excepto los años de fin de siglo que deben ser divisibles por 400.  \nEsto significa que el año 2000 fue un año bisiesto, aunque 1900 no lo fue.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "arb": "تحديد ما إذا كانت السنة المعطاة سنة كبيسة.\nالسنة الكبيسة هي التي تقبل القسمة تمامًا على 4 باستثناء السنوات التي تنتهي بالقرن والتي يجب أن تكون قابلة للقسمة على 400.\nهذا يعني أن سنة 2000 كانت سنة كبيسة، بينما سنة 1900 لم تكن كذلك.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "sw": "Tambua ikiwa mwaka uliotolewa ni mwaka wa kisiku.\nMwaka wa kisiku unagawanyika kwa 4 isipokuwa kwa miaka ya mwisho wa karne ambayo lazima yagawanyike kwa 400.\nHii inamaanisha kwamba mwaka 2000 ulikuwa mwaka wa kisiku, ingawa 1900 haukuwa.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "tr": "Belirtilen bir yılın artık yıl olup olmadığını belirleyin.\nArtık yıl, yüzyıl sonu yılları hariç tam olarak 4'e bölünebilen yıldır ve bu yıllar 400'e bölünebilmelidir.\nBu, 2000 yılının artık yıl olduğu anlamına gelir, ancak 1900 yılı değildir.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "vi": "Xác định xem một năm cho trước có phải là năm nhuận hay không.  \nMột năm nhuận là năm chia hết cho 4, ngoại trừ những năm cuối thế kỷ phải chia hết cho 400.  \nĐiều này có nghĩa là năm 2000 là một năm nhuận, mặc dù năm 1900 thì không.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  "
    },
    "docstring_bertscore": {
      "es": "0.9982917787230999",
      "arb": "0.9607228284541612",
      "sw": "0.9808605723746213",
      "tr": "0.9714530402680469",
      "vi": "0.9758378059293921"
    }
  },
  {
    "task_id": "Swift/30",
    "prompt": {
      "en": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "es": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalcula el número de días en un mes dado de un año dado.\nTiene en cuenta si el año es bisiesto o no.\n\n- Parámetros:\n- year: El año para el cual calcular el número de días.\n- month: El mes para el cual calcular el número de días.\n\n- Retorna: El número de días en el mes dado del año dado.\n\nEjemplos:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "arb": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nيحسب عدد الأيام في شهر معين من سنة معينة.\nيأخذ في الاعتبار ما إذا كانت السنة سنة كبيسة أم لا.\n\n- Parameters:\n- year: السنة التي يتم حساب عدد الأيام لها.\n- month: الشهر الذي يتم حساب عدد الأيام له.\n\n- Returns: عدد الأيام في الشهر المعطى من السنة المعطاة.\n\nأمثلة:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "sw": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nHesabu idadi ya siku katika mwezi fulani wa mwaka fulani.\nInazingatia kama mwaka ni mwaka wa kisiku au la.\n\n- Vigezo:\n- year: Mwaka ambao unahesabu idadi ya siku.\n- month: Mwezi ambao unahesabu idadi ya siku.\n\n- Inarejesha: Idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa.\n\nMifano:\ndaysInMonth(1926, 8) // Inarejesha 31\ndaysInMonth(2000, 2) // Inarejesha 29\n*/",
      "tr": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nBelirtilen bir yılın belirtilen bir ayındaki gün sayısını hesaplar.\nYılın artık yıl olup olmadığını dikkate alır.\n\n- Parametreler:\n- year: Gün sayısını hesaplamak istediğiniz yıl.\n- month: Gün sayısını hesaplamak istediğiniz ay.\n\n- Döndürür: Belirtilen yılın belirtilen ayındaki gün sayısı.\n\nÖrnekler:\ndaysInMonth(1926, 8) // 31 döndürür\ndaysInMonth(2000, 2) // 29 döndürür\n*/",
      "vi": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nTính toán số ngày trong một tháng nhất định của một năm nhất định.\nXem xét liệu năm đó có phải là năm nhuận hay không.\n\n- Tham số:\n- year: Năm mà bạn muốn tính số ngày.\n- month: Tháng mà bạn muốn tính số ngày.\n\n- Trả về: Số ngày trong tháng nhất định của năm nhất định.\n\nVí dụ:\ndaysInMonth(1926, 8) // Trả về 31\ndaysInMonth(2000, 2) // Trả về 29\n*/"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9771606842670845",
      "sw": "0.9765081834653848",
      "tr": "0.9479181209407471",
      "vi": "0.9490737524976082"
    },
    "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "Write a Swift function `func daysInMonth(_ year: Int, _ month: Int) -> Int {` to solve the following problem:\n\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n",
      "es": "Escribe una función en Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` para resolver el siguiente problema:\n\nCalcula el número de días en un mes dado de un año dado.\nTiene en cuenta si el año es bisiesto o no.\n\n- Parámetros:\n- year: El año para el cual calcular el número de días.\n- month: El mes para el cual calcular el número de días.\n\n- Retorna: El número de días en el mes dado del año dado.\n\nEjemplos:\ndaysInMonth(1926, 8) // Retorna 31\ndaysInMonth(2000, 2) // Retorna 29",
      "arb": "اكتب دالة Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` لحل المشكلة التالية:\n\nتحسب عدد الأيام في شهر معين من سنة معينة. تأخذ في الاعتبار ما إذا كانت السنة سنة كبيسة أم لا.\n\n- المعاملات:\n- year: السنة التي سيتم حساب عدد الأيام لها.\n- month: الشهر الذي سيتم حساب عدد الأيام له.\n\n- العائدات: عدد الأيام في الشهر المعطى من السنة المعطاة.\n\nأمثلة:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29",
      "sw": "Andika kazi ya Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa. Inazingatia kama mwaka ni mwaka wa kuruka au la.\n\n- Vigezo:\n- year: Mwaka ambao unahesabu idadi ya siku.\n- month: Mwezi ambao unahesabu idadi ya siku.\n\n- Inarudisha: Idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa.\n\nMifano:\ndaysInMonth(1926, 8) // Inarudisha 31\ndaysInMonth(2000, 2) // Inarudisha 29",
      "tr": "Bir Swift fonksiyonu `func daysInMonth(_ year: Int, _ month: Int) -> Int {` yazarak aşağıdaki problemi çözün:\n\nVerilen bir yılın belirli bir ayındaki gün sayısını hesaplar. Yılın artık yıl olup olmadığını dikkate alır.\n\n- Parametreler:\n- year: Gün sayısını hesaplamak istediğiniz yıl.\n- month: Gün sayısını hesaplamak istediğiniz ay.\n\n- Döndürür: Verilen yılın belirli bir ayındaki gün sayısı.\n\nÖrnekler:\ndaysInMonth(1926, 8) // 31 döndürür\ndaysInMonth(2000, 2) // 29 döndürür",
      "vi": "Viết một hàm Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` để giải quyết vấn đề sau:\n\nTính toán số ngày trong một tháng cụ thể của một năm cụ thể. \nXem xét liệu năm đó có phải là năm nhuận hay không.\n\n- Tham số:\n- year: Năm cần tính số ngày.\n- month: Tháng cần tính số ngày.\n\n- Trả về: Số ngày trong tháng cụ thể của năm cụ thể.\n\nVí dụ:\ndaysInMonth(1926, 8) // Trả về 31\ndaysInMonth(2000, 2) // Trả về 29"
    },
    "instruction_bertscore": {
      "es": "0.9911825987554803",
      "arb": "0.973571830542546",
      "sw": "0.9710291630349185",
      "tr": "0.9752806477105892",
      "vi": "0.9505398433400266"
    },
    "level": "easy",
    "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()",
    "entry_point": "daysInMonth",
    "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n",
      "es": "Calcula el número de días en un mes dado de un año dado.  \nTiene en cuenta si el año es bisiesto o no.\n\n- Parámetros:\n- year: El año para el cual calcular el número de días.\n- month: El mes para el cual calcular el número de días.\n\n- Retorna: El número de días en el mes dado del año dado.\n\nEjemplos:\ndaysInMonth(1926, 8) // Retorna 31\ndaysInMonth(2000, 2) // Retorna 29",
      "arb": "يحسب عدد الأيام في شهر معين من سنة معينة. يأخذ في الاعتبار ما إذا كانت السنة كبيسة أم لا.\n\n- المعاملات:\n- year: السنة التي سيتم حساب عدد الأيام لها.\n- month: الشهر الذي سيتم حساب عدد الأيام له.\n\n- يعيد: عدد الأيام في الشهر المعطى من السنة المعطاة.\n\nأمثلة:\ndaysInMonth(1926, 8) // يعيد 31\ndaysInMonth(2000, 2) // يعيد 29",
      "sw": "Hesabu idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa. Inazingatia kama mwaka ni mwaka wa kuruka au la.\n\n- Vigezo:\n- year: Mwaka ambao unahesabu idadi ya siku.\n- month: Mwezi ambao unahesabu idadi ya siku.\n\n- Inarudisha: Idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa.\n\nMifano:\ndaysInMonth(1926, 8) // Inarudisha 31\ndaysInMonth(2000, 2) // Inarudisha 29",
      "tr": "Belirtilen bir yılın belirtilen bir ayındaki gün sayısını hesaplar.\nYılın artık yıl olup olmadığını dikkate alır.\n\n- Parametreler:\n- year: Gün sayısını hesaplamak için yıl.\n- month: Gün sayısını hesaplamak için ay.\n\n- Döndürür: Belirtilen yılın belirtilen ayındaki gün sayısı.\n\nÖrnekler:\ndaysInMonth(1926, 8) // 31 döndürür\ndaysInMonth(2000, 2) // 29 döndürür",
      "vi": "Tính toán số ngày trong một tháng cụ thể của một năm cụ thể.  \nXem xét liệu năm đó có phải là năm nhuận hay không.\n\n- Tham số:\n- year: Năm cần tính số ngày.\n- month: Tháng cần tính số ngày.\n\n- Trả về: Số ngày trong tháng cụ thể của năm cụ thể.\n\nVí dụ:\ndaysInMonth(1926, 8) // Trả về 31\ndaysInMonth(2000, 2) // Trả về 29"
    },
    "docstring_bertscore": {
      "es": "0.9970616607733509",
      "arb": "0.9645319632712672",
      "sw": "0.9455047618111733",
      "tr": "0.9337595487501993",
      "vi": "0.9519445573947054"
    }
  },
  {
    "task_id": "Swift/31",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "es": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nEncuentra el número mínimo de rotaciones de 180 grados necesarias para reorganizar los vagones de un tren en orden ascendente.\n\nLa función toma un arreglo de enteros que representa el orden inicial de los vagones del tren y devuelve el número mínimo de rotaciones necesarias para ordenarlos en orden ascendente.\n\nCasos de ejemplo:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "arb": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nيجد الحد الأدنى لعدد الدورانات بزاوية 180 درجة اللازمة لإعادة ترتيب عربات القطار بترتيب تصاعدي.\n\nتأخذ الدالة مصفوفة من الأعداد الصحيحة التي تمثل الترتيب الأولي لعربات القطار، وتعيد الحد الأدنى لعدد الدورانات المطلوبة لترتيبها بترتيب تصاعدي.\n\nأمثلة الحالات:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "sw": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nInapata idadi ndogo ya mizunguko ya digrii 180 inayohitajika kupanga upya magari ya treni katika mpangilio wa kupanda.\n\nKazi inachukua safu ya nambari za mzima inayowakilisha mpangilio wa awali wa magari ya treni, na inarudisha idadi ndogo ya mizunguko inayohitajika kuzipanga katika mpangilio wa kupanda.\n\nMifano ya kesi:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "tr": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nBir trenin vagonlarını artan sıraya göre yeniden düzenlemek için gereken minimum 180 derece dönüş sayısını bulur.\n\nFonksiyon, tren vagonlarının başlangıç sırasını temsil eden bir tamsayı dizisi alır ve onları artan sıraya göre düzenlemek için gereken minimum dönüş sayısını döndürür.\n\nÖrnek durumlar:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "vi": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nTìm số lần xoay 180 độ tối thiểu cần thiết để sắp xếp lại các toa tàu theo thứ tự tăng dần.\n\nHàm nhận vào một mảng số nguyên đại diện cho thứ tự ban đầu của các toa tàu, và trả về số lần xoay tối thiểu cần thiết để sắp xếp chúng theo thứ tự tăng dần.\n\nCác trường hợp ví dụ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9857584003101796",
      "arb": "0.9874386147033537",
      "sw": "0.9850002281457694",
      "tr": "0.9788830083010379",
      "vi": "0.979430036370408"
    },
    "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}",
    "instruction": {
      "en": "Write a Swift function `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` to solve the following problem:\n\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n",
      "es": "Escribe una función en Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` para resolver el siguiente problema:\n\nEncuentra el número mínimo de rotaciones de 180 grados necesarias para reorganizar los vagones de un tren en orden ascendente.\n\nLa función toma un arreglo de enteros que representa el orden inicial de los vagones del tren y devuelve el número mínimo de rotaciones necesarias para ordenarlos en orden ascendente.\n\nCasos de ejemplo:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "arb": "اكتب دالة Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` لحل المشكلة التالية:\n\nتجد الحد الأدنى لعدد التدويرات بزاوية 180 درجة اللازمة لإعادة ترتيب عربات القطار بترتيب تصاعدي.\n\nتأخذ الدالة مصفوفة من الأعداد الصحيحة التي تمثل الترتيب الأولي لعربات القطار، وتعيد الحد الأدنى لعدد التدويرات المطلوبة لترتيبها بترتيب تصاعدي.\n\nحالات المثال:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "sw": "Andika kazi ya Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nInapata idadi ndogo ya mizunguko ya digrii 180 inayohitajika kupanga upya magari ya treni katika mpangilio wa kupanda.\n\nKazi inachukua safu ya nambari za mzima zinazoashiria mpangilio wa awali wa magari ya treni, na inarejesha idadi ndogo ya mizunguko inayohitajika kuzipanga katika mpangilio wa kupanda.\n\nMifano ya kesi:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "tr": "Bir Swift fonksiyonu `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nBir trenin vagonlarını artan sıraya göre yeniden düzenlemek için gereken minimum 180 derece döndürme sayısını bulur.\n\nFonksiyon, tren vagonlarının başlangıç sırasını temsil eden bir tamsayı dizisi alır ve bunları artan sıraya göre düzenlemek için gereken minimum döndürme sayısını döndürür.\n\nÖrnek durumlar:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "vi": "Viết một hàm Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nTìm số lần xoay 180 độ tối thiểu cần thiết để sắp xếp lại các toa tàu thành thứ tự tăng dần.\n\nHàm nhận một mảng số nguyên đại diện cho thứ tự ban đầu của các toa tàu, và trả về số lần xoay tối thiểu cần thiết để sắp xếp chúng theo thứ tự tăng dần.\n\nCác trường hợp ví dụ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10"
    },
    "instruction_bertscore": {
      "es": "0.9814628196899191",
      "arb": "0.9830842394903069",
      "sw": "0.9826116978138248",
      "tr": "0.9710865672150375",
      "vi": "0.9796457489642119"
    },
    "level": "middle",
    "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)",
    "entry_point": "minimumSwapsToOrder",
    "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n",
      "es": "Encuentra el número mínimo de rotaciones de 180 grados necesarias para reorganizar los vagones de un tren en orden ascendente.\n\nLa función toma un arreglo de enteros que representa el orden inicial de los vagones del tren y devuelve el número mínimo de rotaciones necesarias para ordenarlos en orden ascendente.\n\nCasos de ejemplo:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "arb": "يعثر على الحد الأدنى لعدد الدورانات بزاوية 180 درجة اللازمة لإعادة ترتيب عربات القطار بترتيب تصاعدي.\n\nتأخذ الدالة مصفوفة من الأعداد الصحيحة التي تمثل الترتيب الأولي لعربات القطار، وتعيد الحد الأدنى لعدد الدورانات المطلوبة لترتيبها بترتيب تصاعدي.\n\nحالات المثال:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "sw": "Inapata idadi ndogo ya mizunguko ya digrii 180 inayohitajika kupanga upya magari ya treni katika mpangilio wa kupanda.\n\nKazi inachukua safu ya nambari za mzima inayoonyesha mpangilio wa awali wa magari ya treni, na inarudisha idadi ndogo ya mizunguko inayohitajika ili kuyapanga katika mpangilio wa kupanda.\n\nMifano ya kesi:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "tr": "Tren vagonlarını artan sıraya göre yeniden düzenlemek için gereken minimum 180 derece dönüş sayısını bulur.\n\nFonksiyon, tren vagonlarının başlangıç sırasını temsil eden bir tamsayı dizisi alır ve onları artan sıraya göre düzenlemek için gereken minimum dönüş sayısını döndürür.\n\nÖrnek durumlar:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "vi": "Tìm số lần xoay 180 độ tối thiểu cần thiết để sắp xếp lại các toa tàu theo thứ tự tăng dần.\n\nHàm nhận một mảng các số nguyên đại diện cho thứ tự ban đầu của các toa tàu, và trả về số lần xoay tối thiểu cần thiết để sắp xếp chúng theo thứ tự tăng dần.\n\nCác trường hợp ví dụ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10"
    },
    "docstring_bertscore": {
      "es": "0.9744094548593701",
      "arb": "0.977693808209782",
      "sw": "0.9779013769579635",
      "tr": "0.9702934361035652",
      "vi": "0.9741379271284955"
    }
  },
  {
    "task_id": "Swift/32",
    "prompt": {
      "en": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "es": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermina si la palabra dada es una \"Palabra Afortunada\". Una palabra se considera afortunada si la diferencia\nentre las frecuencias máximas y mínimas de los caracteres en la palabra es un número primo.\n\n- Parámetros:\n- word: Una cadena que representa la palabra a verificar. Se asume que solo contiene letras minúsculas y una longitud menor a 100.\n\n- Retorna: Una tupla que contiene un booleano indicando si la palabra es afortunada, y un entero que es la diferencia\nentre las frecuencias máximas y mínimas si la palabra es afortunada, o 0 en caso contrario.\n\nEjemplos:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "arb": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nيحدد ما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\". تعتبر الكلمة محظوظة إذا كان الفرق\nبين ترددات الحروف القصوى والدنيا في الكلمة هو عدد أولي.\n\n- المعلمات:\n- word: سلسلة تمثل الكلمة التي سيتم التحقق منها. يفترض أنها تحتوي فقط على حروف صغيرة وطول أقل من 100.\n\n- العوائد: زوج يحتوي على قيمة منطقية تشير إلى ما إذا كانت الكلمة محظوظة، وعدد صحيح يمثل الفرق\nبين الترددات القصوى والدنيا إذا كانت الكلمة محظوظة، أو 0 خلاف ذلك.\n\nأمثلة:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "sw": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nHuamua ikiwa neno lililopewa ni \"Neno la Bahati.\" Neno linachukuliwa kuwa la bahati ikiwa tofauti\nkati ya mara nyingi za herufi za juu na za chini katika neno ni nambari ya kwanza.\n\n- Vigezo:\n- word: Kamba inayowakilisha neno litakalokaguliwa. Inadhaniwa kuwa ni herufi ndogo pekee na urefu chini ya 100.\n\n- Inarudisha: Jozi inayojumuisha boolean inayoonyesha ikiwa neno ni la bahati, na nambari ambayo ni tofauti\nkati ya mara nyingi za juu na za chini ikiwa neno ni la bahati, au 0 vinginevyo.\n\nMifano:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "tr": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nVerilen kelimenin \"Şanslı Kelime\" olup olmadığını belirler. Bir kelime, kelimedeki maksimum ve minimum karakter\nfrekansları arasındaki fark bir asal sayı ise şanslı kabul edilir.\n\n- Parametreler:\n- word: Kontrol edilecek kelimeyi temsil eden bir string. Sadece küçük harfler ve uzunluğu 100'den az olduğu varsayılır.\n\n- Döndürür: Kelimenin şanslı olup olmadığını belirten bir boolean ve kelime şanslıysa maksimum ve minimum frekanslar\narasındaki farkı, aksi takdirde 0 döndüren bir tamsayı içeren bir ikili.\n\nÖrnekler:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "vi": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nXác định xem từ đã cho có phải là \"Từ May Mắn\" hay không. Một từ được coi là may mắn nếu sự chênh lệch\ngiữa tần suất ký tự lớn nhất và nhỏ nhất trong từ là một số nguyên tố.\n\n- Tham số:\n- word: Một chuỗi đại diện cho từ cần kiểm tra. Giả sử chỉ có chữ cái thường và độ dài nhỏ hơn 100.\n\n- Trả về: Một bộ giá trị chứa một giá trị boolean cho biết từ có phải là may mắn hay không, và một số nguyên là sự chênh lệch\ngiữa tần suất lớn nhất và nhỏ nhất nếu từ là may mắn, hoặc 0 nếu không.\n\nVí dụ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/"
    },
    "prompt_bertscore": {
      "es": "0.976412642252107",
      "arb": "0.9682322486395661",
      "sw": "0.9486113409705589",
      "tr": "0.9715078622532125",
      "vi": "0.9518581531789552"
    },
    "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}",
    "instruction": {
      "en": "Write a Swift function `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` to solve the following problem:\n\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n",
      "es": "Escribe una función en Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` para resolver el siguiente problema:\n\nDetermina si la palabra dada es una \"Palabra Afortunada.\" Una palabra se considera afortunada si la diferencia\nentre las frecuencias máximas y mínimas de los caracteres en la palabra es un número primo.\n\n- Parámetros:\n- word: Una cadena que representa la palabra a verificar. Se asume que solo contiene letras minúsculas y una longitud menor a 100.\n\n- Retorna: Una tupla que contiene un booleano que indica si la palabra es afortunada, y un entero que es la diferencia\nentre las frecuencias máxima y mínima si la palabra es afortunada, o 0 en caso contrario.\n\nEjemplos:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "arb": "اكتب دالة Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` لحل المشكلة التالية:\n\nتحدد ما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\". تعتبر الكلمة محظوظة إذا كان الفرق بين ترددات الأحرف القصوى والدنيا في الكلمة هو عدد أولي.\n\n- المعاملات:\n- word: سلسلة تمثل الكلمة المراد التحقق منها. يفترض أنها تحتوي فقط على أحرف صغيرة وطولها أقل من 100.\n\n- الإرجاع: زوج يحتوي على قيمة بوليانية تشير إلى ما إذا كانت الكلمة محظوظة، وعدد صحيح يمثل الفرق بين الترددات القصوى والدنيا إذا كانت الكلمة محظوظة، أو 0 خلاف ذلك.\n\nأمثلة:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "sw": "Andika kazi ya Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` kutatua tatizo lifuatalo:\n\nInabainisha kama neno lililopewa ni \"Neno la Bahati.\" Neno linachukuliwa kuwa la bahati ikiwa tofauti\nkati ya marudio ya herufi ya juu na ya chini kabisa katika neno ni nambari ya kwanza.\n\n- Vigezo:\n- word: Mfuatano wa herufi unaowakilisha neno linalopaswa kukaguliwa. Inadhaniwa kuwa na herufi ndogo tu na urefu chini ya 100.\n\n- Inarudisha: Jozi inayojumuisha boolean inayoonyesha kama neno ni la bahati, na nambari ambayo ni tofauti\nkati ya marudio ya juu na ya chini ikiwa neno ni la bahati, au 0 vinginevyo.\n\nMifano:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "tr": "Bir Swift fonksiyonu `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` yazın ve aşağıdaki problemi çözün:\n\nVerilen kelimenin \"Şanslı Kelime\" olup olmadığını belirler. Bir kelime, kelimedeki maksimum ve minimum karakter frekansları arasındaki fark bir asal sayı ise şanslı kabul edilir.\n\n- Parametreler:\n- word: Kontrol edilecek kelimeyi temsil eden bir string. Sadece küçük harfler ve uzunluğu 100'den az olduğu varsayılır.\n\n- Dönüş: Kelimenin şanslı olup olmadığını belirten bir boolean ve kelime şanslıysa maksimum ve minimum frekanslar arasındaki farkı, aksi takdirde 0'ı içeren bir tuple döner.\n\nÖrnekler:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "vi": "Viết một hàm Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` để giải quyết vấn đề sau:\n\nXác định xem từ cho trước có phải là \"Từ May Mắn\" hay không. Một từ được coi là may mắn nếu sự khác biệt giữa tần suất ký tự lớn nhất và nhỏ nhất trong từ là một số nguyên tố.\n\n- Tham số:\n- word: Một chuỗi đại diện cho từ cần kiểm tra. Giả định chỉ có chữ cái thường và độ dài nhỏ hơn 100.\n\n- Trả về: Một bộ giá trị chứa một giá trị boolean cho biết từ có phải là may mắn hay không, và một số nguyên là sự khác biệt giữa tần suất lớn nhất và nhỏ nhất nếu từ là may mắn, hoặc 0 nếu không.\n\nVí dụ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)"
    },
    "instruction_bertscore": {
      "es": "0.9727161308610478",
      "arb": "0.9635123935254152",
      "sw": "0.9517240776717566",
      "tr": "0.9639122364824384",
      "vi": "0.9642858602291651"
    },
    "level": "hard",
    "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()",
    "entry_point": "isLuckyWord",
    "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {",
    "docstring": {
      "en": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n",
      "es": "Determina si la palabra dada es una \"Palabra de la Suerte\". Una palabra se considera de la suerte si la diferencia entre las frecuencias máximas y mínimas de los caracteres en la palabra es un número primo.\n\n- Parámetros:\n- word: Una cadena que representa la palabra a verificar. Se asume que solo contiene letras minúsculas y una longitud menor a 100.\n\n- Devuelve: Una tupla que contiene un booleano que indica si la palabra es de la suerte, y un entero que es la diferencia entre las frecuencias máxima y mínima si la palabra es de la suerte, o 0 en caso contrario.\n\nEjemplos:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "arb": "يحدد ما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\". تعتبر الكلمة محظوظة إذا كان الفرق بين ترددات الأحرف القصوى والدنيا في الكلمة عددًا أوليًا.\n\n- المعاملات:\n- word: سلسلة تمثل الكلمة المراد التحقق منها. يفترض أنها تحتوي فقط على حروف صغيرة وطولها أقل من 100.\n\n- العائدات: زوج يحتوي على قيمة منطقية تشير إلى ما إذا كانت الكلمة محظوظة، وعدد صحيح هو الفرق بين الترددات القصوى والدنيا إذا كانت الكلمة محظوظة، أو 0 خلاف ذلك.\n\nأمثلة:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "sw": "Inabainisha kama neno lililopeanwa ni \"Neno la Bahati.\" Neno linachukuliwa kuwa la bahati ikiwa tofauti kati ya marudio ya herufi ya juu zaidi na ya chini zaidi katika neno ni nambari ya kwanza.\n\n- Vigezo:\n- word: Kamba inayowakilisha neno litakalokaguliwa. Inadhaniwa kuwa na herufi ndogo pekee na urefu chini ya 100.\n\n- Inarudisha: Jozi inayo na boolean inayoonyesha kama neno ni la bahati, na nambari ambayo ni tofauti kati ya marudio ya juu na ya chini ikiwa neno ni la bahati, au 0 vinginevyo.\n\nMifano:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "tr": "Verilen kelimenin \"Şanslı Kelime\" olup olmadığını belirler. Bir kelime, kelimedeki maksimum ve minimum karakter frekansları arasındaki fark asal bir sayı ise şanslı kabul edilir.\n\n- Parametreler:\n- word: Kontrol edilecek kelimeyi temsil eden bir dize. Sadece küçük harfler ve 100'den az uzunlukta olduğu varsayılır.\n\n- Döndürür: Kelimenin şanslı olup olmadığını belirten bir boolean ve kelime şanslıysa maksimum ve minimum frekanslar arasındaki farkı, aksi takdirde 0 olan bir tamsayı içeren bir demet.\n\nÖrnekler:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "vi": "Xác định xem từ đã cho có phải là \"Từ May Mắn\" hay không. Một từ được coi là may mắn nếu sự khác biệt giữa tần suất ký tự tối đa và tối thiểu trong từ là một số nguyên tố.\n\n- Tham số:\n- word: Một chuỗi đại diện cho từ cần kiểm tra. Giả định chỉ có chữ cái thường và độ dài nhỏ hơn 100.\n\n- Trả về: Một bộ giá trị chứa một giá trị boolean cho biết từ có may mắn hay không, và một số nguyên là sự khác biệt giữa tần suất tối đa và tối thiểu nếu từ may mắn, hoặc 0 nếu không.\n\nVí dụ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)"
    },
    "docstring_bertscore": {
      "es": "0.9702668196325066",
      "arb": "0.9641895244943631",
      "sw": "0.9490143620136787",
      "tr": "0.9628817420656294",
      "vi": "0.9606167598306886"
    }
  },
  {
    "task_id": "Swift/33",
    "prompt": {
      "en": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/",
      "es": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nEncuentra la suma máxima de un subarreglo contiguo en un arreglo de enteros.\n\n- Parámetros:\n- nums: Un arreglo de enteros.\n\n- Retorna: La suma máxima de cualquier subarreglo contiguo.\n\nEjemplos:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] suma 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] es la suma más grande en el arreglo\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] suma 7\n*/",
      "arb": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nيجد أكبر مجموع لمصفوفة فرعية متجاورة في مصفوفة من الأعداد الصحيحة.\n\n- Parameters:\n- nums: مصفوفة من الأعداد الصحيحة.\n\n- Returns: أكبر مجموع لأي مصفوفة فرعية متجاورة.\n\nأمثلة:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] مجموعها 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] هو أكبر مجموع في المصفوفة\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] مجموعها 7\n*/",
      "sw": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nInapata jumla ya juu zaidi ya subarray inayoendelea katika safu ya nambari za integer.\n\n- Vigezo:\n- nums: Safu ya nambari za integer.\n\n- Inarejesha: Jumla ya juu zaidi ya subarray yoyote inayoendelea.\n\nMifano:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ina jumla ya 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ndiyo jumla kubwa zaidi katika safu\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ina jumla ya 7\n*/",
      "tr": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nBir tamsayı dizisindeki ardışık alt dizinin maksimum toplamını bulur.\n\n- Parametreler:\n- nums: Bir tamsayı dizisi.\n\n- Döndürür: Herhangi bir ardışık alt dizinin maksimum toplamı.\n\nÖrnekler:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] toplamı 9 eder\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] dizideki en büyük toplamdır\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] toplamı 7 eder\n*/",
      "vi": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nTìm tổng lớn nhất của một mảng con liên tiếp trong một mảng số nguyên.\n\n- Tham số:\n- nums: Một mảng số nguyên.\n\n- Trả về: Tổng lớn nhất của bất kỳ mảng con liên tiếp nào.\n\nVí dụ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] có tổng là 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] là tổng lớn nhất trong mảng\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] có tổng là 7\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.992108812222246",
      "sw": "0.9714885951062522",
      "tr": "0.9686553313511705",
      "vi": "0.9710877589973237"
    },
    "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}",
    "instruction": {
      "en": "Write a Swift function `func maxSubArraySum(_ nums: [Int]) -> Int {` to solve the following problem:\n\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n",
      "es": "Escribe una función Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` para resolver el siguiente problema:\n\nEncuentra la suma máxima de un subarreglo contiguo en un arreglo de enteros.\n\n- Parámetros:\n- nums: Un arreglo de enteros.\n\n- Retorna: La suma máxima de cualquier subarreglo contiguo.\n\nEjemplos:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] suma 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] es la suma más grande en el arreglo\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] suma 7",
      "arb": "اكتب دالة Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` لحل المشكلة التالية:\n\nتجد أكبر مجموع لمصفوفة فرعية متجاورة في مصفوفة من الأعداد الصحيحة.\n\n- المعاملات:\n- nums: مصفوفة من الأعداد الصحيحة.\n\n- الإرجاع: أكبر مجموع لأي مصفوفة فرعية متجاورة.\n\nأمثلة:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] مجموعها 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] هو أكبر مجموع في المصفوفة\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] مجموعها 7",
      "sw": "Andika kazi ya Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` kutatua tatizo lifuatalo:\n\nInapata jumla kubwa zaidi ya subarray inayoendelea katika safu ya nambari za mzima.\n\n- Vigezo:\n- nums: Safu ya nambari za mzima.\n\n- Inarudisha: Jumla kubwa zaidi ya subarray yoyote inayoendelea.\n\nMifano:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] inajumlisha hadi 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ndiyo jumla kubwa zaidi katika safu\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] inajumlisha hadi 7",
      "tr": "Bir Swift fonksiyonu `func maxSubArraySum(_ nums: [Int]) -> Int {` yazarak aşağıdaki problemi çözün:\n\nBir tamsayı dizisindeki ardışık alt dizinin maksimum toplamını bulur.\n\n- Parametreler:\n- nums: Bir tamsayı dizisi.\n\n- Döndürür: Herhangi bir ardışık alt dizinin maksimum toplamı.\n\nÖrnekler:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] toplamı 9 eder\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] dizideki en büyük toplamdır\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] toplamı 7 eder",
      "vi": "Viết một hàm Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` để giải quyết vấn đề sau:\n\nTìm tổng lớn nhất của một mảng con liên tiếp trong một mảng số nguyên.\n\n- Tham số:\n- nums: Một mảng số nguyên.\n\n- Trả về: Tổng lớn nhất của bất kỳ mảng con liên tiếp nào.\n\nVí dụ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] có tổng là 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] là tổng lớn nhất trong mảng\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] có tổng là 7"
    },
    "instruction_bertscore": {
      "es": "0.9841961723633401",
      "arb": "0.990794077730176",
      "sw": "0.9928413610675026",
      "tr": "0.9670676787155587",
      "vi": "0.9729685900753431"
    },
    "level": "easy",
    "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)",
    "entry_point": "maxSubArraySum",
    "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n",
      "es": "Encuentra la suma máxima de un subarreglo contiguo en un arreglo de enteros.\n\n- Parámetros:\n- nums: Un arreglo de enteros.\n\n- Devuelve: La suma máxima de cualquier subarreglo contiguo.\n\nEjemplos:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] suma 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] es la mayor suma en el arreglo\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] suma 7",
      "arb": "يجد المجموع الأقصى لمصفوفة فرعية متجاورة في مصفوفة من الأعداد الصحيحة.\n\n- المعلمات:\n- nums: مصفوفة من الأعداد الصحيحة.\n\n- يعيد: المجموع الأقصى لأي مصفوفة فرعية متجاورة.\n\nأمثلة:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] يجمع إلى 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] هو أكبر مجموع في المصفوفة\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] يجمع إلى 7",
      "sw": "Inapata jumla ya juu zaidi ya sehemu ndogo inayoendelea katika safu ya nambari za mzima.\n\n- Vigezo:\n- nums: Safu ya nambari za mzima.\n\n- Inarejesha: Jumla ya juu zaidi ya sehemu ndogo yoyote inayoendelea.\n\nMifano:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] hujumlisha hadi 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ndiyo jumla kubwa zaidi katika safu\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] hujumlisha hadi 7",
      "tr": "Bir tamsayı dizisindeki ardışık alt dizinin maksimum toplamını bulur.\n\n- Parametreler:\n- nums: Bir tamsayı dizisi.\n\n- Döndürür: Herhangi bir ardışık alt dizinin maksimum toplamı.\n\nÖrnekler:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] toplamı 9 eder\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] dizideki en büyük toplamdır\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] toplamı 7 eder",
      "vi": "Tìm tổng lớn nhất của một mảng con liên tiếp trong một mảng số nguyên.\n\n- Tham số:\n- nums: Một mảng số nguyên.\n\n- Trả về: Tổng lớn nhất của bất kỳ mảng con liên tiếp nào.\n\nVí dụ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] có tổng là 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] là tổng lớn nhất trong mảng\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] có tổng là 7"
    },
    "docstring_bertscore": {
      "es": "0.98044384583521",
      "arb": "0.999999801369619",
      "sw": "0.9941028626174552",
      "tr": "0.9660020267213064",
      "vi": "0.97225590426819"
    }
  },
  {
    "task_id": "Swift/34",
    "prompt": {
      "en": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "es": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConvierte un número de una base a otra. Las bases pueden variar de 2 a 16.\n\n- Parámetros:\n- fromBase: La base del número de entrada (entre 2 y 16 inclusive).\n- number: El número en formato de cadena que se va a convertir. Para bases mayores que 10,\nutiliza letras mayúsculas de la A a la F.\n- toBase: La base a la que se va a convertir el número (entre 2 y 16 inclusive).\n\n- Devuelve: Una cadena que representa el número convertido en la nueva base.\n\nEjemplos:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "arb": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nتحول رقمًا من قاعدة إلى أخرى. يمكن أن تتراوح القواعد من 2 إلى 16.\n\n- المعلمات:\n- fromBase: قاعدة الرقم المدخل (بين 2 و 16 شامل).\n- number: الرقم بصيغة سلسلة ليتم تحويله. للقواعد الأكبر من 10، \nيستخدم الحروف الكبيرة من A إلى F.\n- toBase: القاعدة التي سيتم تحويل الرقم إليها (بين 2 و 16 شامل).\n\n- يعيد: سلسلة تمثل الرقم المحول في القاعدة الجديدة.\n\nأمثلة:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "sw": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nInabadilisha nambari kutoka msingi mmoja hadi mwingine. Misingi inaweza kuwa kati ya 2 hadi 16.\n\n- Vigezo:\n- fromBase: Msingi wa nambari ya ingizo (kati ya 2 na 16 pamoja).\n- number: Nambari katika muundo wa kamba inayopaswa kubadilishwa. Kwa misingi zaidi ya 10, \ninatumia herufi kubwa A hadi F.\n- toBase: Msingi ambao nambari inapaswa kubadilishwa (kati ya 2 na 16 pamoja).\n\n- Inarejesha: Kamba inayowakilisha nambari iliyobadilishwa katika msingi mpya.\n\nMifano:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "tr": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nBir sayıyı bir tabandan başka bir tabana dönüştürür. Tabanlar 2 ile 16 arasında olabilir.\n\n- Parametreler:\n- fromBase: Girdi sayısının tabanı (2 ile 16 dahil arasında).\n- number: Dönüştürülecek sayının string formatındaki hali. 10'dan büyük tabanlar için \nA'dan F'ye kadar büyük harfler kullanılır.\n- toBase: Sayının dönüştürüleceği taban (2 ile 16 dahil arasında).\n\n- Döndürür: Yeni tabandaki dönüştürülmüş sayıyı temsil eden bir string.\n\nÖrnekler:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "vi": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nChuyển đổi một số từ một cơ số này sang cơ số khác. Các cơ số có thể nằm trong khoảng từ 2 đến 16.\n\n- Tham số:\n- fromBase: Cơ số của số đầu vào (từ 2 đến 16 bao gồm cả hai).\n- number: Số ở định dạng chuỗi cần được chuyển đổi. Đối với các cơ số lớn hơn 10,\nnó sử dụng các chữ cái in hoa từ A đến F.\n- toBase: Cơ số mà số cần được chuyển đổi sang (từ 2 đến 16 bao gồm cả hai).\n\n- Trả về: Một chuỗi đại diện cho số đã chuyển đổi trong cơ số mới.\n\nVí dụ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9876461834515351",
      "arb": "0.9897721244197515",
      "sw": "0.9905352623436876",
      "tr": "0.9695527434126862",
      "vi": "0.9874266968804916"
    },
    "canonical_solution": "let decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}",
    "instruction": {
      "en": "Write a Swift function `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` to solve the following problem:\n\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n",
      "es": "Escribe una función Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` para resolver el siguiente problema:\n\nConvierte un número de una base a otra. Las bases pueden variar de 2 a 16.\n\n- Parámetros:\n- fromBase: La base del número de entrada (entre 2 y 16 inclusive).\n- number: El número en formato de cadena a convertir. Para bases mayores que 10,\nutiliza letras mayúsculas de la A a la F.\n- toBase: La base a la que se va a convertir el número (entre 2 y 16 inclusive).\n\n- Retorna: Una cadena que representa el número convertido en la nueva base.\n\nEjemplos:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "arb": "اكتب دالة Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` لحل المشكلة التالية:\n\nتحويل رقم من قاعدة إلى أخرى. يمكن أن تتراوح القواعد من 2 إلى 16.\n\n- المعاملات:\n- fromBase: قاعدة الرقم المدخل (بين 2 و 16 شامل).\n- number: الرقم بصيغة سلسلة ليتم تحويله. للقواعد الأكبر من 10، \nيستخدم الحروف الكبيرة من A إلى F.\n- toBase: القاعدة التي سيتم تحويل الرقم إليها (بين 2 و 16 شامل).\n\n- يعيد: سلسلة تمثل الرقم المحول في القاعدة الجديدة.\n\nأمثلة:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "sw": "Andika kazi ya Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` kutatua tatizo lifuatalo:\n\nInabadilisha nambari kutoka msingi mmoja hadi mwingine. Misingi inaweza kuwa kati ya 2 hadi 16.\n\n- Vigezo:\n- fromBase: Msingi wa nambari ya ingizo (kati ya 2 na 16 ikijumuishwa).\n- number: Nambari katika muundo wa kamba ya maandishi itakayobadilishwa. Kwa misingi zaidi ya 10, \ninatumia herufi kubwa A hadi F.\n- toBase: Msingi ambao nambari itabadilishwa (kati ya 2 na 16 ikijumuishwa).\n\n- Inarejesha: Kamba ya maandishi inayowakilisha nambari iliyobadilishwa katika msingi mpya.\n\nMifano:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "tr": "Bir Swift fonksiyonu `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` yazın, aşağıdaki problemi çözmek için:\n\nBir sayıyı bir tabandan başka bir tabana dönüştürür. Tabanlar 2 ile 16 arasında olabilir.\n\n- Parametreler:\n- fromBase: Girdi sayısının tabanı (2 ile 16 arasında dahil).\n- number: Dönüştürülecek sayının string formatı. 10'dan büyük tabanlar için, \nA'dan F'ye büyük harfler kullanılır.\n- toBase: Sayının dönüştürüleceği taban (2 ile 16 arasında dahil).\n\n- Döndürür: Yeni tabandaki dönüştürülmüş sayıyı temsil eden bir string.\n\nÖrnekler:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "vi": "Viết một hàm Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` để giải quyết vấn đề sau:\n\nChuyển đổi một số từ một hệ cơ số này sang một hệ cơ số khác. Các hệ cơ số có thể từ 2 đến 16.\n\n- Tham số:\n- fromBase: Hệ cơ số của số đầu vào (giữa 2 và 16 bao gồm cả hai).\n- number: Số ở định dạng chuỗi cần được chuyển đổi. Đối với các hệ cơ số lớn hơn 10, \nnó sử dụng các chữ cái in hoa từ A đến F.\n- toBase: Hệ cơ số mà số cần được chuyển đổi sang (giữa 2 và 16 bao gồm cả hai).\n\n- Trả về: Một chuỗi đại diện cho số đã được chuyển đổi trong hệ cơ số mới.\n\nVí dụ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\""
    },
    "instruction_bertscore": {
      "es": "0.9807002776571261",
      "arb": "0.9875055531417625",
      "sw": "0.986592250649764",
      "tr": "0.9731203436864537",
      "vi": "0.9625349334203425"
    },
    "level": "easy",
    "test": "func check(_ convertNumber: (Int, String, Int) -> String) {\nassert(convertNumber(10, \"255\", 2) == \"11111111\")\nassert(convertNumber(2, \"1010\", 10) == \"10\")\nassert(convertNumber(8, \"175\", 16) == \"7D\")\nassert(convertNumber(16, \"1A\", 10) == \"26\")\nassert(convertNumber(2, \"1111\", 16) == \"F\")\nassert(convertNumber(16, \"FF\", 8) == \"377\")\nassert(convertNumber(10, \"1000\", 16) == \"3E8\")\n}\n\ncheck(convertNumber)",
    "entry_point": "convertNumber",
    "signature": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {",
    "docstring": {
      "en": "\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n",
      "es": "Convierte un número de una base a otra. Las bases pueden variar de 2 a 16.\n\n- Parámetros:\n- fromBase: La base del número de entrada (entre 2 y 16 inclusive).\n- number: El número en formato de cadena para ser convertido. Para bases mayores que 10,\nutiliza letras mayúsculas de la A a la F.\n- toBase: La base a la que se va a convertir el número (entre 2 y 16 inclusive).\n\n- Retorna: Una cadena que representa el número convertido en la nueva base.\n\nEjemplos:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "arb": "تحول رقمًا من قاعدة إلى أخرى. يمكن أن تتراوح القواعد من 2 إلى 16.\n\n- المعلمات:\n- fromBase: قاعدة الرقم المدخل (بين 2 و 16 شاملًا).\n- number: الرقم بصيغة سلسلة ليتم تحويله. للقواعد الأكبر من 10، \nيستخدم الأحرف الكبيرة من A إلى F.\n- toBase: القاعدة التي سيتم تحويل الرقم إليها (بين 2 و 16 شاملًا).\n\n- يعيد: سلسلة تمثل الرقم المحول في القاعدة الجديدة.\n\nأمثلة:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "sw": "Inabadilisha nambari kutoka msingi mmoja hadi mwingine. Misingi inaweza kuwa kati ya 2 hadi 16.\n\n- Vigezo:\n- fromBase: Msingi wa nambari ya ingizo (kati ya 2 na 16 ikijumuishwa).\n- number: Nambari katika muundo wa kamba ya maandishi inayopaswa kubadilishwa. Kwa misingi iliyo juu ya 10, \ninatumia herufi kubwa A hadi F.\n- toBase: Msingi ambao nambari itabadilishwa (kati ya 2 na 16 ikijumuishwa).\n\n- Inarudisha: Kamba ya maandishi inayowakilisha nambari iliyobadilishwa katika msingi mpya.\n\nMifano:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "tr": "Bir sayıyı bir tabandan diğerine dönüştürür. Tabanlar 2 ile 16 arasında olabilir.\n\n- Parametreler:\n- fromBase: Girdi sayısının tabanı (2 ile 16 arasında dahil).\n- number: Dönüştürülecek sayının string formatındaki hali. 10'dan büyük tabanlar için, \nA'dan F'ye kadar büyük harfler kullanılır.\n- toBase: Sayının dönüştürüleceği taban (2 ile 16 arasında dahil).\n\n- Döndürür: Yeni tabandaki dönüştürülmüş sayıyı temsil eden bir string.\n\nÖrnekler:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "vi": "Chuyển đổi một số từ một hệ cơ số này sang hệ cơ số khác. Các hệ cơ số có thể nằm trong khoảng từ 2 đến 16.\n\n- Tham số:\n- fromBase: Hệ cơ số của số đầu vào (từ 2 đến 16 bao gồm cả hai).\n- number: Số ở định dạng chuỗi cần được chuyển đổi. Đối với các hệ cơ số lớn hơn 10, \nnó sử dụng các chữ cái in hoa từ A đến F.\n- toBase: Hệ cơ số mà số sẽ được chuyển đổi sang (từ 2 đến 16 bao gồm cả hai).\n\n- Trả về: Một chuỗi đại diện cho số đã được chuyển đổi sang hệ cơ số mới.\n\nVí dụ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\""
    },
    "docstring_bertscore": {
      "es": "0.9833434521375574",
      "arb": "0.9881078004570603",
      "sw": "0.984986522649478",
      "tr": "0.9694282021637772",
      "vi": "0.9795676872244652"
    }
  },
  {
    "task_id": "Swift/35",
    "prompt": {
      "en": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "es": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nEncuentra el k-ésimo número único más pequeño de una lista dada de enteros. Si dos números son iguales,\nse consideran como un único número. Si el k-ésimo número único más pequeño no existe, devuelve \"NO RESULT\".\n\n- Parámetros:\n- numbers: Un arreglo de enteros.\n- k: El orden del número único más pequeño a encontrar.\n\n- Devuelve: Un String que representa el k-ésimo número único más pequeño o \"NO RESULT\" si no existe.\n\nEjemplos:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "arb": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nيعثر على العدد الفريد الأصغر بالترتيب k من قائمة الأعداد الصحيحة المعطاة. إذا كان هناك عددان متساويان،\nيعتبران كعدد فريد واحد. إذا لم يكن هناك عدد فريد أصغر بالترتيب k، يعيد \"NO RESULT\".\n\n- Parameters:\n- numbers: مصفوفة من الأعداد الصحيحة.\n- k: ترتيب العدد الفريد الأصغر المراد العثور عليه.\n\n- Returns: سلسلة تمثل العدد الفريد الأصغر بالترتيب k أو \"NO RESULT\" إذا لم يكن موجودًا.\n\nأمثلة:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "sw": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nInapata nambari ya kipekee ya k kwa ukubwa kutoka kwenye orodha iliyotolewa ya nambari za mzima. Ikiwa nambari mbili ni sawa,\nzinaangaliwa kama nambari moja ya kipekee. Ikiwa nambari ya kipekee ya k kwa ukubwa haipo, inarudisha \"NO RESULT\".\n\n- Vigezo:\n- numbers: Orodha ya nambari za mzima.\n- k: Mpangilio wa nambari ya kipekee ndogo zaidi ya kupata.\n\n- Inarudisha: Mstari unaowakilisha nambari ya kipekee ya k kwa ukubwa au \"NO RESULT\" ikiwa haipo.\n\nMifano:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "tr": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nVerilen bir tamsayı listesinden k. en küçük benzersiz sayıyı bulur. İki sayı aynıysa,\nbir benzersiz sayı olarak kabul edilirler. Eğer k. en küçük benzersiz sayı mevcut değilse, \"NO RESULT\" döner.\n\n- Parametreler:\n- numbers: Bir tamsayı dizisi.\n- k: Bulunacak en küçük benzersiz sayının sırası.\n\n- Dönüş: k. en küçük benzersiz sayıyı temsil eden bir String veya mevcut değilse \"NO RESULT\".\n\nÖrnekler:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "vi": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nTìm số nhỏ nhất thứ k duy nhất từ một danh sách số nguyên cho trước. Nếu hai số giống nhau,\nchúng được coi là một số duy nhất. Nếu số nhỏ nhất thứ k duy nhất không tồn tại, trả về \"NO RESULT\".\n\n- Tham số:\n- numbers: Một mảng số nguyên.\n- k: Thứ tự của số nhỏ nhất duy nhất cần tìm.\n\n- Trả về: Một chuỗi đại diện cho số nhỏ nhất thứ k duy nhất hoặc \"NO RESULT\" nếu không tồn tại.\n\nVí dụ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9733904810046612",
      "arb": "0.9656738893318368",
      "sw": "0.9711991906410843",
      "tr": "0.9697035038718916",
      "vi": "0.9789676248433588"
    },
    "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` to solve the following problem:\n\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n",
      "es": "Escribe una función en Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` para resolver el siguiente problema:\n\nEncuentra el k-ésimo número único más pequeño de una lista dada de enteros. Si dos números son iguales, se consideran como un solo número único. Si el k-ésimo número único más pequeño no existe, devuelve \"NO RESULT\".\n\n- Parámetros:\n- numbers: Un arreglo de enteros.\n- k: El orden del número único más pequeño a encontrar.\n\n- Retorna: Una cadena que representa el k-ésimo número único más pequeño o \"NO RESULT\" si no existe.\n\nEjemplos:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "arb": "اكتب دالة Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` لحل المشكلة التالية:\n\nإيجاد العدد الفريد الأصغر بالترتيب k من قائمة الأعداد الصحيحة المعطاة. إذا كان هناك رقمان متشابهان، يتم اعتباره كرقم فريد واحد. إذا لم يكن هناك عدد فريد أصغر بالترتيب k، يتم إرجاع \"NO RESULT\".\n\n- المعاملات:\n- numbers: مصفوفة من الأعداد الصحيحة.\n- k: ترتيب العدد الفريد الأصغر المطلوب إيجاده.\n\n- الإرجاع: سلسلة نصية تمثل العدد الفريد الأصغر بالترتيب k أو \"NO RESULT\" إذا لم يكن موجودًا.\n\nأمثلة:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "sw": "Andika kazi ya Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` kutatua tatizo lifuatalo:\n\nInapata nambari ya kipekee ya k ndogo zaidi kutoka kwenye orodha iliyotolewa ya nambari za mzima. Ikiwa nambari mbili ni sawa, zinachukuliwa kama nambari moja ya kipekee. Ikiwa nambari ya kipekee ya k ndogo zaidi haipo, inarudisha \"NO RESULT\".\n\n- Vigezo:\n- numbers: Orodha ya nambari za mzima.\n- k: Mpangilio wa nambari ndogo ya kipekee inayotafutwa.\n\n- Inarudisha: Kamba inayoashiria nambari ya kipekee ya k ndogo zaidi au \"NO RESULT\" ikiwa haipo.\n\nMifano:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "tr": "Bir Swift fonksiyonu `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` yazın ve aşağıdaki problemi çözün:\n\nVerilen bir tamsayı listesinden k. en küçük benzersiz sayıyı bulur. Eğer iki sayı aynıysa, bunlar bir benzersiz sayı olarak kabul edilir. Eğer k. en küçük benzersiz sayı mevcut değilse, \"NO RESULT\" döner.\n\n- Parametreler:\n- numbers: Bir tamsayı dizisi.\n- k: Bulunacak en küçük benzersiz sayının sırası.\n\n- Döndürür: k. en küçük benzersiz sayıyı temsil eden bir String veya mevcut değilse \"NO RESULT\".\n\nÖrnekler:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "vi": "Viết một hàm Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` để giải quyết vấn đề sau:\n\nTìm số nhỏ nhất thứ k duy nhất từ một danh sách các số nguyên đã cho. Nếu hai số giống nhau, chúng được coi là một số duy nhất. Nếu số nhỏ nhất thứ k duy nhất không tồn tại, trả về \"NO RESULT\".\n\n- Tham số:\n- numbers: Một mảng các số nguyên.\n- k: Thứ tự của số nhỏ nhất duy nhất cần tìm.\n\n- Trả về: Một chuỗi đại diện cho số nhỏ nhất thứ k duy nhất hoặc \"NO RESULT\" nếu nó không tồn tại.\n\nVí dụ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\""
    },
    "instruction_bertscore": {
      "es": "0.9688795850513588",
      "arb": "0.972278746762009",
      "sw": "0.9696399421499604",
      "tr": "0.9808919559748248",
      "vi": "0.979726194268531"
    },
    "level": "easy",
    "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()",
    "entry_point": "kthUniqueSmallestNumber",
    "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {",
    "docstring": {
      "en": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n",
      "es": "Encuentra el k-ésimo número único más pequeño de una lista dada de enteros. Si dos números son iguales, se consideran como un único número. Si el k-ésimo número único más pequeño no existe, devuelve \"NO RESULT\".\n\n- Parámetros:\n- numbers: Un arreglo de enteros.\n- k: El orden del número único más pequeño a encontrar.\n\n- Devuelve: Una cadena que representa el k-ésimo número único más pequeño o \"NO RESULT\" si no existe.\n\nEjemplos:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "arb": "يعثر على الرقم الفريد الأصغر من الترتيب k من قائمة معينة من الأعداد الصحيحة. إذا كان هناك رقمان متماثلان، يتم اعتبارهما كرقم فريد واحد. إذا لم يكن هناك رقم فريد أصغر من الترتيب k، يتم إرجاع \"NO RESULT\".\n\n- المعاملات:\n- numbers: مصفوفة من الأعداد الصحيحة.\n- k: ترتيب الرقم الفريد الأصغر الذي يجب العثور عليه.\n\n- يعيد: سلسلة تمثل الرقم الفريد الأصغر من الترتيب k أو \"NO RESULT\" إذا لم يكن موجودًا.\n\nأمثلة:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "sw": "Inapata nambari ya kipekee ndogo ya kth kutoka kwenye orodha iliyotolewa ya nambari za mzima. Ikiwa nambari mbili ni sawa, zinachukuliwa kama nambari moja ya kipekee. Ikiwa nambari ya kipekee ndogo ya kth haipo, inarudisha \"HAKUNA MATOKEO\".\n\n- Vigezo:\n- numbers: Orodha ya nambari za mzima.\n- k: Mpangilio wa nambari ndogo ya kipekee inayotafutwa.\n\n- Inarudisha: Neno linalowakilisha nambari ya kipekee ndogo ya kth au \"HAKUNA MATOKEO\" ikiwa haipo.\n\nMifano:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"HAKUNA MATOKEO\"",
      "tr": "Verilen bir tamsayı listesinden k. en küçük benzersiz sayıyı bulur. İki sayı aynıysa, bir benzersiz sayı olarak kabul edilirler. Eğer k. en küçük benzersiz sayı yoksa, \"SONUÇ YOK\" döndürür.\n\n- Parametreler:\n- numbers: Bir tamsayı dizisi.\n- k: Bulunacak en küçük benzersiz sayının sırası.\n\n- Döndürür: k. en küçük benzersiz sayıyı temsil eden bir String veya mevcut değilse \"SONUÇ YOK\".\n\nÖrnekler:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"SONUÇ YOK\"",
      "vi": "Tìm số nhỏ nhất thứ k duy nhất từ một danh sách số nguyên cho trước. Nếu hai số giống nhau, chúng được coi là một số duy nhất. Nếu số nhỏ nhất thứ k duy nhất không tồn tại, trả về \"KHÔNG CÓ KẾT QUẢ\".\n\n- Tham số:\n- numbers: Một mảng các số nguyên.\n- k: Thứ tự của số nhỏ nhất duy nhất cần tìm.\n\n- Trả về: Một chuỗi đại diện cho số nhỏ nhất thứ k duy nhất hoặc \"KHÔNG CÓ KẾT QUẢ\" nếu nó không tồn tại.\n\nVí dụ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"KHÔNG CÓ KẾT QUẢ\""
    },
    "docstring_bertscore": {
      "es": "0.9783047952618453",
      "arb": "0.955552479635823",
      "sw": "0.9850000295153883",
      "tr": "0.9687353793947275",
      "vi": "0.980494496582374"
    }
  },
  {
    "task_id": "Swift/36",
    "prompt": {
      "en": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "es": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nEncuentra la distancia más corta entre dos puntos cualesquiera en un conjunto dado de puntos en un plano 2D.\n\n- Parámetros:\n- points: Un arreglo de tuplas, donde cada tupla representa las coordenadas x e y de un punto.\n\n- Devuelve: La distancia más corta entre dos puntos cualesquiera, redondeada a cuatro decimales.\n\nEjemplo de uso:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "arb": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nيجد أقصر مسافة بين أي نقطتين في مجموعة معينة من النقاط في مستوى ثنائي الأبعاد.\n\n- Parameters:\n- points: مصفوفة من الأزواج، حيث يمثل كل زوج إحداثيات x و y لنقطة.\n\n- Returns: أقصر مسافة بين أي نقطتين، مقربة إلى أربعة منازل عشرية.\n\nمثال على الاستخدام:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "sw": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nInapata umbali mfupi zaidi kati ya pointi zozote mbili katika seti iliyotolewa ya pointi kwenye ndege ya 2D.\n\n- Vigezo:\n- points: Kifurushi cha safu, ambapo kila kifurushi kinawakilisha kuratibu za x na y za pointi.\n\n- Inarudisha: Umbali mfupi zaidi kati ya pointi zozote mbili, ukizungushwa hadi sehemu nne za desimali.\n\nMfano wa Matumizi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "tr": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nVerilen bir dizi noktada, 2D düzlemde herhangi iki nokta arasındaki en kısa mesafeyi bulur.\n\n- Parametreler:\n- points: Her bir tuple'ın bir noktanın x ve y koordinatlarını temsil ettiği tuple'lardan oluşan bir dizi.\n\n- Döndürülen: Herhangi iki nokta arasındaki en kısa mesafe, dört ondalık basamağa yuvarlanmış olarak.\n\nÖrnek Kullanım:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "vi": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nTìm khoảng cách ngắn nhất giữa hai điểm bất kỳ trong tập hợp các điểm trên mặt phẳng 2D.\n\n- Tham số:\n- points: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho tọa độ x và y của một điểm.\n\n- Trả về: Khoảng cách ngắn nhất giữa hai điểm bất kỳ, làm tròn đến bốn chữ số thập phân.\n\nVí dụ sử dụng:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9964737148454876",
      "arb": "0.9924147030090397",
      "sw": "0.995302987379668",
      "tr": "0.9928270596800681",
      "vi": "0.9856968248920588"
    },
    "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}",
    "instruction": {
      "en": "Write a Swift function `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` to solve the following problem:\n\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n",
      "es": "Escribe una función de Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` para resolver el siguiente problema:\n\nEncuentra la distancia más corta entre dos puntos cualesquiera en un conjunto dado de puntos en un plano 2D.\n\n- Parámetros:\n- points: Un arreglo de tuplas, donde cada tupla representa las coordenadas x e y de un punto.\n\n- Retorna: La distancia más corta entre dos puntos, redondeada a cuatro decimales.\n\nEjemplo de uso:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "arb": "اكتب دالة Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` لحل المشكلة التالية:\n\nتجد أقصر مسافة بين أي نقطتين في مجموعة معينة من النقاط في مستوى ثنائي الأبعاد.\n\n- المعاملات:\n- points: مصفوفة من الأزواج، حيث يمثل كل زوج إحداثيات x و y لنقطة.\n\n- العوائد: أقصر مسافة بين أي نقطتين، مقربة إلى أربعة منازل عشرية.\n\nمثال على الاستخدام:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "sw": "Andika kazi ya Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` kutatua tatizo lifuatalo:\n\nInapata umbali mfupi zaidi kati ya pointi zozote mbili katika seti iliyotolewa ya pointi kwenye ndege ya 2D.\n\n- Vigezo:\n- points: Kundi la tuples, ambapo kila tuple inawakilisha kuratibu za x na y za pointi.\n\n- Inarudisha: Umbali mfupi zaidi kati ya pointi zozote mbili, ukiwa umekadiriwa hadi sehemu nne za desimali.\n\nMfano wa Matumizi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "tr": "Bir Swift fonksiyonu `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` yazın ve aşağıdaki problemi çözün:\n\nVerilen bir nokta kümesindeki herhangi iki nokta arasındaki en kısa mesafeyi bulun.\n\n- Parametreler:\n- points: Her bir tuple'ın bir noktanın x ve y koordinatlarını temsil ettiği bir tuple dizisi.\n\n- Döndürür: Herhangi iki nokta arasındaki en kısa mesafe, dört ondalık basamağa yuvarlanmış olarak.\n\nÖrnek Kullanım:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "vi": "Viết một hàm Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` để giải quyết vấn đề sau:\n\nTìm khoảng cách ngắn nhất giữa bất kỳ hai điểm nào trong một tập hợp các điểm trên mặt phẳng 2D.\n\n- Tham số:\n- points: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho tọa độ x và y của một điểm.\n\n- Trả về: Khoảng cách ngắn nhất giữa bất kỳ hai điểm nào, được làm tròn đến bốn chữ số thập phân.\n\nVí dụ Sử dụng:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142"
    },
    "instruction_bertscore": {
      "es": "0.9885463763383853",
      "arb": "0.993088060000748",
      "sw": "0.9951671241990402",
      "tr": "0.972039794413624",
      "vi": "0.9878908960809701"
    },
    "level": "hard",
    "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)",
    "entry_point": "findShortestDistanceAmongPoints",
    "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {",
    "docstring": {
      "en": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n",
      "es": "Encuentra la distancia más corta entre dos puntos cualesquiera en un conjunto dado de puntos en un plano 2D.\n\n- Parámetros:\n- points: Un array de tuplas, donde cada tupla representa las coordenadas x e y de un punto.\n\n- Retorna: La distancia más corta entre dos puntos cualesquiera, redondeada a cuatro decimales.\n\nEjemplo de Uso:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "arb": "يجد أقصر مسافة بين أي نقطتين في مجموعة معينة من النقاط في مستوى ثنائي الأبعاد.\n\n- المعاملات:\n- points: مصفوفة من الأزواج، حيث يمثل كل زوج إحداثيات x و y لنقطة.\n\n- يعيد: أقصر مسافة بين أي نقطتين، مقربة إلى أربعة منازل عشرية.\n\nمثال على الاستخدام:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "sw": "Inapata umbali mfupi zaidi kati ya pointi zozote mbili katika seti iliyotolewa ya pointi kwenye ndege ya 2D.\n\n- Vigezo:\n- points: Kifungu cha safu, ambapo kila kifungu kinawakilisha kuratibu x na y ya pointi.\n\n- Inarudi: Umbali mfupi zaidi kati ya pointi zozote mbili, uliopigwa hadi nafasi nne za desimali.\n\nMfano wa Matumizi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "tr": "Verilen bir dizi noktada, 2D düzlemde herhangi iki nokta arasındaki en kısa mesafeyi bulur.\n\n- Parametreler:\n- points: Her bir tuple'ın bir noktanın x ve y koordinatlarını temsil ettiği tuple'lardan oluşan bir dizi.\n\n- Döndürür: Herhangi iki nokta arasındaki en kısa mesafe, dört ondalık basamağa yuvarlanmış olarak.\n\nÖrnek Kullanım:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "vi": "Tìm khoảng cách ngắn nhất giữa bất kỳ hai điểm nào trong một tập hợp các điểm trên mặt phẳng 2D.\n\n- Tham số:\n- points: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho tọa độ x và y của một điểm.\n\n- Trả về: Khoảng cách ngắn nhất giữa bất kỳ hai điểm nào, được làm tròn đến bốn chữ số thập phân.\n\nVí dụ Sử dụng:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142"
    },
    "docstring_bertscore": {
      "es": "0.9891792127323624",
      "arb": "0.9799156876520383",
      "sw": "0.9887023011874976",
      "tr": "0.9912846947713322",
      "vi": "0.9842702614954661"
    }
  },
  {
    "task_id": "Swift/37",
    "prompt": {
      "en": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "es": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCuenta el número de formas de elegir platos de un menú de manera que el costo total\ncoincida exactamente con un presupuesto dado. Cada plato solo puede ser seleccionado una vez.\n\n- Parameters:\n- dishes: Un arreglo de enteros donde cada entero representa el costo de un plato.\n- budget: Un entero que representa el presupuesto total para la comida.\n- Returns: El número total de combinaciones únicas de platos que suman exactamente el presupuesto.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "arb": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nيحسب عدد الطرق لاختيار الأطباق من قائمة بحيث يتطابق التكلفة الإجمالية تمامًا مع ميزانية معينة. يمكن اختيار كل طبق مرة واحدة فقط.\n\n- المعاملات:\n- dishes: مصفوفة من الأعداد الصحيحة حيث يمثل كل عدد صحيح تكلفة طبق.\n- budget: عدد صحيح يمثل الميزانية الإجمالية للوجبة.\n- Returns: العدد الإجمالي للتوليفات الفريدة من الأطباق التي تتطابق تمامًا مع الميزانية.\n\n## مثال:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "sw": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nInahesabu idadi ya njia za kuchagua vyakula kutoka kwenye menyu ili gharama ya jumla\nilingane kabisa na bajeti iliyotolewa. Kila chakula kinaweza kuchaguliwa mara moja tu.\n\n- Vigezo:\n- dishes: Mfululizo wa namba ambapo kila namba inawakilisha gharama ya chakula.\n- budget: Namba inayoashiria jumla ya bajeti kwa ajili ya mlo.\n- Inarudisha: Jumla ya idadi ya mchanganyiko wa kipekee wa vyakula vinavyofikia jumla ya bajeti.\n\n## Mfano:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "tr": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nBir menüden yemeklerin toplam maliyetinin verilen bir bütçeye tam olarak eşit olacak şekilde\nseçilme yollarının sayısını sayar. Her yemek yalnızca bir kez seçilebilir.\n\n- Parametreler:\n- dishes: Her bir tamsayının bir yemeğin maliyetini temsil ettiği bir tamsayı dizisi.\n- budget: Yemek için toplam bütçeyi temsil eden bir tamsayı.\n- Döndürür: Bütçeye tam olarak uyan benzersiz yemek kombinasyonlarının toplam sayısı.\n\n## Örnek:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "vi": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nĐếm số cách chọn món ăn từ thực đơn sao cho tổng chi phí\nchính xác bằng ngân sách đã cho. Mỗi món ăn chỉ có thể được chọn một lần.\n\n- Tham số:\n- dishes: Một mảng các số nguyên, mỗi số nguyên đại diện cho chi phí của một món ăn.\n- budget: Một số nguyên đại diện cho tổng ngân sách cho bữa ăn.\n- Trả về: Tổng số các tổ hợp món ăn duy nhất mà tổng chi phí chính xác bằng ngân sách.\n\n## Ví dụ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9955065835202288",
      "arb": "0.972171089095488",
      "sw": "0.9559646376764704",
      "tr": "0.9716260473299283",
      "vi": "0.9569474608018311"
    },
    "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}",
    "instruction": {
      "en": "Write a Swift function `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` to solve the following problem:\n\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n",
      "es": "Escribe una función Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` para resolver el siguiente problema:\n\nCuenta el número de maneras de elegir platos de un menú de manera que el costo total\ncoincida exactamente con un presupuesto dado. Cada plato solo se puede seleccionar una vez.\n\n- Parámetros:\n- dishes: Un arreglo de enteros donde cada entero representa el costo de un plato.\n- budget: Un entero que representa el presupuesto total para la comida.\n- Devuelve: El número total de combinaciones únicas de platos que suman exactamente el presupuesto.\n\n## Ejemplo:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "arb": "اكتب دالة Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` لحل المشكلة التالية:\n\nتحسب عدد الطرق لاختيار الأطباق من قائمة طعام بحيث تتطابق التكلفة الإجمالية تمامًا مع ميزانية معينة. يمكن اختيار كل طبق مرة واحدة فقط.\n\n- المعاملات:\n- dishes: مصفوفة من الأعداد الصحيحة حيث يمثل كل عدد صحيح تكلفة طبق.\n- budget: عدد صحيح يمثل الميزانية الإجمالية للوجبة.\n- يعيد: العدد الإجمالي للتوليفات الفريدة من الأطباق التي تتطابق مجموعها تمامًا مع الميزانية.\n\n## مثال:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "sw": "Andika kazi ya Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu idadi ya njia za kuchagua sahani kutoka kwenye menyu ili gharama ya jumla\nilingane kabisa na bajeti iliyotolewa. Kila sahani inaweza kuchaguliwa mara moja tu.\n\n- Vigezo:\n- dishes: Safu ya namba ambapo kila namba inawakilisha gharama ya sahani.\n- budget: Namba inayowakilisha bajeti ya jumla kwa ajili ya mlo.\n- Inarudisha: Jumla ya idadi ya mchanganyiko wa kipekee wa sahani ambazo jumla yake ni sawa na bajeti.\n\n## Mfano:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "tr": "Bir Swift fonksiyonu `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\n\nBir menüden yemeklerin toplam maliyetinin verilen bir bütçeye tam olarak eşit olacak şekilde seçilme yollarının sayısını sayar. Her yemek yalnızca bir kez seçilebilir.\n\n- Parametreler:\n- dishes: Her bir tamsayının bir yemeğin maliyetini temsil ettiği bir tamsayı dizisi.\n- budget: Yemek için toplam bütçeyi temsil eden bir tamsayı.\n- Döndürür: Yemeklerin tam olarak bütçeye eşit olan benzersiz kombinasyonlarının toplam sayısı.\n\n## Örnek:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "vi": "Viết một hàm Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` để giải quyết vấn đề sau:\n\nĐếm số cách chọn món ăn từ thực đơn sao cho tổng chi phí khớp chính xác với ngân sách đã cho. Mỗi món ăn chỉ có thể được chọn một lần.\n\n- Tham số:\n- dishes: Một mảng số nguyên trong đó mỗi số nguyên đại diện cho chi phí của một món ăn.\n- budget: Một số nguyên đại diện cho tổng ngân sách cho bữa ăn.\n- Trả về: Tổng số tổ hợp món ăn duy nhất mà tổng chi phí chính xác bằng ngân sách.\n\n## Ví dụ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]"
    },
    "instruction_bertscore": {
      "es": "0.9920089011405854",
      "arb": "0.9813851552109344",
      "sw": "0.9663859792478469",
      "tr": "0.9766374918434385",
      "vi": "0.9759849910417389"
    },
    "level": "easy",
    "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)",
    "entry_point": "countMealCombinations",
    "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n",
      "es": "Cuenta el número de formas de elegir platos de un menú de manera que el costo total coincida exactamente con un presupuesto dado. Cada plato solo se puede seleccionar una vez.\n\n- Parámetros:\n- dishes: Un arreglo de enteros donde cada entero representa el costo de un plato.\n- budget: Un entero que representa el presupuesto total para la comida.\n- Devuelve: El número total de combinaciones únicas de platos que suman exactamente el presupuesto.\n\n## Ejemplo:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "arb": "يحسب عدد الطرق لاختيار الأطباق من قائمة طعام بحيث يتطابق التكلفة الإجمالية تمامًا مع ميزانية معينة. يمكن اختيار كل طبق مرة واحدة فقط.\n\n- المعلمات:\n- dishes: مصفوفة من الأعداد الصحيحة حيث يمثل كل عدد صحيح تكلفة طبق.\n- budget: عدد صحيح يمثل الميزانية الإجمالية للوجبة.\n- Returns: العدد الإجمالي للتوليفات الفريدة من الأطباق التي تساوي بالضبط الميزانية.\n\n## مثال:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "sw": "Hesabu idadi ya njia za kuchagua vyakula kutoka kwenye menyu ili gharama ya jumla\nilingane kabisa na bajeti iliyotolewa. Kila chakula kinaweza kuchaguliwa mara moja tu.\n\n- Vigezo:\n- dishes: Mfululizo wa namba za mzima ambapo kila namba inawakilisha gharama ya chakula.\n- budget: Namba ya mzima inayowakilisha bajeti ya jumla kwa mlo.\n- Inarejesha: Jumla ya idadi ya michanganyiko ya kipekee ya vyakula ambayo inajumlisha kabisa na bajeti.\n\n## Mfano:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "tr": "Menüden yemek seçmenin toplam maliyetinin belirli bir bütçeye tam olarak eşleştiği yolların sayısını sayar. Her yemek sadece bir kez seçilebilir.\n\n- Parametreler:\n- dishes: Her bir tamsayı bir yemeğin maliyetini temsil eden bir tamsayı dizisi.\n- budget: Yemek için toplam bütçeyi temsil eden bir tamsayı.\n- Döndürür: Bütçeye tam olarak eşit olan yemeklerin benzersiz kombinasyonlarının toplam sayısı.\n\n## Örnek:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "vi": "Đếm số cách chọn món ăn từ thực đơn sao cho tổng chi phí khớp chính xác với ngân sách đã cho. Mỗi món ăn chỉ có thể được chọn một lần.\n\n- Tham số:\n- dishes: Một mảng các số nguyên mà mỗi số nguyên đại diện cho chi phí của một món ăn.\n- budget: Một số nguyên đại diện cho tổng ngân sách cho bữa ăn.\n- Trả về: Tổng số các tổ hợp món ăn duy nhất mà tổng cộng chính xác bằng ngân sách.\n\n## Ví dụ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9893410964929058",
      "arb": "0.977778822012865",
      "sw": "0.975484641111912",
      "tr": "0.9685002010235823",
      "vi": "0.9826927390092871"
    }
  },
  {
    "task_id": "Swift/38",
    "prompt": {
      "en": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "es": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalcula la última hora a la que yyy puede salir para la escuela sin llegar tarde.\nLa escuela está a 'distance' metros de distancia, y yyy camina a una velocidad de 'speed' metros por minuto.\nAdemás, yyy pasa 10 minutos adicionales clasificando basura en el camino.\n\nLa escuela requiere llegar antes de las 08:00 AM. Esta función devuelve la última hora de salida en formato HH:MM.\n\nEjemplos:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "arb": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nيحسب آخر وقت يمكن لـ yyy أن يغادر فيه إلى المدرسة دون أن يتأخر.\nالمدرسة تبعد 'distance' مترًا، و yyy يمشي بسرعة 'speed' متر في الدقيقة.\nبالإضافة إلى ذلك، يقضي yyy 10 دقائق إضافية في فرز القمامة في الطريق.\n\nتتطلب المدرسة الوصول بحلول الساعة 08:00 صباحًا. تعيد هذه الدالة آخر وقت للمغادرة بتنسيق HH:MM.\n\nأمثلة:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "sw": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nInakokotoa muda wa mwisho ambao yyy anaweza kuondoka kwenda shule bila kuchelewa.\nShule iko umbali wa 'distance' mita, na yyy anatembea kwa kasi ya 'speed' mita kwa dakika.\nZaidi ya hayo, yyy anatumia dakika 10 za ziada kwa ajili ya kupanga takataka njiani.\n\nShule inahitaji kufika kabla ya saa 02:00 asubuhi. Kazi hii inarejesha muda wa mwisho wa kuondoka katika muundo wa HH:MM.\n\nMifano:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "tr": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nOkula geç kalmadan yyy'nin en geç ne zaman çıkabileceğini hesaplar. \nOkul 'distance' metre uzakta ve yyy 'speed' metre/dakika hızla yürür. \nAyrıca, yyy yolda çöp ayrıştırma için fazladan 10 dakika harcar.\n\nOkulun varış saati 08:00 AM'dir. Bu fonksiyon en geç çıkış saatini HH:MM formatında döndürür.\n\nÖrnekler:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "vi": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nTính toán thời gian muộn nhất mà yyy có thể rời khỏi nhà để đến trường mà không bị trễ. \nTrường cách 'distance' mét, và yyy đi bộ với tốc độ 'speed' mét mỗi phút. \nNgoài ra, yyy dành thêm 10 phút để phân loại rác trên đường đi.\n\nTrường yêu cầu phải đến trước 08:00 sáng. Hàm này trả về thời gian khởi hành muộn nhất dưới định dạng HH:MM.\n\nVí dụ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.989939768461345",
      "arb": "0.9901908372629731",
      "sw": "0.9760930459690219",
      "tr": "0.9768667113031528",
      "vi": "0.9659331019790873"
    },
    "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func latestDepartureTime(distance: Int, speed: Int) -> String {` to solve the following problem:\n\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n",
      "es": "Escribe una función en Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` para resolver el siguiente problema:\n\nCalcula la última hora a la que yyy puede salir para la escuela sin llegar tarde. \nLa escuela está a 'distance' metros de distancia, y yyy camina a una velocidad de 'speed' metros por minuto. \nAdemás, yyy pasa 10 minutos extra clasificando basura en el camino.\n\nLa escuela requiere llegar antes de las 08:00 AM. Esta función devuelve la última hora de salida en formato HH:MM.\n\nEjemplos:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "arb": "اكتب دالة Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` لحل المشكلة التالية:\n\nتحسب آخر وقت يمكن لـ yyy أن يغادر فيه إلى المدرسة دون أن يتأخر. \nالمدرسة تبعد 'distance' مترًا، و yyy يمشي بسرعة 'speed' متر في الدقيقة. \nبالإضافة إلى ذلك، يقضي yyy 10 دقائق إضافية في فرز القمامة في الطريق.\n\nتتطلب المدرسة الوصول بحلول الساعة 08:00 صباحًا. تقوم هذه الدالة بإرجاع آخر وقت للمغادرة بتنسيق HH:MM.\n\nأمثلة:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "sw": "Andika kazi ya Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` kutatua tatizo lifuatalo:\n\nInakokotoa muda wa mwisho kabisa ambao yyy anaweza kuondoka kwenda shule bila kuchelewa. \nShule iko umbali wa 'distance' mita, na yyy anatembea kwa kasi ya 'speed' mita kwa dakika. \nZaidi ya hayo, yyy hutumia dakika 10 za ziada kwa ajili ya kupanga takataka njiani.\n\nShule inahitaji kufika ifikapo saa 02:00 asubuhi. Kazi hii inarejesha muda wa mwisho wa kuondoka katika muundo wa HH:MM.\n\nMifano:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "tr": "Bir Swift fonksiyonu `func latestDepartureTime(distance: Int, speed: Int) -> String {` yazın ve aşağıdaki problemi çözün:\n\nyyy'nin okula geç kalmadan en geç ne zaman çıkabileceğini hesaplar. \nOkul 'distance' metre uzaklıktadır ve yyy 'speed' metre/dakika hızla yürür. \nAyrıca, yyy yolda çöp ayrıştırma için fazladan 10 dakika harcar.\n\nOkul saat 08:00'de varış gerektirir. Bu fonksiyon, en geç çıkış zamanını SS:DD formatında döndürür.\n\nÖrnekler:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "vi": "Viết một hàm Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` để giải quyết vấn đề sau:\n\nTính toán thời gian muộn nhất yyy có thể rời khỏi nhà để đến trường mà không bị muộn. \nTrường cách 'distance' mét, và yyy đi bộ với tốc độ 'speed' mét mỗi phút. \nNgoài ra, yyy mất thêm 10 phút để phân loại rác trên đường đi.\n\nTrường yêu cầu đến trước 08:00 AM. Hàm này trả về thời gian khởi hành muộn nhất dưới dạng HH:MM.\n\nVí dụ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\""
    },
    "instruction_bertscore": {
      "es": "0.979315625270932",
      "arb": "0.9871720527320048",
      "sw": "0.9678786865613241",
      "tr": "0.978041014115831",
      "vi": "0.9667778769896287"
    },
    "level": "hard",
    "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)",
    "entry_point": "latestDepartureTime",
    "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {",
    "docstring": {
      "en": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n",
      "es": "Calcula la última hora a la que yyy puede salir para la escuela sin llegar tarde. \nLa escuela está a 'distance' metros de distancia, y yyy camina a una velocidad de 'speed' metros por minuto. \nAdemás, yyy pasa 10 minutos adicionales clasificando basura en el camino.\n\nLa escuela requiere llegar antes de las 08:00 AM. Esta función devuelve la última hora de salida en formato HH:MM.\n\nEjemplos:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "arb": "يحسب أحدث وقت يمكن لـ yyy مغادرة المنزل إلى المدرسة دون تأخير. \nالمدرسة تبعد 'distance' مترًا، و yyy يمشي بسرعة 'speed' متر في الدقيقة. \nبالإضافة إلى ذلك، يقضي yyy 10 دقائق إضافية في فرز القمامة في الطريق.\n\nتتطلب المدرسة الوصول بحلول الساعة 08:00 صباحًا. تُرجع هذه الدالة أحدث وقت للمغادرة بتنسيق HH:MM.\n\nأمثلة:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "sw": "Hesabu wakati wa mwisho ambao yyy anaweza kuondoka kwenda shule bila kuchelewa. \nShule iko umbali wa 'distance' mita, na yyy anatembea kwa kasi ya 'speed' mita kwa dakika. \nZaidi ya hayo, yyy hutumia dakika 10 za ziada kwa ajili ya kupanga takataka njiani.\n\nShule inahitaji kufika ifikapo saa 02:00 asubuhi. Kazi hii inarudisha wakati wa mwisho wa kuondoka katika muundo wa HH:MM.\n\nMifano:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "tr": "Okula geç kalmadan yyy'nin en son ne zaman çıkabileceğini hesaplar. \nOkul 'distance' metre uzaklıktadır ve yyy 'speed' metre/dakika hızla yürür. \nAyrıca, yyy yolda çöp ayrıştırma için ekstra 10 dakika harcar.\n\nOkula varış saati en geç 08:00 olmalıdır. Bu fonksiyon, en geç çıkış saatini SS:DD formatında döndürür.\n\nÖrnekler:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "vi": "Tính toán thời gian muộn nhất yyy có thể rời khỏi nhà để đến trường mà không bị muộn. \nTrường học cách 'distance' mét, và yyy đi bộ với tốc độ 'speed' mét mỗi phút. \nNgoài ra, yyy dành thêm 10 phút để phân loại rác trên đường đi.\n\nTrường yêu cầu đến trước 08:00 AM. Hàm này trả về thời gian khởi hành muộn nhất theo định dạng HH:MM.\n\nVí dụ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\""
    },
    "docstring_bertscore": {
      "es": "0.979242132029949",
      "arb": "0.9870119566448907",
      "sw": "0.9575280574055961",
      "tr": "0.9610042877040876",
      "vi": "0.9627329679102343"
    }
  },
  {
    "task_id": "Swift/39",
    "prompt": {
      "en": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "es": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalcula la puntuación final de un concursante eliminando las puntuaciones más altas y más bajas del\narreglo dado de puntuaciones y luego calculando el promedio de las puntuaciones restantes.\nEl resultado se redondea a dos decimales.\n\n- Parámetros:\n- scores: Un arreglo de `Double` que representa las puntuaciones dadas por cada juez.\n\n- Devuelve: Un `Double` que representa la puntuación final del concursante, redondeada a dos decimales.\n\nEjemplos:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "arb": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nيحسب النتيجة النهائية لمتسابق عن طريق إزالة أعلى وأدنى الدرجات من\nالمصفوفة المعطاة من الدرجات ثم حساب متوسط الدرجات المتبقية.\nيتم تقريب النتيجة إلى منزلتين عشريتين.\n\n- Parameters:\n- scores: مصفوفة من `Double` تمثل الدرجات المعطاة من قبل كل حكم.\n\n- Returns: قيمة `Double` تمثل النتيجة النهائية للمتسابق، مقربة إلى منزلتين عشريتين.\n\nأمثلة:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "sw": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nHesabu alama ya mwisho kwa mshindani kwa kuondoa alama za juu na za chini kutoka kwenye\narray iliyotolewa ya alama na kisha kuhesabu wastani wa alama zilizobaki.\nMatokeo yanazungushwa hadi sehemu mbili za desimali.\n\n- Vigezo:\n- scores: Array ya `Double` inayowakilisha alama zilizotolewa na kila jaji.\n\n- Inarejesha: `Double` inayowakilisha alama ya mwisho ya mshindani, iliyozungushwa hadi sehemu mbili za desimali.\n\nMifano:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "tr": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nBir yarışmacının nihai puanını hesaplar, verilen puanlar dizisinden en yüksek ve en düşük puanları çıkarır ve ardından kalan puanların ortalamasını alır.\nSonuç iki ondalık basamağa yuvarlanır.\n\n- Parametreler:\n- scores: Her bir jüri tarafından verilen puanları temsil eden `Double` türünde bir dizi.\n\n- Dönüş: Yarışmacının nihai puanını temsil eden, iki ondalık basamağa yuvarlanmış bir `Double`.\n\nÖrnekler:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "vi": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nTính điểm cuối cùng cho một thí sinh bằng cách loại bỏ điểm cao nhất và thấp nhất từ\nmảng điểm số đã cho và sau đó tính trung bình của các điểm số còn lại.\nKết quả được làm tròn đến hai chữ số thập phân.\n\n- Tham số:\n- scores: Một mảng `Double` đại diện cho điểm số được đưa ra bởi mỗi giám khảo.\n\n- Trả về: Một `Double` đại diện cho điểm cuối cùng của thí sinh, được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9936708415387043",
      "arb": "0.99205776421432",
      "sw": "0.9733577069917905",
      "tr": "0.987537135372347",
      "vi": "0.9829233488816685"
    },
    "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}",
    "instruction": {
      "en": "Write a Swift function `func calculateFinalScore(_ scores: [Double]) -> Double {` to solve the following problem:\n\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n",
      "es": "Escribe una función Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` para resolver el siguiente problema:\n\nCalcula la puntuación final para un concursante eliminando las puntuaciones más altas y más bajas del\narreglo de puntuaciones dado y luego calculando el promedio de las puntuaciones restantes.\nEl resultado se redondea a dos decimales.\n\n- Parámetros:\n- scores: Un arreglo de `Double` que representa las puntuaciones dadas por cada juez.\n\n- Retorna: Un `Double` que representa la puntuación final del concursante, redondeada a dos decimales.\n\nEjemplos:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "arb": "اكتب دالة Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` لحل المشكلة التالية:\n\nتحسب النتيجة النهائية لمتسابق عن طريق إزالة أعلى وأدنى الدرجات من\nالمصفوفة المعطاة من الدرجات ثم حساب متوسط الدرجات المتبقية.\nيتم تقريب النتيجة إلى منزلتين عشريتين.\n\n- المعاملات:\n- scores: مصفوفة من `Double` تمثل الدرجات المعطاة من كل حكم.\n\n- الإرجاع: قيمة `Double` تمثل النتيجة النهائية للمتسابق، مقربة إلى منزلتين عشريتين.\n\nأمثلة:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "sw": "Andika kazi ya Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` kutatua tatizo lifuatalo:\n\nHesabu alama ya mwisho kwa mshindani kwa kuondoa alama za juu na za chini kutoka kwenye\norodha iliyotolewa ya alama na kisha kuhesabu wastani wa alama zilizobaki.\nMatokeo yanazungushwa hadi sehemu mbili za desimali.\n\n- Vigezo:\n- scores: Orodha ya `Double` inayowakilisha alama zilizotolewa na kila jaji.\n\n- Inarudisha: `Double` inayowakilisha alama ya mwisho ya mshindani, iliyozungushwa hadi sehemu mbili za desimali.\n\nMifano:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "tr": "Bir Swift fonksiyonu `func calculateFinalScore(_ scores: [Double]) -> Double {` yazın ve aşağıdaki problemi çözün:\n\nBir yarışmacının nihai puanını hesaplar, verilen puanlar dizisinden en yüksek ve en düşük puanları çıkarır ve kalan puanların ortalamasını hesaplar. Sonuç, iki ondalık basamağa yuvarlanır.\n\n- Parametreler:\n- scores: Her bir hakemin verdiği puanları temsil eden bir `Double` dizisi.\n\n- Dönüş: Yarışmacının nihai puanını temsil eden, iki ondalık basamağa yuvarlanmış bir `Double`.\n\nÖrnekler:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "vi": "Viết một hàm Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` để giải quyết vấn đề sau:\n\nTính điểm cuối cùng cho một thí sinh bằng cách loại bỏ điểm cao nhất và thấp nhất từ mảng điểm đã cho và sau đó tính trung bình của các điểm còn lại. Kết quả được làm tròn đến hai chữ số thập phân.\n\n- Tham số:\n- scores: Một mảng `Double` đại diện cho điểm số được cho bởi mỗi giám khảo.\n\n- Trả về: Một `Double` đại diện cho điểm cuối cùng của thí sinh, được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00"
    },
    "instruction_bertscore": {
      "es": "0.9945257466986784",
      "arb": "0.9868202783271921",
      "sw": "0.9823175262195122",
      "tr": "0.9855184548098894",
      "vi": "0.9820362655999668"
    },
    "level": "middle",
    "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()",
    "entry_point": "calculateFinalScore",
    "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {",
    "docstring": {
      "en": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n",
      "es": "Calcula la puntuación final para un concursante eliminando las puntuaciones más altas y más bajas del\narreglo dado de puntuaciones y luego calculando el promedio de las puntuaciones restantes.\nEl resultado se redondea a dos decimales.\n\n- Parámetros:\n- scores: Un arreglo de `Double` que representa las puntuaciones dadas por cada juez.\n\n- Devuelve: Un `Double` que representa la puntuación final del concursante, redondeada a dos decimales.\n\nEjemplos:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "arb": "يحسب النتيجة النهائية لمتسابق عن طريق إزالة أعلى وأدنى الدرجات من\nالمصفوفة المعطاة من الدرجات ثم حساب متوسط الدرجات المتبقية.\nيتم تقريب النتيجة إلى منزلتين عشريتين.\n\n- المعلمات:\n- scores: مصفوفة من `Double` تمثل الدرجات المعطاة من قبل كل حكم.\n\n- العوائد: قيمة `Double` تمثل النتيجة النهائية للمتسابق، مقربة إلى منزلتين عشريتين.\n\nأمثلة:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "sw": "Inahesabu alama ya mwisho kwa mshiriki kwa kuondoa alama ya juu na ya chini kutoka kwenye safu iliyotolewa ya alama na kisha kuhesabu wastani wa alama zilizobaki. \nMatokeo yanazungushwa hadi sehemu mbili za desimali.\n\n- Vigezo:\n- scores: Safu ya `Double` inayowakilisha alama zilizotolewa na kila jaji.\n\n- Inarejesha: `Double` inayowakilisha alama ya mwisho ya mshiriki, iliyozungushwa hadi sehemu mbili za desimali.\n\nMifano:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "tr": "Verilen puanlar dizisinden en yüksek ve en düşük puanları çıkararak bir yarışmacının nihai puanını hesaplar ve ardından kalan puanların ortalamasını hesaplar. Sonuç, iki ondalık basamağa yuvarlanır.\n\n- Parametreler:\n- scores: Her hakem tarafından verilen puanları temsil eden bir `Double` dizisi.\n\n- Döndürür: Yarışmacının nihai puanını temsil eden, iki ondalık basamağa yuvarlanmış bir `Double`.\n\nÖrnekler:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "vi": "Tính điểm cuối cùng cho một thí sinh bằng cách loại bỏ điểm cao nhất và thấp nhất từ mảng điểm đã cho và sau đó tính trung bình của các điểm còn lại. Kết quả được làm tròn đến hai chữ số thập phân.\n\n- Tham số:\n- scores: Một mảng `Double` đại diện cho điểm số được cho bởi mỗi giám khảo.\n\n- Trả về: Một `Double` đại diện cho điểm cuối cùng của thí sinh, được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00"
    },
    "docstring_bertscore": {
      "es": "0.992666566332192",
      "arb": "0.988419848785666",
      "sw": "0.9783802748066386",
      "tr": "0.9688940850691744",
      "vi": "0.9757613332326937"
    }
  },
  {
    "task_id": "Swift/40",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "es": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalcula la diferencia mínima absoluta entre la acidez total y la amargura total de una combinación de ingredientes. La acidez total es el producto de la acidez de cada ingrediente utilizado, y la amargura total es la suma de la amargura de cada ingrediente utilizado. Se debe utilizar al menos un ingrediente.\n\n- Parámetros:\n- ingredients: Un arreglo de tuplas, donde cada tupla contiene la acidez y la amargura de un ingrediente.\n\n- Retorna: La diferencia mínima absoluta entre la acidez total y la amargura total.\n\nEjemplo:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "arb": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nيحسب الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية لمجموعة من المكونات. الحموضة الكلية هي حاصل ضرب حموضة كل مكون مستخدم، والمرارة الكلية هي مجموع مرارة كل مكون مستخدم. يجب استخدام مكون واحد على الأقل.\n\n- Parameters:\n- ingredients: مصفوفة من الأزواج، حيث يحتوي كل زوج على حموضة ومرارة مكون.\n\n- Returns: الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية.\n\nمثال:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "sw": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nHesabu tofauti ndogo kabisa ya thamani kati ya ukali wa jumla na uchungu wa jumla wa mchanganyiko wa viungo. Ukali wa jumla ni bidhaa ya ukali wa kila kiungo kilichotumika, na uchungu wa jumla ni jumla ya uchungu wa kila kiungo kilichotumika. Angalau kiungo kimoja lazima kitumike.\n\n- Vigezo:\n- ingredients: Safu ya jozi, ambapo kila jozi ina ukali na uchungu wa kiungo.\n\n- Inarejesha: Tofauti ndogo kabisa ya thamani kati ya ukali wa jumla na uchungu wa jumla.\n\nMfano:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "tr": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nMalzemelerin bir kombinasyonunun toplam ekşiliği ile toplam acılığı arasındaki minimum mutlak farkı hesaplar. Toplam ekşilik, kullanılan her bir malzemenin ekşiliğinin çarpımıdır ve toplam acılık, kullanılan her bir malzemenin acılığının toplamıdır. En az bir malzeme kullanılmalıdır.\n\n- Parametreler:\n- ingredients: Her bir demet, bir malzemenin ekşiliği ve acılığını içeren demetlerden oluşan bir dizi.\n\n- Döndürür: Toplam ekşilik ile toplam acılık arasındaki minimum mutlak fark.\n\nÖrnek:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "vi": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nTính toán sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng của một sự kết hợp các thành phần. Tổng độ chua là tích của độ chua của mỗi thành phần được sử dụng, và tổng độ đắng là tổng của độ đắng của mỗi thành phần được sử dụng. Ít nhất một thành phần phải được sử dụng.\n\n- Tham số:\n- ingredients: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị chứa độ chua và độ đắng của một thành phần.\n\n- Trả về: Sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng.\n\nVí dụ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9917159213285589",
      "arb": "0.9814491141936277",
      "sw": "0.9568129880338705",
      "tr": "0.9954096518942838",
      "vi": "0.9840849393499607"
    },
    "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}",
    "instruction": {
      "en": "Write a Swift function `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` to solve the following problem:\n\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n",
      "es": "Escribe una función de Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` para resolver el siguiente problema:\n\nCalcula la diferencia absoluta mínima entre la acidez total y la amargura total de una combinación de ingredientes. La acidez total es el producto de la acidez de cada ingrediente utilizado, y la amargura total es la suma de la amargura de cada ingrediente utilizado. Se debe usar al menos un ingrediente.\n\n- Parámetros:\n- ingredients: Un arreglo de tuplas, donde cada tupla contiene la acidez y la amargura de un ingrediente.\n\n- Retorna: La diferencia absoluta mínima entre la acidez total y la amargura total.\n\nEjemplo:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "arb": "اكتب دالة Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` لحل المشكلة التالية:\n\nتحسب الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية لمجموعة من المكونات. الحموضة الكلية هي ناتج حموضة كل مكون مستخدم، والمرارة الكلية هي مجموع مرارة كل مكون مستخدم. يجب استخدام مكون واحد على الأقل.\n\n- المعاملات:\n- ingredients: مصفوفة من الأزواج، حيث يحتوي كل زوج على حموضة ومرارة مكون.\n\n- العوائد: الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية.\n\nمثال:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "sw": "Andika kazi ya Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` kutatua tatizo lifuatalo:\n\nHesabu tofauti ndogo kabisa ya thamani kati ya jumla ya ukali na jumla ya uchungu wa mchanganyiko wa viungo. Jumla ya ukali ni bidhaa ya ukali wa kila kiungo kilichotumika, na jumla ya uchungu ni jumla ya uchungu wa kila kiungo kilichotumika. Angalau kiungo kimoja lazima kitumike.\n\n- Vigezo:\n- ingredients: Orodha ya jozi, ambapo kila jozi ina ukali na uchungu wa kiungo.\n\n- Inarudisha: Tofauti ndogo kabisa ya thamani kati ya jumla ya ukali na jumla ya uchungu.\n\nMfano:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "tr": "Bir Swift fonksiyonu `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` yazın:\n\nMalzemelerin toplam ekşiliği ile toplam acılığı arasındaki minimum mutlak farkı hesaplar. Toplam ekşilik, kullanılan her bir malzemenin ekşiliğinin çarpımıdır ve toplam acılık, kullanılan her bir malzemenin acılığının toplamıdır. En az bir malzeme kullanılmalıdır.\n\n- Parametreler:\n- ingredients: Her bir demetin bir malzemenin ekşiliği ve acılığını içerdiği demetlerden oluşan bir dizi.\n\n- Döndürür: Toplam ekşilik ve toplam acılık arasındaki minimum mutlak fark.\n\nÖrnek:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "vi": "Viết một hàm Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` để giải quyết vấn đề sau:\n\nTính toán sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng của một tổ hợp các nguyên liệu. Tổng độ chua là tích của độ chua của mỗi nguyên liệu được sử dụng, và tổng độ đắng là tổng của độ đắng của mỗi nguyên liệu được sử dụng. Ít nhất một nguyên liệu phải được sử dụng.\n\n- Tham số:\n- ingredients: Một mảng các bộ giá trị, trong đó mỗi bộ chứa độ chua và độ đắng của một nguyên liệu.\n\n- Trả về: Sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng.\n\nVí dụ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1"
    },
    "instruction_bertscore": {
      "es": "0.9907245570968138",
      "arb": "0.9772774789311329",
      "sw": "0.9588451754622385",
      "tr": "0.9730156654756483",
      "vi": "0.9903793374945752"
    },
    "level": "hard",
    "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()",
    "entry_point": "minimumTasteDifference",
    "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n",
      "es": "Calcula la diferencia mínima absoluta entre la acidez total y la amargura total de una combinación de ingredientes. La acidez total es el producto de la acidez de cada ingrediente utilizado, y la amargura total es la suma de la amargura de cada ingrediente utilizado. Se debe usar al menos un ingrediente.\n\n- Parámetros:\n- ingredients: Un array de tuplas, donde cada tupla contiene la acidez y la amargura de un ingrediente.\n\n- Devuelve: La diferencia mínima absoluta entre la acidez total y la amargura total.\n\nEjemplo:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "arb": "يحسب الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية لمجموعة من المكونات. الحموضة الكلية هي حاصل ضرب حموضة كل مكون مستخدم، والمرارة الكلية هي مجموع مرارة كل مكون مستخدم. يجب استخدام مكون واحد على الأقل.\n\n- المعلمات:\n- ingredients: مصفوفة من الأزواج، حيث يحتوي كل زوج على حموضة ومرارة مكون.\n\n- العوائد: الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية.\n\nمثال:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "sw": "Hesabu tofauti ndogo kabisa ya thamani kati ya jumla ya uchachu na jumla ya uchungu wa mchanganyiko wa viungo. Jumla ya uchachu ni zao la uchachu wa kila kiungo kilichotumika, na jumla ya uchungu ni jumla ya uchungu wa kila kiungo kilichotumika. Angalau kiungo kimoja lazima kitumike.\n\n- Vigezo:\n- ingredients: Ni safu ya jozi, ambapo kila jozi ina uchachu na uchungu wa kiungo.\n\n- Inarejesha: Tofauti ndogo kabisa ya thamani kati ya jumla ya uchachu na jumla ya uchungu.\n\nMfano:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "tr": "Toplam ekşilik ve toplam acılık arasındaki minimum mutlak farkı hesaplar. Toplam ekşilik, kullanılan her bir malzemenin ekşiliğinin çarpımıdır ve toplam acılık, kullanılan her bir malzemenin acılığının toplamıdır. En az bir malzeme kullanılmalıdır.\n\n- Parametreler:\n- ingredients: Her bir demetin bir malzemenin ekşiliğini ve acılığını içerdiği demetlerin bir dizisi.\n\n- Döndürür: Toplam ekşilik ve toplam acılık arasındaki minimum mutlak fark.\n\nÖrnek:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "vi": "Tính toán sự chênh lệch tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng của một tổ hợp các nguyên liệu. Tổng độ chua là tích của độ chua của mỗi nguyên liệu được sử dụng, và tổng độ đắng là tổng của độ đắng của mỗi nguyên liệu được sử dụng. Ít nhất phải sử dụng một nguyên liệu.\n\n- Tham số:\n- ingredients: Một mảng các bộ giá trị, trong đó mỗi bộ chứa độ chua và độ đắng của một nguyên liệu.\n\n- Trả về: Sự chênh lệch tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng.\n\nVí dụ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9581213663537472",
      "arb": "0.9441691711290947",
      "sw": "0.9583366816867891",
      "tr": "0.9765508889973074",
      "vi": "0.9788224260348223"
    }
  },
  {
    "task_id": "Swift/41",
    "prompt": {
      "en": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calculates the product of the sum of the first two integers and the third integer.\n\n    This function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n    - Parameters:\n        - a: The first integer.\n        - b: The second integer.\n        - c: The third integer.\n\n    - Returns: An integer that is the product of (a+b) and c.\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */",
      "es": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calcula el producto de la suma de los dos primeros enteros y el tercer entero.\n\n    Esta función toma tres enteros como entrada y calcula el producto de la suma de los dos primeros enteros (a y b) y el tercer entero (c), calculando efectivamente (a+b)*c.\n\n    - Parámetros:\n        - a: El primer entero.\n        - b: El segundo entero.\n        - c: El tercer entero.\n\n    - Devuelve: Un entero que es el producto de (a+b) y c.\n\n    ### Ejemplo:\n    calculateProductOfSumAndValue(1, 2, 3) // Devuelve 9 porque (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Devuelve -9 porque (-1-2)*-3 = 9\n    */",
      "arb": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    يحسب حاصل ضرب مجموع العددين الأولين والعدد الثالث.\n\n    تأخذ هذه الدالة ثلاثة أعداد صحيحة كمدخلات وتحسب حاصل ضرب مجموع العددين الأولين (a و b) والعدد الثالث (c)، مما يعني حساب (a+b)*c.\n\n    - Parameters:\n        - a: العدد الصحيح الأول.\n        - b: العدد الصحيح الثاني.\n        - c: العدد الصحيح الثالث.\n\n    - Returns: عدد صحيح يمثل حاصل ضرب (a+b) و c.\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */",
      "sw": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Inahesabu bidhaa ya jumla ya nambari mbili za kwanza na nambari ya tatu.\n\n    Kazi hii inachukua nambari tatu kama pembejeo na inahesabu bidhaa ya jumla ya nambari mbili za kwanza (a na b) na nambari ya tatu (c), ikihesabu kwa ufanisi (a+b)*c.\n\n    - Vigezo:\n        - a: Nambari ya kwanza.\n        - b: Nambari ya pili.\n        - c: Nambari ya tatu.\n\n    - Inarudisha: Nambari ambayo ni bidhaa ya (a+b) na c.\n\n    ### Mfano:\n    calculateProductOfSumAndValue(1, 2, 3) // Inarudisha 9 kwa sababu (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Inarudisha -9 kwa sababu (-1-2)*-3 = 9\n    */",
      "tr": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    İlk iki tam sayının toplamı ile üçüncü tam sayının çarpımını hesaplar.\n\n    Bu fonksiyon üç tam sayı alır ve ilk iki tam sayının (a ve b) toplamı ile üçüncü tam sayının (c) çarpımını hesaplar, yani (a+b)*c hesaplar.\n\n    - Parametreler:\n        - a: Birinci tam sayı.\n        - b: İkinci tam sayı.\n        - c: Üçüncü tam sayı.\n\n    - Döndürür: (a+b) ve c'nin çarpımı olan bir tam sayı.\n\n    ### Örnek:\n    calculateProductOfSumAndValue(1, 2, 3) // (1+2)*3 = 9 olduğu için 9 döndürür\n    calculateProductOfSumAndValue(-1, -2, -3) // (-1-2)*-3 = 9 olduğu için -9 döndürür\n    */",
      "vi": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Tính tích của tổng hai số nguyên đầu tiên và số nguyên thứ ba.\n\n    Hàm này nhận ba số nguyên làm đầu vào và tính tích của tổng hai số nguyên đầu tiên (a và b) và số nguyên thứ ba (c), thực hiện phép tính (a+b)*c.\n\n    - Tham số:\n        - a: Số nguyên thứ nhất.\n        - b: Số nguyên thứ hai.\n        - c: Số nguyên thứ ba.\n\n    - Trả về: Một số nguyên là tích của (a+b) và c.\n\n    ### Ví dụ:\n    calculateProductOfSumAndValue(1, 2, 3) // Trả về 9 vì (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Trả về -9 vì (-1-2)*-3 = 9\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9948121717081307",
      "arb": "0.9769926429647289",
      "sw": "0.9708847587479061",
      "tr": "0.9716606090162284",
      "vi": "0.9884538145808229"
    },
    "canonical_solution": "    return (a + b) * c\n}",
    "instruction": {
      "en": "Write a Swift function `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` to solve the following problem:\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n",
      "es": "Escribe una función Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` para resolver el siguiente problema:\nCalcula el producto de la suma de los dos primeros enteros y el tercer entero.\n\nEsta función toma tres enteros como entrada y calcula el producto de la suma de los dos primeros enteros (a y b) y el tercer entero (c), calculando efectivamente (a+b)*c.\n\n- Parámetros:\n- a: El primer entero.\n- b: El segundo entero.\n- c: El tercer entero.\n\n- Retorna: Un entero que es el producto de (a+b) y c.\n\n### Ejemplo:\ncalculateProductOfSumAndValue(1, 2, 3) // Retorna 9 porque (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Retorna -9 porque (-1-2)*-3 = 9",
      "arb": "اكتب دالة Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` لحل المشكلة التالية:\nتحسب حاصل ضرب مجموع العددين الصحيحين الأول والثاني والعدد الصحيح الثالث.\n\nتأخذ هذه الدالة ثلاثة أعداد صحيحة كمدخلات وتحسب حاصل ضرب مجموع العددين الصحيحين الأولين (a و b) والعدد الصحيح الثالث (c)، بحيث تحسب (a+b)*c.\n\n- المعاملات:\n- a: العدد الصحيح الأول.\n- b: العدد الصحيح الثاني.\n- c: العدد الصحيح الثالث.\n\n- العائد: عدد صحيح يمثل حاصل ضرب (a+b) و c.\n\n### مثال:\ncalculateProductOfSumAndValue(1, 2, 3) // يعيد 9 لأن (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // يعيد -9 لأن (-1-2)*-3 = 9",
      "sw": "Andika kazi ya Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` kutatua tatizo lifuatalo:\nInahesabu bidhaa ya jumla ya nambari mbili za kwanza na nambari ya tatu.\n\nKazi hii inachukua nambari tatu kama pembejeo na inahesabu bidhaa ya jumla ya nambari mbili za kwanza (a na b) na nambari ya tatu (c), kwa ufanisi inahesabu (a+b)*c.\n\n- Vigezo:\n- a: Nambari ya kwanza.\n- b: Nambari ya pili.\n- c: Nambari ya tatu.\n\n- Inarudisha: Nambari ambayo ni bidhaa ya (a+b) na c.\n\n### Mfano:\ncalculateProductOfSumAndValue(1, 2, 3) // Inarudisha 9 kwa sababu (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Inarudisha -9 kwa sababu (-1-2)*-3 = 9",
      "tr": "Bir Swift fonksiyonu `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\nİlk iki tam sayının toplamı ile üçüncü tam sayının çarpımını hesaplar.\n\nBu fonksiyon üç tam sayı alır ve ilk iki tam sayının (a ve b) toplamı ile üçüncü tam sayının (c) çarpımını hesaplar, yani (a+b)*c'yi hesaplar.\n\n- Parametreler:\n- a: Birinci tam sayı.\n- b: İkinci tam sayı.\n- c: Üçüncü tam sayı.\n\n- Döndürür: (a+b) ve c'nin çarpımı olan bir tam sayı.\n\n### Örnek:\ncalculateProductOfSumAndValue(1, 2, 3) // (1+2)*3 = 9 olduğu için 9 döndürür\ncalculateProductOfSumAndValue(-1, -2, -3) // (-1-2)*-3 = 9 olduğu için -9 döndürür",
      "vi": "Viết một hàm Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` để giải quyết vấn đề sau:\nTính tích của tổng hai số nguyên đầu tiên và số nguyên thứ ba.\n\nHàm này nhận ba số nguyên làm đầu vào và tính tích của tổng hai số nguyên đầu tiên (a và b) và số nguyên thứ ba (c), thực hiện tính (a+b)*c.\n\n- Tham số:\n- a: Số nguyên thứ nhất.\n- b: Số nguyên thứ hai.\n- c: Số nguyên thứ ba.\n\n- Trả về: Một số nguyên là tích của (a+b) và c.\n\n### Ví dụ:\ncalculateProductOfSumAndValue(1, 2, 3) // Trả về 9 vì (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Trả về -9 vì (-1-2)*-3 = 9"
    },
    "instruction_bertscore": {
      "es": "0.994739274358291",
      "arb": "0.9818064502491094",
      "sw": "0.9698808808021557",
      "tr": "0.9658860265787821",
      "vi": "0.9892074182464694"
    },
    "level": "easy",
    "test": "func testCalculateProductOfSumAndValue() {\n    assert(calculateProductOfSumAndValue(1, 2, 3) == 9, \"Test Case 1 Failed\")\n    assert(calculateProductOfSumAndValue(-1, 2, 3) == 3, \"Test Case 2 Failed\")\n    assert(calculateProductOfSumAndValue(-1, -2, -3) == 9, \"Test Case 3 Failed\")\n    assert(calculateProductOfSumAndValue(0, 0, 1) == 0, \"Test Case 4 Failed\")\n    assert(calculateProductOfSumAndValue(10, 20, 30) == 900, \"Test Case 5 Failed\")\n    assert(calculateProductOfSumAndValue(-5, 5, 0) == 0, \"Test Case 6 Failed\")\n    assert(calculateProductOfSumAndValue(100, 200, -1) == -300, \"Test Case 7 Failed\")\n}\n\ntestCalculateProductOfSumAndValue()",
    "entry_point": "calculateProductOfSumAndValue",
    "signature": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n",
      "es": "Calcula el producto de la suma de los dos primeros enteros y el tercer entero.\n\nEsta función toma tres enteros como entrada y calcula el producto de la suma de los dos primeros enteros (a y b) y el tercer entero (c), calculando efectivamente (a+b)*c.\n\n- Parámetros:\n- a: El primer entero.\n- b: El segundo entero.\n- c: El tercer entero.\n\n- Retorna: Un entero que es el producto de (a+b) y c.\n\n### Ejemplo:\ncalculateProductOfSumAndValue(1, 2, 3) // Retorna 9 porque (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Retorna -9 porque (-1-2)*-3 = 9",
      "arb": "يحسب حاصل ضرب مجموع أول عددين صحيحين والعدد الصحيح الثالث.\n\nتأخذ هذه الدالة ثلاثة أعداد صحيحة كمدخلات وتحسب حاصل ضرب مجموع أول عددين صحيحين (a و b) والعدد الصحيح الثالث (c)، مما يحسب فعليًا (a+b)*c.\n\n- المعاملات:\n- a: العدد الصحيح الأول.\n- b: العدد الصحيح الثاني.\n- c: العدد الصحيح الثالث.\n\n- يعيد: عدد صحيح وهو حاصل ضرب (a+b) و c.\n\n### مثال:\ncalculateProductOfSumAndValue(1, 2, 3) // يعيد 9 لأن (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // يعيد -9 لأن (-1-2)*-3 = 9",
      "sw": "Hesabu bidhaa ya jumla ya nambari mbili za kwanza na nambari ya tatu.\n\nKazi hii inachukua nambari tatu kama pembejeo na inahesabu bidhaa ya jumla ya nambari mbili za kwanza (a na b) na nambari ya tatu (c), kwa ufanisi inahesabu (a+b)*c.\n\n- Vigezo:\n- a: Nambari ya kwanza.\n- b: Nambari ya pili.\n- c: Nambari ya tatu.\n\n- Inarudisha: Nambari ambayo ni bidhaa ya (a+b) na c.\n\n### Mfano:\ncalculateProductOfSumAndValue(1, 2, 3) // Inarudisha 9 kwa sababu (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Inarudisha -9 kwa sababu (-1-2)*-3 = 9",
      "tr": "İlk iki tam sayının toplamı ile üçüncü tam sayının çarpımını hesaplar.\n\nBu fonksiyon üç tam sayı alır ve ilk iki tam sayının (a ve b) toplamı ile üçüncü tam sayının (c) çarpımını hesaplar, yani (a+b)*c hesaplar.\n\n- Parametreler:\n- a: İlk tam sayı.\n- b: İkinci tam sayı.\n- c: Üçüncü tam sayı.\n\n- Döndürür: (a+b) ve c'nin çarpımı olan bir tam sayı.\n\n### Örnek:\ncalculateProductOfSumAndValue(1, 2, 3) // (1+2)*3 = 9 olduğu için 9 döndürür\ncalculateProductOfSumAndValue(-1, -2, -3) // (-1-2)*-3 = 9 olduğu için -9 döndürür",
      "vi": "Tính tích của tổng hai số nguyên đầu tiên và số nguyên thứ ba.\n\nHàm này nhận ba số nguyên làm đầu vào và tính tích của tổng hai số nguyên đầu tiên (a và b) và số nguyên thứ ba (c), thực hiện tính (a+b)*c.\n\n- Tham số:\n- a: Số nguyên thứ nhất.\n- b: Số nguyên thứ hai.\n- c: Số nguyên thứ ba.\n\n- Trả về: Một số nguyên là tích của (a+b) và c.\n\n### Ví dụ:\ncalculateProductOfSumAndValue(1, 2, 3) // Trả về 9 vì (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Trả về -9 vì (-1-2)*-3 = 9"
    },
    "docstring_bertscore": {
      "es": "0.9936809716881371",
      "arb": "0.9906123309315291",
      "sw": "0.9680379881269141",
      "tr": "0.9746023249593551",
      "vi": "0.9875039640987141"
    }
  },
  {
    "task_id": "Swift/42",
    "prompt": {
      "en": "func asciiCode(of character: Character) -> Int {\n    /**\n    Returns the ASCII code of the given character.\n\n    This function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n    - Parameter character: A `Character` value representing a visible character (excluding space).\n\n    - Returns: An `Int` representing the ASCII code of the given character.\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "es": "func asciiCode(of character: Character) -> Int {\n    /**\n    Devuelve el código ASCII del carácter dado.\n\n    Esta función toma un solo carácter (excluyendo el espacio) como entrada y devuelve su código ASCII como un entero. El valor ASCII se determina en función de la representación del carácter en la tabla ASCII.\n\n    - Parámetro character: Un valor `Character` que representa un carácter visible (excluyendo el espacio).\n\n    - Devuelve: Un `Int` que representa el código ASCII del carácter dado.\n\n    ### Ejemplo:\n    asciiCode(of: \"A\") // Devuelve 65\n    asciiCode(of: \"a\") // Devuelve 97\n    */",
      "arb": "func asciiCode(of character: Character) -> Int {\n    /**\n    تُرجع الشيفرة ASCII للحرف المعطى.\n\n    تأخذ هذه الدالة حرفًا واحدًا (باستثناء المسافة) كمدخل وتُرجع شيفرته ASCII كعدد صحيح. يتم تحديد قيمة ASCII بناءً على تمثيل الحرف في جدول ASCII.\n\n    - Parameter character: قيمة `Character` تمثل حرفًا مرئيًا (باستثناء المسافة).\n\n    - Returns: عدد صحيح `Int` يمثل الشيفرة ASCII للحرف المعطى.\n\n    ### مثال:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "sw": "func asciiCode(of character: Character) -> Int {\n    /**\n    Inarudisha msimbo wa ASCII wa herufi iliyotolewa.\n\n    Kazi hii inachukua herufi moja (isipokuwa nafasi) kama ingizo na inarudisha msimbo wake wa ASCII kama nambari kamili. Thamani ya ASCII inatambuliwa kulingana na uwakilishi wa herufi kwenye jedwali la ASCII.\n\n    - Parameter character: Thamani ya `Character` inayowakilisha herufi inayoonekana (isipokuwa nafasi).\n\n    - Returns: `Int` inayowakilisha msimbo wa ASCII wa herufi iliyotolewa.\n\n    ### Mfano:\n    asciiCode(of: \"A\") // Inarudisha 65\n    asciiCode(of: \"a\") // Inarudisha 97\n    */",
      "tr": "func asciiCode(of character: Character) -> Int {\n    /**\n    Verilen karakterin ASCII kodunu döndürür.\n\n    Bu fonksiyon, giriş olarak tek bir karakter (boşluk hariç) alır ve bu karakterin ASCII kodunu bir tamsayı olarak döndürür. ASCII değeri, karakterin ASCII tablosundaki temsilini temel alarak belirlenir.\n\n    - Parametre karakter: Boşluk hariç, görünen bir karakteri temsil eden bir `Character` değeri.\n\n    - Dönüş: Verilen karakterin ASCII kodunu temsil eden bir `Int`.\n\n    ### Örnek:\n    asciiCode(of: \"A\") // 65 döndürür\n    asciiCode(of: \"a\") // 97 döndürür\n    */",
      "vi": "func asciiCode(of character: Character) -> Int {\n    /**\n    Trả về mã ASCII của ký tự đã cho.\n\n    Hàm này nhận một ký tự đơn (không bao gồm khoảng trắng) làm đầu vào và trả về mã ASCII của nó dưới dạng một số nguyên. Giá trị ASCII được xác định dựa trên biểu diễn của ký tự trong bảng ASCII.\n\n    - Tham số character: Một giá trị `Character` đại diện cho một ký tự có thể nhìn thấy (không bao gồm khoảng trắng).\n\n    - Trả về: Một `Int` đại diện cho mã ASCII của ký tự đã cho.\n\n    ### Ví dụ:\n    asciiCode(of: \"A\") // Trả về 65\n    asciiCode(of: \"a\") // Trả về 97\n    */"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.996811783754009",
      "sw": "0.9942395203196072",
      "tr": "0.9759391074237198",
      "vi": "0.98984859711645"
    },
    "canonical_solution": "    return Int(character.asciiValue!)\n}",
    "instruction": {
      "en": "Write a Swift function `func asciiCode(of character: Character) -> Int {` to solve the following problem:\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n",
      "es": "Escribe una función en Swift `func asciiCode(of character: Character) -> Int {` para resolver el siguiente problema:\nDevuelve el código ASCII del carácter dado.\n\nEsta función toma un solo carácter (excluyendo espacio) como entrada y devuelve su código ASCII como un entero. El valor ASCII se determina en función de la representación del carácter en la tabla ASCII.\n\n- Parámetro character: Un valor `Character` que representa un carácter visible (excluyendo espacio).\n\n- Retorna: Un `Int` que representa el código ASCII del carácter dado.\n\n### Ejemplo:\nasciiCode(of: \"A\") // Devuelve 65\nasciiCode(of: \"a\") // Devuelve 97",
      "arb": "اكتب دالة Swift `func asciiCode(of character: Character) -> Int {` لحل المشكلة التالية:\nإرجاع الكود ASCII للحرف المعطى.\n\nتأخذ هذه الدالة حرفًا واحدًا (باستثناء المسافة) كمدخل وتعيد كود ASCII الخاص به كعدد صحيح. يتم تحديد قيمة ASCII بناءً على تمثيل الحرف في جدول ASCII.\n\n- المعامل character: قيمة `Character` تمثل حرفًا مرئيًا (باستثناء المسافة).\n\n- الإرجاع: قيمة `Int` تمثل كود ASCII للحرف المعطى.\n\n### مثال:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97",
      "sw": "Andika kazi ya Swift `func asciiCode(of character: Character) -> Int {` kutatua tatizo lifuatalo:\nInarejesha msimbo wa ASCII wa herufi iliyotolewa.\n\nKazi hii inachukua herufi moja (isipokuwa nafasi) kama ingizo na inarejesha msimbo wake wa ASCII kama nambari kamili. Thamani ya ASCII imedhamiriwa kulingana na uwakilishi wa herufi katika jedwali la ASCII.\n\n- Kigezo herufi: Thamani ya `Character` inayowakilisha herufi inayoonekana (isipokuwa nafasi).\n\n- Inarejesha: `Int` inayowakilisha msimbo wa ASCII wa herufi iliyotolewa.\n\n### Mfano:\nasciiCode(of: \"A\") // Inarejesha 65\nasciiCode(of: \"a\") // Inarejesha 97",
      "tr": "Bir Swift fonksiyonu `func asciiCode(of character: Character) -> Int {` yazın:\nVerilen karakterin ASCII kodunu döndürür.\n\nBu fonksiyon, giriş olarak tek bir karakter (boşluk hariç) alır ve bu karakterin ASCII kodunu bir tamsayı olarak döndürür. ASCII değeri, karakterin ASCII tablosundaki temsilinden belirlenir.\n\n- Parametre karakter: Boşluk hariç, görünür bir karakteri temsil eden bir `Character` değeri.\n\n- Dönüş: Verilen karakterin ASCII kodunu temsil eden bir `Int`.\n\n### Örnek:\nasciiCode(of: \"A\") // 65 döndürür\nasciiCode(of: \"a\") // 97 döndürür",
      "vi": "Viết một hàm Swift `func asciiCode(of character: Character) -> Int {` để giải quyết vấn đề sau:\nTrả về mã ASCII của ký tự đã cho.\n\nHàm này nhận một ký tự đơn (không bao gồm khoảng trắng) làm đầu vào và trả về mã ASCII của nó dưới dạng một số nguyên. Giá trị ASCII được xác định dựa trên biểu diễn của ký tự trong bảng ASCII.\n\n- Tham số character: Một giá trị `Character` đại diện cho một ký tự có thể nhìn thấy (không bao gồm khoảng trắng).\n\n- Trả về: Một `Int` đại diện cho mã ASCII của ký tự đã cho.\n\n### Ví dụ:\nasciiCode(of: \"A\") // Trả về 65\nasciiCode(of: \"a\") // Trả về 97"
    },
    "instruction_bertscore": {
      "es": "0.9936791840147078",
      "arb": "0.9959042415430606",
      "sw": "0.9947865483889773",
      "tr": "0.9140510450831556",
      "vi": "0.9880450332566532"
    },
    "level": "easy",
    "test": "func testAsciiCode() {\n    assert(asciiCode(of: \"A\") == 65, \"Test Case 1 Failed\")\n    assert(asciiCode(of: \"a\") == 97, \"Test Case 2 Failed\")\n    assert(asciiCode(of: \"0\") == 48, \"Test Case 3 Failed\")\n    assert(asciiCode(of: \"#\") == 35, \"Test Case 4 Failed\")\n    assert(asciiCode(of: \"Z\") == 90, \"Test Case 5 Failed\")\n    assert(asciiCode(of: \"z\") == 122, \"Test Case 6 Failed\")\n}\n\ntestAsciiCode()",
    "entry_point": "asciiCode",
    "signature": "func asciiCode(of character: Character) -> Int {",
    "docstring": {
      "en": "\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n",
      "es": "Devuelve el código ASCII del carácter dado.\n\nEsta función toma un solo carácter (excluyendo el espacio) como entrada y devuelve su código ASCII como un entero. El valor ASCII se determina en función de la representación del carácter en la tabla ASCII.\n\n- Parámetro character: Un valor `Character` que representa un carácter visible (excluyendo el espacio).\n\n- Devuelve: Un `Int` que representa el código ASCII del carácter dado.\n\n### Ejemplo:\nasciiCode(of: \"A\") // Devuelve 65\nasciiCode(of: \"a\") // Devuelve 97",
      "arb": "يعيد رمز ASCII للحرف المعطى.\n\nتأخذ هذه الدالة حرفًا واحدًا (باستثناء المسافة) كمدخل وتعيد رمز ASCII الخاص به كعدد صحيح. يتم تحديد قيمة ASCII بناءً على تمثيل الحرف في جدول ASCII.\n\n- Parameter character: قيمة `Character` تمثل حرفًا مرئيًا (باستثناء المسافة).\n\n- Returns: `Int` يمثل رمز ASCII للحرف المعطى.\n\n### مثال:\nasciiCode(of: \"A\") // يعيد 65\nasciiCode(of: \"a\") // يعيد 97",
      "sw": "Inarejesha msimbo wa ASCII wa herufi iliyotolewa.\n\nKazi hii inachukua herufi moja (isipokuwa nafasi) kama ingizo na inarejesha msimbo wake wa ASCII kama nambari kamili. Thamani ya ASCII inatambuliwa kulingana na uwakilishi wa herufi katika jedwali la ASCII.\n\n- Kigezo character: Thamani ya `Character` inayowakilisha herufi inayoonekana (isipokuwa nafasi).\n\n- Inarejesha: `Int` inayowakilisha msimbo wa ASCII wa herufi iliyotolewa.\n\n### Mfano:\nasciiCode(of: \"A\") // Inarejesha 65\nasciiCode(of: \"a\") // Inarejesha 97",
      "tr": "Verilen karakterin ASCII kodunu döndürür.\n\nBu fonksiyon, giriş olarak tek bir karakter (boşluk hariç) alır ve bu karakterin ASCII kodunu bir tamsayı olarak döndürür. ASCII değeri, karakterin ASCII tablosundaki temsilini temel alır.\n\n- Parametre karakter: Görünür bir karakteri (boşluk hariç) temsil eden bir `Character` değeri.\n\n- Döndürür: Verilen karakterin ASCII kodunu temsil eden bir `Int`.\n\n### Örnek:\nasciiCode(of: \"A\") // 65 döndürür\nasciiCode(of: \"a\") // 97 döndürür",
      "vi": "Trả về mã ASCII của ký tự đã cho.\n\nHàm này nhận một ký tự đơn (không bao gồm khoảng trắng) làm đầu vào và trả về mã ASCII của nó dưới dạng một số nguyên. Giá trị ASCII được xác định dựa trên biểu diễn của ký tự trong bảng ASCII.\n\n- Tham số character: Một giá trị `Character` đại diện cho một ký tự có thể nhìn thấy (không bao gồm khoảng trắng).\n\n- Trả về: Một `Int` đại diện cho mã ASCII của ký tự đã cho.\n\n### Ví dụ:\nasciiCode(of: \"A\") // Trả về 65\nasciiCode(of: \"a\") // Trả về 97"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9927464157453679",
      "sw": "0.9908610161685848",
      "tr": "0.9739762419983331",
      "vi": "0.9877129232595628"
    }
  },
  {
    "task_id": "Swift/43",
    "prompt": {
      "en": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Returns the character corresponding to the given ASCII code.\n\n    This function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n    - Parameter code: An `Int` value representing the ASCII code.\n\n    - Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n    ### Example:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "es": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Devuelve el carácter correspondiente al código ASCII dado.\n\n    Esta función toma un entero que representa un código ASCII y devuelve el carácter correspondiente. La función asegura que el código de entrada esté dentro del rango de caracteres ASCII imprimibles (mayor que 0 y menor que 128).\n\n    - Parámetro code: Un valor `Int` que representa el código ASCII.\n\n    - Devuelve: Un `Character?` que representa el carácter correspondiente si el código está dentro del rango ASCII imprimible; de lo contrario, `nil`.\n\n    ### Ejemplo:\n    characterForAsciiCode(65) // Devuelve \"A\"\n    characterForAsciiCode(97) // Devuelve \"a\"\n    */",
      "arb": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    تُعيد الحرف المقابل لرمز ASCII المعطى.\n\n    تأخذ هذه الدالة عددًا صحيحًا يمثل رمز ASCII وتعيد الحرف المقابل. تضمن الدالة أن يكون رمز الإدخال ضمن نطاق أحرف ASCII القابلة للطباعة (أكبر من 0 وأقل من 128).\n\n    - Parameter code: قيمة `Int` تمثل رمز ASCII.\n\n    - Returns: `Character?` يمثل الحرف المقابل إذا كان الرمز ضمن نطاق ASCII القابل للطباعة؛ وإلا، `nil`.\n\n    ### مثال:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "sw": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Inarudisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\n    Kazi hii inachukua nambari nzima inayowakilisha msimbo wa ASCII na inarudisha herufi inayolingana. Kazi hii inahakikisha kwamba msimbo wa ingizo uko ndani ya safu ya herufi zinazoweza kuchapishwa za ASCII (zaidi ya 0 na chini ya 128).\n\n    - Kigezo code: Thamani ya `Int` inayowakilisha msimbo wa ASCII.\n\n    - Inarudisha: `Character?` inayowakilisha herufi inayolingana ikiwa msimbo uko ndani ya safu ya herufi zinazoweza kuchapishwa; vinginevyo, `nil`.\n\n    ### Mfano:\n    characterForAsciiCode(65) // Inarudisha \"A\"\n    characterForAsciiCode(97) // Inarudisha \"a\"\n    */",
      "tr": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Verilen ASCII koduna karşılık gelen karakteri döndürür.\n\n    Bu fonksiyon, bir ASCII kodunu temsil eden bir tam sayı alır ve karşılık gelen karakteri döndürür. Fonksiyon, giriş kodunun yazdırılabilir ASCII karakterleri aralığında (0'dan büyük ve 128'den küçük) olmasını sağlar.\n\n    - Parametre code: ASCII kodunu temsil eden bir `Int` değeri.\n\n    - Dönüş: Kod yazdırılabilir ASCII aralığında ise karşılık gelen karakteri temsil eden bir `Character?`; aksi takdirde, `nil`.\n\n    ### Örnek:\n    characterForAsciiCode(65) // \"A\" döndürür\n    characterForAsciiCode(97) // \"a\" döndürür\n    */",
      "vi": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Trả về ký tự tương ứng với mã ASCII đã cho.\n\n    Hàm này nhận một số nguyên đại diện cho mã ASCII và trả về ký tự tương ứng. Hàm đảm bảo rằng mã đầu vào nằm trong phạm vi các ký tự ASCII có thể in được (lớn hơn 0 và nhỏ hơn 128).\n\n    - Tham số code: Một giá trị `Int` đại diện cho mã ASCII.\n\n    - Trả về: Một `Character?` đại diện cho ký tự tương ứng nếu mã nằm trong phạm vi ASCII có thể in được; nếu không, trả về `nil`.\n\n    ### Ví dụ:\n    characterForAsciiCode(65) // Trả về \"A\"\n    characterForAsciiCode(97) // Trả về \"a\"\n    */"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9963664544397288",
      "sw": "0.9874286831843019",
      "tr": "0.9979479495335286",
      "vi": "0.9969281811572954"
    },
    "canonical_solution": "    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}",
    "instruction": {
      "en": "Write a Swift function `func characterForAsciiCode(_ code: Int) -> Character? {` to solve the following problem:\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n",
      "es": "Escribe una función Swift `func characterForAsciiCode(_ code: Int) -> Character? {` para resolver el siguiente problema:\nDevuelve el carácter correspondiente al código ASCII dado.\n\nEsta función toma un entero que representa un código ASCII y devuelve el carácter correspondiente. La función asegura que el código de entrada esté dentro del rango de caracteres ASCII imprimibles (mayor que 0 y menor que 128).\n\n- Parámetro code: Un valor `Int` que representa el código ASCII.\n\n- Devuelve: Un `Character?` que representa el carácter correspondiente si el código está dentro del rango ASCII imprimible; de lo contrario, `nil`.\n\n### Ejemplo:\ncharacterForAsciiCode(65) // Devuelve \"A\"\ncharacterForAsciiCode(97) // Devuelve \"a\"",
      "arb": "اكتب دالة Swift `func characterForAsciiCode(_ code: Int) -> Character? {` لحل المشكلة التالية:\nإرجاع الحرف المقابل لرمز ASCII المعطى.\n\nتأخذ هذه الدالة عددًا صحيحًا يمثل رمز ASCII وتعيد الحرف المقابل. تضمن الدالة أن يكون رمز الإدخال ضمن نطاق أحرف ASCII القابلة للطباعة (أكبر من 0 وأقل من 128).\n\n- Parameter code: قيمة `Int` تمثل رمز ASCII.\n\n- Returns: `Character?` يمثل الحرف المقابل إذا كان الرمز ضمن نطاق ASCII القابل للطباعة؛ وإلا، `nil`.\n\n### مثال:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"",
      "sw": "Andika kazi ya Swift `func characterForAsciiCode(_ code: Int) -> Character? {` kutatua tatizo lifuatalo:\nInarudisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\nKazi hii inachukua namba nzima inayowakilisha msimbo wa ASCII na inarudisha herufi inayolingana. Kazi hii inahakikisha kwamba msimbo wa ingizo uko ndani ya wigo wa herufi zinazoweza kuchapishwa za ASCII (zaidi ya 0 na chini ya 128).\n\n- Kigezo code: Thamani ya `Int` inayowakilisha msimbo wa ASCII.\n\n- Inarudisha: `Character?` inayowakilisha herufi inayolingana ikiwa msimbo uko ndani ya wigo wa herufi zinazoweza kuchapishwa; vinginevyo, `nil`.\n\n### Mfano:\ncharacterForAsciiCode(65) // Inarudisha \"A\"\ncharacterForAsciiCode(97) // Inarudisha \"a\"",
      "tr": "Bir Swift fonksiyonu `func characterForAsciiCode(_ code: Int) -> Character? {` yazın. Aşağıdaki problemi çözmek için:\nVerilen ASCII koduna karşılık gelen karakteri döndürür.\n\nBu fonksiyon, bir ASCII kodunu temsil eden bir tam sayı alır ve karşılık gelen karakteri döndürür. Fonksiyon, giriş kodunun yazdırılabilir ASCII karakterleri aralığında (0'dan büyük ve 128'den küçük) olduğundan emin olur.\n\n- Parametre kodu: ASCII kodunu temsil eden bir `Int` değeri.\n\n- Dönüş: Kod yazdırılabilir ASCII aralığında ise karşılık gelen karakteri temsil eden bir `Character?`; aksi takdirde `nil`.\n\n### Örnek:\ncharacterForAsciiCode(65) // \"A\" döndürür\ncharacterForAsciiCode(97) // \"a\" döndürür",
      "vi": "Viết một hàm Swift `func characterForAsciiCode(_ code: Int) -> Character? {` để giải quyết vấn đề sau:\nTrả về ký tự tương ứng với mã ASCII đã cho.\n\nHàm này nhận một số nguyên đại diện cho mã ASCII và trả về ký tự tương ứng. Hàm đảm bảo rằng mã đầu vào nằm trong phạm vi các ký tự ASCII có thể in được (lớn hơn 0 và nhỏ hơn 128).\n\n- Tham số code: Một giá trị `Int` đại diện cho mã ASCII.\n\n- Trả về: Một `Character?` đại diện cho ký tự tương ứng nếu mã nằm trong phạm vi ASCII có thể in được; nếu không, trả về `nil`.\n\n### Ví dụ:\ncharacterForAsciiCode(65) // Trả về \"A\"\ncharacterForAsciiCode(97) // Trả về \"a\""
    },
    "instruction_bertscore": {
      "es": "0.9987760395920631",
      "arb": "0.9950251034766002",
      "sw": "0.9888202876338323",
      "tr": "0.9902806181952009",
      "vi": "0.9962043720488043"
    },
    "level": "easy",
    "test": "func testCharacterForAsciiCode() {\n    assert(characterForAsciiCode(65) == \"A\", \"Test Case 1 Failed\")\n    assert(characterForAsciiCode(97) == \"a\", \"Test Case 2 Failed\")\n    assert(characterForAsciiCode(48) == \"0\", \"Test Case 3 Failed\")\n    assert(characterForAsciiCode(35) == \"#\", \"Test Case 4 Failed\")\n    assert(characterForAsciiCode(90) == \"Z\", \"Test Case 5 Failed\")\n    assert(characterForAsciiCode(122) == \"z\", \"Test Case 6 Failed\")\n}\n\ntestCharacterForAsciiCode()",
    "entry_point": "characterForAsciiCode",
    "signature": "func characterForAsciiCode(_ code: Int) -> Character? {",
    "docstring": {
      "en": "\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n",
      "es": "Devuelve el carácter correspondiente al código ASCII dado.\n\nEsta función toma un entero que representa un código ASCII y devuelve el carácter correspondiente. La función asegura que el código de entrada esté dentro del rango de caracteres ASCII imprimibles (mayor que 0 y menor que 128).\n\n- Parámetro code: Un valor `Int` que representa el código ASCII.\n\n- Devuelve: Un `Character?` que representa el carácter correspondiente si el código está dentro del rango ASCII imprimible; de lo contrario, `nil`.\n\n### Ejemplo:\ncharacterForAsciiCode(65) // Devuelve \"A\"\ncharacterForAsciiCode(97) // Devuelve \"a\"",
      "arb": "يعيد الحرف المقابل لرمز ASCII المعطى.\n\nتأخذ هذه الدالة عددًا صحيحًا يمثل رمز ASCII وتعيد الحرف المقابل. تضمن الدالة أن يكون رمز الإدخال ضمن نطاق أحرف ASCII القابلة للطباعة (أكبر من 0 وأقل من 128).\n\n- Parameter code: قيمة `Int` تمثل رمز ASCII.\n\n- Returns: قيمة `Character?` تمثل الحرف المقابل إذا كان الرمز ضمن نطاق ASCII القابل للطباعة؛ وإلا، `nil`.\n\n### مثال:\ncharacterForAsciiCode(65) // يعيد \"A\"\ncharacterForAsciiCode(97) // يعيد \"a\"",
      "sw": "Inarejesha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\nKazi hii inachukua nambari nzima inayowakilisha msimbo wa ASCII na inarejesha herufi inayolingana. Kazi hii inahakikisha kwamba msimbo wa pembejeo uko ndani ya safu ya herufi zinazoweza kuchapishwa za ASCII (zaidi ya 0 na chini ya 128).\n\n- Parameter code: Thamani ya `Int` inayowakilisha msimbo wa ASCII.\n\n- Inarejesha: `Character?` inayowakilisha herufi inayolingana ikiwa msimbo uko ndani ya safu ya herufi zinazoweza kuchapishwa; vinginevyo, `nil`.\n\n### Mfano:\ncharacterForAsciiCode(65) // Inarejesha \"A\"\ncharacterForAsciiCode(97) // Inarejesha \"a\"",
      "tr": "Verilen ASCII koduna karşılık gelen karakteri döndürür.\n\nBu fonksiyon, bir ASCII kodunu temsil eden bir tamsayı alır ve karşılık gelen karakteri döndürür. Fonksiyon, giriş kodunun yazdırılabilir ASCII karakterleri aralığında (0'dan büyük ve 128'den küçük) olmasını sağlar.\n\n- Parametre code: ASCII kodunu temsil eden bir `Int` değeri.\n\n- Döndürür: Eğer kod yazdırılabilir ASCII aralığındaysa karşılık gelen karakteri temsil eden bir `Character?`; aksi takdirde `nil`.\n\n### Örnek:\ncharacterForAsciiCode(65) // \"A\" döndürür\ncharacterForAsciiCode(97) // \"a\" döndürür",
      "vi": "Trả về ký tự tương ứng với mã ASCII được cung cấp.\n\nHàm này nhận một số nguyên đại diện cho mã ASCII và trả về ký tự tương ứng. Hàm đảm bảo rằng mã đầu vào nằm trong phạm vi của các ký tự ASCII có thể in được (lớn hơn 0 và nhỏ hơn 128).\n\n- Tham số code: Một giá trị `Int` đại diện cho mã ASCII.\n\n- Trả về: Một `Character?` đại diện cho ký tự tương ứng nếu mã nằm trong phạm vi ASCII có thể in được; nếu không, trả về `nil`.\n\n### Ví dụ:\ncharacterForAsciiCode(65) // Trả về \"A\"\ncharacterForAsciiCode(97) // Trả về \"a\""
    },
    "docstring_bertscore": {
      "es": "0.9958331318666501",
      "arb": "0.9954291176716251",
      "sw": "0.9915786677352638",
      "tr": "0.9983825528072329",
      "vi": "0.9883902528588918"
    }
  },
  {
    "task_id": "Swift/44",
    "prompt": {
      "en": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n    - Parameters:\n        - value: An integer value to be converted to boolean and back to integer.\n\n    - Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n    */",
      "es": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Convierte un entero a un booleano y luego de nuevo a un entero, y devuelve el valor entero resultante.\n\n    - Parámetros:\n        - value: Un valor entero que se convertirá a booleano y luego de nuevo a entero.\n\n    - Devuelve: Un valor entero después de la conversión. El valor devuelto es 1 si el entero original era distinto de cero; de lo contrario, es 0.\n\n    ### Ejemplo:\n    - `convertIntToBoolToInt(5)` devuelve `1`, porque cualquier entero distinto de cero se convierte en `true`, que luego se convierte de nuevo en `1`.\n    - `convertIntToBoolToInt(0)` devuelve `0`, porque `0` se convierte en `false`, que luego se convierte de nuevo en `0`.\n    - `convertIntToBoolToInt(-10)` devuelve `1`, porque cualquier entero distinto de cero, incluidos los números negativos, se convierte en `true`, que luego se convierte de nuevo en `1`.\n    */",
      "arb": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    يحول عددًا صحيحًا إلى قيمة منطقية ثم يعيده إلى عدد صحيح، ويعيد القيمة العددية الناتجة.\n\n    - Parameters:\n        - value: قيمة عدد صحيح ليتم تحويلها إلى قيمة منطقية ثم إلى عدد صحيح.\n\n    - Returns: قيمة عدد صحيح بعد التحويل. تكون القيمة المعادة 1 إذا كان العدد الأصلي غير صفري؛ وإلا تكون 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n    */",
      "sw": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Inabadilisha nambari nzima kuwa boolean na kisha kurudi kwenye nambari nzima, na inarudisha thamani ya nambari nzima inayopatikana.\n\n    - Vigezo:\n        - value: Thamani ya nambari nzima inayopaswa kubadilishwa kuwa boolean na kurudi kwenye nambari nzima.\n\n    - Inarudisha: Thamani ya nambari nzima baada ya kubadilishwa. Thamani inayorudi ni 1 ikiwa nambari nzima ya awali haikuwa sifuri; vinginevyo, ni 0.\n\n    ### Mfano:\n    - `convertIntToBoolToInt(5)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri inabadilishwa kuwa `true`, ambayo kisha inabadilishwa tena kuwa `1`.\n    - `convertIntToBoolToInt(0)` inarudisha `0`, kwa sababu `0` inabadilishwa kuwa `false`, ambayo kisha inabadilishwa tena kuwa `0`.\n    - `convertIntToBoolToInt(-10)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri, ikiwa ni pamoja na nambari hasi, inabadilishwa kuwa `true`, ambayo kisha inabadilishwa tena kuwa `1`.\n    */",
      "tr": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Bir tam sayıyı boolean'a ve ardından tekrar tam sayıya dönüştürür ve ortaya çıkan tam sayı değerini döndürür.\n\n    - Parametreler:\n        - value: Boolean'a dönüştürülecek ve tekrar tam sayıya dönüştürülecek bir tam sayı değeri.\n\n    - Dönüş: Dönüştürme işleminden sonra bir tam sayı değeri. Orijinal tam sayı sıfır değilse dönüş değeri 1'dir; aksi takdirde 0'dır.\n\n    ### Örnek:\n    - `convertIntToBoolToInt(5)` `1` döndürür, çünkü sıfır olmayan herhangi bir tam sayı `true`'ya dönüşür ve bu da tekrar `1`'e dönüşür.\n    - `convertIntToBoolToInt(0)` `0` döndürür, çünkü `0` `false`'a dönüşür ve bu da tekrar `0`'a dönüşür.\n    - `convertIntToBoolToInt(-10)` `1` döndürür, çünkü sıfır olmayan herhangi bir tam sayı, negatif sayılar dahil, `true`'ya dönüşür ve bu da tekrar `1`'e dönüşür.\n    */",
      "vi": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Chuyển đổi một số nguyên thành một giá trị boolean và sau đó quay lại thành số nguyên, và trả về giá trị số nguyên kết quả.\n\n    - Tham số:\n        - value: Một giá trị số nguyên cần được chuyển đổi thành boolean và sau đó quay lại thành số nguyên.\n\n    - Trả về: Một giá trị số nguyên sau khi chuyển đổi. Giá trị trả về là 1 nếu số nguyên ban đầu khác không; ngược lại, nó là 0.\n\n    ### Ví dụ:\n    - `convertIntToBoolToInt(5)` trả về `1`, bởi vì bất kỳ số nguyên nào khác không chuyển đổi thành `true`, sau đó chuyển đổi lại thành `1`.\n    - `convertIntToBoolToInt(0)` trả về `0`, bởi vì `0` chuyển đổi thành `false`, sau đó chuyển đổi lại thành `0`.\n    - `convertIntToBoolToInt(-10)` trả về `1`, bởi vì bất kỳ số nguyên nào khác không, bao gồm cả số âm, chuyển đổi thành `true`, sau đó chuyển đổi lại thành `1`.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.975985388302501",
      "arb": "0.9821421355930584",
      "sw": "0.972495651138099",
      "tr": "0.9742908725218924",
      "vi": "0.9807475516878125"
    },
    "canonical_solution": "    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}",
    "instruction": {
      "en": "Write a Swift function `func convertIntToBoolToInt(_ value: Int) -> Int {` to solve the following problem:\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n",
      "es": "Escribe una función Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` para resolver el siguiente problema:\nConvierte un entero a un booleano y luego de vuelta a un entero, y devuelve el valor entero resultante.\n\n- Parámetros:\n- value: Un valor entero para ser convertido a booleano y de vuelta a entero.\n\n- Retorna: Un valor entero después de la conversión. El valor de retorno es 1 si el entero original era distinto de cero; de lo contrario, es 0.\n\n### Ejemplo:\n- `convertIntToBoolToInt(5)` devuelve `1`, porque cualquier entero distinto de cero se convierte en `true`, que luego se convierte de nuevo en `1`.\n- `convertIntToBoolToInt(0)` devuelve `0`, porque `0` se convierte en `false`, que luego se convierte de nuevo en `0`.\n- `convertIntToBoolToInt(-10)` devuelve `1`, porque cualquier entero distinto de cero, incluidos los números negativos, se convierte en `true`, que luego se convierte de nuevo en `1`.",
      "arb": "اكتب دالة Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` لحل المشكلة التالية:\nتحويل عدد صحيح إلى قيمة منطقية ثم إعادته إلى عدد صحيح، وإرجاع القيمة الصحيحة الناتجة.\n\n- المعاملات:\n- value: قيمة عدد صحيح ليتم تحويلها إلى قيمة منطقية ثم إلى عدد صحيح.\n\n- الإرجاع: قيمة عدد صحيح بعد التحويل. تكون القيمة المرجعة 1 إذا كان العدد الصحيح الأصلي غير صفري؛ وإلا، تكون 0.\n\n### مثال:\n- `convertIntToBoolToInt(5)` تُرجع `1`، لأن أي عدد صحيح غير صفري يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.\n- `convertIntToBoolToInt(0)` تُرجع `0`، لأن `0` يتحول إلى `false`، والذي يتحول بعد ذلك إلى `0`.\n- `convertIntToBoolToInt(-10)` تُرجع `1`، لأن أي عدد صحيح غير صفري، بما في ذلك الأعداد السالبة، يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.",
      "sw": "Andika kazi ya Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` kutatua tatizo lifuatalo:\nInabadilisha nambari kamili kuwa boolean na kisha kurudi kwenye nambari kamili, na inarudisha thamani ya nambari kamili inayotokana.\n\n- Vigezo:\n- value: Thamani ya nambari kamili inayopaswa kubadilishwa kuwa boolean na kurudi kwenye nambari kamili.\n\n- Inarudisha: Thamani ya nambari kamili baada ya kubadilishwa. Thamani inayorudi ni 1 ikiwa nambari kamili ya awali haikuwa sifuri; vinginevyo, ni 0.\n\n### Mfano:\n- `convertIntToBoolToInt(5)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri inabadilika kuwa `true`, ambayo kisha inabadilika tena kuwa `1`.\n- `convertIntToBoolToInt(0)` inarudisha `0`, kwa sababu `0` inabadilika kuwa `false`, ambayo kisha inabadilika tena kuwa `0`.\n- `convertIntToBoolToInt(-10)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri, ikiwa ni pamoja na nambari hasi, inabadilika kuwa `true`, ambayo kisha inabadilika tena kuwa `1`.",
      "tr": "Bir Swift fonksiyonu `func convertIntToBoolToInt(_ value: Int) -> Int {` yazın, aşağıdaki problemi çözmek için:\nBir tam sayıyı boolean'a ve ardından tekrar tam sayıya dönüştürür ve ortaya çıkan tam sayı değerini döndürür.\n\n- Parametreler:\n- value: Boolean'a ve tekrar tam sayıya dönüştürülecek bir tam sayı değeri.\n\n- Döndürür: Dönüştürme işleminden sonra bir tam sayı değeri. Eğer orijinal tam sayı sıfır değilse döndürülen değer 1'dir; aksi takdirde 0'dır.\n\n### Örnek:\n- `convertIntToBoolToInt(5)` `1` döndürür, çünkü sıfır olmayan herhangi bir tam sayı `true`'ya dönüşür, bu da tekrar `1`'e dönüşür.\n- `convertIntToBoolToInt(0)` `0` döndürür, çünkü `0` `false`'a dönüşür, bu da tekrar `0`'a dönüşür.\n- `convertIntToBoolToInt(-10)` `1` döndürür, çünkü sıfır olmayan herhangi bir tam sayı, negatif sayılar da dahil, `true`'ya dönüşür, bu da tekrar `1`'e dönüşür.",
      "vi": "Viết một hàm Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` để giải quyết vấn đề sau:\nChuyển đổi một số nguyên thành một giá trị boolean và sau đó chuyển đổi lại thành số nguyên, và trả về giá trị số nguyên kết quả.\n\n- Tham số:\n- value: Một giá trị số nguyên cần được chuyển đổi thành boolean và sau đó chuyển đổi lại thành số nguyên.\n\n- Trả về: Một giá trị số nguyên sau khi chuyển đổi. Giá trị trả về là 1 nếu số nguyên ban đầu khác 0; ngược lại, là 0.\n\n### Ví dụ:\n- `convertIntToBoolToInt(5)` trả về `1`, vì bất kỳ số nguyên nào khác 0 chuyển đổi thành `true`, sau đó chuyển đổi lại thành `1`.\n- `convertIntToBoolToInt(0)` trả về `0`, vì `0` chuyển đổi thành `false`, sau đó chuyển đổi lại thành `0`.\n- `convertIntToBoolToInt(-10)` trả về `1`, vì bất kỳ số nguyên nào khác 0, bao gồm cả số âm, chuyển đổi thành `true`, sau đó chuyển đổi lại thành `1`."
    },
    "instruction_bertscore": {
      "es": "0.9952253229006833",
      "arb": "0.979828290284383",
      "sw": "0.9860619075324009",
      "tr": "0.9792016114322178",
      "vi": "0.9649600117423974"
    },
    "level": "easy",
    "test": "func testConvertIntToBoolToInt() {\n    assert(convertIntToBoolToInt(5) == 1, \"Conversion of 5 should return 1.\")\n    assert(convertIntToBoolToInt(0) == 0, \"Conversion of 0 should return 0.\")\n    assert(convertIntToBoolToInt(-10) == 1, \"Conversion of -10 should return 1.\")\n    assert(convertIntToBoolToInt(1) == 1, \"Conversion of 1 should return 1.\")\n    assert(convertIntToBoolToInt(-1) == 1, \"Conversion of -1 should return 1.\")\n    assert(convertIntToBoolToInt(100) == 1, \"Conversion of 100 should return 1.\")\n    assert(convertIntToBoolToInt(-100) == 1, \"Conversion of -100 should return 1.\")\n}\n\n// Call the test function to verify the functionality\ntestConvertIntToBoolToInt()",
    "entry_point": "convertIntToBoolToInt",
    "signature": "func convertIntToBoolToInt(_ value: Int) -> Int {",
    "docstring": {
      "en": "\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n",
      "es": "Convierte un entero a un booleano y luego de nuevo a un entero, y devuelve el valor entero resultante.\n\n- Parámetros:\n- value: Un valor entero que se convertirá a booleano y luego de nuevo a entero.\n\n- Devuelve: Un valor entero después de la conversión. El valor devuelto es 1 si el entero original era distinto de cero; de lo contrario, es 0.\n\n### Ejemplo:\n- `convertIntToBoolToInt(5)` devuelve `1`, porque cualquier entero distinto de cero se convierte en `true`, que luego se convierte de nuevo a `1`.\n- `convertIntToBoolToInt(0)` devuelve `0`, porque `0` se convierte en `false`, que luego se convierte de nuevo a `0`.\n- `convertIntToBoolToInt(-10)` devuelve `1`, porque cualquier entero distinto de cero, incluidos los números negativos, se convierte en `true`, que luego se convierte de nuevo a `1`.",
      "arb": "تحول عددًا صحيحًا إلى قيمة منطقية ثم تعيده إلى عدد صحيح، وتعيد القيمة الصحيحة الناتجة.\n\n- المعلمات:\n- value: قيمة صحيحة ليتم تحويلها إلى قيمة منطقية ثم تعاد إلى عدد صحيح.\n\n- العوائد: قيمة صحيحة بعد التحويل. تكون القيمة المعادة 1 إذا كان العدد الصحيح الأصلي غير صفري؛ وإلا، تكون 0.\n\n### مثال:\n- `convertIntToBoolToInt(5)` تعيد `1`، لأن أي عدد صحيح غير صفري يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.\n- `convertIntToBoolToInt(0)` تعيد `0`، لأن `0` يتحول إلى `false`، والذي يتحول بعد ذلك إلى `0`.\n- `convertIntToBoolToInt(-10)` تعيد `1`، لأن أي عدد صحيح غير صفري، بما في ذلك الأعداد السالبة، يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.",
      "sw": "Inabadilisha nambari nzima kuwa boolean na kisha kurudi kuwa nambari nzima, na inarudisha thamani ya nambari nzima inayopatikana.\n\n- Vigezo:\n- value: Thamani ya nambari nzima inayopaswa kubadilishwa kuwa boolean na kurudi kuwa nambari nzima.\n\n- Inarudisha: Thamani ya nambari nzima baada ya kubadilishwa. Thamani inayorudishwa ni 1 ikiwa nambari nzima ya awali haikuwa sifuri; vinginevyo, ni 0.\n\n### Mfano:\n- `convertIntToBoolToInt(5)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri hubadilishwa kuwa `true`, ambayo kisha hubadilishwa tena kuwa `1`.\n- `convertIntToBoolToInt(0)` inarudisha `0`, kwa sababu `0` hubadilishwa kuwa `false`, ambayo kisha hubadilishwa tena kuwa `0`.\n- `convertIntToBoolToInt(-10)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri, pamoja na nambari hasi, hubadilishwa kuwa `true`, ambayo kisha hubadilishwa tena kuwa `1`.",
      "tr": "Bir tamsayıyı boolean'a ve ardından tekrar bir tamsayıya dönüştürür ve elde edilen tamsayı değerini döndürür.\n\n- Parametreler:\n- value: Boolean'a ve tekrar tamsayıya dönüştürülecek bir tamsayı değeri.\n\n- Döndürür: Dönüştürme sonrası bir tamsayı değeri. Eğer orijinal tamsayı sıfır değilse, döndürülen değer 1'dir; aksi takdirde 0'dır.\n\n### Örnek:\n- `convertIntToBoolToInt(5)` `1` döndürür, çünkü sıfır olmayan herhangi bir tamsayı `true`'ya dönüşür, bu da ardından `1`e dönüşür.\n- `convertIntToBoolToInt(0)` `0` döndürür, çünkü `0` `false`'a dönüşür, bu da ardından `0`a dönüşür.\n- `convertIntToBoolToInt(-10)` `1` döndürür, çünkü negatif sayılar da dahil olmak üzere sıfır olmayan herhangi bir tamsayı `true`'ya dönüşür, bu da ardından `1`e dönüşür.",
      "vi": "Chuyển đổi một số nguyên thành một giá trị boolean và sau đó quay lại thành số nguyên, và trả về giá trị số nguyên kết quả.\n\n- Tham số:\n- value: Một giá trị số nguyên để được chuyển đổi thành boolean và quay lại thành số nguyên.\n\n- Trả về: Một giá trị số nguyên sau khi chuyển đổi. Giá trị trả về là 1 nếu số nguyên ban đầu khác 0; nếu không, nó là 0.\n\n### Ví dụ:\n- `convertIntToBoolToInt(5)` trả về `1`, vì bất kỳ số nguyên nào khác 0 đều chuyển đổi thành `true`, sau đó chuyển đổi lại thành `1`.\n- `convertIntToBoolToInt(0)` trả về `0`, vì `0` chuyển đổi thành `false`, sau đó chuyển đổi lại thành `0`.\n- `convertIntToBoolToInt(-10)` trả về `1`, vì bất kỳ số nguyên nào khác 0, bao gồm cả số âm, đều chuyển đổi thành `true`, sau đó chuyển đổi lại thành `1`."
    },
    "docstring_bertscore": {
      "es": "0.9710349233159684",
      "arb": "0.9775313285580955",
      "sw": "0.9705264295405192",
      "tr": "0.9732860014242368",
      "vi": "0.9837881855606945"
    }
  },
  {
    "task_id": "Swift/45",
    "prompt": {
      "en": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */",
      "es": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Invierte un número de tres dígitos y devuelve el resultado.\n\n    - Parámetros:\n        - number: Un entero de tres dígitos a invertir.\n\n    - Devuelve: El entero invertido. Si el número de entrada no es un entero de tres dígitos, la función devuelve -1 para indicar un error.\n\n    ### Ejemplos:\n    - `reverseThreeDigitNumber(123)` devuelve `321`.\n    - `reverseThreeDigitNumber(456)` devuelve `654`.\n    - `reverseThreeDigitNumber(789)` devuelve `987`.\n    - `reverseThreeDigitNumber(100)` devuelve `1`, ya que los ceros a la izquierda no se representan en enteros.\n    - `reverseThreeDigitNumber(905)` devuelve `509`.\n\n    Nota: La función asume que la entrada es siempre un número de tres dígitos.\n    */",
      "arb": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    يعكس رقمًا مكونًا من ثلاثة أرقام ويعيد النتيجة.\n\n    - Parameters:\n        - number: عدد صحيح مكون من ثلاثة أرقام ليتم عكسه.\n\n    - Returns: العدد الصحيح المعكوس. إذا لم يكن الرقم المدخل عددًا صحيحًا مكونًا من ثلاثة أرقام، تعيد الدالة -1 للإشارة إلى خطأ.\n\n    ### أمثلة:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, حيث أن الأصفار البادئة لا تمثل في الأعداد الصحيحة.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    ملاحظة: تفترض الدالة أن المدخل هو دائمًا رقم مكون من ثلاثة أرقام.\n    */",
      "sw": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Inageuza namba ya tarakimu tatu na kurudisha matokeo.\n\n    - Vigezo:\n        - number: Nambari ya tarakimu tatu inayopaswa kugeuzwa.\n\n    - Inarudisha: Nambari iliyogeuzwa. Ikiwa nambari ya ingizo si nambari ya tarakimu tatu, kazi inarudisha -1 kuashiria hitilafu.\n\n    ### Mifano:\n    - `reverseThreeDigitNumber(123)` inarudisha `321`.\n    - `reverseThreeDigitNumber(456)` inarudisha `654`.\n    - `reverseThreeDigitNumber(789)` inarudisha `987`.\n    - `reverseThreeDigitNumber(100)` inarudisha `1`, kwani sifuri za mwanzo hazionyeshwi kwenye nambari nzima.\n    - `reverseThreeDigitNumber(905)` inarudisha `509`.\n\n    Kumbuka: Kazi inadhani ingizo daima ni nambari ya tarakimu tatu.\n    */",
      "tr": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Üç basamaklı bir sayıyı ters çevirir ve sonucu döndürür.\n\n    - Parametreler:\n        - number: Ters çevrilecek üç basamaklı bir tamsayı.\n\n    - Dönüş: Ters çevrilmiş tamsayı. Eğer giriş sayısı üç basamaklı bir tamsayı değilse, fonksiyon bir hata belirtmek için -1 döndürür.\n\n    ### Örnekler:\n    - `reverseThreeDigitNumber(123)` `321` döndürür.\n    - `reverseThreeDigitNumber(456)` `654` döndürür.\n    - `reverseThreeDigitNumber(789)` `987` döndürür.\n    - `reverseThreeDigitNumber(100)` `1` döndürür, çünkü baştaki sıfırlar tamsayılarda temsil edilmez.\n    - `reverseThreeDigitNumber(905)` `509` döndürür.\n\n    Not: Fonksiyon, girdinin her zaman üç basamaklı bir sayı olduğunu varsayar.\n    */",
      "vi": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Đảo ngược một số có ba chữ số và trả về kết quả.\n\n    - Tham số:\n        - number: Một số nguyên có ba chữ số cần được đảo ngược.\n\n    - Trả về: Số nguyên đã được đảo ngược. Nếu số đầu vào không phải là số nguyên có ba chữ số, hàm sẽ trả về -1 để chỉ ra lỗi.\n\n    ### Ví dụ:\n    - `reverseThreeDigitNumber(123)` trả về `321`.\n    - `reverseThreeDigitNumber(456)` trả về `654`.\n    - `reverseThreeDigitNumber(789)` trả về `987`.\n    - `reverseThreeDigitNumber(100)` trả về `1`, vì các số 0 đứng đầu không được biểu diễn trong số nguyên.\n    - `reverseThreeDigitNumber(905)` trả về `509`.\n\n    Lưu ý: Hàm giả định rằng đầu vào luôn là một số có ba chữ số.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9951289871658814",
      "arb": "1",
      "sw": "0.9820003135009995",
      "tr": "0.9982395389328877",
      "vi": "0.9803105648495357"
    },
    "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}",
    "instruction": {
      "en": "Write a Swift function `func reverseThreeDigitNumber(_ number: Int) -> Int {` to solve the following problem:\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n",
      "es": "Escribe una función en Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` para resolver el siguiente problema:\nInvierte un número de tres dígitos y devuelve el resultado.\n\n- Parámetros:\n- number: Un entero de tres dígitos a invertir.\n\n- Devuelve: El entero invertido. Si el número de entrada no es un entero de tres dígitos, la función devuelve -1 para indicar un error.\n\n### Ejemplos:\n- `reverseThreeDigitNumber(123)` devuelve `321`.\n- `reverseThreeDigitNumber(456)` devuelve `654`.\n- `reverseThreeDigitNumber(789)` devuelve `987`.\n- `reverseThreeDigitNumber(100)` devuelve `1`, ya que los ceros a la izquierda no se representan en enteros.\n- `reverseThreeDigitNumber(905)` devuelve `509`.\n\nNota: La función asume que la entrada es siempre un número de tres dígitos.",
      "arb": "اكتب دالة Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` لحل المشكلة التالية:\nيعكس رقمًا مكونًا من ثلاثة أرقام ويعيد النتيجة.\n\n- المعاملات:\n- number: عدد صحيح مكون من ثلاثة أرقام ليتم عكسه.\n\n- العوائد: العدد الصحيح المعكوس. إذا لم يكن الرقم المدخل عددًا صحيحًا مكونًا من ثلاثة أرقام، فإن الدالة تعيد -1 للإشارة إلى خطأ.\n\n### أمثلة:\n- `reverseThreeDigitNumber(123)` يعيد `321`.\n- `reverseThreeDigitNumber(456)` يعيد `654`.\n- `reverseThreeDigitNumber(789)` يعيد `987`.\n- `reverseThreeDigitNumber(100)` يعيد `1`، حيث لا يتم تمثيل الأصفار البادئة في الأعداد الصحيحة.\n- `reverseThreeDigitNumber(905)` يعيد `509`.\n\nملاحظة: تفترض الدالة أن المدخل هو دائمًا رقم مكون من ثلاثة أرقام.",
      "sw": "Andika kazi ya Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` kutatua tatizo lifuatalo:\nInageuza namba ya tarakimu tatu na kurudisha matokeo.\n\n- Vigezo:\n- number: Namba ya tarakimu tatu inayopaswa kugeuzwa.\n\n- Inarudisha: Namba iliyogeuzwa. Ikiwa namba iliyoingizwa si namba ya tarakimu tatu, kazi inarudisha -1 kuonyesha kosa.\n\n### Mifano:\n- `reverseThreeDigitNumber(123)` inarudisha `321`.\n- `reverseThreeDigitNumber(456)` inarudisha `654`.\n- `reverseThreeDigitNumber(789)` inarudisha `987`.\n- `reverseThreeDigitNumber(100)` inarudisha `1`, kwani tarakimu sifuri za mwanzo hazionyeshwi katika namba.\n- `reverseThreeDigitNumber(905)` inarudisha `509`.\n\nKumbuka: Kazi inadhani kwamba ingizo daima ni namba ya tarakimu tatu.",
      "tr": "Bir Swift fonksiyonu `func reverseThreeDigitNumber(_ number: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\nÜç basamaklı bir sayıyı ters çevirir ve sonucu döndürür.\n\n- Parametreler:\n- number: Ters çevrilecek üç basamaklı bir tamsayı.\n\n- Döndürür: Ters çevrilmiş tamsayı. Eğer giriş sayısı üç basamaklı bir tamsayı değilse, fonksiyon bir hatayı belirtmek için -1 döndürür.\n\n### Örnekler:\n- `reverseThreeDigitNumber(123)` `321` döndürür.\n- `reverseThreeDigitNumber(456)` `654` döndürür.\n- `reverseThreeDigitNumber(789)` `987` döndürür.\n- `reverseThreeDigitNumber(100)` `1` döndürür, çünkü baştaki sıfırlar tamsayılarda temsil edilmez.\n- `reverseThreeDigitNumber(905)` `509` döndürür.\n\nNot: Fonksiyon, girişin her zaman üç basamaklı bir sayı olduğunu varsayar.",
      "vi": "Viết một hàm Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` để giải quyết vấn đề sau:\nĐảo ngược một số có ba chữ số và trả về kết quả.\n\n- Tham số:\n- number: Một số nguyên có ba chữ số cần được đảo ngược.\n\n- Trả về: Số nguyên đã được đảo ngược. Nếu số đầu vào không phải là số nguyên có ba chữ số, hàm trả về -1 để chỉ ra lỗi.\n\n### Ví dụ:\n- `reverseThreeDigitNumber(123)` trả về `321`.\n- `reverseThreeDigitNumber(456)` trả về `654`.\n- `reverseThreeDigitNumber(789)` trả về `987`.\n- `reverseThreeDigitNumber(100)` trả về `1`, vì các số 0 đứng đầu không được biểu diễn trong số nguyên.\n- `reverseThreeDigitNumber(905)` trả về `509`.\n\nLưu ý: Hàm giả định đầu vào luôn là một số có ba chữ số."
    },
    "instruction_bertscore": {
      "es": "0.9868240523044317",
      "arb": "1",
      "sw": "0.9777150616605528",
      "tr": "0.996481461430348",
      "vi": "0.9831380683235673"
    },
    "level": "middle",
    "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()",
    "entry_point": "reverseThreeDigitNumber",
    "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {",
    "docstring": {
      "en": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n",
      "es": "Invierte un número de tres dígitos y devuelve el resultado.\n\n- Parámetros:\n- number: Un entero de tres dígitos que se va a invertir.\n\n- Devuelve: El entero invertido. Si el número de entrada no es un entero de tres dígitos, la función devuelve -1 para indicar un error.\n\n### Ejemplos:\n- `reverseThreeDigitNumber(123)` devuelve `321`.\n- `reverseThreeDigitNumber(456)` devuelve `654`.\n- `reverseThreeDigitNumber(789)` devuelve `987`.\n- `reverseThreeDigitNumber(100)` devuelve `1`, ya que los ceros a la izquierda no se representan en enteros.\n- `reverseThreeDigitNumber(905)` devuelve `509`.\n\nNota: La función asume que la entrada es siempre un número de tres dígitos.",
      "arb": "يعكس رقمًا مكونًا من ثلاثة أرقام ويعيد النتيجة.\n\n- المعلمات:\n- number: عدد صحيح مكون من ثلاثة أرقام ليتم عكسه.\n\n- العوائد: العدد الصحيح المعكوس. إذا لم يكن الرقم المدخل عددًا صحيحًا مكونًا من ثلاثة أرقام، فإن الدالة تعيد -1 للإشارة إلى خطأ.\n\n### أمثلة:\n- `reverseThreeDigitNumber(123)` يعيد `321`.\n- `reverseThreeDigitNumber(456)` يعيد `654`.\n- `reverseThreeDigitNumber(789)` يعيد `987`.\n- `reverseThreeDigitNumber(100)` يعيد `1`، حيث لا يتم تمثيل الأصفار البادئة في الأعداد الصحيحة.\n- `reverseThreeDigitNumber(905)` يعيد `509`.\n\nملاحظة: تفترض الدالة أن المدخل هو دائمًا رقم مكون من ثلاثة أرقام.",
      "sw": "Inageuza nambari ya tarakimu tatu na kurudisha matokeo.\n\n- Vigezo:\n- number: Nambari ya tarakimu tatu inayopaswa kugeuzwa.\n\n- Inarudisha: Nambari iliyo geuzwa. Ikiwa nambari ya ingizo si nambari ya tarakimu tatu, kazi inarudisha -1 kuashiria kosa.\n\n### Mifano:\n- `reverseThreeDigitNumber(123)` inarudisha `321`.\n- `reverseThreeDigitNumber(456)` inarudisha `654`.\n- `reverseThreeDigitNumber(789)` inarudisha `987`.\n- `reverseThreeDigitNumber(100)` inarudisha `1`, kwani sifuri za mwanzo hazionyeshwi katika nambari.\n- `reverseThreeDigitNumber(905)` inarudisha `509`.\n\nKumbuka: Kazi inadhani ingizo daima ni nambari ya tarakimu tatu.",
      "tr": "Üç basamaklı bir sayıyı tersine çevirir ve sonucu döndürür.\n\n- Parametreler:\n- number: Tersine çevrilecek üç basamaklı bir tamsayı.\n\n- Döndürür: Tersine çevrilmiş tamsayı. Eğer giriş sayısı üç basamaklı bir tamsayı değilse, fonksiyon bir hata belirtmek için -1 döndürür.\n\n### Örnekler:\n- `reverseThreeDigitNumber(123)` `321` döndürür.\n- `reverseThreeDigitNumber(456)` `654` döndürür.\n- `reverseThreeDigitNumber(789)` `987` döndürür.\n- `reverseThreeDigitNumber(100)` `1` döndürür, çünkü baştaki sıfırlar tamsayılarda temsil edilmez.\n- `reverseThreeDigitNumber(905)` `509` döndürür.\n\nNot: Fonksiyon, girdinin her zaman üç basamaklı bir sayı olduğunu varsayar.",
      "vi": "Đảo ngược một số có ba chữ số và trả về kết quả.\n\n- Tham số:\n- number: Một số nguyên có ba chữ số cần được đảo ngược.\n\n- Trả về: Số nguyên đã được đảo ngược. Nếu số đầu vào không phải là số nguyên có ba chữ số, hàm trả về -1 để chỉ ra lỗi.\n\n### Ví dụ:\n- `reverseThreeDigitNumber(123)` trả về `321`.\n- `reverseThreeDigitNumber(456)` trả về `654`.\n- `reverseThreeDigitNumber(789)` trả về `987`.\n- `reverseThreeDigitNumber(100)` trả về `1`, vì các số 0 đứng đầu không được biểu diễn trong các số nguyên.\n- `reverseThreeDigitNumber(905)` trả về `509`.\n\nLưu ý: Hàm giả định rằng đầu vào luôn là một số có ba chữ số."
    },
    "docstring_bertscore": {
      "es": "0.98683140162853",
      "arb": "1",
      "sw": "0.9728309392212859",
      "tr": "0.9981741895375273",
      "vi": "0.9859069758351936"
    }
  },
  {
    "task_id": "Swift/46",
    "prompt": {
      "en": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calculates the nth term of an arithmetic sequence given its first two terms.\n\n    - Parameters:\n        - a1: The first term of the arithmetic sequence.\n        - a2: The second term of the arithmetic sequence.\n        - n: The position of the term in the sequence to be found (1-based index).\n\n    - Returns: The nth term of the arithmetic sequence.\n\n    ### Example:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\n    Note: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "es": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calcula el enésimo término de una secuencia aritmética dada sus dos primeros términos.\n\n    - Parámetros:\n        - a1: El primer término de la secuencia aritmética.\n        - a2: El segundo término de la secuencia aritmética.\n        - n: La posición del término en la secuencia que se desea encontrar (índice basado en 1).\n\n    - Devuelve: El enésimo término de la secuencia aritmética.\n\n    ### Ejemplo:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calcula el término 100 de una secuencia aritmética que comienza con 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calcula el término 20 de una secuencia aritmética que comienza con 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calcula el término 10 de una secuencia aritmética que comienza con -3, 1.\n\n    Nota: La función asume que los valores de entrada para `a1`, `a2` y `n` siguen las restricciones -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "arb": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    يحسب الحد النوني لمتتالية حسابية معطاة أول حدين لها.\n\n    - المعاملات:\n        - a1: الحد الأول للمتتالية الحسابية.\n        - a2: الحد الثاني للمتتالية الحسابية.\n        - n: موضع الحد في المتتالية المطلوب إيجاده (مؤشر يبدأ من 1).\n\n    - يعيد: الحد النوني للمتتالية الحسابية.\n\n    ### مثال:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` يحسب الحد المائة لمتتالية حسابية تبدأ بـ 1، 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` يحسب الحد العشرين لمتتالية حسابية تبدأ بـ 5، 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` يحسب الحد العاشر لمتتالية حسابية تبدأ بـ -3، 1.\n\n    ملاحظة: تفترض الدالة أن القيم المدخلة لـ `a1`، `a2`، و `n` تتبع القيود -100 <= a1,a2 <= 100، 0 < n <= 1000.\n    */",
      "sw": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Inahesabu neno la nth la mlolongo wa hesabu ukizingatia maneno yake mawili ya kwanza.\n\n    - Vigezo:\n        - a1: Neno la kwanza la mlolongo wa hesabu.\n        - a2: Neno la pili la mlolongo wa hesabu.\n        - n: Nafasi ya neno katika mlolongo inayopaswa kupatikana (kiwango cha kuanzia 1).\n\n    - Inarudisha: Neno la nth la mlolongo wa hesabu.\n\n    ### Mfano:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` inahesabu neno la 100 la mlolongo wa hesabu unaoanza na 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` inahesabu neno la 20 la mlolongo wa hesabu unaoanza na 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` inahesabu neno la 10 la mlolongo wa hesabu unaoanza na -3, 1.\n\n    Kumbuka: Kazi inadhani thamani za pembejeo kwa `a1`, `a2`, na `n` zinafuata vizuizi -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "tr": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    İlk iki terimi verilen bir aritmetik dizinin n'inci terimini hesaplar.\n\n    - Parametreler:\n        - a1: Aritmetik dizinin ilk terimi.\n        - a2: Aritmetik dizinin ikinci terimi.\n        - n: Dizide bulunacak terimin pozisyonu (1 tabanlı indeks).\n\n    - Döndürür: Aritmetik dizinin n'inci terimi.\n\n    ### Örnek:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` 1, 4 ile başlayan bir aritmetik dizinin 100. terimini hesaplar.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` 5, 9 ile başlayan bir aritmetik dizinin 20. terimini hesaplar.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` -3, 1 ile başlayan bir aritmetik dizinin 10. terimini hesaplar.\n\n    Not: Fonksiyon, `a1`, `a2` ve `n` için giriş değerlerinin -100 <= a1,a2 <= 100, 0 < n <= 1000 kısıtlamalarına uyduğunu varsayar.\n    */",
      "vi": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Tính toán số hạng thứ n của một dãy số cấp số cộng cho trước hai số hạng đầu tiên.\n\n    - Tham số:\n        - a1: Số hạng đầu tiên của dãy số cấp số cộng.\n        - a2: Số hạng thứ hai của dãy số cấp số cộng.\n        - n: Vị trí của số hạng trong dãy cần tìm (chỉ số bắt đầu từ 1).\n\n    - Trả về: Số hạng thứ n của dãy số cấp số cộng.\n\n    ### Ví dụ:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` tính toán số hạng thứ 100 của một dãy số cấp số cộng bắt đầu với 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` tính toán số hạng thứ 20 của một dãy số cấp số cộng bắt đầu với 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` tính toán số hạng thứ 10 của một dãy số cấp số cộng bắt đầu với -3, 1.\n\n    Lưu ý: Hàm giả định các giá trị đầu vào cho `a1`, `a2`, và `n` tuân theo các ràng buộc -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.988579348981637",
      "arb": "0.99832058012835",
      "sw": "0.9861453322924355",
      "tr": "0.986017017066287",
      "vi": "0.9863378051316584"
    },
    "canonical_solution": "    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}",
    "instruction": {
      "en": "Write a Swift function `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` to solve the following problem:\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n",
      "es": "Escribe una función en Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` para resolver el siguiente problema:\nCalcula el enésimo término de una secuencia aritmética dados sus dos primeros términos.\n\n- Parámetros:\n- a1: El primer término de la secuencia aritmética.\n- a2: El segundo término de la secuencia aritmética.\n- n: La posición del término en la secuencia que se desea encontrar (índice basado en 1).\n\n- Retorna: El enésimo término de la secuencia aritmética.\n\n### Ejemplo:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calcula el término 100 de una secuencia aritmética comenzando con 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calcula el término 20 de una secuencia aritmética comenzando con 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calcula el término 10 de una secuencia aritmética comenzando con -3, 1.\n\nNota: La función asume que los valores de entrada para `a1`, `a2` y `n` siguen las restricciones -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "arb": "اكتب دالة Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` لحل المشكلة التالية:\nتحسب الحد النوني من متتالية حسابية معطاة أول حدين منها.\n\n- المعاملات:\n- a1: الحد الأول من المتتالية الحسابية.\n- a2: الحد الثاني من المتتالية الحسابية.\n- n: موضع الحد في المتتالية الذي سيتم إيجاده (مؤشر يبدأ من 1).\n\n- يعيد: الحد النوني من المتتالية الحسابية.\n\n### مثال:\n- `arithmeticSequenceLastTerm(1, 4, 100)` يحسب الحد المائة من متتالية حسابية تبدأ بـ 1، 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` يحسب الحد العشرين من متتالية حسابية تبدأ بـ 5، 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` يحسب الحد العاشر من متتالية حسابية تبدأ بـ -3، 1.\n\nملاحظة: تفترض الدالة أن القيم المدخلة لـ `a1`، `a2`، و `n` تتبع القيود -100 <= a1,a2 <= 100، 0 < n <= 1000.",
      "sw": "Andika kazi ya Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` kutatua tatizo lifuatalo:\nInahesabu neno la nth la mlolongo wa hesabu ukizingatia maneno yake mawili ya kwanza.\n\n- Vigezo:\n- a1: Neno la kwanza la mlolongo wa hesabu.\n- a2: Neno la pili la mlolongo wa hesabu.\n- n: Nafasi ya neno katika mlolongo inayopaswa kupatikana (kiwango cha kuanzia 1).\n\n- Inarudisha: Neno la nth la mlolongo wa hesabu.\n\n### Mfano:\n- `arithmeticSequenceLastTerm(1, 4, 100)` inahesabu neno la 100 la mlolongo wa hesabu unaoanza na 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` inahesabu neno la 20 la mlolongo wa hesabu unaoanza na 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` inahesabu neno la 10 la mlolongo wa hesabu unaoanza na -3, 1.\n\nKumbuka: Kazi inadhani thamani za ingizo kwa `a1`, `a2`, na `n` zinafuata vikwazo -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "tr": "Bir Swift fonksiyonu `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` yazın:\nİlk iki terimi verilen bir aritmetik dizinin n'inci terimini hesaplar.\n\n- Parametreler:\n- a1: Aritmetik dizinin ilk terimi.\n- a2: Aritmetik dizinin ikinci terimi.\n- n: Dizide bulunacak terimin pozisyonu (1 tabanlı indeks).\n\n- Döndürür: Aritmetik dizinin n'inci terimi.\n\n### Örnek:\n- `arithmeticSequenceLastTerm(1, 4, 100)` 1, 4 ile başlayan bir aritmetik dizinin 100. terimini hesaplar.\n- `arithmeticSequenceLastTerm(5, 9, 20)` 5, 9 ile başlayan bir aritmetik dizinin 20. terimini hesaplar.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` -3, 1 ile başlayan bir aritmetik dizinin 10. terimini hesaplar.\n\nNot: Fonksiyon, `a1`, `a2` ve `n` için verilen giriş değerlerinin -100 <= a1,a2 <= 100, 0 < n <= 1000 kısıtlamalarına uyduğunu varsayar.",
      "vi": "Viết một hàm Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` để giải quyết vấn đề sau:\nTính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên của nó.\n\n- Tham số:\n- a1: Số hạng đầu tiên của dãy số học.\n- a2: Số hạng thứ hai của dãy số học.\n- n: Vị trí của số hạng trong dãy cần tìm (chỉ số bắt đầu từ 1).\n\n- Trả về: Số hạng thứ n của dãy số học.\n\n### Ví dụ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` tính toán số hạng thứ 100 của một dãy số học bắt đầu với 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` tính toán số hạng thứ 20 của một dãy số học bắt đầu với 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` tính toán số hạng thứ 10 của một dãy số học bắt đầu với -3, 1.\n\nLưu ý: Hàm giả định các giá trị đầu vào cho `a1`, `a2`, và `n` tuân theo các ràng buộc -100 <= a1,a2 <= 100, 0 < n <= 1000."
    },
    "instruction_bertscore": {
      "es": "0.9941481503443311",
      "arb": "0.9962647556846389",
      "sw": "0.9829386434210082",
      "tr": "0.9580585991533402",
      "vi": "0.9852731462893113"
    },
    "level": "easy",
    "test": "func testArithmeticSequenceLastTerm() {\n    assert(arithmeticSequenceLastTerm(1, 4, 100) == 298, \"The 100th term should be 298.\")\n    assert(arithmeticSequenceLastTerm(5, 9, 20) == 81, \"The 20th term should be 77.\")\n    assert(arithmeticSequenceLastTerm(-3, 1, 10) == 33, \"The 10th term should be 33.\")\n    assert(arithmeticSequenceLastTerm(0, 2, 50) == 98, \"The 50th term should be 98.\")\n    assert(arithmeticSequenceLastTerm(-100, -97, 1000) == 2897, \"The 1000th term should be 2897.\")\n    assert(arithmeticSequenceLastTerm(2, 5, 3) == 8, \"The 3rd term should be 8.\")\n}\n\n// Call the test function to verify the functionality\ntestArithmeticSequenceLastTerm()",
    "entry_point": "arithmeticSequenceLastTerm",
    "signature": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n",
      "es": "Calcula el término n de una secuencia aritmética dada sus dos primeros términos.\n\n- Parámetros:\n- a1: El primer término de la secuencia aritmética.\n- a2: El segundo término de la secuencia aritmética.\n- n: La posición del término en la secuencia que se desea encontrar (índice basado en 1).\n\n- Retorna: El término n de la secuencia aritmética.\n\n### Ejemplo:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calcula el término 100 de una secuencia aritmética comenzando con 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calcula el término 20 de una secuencia aritmética comenzando con 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calcula el término 10 de una secuencia aritmética comenzando con -3, 1.\n\nNota: La función asume que los valores de entrada para `a1`, `a2` y `n` siguen las restricciones -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "arb": "يحسب الحد النوني لمتتالية حسابية معطاة حدها الأول وحدها الثاني.\n\n- المعاملات:\n- a1: الحد الأول للمتتالية الحسابية.\n- a2: الحد الثاني للمتتالية الحسابية.\n- n: موضع الحد في المتتالية المطلوب إيجاده (فهرس يبدأ من 1).\n\n- يعيد: الحد النوني للمتتالية الحسابية.\n\n### مثال:\n- `arithmeticSequenceLastTerm(1, 4, 100)` يحسب الحد المائة لمتتالية حسابية تبدأ بـ 1، 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` يحسب الحد العشرين لمتتالية حسابية تبدأ بـ 5، 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` يحسب الحد العاشر لمتتالية حسابية تبدأ بـ -3، 1.\n\nملاحظة: تفترض الدالة أن القيم المدخلة لـ `a1`، `a2`، و `n` تتبع القيود -100 <= a1,a2 <= 100، 0 < n <= 1000.",
      "sw": "Huhesabu neno la nth la mlolongo wa hesabu ukizingatia maneno yake mawili ya kwanza.\n\n- Vigezo:\n- a1: Neno la kwanza la mlolongo wa hesabu.\n- a2: Neno la pili la mlolongo wa hesabu.\n- n: Nafasi ya neno katika mlolongo inayopaswa kupatikana (kiashiria cha kuanzia 1).\n\n- Inarudisha: Neno la nth la mlolongo wa hesabu.\n\n### Mfano:\n- `arithmeticSequenceLastTerm(1, 4, 100)` huhesabu neno la 100 la mlolongo wa hesabu unaoanza na 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` huhesabu neno la 20 la mlolongo wa hesabu unaoanza na 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` huhesabu neno la 10 la mlolongo wa hesabu unaoanza na -3, 1.\n\nKumbuka: Kazi inadhani thamani za pembejeo kwa `a1`, `a2`, na `n` zinafuata vikwazo -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "tr": "Bir aritmetik dizinin ilk iki terimi verildiğinde n'inci terimini hesaplar.\n\n- Parametreler:\n- a1: Aritmetik dizinin ilk terimi.\n- a2: Aritmetik dizinin ikinci terimi.\n- n: Dizide bulunacak terimin pozisyonu (1 tabanlı indeks).\n\n- Döndürür: Aritmetik dizinin n'inci terimi.\n\n### Örnek:\n- `arithmeticSequenceLastTerm(1, 4, 100)` 1, 4 ile başlayan bir aritmetik dizinin 100. terimini hesaplar.\n- `arithmeticSequenceLastTerm(5, 9, 20)` 5, 9 ile başlayan bir aritmetik dizinin 20. terimini hesaplar.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` -3, 1 ile başlayan bir aritmetik dizinin 10. terimini hesaplar.\n\nNot: Fonksiyon, `a1`, `a2` ve `n` için giriş değerlerinin -100 <= a1,a2 <= 100, 0 < n <= 1000 kısıtlamalarına uyduğunu varsayar.",
      "vi": "Tính toán số hạng thứ n của một dãy số học dựa trên hai số hạng đầu tiên của nó.\n\n- Tham số:\n- a1: Số hạng đầu tiên của dãy số học.\n- a2: Số hạng thứ hai của dãy số học.\n- n: Vị trí của số hạng trong dãy cần tìm (chỉ số bắt đầu từ 1).\n\n- Trả về: Số hạng thứ n của dãy số học.\n\n### Ví dụ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` tính toán số hạng thứ 100 của một dãy số học bắt đầu với 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` tính toán số hạng thứ 20 của một dãy số học bắt đầu với 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` tính toán số hạng thứ 10 của một dãy số học bắt đầu với -3, 1.\n\nLưu ý: Hàm giả định rằng các giá trị đầu vào cho `a1`, `a2`, và `n` tuân theo các ràng buộc -100 <= a1,a2 <= 100, 0 < n <= 1000."
    },
    "docstring_bertscore": {
      "es": "0.9856799413096707",
      "arb": "0.985636043995462",
      "sw": "0.9928761213841837",
      "tr": "0.9832421506432296",
      "vi": "0.9826242115278301"
    }
  },
  {
    "task_id": "Swift/47",
    "prompt": {
      "en": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calculates the product of two positive integers.\n\n    - Parameters:\n        - a: The first positive integer.\n        - b: The second positive integer.\n        - Both `a` and `b` should be in the range of 1 to 50,000.\n\n    - Returns: The product of `a` and `b` as an integer.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    Note: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n    */",
      "es": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calcula el producto de dos enteros positivos.\n\n    - Parámetros:\n        - a: El primer entero positivo.\n        - b: El segundo entero positivo.\n        - Tanto `a` como `b` deben estar en el rango de 1 a 50,000.\n\n    - Retorna: El producto de `a` y `b` como un entero.\n\n    ### Ejemplo:\n    - `multiply(3, 4)` retorna `12`.\n    - `multiply(10, 5)` retorna `50`.\n    - `multiply(36, 18)` retorna `648`.\n\n    Nota: La función maneja la multiplicación dentro del rango especificado, asegurando que no haya desbordamiento para valores de hasta 50,000.\n    */",
      "arb": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    يحسب حاصل ضرب عددين صحيحين موجبين.\n\n    - Parameters:\n        - a: العدد الصحيح الموجب الأول.\n        - b: العدد الصحيح الموجب الثاني.\n        - يجب أن يكون كلا من `a` و `b` في النطاق من 1 إلى 50,000.\n\n    - Returns: حاصل ضرب `a` و `b` كعدد صحيح.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    ملاحظة: تتعامل الدالة مع الضرب ضمن النطاق المحدد، مما يضمن عدم حدوث تجاوز للقيم حتى 50,000.\n    */",
      "sw": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Inahesabu bidhaa ya nambari mbili nzima chanya.\n\n    - Vigezo:\n        - a: Nambari ya kwanza nzima chanya.\n        - b: Nambari ya pili nzima chanya.\n        - Zote `a` na `b` zinapaswa kuwa katika safu ya 1 hadi 50,000.\n\n    - Inarudisha: Bidhaa ya `a` na `b` kama nambari nzima.\n\n    ### Mfano:\n    - `multiply(3, 4)` inarudisha `12`.\n    - `multiply(10, 5)` inarudisha `50`.\n    - `multiply(36, 18)` inarudisha `648`.\n\n    Kumbuka: Kazi inashughulikia kuzidisha ndani ya safu iliyobainishwa, kuhakikisha hakuna kufurika kwa thamani hadi 50,000.\n    */",
      "tr": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    İki pozitif tam sayının çarpımını hesaplar.\n\n    - Parametreler:\n        - a: İlk pozitif tam sayı.\n        - b: İkinci pozitif tam sayı.\n        - Hem `a` hem de `b` 1 ile 50,000 arasında olmalıdır.\n\n    - Döndürür: `a` ve `b`'nin çarpımını bir tam sayı olarak döndürür.\n\n    ### Örnek:\n    - `multiply(3, 4)` `12` döndürür.\n    - `multiply(10, 5)` `50` döndürür.\n    - `multiply(36, 18)` `648` döndürür.\n\n    Not: Fonksiyon, belirtilen aralıkta çarpmayı ele alır ve 50,000'e kadar olan değerler için taşma olmadığını garanti eder.\n    */",
      "vi": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Tính tích của hai số nguyên dương.\n\n    - Tham số:\n        - a: Số nguyên dương thứ nhất.\n        - b: Số nguyên dương thứ hai.\n        - Cả `a` và `b` nên nằm trong khoảng từ 1 đến 50,000.\n\n    - Trả về: Tích của `a` và `b` dưới dạng số nguyên.\n\n    ### Ví dụ:\n    - `multiply(3, 4)` trả về `12`.\n    - `multiply(10, 5)` trả về `50`.\n    - `multiply(36, 18)` trả về `648`.\n\n    Lưu ý: Hàm xử lý phép nhân trong phạm vi đã chỉ định, đảm bảo không tràn số cho các giá trị lên đến 50,000.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9973077638154532",
      "arb": "0.9942544175981848",
      "sw": "0.9949573705166673",
      "tr": "0.9851017282704783",
      "vi": "0.9951202474291159"
    },
    "canonical_solution": "    return a * b\n}",
    "instruction": {
      "en": "Write a Swift function `func multiply(_ a: Int, _ b: Int) -> Int {` to solve the following problem:\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n",
      "es": "Escribe una función de Swift `func multiply(_ a: Int, _ b: Int) -> Int {` para resolver el siguiente problema:\nCalcula el producto de dos enteros positivos.\n\n- Parámetros:\n- a: El primer entero positivo.\n- b: El segundo entero positivo.\n- Tanto `a` como `b` deben estar en el rango de 1 a 50,000.\n\n- Retorna: El producto de `a` y `b` como un entero.\n\n### Ejemplo:\n- `multiply(3, 4)` devuelve `12`.\n- `multiply(10, 5)` devuelve `50`.\n- `multiply(36, 18)` devuelve `648`.\n\nNota: La función maneja la multiplicación dentro del rango especificado, asegurando que no haya desbordamiento para valores de hasta 50,000.",
      "arb": "اكتب دالة Swift `func multiply(_ a: Int, _ b: Int) -> Int {` لحل المشكلة التالية:\nتحسب حاصل ضرب عددين صحيحين موجبين.\n\n- المعاملات:\n- a: العدد الصحيح الموجب الأول.\n- b: العدد الصحيح الموجب الثاني.\n- يجب أن يكون كل من `a` و `b` في النطاق من 1 إلى 50,000.\n\n- يعيد: حاصل ضرب `a` و `b` كعدد صحيح.\n\n### مثال:\n- `multiply(3, 4)` يعيد `12`.\n- `multiply(10, 5)` يعيد `50`.\n- `multiply(36, 18)` يعيد `648`.\n\nملاحظة: تتعامل الدالة مع الضرب ضمن النطاق المحدد، مما يضمن عدم حدوث تجاوز للقيم حتى 50,000.",
      "sw": "Andika kazi ya Swift `func multiply(_ a: Int, _ b: Int) -> Int {` kutatua tatizo lifuatalo:\nInahesabu bidhaa ya nambari mbili nzima chanya.\n\n- Vigezo:\n- a: Nambari ya kwanza nzima chanya.\n- b: Nambari ya pili nzima chanya.\n- Zote `a` na `b` zinapaswa kuwa katika safu ya 1 hadi 50,000.\n\n- Inarudisha: Bidhaa ya `a` na `b` kama nambari nzima.\n\n### Mfano:\n- `multiply(3, 4)` inarudisha `12`.\n- `multiply(10, 5)` inarudisha `50`.\n- `multiply(36, 18)` inarudisha `648`.\n\nKumbuka: Kazi inashughulikia kuzidisha ndani ya safu iliyobainishwa, kuhakikisha hakuna upitilivu kwa thamani hadi 50,000.",
      "tr": "Bir Swift fonksiyonu `func multiply(_ a: Int, _ b: Int) -> Int {` yazarak aşağıdaki problemi çözün:\nİki pozitif tam sayının çarpımını hesaplar.\n\n- Parametreler:\n- a: İlk pozitif tam sayı.\n- b: İkinci pozitif tam sayı.\n- Hem `a` hem de `b` 1 ile 50,000 arasında olmalıdır.\n\n- Döndürür: `a` ve `b`'nin çarpımını bir tam sayı olarak döndürür.\n\n### Örnek:\n- `multiply(3, 4)` `12` döndürür.\n- `multiply(10, 5)` `50` döndürür.\n- `multiply(36, 18)` `648` döndürür.\n\nNot: Fonksiyon, belirtilen aralık içinde çarpmayı ele alır ve 50,000'e kadar olan değerler için taşma olmadığını garanti eder.",
      "vi": "Viết một hàm Swift `func multiply(_ a: Int, _ b: Int) -> Int {` để giải quyết vấn đề sau:\nTính tích của hai số nguyên dương.\n\n- Tham số:\n- a: Số nguyên dương thứ nhất.\n- b: Số nguyên dương thứ hai.\n- Cả `a` và `b` nên nằm trong khoảng từ 1 đến 50,000.\n\n- Trả về: Tích của `a` và `b` dưới dạng một số nguyên.\n\n### Ví dụ:\n- `multiply(3, 4)` trả về `12`.\n- `multiply(10, 5)` trả về `50`.\n- `multiply(36, 18)` trả về `648`.\n\nLưu ý: Hàm xử lý phép nhân trong phạm vi đã chỉ định, đảm bảo không tràn số cho các giá trị lên đến 50,000."
    },
    "instruction_bertscore": {
      "es": "0.9926963608893472",
      "arb": "0.9887328902661771",
      "sw": "0.9955631931788237",
      "tr": "0.9857065577807295",
      "vi": "0.9964770915619652"
    },
    "level": "easy",
    "test": "func testMultiply() {\n    assert(multiply(3, 4) == 12, \"Product of 3 and 4 should be 12.\")\n    assert(multiply(10, 5) == 50, \"Product of 10 and 5 should be 50.\")\n    assert(multiply(36, 18) == 648, \"Product of 36 and 18 should be 648.\")\n    assert(multiply(1, 50000) == 50000, \"Product of 1 and 50000 should be 50000.\")\n    assert(multiply(123, 456) == 56088, \"Product of 123 and 456 should be 56088.\")\n    assert(multiply(500, 100) == 50000, \"Product of 500 and 100 should be 50000.\")\n}\n\n// Call the test function to verify the functionality\ntestMultiply()",
    "entry_point": "multiply",
    "signature": "func multiply(_ a: Int, _ b: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n",
      "es": "Calcula el producto de dos enteros positivos.\n\n- Parámetros:\n- a: El primer entero positivo.\n- b: El segundo entero positivo.\n- Tanto `a` como `b` deben estar en el rango de 1 a 50,000.\n\n- Devuelve: El producto de `a` y `b` como un entero.\n\n### Ejemplo:\n- `multiply(3, 4)` devuelve `12`.\n- `multiply(10, 5)` devuelve `50`.\n- `multiply(36, 18)` devuelve `648`.\n\nNota: La función maneja la multiplicación dentro del rango especificado, asegurando que no haya desbordamiento para valores de hasta 50,000.",
      "arb": "يحسب حاصل ضرب عددين صحيحين موجبين.\n\n- المعاملات:\n- a: العدد الصحيح الموجب الأول.\n- b: العدد الصحيح الموجب الثاني.\n- يجب أن يكون كلا من `a` و `b` في النطاق من 1 إلى 50,000.\n\n- يعيد: حاصل ضرب `a` و `b` كعدد صحيح.\n\n### مثال:\n- `multiply(3, 4)` يعيد `12`.\n- `multiply(10, 5)` يعيد `50`.\n- `multiply(36, 18)` يعيد `648`.\n\nملاحظة: تتعامل الدالة مع الضرب ضمن النطاق المحدد، مما يضمن عدم حدوث تجاوز للقيم حتى 50,000.",
      "sw": "Inahesabu bidhaa ya nambari mbili nzima chanya.\n\n- Vigezo:\n- a: Nambari ya kwanza nzima chanya.\n- b: Nambari ya pili nzima chanya.\n- Zote `a` na `b` zinapaswa kuwa katika safu ya 1 hadi 50,000.\n\n- Inarudisha: Bidhaa ya `a` na `b` kama nambari nzima.\n\n### Mfano:\n- `multiply(3, 4)` inarudisha `12`.\n- `multiply(10, 5)` inarudisha `50`.\n- `multiply(36, 18)` inarudisha `648`.\n\nKumbuka: Kazi inashughulikia kuzidisha ndani ya safu iliyotajwa, kuhakikisha hakuna kufurika kwa thamani hadi 50,000.",
      "tr": "İki pozitif tam sayının çarpımını hesaplar.\n\n- Parametreler:\n- a: İlk pozitif tam sayı.\n- b: İkinci pozitif tam sayı.\n- Hem `a` hem de `b` 1 ile 50.000 arasında olmalıdır.\n\n- Döndürür: `a` ve `b`'nin çarpımını bir tam sayı olarak döndürür.\n\n### Örnek:\n- `multiply(3, 4)` `12` döndürür.\n- `multiply(10, 5)` `50` döndürür.\n- `multiply(36, 18)` `648` döndürür.\n\nNot: Fonksiyon, belirtilen aralık içinde çarpma işlemini ele alır ve 50.000'e kadar olan değerler için taşma olmadığını garanti eder.",
      "vi": "Tính tích của hai số nguyên dương.\n\n- Tham số:\n- a: Số nguyên dương thứ nhất.\n- b: Số nguyên dương thứ hai.\n- Cả `a` và `b` nên nằm trong khoảng từ 1 đến 50,000.\n\n- Trả về: Tích của `a` và `b` dưới dạng số nguyên.\n\n### Ví dụ:\n- `multiply(3, 4)` trả về `12`.\n- `multiply(10, 5)` trả về `50`.\n- `multiply(36, 18)` trả về `648`.\n\nLưu ý: Hàm xử lý phép nhân trong phạm vi được chỉ định, đảm bảo không tràn số cho các giá trị lên đến 50,000."
    },
    "docstring_bertscore": {
      "es": "0.9935596085253248",
      "arb": "0.9866295931613985",
      "sw": "1",
      "tr": "0.9817293816612679",
      "vi": "0.9943827328243333"
    }
  },
  {
    "task_id": "Swift/48",
    "prompt": {
      "en": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calculates the power of 2 for a given non-negative integer.\n\n    - Parameters:\n        - n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n    - Returns: The result of 2 raised to the power of `n`.\n\n    ### Example:\n    - `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n    - `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n    - `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\n    Note: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n    */",
      "es": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calcula la potencia de 2 para un entero no negativo dado.\n\n    - Parámetros:\n        - n: Un entero no negativo para el cual se calcula la potencia de 2. El valor de `n` debe estar en el rango de 0 a 30, inclusive.\n\n    - Retorna: El resultado de 2 elevado a la potencia de `n`.\n\n    ### Ejemplo:\n    - `powerOfTwo(3)` retorna `8`, ya que 2^3 = 8.\n    - `powerOfTwo(5)` retorna `32`, ya que 2^5 = 32.\n    - `powerOfTwo(10)` retorna `1024`, ya que 2^10 = 1024.\n\n    Nota: La función está diseñada para manejar entradas dentro del rango especificado sin resultar en un desbordamiento de enteros.\n    */",
      "arb": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    يحسب قوة العدد 2 لعدد صحيح غير سالب معين.\n\n    - المعاملات:\n        - n: عدد صحيح غير سالب يتم حساب قوة العدد 2 له. يجب أن تكون قيمة `n` في النطاق من 0 إلى 30، شاملًا.\n\n    - يعيد: نتيجة رفع العدد 2 إلى قوة `n`.\n\n    ### مثال:\n    - `powerOfTwo(3)` يعيد `8`، حيث 2^3 = 8.\n    - `powerOfTwo(5)` يعيد `32`، حيث 2^5 = 32.\n    - `powerOfTwo(10)` يعيد `1024`، حيث 2^10 = 1024.\n\n    ملاحظة: تم تصميم الدالة للتعامل مع المدخلات ضمن النطاق المحدد دون التسبب في تجاوز سعة العدد الصحيح.\n    */",
      "sw": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Inahesabu nguvu ya 2 kwa nambari isiyo hasi iliyotolewa.\n\n    - Vigezo:\n        - n: Nambari isiyo hasi ambayo nguvu ya 2 inahesabiwa. Thamani ya `n` lazima iwe katika safu ya 0 hadi 30, ikijumuisha.\n\n    - Inarudisha: Matokeo ya 2 iliyoinuliwa kwa nguvu ya `n`.\n\n    ### Mfano:\n    - `powerOfTwo(3)` inarudisha `8`, kama 2^3 = 8.\n    - `powerOfTwo(5)` inarudisha `32`, kama 2^5 = 32.\n    - `powerOfTwo(10)` inarudisha `1024`, kama 2^10 = 1024.\n\n    Kumbuka: Kazi imeundwa kushughulikia ingizo ndani ya safu iliyobainishwa bila kusababisha kufurika kwa nambari nzima.\n    */",
      "tr": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Belirtilen bir pozitif olmayan tamsayı için 2'nin kuvvetini hesaplar.\n\n    - Parametreler:\n        - n: 2'nin kuvvetinin hesaplandığı pozitif olmayan bir tamsayı. `n` değeri 0 ile 30 arasında, dahil olmak üzere olmalıdır.\n\n    - Döndürülen: 2'nin `n` kuvveti olarak yükseltilmesinin sonucu.\n\n    ### Örnek:\n    - `powerOfTwo(3)` `8` döndürür, çünkü 2^3 = 8.\n    - `powerOfTwo(5)` `32` döndürür, çünkü 2^5 = 32.\n    - `powerOfTwo(10)` `1024` döndürür, çünkü 2^10 = 1024.\n\n    Not: Fonksiyon, belirtilen aralık içindeki girdileri tamsayı taşması olmadan işlemek üzere tasarlanmıştır.\n    */",
      "vi": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Tính lũy thừa của 2 cho một số nguyên không âm đã cho.\n\n    - Tham số:\n        - n: Một số nguyên không âm mà lũy thừa của 2 được tính. Giá trị của `n` phải nằm trong khoảng từ 0 đến 30, bao gồm cả hai.\n\n    - Trả về: Kết quả của 2 mũ `n`.\n\n    ### Ví dụ:\n    - `powerOfTwo(3)` trả về `8`, vì 2^3 = 8.\n    - `powerOfTwo(5)` trả về `32`, vì 2^5 = 32.\n    - `powerOfTwo(10)` trả về `1024`, vì 2^10 = 1024.\n\n    Lưu ý: Hàm được thiết kế để xử lý các đầu vào trong phạm vi đã chỉ định mà không dẫn đến tràn số nguyên.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9890874454963243",
      "arb": "0.9828520405748771",
      "sw": "0.9860219828258129",
      "tr": "0.9669870347808585",
      "vi": "0.9842053093608678"
    },
    "canonical_solution": "    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}",
    "instruction": {
      "en": "Write a Swift function `func powerOfTwo(_ n: Int) -> Int {` to solve the following problem:\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n",
      "es": "Escribe una función Swift `func powerOfTwo(_ n: Int) -> Int {` para resolver el siguiente problema:\nCalcula la potencia de 2 para un entero no negativo dado.\n\n- Parámetros:\n- n: Un entero no negativo para el cual se calcula la potencia de 2. El valor de `n` debe estar en el rango de 0 a 30, inclusive.\n\n- Retorna: El resultado de 2 elevado a la potencia de `n`.\n\n### Ejemplo:\n- `powerOfTwo(3)` retorna `8`, ya que 2^3 = 8.\n- `powerOfTwo(5)` retorna `32`, ya que 2^5 = 32.\n- `powerOfTwo(10)` retorna `1024`, ya que 2^10 = 1024.\n\nNota: La función está diseñada para manejar entradas dentro del rango especificado sin resultar en un desbordamiento de enteros.",
      "arb": "اكتب دالة Swift `func powerOfTwo(_ n: Int) -> Int {` لحل المشكلة التالية:\nتحسب قوة 2 لعدد صحيح غير سالب معين.\n\n- المعاملات:\n- n: عدد صحيح غير سالب يتم حساب قوة 2 له. يجب أن تكون قيمة `n` في النطاق من 0 إلى 30، شاملًا.\n\n- يعيد: نتيجة 2 مرفوعة إلى قوة `n`.\n\n### مثال:\n- `powerOfTwo(3)` يعيد `8`، حيث 2^3 = 8.\n- `powerOfTwo(5)` يعيد `32`، حيث 2^5 = 32.\n- `powerOfTwo(10)` يعيد `1024`، حيث 2^10 = 1024.\n\nملاحظة: تم تصميم الدالة للتعامل مع المدخلات ضمن النطاق المحدد دون أن يؤدي ذلك إلى تجاوز في الأعداد الصحيحة.",
      "sw": "Andika kazi ya Swift `func powerOfTwo(_ n: Int) -> Int {` kutatua tatizo lifuatalo:\nHesabu nguvu ya 2 kwa nambari yoyote isiyo hasi.\n\n- Vigezo:\n- n: Nambari isiyo hasi ambayo nguvu ya 2 inahesabiwa. Thamani ya `n` lazima iwe katika safu ya 0 hadi 30, ikijumuisha.\n\n- Inarejesha: Matokeo ya 2 yaliyoinuliwa kwa nguvu ya `n`.\n\n### Mfano:\n- `powerOfTwo(3)` inarejesha `8`, kama 2^3 = 8.\n- `powerOfTwo(5)` inarejesha `32`, kama 2^5 = 32.\n- `powerOfTwo(10)` inarejesha `1024`, kama 2^10 = 1024.\n\nKumbuka: Kazi imeundwa kushughulikia ingizo ndani ya safu iliyobainishwa bila kusababisha kufurika kwa nambari nzima.",
      "tr": "Bir Swift fonksiyonu `func powerOfTwo(_ n: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tamsayı için 2'nin kuvvetini hesaplar.\n\n- Parametreler:\n- n: 2'nin kuvvetinin hesaplandığı negatif olmayan bir tamsayı. `n` değeri 0 ile 30 arasında, dahil olmak üzere, olmalıdır.\n\n- Döndürülen: 2'nin `n` kuvveti olarak elde edilen sonuç.\n\n### Örnek:\n- `powerOfTwo(3)` `8` döndürür, çünkü 2^3 = 8.\n- `powerOfTwo(5)` `32` döndürür, çünkü 2^5 = 32.\n- `powerOfTwo(10)` `1024` döndürür, çünkü 2^10 = 1024.\n\nNot: Fonksiyon, belirtilen aralıktaki girdileri tamsayı taşması olmadan işlemek üzere tasarlanmıştır.",
      "vi": "Viết một hàm Swift `func powerOfTwo(_ n: Int) -> Int {` để giải quyết vấn đề sau:\nTính lũy thừa của 2 cho một số nguyên không âm đã cho.\n\n- Tham số:\n- n: Một số nguyên không âm mà lũy thừa của 2 được tính. Giá trị của `n` phải nằm trong khoảng từ 0 đến 30, bao gồm cả hai đầu.\n\n- Trả về: Kết quả của 2 mũ `n`.\n\n### Ví dụ:\n- `powerOfTwo(3)` trả về `8`, vì 2^3 = 8.\n- `powerOfTwo(5)` trả về `32`, vì 2^5 = 32.\n- `powerOfTwo(10)` trả về `1024`, vì 2^10 = 1024.\n\nLưu ý: Hàm được thiết kế để xử lý các đầu vào trong phạm vi đã chỉ định mà không dẫn đến tràn số nguyên."
    },
    "instruction_bertscore": {
      "es": "0.9896034872262529",
      "arb": "0.9890330207719207",
      "sw": "0.9853150572997097",
      "tr": "0.9730007681970707",
      "vi": "0.985812030513059"
    },
    "level": "easy",
    "test": "func testPowerOfTwo() {\n    assert(powerOfTwo(3) == 8, \"2^3 should be 8.\")\n    assert(powerOfTwo(5) == 32, \"2^5 should be 32.\")\n    assert(powerOfTwo(10) == 1024, \"2^10 should be 1024.\")\n    assert(powerOfTwo(0) == 1, \"2^0 should be 1.\")\n    assert(powerOfTwo(15) == 32768, \"2^15 should be 32768.\")\n    assert(powerOfTwo(30) == 1073741824, \"2^30 should be 1073741824.\")\n}\n\n// Call the test function to verify the functionality\ntestPowerOfTwo()",
    "entry_point": "powerOfTwo",
    "signature": "func powerOfTwo(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n",
      "es": "Calcula la potencia de 2 para un entero no negativo dado.\n\n- Parámetros:\n- n: Un entero no negativo para el cual se calcula la potencia de 2. El valor de `n` debe estar en el rango de 0 a 30, inclusive.\n\n- Devuelve: El resultado de 2 elevado a la potencia de `n`.\n\n### Ejemplo:\n- `powerOfTwo(3)` devuelve `8`, ya que 2^3 = 8.\n- `powerOfTwo(5)` devuelve `32`, ya que 2^5 = 32.\n- `powerOfTwo(10)` devuelve `1024`, ya que 2^10 = 1024.\n\nNota: La función está diseñada para manejar entradas dentro del rango especificado sin resultar en desbordamiento de enteros.",
      "arb": "يحسب قوة 2 لعدد صحيح غير سالب معين.\n\n- المعلمات:\n- n: عدد صحيح غير سالب يتم حساب قوة 2 له. يجب أن تكون قيمة `n` في النطاق من 0 إلى 30، شامل.\n\n- يعيد: نتيجة 2 مرفوعة إلى قوة `n`.\n\n### مثال:\n- `powerOfTwo(3)` يعيد `8`، حيث 2^3 = 8.\n- `powerOfTwo(5)` يعيد `32`، حيث 2^5 = 32.\n- `powerOfTwo(10)` يعيد `1024`، حيث 2^10 = 1024.\n\nملاحظة: تم تصميم الدالة للتعامل مع المدخلات ضمن النطاق المحدد دون أن يؤدي ذلك إلى تجاوز سعة العدد الصحيح.",
      "sw": "Hukokotoa nguvu ya 2 kwa nambari kamili isiyo na alama hasi.\n\n- Vigezo:\n- n: Nambari kamili isiyo na alama hasi ambayo nguvu ya 2 inakokotolewa. Thamani ya `n` lazima iwe katika safu ya 0 hadi 30, ikijumuisha.\n\n- Inarejesha: Matokeo ya 2 iliyopandishwa kwa nguvu ya `n`.\n\n### Mfano:\n- `powerOfTwo(3)` inarejesha `8`, kwani 2^3 = 8.\n- `powerOfTwo(5)` inarejesha `32`, kwani 2^5 = 32.\n- `powerOfTwo(10)` inarejesha `1024`, kwani 2^10 = 1024.\n\nKumbuka: Kazi hii imeundwa kushughulikia ingizo ndani ya safu iliyobainishwa bila kusababisha kufurika kwa nambari kamili.",
      "tr": "Verilen negatif olmayan bir tamsayı için 2'nin kuvvetini hesaplar.\n\n- Parametreler:\n- n: 2'nin kuvvetinin hesaplandığı negatif olmayan bir tamsayı. `n` değeri 0 ile 30 arasında olmalıdır, dahil.\n\n- Döndürür: `n` kuvveti olarak 2'nin sonucu.\n\n### Örnek:\n- `powerOfTwo(3)` `8` döndürür, çünkü 2^3 = 8.\n- `powerOfTwo(5)` `32` döndürür, çünkü 2^5 = 32.\n- `powerOfTwo(10)` `1024` döndürür, çünkü 2^10 = 1024.\n\nNot: Fonksiyon, belirtilen aralıktaki girdileri tam sayı taşması olmadan işlemek üzere tasarlanmıştır.",
      "vi": "Tính lũy thừa của 2 cho một số nguyên không âm cho trước.\n\n- Tham số:\n- n: Một số nguyên không âm mà lũy thừa của 2 được tính toán. Giá trị của `n` phải nằm trong khoảng từ 0 đến 30, bao gồm cả hai đầu.\n\n- Trả về: Kết quả của 2 lũy thừa `n`.\n\n### Ví dụ:\n- `powerOfTwo(3)` trả về `8`, vì 2^3 = 8.\n- `powerOfTwo(5)` trả về `32`, vì 2^5 = 32.\n- `powerOfTwo(10)` trả về `1024`, vì 2^10 = 1024.\n\nLưu ý: Hàm được thiết kế để xử lý các đầu vào trong phạm vi chỉ định mà không dẫn đến tràn số nguyên."
    },
    "docstring_bertscore": {
      "es": "0.988356882954878",
      "arb": "0.9856259138460293",
      "sw": "0.9808087298451712",
      "tr": "0.9757394838907798",
      "vi": "0.981662045962097"
    }
  },
  {
    "task_id": "Swift/49",
    "prompt": {
      "en": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */",
      "es": "func determineSign(_ n: Int) -> String {\n    /**\n    Determina si un entero dado es positivo, cero o negativo.\n\n    - Parámetros:\n        - n: Un valor entero que puede variar de -10^9 a 10^9.\n\n    - Retorna: Una cadena que indica si el entero es `positive`, `zero` o `negative`.\n\n    ### Ejemplo:\n    - `determineSign(3)` retorna `\"positive\"`.\n    - `determineSign(0)` retorna `\"zero\"`.\n    - `determineSign(-5)` retorna `\"negative\"`.\n\n    Nota: Esta función clasifica con precisión cualquier entero dentro del rango especificado en una de las tres categorías.\n    */",
      "arb": "func determineSign(_ n: Int) -> String {\n    /**\n    يحدد ما إذا كان العدد الصحيح المعطى موجبًا أو صفرًا أو سالبًا.\n\n    - المعلمات:\n        - n: قيمة عدد صحيح يمكن أن تتراوح من -10^9 إلى 10^9.\n\n    - يعيد: سلسلة تشير إلى ما إذا كان العدد الصحيح `موجبًا` أو `صفرًا` أو `سالبًا`.\n\n    ### مثال:\n    - `determineSign(3)` يعيد `\"positive\"`.\n    - `determineSign(0)` يعيد `\"zero\"`.\n    - `determineSign(-5)` يعيد `\"negative\"`.\n\n    ملاحظة: تقوم هذه الدالة بتصنيف أي عدد صحيح ضمن النطاق المحدد بدقة إلى واحدة من الفئات الثلاث.\n    */",
      "sw": "func determineSign(_ n: Int) -> String {\n    /**\n    Huamua ikiwa nambari nzima iliyotolewa ni chanya, sifuri, au hasi.\n\n    - Vigezo:\n        - n: Thamani ya nambari nzima inayoweza kuwa kati ya -10^9 hadi 10^9.\n\n    - Inarejesha: Msururu unaoonyesha ikiwa nambari nzima ni `chanya`, `sifuri`, au `hasi`.\n\n    ### Mfano:\n    - `determineSign(3)` inarejesha `\"positive\"`.\n    - `determineSign(0)` inarejesha `\"zero\"`.\n    - `determineSign(-5)` inarejesha `\"negative\"`.\n\n    Kumbuka: Kazi hii inatambua kwa usahihi nambari yoyote nzima ndani ya anuwai iliyotajwa katika moja ya makundi matatu.\n    */",
      "tr": "func determineSign(_ n: Int) -> String {\n    /**\n    Verilen bir tam sayının pozitif, sıfır veya negatif olup olmadığını belirler.\n\n    - Parametreler:\n        - n: -10^9 ile 10^9 arasında değişebilen bir tam sayı değeri.\n\n    - Döndürülen: Tam sayının `pozitif`, `sıfır` veya `negatif` olduğunu belirten bir dize.\n\n    ### Örnek:\n    - `determineSign(3)` `\"positive\"` döndürür.\n    - `determineSign(0)` `\"zero\"` döndürür.\n    - `determineSign(-5)` `\"negative\"` döndürür.\n\n    Not: Bu fonksiyon belirtilen aralıktaki herhangi bir tam sayıyı üç kategoriden birine doğru bir şekilde sınıflandırır.\n    */",
      "vi": "func determineSign(_ n: Int) -> String {\n    /**\n    Xác định xem một số nguyên đã cho là dương, bằng không, hay âm.\n\n    - Tham số:\n        - n: Một giá trị số nguyên có thể nằm trong khoảng từ -10^9 đến 10^9.\n\n    - Trả về: Một chuỗi chỉ ra liệu số nguyên là `positive`, `zero`, hay `negative`.\n\n    ### Ví dụ:\n    - `determineSign(3)` trả về `\"positive\"`.\n    - `determineSign(0)` trả về `\"zero\"`.\n    - `determineSign(-5)` trả về `\"negative\"`.\n\n    Lưu ý: Hàm này phân loại chính xác bất kỳ số nguyên nào trong phạm vi đã chỉ định vào một trong ba loại.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.996897393448235",
      "arb": "0.99560470692846",
      "sw": "0.9855053452047411",
      "tr": "0.994528328893632",
      "vi": "0.9899431451778226"
    },
    "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}",
    "instruction": {
      "en": "Write a Swift function `func determineSign(_ n: Int) -> String {` to solve the following problem:\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n",
      "es": "Escribe una función en Swift `func determineSign(_ n: Int) -> String {` para resolver el siguiente problema:\nDetermina si un número entero dado es positivo, cero o negativo.\n\n- Parámetros:\n- n: Un valor entero que puede variar de -10^9 a 10^9.\n\n- Retorna: Una cadena que indica si el entero es `positive`, `zero`, o `negative`.\n\n### Ejemplo:\n- `determineSign(3)` retorna `\"positive\"`.\n- `determineSign(0)` retorna `\"zero\"`.\n- `determineSign(-5)` retorna `\"negative\"`.\n\nNota: Esta función clasifica con precisión cualquier entero dentro del rango especificado en una de las tres categorías.",
      "arb": "اكتب دالة Swift `func determineSign(_ n: Int) -> String {` لحل المشكلة التالية:\nتحدد ما إذا كان العدد الصحيح المعطى موجبًا، صفرًا، أو سالبًا.\n\n- المعاملات:\n- n: قيمة عدد صحيح يمكن أن تتراوح من -10^9 إلى 10^9.\n\n- العوائد: سلسلة نصية تشير إلى ما إذا كان العدد الصحيح `موجبًا`، `صفرًا`، أو `سالبًا`.\n\n### مثال:\n- `determineSign(3)` تعيد `\"positive\"`.\n- `determineSign(0)` تعيد `\"zero\"`.\n- `determineSign(-5)` تعيد `\"negative\"`.\n\nملاحظة: تقوم هذه الدالة بتصنيف أي عدد صحيح ضمن النطاق المحدد بدقة إلى واحدة من الفئات الثلاث.",
      "sw": "Andika kazi ya Swift `func determineSign(_ n: Int) -> String {` kutatua tatizo lifuatalo:\nInabaini ikiwa nambari kamili iliyotolewa ni chanya, sifuri, au hasi.\n\n- Vigezo:\n- n: Thamani ya nambari kamili inayoweza kuwa kati ya -10^9 hadi 10^9.\n\n- Inarudisha: Mfuatano wa herufi unaoonyesha kama nambari kamili ni `positive`, `zero`, au `negative`.\n\n### Mfano:\n- `determineSign(3)` inarudisha `\"positive\"`.\n- `determineSign(0)` inarudisha `\"zero\"`.\n- `determineSign(-5)` inarudisha `\"negative\"`.\n\nKumbuka: Kazi hii inatambua kwa usahihi nambari yoyote kamili ndani ya wigo uliotajwa katika moja ya makundi matatu.",
      "tr": "Bir Swift fonksiyonu `func determineSign(_ n: Int) -> String {` yazın. Aşağıdaki problemi çözmek için:\nVerilen bir tam sayının pozitif, sıfır veya negatif olup olmadığını belirler.\n\n- Parametreler:\n- n: -10^9 ile 10^9 arasında değişebilen bir tam sayı değeri.\n\n- Döndürür: Tam sayının `positive`, `zero` veya `negative` olduğunu belirten bir dize.\n\n### Örnek:\n- `determineSign(3)` `\"positive\"` döndürür.\n- `determineSign(0)` `\"zero\"` döndürür.\n- `determineSign(-5)` `\"negative\"` döndürür.\n\nNot: Bu fonksiyon, belirtilen aralıktaki herhangi bir tam sayıyı üç kategoriden birine doğru bir şekilde sınıflandırır.",
      "vi": "Viết một hàm Swift `func determineSign(_ n: Int) -> String {` để giải quyết vấn đề sau:\nXác định xem một số nguyên cho trước là dương, bằng không, hay âm.\n\n- Tham số:\n- n: Một giá trị số nguyên có thể nằm trong khoảng từ -10^9 đến 10^9.\n\n- Trả về: Một chuỗi cho biết liệu số nguyên là `positive`, `zero`, hay `negative`.\n\n### Ví dụ:\n- `determineSign(3)` trả về `\"positive\"`.\n- `determineSign(0)` trả về `\"zero\"`.\n- `determineSign(-5)` trả về `\"negative\"`.\n\nLưu ý: Hàm này phân loại chính xác bất kỳ số nguyên nào trong phạm vi được chỉ định vào một trong ba loại."
    },
    "instruction_bertscore": {
      "es": "0.9895516446968028",
      "arb": "0.9894203500149388",
      "sw": "0.9846838099487808",
      "tr": "0.9893903568274025",
      "vi": "0.9854779342121582"
    },
    "level": "easy",
    "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()",
    "entry_point": "determineSign",
    "signature": "func determineSign(_ n: Int) -> String {",
    "docstring": {
      "en": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n",
      "es": "Determina si un número entero dado es positivo, cero o negativo.\n\n- Parámetros:\n- n: Un valor entero que puede variar de -10^9 a 10^9.\n\n- Retorna: Una cadena que indica si el entero es `positive`, `zero`, o `negative`.\n\n### Ejemplo:\n- `determineSign(3)` retorna `\"positive\"`.\n- `determineSign(0)` retorna `\"zero\"`.\n- `determineSign(-5)` retorna `\"negative\"`.\n\nNota: Esta función clasifica con precisión cualquier entero dentro del rango especificado en una de las tres categorías.",
      "arb": "يحدد ما إذا كان عدد صحيح معين موجبًا أو صفرًا أو سالبًا.\n\n- المعلمات:\n- n: قيمة عدد صحيح يمكن أن تتراوح من -10^9 إلى 10^9.\n\n- يعيد: سلسلة نصية تشير إلى ما إذا كان العدد الصحيح `موجبًا`، `صفرًا`، أو `سالبًا`.\n\n### مثال:\n- `determineSign(3)` يعيد `\"positive\"`.\n- `determineSign(0)` يعيد `\"zero\"`.\n- `determineSign(-5)` يعيد `\"negative\"`.\n\nملاحظة: تقوم هذه الدالة بتصنيف أي عدد صحيح ضمن النطاق المحدد بدقة إلى واحدة من الفئات الثلاث.",
      "sw": "Inabainisha ikiwa nambari kamili iliyotolewa ni chanya, sifuri, au hasi.\n\n- Vigezo:\n- n: Thamani ya nambari kamili inayoweza kuwa kati ya -10^9 hadi 10^9.\n\n- Inarejesha: Mfuatano wa herufi unaoonyesha ikiwa nambari kamili ni `chanya`, `sifuri`, au `hasi`.\n\n### Mfano:\n- `determineSign(3)` inarejesha `\"positive\"`.\n- `determineSign(0)` inarejesha `\"zero\"`.\n- `determineSign(-5)` inarejesha `\"negative\"`.\n\nKumbuka: Kazi hii inatambua kwa usahihi nambari yoyote kamili ndani ya safu iliyobainishwa katika moja ya makundi matatu.",
      "tr": "Verilen bir tam sayının pozitif, sıfır veya negatif olup olmadığını belirler.\n\n- Parametreler:\n- n: -10^9 ile 10^9 arasında değişebilen bir tam sayı değeri.\n\n- Döndürür: Tam sayının `pozitif`, `sıfır` veya `negatif` olduğunu belirten bir dize.\n\n### Örnek:\n- `determineSign(3)` `\"positive\"` döndürür.\n- `determineSign(0)` `\"zero\"` döndürür.\n- `determineSign(-5)` `\"negative\"` döndürür.\n\nNot: Bu fonksiyon, belirtilen aralıktaki herhangi bir tam sayıyı üç kategoriden birine doğru bir şekilde sınıflandırır.",
      "vi": "Xác định xem một số nguyên cho trước là dương, bằng không, hay âm.\n\n- Tham số:\n- n: Một giá trị số nguyên có thể nằm trong khoảng từ -10^9 đến 10^9.\n\n- Trả về: Một chuỗi chỉ ra liệu số nguyên là `positive`, `zero`, hay `negative`.\n\n### Ví dụ:\n- `determineSign(3)` trả về `\"positive\"`.\n- `determineSign(0)` trả về `\"zero\"`.\n- `determineSign(-5)` trả về `\"negative\"`.\n\nLưu ý: Hàm này phân loại chính xác bất kỳ số nguyên nào trong phạm vi đã chỉ định vào một trong ba loại."
    },
    "docstring_bertscore": {
      "es": "0.9942274038663641",
      "arb": "0.9947366921633375",
      "sw": "0.9873714776345639",
      "tr": "0.9929108817008648",
      "vi": "0.9864573806210413"
    }
  },
  {
    "task_id": "Swift/50",
    "prompt": {
      "en": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calculates and returns the absolute value of a given integer.\n\n    - Parameters:\n        - n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n    - Returns: The absolute value of `n`.\n\n    ### Example:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    Note: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n    */",
      "es": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calcula y devuelve el valor absoluto de un entero dado.\n\n    - Parámetros:\n        - n: Un entero cuyo valor absoluto se va a calcular. El valor de `n` no debe exceder el valor absoluto de 10000.\n\n    - Devuelve: El valor absoluto de `n`.\n\n    ### Ejemplo:\n    - `absoluteValue(-3)` devuelve `3`.\n    - `absoluteValue(5)` devuelve `5`.\n    - `absoluteValue(0)` devuelve `0`.\n    - `absoluteValue(-10000)` devuelve `10000`.\n\n    Nota: Esta función asegura que el valor absoluto se calcule correctamente para cualquier entero dentro del límite especificado.\n    */",
      "arb": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    يحسب ويعيد القيمة المطلقة لعدد صحيح معين.\n\n    - المعاملات:\n        - n: عدد صحيح يجب حساب قيمته المطلقة. يجب ألا يتجاوز قيمة `n` المطلقة 10000.\n\n    - العوائد: القيمة المطلقة لـ `n`.\n\n    ### مثال:\n    - `absoluteValue(-3)` يعيد `3`.\n    - `absoluteValue(5)` يعيد `5`.\n    - `absoluteValue(0)` يعيد `0`.\n    - `absoluteValue(-10000)` يعيد `10000`.\n\n    ملاحظة: تضمن هذه الدالة حساب القيمة المطلقة بشكل صحيح لأي عدد صحيح ضمن الحد المحدد.\n    */",
      "sw": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Inahesabu na kurudisha thamani kamili ya nambari nzima iliyotolewa.\n\n    - Vigezo:\n        - n: Nambari nzima ambayo thamani yake kamili inapaswa kuhesabiwa. Thamani ya `n` haipaswi kuzidi thamani kamili ya 10000.\n\n    - Inarudisha: Thamani kamili ya `n`.\n\n    ### Mfano:\n    - `absoluteValue(-3)` inarudisha `3`.\n    - `absoluteValue(5)` inarudisha `5`.\n    - `absoluteValue(0)` inarudisha `0`.\n    - `absoluteValue(-10000)` inarudisha `10000`.\n\n    Kumbuka: Kazi hii inahakikisha kwamba thamani kamili inahesabiwa kwa usahihi kwa nambari yoyote nzima ndani ya kikomo kilichowekwa.\n    */",
      "tr": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Verilen bir tam sayının mutlak değerini hesaplar ve döndürür.\n\n    - Parametreler:\n        - n: Mutlak değeri hesaplanacak tam sayı. `n`'nin değeri mutlak değeri 10000'i geçmemelidir.\n\n    - Döndürür: `n`'nin mutlak değeri.\n\n    ### Örnek:\n    - `absoluteValue(-3)` `3` döndürür.\n    - `absoluteValue(5)` `5` döndürür.\n    - `absoluteValue(0)` `0` döndürür.\n    - `absoluteValue(-10000)` `10000` döndürür.\n\n    Not: Bu fonksiyon, belirtilen sınırlar içindeki herhangi bir tam sayı için mutlak değerin doğru bir şekilde hesaplanmasını sağlar.\n    */",
      "vi": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Tính toán và trả về giá trị tuyệt đối của một số nguyên đã cho.\n\n    - Tham số:\n        - n: Một số nguyên mà giá trị tuyệt đối cần được tính. Giá trị của `n` không được vượt quá giá trị tuyệt đối của 10000.\n\n    - Trả về: Giá trị tuyệt đối của `n`.\n\n    ### Ví dụ:\n    - `absoluteValue(-3)` trả về `3`.\n    - `absoluteValue(5)` trả về `5`.\n    - `absoluteValue(0)` trả về `0`.\n    - `absoluteValue(-10000)` trả về `10000`.\n\n    Lưu ý: Hàm này đảm bảo rằng giá trị tuyệt đối được tính chính xác cho bất kỳ số nguyên nào trong giới hạn đã chỉ định.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9994450267153885",
      "arb": "0.9817935392743421",
      "sw": "0.9913125030246771",
      "tr": "0.979674947630224",
      "vi": "0.987344066641981"
    },
    "canonical_solution": "    return abs(n)\n}",
    "instruction": {
      "en": "Write a Swift function `func absoluteValue(_ n: Int) -> Int {` to solve the following problem:\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n",
      "es": "Escribe una función Swift `func absoluteValue(_ n: Int) -> Int {` para resolver el siguiente problema:\nCalcula y devuelve el valor absoluto de un entero dado.\n\n- Parámetros:\n- n: Un entero cuyo valor absoluto se va a calcular. El valor de `n` no debe exceder el valor absoluto de 10000.\n\n- Devuelve: El valor absoluto de `n`.\n\n### Ejemplo:\n- `absoluteValue(-3)` devuelve `3`.\n- `absoluteValue(5)` devuelve `5`.\n- `absoluteValue(0)` devuelve `0`.\n- `absoluteValue(-10000)` devuelve `10000`.\n\nNota: Esta función asegura que el valor absoluto se calcule correctamente para cualquier entero dentro del límite especificado.",
      "arb": "اكتب دالة Swift `func absoluteValue(_ n: Int) -> Int {` لحل المشكلة التالية:\nتحسب وتعيد القيمة المطلقة لعدد صحيح معطى.\n\n- المعاملات:\n- n: عدد صحيح يجب حساب قيمته المطلقة. يجب ألا تتجاوز قيمة `n` القيمة المطلقة لـ 10000.\n\n- العوائد: القيمة المطلقة لـ `n`.\n\n### مثال:\n- `absoluteValue(-3)` تعيد `3`.\n- `absoluteValue(5)` تعيد `5`.\n- `absoluteValue(0)` تعيد `0`.\n- `absoluteValue(-10000)` تعيد `10000`.\n\nملاحظة: تضمن هذه الدالة أن القيمة المطلقة يتم حسابها بشكل صحيح لأي عدد صحيح ضمن الحد المحدد.",
      "sw": "Andika kazi ya Swift `func absoluteValue(_ n: Int) -> Int {` kutatua tatizo lifuatalo:\nInahesabu na kurudisha thamani kamili ya nambari nzima iliyotolewa.\n\n- Vigezo:\n- n: Nambari nzima ambayo thamani yake kamili inapaswa kuhesabiwa. Thamani ya `n` haipaswi kuzidi thamani kamili ya 10000.\n\n- Inarudisha: Thamani kamili ya `n`.\n\n### Mfano:\n- `absoluteValue(-3)` inarudisha `3`.\n- `absoluteValue(5)` inarudisha `5`.\n- `absoluteValue(0)` inarudisha `0`.\n- `absoluteValue(-10000)` inarudisha `10000`.\n\nKumbuka: Kazi hii inahakikisha kuwa thamani kamili inahesabiwa kwa usahihi kwa nambari yoyote nzima ndani ya kikomo kilichobainishwa.",
      "tr": "Bir Swift fonksiyonu `func absoluteValue(_ n: Int) -> Int {` yazın ve aşağıdaki problemi çözün:\nVerilen bir tam sayının mutlak değerini hesaplar ve döndürür.\n\n- Parametreler:\n- n: Mutlak değeri hesaplanacak bir tam sayı. `n`'in değeri mutlak değer olarak 10000'i aşmamalıdır.\n\n- Dönüş: `n`'in mutlak değeri.\n\n### Örnek:\n- `absoluteValue(-3)` `3` döndürür.\n- `absoluteValue(5)` `5` döndürür.\n- `absoluteValue(0)` `0` döndürür.\n- `absoluteValue(-10000)` `10000` döndürür.\n\nNot: Bu fonksiyon, belirtilen sınır içerisindeki herhangi bir tam sayı için mutlak değerin doğru bir şekilde hesaplandığını garanti eder.",
      "vi": "Viết một hàm Swift `func absoluteValue(_ n: Int) -> Int {` để giải quyết vấn đề sau:\nTính toán và trả về giá trị tuyệt đối của một số nguyên cho trước.\n\n- Tham số:\n- n: Một số nguyên mà giá trị tuyệt đối cần được tính toán. Giá trị của `n` không được vượt quá giá trị tuyệt đối của 10000.\n\n- Trả về: Giá trị tuyệt đối của `n`.\n\n### Ví dụ:\n- `absoluteValue(-3)` trả về `3`.\n- `absoluteValue(5)` trả về `5`.\n- `absoluteValue(0)` trả về `0`.\n- `absoluteValue(-10000)` trả về `10000`.\n\nLưu ý: Hàm này đảm bảo rằng giá trị tuyệt đối được tính toán chính xác cho bất kỳ số nguyên nào trong giới hạn đã chỉ định."
    },
    "instruction_bertscore": {
      "es": "0.9958786182239071",
      "arb": "0.9928856556424734",
      "sw": "0.9902810154559629",
      "tr": "0.9804335170553963",
      "vi": "0.9870707512376771"
    },
    "level": "easy",
    "test": "func testAbsoluteValue() {\n    assert(absoluteValue(-3) == 3, \"-3's absolute value should be 3.\")\n    assert(absoluteValue(5) == 5, \"5's absolute value should be 5.\")\n    assert(absoluteValue(0) == 0, \"0's absolute value should be 0.\")\n    assert(absoluteValue(-10000) == 10000, \"-10000's absolute value should be 10000.\")\n    assert(absoluteValue(10000) == 10000, \"10000's absolute value should be 10000.\")\n    assert(absoluteValue(-1) == 1, \"-1's absolute value should be 1.\")\n}\n\n// Call the test function to verify the functionality\ntestAbsoluteValue()",
    "entry_point": "absoluteValue",
    "signature": "func absoluteValue(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n",
      "es": "Calcula y devuelve el valor absoluto de un entero dado.\n\n- Parámetros:\n- n: Un entero cuyo valor absoluto se va a calcular. El valor de `n` no debe exceder el valor absoluto de 10000.\n\n- Devuelve: El valor absoluto de `n`.\n\n### Ejemplo:\n- `absoluteValue(-3)` devuelve `3`.\n- `absoluteValue(5)` devuelve `5`.\n- `absoluteValue(0)` devuelve `0`.\n- `absoluteValue(-10000)` devuelve `10000`.\n\nNota: Esta función asegura que el valor absoluto se calcule correctamente para cualquier entero dentro del límite especificado.",
      "arb": "يحسب ويعيد القيمة المطلقة لعدد صحيح معين.\n\n- المعلمات:\n- n: عدد صحيح يجب حساب قيمته المطلقة. يجب ألا تتجاوز قيمة `n` القيمة المطلقة لـ 10000.\n\n- العوائد: القيمة المطلقة لـ `n`.\n\n### مثال:\n- `absoluteValue(-3)` يعيد `3`.\n- `absoluteValue(5)` يعيد `5`.\n- `absoluteValue(0)` يعيد `0`.\n- `absoluteValue(-10000)` يعيد `10000`.\n\nملاحظة: تضمن هذه الدالة حساب القيمة المطلقة بشكل صحيح لأي عدد صحيح ضمن الحد المحدد.",
      "sw": "Inahesabu na kurudisha thamani kamili ya nambari nzima iliyotolewa.\n\n- Vigezo:\n- n: Nambari nzima ambayo thamani yake kamili inapaswa kuhesabiwa. Thamani ya `n` haipaswi kuzidi thamani kamili ya 10000.\n\n- Inarudisha: Thamani kamili ya `n`.\n\n### Mfano:\n- `absoluteValue(-3)` inarudisha `3`.\n- `absoluteValue(5)` inarudisha `5`.\n- `absoluteValue(0)` inarudisha `0`.\n- `absoluteValue(-10000)` inarudisha `10000`.\n\nKumbuka: Kazi hii inahakikisha kuwa thamani kamili inahesabiwa kwa usahihi kwa nambari yoyote nzima ndani ya kikomo kilichowekwa.",
      "tr": "Verilen bir tam sayının mutlak değerini hesaplar ve döndürür.\n\n- Parametreler:\n- n: Mutlak değeri hesaplanacak bir tam sayı. `n`'nin değeri mutlak değer olarak 10000'i aşmamalıdır.\n\n- Döndürür: `n`'nin mutlak değeri.\n\n### Örnek:\n- `absoluteValue(-3)` `3` döndürür.\n- `absoluteValue(5)` `5` döndürür.\n- `absoluteValue(0)` `0` döndürür.\n- `absoluteValue(-10000)` `10000` döndürür.\n\nNot: Bu fonksiyon, belirtilen sınır dahilinde herhangi bir tam sayı için mutlak değerin doğru bir şekilde hesaplanmasını sağlar.",
      "vi": "Tính toán và trả về giá trị tuyệt đối của một số nguyên cho trước.\n\n- Tham số:\n- n: Một số nguyên mà giá trị tuyệt đối cần được tính toán. Giá trị của `n` không được vượt quá giá trị tuyệt đối của 10000.\n\n- Trả về: Giá trị tuyệt đối của `n`.\n\n### Ví dụ:\n- `absoluteValue(-3)` trả về `3`.\n- `absoluteValue(5)` trả về `5`.\n- `absoluteValue(0)` trả về `0`.\n- `absoluteValue(-10000)` trả về `10000`.\n\nLưu ý: Hàm này đảm bảo rằng giá trị tuyệt đối được tính toán chính xác cho bất kỳ số nguyên nào trong giới hạn đã chỉ định."
    },
    "docstring_bertscore": {
      "es": "0.9993196909449555",
      "arb": "0.9908097695302778",
      "sw": "0.9942524312943745",
      "tr": "0.976122046004653",
      "vi": "0.986950977117913"
    }
  }
]