[
  {
    "task_id": "C/1",
    "prompt": {
      "es": "#include <assert.h>\n#include <string.h>\n// Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "arb": "#include <assert.h>\n#include <string.h>\n// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "sw": "#include <assert.h>\n#include <string.h>\n// Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "tr": "#include <assert.h>\n#include <string.h>\n// çözün\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nchar *hello_mmcodeeval()",
      "vi": "#include <assert.h>\n#include <string.h>\n// Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "es": "0.9978188397858558",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "0.9328045338781835"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "es": "Escribe una función en C `char *hello_mmcodeeval()` para resolver el siguiente problema:  \nDevuelve: \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "اكتب دالة بلغة C `char *hello_mmcodeeval()` لحل المشكلة التالية:  \nإرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Andika kazi ya C `char *hello_mmcodeeval()` kutatua tatizo lifuatalo:  \nRudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "Bir C fonksiyonu `char *hello_mmcodeeval()` yazın ve aşağıdaki problemi \nçözün:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndürün.",
      "vi": "Viết một hàm C `char *hello_mmcodeeval()` để giải quyết vấn đề sau:  \nTrả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "instruction_bertscore": {
      "es": "0.9891494181752072",
      "arb": "0.9891494181752072",
      "sw": "1",
      "tr": "0.9842543710649834",
      "vi": "1"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(strcmp(hello_mmcodeeval(), \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\") == 0);\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "char *hello_mmcodeeval()",
    "docstring": {
      "es": "Devuelve:\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "إرجاع:\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Rudisha: \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "çözün: \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "vi": "Trả về: \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9299498180419501",
      "tr": "0.953923710511337",
      "vi": "0.9390822470707911"
    }
  },
  {
    "task_id": "C/2",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب مساحة المثلث المعطى أطوال أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة بدقتين عشريتين.\nخلاف ذلك، يتم إرجاع \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n​    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n​    Inarudisha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n​    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n​    Döndürür:\n- str: Sağlanan kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n​    Tham số:\n- a (float): Độ dài cạnh 'a'.\n- b (float): Độ dài cạnh 'b'.\n- c (float): Độ dài cạnh 'c'.\n​    Trả về:\n- str: Nếu các cạnh đã cho tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "es": "0.9776175341434646",
      "arb": "0.9728247816794738",
      "sw": "0.9875013819037607",
      "tr": "0.9880513894288463",
      "vi": "0.9858700305843212"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C `double calculate_triangle_area(double a, double b, double c)` para resolver el siguiente problema:\nCalcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "arb": "اكتب دالة بلغة C `double calculate_triangle_area(double a, double b, double c)` لحل المشكلة التالية:\nاحسب مساحة مثلث معطى أطوال أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، أعد المساحة المحسوبة بدقتين عشريتين.\nخلاف ذلك، أعد \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "sw": "Andika kazi ya C `double calculate_triangle_area(double a, double b, double c)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukizingatia pande zake tatu.\n    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n    Inarejesha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rejesha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rejesha \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n",
      "tr": "Bir C fonksiyonu `double calculate_triangle_area(double a, double b, double c)` yazın ve aşağıdaki problemi çözün:\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n    Döndürür:\n- str: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "vi": "Viết một hàm C `double calculate_triangle_area(double a, double b, double c)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n    Tham số:\n- a (float): Chiều dài cạnh 'a'.\n- b (float): Chiều dài cạnh 'b'.\n- c (float): Chiều dài cạnh 'c'.\n    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNgược lại, trả về \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6"
    },
    "instruction_bertscore": {
      "es": "0.9799127081963228",
      "arb": "0.9872854706795757",
      "sw": "0.996766098766371",
      "tr": "0.9911665096946165",
      "vi": "1"
    },
    "level": "easy",
    "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = calculate_triangle_area(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculate_triangle_area(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "es": "Calcular el área de un triángulo dado sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "arb": "حساب مساحة المثلث المعطى أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مع منزلتين عشريتين.\nوإلا، يتم إرجاع \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "sw": "Hesabu eneo la pembetatu ukizingatia pande zake tatu.\n    Parameters:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n    Returns:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililokokotolewa na sehemu 2 za desimali.\nVinginevyo, rudisha \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n    Döndürülen:\n- str: Sağlanan kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "vi": "Tính diện tích của một tam giác khi biết độ dài ba cạnh của nó.\n    Tham số:\n- a (float): Độ dài của cạnh 'a'.\n- b (float): Độ dài của cạnh 'b'.\n- c (float): Độ dài của cạnh 'c'.\n    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9792892074302543",
      "arb": "0.979282255366918",
      "sw": "0.9957602345168103",
      "tr": "0.9960742691492265",
      "vi": "0.9803927978272842"
    }
  },
  {
    "task_id": "C/3",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, retorna \"Not define\".\nDe lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب قيمة الدالة لمدخل معين.\n    المعاملات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu thamani ya kazi kwa ingizo lililopewa.\n    Vigezo:\n- x (int): Thamani ya ingizo kwa kazi.\n    Inarudisha:\n- double au string: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBelirtilen bir girdi için fonksiyonun değerini hesapla.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürür:\n- double veya string: x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính giá trị của hàm cho một đầu vào cho trước.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "es": "0.980864942243004",
      "arb": "0.9618991175706498",
      "sw": "0.9940351296575223",
      "tr": "0.9853027422160855",
      "vi": "0.9928536761511267"
    },
    "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}",
    "instruction": {
      "es": "Escribe una función en C `const char* calculate_function_value(int x)` para resolver el siguiente problema:\nCalcula el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "arb": "اكتب دالة بلغة C `const char* calculate_function_value(int x)` لحل المشكلة التالية:\nاحسب قيمة الدالة لقيمة مدخلة معينة.\n    المعاملات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\nبخلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدالة:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "sw": "Andika kazi ya C `const char* calculate_function_value(int x)` kutatua tatizo lifuatalo:\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarejesha:\n- double au string: Ikiwa x haiko kwenye kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "tr": "Bir C fonksiyonu `const char* calculate_function_value(int x)` yazın ve aşağıdaki problemi çözün:\nVerilen bir girdi için fonksiyonun değerini hesaplayın.\n    \nParametreler:\n- x (int): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- double veya string: Eğer x tanımlı alanda değilse, \"Not define\" döner.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\n    >>> calculate_function_value(40)\n    Not define",
      "vi": "Viết một hàm C `const char* calculate_function_value(int x)` để giải quyết vấn đề sau:\nTính giá trị của hàm cho một đầu vào cho trước.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc chuỗi: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define"
    },
    "instruction_bertscore": {
      "es": "0.9850316117459729",
      "arb": "0.9761609775593358",
      "sw": "0.9943112258871608",
      "tr": "0.984650638675148",
      "vi": "0.9940263899207568"
    },
    "level": "middle",
    "test": "int main() {\n    const char* result = calculate_function_value(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(calculate_function_value(40), \"Not define\") == 0);\n    assert(strcmp(calculate_function_value(5), \"-0.14550\") == 0);\n    assert(strcmp(calculate_function_value(15), \"0.76266\") == 0);\n    assert(strcmp(calculate_function_value(25), \"0.31314\") == 0);\n    assert(strcmp(calculate_function_value(-1), \"Not define\") == 0);\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "const char* calculate_function_value(int x)",
    "docstring": {
      "es": "Calcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Devuelve:\n- double o string: Si x no está en el dominio definido, devuelve \"Not define\".\nDe lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de la función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "arb": "احسب قيمة الدالة لمدخل معين.\n    المعلمات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nخلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarudisha:\n- double au string: Ikiwa x haiko katika kikoa kilichobainishwa, inarudisha \"Not define\".\nVinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "tr": "Belirtilen bir giriş için fonksiyonun değerini hesaplayın.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürür:\n- double veya string: Eğer x tanımlı alanda değilse, \"Tanımsız\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Tanımsız",
      "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Với 0 <= x < 10: y = cos(x + 3.0)\n- Với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define"
    },
    "docstring_bertscore": {
      "es": "0.9762062652862118",
      "arb": "0.9793271458330319",
      "sw": "0.98750316957719",
      "tr": "0.971943260048441",
      "vi": "0.9905447966019773"
    }
  },
  {
    "task_id": "C/4",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nEncontrar el máximo y mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nإيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: مفهوم tuple غير موجود في لغة C؛ بدلاً من ذلك، سنعيد القيم بواسطة المرجع.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nPata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürülenler:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9646372373732157",
      "sw": "0.9820154094099581",
      "tr": "0.9790474742565348",
      "vi": "0.9834026439911058"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C `void find_max_min(int a, int b, int c, int *max, int *min)` para resolver el siguiente problema:\nEncuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "arb": "اكتب دالة بلغة C `void find_max_min(int a, int b, int c, int *max, int *min)` لحل المشكلة التالية:\nإيجاد القيمة العظمى والصغرى لثلاثة أعداد صحيحة مختلفة.\nالمعطيات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: لا يوجد مفهوم الترتيب في C؛ بدلاً من ذلك، سنعيد القيم عن طريق المرجع.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sw": "Andika kazi ya C `void find_max_min(int a, int b, int c, int *max, int *min)` kutatua tatizo lifuatalo:\nPata kubwa na ndogo kati ya nambari tatu tofauti.\nVigezo:\na (int): Nambari ya kwanza.\nb (int): Nambari ya pili.\nc (int): Nambari ya tatu.\n\nInarudisha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarudisha kwa marejeleo.\n\n>>> Mfano wa kupiga simu:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "tr": "Bir C fonksiyonu `void find_max_min(int a, int b, int c, int *max, int *min)` yazın ve aşağıdaki problemi çözün:\nÜç farklı tamsayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürülenler:\nTuple[int, int]: C'de tuple bir kavram değildir; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "vi": "Viết một hàm C `void find_max_min(int a, int b, int c, int *max, int *min)` để giải quyết vấn đề sau:\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "instruction_bertscore": {
      "es": "0.9958766319200968",
      "arb": "0.9581346745892766",
      "sw": "0.9614184320485454",
      "tr": "0.9766891357425076",
      "vi": "0.9845145768641391"
    },
    "level": "middle",
    "test": "int main() {\n    int max, min;\n\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "es": "Encuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: ليست هناك مفهوم للـ tuple في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sw": "Tafuta kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga simu:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "tr": "Üç farklı tamsayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tamsayı.\nb (int): İkinci tamsayı.\nc (int): Üçüncü tamsayı.\n\nDöndürülenler:\nTuple[int, int]: C'de bir kavram değildir; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.  \nTham số:  \na (int): Số nguyên thứ nhất.  \nb (int): Số nguyên thứ hai.  \nc (int): Số nguyên thứ ba.  \n\nTrả về:  \nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9638385446110744",
      "sw": "0.9675094326829803",
      "tr": "0.9683246117667474",
      "vi": "0.9877168958671836"
    }
  },
  {
    "task_id": "C/5",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürür:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9776507054170975",
      "sw": "0.9970292840212422",
      "tr": "0.9970292840212422",
      "vi": "0.996288392699982"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "es": "Escribe una función en C `double calculate_distance(double xa, double ya, double xb, double yb)` para resolver el siguiente problema:\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Retorna:\n    double: La distancia entre los puntos A y B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "arb": "اكتب دالة C `double calculate_distance(double xa, double ya, double xb, double yb)` لحل المشكلة التالية:\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعاملات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "sw": "Andika kazi ya C `double calculate_distance(double xa, double ya, double xb, double yb)` kutatua tatizo lifuatalo:\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarudisha:\n    double: Umbali kati ya pointi A na B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "tr": "Bir C fonksiyonu `double calculate_distance(double xa, double ya, double xb, double yb)` yazın ve aşağıdaki problemi çözün:\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürür:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "vi": "Viết một hàm C `double calculate_distance(double xa, double ya, double xb, double yb)` để giải quyết vấn đề sau:\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> calculate_distance(0,0,3,4)\n    5\n"
    },
    "instruction_bertscore": {
      "es": "0.9951297816874056",
      "arb": "0.9791215633886609",
      "sw": "1",
      "tr": "0.9949432677596138",
      "vi": "0.9990048617910152"
    },
    "level": "easy",
    "test": "int main() {\n    assert(fabs(calculate_distance(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعاملات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kipeo cha pointi A.\n- ya (double): y-kipeo cha pointi A.\n- xb (double): x-kipeo cha pointi B.\n- yb (double): y-kipeo cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürülenler:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> calculate_distance(0,0,3,4)\n    5"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9711094097088565",
      "sw": "0.9957141522684102",
      "tr": "0.9968674002606988",
      "vi": "0.998719032672706"
    }
  },
  {
    "task_id": "C/6",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Devuelve:\n    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n​    المعاملات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n​    يعيد:\n​    int: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPata faktoria ya N na chukua modulo 10007 ya matokeo.\n​    Vigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n​    Inarudisha:\n​    int: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN'in faktöriyelini bulun ve sonucun 10007 modunu alın.\n​    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n​    Döndürür:\n​    int: Çıktının 10007 modunu aldıktan sonraki sonucu.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm giai thừa của N và lấy phần dư 10007 của kết quả.\n    Tham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n    Trả về:\n    int: Kết quả sau khi lấy phần dư 10007 của đầu ra.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9834018494695816",
      "arb": "0.9430282382204302",
      "sw": "0.9672414802989642",
      "tr": "0.9620697410679588",
      "vi": "0.9587877712821193"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "es": "Escribe una función en C `int process_request(int n)` para resolver el siguiente problema:\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Retorna:\n    int: El resultado después de tomar el módulo 10007 del resultado.\n    >>> process_request(1)\n    1",
      "arb": "اكتب دالة بلغة C `int process_request(int n)` لحل المشكلة التالية:\nابحث عن مضروب N وخذ باقي القسمة 10007 للنتيجة.\n    المعطيات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n    يعيد:\n    int: النتيجة بعد أخذ باقي القسمة 10007 من المخرجات.\n    >>> process_request(1)\n    1",
      "sw": "Andika kazi ya C `int process_request(int n)` kutatua tatizo lifuatalo:\nPata faktoria ya N na chukua modulo 10007 ya matokeo.\n    Vigezo:\n- N (int): Nambari kamili inayowakilisha thamani ya ingizo (N <= 10000).\n    Inarudisha:\n    int: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n    >>> process_request(1)\n    1",
      "tr": "Bir C fonksiyonu `int process_request(int n)` yazın ve aşağıdaki problemi çözün:\nN faktöriyelini bulun ve sonucu 10007 ile mod alın.\n    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n    Döndürülen:\n    int: Çıktının 10007 ile mod alınmasından sonra elde edilen sonuç.\n    >>> process_request(1)\n    1",
      "vi": "Viết một hàm C `int process_request(int n)` để giải quyết vấn đề sau:  \nTìm giai thừa của N và lấy modulo 10007 của kết quả.  \n    Tham số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).  \n    Trả về:  \n    int: Kết quả sau khi lấy modulo 10007 của đầu ra.  \n    >>> process_request(1)  \n    1  "
    },
    "instruction_bertscore": {
      "es": "0.9881814923284241",
      "arb": "0.919410887285001",
      "sw": "0.9828603830508805",
      "tr": "0.9600826427360858",
      "vi": "0.9880541702541807"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "es": "Encontrar el factorial de N y tomar el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Devuelve:\n    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> process_request(1)\n    1",
      "arb": "احسب المضروب لـ N وخذ باقي القسمة 10007 من النتيجة.\n    المعاملات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n    يعيد:\n    int: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n    >>> process_request(1)\n    1",
      "sw": "Pata faktoria ya N na chukua modulo 10007 ya matokeo.\n    Vigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n    Inarejesha:\n    int: Matokeo baada ya kuchukua modulo 10007 ya matokeo.\n    >>> process_request(1)\n    1",
      "tr": "N faktöriyelini bulun ve sonucu 10007 ile mod alın.\n    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n    Döndürür:\n    int: Çıktının 10007 ile modülüsünün alınmasından sonra elde edilen sonuç.\n    >>> process_request(1)\n    1",
      "vi": "Tìm giai thừa của N và lấy modulo 10007 của kết quả.  \n    Tham số:  \n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).  \n    Trả về:  \n    int: Kết quả sau khi lấy modulo 10007 của đầu ra.  \n    >>> process_request(1)  \n    1  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9067895156132821",
      "sw": "0.9914622703319774",
      "tr": "0.9658274306163768",
      "vi": "0.9845400015529115"
    }
  },
  {
    "task_id": "C/7",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarudisha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "es": "0.9795347145812134",
      "arb": "0.9780992128174743",
      "sw": "0.9692039484635888",
      "tr": "0.9822062932061326",
      "vi": "0.9753600998630032"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "es": "Escribe una función en C `float calculate_triangle_area(int base, int height)` para resolver el siguiente problema:\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Retorna:\n    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "arb": "اكتب دالة C `float calculate_triangle_area(int base, int height)` لحل المشكلة التالية:  \nاحسب مساحة المثلث المعطى قاعدته وارتفاعه.  \n    المعاملات:  \n- base (int): طول قاعدة المثلث.  \n- height (int): ارتفاع المثلث.  \n    يعيد:  \n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.  \n    >>> calculate_triangle_area(1,2)  \n    1.0  ",
      "sw": "Andika kazi ya C `float calculate_triangle_area(int base, int height)` kutatua tatizo lifuatalo:\nHesabu eneo la pembetatu ukitumia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "tr": "Bir C fonksiyonu `float calculate_triangle_area(int base, int height)` yazın ve aşağıdaki problemi çözün:\nÜçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Döndürür:\n    float: Hesaplanan üçgen alanı, bir ondalık basamağa yuvarlanmış.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "vi": "Viết hàm C `float calculate_triangle_area(int base, int height)` để giải quyết vấn đề sau:\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, được làm tròn đến một chữ số thập phân.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "instruction_bertscore": {
      "es": "0.9837067471044701",
      "arb": "0.9915232498589551",
      "sw": "0.9875043613594762",
      "tr": "0.987372073525707",
      "vi": "0.9912032563151079"
    },
    "level": "easy",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "es": "Calcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "arb": "حساب مساحة المثلث بناءً على قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "sw": "Hesabu eneo la pembetatu ukitumia msingi na urefu wake.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "tr": "Üçgenin taban uzunluğu ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Döndürülen:\n    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "vi": "Tính diện tích của một tam giác dựa trên độ dài đáy và chiều cao của nó.\n    Tham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "es": "0.9881097867608706",
      "arb": "0.9766956905450818",
      "sw": "0.9823451358424761",
      "tr": "0.9871063060758823",
      "vi": "0.9813347030941516"
    }
  },
  {
    "task_id": "C/8",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Retorna:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados\n         para transformar x en y en binario.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب\n         لتحويل x إلى y في النظام الثنائي.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarudisha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki tam sayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi\n         để biến đổi x thành y trong nhị phân.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "es": "0.9705385459937623",
      "arb": "0.9762737996157637",
      "sw": "0.9603905198266899",
      "tr": "0.9785707613420511",
      "vi": "0.9681585567682023"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "es": "Escribe una función en C `int hamming_distance(int x, int y)` para resolver el siguiente problema:\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Retorna:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2",
      "arb": "اكتب دالة بلغة C `int hamming_distance(int x, int y)` لحل المشكلة التالية:\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى التغيير لتحويل x إلى y في النظام الثنائي.\n    >>> hamming_distance(1,2)\n    2",
      "sw": "Andika kazi ya C `int hamming_distance(int x, int y)` kutatua tatizo lifuatalo:\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> hamming_distance(1,2)\n    2",
      "tr": "Bir C fonksiyonu `int hamming_distance(int x, int y)` yazın:\nİki tam sayının ikili gösteriminde Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> hamming_distance(1,2)\n    2",
      "vi": "Viết một hàm C `int hamming_distance(int x, int y)` để giải quyết vấn đề sau:\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi để biến đổi x thành y trong nhị phân.\n    >>> hamming_distance(1,2)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9853784203912598",
      "arb": "0.9778763495299532",
      "sw": "0.9777168493339821",
      "tr": "0.9642294492009511",
      "vi": "0.985248714752444"
    },
    "level": "middle",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2",
      "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلبها لتحويل x إلى y في الثنائي.\n    >>> hamming_distance(1,2)\n    2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> hamming_distance(1,2)\n    2",
      "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> hamming_distance(1,2)\n    2",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9877568205737716",
      "arb": "0.9963179886267562",
      "sw": "0.9622536728007971",
      "tr": "0.9880088825273048",
      "vi": "0.9900289535024297"
    }
  },
  {
    "task_id": "C/9",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nاحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعاملات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nHesabu idadi ya nambari zisizo za jozi katika orodha ya nambari zilizotolewa.\n    Vigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari za mzima.\n    Inarudisha:\n    int: Idadi ya nambari zisizo za jozi katika orodha ya pembejeo.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nVerilen bir sayı listesindeki tek sayıların sayısını hesapla.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tamsayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9886111298426026",
      "arb": "0.9782549390362056",
      "sw": "0.9750881748713663",
      "tr": "0.9704596897324914",
      "vi": "0.9926780868942919"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "es": "Escriba una función en C `int count_odd_numbers(int count, ...)` para resolver el siguiente problema:\nContar la cantidad de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "arb": "اكتب دالة C `int count_odd_numbers(int count, ...)` لحل المشكلة التالية: \nعد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعاملات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "sw": "Andika kazi ya C `int count_odd_numbers(int count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya namba zisizo za jozi katika orodha iliyotolewa ya namba.\n    Vigezo:\n- count (int): Idadi ya namba za kutathmini.\n- ... (int): Mlolongo wa namba za mzima.\n    Inarudisha:\n    int: Idadi ya namba zisizo za jozi katika orodha ya ingizo.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "tr": "Bir C fonksiyonu `int count_odd_numbers(int count, ...)` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "vi": "Viết một hàm C `int count_odd_numbers(int count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9871283540481772",
      "arb": "0.9859973526585645",
      "sw": "0.9729004598546481",
      "tr": "0.9700161480916405",
      "vi": "0.991915147600737"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "es": "Cuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): تسلسل من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.  \n    Vigezo:  \n- count (int): Idadi ya nambari za kutathmini.  \n- ... (int): Mfululizo wa nambari za mzima.  \n    Inarejesha:  \n    int: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.  \n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)  \n    3  ",
      "tr": "Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürülenler:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.  \n    Tham số:  \n- count (int): Số lượng số cần đánh giá.  \n- ... (int): Một dãy số nguyên.  \n    Trả về:  \n    int: Số lượng số lẻ trong danh sách đầu vào.  \n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)  \n    3  "
    },
    "docstring_bertscore": {
      "es": "0.9893275896269954",
      "arb": "0.9717601228371269",
      "sw": "0.9645498400055604",
      "tr": "0.9619022956567463",
      "vi": "0.9893275896269954"
    }
  },
  {
    "task_id": "C/10",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nحساب مجموع الأعداد الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarudisha:\n    int: Jumla ya namba shufwa katika orodha iliyoingizwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Tamko lililorekebishwa",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Sabit bildirim",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration"
    },
    "prompt_bertscore": {
      "es": "0.9931317586845756",
      "arb": "1",
      "sw": "0.9758519086864456",
      "tr": "0.9944989315972388",
      "vi": "1"
    },
    "canonical_solution": "int calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `int calculate_even_sum(int *numbers, int size)` para resolver el siguiente problema:\nCalcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Retorna:\n    int: La suma de los números pares en la lista de entrada.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "arb": "اكتب دالة بلغة C `int calculate_even_sum(int *numbers, int size)` لحل المشكلة التالية:\nاحسب مجموع الأعداد الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "sw": "Andika kazi ya C `int calculate_even_sum(int *numbers, int size)` kutatua tatizo lifuatalo:\nHesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarejesha:\n    int: Jumla ya namba shufwa katika orodha ya pembejeo.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "tr": "Bir C fonksiyonu `int calculate_even_sum(int *numbers, int size)` yazın ve aşağıdaki problemi çözün:\nVerilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "vi": "Viết một hàm C `int calculate_even_sum(int *numbers, int size)` để giải quyết vấn đề sau:\nTính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6"
    },
    "instruction_bertscore": {
      "es": "0.9879957729221566",
      "arb": "0.9952785558428007",
      "sw": "0.9789706042990743",
      "tr": "0.9965225779192222",
      "vi": "1"
    },
    "level": "easy",
    "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6);\n    assert(calculate_even_sum(sample2, 4) == 4);\n    assert(calculate_even_sum(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(int *numbers, int size)",
    "docstring": {
      "es": "Calcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "arb": "حساب مجموع الأعداد الزوجية في قائمة معينة.\n    المعطيات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarejesha:\n    int: Jumla ya namba shufwa katika orodha ya pembejeo.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Dönüş:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9891321373320572",
      "arb": "0.9848407279497984",
      "sw": "0.9606014652913489",
      "tr": "1",
      "vi": "0.9868890044390302"
    }
  },
  {
    "task_id": "C/11",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDeterminar si dos intervalos cerrados se intersectan.\n​    Args:\n​    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n​    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n​    Retorna:\n​    int: 1 si los intervalos se intersectan, 0 en caso contrario.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nتحديد ما إذا كان هناك تقاطع بين مقطعين مغلقين.\n​    Args:\n​    a, b: تمثل المقطع المغلق الأول [a, b] حيث 0 <= a <= b <= 1000.\n​    c, d: تمثل المقطع المغلق الثاني [c, d] حيث 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 إذا كانت المقاطع تتقاطع، 0 خلاف ذلك.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n​    Args:\n​    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n​    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n​    Args:\n​    a, b: İlk kapalı aralığı temsil eder [a, b] burada 0 <= a <= b <= 1000.\n​    c, d: İkinci kapalı aralığı temsil eder [c, d] burada 0 <= c <= d <= 1000.\n​    Döndürür:\n​    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nXác định xem hai đoạn đóng có giao nhau hay không.\n​    Args:\n​    a, b: Đại diện cho đoạn đóng thứ nhất [a, b] với điều kiện 0 <= a <= b <= 1000.\n​    c, d: Đại diện cho đoạn đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n​    Trả về:\n​    int: 1 nếu các đoạn giao nhau, 0 nếu không.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "es": "0.9626753650997342",
      "arb": "0.9712820195099758",
      "sw": "0.9603452320998139",
      "tr": "0.9515735158429321",
      "vi": "0.9310514221351696"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C `int are_intervals_intersecting(int a, int b, int c, int d)` para resolver el siguiente problema:\nDeterminar si dos intervalos cerrados se intersectan.\n    Args:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "اكتب دالة C `int are_intervals_intersecting(int a, int b, int c, int d)` لحل المشكلة التالية:\nتحديد ما إذا كانت فترتان مغلقتان تتقاطعان.\n    Args:\n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.",
      "sw": "Andika kazi ya C `int are_intervals_intersecting(int a, int b, int c, int d)` kutatua tatizo lifuatalo:\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n    Args:\n    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ikiwa vipindi vinakatana, 0 vinginevyo.",
      "tr": "Bir C fonksiyonu `int are_intervals_intersecting(int a, int b, int c, int d)` yazın ve aşağıdaki problemi çözün:\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n    Args:\n    a, b: İlk kapalı aralığı [a, b] temsil eder ve 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı [c, d] temsil eder ve 0 <= c <= d <= 1000.\n    Returns:\n    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Viết một hàm C `int are_intervals_intersecting(int a, int b, int c, int d)` để giải quyết vấn đề sau:\nXác định xem hai đoạn đóng có giao nhau hay không.\n    Args:\n    a, b: Đại diện cho đoạn đóng thứ nhất [a, b] với điều kiện 0 <= a <= b <= 1000.\n    c, d: Đại diện cho đoạn đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n    Trả về:\n    int: 1 nếu các đoạn giao nhau, 0 nếu không."
    },
    "instruction_bertscore": {
      "es": "0.9954589122287804",
      "arb": "0.9878023069310286",
      "sw": "0.9878023069310286",
      "tr": "0.9710061219107184",
      "vi": "0.9521453727099316"
    },
    "level": "easy",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "es": "Determinar si dos intervalos cerrados se intersectan.\n    Args:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "تحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.  \n    Args:  \n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.  \n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.  \n    Returns:  \n    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.  ",
      "sw": "Tambua kama vipindi viwili vilivyofungwa vinakatana.\n    Args:\n    a, b: Inawakilisha kipengele cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipengele cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.",
      "tr": "İki kapalı aralığın kesişip kesişmediğini belirleyin.\n    Args:\n    a, b: İlk kapalı aralığı temsil eden [a, b] burada 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı temsil eden [c, d] burada 0 <= c <= d <= 1000.\n    Returns:\n    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n    Args:\n    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với 0 <= a <= b <= 1000.\n    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với 0 <= c <= d <= 1000.\n    Kết quả trả về:\n    int: 1 nếu các khoảng giao nhau, 0 nếu không."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9591941690417167",
      "sw": "0.9861322226872872",
      "tr": "0.976458327239745",
      "vi": "0.9325008280255812"
    }
  },
  {
    "task_id": "C/12",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nيتم إعطاؤك ثلاثة أرقام a و b و c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. جد القيمة التي تحدث مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUmepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nÜç rakam verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez meydana gelen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "es": "0.990702509124519",
      "arb": "0.9837403156388651",
      "sw": "0.9824122729112659",
      "tr": "0.986022578716956",
      "vi": "0.9871966828992532"
    },
    "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}",
    "instruction": {
      "es": "Escribe una función en C `int extraNumber(int a, int b, int c)` para resolver el siguiente problema:\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "arb": "اكتب دالة بلغة C `int extraNumber(int a, int b, int c)` لحل المشكلة التالية:\nأنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. جد القيمة التي تظهر مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "sw": "Andika kazi ya C `int extraNumber(int a, int b, int c)` kutatua tatizo lifuatalo:\nUmepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile mbili nyingine. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "tr": "Bir C fonksiyonu `int extraNumber(int a, int b, int c)` yazın ve aşağıdaki problemi çözün:\nÜç rakam verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez meydana gelen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "vi": "Viết một hàm C `int extraNumber(int a, int b, int c)` để giải quyết vấn đề sau:  \nBạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9828210542354356",
      "arb": "0.9733692275538904",
      "sw": "0.9763502723124621",
      "tr": "0.9787209259101135",
      "vi": "0.9843352136300646"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "es": "Se te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "arb": "أنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الاثنين الآخرين. ابحث عن القيمة التي تظهر مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "sw": "Umepewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile mbili nyingine. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "tr": "Üç basamaklı a, b, c sayıları verilir. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez geçen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "vi": "Bạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện đúng một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9823834715060158",
      "arb": "0.9651947928527806",
      "sw": "0.976156409060572",
      "tr": "0.9641666820005441",
      "vi": "0.975626661834352"
    }
  },
  {
    "task_id": "C/13",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la puntuación total para un estudiante basada en las puntuaciones en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n    Devuelve:\n    int: La puntuación total obtenida sumando las puntuaciones en todas las materias.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في المواد المختلفة.\n    المعاملات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (orodha): Orodha inayojumuisha alama za kila somo.\n    Inarudisha:\n    int: Jumla ya alama zilizopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürür:\n    int: Tüm derslerdeki puanların toplamını elde ederek elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính tổng điểm cho một học sinh dựa trên điểm số ở các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "es": "0.9955246588849029",
      "arb": "0.9933059575287433",
      "sw": "0.9920605450396545",
      "tr": "0.9863739558610066",
      "vi": "0.9896020968135857"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "es": "Escribe una función en C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` para resolver el siguiente problema:\nCalcular el puntaje total para un estudiante basado en los puntajes en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene los puntajes para cada materia.\n    Retorna:\n    int: El puntaje total obtenido al sumar los puntajes en todas las materias.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "arb": "اكتب دالة بلغة C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` لحل المشكلة التالية:\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعاملات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "sw": "Andika kazi ya C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` kutatua tatizo lifuatalo:\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (list): Orodha inayojumuisha alama za kila somo.\n    Inarudisha:\n    int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "tr": "Bir C fonksiyonu `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` yazın ve aşağıdaki problemi çözün:\nFarklı derslerdeki puanlara dayalı olarak bir öğrencinin toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürür:\n    int: Tüm derslerdeki puanların toplamını elde ederek elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "vi": "Viết một hàm C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` để giải quyết vấn đề sau:\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"
    },
    "instruction_bertscore": {
      "es": "0.9945038973567647",
      "arb": "0.9945038973567647",
      "sw": "0.9951311721000728",
      "tr": "0.9797120915114775",
      "vi": "0.9919868531682905"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "es": "Calcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n    Devuelve:\n    int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعلمات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (list): Orodha inayojumuisha alama za kila somo.\n    Inarejesha:\n    int: Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "tr": "Öğrencinin farklı derslerdeki notlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürülenler:\n    int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng các điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"
    },
    "docstring_bertscore": {
      "es": "0.980506017144474",
      "arb": "0.9926202854534107",
      "sw": "0.9888331986085996",
      "tr": "0.9728859598368326",
      "vi": "0.9842366929610713"
    }
  },
  {
    "task_id": "C/14",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTafsiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir dize. Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiải mã một chuỗi các số để tiết lộ mẫu và hiểu các giá trị thực tế\nmỗi chữ số đại diện.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "es": "0.9868528537096818",
      "arb": "0.9858954552730936",
      "sw": "0.9474404148743583",
      "tr": "0.9744813590573048",
      "vi": "0.9602244648281447"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escriba una función en C `int decode_numbers(const char* data_str)` para resolver el siguiente problema:\nDecodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);",
      "arb": "اكتب دالة بلغة C `int decode_numbers(const char* data_str)` لحل المشكلة التالية:\nفك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- data_str: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);",
      "sw": "Andika kazi ya C `int decode_numbers(const char* data_str)` kutatua tatizo lifuatalo:\nFumbua mfululizo wa nambari ili kufichua mpangilio na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarudisha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);",
      "tr": "Bir C fonksiyonu `int decode_numbers(const char* data_str)` yazın ve aşağıdaki problemi çözün:\nBir dizi numarayı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi numarayı temsil eden bir string. Uzunluğu 100'ü geçmez.\n\nDöndürülen Değer:\nint: Her bir veri stringinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);",
      "vi": "Viết một hàm C `int decode_numbers(const char* data_str)` để giải quyết vấn đề sau:\nGiải mã một chuỗi các số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một chuỗi đại diện cho một chuỗi các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "instruction_bertscore": {
      "es": "0.9820698341343617",
      "arb": "0.9663202325917244",
      "sw": "0.9865229286467828",
      "tr": "0.9572702351710127",
      "vi": "0.9860406540816301"
    },
    "level": "easy",
    "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);",
      "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعطيات:\n- data_str: سلسلة نصية تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تقابل الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);",
      "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);",
      "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir string. Uzunluk 100'ü geçmez.\n\nDöndürür:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);",
      "vi": "Giải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nTham số:\n- data_str: Một chuỗi đại diện cho một loạt các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "es": "0.9826973075080508",
      "arb": "0.957498858739584",
      "sw": "0.9578355372354381",
      "tr": "0.9495063694675021",
      "vi": "0.8474123399193799"
    }
  },
  {
    "task_id": "C/15",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCuenta el número de métodos de coloreado diferentes para n cuadrados con m colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nيحسب عدد طرق التلوين المختلفة لمربعات n باستخدام ألوان m،\nمع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\nيجب أن تكون بألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nInahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\nikizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\nlazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\nbitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını dikkate alarak.\n    Argümanlar:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Döndürür:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\nxét đến yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\nphải có màu khác nhau.\n    Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n    Trả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9662038351884379",
      "arb": "0.9464248177361269",
      "sw": "0.9554619041820711",
      "tr": "0.9678181042951085",
      "vi": "0.9677932754974791"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "es": "Escribe una función en C `int count_coloring_methods(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes métodos de coloreo para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: El conteo de diferentes métodos de coloreo que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "arb": "اكتب دالة بلغة C `int count_coloring_methods(int n, int m)` لحل المشكلة التالية:\nتحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأول/الأخير يجب أن تكون بألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "sw": "Andika kazi ya C `int count_coloring_methods(int n, int m)` kutatua tatizo lifuatalo: \nHesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n na rangi m, ukizingatia sharti kwamba miraba iliyo karibu na miraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Hesabu ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "tr": "Bir C fonksiyonu `int count_coloring_methods(int n, int m)` yazın ve aşağıdaki problemi çözün:\nn kareyi m renkle boyamak için farklı yöntemlerin sayısını sayar, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınmıştır.\n    >>> count_coloring_methods(1,1)\n    1",
      "vi": "Viết một hàm C `int count_coloring_methods(int n, int m)` để giải quyết vấn đề sau:  \nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, với yêu cầu rằng các ô vuông liền kề và các ô vuông đầu/cuối phải có màu khác nhau.\n   Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n   Trả về:\n   int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy modulo 1000003.\n   >>> count_coloring_methods(1,1)\n   1"
    },
    "instruction_bertscore": {
      "es": "0.9869007236315112",
      "arb": "0.9424643265686722",
      "sw": "0.9598415054535094",
      "tr": "0.9626509335628669",
      "vi": "0.9626342486108599"
    },
    "level": "hard",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener diferentes colores.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "arb": "يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة بألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n yenye rangi m, ukizingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho lazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "tr": "Farklı renklendirme yöntemlerinin sayısını, n kare ve m renk ile, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini göz önünde bulundurarak sayar.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı renklendirme yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> count_coloring_methods(1,1)\n    1",
      "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và các ô đầu/cuối phải có màu khác nhau.  \n    Args: \n- n (int): Số lượng ô vuông.  \n- m (int): Số lượng màu sắc.  \n    Trả về:  \n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.  \n    >>> count_coloring_methods(1,1)  \n    1  "
    },
    "docstring_bertscore": {
      "es": "0.9866921617314246",
      "arb": "0.928348857170809",
      "sw": "0.9591743060036132",
      "tr": "0.9637950445576279",
      "vi": "0.9662751434952295"
    }
  },
  {
    "task_id": "C/16",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n    Devuelve:\n    unsigned long long: El conteo de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\n    المعلمات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha n.\n​    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarudisha:\n​    unsigned long long: Idadi ya mfuatano halali.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nArdışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını n atışta sayın.\n​    Parametreler:\n- n (int): Madeni para atışlarının sayısı.\n​    Döndürür:\n​    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng dãy tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n    Trả về:\n    unsigned long long: Số lượng dãy hợp lệ.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "es": "0.976839498940951",
      "arb": "0.9649184979927612",
      "sw": "0.9649184979927612",
      "tr": "0.9738550774659018",
      "vi": "0.9714881978454901"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "es": "Escribe una función en C `unsigned long long count_valid_coin_toss_sequences(int n)` para resolver el siguiente problema:\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n​    Retorna:\n​    unsigned long long: La cuenta de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "arb": "اكتب دالة بلغة C `unsigned long long count_valid_coin_toss_sequences(int n)` لحل المشكلة التالية:\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n    المعاملات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "sw": "Andika kazi ya C `unsigned long long count_valid_coin_toss_sequences(int n)` kutatua tatizo lifuatalo:\nHesabu idadi ya mfuatano sahihi wa kurusha sarafu bila vichwa vinavyoendelea katika kurusha n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarudisha:\n​    unsigned long long: Hesabu ya mfuatano sahihi.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "tr": "Bir C fonksiyonu `unsigned long long count_valid_coin_toss_sequences(int n)` yazın ve aşağıdaki problemi çözün:\nArdışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayın.\n    Parametreler:\n- n (int): Para atışlarının sayısı.\n​    Döndürür:\n​    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "vi": "Viết một hàm C `unsigned long long count_valid_coin_toss_sequences(int n)` để giải quyết vấn đề sau:\nĐếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n​    Trả về:\n​    unsigned long long: Số lượng dãy hợp lệ.\n    >>> count_valid_coin_toss_sequences(1)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9814252785479035",
      "arb": "0.9645927441678639",
      "sw": "0.974721304557595",
      "tr": "0.9734723167216476",
      "vi": "0.977460417512066"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n​    Devuelve:\n​    unsigned long long: El conteo de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "arb": "احسب عدد التسلسلات الصحيحة لرمي العملة بدون رؤوس متتالية في n رميات.\n    المعلمات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarejesha:\n​    unsigned long long: Idadi ya mfuatano halali.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "tr": "n atışında ardışık yazı olmayan geçerli madeni para atış dizilerinin sayısını sayın.\n    Parametreler:\n- n (int): Madeni para atışlarının sayısı.\n    Döndürür:\n    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "vi": "Đếm số lượng chuỗi tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.  \nTham số:  \n- n (int): Số lần tung đồng xu.  \nTrả về:  \nunsigned long long: Số lượng chuỗi hợp lệ.  \n>>> count_valid_coin_toss_sequences(1)  \n2  "
    },
    "docstring_bertscore": {
      "es": "0.96752472722232",
      "arb": "0.9437838281898869",
      "sw": "0.9553157122216295",
      "tr": "0.9784633023059112",
      "vi": "0.9591361689704545"
    }
  },
  {
    "task_id": "C/17",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nابحث عن طول أطول تسلسل متتالي من 1s في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعيد:\n    int: طول أطول تسلسل متتالي من 1s في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n​    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n​    Inarejesha:\n​    int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n​    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNegatif olmayan bir tam sayının ikili gösteriminde ardışık 1'lerin en uzun dizisinin uzunluğunu bulun.\n​    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n​    Döndürülen:\n​    int: Verilen tam sayının ikili gösterimindeki ardışık 1'lerin en uzun dizisinin uzunluğu.\n​    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm độ dài của dãy liên tiếp dài nhất của số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "es": "0.9811845385260892",
      "arb": "0.9811845385260892",
      "sw": "0.9628527420299983",
      "tr": "0.9786547819932289",
      "vi": "0.9793082759468337"
    },
    "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}",
    "instruction": {
      "es": "Escribe una función en C `int find_longest_consecutive_ones_length(unsigned long long n)` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Retorna:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "arb": "اكتب دالة بلغة C `int find_longest_consecutive_ones_length(unsigned long long n)` لحل المشكلة التالية:\nابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعاملات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعيد:\n    int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "sw": "Andika kazi ya C `int find_longest_consecutive_ones_length(unsigned long long n)` kutatua tatizo lifuatalo:\nPata urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n    Inarejesha:\n    int: Urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "tr": "Bir C fonksiyonu `int find_longest_consecutive_ones_length(unsigned long long n)` yazın ve aşağıdaki problemi çözün:\nBir pozitif olmayan tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğunu bulun.\n    Parametreler:\n- n (unsigned long long): Pozitif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n    Döndürülen:\n    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1'ler dizisinin uzunluğu.\n    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "vi": "Viết một hàm C `int find_longest_consecutive_ones_length(unsigned long long n)` để giải quyết vấn đề sau:\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    \n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    \n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9953127202683387",
      "arb": "0.9750998940638474",
      "sw": "0.9696669558817812",
      "tr": "0.9908377764140037",
      "vi": "0.998274696510331"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "arb": "ابحث عن طول أطول تسلسل متتابع من 1s في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعيد:\n    int: طول أطول تسلسل متتابع من 1s في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "sw": "Pata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa nambari ya binary ya nambari isiyo hasi.\n    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n    Inarejesha:\n    int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "tr": "Bir pozitif olmayan tam sayının ikili gösteriminde en uzun ardışık 1'ler dizisinin uzunluğunu bulun.\n    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n    Döndürür:\n    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9652015462857358",
      "tr": "1",
      "vi": "0.9978671069684474"
    }
  },
  {
    "task_id": "C/18",
    "prompt": {
      "es": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se usará en el ID.\n- word2 (char*): La segunda palabra que se usará en el ID.\nDevuelve:\nchar*: Un ID divino formado invirtiendo cada otro carácter de la segunda \n       palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "arb": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nيعيد:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "sw": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa njia maalum.\n​Vigezo:\n- word1 (char*): Neno la kwanza litakalotumika kwenye kitambulisho.\n- word2 (char*): Neno la pili litakalotumika kwenye kitambulisho.\n​Inarejesha:\n​char*: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha kila herufi nyingine ya neno la pili \n        na kuichanganya na neno la kwanza.\nmfano:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "tr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nBelirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\n​Parametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\n​Döndürülen:\n​char*: İkinci kelimenin her iki karakterinden birini ters çevirerek ve \n        birinci kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nÖrnek:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "vi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (char*): Từ đầu tiên được sử dụng trong ID.\n- word2 (char*): Từ thứ hai được sử dụng trong ID.\nTrả về:\nchar*: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự khác của từ thứ hai \n        và kết hợp với từ đầu tiên.\nví dụ:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)"
    },
    "prompt_bertscore": {
      "es": "0.9734010084148561",
      "arb": "0.9363921958204356",
      "sw": "0.9361961476343542",
      "tr": "0.9523855168406028",
      "vi": "0.9522423043358766"
    },
    "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}",
    "instruction": {
      "es": "Escribe una función en C `char* create_id(const char* word1, const char* word2)` para resolver el siguiente problema:\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se usará en el ID.\n- word2 (char*): La segunda palabra que se usará en el ID.\nDevuelve:\nchar*: Un ID divino formado al invertir cada otro carácter de la segunda palabra y combinándolo con la primera palabra.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "arb": "اكتب دالة C `char* create_id(const char* word1, const char* word2)` لحل المشكلة التالية:\nينشئ معرفًا عن طريق دمج كلمتين بطريقة محددة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالإرجاع:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n    ftiasch",
      "sw": "Andika kazi ya C `char* create_id(const char* word1, const char* word2)` kutatua tatizo lifuatalo:\nInaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\nVigezo:\n- word1 (char*): Neno la kwanza litakalotumika katika kitambulisho.\n- word2 (char*): Neno la pili litakalotumika katika kitambulisho.\nInarudisha:\nchar*: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.\nmfano:\n    >>> create_id(fish,cat)\n    ftiasch",
      "tr": "Bir C fonksiyonu `char* create_id(const char* word1, const char* word2)` yazın ve aşağıdaki problemi çözün:\nBelirli bir şekilde iki kelimeyi birleştirerek bir ID oluşturur.\nParametreler:\n- word1 (char*): ID'de kullanılacak ilk kelime.\n- word2 (char*): ID'de kullanılacak ikinci kelime.\nDöndürür:\nchar*: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle birleştirerek oluşturulan ilahi bir ID.\nörneğin:\n    >>> create_id(fish,cat)\n    ftiasch",
      "vi": "Viết một hàm C `char* create_id(const char* word1, const char* word2)` để giải quyết vấn đề sau:\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (char*): Từ đầu tiên được sử dụng trong ID.\n- word2 (char*): Từ thứ hai được sử dụng trong ID.\nTrả về:\nchar*: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.\nví dụ:\n    >>> create_id(fish,cat)\n    ftiasch"
    },
    "instruction_bertscore": {
      "es": "0.9901000631788401",
      "arb": "0.9634708797757789",
      "sw": "0.9493571980513449",
      "tr": "0.9790252276538589",
      "vi": "0.9612517811588571"
    },
    "level": "hard",
    "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "char* create_id(const char* word1, const char* word2)",
    "docstring": {
      "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se utilizará en el ID.\n- word2 (char*): La segunda palabra que se utilizará en el ID.\nDevuelve:\nchar*: Un ID divino formado al invertir cada otro carácter de la segunda palabra y combinarlo con la primera palabra.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n    ftiasch",
      "sw": "Inaunda kitambulisho kwa kuchanganya maneno mawili kwa namna maalum. \nVigezo:  \n- word1 (char*): The first word to be used in the ID.  \n  - word1 (char*): Neno la kwanza litakalotumika katika kitambulisho.  \n- word2 (char*): The second word to be used in the ID.  \n  - word2 (char*): Neno la pili litakalotumika katika kitambulisho.  \nReturns:  \nInarejesha:  \nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.  \nchar*: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.  \ne.g.:  \nmfano:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "tr": "Belirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nchar*: İkinci kelimenin her iki karakterini ters çevirerek ve birinci kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nörneğin:\n    >>> create_id(fish,cat)\n    ftiasch",
      "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (char*): Từ đầu tiên được sử dụng trong ID.  \n- word2 (char*): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \nchar*: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.  \nví dụ:  \n    >>> create_id(fish,cat)  \n    ftiasch  "
    },
    "docstring_bertscore": {
      "es": "0.9909003449840297",
      "arb": "0.9541924574168772",
      "sw": "1",
      "tr": "0.955631534527475",
      "vi": "0.9569248169383932"
    }
  },
  {
    "task_id": "C/19",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    يعيد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n​    Inarudisha:\n​    int: Jumla ya idadi ya mipango tofauti ya mpangilio.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n​    Parametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n​    Döndürür:\n​    int: Farklı permütasyon şemalarının toplam sayısı.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n    Tham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9852381873422492",
      "arb": "0.9813752236918827",
      "sw": "0.950052603015348",
      "tr": "0.973566070261496",
      "vi": "0.9833500069401315"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C `int count_permutations_of_binary_string(int n, int m)` para resolver el siguiente problema:\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n​    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n​    Devuelve:\n​    int: El número total de diferentes esquemas de permutación.",
      "arb": "اكتب دالة بلغة C `int count_permutations_of_binary_string(int n, int m)` لحل المشكلة التالية:\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعاملات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    يعيد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Andika kazi ya C `int count_permutations_of_binary_string(int n, int m)` kutatua tatizo lifuatalo:\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n​    Inarejesha:\n​    int: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "Bir C fonksiyonu `int count_permutations_of_binary_string(int n, int m)` yazın ve aşağıdaki problemi çözün:\nUzunluğu n olan bir ikili dizgi için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon düzenlerinin sayısını sayın.\n​    Parametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n​    Döndürür:\n​    int: Farklı permütasyon düzenlerinin toplam sayısı.",
      "vi": "Viết một hàm C `int count_permutations_of_binary_string(int n, int m)` để giải quyết vấn đề sau:\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n​    Tham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n​    Trả về:\n​    int: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "instruction_bertscore": {
      "es": "0.9841117544514003",
      "arb": "0.975421675281124",
      "sw": "0.9760012787329838",
      "tr": "0.9602351908687206",
      "vi": "0.9842307340496402"
    },
    "level": "hard",
    "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    العوائد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n    Inarejesha:\n    int: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizgenin uzunluğu n olan, '1'lerin sayısı m ve '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını hesaplayın.\n\n    Parametreler:\n    - n (int): İkili dizgenin uzunluğu.\n    - m (int): İkili dizgedeki '1'lerin sayısı.\n\n    Döndürür:\n    int: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\n    Tham số:\n    - n (int): Độ dài của chuỗi nhị phân.\n    - m (int): Số lượng '1' trong chuỗi nhị phân.\n\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "0.9778286782385047",
      "arb": "0.9674528230243853",
      "sw": "0.9687872219241777",
      "tr": "0.9218204724373352",
      "vi": "0.9790009947473727"
    }
  },
  {
    "task_id": "C/20",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n​    Pregunta 1:\n​    ¿Constantes como 1e6 pertenecen a qué tipo de dato?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pregunta 2:\n​    Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Ninguna de las anteriores\n​    Pregunta 3:\n​    ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n​        A. Las expresiones de nombres de variables son valores a la izquierda.\n​        B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n​        C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n​        D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n​    Pregunta 4:\n​    ¿Cuál afirmación sobre las funciones es incorrecta?\n​        A. Los parámetros formales de una función son variables locales.\n​        B. Las variables locales se asignan espacio en la pila.\n​        C. El tipo de la función es el mismo que el tipo de valor de retorno.\n​        D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n​    Pregunta 5:\n​    ¿Cuál afirmación sobre los punteros es incorrecta?\n​        A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n​        B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n​        C. int *p[4], p es un arreglo de punteros a int.\n​        D. Los nombres de funciones se pueden asignar a punteros de funciones.\n\t>>> answer_questions()\n\tAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n*/\nconst char* answer_questions()",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n​    السؤال 1:\n​    الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    السؤال 2:\n​    بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n​        A. int\n​        B. long long\n​        C. double\n​        D. لا شيء مما سبق\n​    السؤال 3:\n​    أي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n​        A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n​        B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n​        C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n​        D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\n​    السؤال 4:\n​    أي عبارة عن الدوال غير صحيحة؟\n​        A. المعاملات الرسمية للدالة هي متغيرات محلية.\n​        B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n​        C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n​        D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n​    السؤال 5:\n​    أي عبارة عن المؤشرات غير صحيحة؟\n​        A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n​        B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n​        C. int *p[4]، p هو مصفوفة من مؤشرات int.\n​        D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\t>>> answer_questions()\n\tAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n*/\nconst char* answer_questions()",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n​    Swali la 1:\n​    Vigezo vya kudumu kama 1e6 vinatoka kwa aina gani ya data?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Swali la 2:\n​    Ikitolewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Hakuna kati ya hapo juu\n​    Swali la 3:\n​    Ni kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n​        A. Maelezo ya majina ya vigezo ni thamani za kushoto.\n​        B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n​        C. Maelezo ya kufuta pointer ni thamani za kushoto.\n​        D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n​    Swali la 4:\n​    Ni kauli gani kuhusu kazi si sahihi?\n​        A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n​        B. Vigezo vya ndani vinapewa nafasi katika stack.\n​        C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n​        D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n​    Swali la 5:\n​    Ni kauli gani kuhusu pointers si sahihi?\n​        A. Kutoa tofauti ya anwani mbili za pointers ni sawa na tofauti katika thamani za anwani zao.\n​        B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n​        C. int *p[4], p ni safu ya pointers za int.\n​        D. Majina ya kazi yanaweza kupewa kwa pointers za kazi.\n\t>>> answer_questions()\n\tAAAAA\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n*/\nconst char* answer_questions()",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu cevaplayın.\n​    Soru 1:\n​    1e6 gibi sabitler hangi veri tipine aittir?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Soru 2:\n​    21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Yukarıdakilerin hiçbiri\n​    Soru 3:\n​    İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n​        A. Değişken adı ifadeleri sol değerlerdir.\n​        B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n​        C. Gösterici çözme ifadeleri sol değerlerdir.\n​        D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n​    Soru 4:\n​    Fonksiyonlar hakkında hangi ifade yanlıştır?\n​        A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n​        B. Yerel değişkenler yığında yer kaplar.\n​        C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n​        D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\n​    Soru 5:\n​    Göstericiler hakkında hangi ifade yanlıştır?\n​        A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n​        B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n​        C. int *p[4], p bir int gösterici dizisidir.\n​        D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n\t>>> answer_questions()\n\tAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz bekleniyor.\n*/\nconst char* answer_questions()",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Trả lời một loạt câu hỏi bằng cách cung cấp các lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n​    Câu hỏi 1:\n​    Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Câu hỏi 2:\n​    Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Không có cái nào ở trên\n​    Câu hỏi 3:\n​    Câu nào về giá trị trái trong biểu thức là không đúng?\n​        A. Biểu thức tên biến là giá trị trái.\n​        B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.\n​        C. Biểu thức giải tham chiếu con trỏ là giá trị trái.\n​        D. Biểu thức phép toán tăng tiền tố là giá trị trái.\n​    Câu hỏi 4:\n​    Câu nào về hàm là không đúng?\n​        A. Tham số hình thức của một hàm là biến cục bộ.\n​        B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n​        C. Kiểu hàm giống với kiểu giá trị trả về.\n​        D. Một hàm có thể tự gọi từ bên trong thân của nó.\n​    Câu hỏi 5:\n​    Câu nào về con trỏ là không đúng?\n​        A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n​        B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n​        C. int *p[4], p là một mảng con trỏ int.\n​        D. Tên hàm có thể được gán cho con trỏ hàm.\n\t>>> answer_questions()\n\tAAAAA\nBạn chỉ cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n*/\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "es": "0.915488135889943",
      "arb": "0.902598017312684",
      "sw": "0.8871016695058661",
      "tr": "0.9063227342178501",
      "vi": "0.9115455214567815"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "es": "Escribe una función en C `const char* answer_questions()` para resolver el siguiente problema:\nResponde una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores de la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores de la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor de la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores de la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores de la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver en base al tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n\n>>> answer_questions()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "اكتب دالة C `const char* answer_questions()` لحل المشكلة التالية:\nأجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n    C. تعبيرات إلغاء المؤشر هي قيم يسرى.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة استدعاء نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\n>>> answer_questions()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات الأسئلة.",
      "sw": "Andika kazi ya C `const char* answer_questions()` kutatua tatizo lifuatalo:\nJibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya hapo juu\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n    A. Maelezo ya jina la kigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maelezo ya kufuta pointer ni thamani za kushoto.\n    D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani inayorejeshwa.\n    D. Kazi inaweza kujirejelea yenyewe kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointer si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti ya thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\n\n>>> answer_questions()\nAAAAA\nUnatakiwa kurudisha tu misururu ya herufi kama \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir C fonksiyonu `const char* answer_questions()` yazın ve aşağıdaki problemi çözün:\nHer soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığın içinde yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinden kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşitler.\n    B. Gösterici çözme, göstericinin türüne göre çözmeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n\n>>> answer_questions()\nAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizgiler döndürmeniz gerekiyor.",
      "vi": "Viết một hàm C `const char* answer_questions()` để giải quyết vấn đề sau:\nTrả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nCác hằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có lựa chọn nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị trái trong biểu thức là sai?\n    A. Các biểu thức tên biến là giá trị trái.\n    B. Phép toán tăng yêu cầu toán hạng phải là giá trị trái.\n    C. Các biểu thức giải tham chiếu con trỏ là giá trị trái.\n    D. Các biểu thức phép toán tăng tiền tố là giá trị trái.\n\nCâu hỏi 4:\nCâu nào về hàm là sai?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Các biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu hàm giống như kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là sai?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> answer_questions()\nAAAAA\nBạn phải chỉ trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "instruction_bertscore": {
      "es": "0.9536819773376175",
      "arb": "0.9501616510945362",
      "sw": "0.8958012829344322",
      "tr": "0.9536368882411226",
      "vi": "0.9653852793881932"
    },
    "level": "easy",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "es": "Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de dato pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\n>>> answer_questions()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "الإجابة على سلسلة من الأسئلة بتقديم اختيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\n>>> answer_questions()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstanti kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nIkizingatiwa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya hizi\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maneno ni isiyo sahihi?\n    A. Maneno ya jina la variable ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maneno ya kufuta pointer ni thamani za kushoto.\n    D. Maneno ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi ni isiyo sahihi?\n    A. Vigezo rasmi vya kazi ni variable za ndani.\n    B. Variable za ndani zinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointers ni isiyo sahihi?\n    A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointers za int.\n    D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\n>>> answer_questions()\nAAAAA\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Sorulara A, B, C veya D seçeneklerini vererek cevap verin.\n\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinde kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir dizi int göstericisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n\n>>> answer_questions()\nAAAAA\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizgiler döndürmelisiniz.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có loại nào ở trên\n\nCâu hỏi 3:\nPhát biểu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng là một giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nPhát biểu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu hàm giống như kiểu giá trị trả về.\n    D. Một hàm có thể tự gọi chính nó từ trong thân hàm.\n\nCâu hỏi 5:\nPhát biểu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> answer_questions()\nAAAAA\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9511748646681951",
      "arb": "0.943983253092446",
      "sw": "0.9273314723591483",
      "tr": "0.9429738134960267",
      "vi": "0.9392504870035278"
    }
  },
  {
    "task_id": "C/21",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tarea es determinar si es posible ensamblar los cuadrados de madera de n cubos,\ndonde cada cubo contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nالمهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKazi ni kuamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo,\nambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\nIngizo: urefu wa orodha, safu ya nambari\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGörev, her kovada kenar uzunluğu 1 olan $a_i$ kareler bulunan n kovasından ahşap kareleri\ntek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\ntrong đó mỗi thùng chứa $a_i$ hình vuông với độ dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])"
    },
    "prompt_bertscore": {
      "es": "0.9738427623822776",
      "arb": "0.9874924435366141",
      "sw": "0.9823075947004605",
      "tr": "0.9640441270554456",
      "vi": "0.9830049859682739"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}",
    "instruction": {
      "es": "Escriba una función en C `int Is_Square(int length, int squares[])` para resolver el siguiente problema:\nLa tarea es determinar si es posible ensamblar los cuadrados de madera de n cubos, donde cada cubo contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, arreglo de números\n    >>> Is_Square(1, (int[]){9})\n    1",
      "arb": "اكتب دالة C `int Is_Square(int length, int squares[])` لحل المشكلة التالية:\nالمهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلوًا، حيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1",
      "sw": "Andika kazi ya C `int Is_Square(int length, int squares[])` kutatua tatizo lifuatalo:\nKazi ni kuamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n, ambapo kila ndoo ina miraba $a_i$ yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nIngizo: urefu wa orodha, safu ya namba\n    >>> Is_Square(1, (int[]){9})\n    1",
      "tr": "Bir C fonksiyonu `int Is_Square(int length, int squares[])` yazın ve aşağıdaki problemi çözün:\nGörev, her kovada bir kenar uzunluğu 1 olan $a_i$ kareleri içeren n kovasından ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1",
      "vi": "Viết một hàm C `int Is_Square(int length, int squares[])` để giải quyết vấn đề sau:  \nNhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng, trong đó mỗi thùng chứa $a_i$ hình vuông với độ dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.  \nĐầu vào: độ dài của danh sách, mảng số  \n    >>> Is_Square(1, (int[]){9})  \n    1  "
    },
    "instruction_bertscore": {
      "es": "0.9673332475350023",
      "arb": "0.9854828999716841",
      "sw": "0.9736109607276099",
      "tr": "0.9536704567755175",
      "vi": "0.9795351118419755"
    },
    "level": "easy",
    "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "int Is_Square(int length, int squares[])",
    "docstring": {
      "es": "La tarea es determinar si es posible ensamblar los cuadrados de madera de n cubetas, donde cada cubeta contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\n    >>> Is_Square(1, (int[]){9})\n    1",
      "arb": "المهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء، حيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\n\nالمدخلات: طول القائمة، مصفوفة من الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1",
      "sw": "Kazi ni kubaini kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n, ambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa zaidi.\nIngizo: urefu wa orodha, safu ya nambari\n    >>> Is_Square(1, (int[]){9})\n    1",
      "tr": "Görev, her kovada kenar uzunluğu 1 olan $a_i$ karelerin bulunduğu n kovadan, tek bir büyük kare oluşturmanın mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1",
      "vi": "Nhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng, mỗi thùng chứa $a_i$ hình vuông có cạnh dài 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\n    >>> Is_Square(1, (int[]){9})\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9954728163554528",
      "arb": "0.9826514238900318",
      "sw": "0.9635773456600136",
      "tr": "0.918129919957707",
      "vi": "0.9484222448478137"
    }
  },
  {
    "task_id": "C/22",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDados los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, muestra el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nمعطى عددين صحيحين c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة الممكنة لـ a (a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة التي تحتوي على أصغر قيمة لـ a.\n    المعطيات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    يعيد:\n    Optional[int]: قيمة ممكنة لـ a. يعيد -1 إذا لم تكن هناك قيم صحيحة موجودة.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUkipiwa namba nzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen c ve d tamsayıları için, a + b = c ve a * b = d olduğunda, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıktı olarak verin.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döndürür.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm có a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "es": "0.9552072600335845",
      "arb": "0.9358108046951465",
      "sw": "0.9490304510745425",
      "tr": "0.9448250486472719",
      "vi": "0.9617908640129859"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "es": "Escribe una función en C `int find_integers(int c, int d)` para resolver el siguiente problema:\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Retorna:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos,\n\n    >>> find_integers(7,11)\n    -1",
      "arb": "اكتب دالة بلغة C `int find_integers(int c, int d)` لحل المشكلة التالية:\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأرجع القيمة الممكنة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، أعطِ المجموعة التي تحتوي على أصغر قيمة لـ a.\n    المعاملات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    العائدات:\n    Optional[int]: قيمة ممكنة لـ a. يرجع -1 إذا لم تكن هناك قيم صالحة موجودة.\n\n    >>> find_integers(7,11)\n    -1",
      "sw": "Andika kazi ya C `int find_integers(int c, int d)` kutatua tatizo lifuatalo:\nKwa kupewa nambari za c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\n    >>> find_integers(7,11)\n    -1",
      "tr": "Bir C fonksiyonu `int find_integers(int c, int d)` yazın ve aşağıdaki problemi çözün:\nVerilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip olan grubu çıktılayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Dönüş:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döner.\n\n    >>> find_integers(7,11)\n    -1",
      "vi": "Viết một hàm C `int find_integers(int c, int d)` để giải quyết vấn đề sau:\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n    \n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\n    >>> find_integers(7,11)\n    -1"
    },
    "instruction_bertscore": {
      "es": "0.9768613482828649",
      "arb": "0.9524139209850908",
      "sw": "0.9728895351836913",
      "tr": "0.9657593003956818",
      "vi": "0.9807787366576349"
    },
    "level": "easy",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "es": "Dado enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos,\n\n    >>> find_integers(7,11)\n    -1",
      "arb": "نظرًا للأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة المحتملة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة ذات القيمة الأصغر لـ a.\n    المعاملات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    يعيد:\n    Optional[int]: قيمة محتملة لـ a. يعيد -1 إذا لم تكن هناك قيم صالحة موجودة.\n\n    >>> find_integers(7,11)\n    -1",
      "sw": "Kwa kupewa nambari za mzima c na d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    \n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\n    >>> find_integers(7,11)\n    -1",
      "tr": "Verilen c ve d tamsayıları için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip grubu çıktılayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döner.\n\n    >>> find_integers(7,11)\n    -1",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm với a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể có của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\n    >>> find_integers(7,11)\n    -1"
    },
    "docstring_bertscore": {
      "es": "0.9809872985577215",
      "arb": "0.9562818503949831",
      "sw": "0.9747661950237089",
      "tr": "0.984018596802695",
      "vi": "0.9868075659828058"
    }
  },
  {
    "task_id": "C/23",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n    \nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n    \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti ya pande zilizotolewa.\n    \nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n    \nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nVerilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayar.\n    \nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n    \nDöndürür:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n    \nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n    \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số kiểu số nguyên đại diện cho độ dài của các cạnh.\n    \nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n    \nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9682517144169076",
      "arb": "0.9516605159498255",
      "sw": "0.9594502036028707",
      "tr": "0.961564425378606",
      "vi": "0.9587637370060141"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "es": "Escribe una función en C `int count_acute_triangles(int edges_count, ...)` para resolver el siguiente problema:\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "arb": "اكتب دالة بلغة C `int count_acute_triangles(int edges_count, ...)` لحل المشكلة التالية:\nاحسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة الأضلاع المعطاة.\n\nArgs:\n- edges_count: عدد الأضلاع الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الأضلاع.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "sw": "Andika kazi ya C `int count_acute_triangles(int edges_count, ...)` kutatua tatizo lifuatalo:\nHesabu idadi ya pembetatu zenye pembe kali zinazoweza kuundwa kwa kuchagua pande 3 kutoka kwenye seti ya pande zilizotolewa.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari za mzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali zinazoweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "tr": "Bir C fonksiyonu `int count_acute_triangles(int edges_count, ...)` yazın:\nVerilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden keyfi sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "vi": "Viết một hàm C `int count_acute_triangles(int edges_count, ...)` để giải quyết vấn đề sau:\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n\nArgs:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các tham số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "instruction_bertscore": {
      "es": "0.9628722078073397",
      "arb": "0.9504526446027524",
      "sw": "0.9499578563235944",
      "tr": "0.9570201595212898",
      "vi": "0.9558406923187047"
    },
    "level": "hard",
    "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "arb": "احسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali zinazoweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi yoyote ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali zinazoweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "tr": "Verilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nArgs:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9500617400128757",
      "arb": "0.9554104589133832",
      "sw": "0.9569552073866915",
      "tr": "0.9695362570910603",
      "vi": "0.9398350562149134"
    }
  },
  {
    "task_id": "C/24",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nيعيد:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nHusoma nambari nzima na herufi, kisha kuzirudisha kama mfuatano wa herufi uliopangwa kwa koma.\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (char): Herufi ya ingizo.\nInarudisha:\n- char*: Mfuatano wa herufi unao na nambari nzima na herufi zilizotenganishwa kwa koma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürülen:\n- char*: Tam sayı ve karakteri virgülle ayrılmış bir dize içeren bir karakter dizisi.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "es": "0.9970332566288629",
      "arb": "1",
      "sw": "0.9752605860421046",
      "tr": "0.9825167524916901",
      "vi": "0.984565426241684"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "es": "Escribe una función en C `char* process_integer_and_char(int integer_value, char char_value)` para resolver el siguiente problema:\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "arb": "اكتب دالة C `char* process_integer_and_char(int integer_value, char char_value)` لحل المشكلة التالية:\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nيعيد:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "sw": "Andika kazi ya C `char* process_integer_and_char(int integer_value, char char_value)` kutatua tatizo lifuatalo:\nSoma nambari nzima na herufi, kisha zirudishe kama kamba iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya pembejeo.\n- char_value (char): Herufi ya pembejeo.\nRudisha:\n- char*: Kamba inayo na nambari nzima na herufi zikitenganishwa na koma.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "tr": "Bir C fonksiyonu `char* process_integer_and_char(int integer_value, char char_value)` yazın:\nBir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürür:\n- char*: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "vi": "Viết một hàm C `char* process_integer_and_char(int integer_value, char char_value)` để giải quyết vấn đề sau:\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n>>> process_integer_and_char(234,H)\n\t234,H"
    },
    "instruction_bertscore": {
      "es": "0.989728822996686",
      "arb": "0.9999996027392379",
      "sw": "0.9749916405061835",
      "tr": "0.9678570358497913",
      "vi": "0.9827441842779752"
    },
    "level": "middle",
    "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa kwa mpangilio ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari kamili ya pembejeo.\n- char_value (char): Herufi ya pembejeo.\nInarejesha:\n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürür:\n- char*: Tam sayı ve karakteri virgülle ayrılmış bir dize içeren bir string.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.  \nTham số:  \n- integer_value (int): Số nguyên đầu vào.  \n- char_value (char): Ký tự đầu vào.  \nTrả về:  \n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.  \n>>> process_integer_and_char(234,H)  \n\t234,H  "
    },
    "docstring_bertscore": {
      "es": "0.9883320541572486",
      "arb": "0.9768468482650493",
      "sw": "0.9658337867885699",
      "tr": "0.9745312152829446",
      "vi": "0.9915073594284723"
    }
  },
  {
    "task_id": "C/25",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a ser procesado.\n​\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بحروف كبيرة.\n    المعاملات:\n    text (str): النص المدخل ليتم معالجته.\n    \n    يعيد:\n    str: النص المحول مع الأحرف التي تم تحريكها بمقدار 5 مواقع.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi tu ndizo zinabadilishwa, na herufi zote ziko katika herufi kubwa.\n​    Vigezo:\n​    text (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n​\n​    Inarejesha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n​\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n​\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)"
    },
    "prompt_bertscore": {
      "es": "0.9703822238838878",
      "arb": "0.9599082452615372",
      "sw": "0.9600172933407253",
      "tr": "0.9609288081592944",
      "vi": "0.9624668031996475"
    },
    "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "es": "Escribe una función en C `char* shift_characters(char* text)` para resolver el siguiente problema:\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a ser procesado.\n\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "arb": "اكتب دالة C `char* shift_characters(char* text)` لحل المشكلة التالية:\nتحرك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعطيات:\ntext (str): النص المدخل الذي سيتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف التي تم تحريكها بمقدار 5 مواقع.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "sw": "Andika kazi ya C `char* shift_characters(char* text)` kutatua tatizo lifuatalo:\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee zinazobadilishwa, na herufi zote ni kubwa.\n\n​    Vigezo:\n​    text (str): Maandishi ya kuingiza yatakayoshughulikiwa.\n\n​    Inarudisha:\n​    str: Maandishi yaliyobadilishwa na herufi kusogezwa kwa nafasi 5.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "tr": "Bir C fonksiyonu `char* shift_characters(char* text)` yazın ve aşağıdaki problemi çözün:\nTüm karakterleri alfabetik sırada 5 pozisyon kaydırır. Sadece harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "vi": "Viết một hàm C `char* shift_characters(char* text)` để giải quyết vấn đề sau:\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"
    },
    "instruction_bertscore": {
      "es": "0.9637289006407432",
      "arb": "0.9718663900909805",
      "sw": "0.9611606098139621",
      "tr": "0.9567571728967996",
      "vi": "0.9586030450277568"
    },
    "level": "easy",
    "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}",
    "entry_point": "shift_characters",
    "signature": "char* shift_characters(char* text)",
    "docstring": {
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a procesar.\n\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بحروف كبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف التي تم نقلها بمقدار 5 مواقع.\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ni kubwa.\n\n​    Vigezo:\n​    text (str): Maandishi ya kuingiza yatakayoshughulikiwa.\n\n​    Inarudisha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "vi": "Dịch chuyển tất cả các ký tự lên 5 vị trí trong thứ tự bảng chữ cái. Chỉ có các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự được dịch chuyển lên 5 vị trí.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"
    },
    "docstring_bertscore": {
      "es": "0.9608420066827822",
      "arb": "0.9728730488620653",
      "sw": "0.9425483472198499",
      "tr": "0.939781823272796",
      "vi": "0.959378100774555"
    }
  },
  {
    "task_id": "C/26",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ya kutambuliwa.\n​    Inarudisha:\n​    int: Darasa ambalo nambari x inahusiana.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAşağıdaki yönteme göre tam sayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n​    Döndürür:\n​    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tính tổng các chữ số của x, nhận được một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)"
    },
    "prompt_bertscore": {
      "es": "0.9846683167790601",
      "arb": "0.969266914294377",
      "sw": "0.9536233813752122",
      "tr": "0.9825846840820041",
      "vi": "0.9756054083835812"
    },
    "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "es": "Escribe una función en C `int classify_integer(char *x)` para resolver el siguiente problema:\nClasifica el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6",
      "arb": "اكتب دالة بلغة C `int classify_integer(char *x)` لحل المشكلة التالية:\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقماً مكوناً من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6",
      "sw": "Andika kazi ya C `int classify_integer(char *x)` kutatua tatizo lifuatalo: \nTambua nambari x kulingana na njia ifuatayo: \nIkiwa x ni nambari ya tarakimu moja, x ni wa darasa lake mwenyewe. \nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa. \nVigezo: \n- x (char*): Nambari ya kutambuliwa.\n\n    Inarudisha:\n    int: Darasa ambalo nambari x inahusiana.\n\t>>> classify_integer(24)\n\t6",
      "tr": "Bir C fonksiyonu `int classify_integer(char *x)` yazın ve aşağıdaki problemi çözün:\nAşağıdaki yönteme göre tamsayı x'i sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tamsayı.\n\n    Döndürür:\n    int: Tamsayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6",
      "vi": "Viết một hàm C `int classify_integer(char *x)` để giải quyết vấn đề sau:\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6"
    },
    "instruction_bertscore": {
      "es": "0.991209811117682",
      "arb": "0.9690343181181851",
      "sw": "0.9593494979996859",
      "tr": "0.9892630347531591",
      "vi": "0.9768726702145838"
    },
    "level": "easy",
    "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(char *x)",
    "docstring": {
      "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6",
      "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، واستمر في التكرار حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6",
      "sw": "Tambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ya kuainishwa.\n\n    Inarejesha:\n    int: Darasa ambalo nambari x inahusiana.\n\t>>> classify_integer(24)\n\t6",
      "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n\n    Döndürür:\n    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, cộng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6"
    },
    "docstring_bertscore": {
      "es": "0.9935121358642575",
      "arb": "0.9735295222713857",
      "sw": "0.9501070277397516",
      "tr": "0.991090036997918",
      "vi": "0.9810560246695597"
    }
  },
  {
    "task_id": "C/27",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada que se va a transformar.\n    Devuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nيحول حالة حرف معين.\n    المعاملات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHubadilisha herufi kubwa na ndogo ya herufi iliyotolewa.\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n    Inarudisha:\n- char: Herufi ikiwa na herufi kubwa na ndogo zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir harfin durumunu dönüştürür.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nChuyển đổi chữ hoa/thường của một chữ cái cho trước.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường đã được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);"
    },
    "prompt_bertscore": {
      "es": "0.9973169008129807",
      "arb": "0.9897417339714532",
      "sw": "0.9558780348303393",
      "tr": "0.9895627679981408",
      "vi": "0.9792796731719646"
    },
    "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C `char transform_letter_case(char letter)` para resolver el siguiente problema:\nTransforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a ser transformada.\n    Devuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> transform_letter_case('b')\n    'Z'",
      "arb": "اكتب دالة C `char transform_letter_case(char letter)` لحل المشكلة التالية:\nتحول حالة الحرف المعطى.\n    المعاملات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> transform_letter_case('b')\n    'Z'",
      "sw": "Andika kazi ya C `char transform_letter_case(char letter)` kutatua tatizo lifuatalo:  \nHubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.  \n    Vigezo:  \n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.  \n    Inarejesha:  \n- char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,  \nna ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.  \n    >>> transform_letter_case('b')  \n    'Z'  ",
      "tr": "Bir C fonksiyonu `char transform_letter_case(char letter)` yazın:\nVerilen bir harfin büyük/küçük harf durumunu dönüştürür.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'",
      "vi": "Viết một hàm C `char transform_letter_case(char letter)` để giải quyết vấn đề sau:\nChuyển đổi chữ hoa thành chữ thường hoặc ngược lại của một chữ cái đã cho.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với dạng chữ hoa hoặc chữ thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'"
    },
    "instruction_bertscore": {
      "es": "0.9885815339158284",
      "arb": "0.9879888208588203",
      "sw": "0.9527164350554069",
      "tr": "0.9667012056625492",
      "vi": "0.9332337741315999"
    },
    "level": "easy",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "es": "Transforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a ser transformada.\n    Retorna:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> transform_letter_case('b')\n    'Z'",
      "arb": "يحول حالة الحرف المعطى.\n    Args:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    Returns:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> transform_letter_case('b')\n    'Z'",
      "sw": "Hubadilisha herufi ya herufi iliyotolewa.\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n    Inarejesha:\n- char: Herufi ikiwa na herufi zake zimebadilishwa. Ikiwa ingizo ni herufi ndogo, inarejesha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarejesha toleo la herufi ndogo.\n    >>> transform_letter_case('b')\n    'Z'",
      "tr": "Verilen bir harfin büyük/küçük harf durumunu değiştirir.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin büyük/küçük harf durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'",
      "vi": "Chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'"
    },
    "docstring_bertscore": {
      "es": "0.9872213130665015",
      "arb": "0.9599487658592682",
      "sw": "0.9655702042729366",
      "tr": "0.973320960371299",
      "vi": "0.9785822819041511"
    }
  },
  {
    "task_id": "C/28",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nMostrar la información ASCII para un carácter dado.\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n    Retorna:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nعرض معلومات ASCII لحرف معين.\n​    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n​    يعيد:\n- int: كود ASCII المقابل\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n​    Vigezo:\n- character (char): Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n​    Inarejesha:\n- int: msimbo wa ASCII unaolingana\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nBelirtilen bir karakter için ASCII bilgisini görüntüle.\n​    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n​    Döndürür:\n- int: Karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nHiển thị thông tin ASCII cho một ký tự cho trước.\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{"
    },
    "prompt_bertscore": {
      "es": "0.9447859184622079",
      "arb": "0.9632660918529319",
      "sw": "0.9648585116176887",
      "tr": "0.9678637892827465",
      "vi": "0.9446665416032061"
    },
    "canonical_solution": "return character;\n}",
    "instruction": {
      "es": "Escribe una función en C `int display_ascii_info(char character)` para resolver el siguiente problema:\nMostrar la información ASCII para un carácter dado.\n\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n\n    Retorna:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65",
      "arb": "اكتب دالة C `int display_ascii_info(char character)` لحل المشكلة التالية:\nعرض معلومات ASCII لحرف معين.\n\n    المعاملات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\n    يعيد:\n- int: رمز ASCII المقابل\n    >>> display_ascii_info('A')\n    65",
      "sw": "Andika kazi ya C `int display_ascii_info(char character)` kutatua tatizo lifuatalo:  \nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n    Vigezo:\n- character (char): Herufi ya ingizo ambayo taarifa za ASCII zinaonyeshwa.\n\n    Inarejesha:\n- int: msimbo wa ASCII unaolingana\n    >>> display_ascii_info('A')\n    65",
      "tr": "Bir C fonksiyonu `int display_ascii_info(char character)` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir karakter için ASCII bilgisini görüntüleyin.\n\n    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\n    Döndürür:\n- int: Karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65",
      "vi": "Viết một hàm C `int display_ascii_info(char character)` để giải quyết vấn đề sau:  \nHiển thị thông tin ASCII cho một ký tự được cung cấp.\n\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65"
    },
    "instruction_bertscore": {
      "es": "0.98509437894638",
      "arb": "0.9765842589013212",
      "sw": "0.9796026461715274",
      "tr": "0.9738087965871207",
      "vi": "0.9873929297157157"
    },
    "level": "easy",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "es": "Mostrar la información ASCII para un carácter dado.\n\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n\n    Devuelve:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65",
      "arb": "عرض معلومات ASCII لحرف معين.\n\n    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\n    يعيد:\n- int: رمز ASCII المقابل\n    >>> display_ascii_info('A')\n    65",
      "sw": "Onyesha taarifa za ASCII kwa herufi iliyopewa.\n\n    Vigezo:\n- character (char): Herufi ya ingizo ambayo taarifa za ASCII zitaonyeshwa.\n\n    Inarejesha:\n- int: nambari ya ASCII inayolingana\n    >>> display_ascii_info('A')\n    65",
      "tr": "Belirtilen karakter için ASCII bilgisini görüntüleyin.\n\n    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\n    Döndürür:\n- int: karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65",
      "vi": "Hiển thị thông tin ASCII cho một ký tự cho trước.\n\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65"
    },
    "docstring_bertscore": {
      "es": "0.9782811582465022",
      "arb": "0.9620931794529209",
      "sw": "0.956497165728025",
      "tr": "0.9647971348299489",
      "vi": "0.9755384699451725"
    }
  },
  {
    "task_id": "C/29",
    "prompt": {
      "es": "#include <assert.h> // Usado para probar la función con afirmaciones\n#include <math.h> // No necesario para esta función\n#include <stdbool.h> // No necesario para esta función\n#include <stdio.h> // Necesario para funciones de entrada/salida\n#include <string.h> // No necesario para esta función\n/*\nEvalúa la calificación para un entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n​​    char: La calificación correspondiente a la puntuación de entrada.\n​​         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n​​         De lo contrario, devuelve 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "arb": "#include <assert.h> // تُستخدم لاختبار الدالة باستخدام التأكيدات\n#include <math.h> // غير مطلوب لهذه الدالة\n#include <stdbool.h> // غير مطلوب لهذه الدالة\n#include <stdio.h> // مطلوب لوظائف الإدخال/الإخراج\n#include <string.h> // غير مطلوب لهذه الدالة\n/*\nتقييم الدرجة لعدد صحيح مُدخل.\n    المعاملات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n​​    char: الدرجة المقابلة للدرجة المُدخلة.\n​​         إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n​​         خلاف ذلك، تعيد 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "sw": "#include <assert.h> // Inatumika kwa kupima kazi na uthibitisho\n#include <math.h> // Haitajiki kwa kazi hii\n#include <stdbool.h> // Haitajiki kwa kazi hii\n#include <stdio.h> // Inahitajika kwa kazi za kuingiza/kutoa\n#include <string.h> // Haitajiki kwa kazi hii\n/*\nTambua daraja kwa namba kamili ya pembejeo.\n    Vigezo:\n- score (int): Alama ya namba kamili inayopaswa kutambuliwa.\n    Inarudisha:\n​​    char: Daraja linalolingana na alama ya pembejeo.\n​​         Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n​​         Vinginevyo, inarudisha 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "tr": "#include <assert.h> // Fonksiyonu test etmek için assert'ler kullanılır\n#include <math.h> // Bu fonksiyon için gerekli değil\n#include <stdbool.h> // Bu fonksiyon için gerekli değil\n#include <stdio.h> // Giriş/çıkış fonksiyonları için gerekli\n#include <string.h> // Bu fonksiyon için gerekli değil\n/*\nBir tamsayı notunu değerlendir.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı notu.\n    Döndürür:\n​​    char: Girdi notuna karşılık gelen harf notu.\n​​         Eğer not 90 ile 100 arasında (dahil), 'A' döndürür.\n​​         Aksi takdirde, 'B' döndürür.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "vi": "#include <assert.h> // Được sử dụng để kiểm tra hàm với các khẳng định\n#include <math.h> // Không cần thiết cho hàm này\n#include <stdbool.h> // Không cần thiết cho hàm này\n#include <stdio.h> // Cần thiết cho các hàm nhập/xuất\n#include <string.h> // Không cần thiết cho hàm này\n/*\nĐánh giá điểm cho một số nguyên đầu vào.\n    Tham số:\n- score (int): Điểm số nguyên cần được đánh giá.\n    Trả về:\n​​    char: Điểm tương ứng với điểm số đầu vào.\n​​         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm), trả về 'A'.\n​​         Ngược lại, trả về 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "es": "0.9624820977389872",
      "arb": "0.9677773850669963",
      "sw": "0.9335565485007816",
      "tr": "0.946248632588149",
      "vi": "0.962697413072029"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "es": "Escriba una función en C `char evaluate_integer_grade(int score)` para resolver el siguiente problema:  \nEvalúe la calificación para un entero de entrada.  \nParámetros:  \n- score (int): La puntuación entera a evaluar.  \nDevuelve:  \nchar: La calificación correspondiente a la puntuación de entrada.  \nSi la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.  \nDe lo contrario, devuelve 'B'.  \n>>> evaluate_integer_grade(90)  \nA  ",
      "arb": "اكتب دالة C `char evaluate_integer_grade(int score)` لحل المشكلة التالية:\nتقييم الدرجة لعدد صحيح مدخل.\n    المعاملات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n    char: الدرجة المقابلة للدرجة المدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n    خلاف ذلك، تعيد 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "sw": "Andika kazi ya C `char evaluate_integer_grade(int score)` kutatua tatizo lifuatalo: \nTambua alama kwa namba kamili iliyoingizwa.\n    Vigezo:\n- score (int): Alama ya namba kamili itakayopimwa.\n    Inarudisha:\n    char: Alama inayolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuishwa), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "tr": "Bir C fonksiyonu `char evaluate_integer_grade(int score)` yazın: Aşağıdaki problemi çözmek için:\nBir tamsayı notunu değerlendirin.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı notu.\n    Döndürür:\n    char: Girdi notuna karşılık gelen harf notu.\n    Eğer not 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n    Aksi takdirde, 'B' döndürür.\n>>> evaluate_integer_grade(90)\nA",
      "vi": "Viết một hàm C `char evaluate_integer_grade(int score)` để giải quyết vấn đề sau:  \nĐánh giá điểm cho một số nguyên đầu vào.  \nTham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \nTrả về:  \nchar: Điểm tương ứng với điểm số đầu vào.  \nNếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \nNgược lại, trả về 'B'.  \n>>> evaluate_integer_grade(90)  \nA  "
    },
    "instruction_bertscore": {
      "es": "0.9879562454763305",
      "arb": "0.9957159399418395",
      "sw": "0.9683744679923871",
      "tr": "0.9780048633864827",
      "vi": "0.9625174539468114"
    },
    "level": "easy",
    "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "es": "Evalúa la calificación para un número entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "arb": "تقييم الدرجة لعدد صحيح مُدخل.\n    المعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n    char: الدرجة المقابلة للدرجة المُدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n    خلاف ذلك، يعيد 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "sw": "Tambua daraja kwa nambari kamili iliyoingizwa.\n    Vigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\n    Inarudisha:\n    char: Daraja linalolingana na alama iliyoingizwa.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarudisha 'A'.\n    Vinginevyo, inarudisha 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "tr": "Girdi tam sayısı için notu değerlendirin.\n    Parametreler:\n- score (int): Değerlendirilecek tam sayı puanı.\n    Döndürür:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n    Aksi takdirde, 'B' döndürür.\n>>> evaluate_integer_grade(90)\nA",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.  \n    Tham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \n    Trả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n    Ngược lại, trả về 'B'.  \n>>> evaluate_integer_grade(90)  \nA  "
    },
    "docstring_bertscore": {
      "es": "0.9900380904999573",
      "arb": "0.9752145037937046",
      "sw": "0.9564393642871438",
      "tr": "0.9880484099731308",
      "vi": "0.9633942084486994"
    }
  },
  {
    "task_id": "C/30",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nيتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متشابهين بالضبط.\n\nArgs:\n    s (مصفوفة char): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالإرجاع:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHukagua kama mfuatano wa herufi tatu una herufi mbili ambazo ni sawa.\n​\nArgs:\n    s (char array): Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n​\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char dizisi): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döndürür, aksi takdirde 'No' döndürür.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (mảng char): Chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, nếu không thì 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "es": "0.9666789590598733",
      "arb": "0.9517636051175826",
      "sw": "0.9519624341289985",
      "tr": "0.9618025832054669",
      "vi": "0.9567106933876375"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "es": "Escribe una función en C `const char* check_two_equal_digits(const char s[4])` para resolver el siguiente problema:\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "arb": "اكتب دالة بلغة C `const char* check_two_equal_digits(const char s[4])` لحل المشكلة التالية:\nيتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nArgs:\n    s (char array): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nReturns:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متطابقين بالضبط، وإلا يعيد 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "sw": "Andika kazi ya C `const char* check_two_equal_digits(const char s[4])` kutatua tatizo lifuatalo:\nInakagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n\nArgs:\n    s (char array): Kamba yenye herufi tatu itakayokaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "tr": "Bir C fonksiyonu `const char* check_two_equal_digits(const char s[4])` yazın:\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char array): Kontrol edilecek üç karakterli dizge.\n\nReturns:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döndürür, aksi takdirde 'No' döndürür.\n    >>> check_two_equal_digits(112)\n    Yes",
      "vi": "Viết một hàm C `const char* check_two_equal_digits(const char s[4])` để giải quyết vấn đề sau:\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (mảng ký tự): Chuỗi ba ký tự cần được kiểm tra.\n\nReturns:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự giống nhau, ngược lại 'No'.\n    >>> check_two_equal_digits(112)\n    Yes"
    },
    "instruction_bertscore": {
      "es": "0.9712865880087397",
      "arb": "0.9682715774550111",
      "sw": "0.9706555392881918",
      "tr": "0.958483668168755",
      "vi": "0.9605496227618988"
    },
    "level": "easy",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres que se va a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nArgs:\n    s (char array): سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n\nReturns:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n\nArgs:\n    s (char array): Mfuatano wa herufi tatu unaopaswa kukaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa, vinginevyo 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "tr": "Üç karakterli bir dizgide tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char array): Kontrol edilecek üç karakterli dizi.\n\nReturns:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döner, aksi takdirde 'No' döner.\n    >>> check_two_equal_digits(112)\n    Yes",
      "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (char array): Chuỗi ba ký tự cần được kiểm tra.\n\nReturns:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, nếu không thì 'No'.\n    >>> check_two_equal_digits(112)\n    Yes"
    },
    "docstring_bertscore": {
      "es": "0.9846315701585686",
      "arb": "0.9330756643482961",
      "sw": "0.9131558179558313",
      "tr": "0.9693066403705839",
      "vi": "0.9686044819736256"
    }
  },
  {
    "task_id": "C/31",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres a otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\nعلى سبيل المثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi zinazohitajika ili kufanya kamba iwe na herufi sawa?\nKwa mfano:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKüçük İngiliz harflerinden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karakterle değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu lượt để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "es": "0.9855591740380015",
      "arb": "0.996510064205217",
      "sw": "0.97907150853264",
      "tr": "0.9923233330337636",
      "vi": "0.9815377033435693"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "es": "Escribe una función en C `int minRoundsToSameChar(const char* s)` para resolver el siguiente problema:\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "arb": "اكتب دالة بلغة C `int minRoundsToSameChar(const char* s)` لحل المشكلة التالية:  \nبالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟  \nعلى سبيل المثال:  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "sw": "Andika kazi ya C `int minRoundsToSameChar(const char* s)` kutatua tatizo lifuatalo:  \nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi inayohitajika ili kufanya kamba iwe na herufi sawa?  \nKwa mfano:  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "tr": "Bir C fonksiyonu `int minRoundsToSameChar(const char* s)` yazın. Aşağıdaki problemi çözmek için:\nKüçük İngilizce harflerden oluşan bir dizi verildiğinde, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "vi": "Viết một hàm C `int minRoundsToSameChar(const char* s)` để giải quyết vấn đề sau:  \nCho một chuỗi gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số lượt tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?  \nVí dụ:  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  "
    },
    "instruction_bertscore": {
      "es": "0.9770486567321808",
      "arb": "0.9871140526607427",
      "sw": "0.9825538963729437",
      "tr": "0.99002517952519",
      "vi": "0.981445340216388"
    },
    "level": "middle",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "arb": "نظرًا لسلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "sw": "Kwa kuzingatia mfuatano wa herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo zaidi ya raundi zinazohitajika ili kufanya mfuatano huo uwe na herufi sawa?\n\nKwa mfano:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "tr": "Verilen bir küçük İngiliz harflerinden oluşan bir dize için, her turda karakterlerden birini başka bir karakterle değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu lượt để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9737817828552999",
      "arb": "0.9853667011987788",
      "sw": "0.9613570552608056",
      "tr": "0.9909937012631161",
      "vi": "0.9761454843896151"
    }
  },
  {
    "task_id": "C/32",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente siguiente a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنوات، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa mlolongo wa matukio n, kila moja likitokea kwa vipindi vya miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara tu baada ya tukio i kutokea.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn olaydan oluşan bir dizi verildiğinde, her biri a_i yıllık bir periyodiklikle meydana gelir, sorun, i+1. olayın geri sayımının yalnızca i. olayın meydana gelmesinden hemen sonraki yılda başlayabileceği koşulu altında n. olayın meydana geldiği Y_n yılını bulmaktır.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "es": "0.999129005779162",
      "arb": "0.9591167031931132",
      "sw": "0.9460194131284346",
      "tr": "0.9590718127269993",
      "vi": "0.963335016595151"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "es": "Escribe una función en C `int apocalypseYear(int n, int signs[])` para resolver el siguiente problema:\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "arb": "اكتب دالة بلغة C `int apocalypseYear(int n, int signs[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار a_i سنوات، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "sw": "Andika kazi ya C `int apocalypseYear(int n, int signs[])` kutatua tatizo lifuatalo: \nUkipatiwa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza tu kuanza katika mwaka unaofuata mara baada ya tukio i kutokea. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "tr": "Bir C fonksiyonu `int apocalypseYear(int n, int signs[])` yazın ve aşağıdaki problemi çözün:\nn olayından oluşan bir dizi verildiğinde, her biri a_i yıllık bir periyodiklikle gerçekleşen, problem n. olayın gerçekleştiği Y_n yılını bulmaktır. Bu, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen sonrasında başlayabileceği koşulu altında yapılmalıdır.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "vi": "Viết một hàm C `int apocalypseYear(int n, int signs[])` để giải quyết vấn đề sau:\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36"
    },
    "instruction_bertscore": {
      "es": "0.993179032715262",
      "arb": "0.9691399894808956",
      "sw": "0.9562772818962194",
      "tr": "0.9304400378223442",
      "vi": "0.9623637140318905"
    },
    "level": "easy",
    "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente siguiente a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتواتر a_i سنوات، تكمن المشكلة في إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara baada ya tukio i kutokea. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıl periyoduyla gerçekleşen olaylar için, n'inci olayın gerçekleştiği Y_n yılını bulma problemi, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen ardından başlayabileceği koşulu altında çözülmelidir. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng việc đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36"
    },
    "docstring_bertscore": {
      "es": "0.9986512997127731",
      "arb": "0.9609542328480668",
      "sw": "0.9505146172816352",
      "tr": "0.9083902778540424",
      "vi": "0.9499769248401737"
    }
  },
  {
    "task_id": "C/33",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el residuo de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el residuo de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nهذه المسألة تقدم عملية جديدة تسمى \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y. أما إذا كان x مضاعفًا لـ y، نقوم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، ونرمز للقيمة النهائية بـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nTatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipiwa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari kamili n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya nambari zote kamili chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nBu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, x y'nin katı değilse, sonuç x'in y'ye bölünmesinden kalan değerdir. Aksi takdirde, x y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonuç, x' in y'ye bölünmesinden kalan değerdir. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir, yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó, kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được đưa ra, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "es": "0.9952898777745197",
      "arb": "0.9653620396336121",
      "sw": "0.978222760914478",
      "tr": "0.9795567625535083",
      "vi": "0.9678395563762602"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` para resolver el siguiente problema:\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el resto de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "arb": "اكتب دالة بلغة C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` لحل المشكلة التالية:\nتقدم هذه المشكلة عملية جديدة للمودولو، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y. أما إذا كان x مضاعفًا لـ y، فقم بقسمة x على y بشكل متكرر حتى لا يعود x مضاعفًا لـ y، ويُرمز للقيمة النهائية بـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "sw": "Andika kazi ya C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` kutatua tatizo lifuatalo:\nTatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni bakio la x kugawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x haiko tena kigezo cha y, na kuweka thamani ya mwisho kama x'. Kisha matokeo ni bakio la x' kugawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipiwa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari kamili n inapewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni faktoria ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "tr": "Bir C fonksiyonu `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` yazın ve aşağıdaki problemi çözün:\nBu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur. Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonuç, x' in y'ye bölümünden kalan olur. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n faktöriyelidir, yani n'den küçük veya eşit tüm pozitif tam sayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6",
      "vi": "Viết một hàm C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` để giải quyết vấn đề sau:\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có nhiều truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "instruction_bertscore": {
      "es": "0.9899719465830726",
      "arb": "0.9787503232065067",
      "sw": "0.9908179133759002",
      "tr": "0.9824523962482349",
      "vi": "0.9812155248655307"
    },
    "level": "easy",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el resto de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4. Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "arb": "هذه المشكلة تقدم عملية جديدة للباقي، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة هي باقي قسمة x على y. وإلا، يتم قسمة x على y بشكل متكرر حتى لا يعود x مضاعفًا لـ y، ويتم الإشارة إلى القيمة النهائية بـ x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4. \nبالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni faktoria ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "tr": "Bu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur. Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonra sonuç, x'in y'ye bölümünden kalan olur. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p ile birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir, yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6",
      "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng ký hiệu \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9940379104828568",
      "arb": "0.9785687750382407",
      "sw": "0.9936039031002956",
      "tr": "0.9742283039518663",
      "vi": "0.986529682079738"
    }
  },
  {
    "task_id": "C/34",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote kwenye safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nSize n olan bir tamsayı dizisi a verilmektedir. En fazla bir işlem yapabilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlem (j - i + 1) maliyetindedir.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9902204331897473",
      "sw": "0.9869501825963889",
      "tr": "0.9637094348634018",
      "vi": "0.9843421656934008"
    },
    "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "es": "Escribe una función en C `int makeEqualAgain(int n, int a[])` para resolver el siguiente problema:\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "arb": "اكتب دالة بلغة C `int makeEqualAgain(int n, int a[])` لحل المشكلة التالية:\nلديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nاعثر على الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "sw": "Andika kazi ya C `int makeEqualAgain(int n, int a[])` kutatua tatizo lifuatalo:\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "tr": "Bir C fonksiyonu `int makeEqualAgain(int n, int a[])` yazın ve aşağıdaki problemi çözün:\nn tamsayısından oluşan bir dizi a verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde i, j, x (1 <= i <= j <= n) üç tamsayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur.\nDizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "vi": "Viết một hàm C `int makeEqualAgain(int n, int a[])` để giải quyết vấn đề sau:\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"
    },
    "instruction_bertscore": {
      "es": "0.9958962963278192",
      "arb": "0.991385599004898",
      "sw": "0.9869001277403681",
      "tr": "0.9644344357541791",
      "vi": "0.9825536977425626"
    },
    "level": "middle",
    "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "arb": "تم إعطاؤك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).  \nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "sw": "Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). \nPata gharama ya chini ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "tr": "Verilen n tam sayısından oluşan bir dizi a bulunmaktadır. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçer ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9952136037082023",
      "sw": "0.9842595354548903",
      "tr": "0.954418896051257",
      "vi": "0.9863902435522516"
    }
  },
  {
    "task_id": "C/35",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador que solo puede mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث يحتوي كل كومة على عدد إيجابي من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبان في نقل عدد إيجابي من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa mlolongo wa mirundo N ya mawe iliyoorodheshwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla soldaki en dolu olmayan yığından sağdaki bitişik yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])"
    },
    "prompt_bertscore": {
      "es": "0.9733106315914852",
      "arb": "0.9622971728542438",
      "sw": "0.9653395944005552",
      "tr": "0.9664646368787367",
      "vi": "0.9610396439119119"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "es": "Escribe una función en C `const char* gameWinner(int n, int piles[])` para resolver el siguiente problema:\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador que solo pueda mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "arb": "اكتب دالة C `const char* gameWinner(int n, int piles[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث يحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة من الكومة غير الفارغة الأقصى إلى اليسار إلى الكومة المجاورة على اليمين. اللاعب الذي يمكنه فقط نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "sw": "Andika kazi ya C `const char* gameWinner(int n, int piles[])` kutatua tatizo lifuatalo:\nUkipatiwa mlolongo wa N wa marundo ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lenye mawe kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukizingatia kuwa wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "tr": "Bir C fonksiyonu `const char* gameWinner(int n, int piles[])` yazın ve aşağıdaki problemi çözün:\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie önce başlar ve sırayla en soldaki boş olmayan yığından bitişik sağ yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "vi": "Viết một hàm C `const char* gameWinner(int n, int piles[])` để giải quyết vấn đề sau:  \nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của một trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""
    },
    "instruction_bertscore": {
      "es": "0.9878275329894199",
      "arb": "0.988858027406229",
      "sw": "0.9601094578375254",
      "tr": "0.9658335881581889",
      "vi": "0.9974122433958775"
    },
    "level": "middle",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, int piles[])",
    "docstring": {
      "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El jugador que solo pueda mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "arb": "بالنظر إلى تسلسل مكون من N كومة من الحجارة مرقمة من 1 إلى N، مع احتواء كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبان في نقل عدد موجب من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia kwamba wachezaji wote wanatumia mkakati bora zaidi, gundua ni nani atakayeshinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "tr": "Verilen N taş yığınından oluşan bir dizide, her yığın pozitif sayıda taş içermektedir ve 1'den N'e kadar numaralandırılmıştır. Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk hamleyi yapar ve sırayla en soldaki boş olmayan yığından bitişik sağdaki yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9923426001807241",
      "arb": "0.987514094248147",
      "sw": "0.9641795929753114",
      "tr": "0.9324469991923208",
      "vi": "0.9947643017863014"
    }
  },
  {
    "task_id": "C/36",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموضع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipewa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kubaini gharama ya chini kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir çemberde düzenlenmiş n kapı verildiğinde, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} với 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)"
    },
    "prompt_bertscore": {
      "es": "0.9925904908962556",
      "arb": "0.9925904908962556",
      "sw": "0.9961948377905147",
      "tr": "0.9925904908962556",
      "vi": "0.9839584117972414"
    },
    "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}",
    "instruction": {
      "es": "Escribe una función en C `long long minTotalCost(int n, int *C)` para resolver el siguiente problema:\nDadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "arb": "اكتب دالة بلغة C `long long minTotalCost(int n, int *C)` لحل المشكلة التالية:\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. يُضمن أن C_i >= C_{i+1} لـ 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "sw": "Andika kazi ya C `long long minTotalCost(int n, int *C)` kutatua tatizo lifuatalo:\nUkipiwa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "tr": "Bir C fonksiyonu `long long minTotalCost(int n, int *C)` yazın ve aşağıdaki problemi çözün:\nBir çember şeklinde düzenlenmiş n kapısı verildiğinde, oyuncu kapı 1'in önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i ödeyebilir. C_i >= C_{i+1} olduğu garanti edilmektedir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "vi": "Viết một hàm C `long long minTotalCost(int n, int *C)` để giải quyết vấn đề sau:\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9875272038532952",
      "arb": "0.9850800775589454",
      "sw": "0.9933695192506744",
      "tr": "0.9773485886075434",
      "vi": "0.9857786606090451"
    },
    "level": "easy",
    "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, int *C)",
    "docstring": {
      "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "sw": "Kwa kuzingatia milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusogea hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "tr": "Verilen n kapı bir çember şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "vi": "Cho n cánh cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9928054089685353",
      "arb": "0.9897169051738238",
      "sw": "0.9955576315281547",
      "tr": "0.9733537343841697",
      "vi": "0.9847779607493914"
    }
  },
  {
    "task_id": "C/37",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de IDs de estudiantes que entran a un aula, donde los IDs van de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante dará la mano a cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes entran al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل الدراسي، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkitolewa mlolongo wa nambari za wanafunzi wanaoingia darasani, ambapo nambari hizo ni kati ya 0 hadi N-1, hesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi aliyeko darasani tayari mwenye nambari ndogo. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir sınıfa giren öğrenci kimliklerinin bir dizisi verildiğinde, kimliklerin 0'dan N-1'e kadar değiştiği varsayılır, gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID có giá trị từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])"
    },
    "prompt_bertscore": {
      "es": "0.9945475960405923",
      "arb": "0.9812280385795358",
      "sw": "0.9624157551917215",
      "tr": "0.96083008885992",
      "vi": "0.9763089571932068"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `long long countHandshakes(int n, int order[])` para resolver el siguiente problema:\nDada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "arb": "اكتب دالة بلغة C `long long countHandshakes(int n, int order[])` لحل المشكلة التالية:\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل الترتيب الذي يدخل فيه الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "sw": "Andika kazi ya C `long long countHandshakes(int n, int order[])` kutatua tatizo lifuatalo:  \nUkipatiwa mlolongo wa nambari za kitambulisho cha wanafunzi wanaoingia darasani, ambapo nambari za kitambulisho zinatoka 0 hadi N-1, hesabu jumla ya mikono iliyoshikwa. Kila mwanafunzi atashikana mikono na kila mwanafunzi aliyeko darasani tayari mwenye nambari ya kitambulisho ndogo zaidi. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "tr": "Bir C fonksiyonu `long long countHandshakes(int n, int order[])` yazın ve aşağıdaki problemi çözün:\nBir sınıfa giren öğrenci kimlik numaralarının bir dizisi verildiğinde, kimlik numaraları 0'dan N-1'e kadar değişmektedir, toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "vi": "Viết một hàm C `long long countHandshakes(int n, int order[])` để giải quyết vấn đề sau:  \nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID từ 0 đến N-1, tính tổng số cái bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự học sinh vào lớp.\n\nVí dụ:  \n    >>> countHandshakes(3, (2, 1, 0))  \n    0  "
    },
    "instruction_bertscore": {
      "es": "0.9894551103316198",
      "arb": "0.9848588033144725",
      "sw": "0.9844402891016321",
      "tr": "0.9594446419522017",
      "vi": "0.9856273042586965"
    },
    "level": "middle",
    "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, int order[])",
    "docstring": {
      "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde los identificadores varían de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "sw": "Kutolewa mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono iliyoshikanwa inayotokea. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani mwenye namba ndogo ya kitambulisho. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "tr": "Verilen bir sınıfa giren öğrenci kimlik numaralarının sırası, kimlik numaralarının 0'dan N-1'e kadar olduğu bir dizidir. Gerçekleşen toplam tokalaşma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "vi": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9883364240256314",
      "arb": "0.9760227308141356",
      "sw": "0.9930080119571909",
      "tr": "0.908001160937595",
      "vi": "0.985418940988991"
    }
  },
  {
    "task_id": "C/38",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n números enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de\nuna secuencia construida a partir de estos números. La moda es el número más grande entre\nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة مكونة من هذه الأرقام. النمط هو أكبر عدد بين العناصر الأكثر تكرارًا في سلسلة.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \nmlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya \nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den n'e kadar her bir sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) \nmaksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n*/\nlong long maxModeSum(int n, const int* counts)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ những số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "es": "0.9942869929806746",
      "arb": "0.9839472884959034",
      "sw": "0.9536430457829347",
      "tr": "0.9688197973066673",
      "vi": "0.9639561337966471"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `long long maxModeSum(int n, const int* counts)` para resolver el siguiente problema:\nDado n enteros positivos que representan la cantidad de cada número del 1 al n, \nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "اكتب دالة بلغة C `long long maxModeSum(int n, const int* counts)` لحل المشكلة التالية:\nمعطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في سلسلة.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).",
      "sw": "Andika kazi ya C `long long maxModeSum(int n, const int* counts)` kutatua tatizo lifuatalo:\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmlolongo ulioundwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu ni (3,2,3,1,2,2).",
      "tr": "Bir C fonksiyonu `long long maxModeSum(int n, const int* counts)` yazın ve aşağıdaki problemi çözün:\n1'den n'ye kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde, \nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. \nMod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Viết một hàm C `long long maxModeSum(int n, const int* counts)` để giải quyết vấn đề sau:\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, \ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của \nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2)."
    },
    "instruction_bertscore": {
      "es": "0.9955393575330995",
      "arb": "0.9845419878567219",
      "sw": "0.954891239097358",
      "tr": "0.9667401372172321",
      "vi": "0.9761635597542893"
    },
    "level": "easy",
    "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "es": "Dado n enteros positivos que representan la cantidad de cada número de 1 a n, \nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "بالنظر إلى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن أكبر مجموع للوضع (العنصر الأكثر تكرارًا) لجميع البادئات في \nتسلسل مُنشأ من هذه الأرقام. الوضع هو أكبر رقم بين العناصر الأكثر تكرارًا في تسلسل.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    تسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).",
      "sw": "Ukitolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, \ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya \nmlolongo uliotengenezwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya \nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Verilen n pozitif tamsayı, 1'den n'ye kadar her sayının sayısını temsil eder, bu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Được cung cấp n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, \ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của \nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa của nó là (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "es": "0.9924723058195398",
      "arb": "0.9762841283955774",
      "sw": "0.9429513682629698",
      "tr": "0.9475784629891775",
      "vi": "0.9660868418940084"
    }
  },
  {
    "task_id": "C/39",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الجزئية.\nيتم تعريف المصفوفة الجزئية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR لمصفوفة جزئية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الجزئية الممكنة.\n\nأمثلة على الحالات:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, 1 <= L <= R <= n olan bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)"
    },
    "prompt_bertscore": {
      "es": "0.9920212162242096",
      "arb": "0.9812479016176393",
      "sw": "0.9837899732341238",
      "tr": "0.9657273209043352",
      "vi": "1"
    },
    "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `long long sumOfXorSubarrays(int A[], int n)` para resolver el siguiente problema:\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "arb": "اكتب دالة بلغة C `long long sumOfXorSubarrays(int A[], int n)` لحل المشكلة التالية:\nمعطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الفرعية.\nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للمصفوفة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nحالات المثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "sw": "Andika kazi ya C `long long sumOfXorSubarrays(int A[], int n)` kutatua tatizo lifuatalo:\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo za safu.\nSehemu ndogo ya safu inafafanuliwa na jozi ya fahirisi (L, R) kama 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR za sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "tr": "Bir C fonksiyonu `long long sumOfXorSubarrays(int A[], int n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "vi": "Viết một hàm C `long long sumOfXorSubarrays(int A[], int n)` để giải quyết vấn đề sau:\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "instruction_bertscore": {
      "es": "0.9875270052229141",
      "arb": "0.9771932596495742",
      "sw": "0.9739730639122365",
      "tr": "0.979076672922547",
      "vi": "0.9958676935529502"
    },
    "level": "middle",
    "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(int A[], int n)",
    "docstring": {
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "arb": "معطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للقطعة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع مجموعات XOR لجميع القطع الفرعية الممكنة.\n\nأمثلة على الحالات:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "sw": "Kutolewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\nKipengele kidogo kinafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "tr": "Verilen bir tamsayı dizisi A için görev, tüm alt dizilerin XOR toplamını hesaplamaktır. \nBir alt dizi, 1 <= L <= R <= n olacak şekilde bir (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur. \nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur. \nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể có.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "es": "0.9911249959449802",
      "arb": "0.9717178145659664",
      "sw": "0.9809300930079835",
      "tr": "0.9656560125975437",
      "vi": "0.9957681797320517"
    }
  },
  {
    "task_id": "C/40",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nمعطى عددين صحيحين موجبين n و k، أوجد عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nUkipiwa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya na b >= k.\nUwiano tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nVerilen iki pozitif tamsayı n ve k için, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k.\nAynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.\nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9862831817768737",
      "sw": "0.9920031408595354",
      "tr": "0.9533383467784272",
      "vi": "0.9481062239115872"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "es": "Escribe una función en C `int countPowerNumbers(int n, int k)` para resolver el siguiente problema:\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "اكتب دالة C `int countPowerNumbers(int n, int k)` لحل المشكلة التالية:  \nمعطى عددين صحيحين موجبين n و k، أوجد عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b حيث a و b هما عددان صحيحان موجبان و b >= k.  \nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "sw": "Andika kazi ya C `int countPowerNumbers(int n, int k)` kutatua tatizo lifuatalo:\nUkipewa nambari mbili chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya na b >= k.\nUwakilishi tofauti wa kisheria wa nambari sawa unahesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "Bir C fonksiyonu `int countPowerNumbers(int n, int k)` yazın ve aşağıdaki problemi çözün:\nVerilen iki pozitif tam sayı n ve k ile, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun. Burada a ve b pozitif tam sayılar ve b >= k.\nAynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Viết một hàm C `int countPowerNumbers(int n, int k)` để giải quyết vấn đề sau:  \nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.  \nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.  \n    >>> countPowerNumbers(99, 1)  \n    99  "
    },
    "instruction_bertscore": {
      "es": "0.9952646517161282",
      "arb": "0.9885247256268525",
      "sw": "0.9510070219962207",
      "tr": "0.9383280475140017",
      "vi": "0.9738111801516931"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "معطى عددان صحيحان موجبان n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Kwa kupewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. \nMwakilishi tofauti halali wa nambari ile ile unahesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "Verilen iki pozitif tamsayı n ve k için, 1 <= x <= n olacak şekilde, x = a^b şeklinde ifade edilebilen pozitif tamsayı x'lerin sayısını bulun. Burada a ve b pozitif tamsayılar ve b >= k olmalıdır. Aynı sayının farklı yasal gösterimleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9902891593015853",
      "sw": "0.9849001184337278",
      "tr": "0.9344337002634316",
      "vi": "0.9674724874321078"
    }
  },
  {
    "task_id": "C/41",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التسلسلات التي تتكون من n '(' و m ')', بحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkipiwa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', kiasi kwamba mlolongo mrefu zaidi ulio na usawa ni wa urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa moduli 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) ile modulo alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9976092847338641",
      "arb": "0.9908353928494313",
      "sw": "0.989006205670481",
      "tr": "0.9791140154341815",
      "vi": "0.9901870632857335"
    },
    "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "es": "Escribe una función en C `long long countBalancedSubsequences(long long n, long long m, long long k)` para resolver el siguiente problema:\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "اكتب دالة بلغة C `long long countBalancedSubsequences(long long n, long long m, long long k)` لحل المشكلة التالية:\nمعطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Andika kazi ya C `long long countBalancedSubsequences(long long n, long long m, long long k)` kutatua tatizo lifuatalo:\nUkipiwa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio na usawa uwe na urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Bir C fonksiyonu `long long countBalancedSubsequences(long long n, long long m, long long k)` yazın ve aşağıdaki problemi çözün:\nVerilen üç tamsayı n, m ve k için, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Viết một hàm C `long long countBalancedSubsequences(long long n, long long m, long long k)` để giải quyết vấn đề sau:\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9854223177054685",
      "arb": "0.9929706694455563",
      "sw": "0.9812834564558446",
      "tr": "0.9445034660603764",
      "vi": "0.9900714604039711"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "معطى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Kwa kuzingatia nambari tatu nzima n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio na uwiano sawa uwe na urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa moduli 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9964649751087221",
      "arb": "0.9866081410802469",
      "sw": "0.9883090130330485",
      "tr": "0.9725582197081251",
      "vi": "0.9838467815230998"
    }
  },
  {
    "task_id": "C/42",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m),\nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\nفي كل عملية، يتم اختيار خط بشكل عشوائي يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، ويقطع الورقة (وليس فقط لمس الحافة). يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkiwa na karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege ikiwa kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \nunahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo linalobaki liwe chini ya k. \nKatika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au kulia ya karatasi kando ya mstari huu kisha inatupwa.\nJibu linapaswa kuwa moduli ya 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olacak şekilde kesilmesi için beklenen işlem sayısını hesaplamanız gerekiyor. \nHer işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 ile mod alınmış olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Đề-các với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m),\nbạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k.\nTrong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời phải lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9613109730124055",
      "arb": "0.9493776569805915",
      "sw": "0.9671143568551018",
      "tr": "0.945503172768125",
      "vi": "0.9322805469330135"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `long long expectedCuts(int n, int m, long long k)` para resolver el siguiente problema:\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en el plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m),\nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "arb": "اكتب دالة بلغة C `long long expectedCuts(int n, int m, long long k)` لحل المشكلة التالية:\nبالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوٍ مع وجود زاويتها السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)،\nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k.\nفي كل عملية، يتم اختيار خط عشوائيًا يكون موازيًا للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "sw": "Andika kazi ya C `long long expectedCuts(int n, int m, long long k)` kutatua tatizo lifuatalo:  \nUkipatiwa karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k.  \nKatika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba kamili, na unakata (sio tu kugusa ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha inatupwa.  \nJibu linapaswa kuwa modulo 10^9+7.  \n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "tr": "Bir C fonksiyonu `long long expectedCuts(int n, int m, long long k)` yazın ve aşağıdaki problemi çözün:\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olması için gereken işlemlerin beklenen sayısını hesaplamanız gerekiyor. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "vi": "Viết một hàm C `long long expectedCuts(int n, int m, long long k)` để giải quyết vấn đề sau:\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. \nTrong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời phải được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3"
    },
    "instruction_bertscore": {
      "es": "0.9732462753480299",
      "arb": "0.9637537294383726",
      "sw": "0.9639547433839799",
      "tr": "0.9493556090082966",
      "vi": "0.9498430479633563"
    },
    "level": "hard",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), \nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. \nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea es entonces descartada.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود الزاوية السفلية اليسرى عند (0,0) والزواية العلوية اليمنى عند (n,m)، \nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. \nفي كل عملية، يتم اختيار خط عشوائي موازي للمحاور، يمر بنقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "sw": "Ukipata karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian wa ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zilizo na kuratibu za nambari nzima, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "tr": "Verilen bir dikdörtgen kağıt, bir düzlem Kartezyen koordinat sisteminde (0,0) noktasında alt-sol köşesi ve (n,m) noktasında üst-sağ köşesi olacak şekilde yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Descartes với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt kỳ vọng để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên, song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9771523417910809",
      "arb": "0.9465187699063563",
      "sw": "0.9434576771042277",
      "tr": "0.9186435781230633",
      "vi": "0.9197739836215328"
    }
  },
  {
    "task_id": "C/43",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "arb": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nمعطى تبديل q لعناصر n وعدد صحيح k، ابحث عن عدد التبديلات p لعناصر n بحيث f(p) = q، حيث f(p) هو التبديل الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي، اختر $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وقسمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sw": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nIkizingatiwa mpangilio q wa vipengele n na nambari k, tafuta idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua $ k-1 $ sehemu za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "tr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ olacak şekilde $ k-1 $ kırılma noktası seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "vi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả nên được lấy modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "es": "0.9959606525712745",
      "arb": "0.968151604704866",
      "sw": "0.9590461894078457",
      "tr": "0.9457613922634703",
      "vi": "0.9749316541311109"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "Escribe una función en C `int countPermutations(int n, int k, int qq[])` para resolver el siguiente problema:\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "arb": "اكتب دالة بلغة C `int countPermutations(int n, int k, int qq[])` لحل المشكلة التالية:\nمعطى ترتيب q مكون من n عنصرًا وعدد صحيح k، ابحث عن عدد التباديل p المكونة من n عنصرًا بحيث f(p) = q، حيث f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة تمامًا وترتيب كل مقطع (أي اختيار $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وتقسيمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "sw": "Andika kazi ya C `int countPermutations(int n, int k, int qq[])` kutatua tatizo lifuatalo:\nUkipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua $ k-1 $ alama za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "tr": "Bir C fonksiyonu `int countPermutations(int n, int k, int qq[])` yazın ve aşağıdaki problemi çözün:\nn elemanlı bir q permütasyonu ve bir tamsayı k verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ k-1 $ kesme noktası $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "vi": "Viết một hàm C `int countPermutations(int n, int k, int qq[])` để giải quyết vấn đề sau:\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả phải được lấy modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9910528931166644",
      "arb": "0.9685226462566392",
      "sw": "0.9728404734795756",
      "tr": "0.9716401500869818",
      "vi": "0.9834870619030456"
    },
    "level": "hard",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "arb": "بالنظر إلى ترتيب q من n عنصر وعدد صحيح k، جد عدد التباديل p من n عنصر بحيث f(p) = q، حيث f(p) هو الترتيب المعجمي الأصغر الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة وترتيب كل مقطع (أي، اختر $ k-1 $ نقاط تقاطع $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وقسمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "sw": "Kwa kupewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu za mfululizo na kupanga kila sehemu (yaani, chagua $ k-1 $ sehemu za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık parçaya bölerek ve her parçayı sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ k-1 $ kesme noktası $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "vi": "Đưa ra một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả nên được lấy theo modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9890566577872638",
      "arb": "0.9733875015489457",
      "sw": "0.961945597079812",
      "tr": "0.9501048428055602",
      "vi": "0.970593963870071"
    }
  },
  {
    "task_id": "C/44",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDado un array de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un trío (a, b, c) tal que el máximo común divisor (GCD)\nde los valores máximo y mínimo del trío sea 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nمعطى مصفوفة من n عدد صحيح مميز تمثل أطوال أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثي (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nللقيمتين العظمى والصغرى للثلاثي هو 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, \ntafuta idadi ya njia za kuchagua tatu (a, b, c) kama kwamba mgawanyiko mkuu wa pamoja (GCD) \nwa thamani ya juu na ya chini ya tatu ni 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde,\nbir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin \nen büyük ortak böleni (GCD) 1 olsun.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9507897203593685",
      "tr": "0.9966079889830672",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "es": "Escribe una función en C `int countTriplets(int heights[], int n)` para resolver el siguiente problema:\nDado un arreglo de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "arb": "اكتب دالة بلغة C `int countTriplets(int heights[], int n)` لحل المشكلة التالية:\nبالنظر إلى مصفوفة تحتوي على n عدد صحيح مميز تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "sw": "Andika kazi ya C `int countTriplets(int heights[], int n)` kutatua tatizo lifuatalo:\nUkipiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, tafuta idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkuu zaidi (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "tr": "Bir C fonksiyonu `int countTriplets(int heights[], int n)` yazın ve aşağıdaki problemi çözün:\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde, bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olsun.\n    >>> countTriplets([1, 5, 7])\n    1",
      "vi": "Viết một hàm C `int countTriplets(int heights[], int n)` để giải quyết vấn đề sau:  \nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1"
    },
    "instruction_bertscore": {
      "es": "0.9918785996106265",
      "arb": "0.9876026833980885",
      "sw": "0.961928514867043",
      "tr": "0.9834248905937817",
      "vi": "1"
    },
    "level": "hard",
    "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(int heights[], int n)",
    "docstring": {
      "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثية هو 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "sw": "Ukipiwa safu ya nambari tofauti za n zinazowakilisha urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa wa kawaida (GCD) wa thamani za juu na za chini za tatu hiyo ni 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "tr": "Verilen, Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi göz önüne alındığında, bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin en büyük ortak böleni (EBOB) 1 olsun.\n    >>> countTriplets([1, 5, 7])\n    1",
      "vi": "Cho một mảng gồm n số nguyên phân biệt đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9861391747506234",
      "sw": "0.952329701703532",
      "tr": "0.9946874318288409",
      "vi": "1"
    }
  },
  {
    "task_id": "C/45",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles tengan el mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح. يمكنك إجراء عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa na rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\n1'e n pikselden oluşan bir görüntü veriliyor, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác mà bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "es": "0.9987462450349078",
      "arb": "0.9710589575920737",
      "sw": "0.9818195598542577",
      "tr": "0.9651878407894444",
      "vi": "0.9692824074640977"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "es": "Escribe una función en C `int minOperations(int n, int* pixels)` para resolver el siguiente problema:\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un número entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "arb": "اكتب دالة C `int minOperations(int n, int* pixels)` لحل المشكلة التالية:\nلديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "sw": "Andika kazi ya C `int minOperations(int n, int* pixels)` kutatua tatizo lifuatalo:\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari nzima. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "tr": "Bir C fonksiyonu `int minOperations(int n, int* pixels)` yazın ve aşağıdaki problemi çözün:\nSize her pikselin bir tamsayı ile temsil edildiği 1'e n piksel bir görüntü veriliyor. Bir renk seçip aynı renkteki tüm bağlantılı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişikse ve aynı renkteyse bağlantılıdır. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "vi": "Viết một hàm C `int minOperations(int n, int* pixels)` để giải quyết vấn đề sau:\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2"
    },
    "instruction_bertscore": {
      "es": "0.9943519451152729",
      "arb": "0.9647744909665109",
      "sw": "0.9825320470310298",
      "tr": "0.9689147426288021",
      "vi": "0.9938774171349806"
    },
    "level": "hard",
    "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "es": "Se le da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puede realizar una operación en la que elige un color y cambia todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentre el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "arb": "أنت لديك صورة بحجم 1 في n بكسل، حيث كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. جد الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi hiyo kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "tr": "1'e n piksel boyutunda bir görüntü veriliyor ve her piksel bir tamsayı ile temsil edilen bir renge sahip. Bir renk seçip, aynı renge sahip tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renge sahiplerse bağlıdır. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9975707504399434",
      "arb": "0.97547272328905",
      "sw": "0.9750847981548888",
      "tr": "0.9701188399986356",
      "vi": "0.9930050325014754"
    }
  },
  {
    "task_id": "C/46",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni vizidisho vya ama 3 au 5. Ikiwa nambari ni kizidisho cha 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir tamsayı n için, 1'den n'ye kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được đếm một lần.\nVí dụ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9926709362005747",
      "arb": "0.9920259833533545",
      "sw": "0.9963859202170702",
      "tr": "0.968800530159707",
      "vi": "0.9883465541750641"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "es": "Escribe una función en C `int sumOfMultiples(int n)` para resolver el siguiente problema:\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que sean múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "arb": "اكتب دالة بلغة C `int sumOfMultiples(int n)` لحل المشكلة التالية:\nمعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب أن يُحسب مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "sw": "Andika kazi ya C `int sumOfMultiples(int n)` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni vizidisho vya 3 au 5. Ikiwa nambari ni kizidisho cha 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "tr": "Bir C fonksiyonu `int sumOfMultiples(int n)` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı n için, 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katı ise, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "vi": "Viết một hàm C `int sumOfMultiples(int n)` để giải quyết vấn đề sau:  \nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.  \nVí dụ:  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  "
    },
    "instruction_bertscore": {
      "es": "0.9899955835984158",
      "arb": "0.9890655961544105",
      "sw": "0.9914642566357877",
      "tr": "0.9574225846732666",
      "vi": "0.9884635474694937"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, debe contarse solo una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع كل الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "sw": "Kwa kupewa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu. \nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "tr": "Verilen bir tam sayı n için, 1'den n'e kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.  \nVí dụ:  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  "
    },
    "docstring_bertscore": {
      "es": "0.9900521932570108",
      "arb": "0.9944242465739697",
      "sw": "0.9900521932570108",
      "tr": "0.9769298757643219",
      "vi": "0.9860144348713336"
    }
  },
  {
    "task_id": "C/47",
    "prompt": {
      "es": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "arb": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتحديد ما إذا كانت سلسلة معينة هي كلمة متكاملة. الكلمة المتكاملة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تقرأ بنفس الطريقة للأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "sw": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua kama mfuatano wa herufi uliotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mfuatano mwingine wa herufi unaosomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "tr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "vi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nXác định xem một chuỗi cho trước có phải là palindrome hay không. Palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà khi đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9992019031290018",
      "sw": "0.9904041662922045",
      "tr": "0.9894821240634406",
      "vi": "0.9886729038911045"
    },
    "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "es": "Escribe una función en C `bool isPalindrome(const char* str)` para resolver el siguiente problema:\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "arb": "اكتب دالة بلغة C `bool isPalindrome(const char* str)` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة. الكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف الذي يقرأ بنفس الطريقة من الأمام إلى الخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة والصغيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "sw": "Andika kazi ya C `bool isPalindrome(const char* str)` kutatua tatizo lifuatalo:  \nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  ",
      "tr": "Bir C fonksiyonu `bool isPalindrome(const char* str)` yazın ve aşağıdaki problemi çözün:\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "vi": "Viết một hàm C `bool isPalindrome(const char* str)` để giải quyết vấn đề sau:  \nXác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và phân biệt chữ hoa chữ thường).  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  "
    },
    "instruction_bertscore": {
      "es": "0.9939316432290032",
      "arb": "0.9139684148446451",
      "sw": "0.9975981614325261",
      "tr": "0.9814300456770483",
      "vi": "0.9853327354036218"
    },
    "level": "middle",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة عند قراءتها من الأمام والخلف. الكلمة المتطابقة هي كلمة، عبارة، رقم، أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة من الأمام والخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة والصغيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "sw": "Amua kama string iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomeka sawa mbele na nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "tr": "Verilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà khi đọc từ trái sang phải và từ phải sang trái đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9705800597433986",
      "sw": "0.9964693449771048",
      "tr": "0.9810349698491699",
      "vi": "0.9989991015099652"
    }
  },
  {
    "task_id": "C/48",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> addDigits(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n*/\nint addDigits(int num)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. ولأن 2 هو رقم واحد فقط، فإن 2 هو الناتج.\n*/\nint addDigits(int num)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa nambari isiyo hasi num, ongeza tarakimu zake zote mara kwa mara hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    >>> addDigits(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n*/\nint addDigits(int num)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen negatif olmayan bir tamsayı num için, sonucu tek bir basamak olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> addDigits(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamağa sahip olduğundan, sonuç 2'dir.\n*/\nint addDigits(int num)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    >>> addDigits(38)\n    2\n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9697837505458297",
      "sw": "0.993617409966206",
      "tr": "0.9694285994245393",
      "vi": "0.9785302407443199"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "es": "Escriba una función en C `int addDigits(int num)` para resolver el siguiente problema:\nDado un número entero no negativo num, sume repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> addDigits(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "اكتب دالة بلغة C `int addDigits(int num)` لحل المشكلة التالية:\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 يحتوي على رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Andika kazi ya C `int addDigits(int num)` kutatua tatizo lifuatalo:  \nUkipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.  \nKwa mfano:  \n    >>> addDigits(38)  \n    2  \n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Bir C fonksiyonu `int addDigits(int num)` yazın ve aşağıdaki problemi çözün:\nVerilen bir negatif olmayan tam sayı num, sonucu tek basamaklı olana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> addDigits(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 tek basamaklı olduğundan, sonuç 2'dir.",
      "vi": "Viết một hàm C `int addDigits(int num)` để giải quyết vấn đề sau:  \nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    >>> addDigits(38)  \n    2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "instruction_bertscore": {
      "es": "0.9943400272924109",
      "arb": "0.9787248985177341",
      "sw": "0.9914813388485567",
      "tr": "0.9594476214079172",
      "vi": "0.9956571453490533"
    },
    "level": "easy",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.  \nPor ejemplo:  \n    >>> addDigits(38)  \n    2  \n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "بالنظر إلى عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. ولأن 2 يحتوي على رقم واحد فقط، فإن 2 هو النتيجة.",
      "sw": "Ukipokea nambari isiyo hasi num, ongeza tena tarakimu zake zote hadi matokeo yawe na tarakimu moja pekee.\nKwa mfano:\n    >>> addDigits(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja pekee, 2 ndiyo matokeo.",
      "tr": "Verilen bir negatif olmayan tamsayı num için, sonucu tek bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> addDigits(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak içerdiğinden, sonuç 2'dir.",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    >>> addDigits(38)  \n    2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "docstring_bertscore": {
      "es": "0.9893973088907387",
      "arb": "0.9728756310570188",
      "sw": "0.9666074521227008",
      "tr": "0.9833712603909023",
      "vi": "0.9584280516620651"
    }
  },
  {
    "task_id": "C/49",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para remover de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho ndiye anayeshinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaocheza kwa ufanisi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định liệu bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);"
    },
    "prompt_bertscore": {
      "es": "0.99082744763419",
      "arb": "0.9860881267426974",
      "sw": "0.989854556027881",
      "tr": "0.9856590851196622",
      "vi": "0.9817734776058576"
    },
    "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}",
    "instruction": {
      "es": "Escribe una función en C `bool canWinNim(int n)` para resolver el siguiente problema:\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "اكتب دالة بلغة C `bool canWinNim(int n)` لحل المشكلة التالية:\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n حجارة، وتقوم أنت وخصمك بالتناوب لإزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Andika kazi ya C `bool canWinNim(int n)` kutatua tatizo lifuatalo:\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ufanisi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Bir C fonksiyonu `bool canWinNim(int n)` yazın ve aşağıdaki problemi çözün:\nNim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Verilen taş sayısı n olduğunda, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Viết một hàm C `bool canWinNim(int n)` để giải quyết vấn đề sau:  \nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ của bạn lần lượt loại bỏ từ 1 đến 3 viên đá khỏi đống. Người nào loại bỏ viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ của bạn đều chơi tối ưu.  \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:  \n    >>> canWinNim(1)  \n    true  "
    },
    "instruction_bertscore": {
      "es": "0.987617580676666",
      "arb": "0.9874139845361053",
      "sw": "0.9918509899876626",
      "tr": "0.949220937609955",
      "vi": "0.9853331326643838"
    },
    "level": "easy",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة من 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. \nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe pamoja na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. Not: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "es": "0.9948346169411877",
      "arb": "0.9880815812467636",
      "sw": "0.9863596544735722",
      "tr": "0.9734735085039338",
      "vi": "0.9769598689518582"
    }
  },
  {
    "task_id": "C/50",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عددان صحيحان a و b، أعد المجموع إذا كان المجموع زوجيًا، أو أعد حاصل ضرب a و b إذا كان المجموع فرديًا.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipata nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki tamsayı a ve b verildiğinde, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "es": "Escribe una función en C `int evenSumOrOddProduct(int a, int b)` para resolver el siguiente problema:\nDado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "arb": "اكتب دالة بلغة C `int evenSumOrOddProduct(int a, int b)` لحل المشكلة التالية:\nبالنظر إلى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجياً، أو أعد حاصل ضرب a و b إذا كان المجموع فردياً.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "sw": "Andika kazi ya C `int evenSumOrOddProduct(int a, int b)` kutatua tatizo lifuatalo:  \nUkipiwa nambari mbili za mzima a na b, rudisha jumla ikiwa jumla ni nambari shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni nambari witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "tr": "Bir C fonksiyonu `int evenSumOrOddProduct(int a, int b)` yazın ve aşağıdaki problemi çözün:\nVerilen iki tam sayı a ve b için, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "vi": "Viết một hàm C `int evenSumOrOddProduct(int a, int b)` để giải quyết vấn đề sau:  \nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10"
    },
    "instruction_bertscore": {
      "es": "0.994574411142032",
      "arb": "0.994574411142032",
      "sw": "0.9724471853251265",
      "tr": "0.9844623370739269",
      "vi": "1"
    },
    "level": "easy",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "arb": "نظرًا لعددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو قم بإرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "sw": "Kwa kupewa nambari mbili za mzima a na b, rudisha jumla ikiwa jumla ni namba shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni namba witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "tr": "Verilen iki tamsayı a ve b için, toplam çift ise toplamı döndürün, eğer toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9676075560912115",
      "tr": "0.942986525840413",
      "vi": "1"
    }
  }
]