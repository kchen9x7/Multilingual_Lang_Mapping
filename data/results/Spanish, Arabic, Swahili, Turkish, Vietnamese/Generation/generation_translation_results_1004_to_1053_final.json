[
  {
    "task_id": "Kotlin/1",
    "prompt": {
      "en": "/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "es": "/**\n    * Verificar si en la lista dada de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "arb": "/**\n    * تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n    * العتبة المعطاة.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "sw": "/**\n    * Angalia kama katika orodha iliyotolewa ya namba, namba zozote mbili ziko karibu zaidi kuliko\n    * kizingiti kilichopewa.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "tr": "/**\n    * Verilen sayı listesindeki herhangi iki sayının\n    * belirtilen eşikten daha yakın olup olmadığını kontrol edin.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "vi": "/**\n    * Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn\n    * ngưỡng đã cho hay không.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean"
    },
    "prompt_bertscore": {
      "es": "0.9631999479360474",
      "arb": "0.9879715400156702",
      "sw": "0.972221938473033",
      "tr": "0.9344035084455143",
      "vi": "0.9602163209825223"
    },
    "canonical_solution": "{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "es": "Escribe una función en Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` para resolver el siguiente problema:\nVerifica si en la lista dada de números, hay dos números que estén más cerca uno del otro que el umbral dado.",
      "arb": "اكتب دالة Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` لحل المشكلة التالية:\nتحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.",
      "sw": "Andika kazi ya Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` kutatua tatizo lifuatalo:\nAngalia kama katika orodha iliyotolewa ya namba, namba zozote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.",
      "tr": "Bir Kotlin fonksiyonu `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` yazın:\nVerilen sayı listesinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Viết một hàm Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` để giải quyết vấn đề sau:  \nKiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "instruction_bertscore": {
      "es": "0.9672023501139003",
      "arb": "0.9671159458981501",
      "sw": "0.9921221204577753",
      "tr": "0.9466121261854428",
      "vi": "0.9824317386886072"
    },
    "level": "easy",
    "test": "// Test cases\nfun main() {\n    println(\"start\")\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n\n}",
    "entry_point": "hasCloseElements",
    "signature": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "es": "Verificar si en la lista dada de números, hay dos números que estén más cerca entre sí que el umbral dado.",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.",
      "sw": "Angalia kama katika orodha iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi kuliko kizingiti kilichotolewa.",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9391279320584291",
      "arb": "0.9626747692085911",
      "sw": "0.902125674266583",
      "tr": "0.892139730490435",
      "vi": "0.915573546953788"
    }
  },
  {
    "task_id": "Kotlin/2",
    "prompt": {
      "en": "/**\n * Finds all Armstrong numbers within a specified range.\n * An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\n * For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "es": "/**\n * Encuentra todos los números de Armstrong dentro de un rango especificado.\n * Un número de Armstrong es un número que es igual a la suma de sus propios dígitos, cada uno elevado a la potencia del número de 3.\n * Por ejemplo, 153 es un número de Armstrong porque 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "arb": "/**\n * يجد جميع الأعداد أرمسترونغ ضمن نطاق محدد.\n * عدد أرمسترونغ هو عدد يساوي مجموع أرقامه كل منها مرفوع إلى قوة العدد 3.\n * على سبيل المثال، 153 هو عدد أرمسترونغ لأن 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "sw": "/**\n * Inapata namba zote za Armstrong ndani ya upeo uliobainishwa.\n * Namba ya Armstrong ni namba ambayo ni sawa na jumla ya tarakimu zake yenyewe kila moja ikiwa imeinuliwa kwa nguvu ya namba ya 3.\n * Kwa mfano, 153 ni namba ya Armstrong kwa sababu 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "tr": "/**\n * Belirtilen bir aralıktaki tüm Armstrong sayılarını bulur.\n * Bir Armstrong sayısı, kendi basamaklarının her birinin 3 sayısının kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\n * Örneğin, 153 bir Armstrong sayısıdır çünkü 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "vi": "/**\n * Tìm tất cả các số Armstrong trong một phạm vi xác định.\n * Một số Armstrong là một số bằng tổng các chữ số của chính nó, mỗi chữ số được nâng lên lũy thừa của số 3.\n * Ví dụ, 153 là một số Armstrong vì 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9884675200771144",
      "arb": "0.9806889557254072",
      "sw": "0.9855492425189498",
      "tr": "0.9874982038176642",
      "vi": "0.9753036888347892"
    },
    "canonical_solution": "{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` to solve the following problem:\nFinds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "es": "Escribe una función de Kotlin `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` para resolver el siguiente problema:\nEncuentra todos los números de Armstrong dentro de un rango especificado.\nUn número de Armstrong es un número que es igual a la suma de sus propios dígitos, cada uno elevado a la potencia del número de 3.\nPor ejemplo, 153 es un número de Armstrong porque 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "arb": "اكتب دالة كوتلن `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` لحل المشكلة التالية:\nتجد جميع الأعداد أرمسترونغ ضمن نطاق محدد.\nعدد أرمسترونغ هو عدد يساوي مجموع أرقامه كل منها مرفوع إلى قوة العدد 3.\nعلى سبيل المثال، 153 هو عدد أرمسترونغ لأن 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "sw": "Andika kazi ya Kotlin `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` kutatua tatizo lifuatalo:\nInapata namba zote za Armstrong ndani ya safu maalum.\nNamba ya Armstrong ni namba ambayo ni sawa na jumla ya tarakimu zake zenyewe kila moja ikiwa imeinuliwa kwa nguvu ya namba ya 3.\nKwa mfano, 153 ni namba ya Armstrong kwa sababu 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "tr": "Bir Kotlin fonksiyonu `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` yazın:\nBelirtilen bir aralıktaki tüm Armstrong sayılarını bulur.\nBir Armstrong sayısı, kendi basamaklarının her birinin 3 sayısının kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\nÖrneğin, 153 bir Armstrong sayısıdır çünkü 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "vi": "Viết một hàm Kotlin `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` để giải quyết vấn đề sau:\nTìm tất cả các số Armstrong trong một phạm vi xác định.\nMột số Armstrong là một số bằng tổng của các chữ số của nó, mỗi chữ số được nâng lên lũy thừa của số 3.\nVí dụ, 153 là một số Armstrong vì 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()"
    },
    "instruction_bertscore": {
      "es": "0.9847437963238533",
      "arb": "0.9119815151431531",
      "sw": "0.9864399011475102",
      "tr": "0.9734367618834423",
      "vi": "0.9787119875429668"
    },
    "level": "middle",
    "test": "fun main() {\n    check(findArmstrongNumbersInRange(1, 500) == listOf(1, 153, 370, 371, 407))\n    check(findArmstrongNumbersInRange(500, 1000) == emptyList<Int>())\n    check(findArmstrongNumbersInRange(1, 100) == listOf(1))\n    check(findArmstrongNumbersInRange(100, 200) == listOf(153))\n    check(findArmstrongNumbersInRange(100, 1000) == listOf(153, 370, 371, 407))\n}\n\n\nmain()",
    "entry_point": "findArmstrongNumbersInRange",
    "signature": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>",
    "docstring": {
      "en": "Finds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "es": "Encuentra todos los números de Armstrong dentro de un rango especificado.  \nUn número de Armstrong es un número que es igual a la suma de sus propios dígitos, cada uno elevado a la potencia del número de 3.  \nPor ejemplo, 153 es un número de Armstrong porque 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()",
      "arb": "يعثر على جميع أرقام أرمسترونغ ضمن نطاق محدد.\nرقم أرمسترونغ هو رقم يساوي مجموع أرقامه الخاصة، كل منها مرفوع إلى قوة الرقم 3.\nعلى سبيل المثال، 153 هو رقم أرمسترونغ لأن 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "sw": "Inapata nambari zote za Armstrong ndani ya safu maalum.  \nNambari ya Armstrong ni nambari ambayo ni sawa na jumla ya tarakimu zake yenyewe kila moja ikipandishwa kwa nguvu ya nambari ya 3.  \nKwa mfano, 153 ni nambari ya Armstrong kwa sababu 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()",
      "tr": "Belirtilen bir aralık içindeki tüm Armstrong sayılarını bulur.\nBir Armstrong sayısı, kendi rakamlarının her birinin 3 sayısının kuvvetine yükseltilmiş toplamına eşit olan bir sayıdır.\nÖrneğin, 153 bir Armstrong sayısıdır çünkü 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "vi": "Tìm tất cả các số Armstrong trong một phạm vi được chỉ định.  \nMột số Armstrong là một số bằng tổng các chữ số của chính nó, mỗi chữ số được nâng lên lũy thừa của số 3.  \nVí dụ, 153 là một số Armstrong vì 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  "
    },
    "docstring_bertscore": {
      "es": "0.9877266287558543",
      "arb": "0.9779822195230448",
      "sw": "0.9843421656934008",
      "tr": "0.9867620796255488",
      "vi": "0.9788440767463551"
    }
  },
  {
    "task_id": "Kotlin/3",
    "prompt": {
      "en": "/**\n * Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\n * to safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\n * so you need to ensure that no M consecutive test tubes contain chemicals.\n *\n * Write a function that calculates the total number of safe placement options.\n *\n * Example:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Constraints:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Note: The result can be a large number, so return it as a Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "es": "/**\n * Dado un laboratorio con N tubos de ensayo dispuestos en línea recta, necesitas encontrar el número de formas\n * de colocar de manera segura productos químicos en los tubos de ensayo. Colocar productos químicos en M tubos de ensayo consecutivos causará una explosión,\n * por lo que debes asegurarte de que no haya M tubos de ensayo consecutivos que contengan productos químicos.\n *\n * Escribe una función que calcule el número total de opciones de colocación segura.\n *\n * Ejemplo:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Restricciones:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Nota: El resultado puede ser un número grande, por lo que devuélvelo como un Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "arb": "/**\n * بالنظر إلى مختبر يحتوي على N أنبوب اختبار مرتبة في خط مستقيم، تحتاج إلى إيجاد عدد الطرق\n * لوضع المواد الكيميائية بأمان في أنابيب الاختبار. وضع المواد الكيميائية في M أنابيب اختبار متتالية سيسبب انفجارًا،\n * لذا تحتاج إلى التأكد من أن لا تحتوي M أنابيب اختبار متتالية على مواد كيميائية.\n *\n * اكتب دالة تحسب العدد الإجمالي لخيارات الوضع الآمن.\n *\n * مثال:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * القيود:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * ملاحظة: يمكن أن تكون النتيجة عددًا كبيرًا، لذا أعدها كـ Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "sw": "/**\n * Ukiwa na maabara yenye mirija ya majaribio N iliyopangwa kwa mstari wa moja kwa moja, unahitaji kupata idadi ya njia\n * za kuweka kemikali kwa usalama kwenye mirija ya majaribio. Kuweka kemikali katika mirija M mfululizo kutasababisha mlipuko,\n * hivyo unahitaji kuhakikisha kuwa hakuna mirija M mfululizo yenye kemikali.\n *\n * Andika kazi inayohesabu jumla ya chaguzi za uwekaji salama.\n *\n * Mfano:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Vikwazo:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Kumbuka: Matokeo yanaweza kuwa namba kubwa, hivyo yarudishe kama Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "tr": "/**\n * Bir laboratuvarda düz bir çizgi halinde düzenlenmiş N test tüpü verildiğinde, kimyasalları test tüplerine güvenli bir şekilde yerleştirmenin kaç yolu olduğunu bulmanız gerekiyor. M ardışık test tüpüne kimyasal yerleştirmek bir patlamaya neden olacaktır, bu yüzden hiçbir M ardışık test tüpünün kimyasal içermediğinden emin olmalısınız.\n *\n * Toplam güvenli yerleştirme seçeneği sayısını hesaplayan bir fonksiyon yazın.\n *\n * Örnek:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Kısıtlamalar:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Not: Sonuç büyük bir sayı olabilir, bu yüzden Long olarak döndürün.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "vi": "/**\n * Cho một phòng thí nghiệm với N ống nghiệm được sắp xếp thành một hàng thẳng, bạn cần tìm số cách\n * để đặt hóa chất an toàn trong các ống nghiệm. Đặt hóa chất trong M ống nghiệm liên tiếp sẽ gây ra nổ,\n * vì vậy bạn cần đảm bảo rằng không có M ống nghiệm liên tiếp nào chứa hóa chất.\n *\n * Viết một hàm tính tổng số tùy chọn đặt an toàn.\n *\n * Ví dụ:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Ràng buộc:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Lưu ý: Kết quả có thể là một số lớn, vì vậy hãy trả về nó dưới dạng Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long"
    },
    "prompt_bertscore": {
      "es": "0.9940534036525775",
      "arb": "0.9976434491594021",
      "sw": "0.9902033509769783",
      "tr": "0.9782791719426919",
      "vi": "0.9988352314456114"
    },
    "canonical_solution": "{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countSafePlacementOptions(N: Int, M: Int): Long` to solve the following problem:\nGiven a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.",
      "es": "Escribe una función en Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` para resolver el siguiente problema:\nDado un laboratorio con N tubos de ensayo dispuestos en línea recta, necesitas encontrar el número de formas\nde colocar de manera segura productos químicos en los tubos de ensayo. Colocar productos químicos en M tubos de ensayo consecutivos causará una explosión,\npor lo que debes asegurarte de que no haya M tubos de ensayo consecutivos que contengan productos químicos.\n\nEscribe una función que calcule el número total de opciones de colocación segura.\n\nEjemplo:\n>>> countSafePlacementOptions(4, 3)\n13\n\nRestricciones:\n1 < N < 32\n2 <= M <= 5\n\nNota: El resultado puede ser un número grande, por lo que devuélvelo como un Long.",
      "arb": "اكتب دالة Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` لحل المشكلة التالية:\nمعمل يحتوي على N أنبوب اختبار مرتبة في خط مستقيم، تحتاج إلى إيجاد عدد الطرق\nلوضع المواد الكيميائية بأمان في أنابيب الاختبار. وضع المواد الكيميائية في M أنابيب اختبار متتالية سيسبب انفجارًا،\nلذلك تحتاج إلى التأكد من أن لا تحتوي M أنابيب اختبار متتالية على مواد كيميائية.\n\nاكتب دالة تحسب العدد الإجمالي لخيارات الوضع الآمن.\n\nمثال:\n>>> countSafePlacementOptions(4, 3)\n13\n\nالقيود:\n1 < N < 32\n2 <= M <= 5\n\nملاحظة: يمكن أن يكون الناتج عددًا كبيرًا، لذا أعده كـ Long.",
      "sw": "Andika kazi ya Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` kutatua tatizo lifuatalo:\nUkipatiwa maabara yenye mirija ya majaribio N iliyopangwa kwa mstari wa moja kwa moja, unahitaji kupata idadi ya njia\nza kuweka kemikali kwa usalama kwenye mirija ya majaribio. Kuweka kemikali kwenye mirija M mfululizo kutasababisha mlipuko,\nkwa hivyo unahitaji kuhakikisha kuwa hakuna mirija M mfululizo yenye kemikali.\n\nAndika kazi inayohesabu jumla ya chaguo salama za uwekaji.\n\nMfano:\n>>> countSafePlacementOptions(4, 3)\n13\n\nVikwazo:\n1 < N < 32\n2 <= M <= 5\n\nKumbuka: Matokeo yanaweza kuwa namba kubwa, hivyo yarudishe kama Long.",
      "tr": "Bir Kotlin fonksiyonu `fun countSafePlacementOptions(N: Int, M: Int): Long` yazın ve aşağıdaki problemi çözün:\nN adet deney tüpünün bir doğru boyunca dizildiği bir laboratuvar verildiğinde, deney tüplerine kimyasalları güvenli bir şekilde yerleştirmenin kaç yolu olduğunu bulmanız gerekiyor. M ardışık deney tüpüne kimyasal yerleştirmek bir patlamaya neden olacaktır, bu yüzden hiçbir M ardışık deney tüpünde kimyasal bulunmadığından emin olmalısınız.\n\nToplam güvenli yerleştirme seçeneklerinin sayısını hesaplayan bir fonksiyon yazın.\n\nÖrnek:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKısıtlamalar:\n1 < N < 32\n2 <= M <= 5\n\nNot: Sonuç büyük bir sayı olabilir, bu yüzden Long olarak döndürün.",
      "vi": "Viết một hàm Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` để giải quyết vấn đề sau:\nCho một phòng thí nghiệm với N ống nghiệm được sắp xếp thành một hàng thẳng, bạn cần tìm số cách\nđể đặt hóa chất an toàn trong các ống nghiệm. Đặt hóa chất trong M ống nghiệm liên tiếp sẽ gây ra nổ,\nvì vậy bạn cần đảm bảo rằng không có M ống nghiệm liên tiếp nào chứa hóa chất.\n\nViết một hàm tính toán tổng số các cách đặt an toàn.\n\nVí dụ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nRàng buộc:\n1 < N < 32\n2 <= M <= 5\n\nLưu ý: Kết quả có thể là một số lớn, vì vậy hãy trả về nó dưới dạng Long."
    },
    "instruction_bertscore": {
      "es": "0.9900672891659694",
      "arb": "0.9895748844513839",
      "sw": "0.9907436256133931",
      "tr": "0.979765920344738",
      "vi": "0.9986765257711645"
    },
    "level": "easy",
    "test": "fun main() {\n    // Test cases\n    check(countSafePlacementOptions(4, 3) == 13L)\n    check(countSafePlacementOptions(3, 2) == 5L)\n    check(countSafePlacementOptions(5, 2) == 13L)\n    check(countSafePlacementOptions(7, 3) == 81L)\n    check(countSafePlacementOptions(10, 4) == 773L)\n    check(countSafePlacementOptions(12, 5) == 3525L)\n}\n\nmain()",
    "entry_point": "countSafePlacementOptions",
    "signature": "fun countSafePlacementOptions(N: Int, M: Int): Long",
    "docstring": {
      "en": "Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.",
      "es": "Dado un laboratorio con N tubos de ensayo dispuestos en línea recta, necesitas encontrar el número de formas de colocar de manera segura productos químicos en los tubos de ensayo. Colocar productos químicos en M tubos de ensayo consecutivos causará una explosión, por lo que debes asegurarte de que no haya M tubos de ensayo consecutivos que contengan productos químicos.\n\nEscribe una función que calcule el número total de opciones de colocación segura.\n\nEjemplo:\n>>> countSafePlacementOptions(4, 3)\n13\n\nRestricciones:\n1 < N < 32\n2 <= M <= 5\n\nNota: El resultado puede ser un número grande, por lo que debes devolverlo como un Long.",
      "arb": "نظرًا لوجود مختبر يحتوي على N من أنابيب الاختبار مرتبة في خط مستقيم، تحتاج إلى إيجاد عدد الطرق الآمنة لوضع المواد الكيميائية في أنابيب الاختبار. وضع المواد الكيميائية في M من أنابيب الاختبار المتتالية سيسبب انفجارًا، لذلك تحتاج إلى التأكد من أن لا تحتوي M من أنابيب الاختبار المتتالية على مواد كيميائية.\n\nاكتب دالة تحسب العدد الإجمالي لخيارات الوضع الآمن.\n\nمثال:\n>>> countSafePlacementOptions(4, 3)\n13\n\nالقيود:\n1 < N < 32\n2 <= M <= 5\n\nملاحظة: قد تكون النتيجة عددًا كبيرًا، لذا قم بإعادتها كـ Long.",
      "sw": "Ukiwa na maabara yenye mirija ya majaribio N iliyopangwa katika mstari wa moja kwa moja, unahitaji kupata idadi ya njia za kuweka kemikali kwa usalama kwenye mirija ya majaribio. Kuweka kemikali katika mirija ya majaribio M mfululizo kutaweza kusababisha mlipuko, kwa hivyo unahitaji kuhakikisha kuwa hakuna mirija ya majaribio M mfululizo yenye kemikali.\n\nAndika kazi inayohesabu jumla ya chaguzi salama za uwekaji.\n\nMfano:\n>>> countSafePlacementOptions(4, 3)\n13\n\nVikwazo:\n1 < N < 32\n2 <= M <= 5\n\nKumbuka: Matokeo yanaweza kuwa namba kubwa, hivyo irudishe kama Long.",
      "tr": "Verilen bir laboratuvarda, düz bir çizgide düzenlenmiş N deney tüpü bulunmaktadır. Kimyasalları güvenli bir şekilde yerleştirme yollarını bulmanız gerekiyor. M ardışık deney tüpüne kimyasal yerleştirmek bir patlamaya neden olacaktır, bu yüzden M ardışık deney tüpünde kimyasal bulunmadığından emin olmalısınız.\n\nToplam güvenli yerleştirme seçeneklerinin sayısını hesaplayan bir fonksiyon yazın.\n\nÖrnek:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKısıtlamalar:\n1 < N < 32\n2 <= M <= 5\n\nNot: Sonuç büyük bir sayı olabilir, bu yüzden Long olarak döndürün.",
      "vi": "Cho một phòng thí nghiệm với N ống nghiệm được sắp xếp thành một hàng thẳng, bạn cần tìm số cách để đặt hóa chất an toàn vào các ống nghiệm. Đặt hóa chất vào M ống nghiệm liên tiếp sẽ gây ra nổ, vì vậy bạn cần đảm bảo rằng không có M ống nghiệm liên tiếp nào chứa hóa chất.\n\nViết một hàm tính tổng số cách đặt an toàn.\n\nVí dụ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nRàng buộc:\n1 < N < 32\n2 <= M <= 5\n\nLưu ý: Kết quả có thể là một số lớn, vì vậy hãy trả về nó dưới dạng Long."
    },
    "docstring_bertscore": {
      "es": "0.9886425134428062",
      "arb": "0.9940601570855327",
      "sw": "0.9886443011162355",
      "tr": "0.9552009038613913",
      "vi": "0.9969184482686247"
    }
  },
  {
    "task_id": "Kotlin/4",
    "prompt": {
      "en": "/**\n * Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\n * that are both prime and palindrome.\n *\n * Example:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n *\n * Note:\n * - A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n * - A palindrome number is a number that reads the same forwards and backwards.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "es": "/**\n * Dado un entero 'n', encuentra y devuelve la cantidad de números entre 11 y 'n' (inclusive)\n * que son tanto primos como palíndromos.\n *\n * Ejemplo:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Porque hay dos números, 11 y 22, que son primos y palíndromos entre 11 y 50.\n *\n * Nota:\n * - Un número primo es un entero positivo mayor que 1 que no tiene divisores enteros positivos distintos de 1 y sí mismo.\n * - Un número palíndromo es un número que se lee igual de adelante hacia atrás y viceversa.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "arb": "/**\n * معطى عدد صحيح 'n'، ابحث وأعد عدد الأرقام بين 11 و 'n' (شاملاً)\n * التي هي أعداد أولية و أعداد متناظرة.\n *\n * مثال:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // لأن هناك رقمين، 11 و 22، هما عددان أوليان و متناظران بين 11 و 50.\n *\n * ملاحظة:\n * - العدد الأولي هو عدد صحيح موجب أكبر من 1 وليس له قواسم صحيحة موجبة أخرى غير 1 ونفسه.\n * - العدد المتناظر هو عدد يُقرأ بنفس الطريقة من الأمام والخلف.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "sw": "/**\n * Ukipewa nambari 'n', pata na rudisha idadi ya nambari kati ya 11 na 'n' (ikiwemo)\n * ambazo ni zote mbili nambari za kwanza na palindrome.\n *\n * Mfano:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Kwa sababu kuna nambari mbili, 11 na 22, ambazo ni nambari za kwanza na palindrome kati ya 11 na 50.\n *\n * Kumbuka:\n * - Nambari ya kwanza ni nambari nzima chanya kubwa kuliko 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe.\n * - Nambari ya palindrome ni nambari inayosomwa sawa mbele na nyuma.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "tr": "/**\n * Bir tamsayı 'n' verildiğinde, 11 ile 'n' (dahil) arasında hem asal hem de palindrom olan sayıların sayısını bulun ve döndürün.\n *\n * Örnek:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Çünkü 11 ve 22, 11 ile 50 arasında hem asal hem de palindrom olan iki sayıdır.\n *\n * Not:\n * - Asal sayı, 1 ve kendisinden başka pozitif tam böleni olmayan 1'den büyük pozitif bir tam sayıdır.\n * - Palindrom sayı, ileri ve geri okunduğunda aynı olan bir sayıdır.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "vi": "/**\n * Cho một số nguyên 'n', tìm và trả về số lượng các số giữa 11 và 'n' (bao gồm cả 11 và 'n')\n * mà vừa là số nguyên tố vừa là số đối xứng.\n *\n * Ví dụ:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Bởi vì có hai số, 11 và 22, là số nguyên tố và số đối xứng giữa 11 và 50.\n *\n * Lưu ý:\n * - Số nguyên tố là một số nguyên dương lớn hơn 1 mà không có ước số nguyên dương nào khác ngoài 1 và chính nó.\n * - Số đối xứng là một số mà đọc xuôi hay ngược đều như nhau.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9861109692365165",
      "arb": "0.9743149067979976",
      "sw": "0.9714689306985297",
      "tr": "0.9663700888173641",
      "vi": "0.9553707328371761"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countPrimePalindromeNumbers(n: Int): Int` to solve the following problem:\nGiven an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.",
      "es": "Escribe una función en Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` para resolver el siguiente problema:\nDado un entero 'n', encuentra y devuelve la cantidad de números entre 11 y 'n' (inclusive)\nque son tanto primos como palíndromos.\n\nEjemplo:\n>>> countPrimePalindromeNumbers(50)\n2 // Porque hay dos números, 11 y 22, que son primos y palíndromos entre 11 y 50.\n\nNota:\n- Un número primo es un entero positivo mayor que 1 que no tiene divisores enteros positivos distintos de 1 y él mismo.\n- Un número palíndromo es un número que se lee igual hacia adelante y hacia atrás.",
      "arb": "اكتب دالة Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` لحل المشكلة التالية:\nمعطى عدد صحيح 'n'، ابحث وأعد عدد الأرقام بين 11 و 'n' (شاملاً) التي هي أعداد أولية و أعداد متناظرة.\n\nمثال:\n>>> countPrimePalindromeNumbers(50)\n2 // لأن هناك رقمين، 11 و 22، هما عددان أوليان و متناظران بين 11 و 50.\n\nملاحظة:\n- العدد الأولي هو عدد صحيح موجب أكبر من 1 ولا يوجد له قواسم صحيحة موجبة غير 1 ونفسه.\n- العدد المتناظر هو عدد يقرأ نفسه بنفس الطريقة من الأمام والخلف.",
      "sw": "Andika kazi ya Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` kutatua tatizo lifuatalo:\nUkipiwa nambari nzima 'n', tafuta na rudisha hesabu ya nambari kati ya 11 na 'n' (ikiwa ni pamoja)\nambazo ni zote mbili, nambari kuu na palindromu.\n\nMfano:\n>>> countPrimePalindromeNumbers(50)\n2 // Kwa sababu kuna nambari mbili, 11 na 22, ambazo ni nambari kuu na palindromu kati ya 11 na 50.\n\nKumbuka:\n- Nambari kuu ni nambari nzima chanya zaidi ya 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe.\n- Nambari ya palindromu ni nambari inayosoma sawa mbele na nyuma.",
      "tr": "Bir Kotlin fonksiyonu `fun countPrimePalindromeNumbers(n: Int): Int` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı 'n' için, 11 ile 'n' (dahil) arasında hem asal hem de palindrom olan sayıların sayısını bulun ve döndürün.\n\nÖrnek:\n>>> countPrimePalindromeNumbers(50)\n2 // Çünkü 11 ve 22 olmak üzere, 11 ile 50 arasında hem asal hem de palindrom olan iki sayı vardır.\n\nNot:\n- Asal bir sayı, 1'den büyük olan ve 1 ve kendisi dışında pozitif tam böleni olmayan bir pozitif tam sayıdır.\n- Palindrom bir sayı, ileri ve geri okunduğunda aynı olan bir sayıdır.",
      "vi": "Viết một hàm Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` để giải quyết vấn đề sau:\nCho một số nguyên 'n', tìm và trả về số lượng các số giữa 11 và 'n' (bao gồm cả 11 và 'n') mà vừa là số nguyên tố vừa là số đối xứng.\n\nVí dụ:\n>>> countPrimePalindromeNumbers(50)\n2 // Bởi vì có hai số, 11 và 22, vừa là số nguyên tố vừa là số đối xứng giữa 11 và 50.\n\nLưu ý:\n- Một số nguyên tố là một số nguyên dương lớn hơn 1 mà không có ước số nguyên dương nào khác ngoài 1 và chính nó.\n- Một số đối xứng là một số mà đọc xuôi hay ngược đều giống nhau."
    },
    "instruction_bertscore": {
      "es": "0.9800489686377127",
      "arb": "0.9732425013707902",
      "sw": "0.982481594914247",
      "tr": "0.9797835984486502",
      "vi": "0.9613181237061228"
    },
    "level": "middle",
    "test": "fun main() {\n    check(countPrimePalindromeNumbers(50) == 1) // There are two prime palindrome numbers between 11 and 50 (11).\n    check(countPrimePalindromeNumbers(150) == 3) // There are three prime palindrome numbers between 11 and 100 (11, 101, 131).\n    check(countPrimePalindromeNumbers(200) == 6) // There are four prime palindrome numbers between 11 and 200 (11, 101, 131, 151, 181, 191).\n    check(countPrimePalindromeNumbers(11) == 1)  // The only prime palindrome number between 11 and 11 is 11 itself.\n}\n\nmain()",
    "entry_point": "countPrimePalindromeNumbers",
    "signature": "fun countPrimePalindromeNumbers(n: Int): Int",
    "docstring": {
      "en": "Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.",
      "es": "Dado un entero 'n', encuentra y devuelve la cantidad de números entre 11 y 'n' (inclusive) que son tanto primos como palíndromos.\n\nEjemplo:\n>>> countPrimePalindromeNumbers(50)\n2 // Porque hay dos números, 11 y 22, que son primos y palíndromos entre 11 y 50.\n\nNota:\n- Un número primo es un entero positivo mayor que 1 que no tiene divisores enteros positivos distintos de 1 y él mismo.\n- Un número palíndromo es un número que se lee igual de adelante hacia atrás y viceversa.",
      "arb": "إعطاء عدد صحيح 'n'، ابحث وأعد عدد الأرقام بين 11 و'n' (بما في ذلك) التي تكون كلاً من أعداد أولية وأعداد متطابقة.\n\nمثال:\n>>> countPrimePalindromeNumbers(50)\n2 // لأن هناك عددين، 11 و22، هما أوليان ومتطابقان بين 11 و50.\n\nملاحظة:\n- العدد الأولي هو عدد صحيح موجب أكبر من 1 لا يوجد له قواسم صحيحة موجبة أخرى غير 1 ونفسه.\n- العدد المتطابق هو عدد يقرأ بنفس الطريقة من الأمام إلى الخلف والعكس.",
      "sw": "Kwa kupewa nambari nzima 'n', tafuta na rudisha idadi ya nambari kati ya 11 na 'n' (ikiwemo) ambazo ni nambari kuu na pia ni palindromu.\n\nMfano:\n>>> countPrimePalindromeNumbers(50)\n2 // Kwa sababu kuna nambari mbili, 11 na 22, ambazo ni nambari kuu na palindromu kati ya 11 na 50.\n\nKumbuka:\n- Nambari kuu ni nambari nzima chanya iliyo kubwa kuliko 1 ambayo haina wagawanyaji chanya zaidi ya 1 na yenyewe.\n- Nambari ya palindromu ni nambari inayosomwa sawa mbele na nyuma.",
      "tr": "Verilen bir tamsayı 'n' için, 11 ile 'n' (dahil) arasında hem asal hem de palindrom olan sayıların sayısını bulun ve döndürün.\n\nÖrnek:\n>>> countPrimePalindromeNumbers(50)\n2 // Çünkü 11 ve 22, 11 ile 50 arasında asal ve palindrom olan iki sayıdır.\n\nNot:\n- Asal sayı, 1 ve kendisi dışında pozitif tam böleni olmayan 1'den büyük pozitif bir tam sayıdır.\n- Palindrom sayı, ileri ve geri aynı okunan bir sayıdır.",
      "vi": "Cho một số nguyên 'n', tìm và trả về số lượng các số giữa 11 và 'n' (bao gồm cả 11 và 'n') mà vừa là số nguyên tố vừa là số đối xứng.\n\nVí dụ:\n>>> countPrimePalindromeNumbers(50)\n2 // Bởi vì có hai số, 11 và 22, vừa là số nguyên tố vừa là số đối xứng giữa 11 và 50.\n\nLưu ý:\n- Số nguyên tố là số nguyên dương lớn hơn 1 mà không có ước số nguyên dương nào khác ngoài 1 và chính nó.\n- Số đối xứng là số mà khi đọc từ trái sang phải hay từ phải sang trái đều giống nhau."
    },
    "docstring_bertscore": {
      "es": "0.9791058715885591",
      "arb": "0.9666251302266129",
      "sw": "0.9648515595543524",
      "tr": "0.9705858200244486",
      "vi": "0.9208350671170211"
    }
  },
  {
    "task_id": "Kotlin/5",
    "prompt": {
      "en": "\n/**\n    * Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\n    * A Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\n    * The function returns a list of triples (a, b, c) that satisfy the conditions.\n    *\n    * Example:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n    * (3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n    * (5, 12, 13) and (6, 8, 10) are other valid triplets.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "es": "/**\n    * Dado un límite, encuentra todos los tripletes pitagóricos (a, b, c) tales que a < b < c y a + b + c <= límite.\n    * Un triplete pitagórico es un conjunto de tres enteros positivos a, b y c, donde a^2 + b^2 = c^2.\n    * La función devuelve una lista de tríos (a, b, c) que satisfacen las condiciones.\n    *\n    * Ejemplo:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explicación: Para límite=30, la función encuentra tripletes pitagóricos donde a + b + c es menor o igual a 30.\n    * (3, 4, 5) es el primer triplete con a^2 + b^2 = c^2 y a + b + c = 12, que es menor que 30.\n    * (5, 12, 13) y (6, 8, 10) son otros tripletes válidos.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "arb": "/**\n    * بالنظر إلى حد معين، ابحث عن جميع ثلاثيات فيثاغورس (a, b, c) بحيث a < b < c و a + b + c <= الحد.\n    * ثلاثية فيثاغورس هي مجموعة من ثلاثة أعداد صحيحة موجبة a و b و c، حيث a^2 + b^2 = c^2.\n    * تعيد الدالة قائمة من الثلاثيات (a, b, c) التي تفي بالشروط.\n    *\n    * مثال:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * الشرح: بالنسبة للحد=30، تجد الدالة ثلاثيات فيثاغورس حيث a + b + c أقل من أو يساوي 30.\n    * (3, 4, 5) هي الثلاثية الأولى حيث a^2 + b^2 = c^2 و a + b + c = 12، وهو أقل من 30.\n    * (5, 12, 13) و (6, 8, 10) هي ثلاثيات صحيحة أخرى.\n**/ \n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "sw": "/**\n    * Ukipewa kikomo, tafuta tripleti zote za Pythagorean (a, b, c) ambapo a < b < c na a + b + c <= kikomo.\n    * Tripleti ya Pythagorean ni seti ya namba tatu chanya a, b, na c, ambapo a^2 + b^2 = c^2.\n    * Kazi inarudisha orodha ya tatu (a, b, c) zinazokidhi masharti.\n    *\n    * Mfano:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Maelezo: Kwa kikomo=30, kazi inapata tripleti za Pythagorean ambapo a + b + c ni ndogo au sawa na 30.\n    * (3, 4, 5) ni tripleti ya kwanza yenye a^2 + b^2 = c^2 na a + b + c = 12, ambayo ni ndogo kuliko 30.\n    * (5, 12, 13) na (6, 8, 10) ni tripleti zingine halali.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "tr": "/**\n    * Bir limit verildiğinde, a < b < c ve a + b + c <= limit olacak şekilde tüm Pisagor üçlülerini (a, b, c) bulun.\n    * Bir Pisagor üçlüsü, a^2 + b^2 = c^2 olan üç pozitif tam sayı a, b ve c kümesidir.\n    * Fonksiyon, koşulları sağlayan üçlülerin (a, b, c) bir listesini döndürür.\n    *\n    * Örnek:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Açıklama: limit=30 için, fonksiyon a + b + c'nin 30'dan küçük veya eşit olduğu Pisagor üçlülerini bulur.\n    * (3, 4, 5), a^2 + b^2 = c^2 ve a + b + c = 12 olan ve 30'dan küçük olan ilk üçlüdür.\n    * (5, 12, 13) ve (6, 8, 10) diğer geçerli üçlülerdir.\n**/",
      "vi": "/**\n    * Cho một giới hạn, tìm tất cả các bộ ba Pythagore (a, b, c) sao cho a < b < c và a + b + c <= giới hạn.\n    * Một bộ ba Pythagore là một tập hợp ba số nguyên dương a, b và c, trong đó a^2 + b^2 = c^2.\n    * Hàm trả về một danh sách các bộ ba (a, b, c) thỏa mãn các điều kiện.\n    *\n    * Ví dụ:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Giải thích: Với giới hạn=30, hàm tìm các bộ ba Pythagore mà a + b + c nhỏ hơn hoặc bằng 30.\n    * (3, 4, 5) là bộ ba đầu tiên với a^2 + b^2 = c^2 và a + b + c = 12, nhỏ hơn 30.\n    * (5, 12, 13) và (6, 8, 10) là các bộ ba hợp lệ khác.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.993435663167559",
      "sw": "0.9941888695724433",
      "tr": "0.9551498558534653",
      "vi": "0.9934330809726055"
    },
    "canonical_solution": "{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` to solve the following problem:\nGiven a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.",
      "es": "Escribe una función de Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` para resolver el siguiente problema:\nDado un límite, encuentra todos los tríos pitagóricos (a, b, c) tales que a < b < c y a + b + c <= límite.\nUn trío pitagórico es un conjunto de tres enteros positivos a, b y c, donde a^2 + b^2 = c^2.\nLa función devuelve una lista de tríos (a, b, c) que satisfacen las condiciones.\n\nEjemplo:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplicación: Para límite=30, la función encuentra tríos pitagóricos donde a + b + c es menor o igual a 30.\n(3, 4, 5) es el primer trío con a^2 + b^2 = c^2 y a + b + c = 12, que es menor que 30.\n(5, 12, 13) y (6, 8, 10) son otros tríos válidos.",
      "arb": "اكتب دالة Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` لحل المشكلة التالية:\nبالنظر إلى حد معين، ابحث عن جميع الثلاثيات البثاغورية (a, b, c) بحيث a < b < c و a + b + c <= الحد.\nالثلاثية البثاغورية هي مجموعة من ثلاثة أعداد صحيحة موجبة a و b و c، حيث a^2 + b^2 = c^2.\nتعيد الدالة قائمة من الثلاثيات (a, b, c) التي تفي بالشروط.\n\nمثال:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nتفسير: بالنسبة للحد=30، تجد الدالة الثلاثيات البثاغورية حيث a + b + c أقل من أو يساوي 30.\n(3, 4, 5) هي الثلاثية الأولى حيث a^2 + b^2 = c^2 و a + b + c = 12، وهو أقل من 30.\n(5, 12, 13) و (6, 8, 10) هما ثلاثيات صحيحة أخرى.",
      "sw": "Andika kazi ya Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` kutatua tatizo lifuatalo:\nUkipatiwa kikomo, tafuta tripleti zote za Pythagorean (a, b, c) kama a < b < c na a + b + c <= limit.\nTripleti ya Pythagorean ni seti ya namba tatu chanya a, b, na c, ambapo a^2 + b^2 = c^2.\nKazi inarudisha orodha ya triples (a, b, c) zinazokidhi masharti.\n\nMfano:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nMaelezo: Kwa limit=30, kazi inapata tripleti za Pythagorean ambapo a + b + c ni ndogo au sawa na 30.\n(3, 4, 5) ni tripleti ya kwanza yenye a^2 + b^2 = c^2 na a + b + c = 12, ambayo ni ndogo kuliko 30.\n(5, 12, 13) na (6, 8, 10) ni tripleti zingine halali.",
      "tr": "Bir Kotlin fonksiyonu `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` yazarak aşağıdaki problemi çözün:\nVerilen bir limit ile, a < b < c ve a + b + c <= limit olacak şekilde tüm Pisagor üçlülerini (a, b, c) bulun.\nBir Pisagor üçlüsü, a^2 + b^2 = c^2 koşulunu sağlayan üç pozitif tam sayı a, b ve c kümesidir.\nFonksiyon, koşulları sağlayan üçlüler listesini döndürür.\n\nÖrnek:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nAçıklama: limit=30 için, fonksiyon a + b + c'nin 30'a eşit veya daha küçük olduğu Pisagor üçlülerini bulur.\n(3, 4, 5) a^2 + b^2 = c^2 ve a + b + c = 12 olan ilk üçlüdür ve bu, 30'dan küçüktür.\n(5, 12, 13) ve (6, 8, 10) diğer geçerli üçlülerdir.",
      "vi": "Viết một hàm Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` để giải quyết vấn đề sau:\nCho một giới hạn, tìm tất cả các bộ ba Pythagorean (a, b, c) sao cho a < b < c và a + b + c <= giới hạn.\nMột bộ ba Pythagorean là một tập hợp ba số nguyên dương a, b và c, trong đó a^2 + b^2 = c^2.\nHàm trả về một danh sách các bộ ba (a, b, c) thỏa mãn các điều kiện.\n\nVí dụ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nGiải thích: Với giới hạn=30, hàm tìm các bộ ba Pythagorean mà a + b + c nhỏ hơn hoặc bằng 30.\n(3, 4, 5) là bộ ba đầu tiên với a^2 + b^2 = c^2 và a + b + c = 12, nhỏ hơn 30.\n(5, 12, 13) và (6, 8, 10) là các bộ ba hợp lệ khác."
    },
    "instruction_bertscore": {
      "es": "0.9979860865666873",
      "arb": "0.9928594364321768",
      "sw": "0.9976881409951349",
      "tr": "0.9691793182963405",
      "vi": "0.9937632046658855"
    },
    "level": "middle",
    "test": "fun main() {\n    val result1 = findPythagoreanTriplets(20)\n    val expected1 = listOf(Triple(3, 4, 5))\n    check(result1 == expected1) // Should print true\n\n    \n    val result2 = findPythagoreanTriplets(30)\n    val expected2 = listOf(Triple(3, 4, 5), Triple(5, 12, 13), Triple(6, 8, 10))\n    check(result2 == expected2) // Should print true\n \n}\n\n\nmain()",
    "entry_point": "findPythagoreanTriplets",
    "signature": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>",
    "docstring": {
      "en": "Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.",
      "es": "Dado un límite, encuentra todos los tríos pitagóricos (a, b, c) tales que a < b < c y a + b + c <= límite.\nUn trío pitagórico es un conjunto de tres enteros positivos a, b y c, donde a^2 + b^2 = c^2.\nLa función devuelve una lista de tríos (a, b, c) que satisfacen las condiciones.\n\nEjemplo:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplicación: Para límite=30, la función encuentra tríos pitagóricos donde a + b + c es menor o igual a 30.\n(3, 4, 5) es el primer trío con a^2 + b^2 = c^2 y a + b + c = 12, que es menor que 30.\n(5, 12, 13) y (6, 8, 10) son otros tríos válidos.",
      "arb": "معطى حد معين، ابحث عن جميع الثلاثيات فيثاغورس (a, b, c) بحيث a < b < c و a + b + c <= الحد.\nالثلاثية فيثاغورس هي مجموعة من ثلاثة أعداد صحيحة موجبة a و b و c، حيث a^2 + b^2 = c^2.\nترجع الدالة قائمة من الثلاثيات (a, b, c) التي تلبي الشروط.\n\nمثال:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nتوضيح: بالنسبة للحد=30، تجد الدالة الثلاثيات فيثاغورس حيث a + b + c أقل من أو يساوي 30.\n(3, 4, 5) هي الثلاثية الأولى مع a^2 + b^2 = c^2 و a + b + c = 12، وهو أقل من 30.\n(5, 12, 13) و (6, 8, 10) هي ثلاثيات صحيحة أخرى.",
      "sw": "Ukipatiwa kikomo, tafuta tripleti zote za Pythagorean (a, b, c) kama a < b < c na a + b + c <= limit. \nPythagorean triplet ni seti ya namba tatu chanya a, b, na c, ambapo a^2 + b^2 = c^2.  \nKazi inarudisha orodha ya matatu (a, b, c) yanayokidhi masharti.\n\nMfano:  \n>>> findPythagoreanTriplets(30)  \n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nMaelezo: Kwa limit=30, kazi inapata Pythagorean triplets ambapo a + b + c ni ndogo au sawa na 30.  \n(3, 4, 5) ni triplet ya kwanza yenye a^2 + b^2 = c^2 na a + b + c = 12, ambayo ni ndogo kuliko 30.  \n(5, 12, 13) na (6, 8, 10) ni triplet zingine halali.",
      "tr": "Verilen bir sınır ile, a < b < c ve a + b + c <= sınır olacak şekilde tüm Pisagor üçlülerini (a, b, c) bulun. Bir Pisagor üçlüsü, a^2 + b^2 = c^2 olan üç pozitif tam sayı a, b ve c'den oluşan bir settir. Fonksiyon, koşulları sağlayan üçlülerin (a, b, c) bir listesini döndürür.\n\nÖrnek:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nAçıklama: limit=30 için, fonksiyon a + b + c'nin 30'dan küçük veya eşit olduğu Pisagor üçlülerini bulur. (3, 4, 5) ilk üçlüdür ve a^2 + b^2 = c^2 ve a + b + c = 12, bu da 30'dan küçüktür. (5, 12, 13) ve (6, 8, 10) diğer geçerli üçlülerdir.",
      "vi": "Cho một giới hạn, tìm tất cả các bộ ba Pythagore (a, b, c) sao cho a < b < c và a + b + c <= giới hạn.\nMột bộ ba Pythagore là một tập hợp gồm ba số nguyên dương a, b và c, nơi a^2 + b^2 = c^2.\nHàm trả về một danh sách các bộ ba (a, b, c) thỏa mãn các điều kiện.\n\nVí dụ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nGiải thích: Với giới hạn=30, hàm tìm các bộ ba Pythagore mà a + b + c nhỏ hơn hoặc bằng 30.\n(3, 4, 5) là bộ ba đầu tiên với a^2 + b^2 = c^2 và a + b + c = 12, nhỏ hơn 30.\n(5, 12, 13) và (6, 8, 10) là các bộ ba hợp lệ khác."
    },
    "docstring_bertscore": {
      "es": "0.9977872575552713",
      "arb": "0.9914606812889292",
      "sw": "0.9971935513463581",
      "tr": "0.9900903302901695",
      "vi": "0.9931099093426617"
    }
  },
  {
    "task_id": "Kotlin/6",
    "prompt": {
      "en": "/**\n * Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\n * and counts the number of words in it. Words in the input string are separated by spaces.\n *\n * Example:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "es": "/**\n * Escribe una función en Kotlin que tome una cadena como entrada (longitud no superior a 80 caracteres)\n * y cuente el número de palabras en ella. Las palabras en la cadena de entrada están separadas por espacios.\n *\n * Ejemplo:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "arb": "/**\n * اكتب دالة بلغة كوتلن تأخذ سلسلة نصية كمدخل (لا يتجاوز طولها 80 حرفًا)\n * وتعد عدد الكلمات فيها. الكلمات في السلسلة النصية المدخلة مفصولة بمسافات.\n *\n * مثال:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "sw": "/**\n * Andika kazi ya Kotlin inayochukua kamba kama ingizo (urefu usiozidi herufi 80)\n * na inahesabu idadi ya maneno ndani yake. Maneno katika kamba ya ingizo yanatenganishwa na nafasi.\n *\n * Mfano:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "tr": "/**\n * Bir Kotlin fonksiyonu yazın, bu fonksiyon bir dizeyi girdi olarak alır (uzunluğu 80 karakteri geçmemelidir)\n * ve içindeki kelimelerin sayısını sayar. Girdi dizisindeki kelimeler boşluklarla ayrılmıştır.\n *\n * Örnek:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "vi": "/**\n * Viết một hàm Kotlin nhận một chuỗi làm đầu vào (độ dài không vượt quá 80 ký tự)\n * và đếm số lượng từ trong đó. Các từ trong chuỗi đầu vào được ngăn cách bởi dấu cách.\n *\n * Ví dụ:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int"
    },
    "prompt_bertscore": {
      "es": "0.9881600402472723",
      "arb": "0.9796240982526792",
      "sw": "1",
      "tr": "0.9692244073928354",
      "vi": "0.9955772959358772"
    },
    "canonical_solution": "{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countWords(inputString: String): Int` to solve the following problem:\nWrite a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "es": "Escribe una función en Kotlin `fun countWords(inputString: String): Int` para resolver el siguiente problema:\nEscribe una función en Kotlin que tome una cadena como entrada (longitud que no exceda los 80 caracteres)\ny cuente el número de palabras en ella. Las palabras en la cadena de entrada están separadas por espacios.\n\nEjemplo:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "arb": "اكتب دالة Kotlin `fun countWords(inputString: String): Int` لحل المشكلة التالية:\nاكتب دالة Kotlin تأخذ سلسلة نصية كمدخل (الطول لا يتجاوز 80 حرفًا)\nوتحسب عدد الكلمات فيها. الكلمات في السلسلة النصية المدخلة مفصولة بمسافات.\n\nمثال:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "sw": "Andika kazi ya Kotlin `fun countWords(inputString: String): Int` kutatua tatizo lifuatalo:\nAndika kazi ya Kotlin inayochukua kamba kama ingizo (urefu usiozidi herufi 80) na kuhesabu idadi ya maneno ndani yake. Maneno katika kamba ya ingizo yanatenganishwa na nafasi.\n\nMfano:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "tr": "Bir Kotlin fonksiyonu `fun countWords(inputString: String): Int` yazın ve aşağıdaki problemi çözün:\nBir Kotlin fonksiyonu yazın, bu fonksiyon bir dizeyi girdi olarak alır (uzunluğu 80 karakteri geçmeyecek şekilde) ve içindeki kelimelerin sayısını sayar. Girdi dizisindeki kelimeler boşluklarla ayrılmıştır.\n\nÖrnek:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "vi": "Viết một hàm Kotlin `fun countWords(inputString: String): Int` để giải quyết vấn đề sau:\nViết một hàm Kotlin nhận một chuỗi làm đầu vào (độ dài không vượt quá 80 ký tự) và đếm số lượng từ trong đó. Các từ trong chuỗi đầu vào được phân tách bằng dấu cách.\n\nVí dụ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5"
    },
    "instruction_bertscore": {
      "es": "0.9861157363656613",
      "arb": "0.9928512925865544",
      "sw": "1",
      "tr": "0.9736014264693202",
      "vi": "0.9964113449058427"
    },
    "level": "hard",
    "test": "fun main() {\n    // Test cases\n    check(countWords(\"This is a book\") == 4)\n    check(countWords(\"   Hello   World!  World World \") == 3)\n    check(countWords(\"A  string  with  multiple  spaces\") == 5)\n    check(countWords(\"\") == 0) // Edge case: Empty string should have 0 words\n    check(countWords(\"SingleWord\") == 1) // Edge case: String with a single word\n    check(countWords(\"a a a a a a a a a a a a\") == 1) \n    check(countWords(\"a a a ab ab c c c c c c b a c\") == 4) \n}\n\n\nmain()",
    "entry_point": "countWords",
    "signature": "fun countWords(inputString: String): Int",
    "docstring": {
      "en": "Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "es": "Escribe una función en Kotlin que tome una cadena como entrada (longitud que no exceda los 80 caracteres) y cuente el número de palabras en ella. Las palabras en la cadena de entrada están separadas por espacios.\n\nEjemplo:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "arb": "اكتب دالة في لغة Kotlin تأخذ سلسلة نصية كمدخل (لا يتجاوز طولها 80 حرفًا) وتحصي عدد الكلمات فيها. الكلمات في السلسلة النصية المدخلة مفصولة بمسافات.\n\nمثال:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "sw": "Andika kazi ya Kotlin inayopokea kamba kama ingizo (urefu usiozidi herufi 80) na kuhesabu idadi ya maneno ndani yake. Maneno katika kamba ya ingizo yanatenganishwa na nafasi.\n\nMfano:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "tr": "Bir Kotlin fonksiyonu yazın, bu fonksiyon bir dizeyi girdi olarak alır (uzunluğu 80 karakteri geçmeyecek) ve içindeki kelimelerin sayısını sayar. Girdi dizisindeki kelimeler boşluklarla ayrılmıştır.\n\nÖrnek:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "vi": "Viết một hàm Kotlin nhận một chuỗi làm đầu vào (độ dài không vượt quá 80 ký tự) và đếm số lượng từ trong đó. Các từ trong chuỗi đầu vào được phân tách bằng dấu cách.\n\nVí dụ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5"
    },
    "docstring_bertscore": {
      "es": "0.9864547984260879",
      "arb": "0.9786980834162945",
      "sw": "0.9891766305374089",
      "tr": "0.9790341660210055",
      "vi": "0.994158081863383"
    }
  },
  {
    "task_id": "Kotlin/7",
    "prompt": {
      "en": "\n\n/**\n  * Generates a Pascal's Triangle up to the specified number of rows.\n  * In Pascal's Triangle, each number is the sum of the two numbers directly above it.\n  * The function returns a list of lists, where each inner list represents a row in the triangle.\n  *\n  * Example:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "es": "/**\n  * Genera un Triángulo de Pascal hasta el número especificado de filas.\n  * En el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.\n  * La función devuelve una lista de listas, donde cada lista interna representa una fila en el triángulo.\n  *\n  * Ejemplo:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "arb": "/**\n  * يولد مثلث باسكال حتى العدد المحدد من الصفوف.\n  * في مثلث باسكال، كل رقم هو مجموع الرقمين الموجودين مباشرة فوقه.\n  * ترجع الدالة قائمة من القوائم، حيث تمثل كل قائمة داخلية صفًا في المثلث.\n  *\n  * مثال:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "sw": "/**\n  * Hutoa Pembetatu ya Pascal hadi idadi maalum ya safu.\n  * Katika Pembetatu ya Pascal, kila nambari ni jumla ya nambari mbili zilizo juu yake moja kwa moja.\n  * Kazi inarudisha orodha ya orodha, ambapo kila orodha ya ndani inawakilisha safu katika pembetatu.\n  *\n  * Mfano:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "tr": "/**\n  * Belirtilen satır sayısına kadar Pascal Üçgeni oluşturur.\n  * Pascal Üçgeni'nde, her sayı doğrudan üstündeki iki sayının toplamıdır.\n  * Fonksiyon, her bir iç listenin üçgendeki bir satırı temsil ettiği bir liste listesi döndürür.\n  *\n  * Örnek:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "vi": "/**\n  * Tạo một Tam giác Pascal đến số hàng được chỉ định.\n  * Trong Tam giác Pascal, mỗi số là tổng của hai số trực tiếp phía trên nó.\n  * Hàm trả về một danh sách các danh sách, trong đó mỗi danh sách bên trong đại diện cho một hàng trong tam giác.\n  *\n  * Ví dụ:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.958654887557207",
      "sw": "0.993475389243766",
      "tr": "0.9954422272767735",
      "vi": "0.9934465878385159"
    },
    "canonical_solution": "{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun generatePascalsTriangle(rows: Int): List<List<Int>>` to solve the following problem:\nGenerates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "es": "Escribe una función de Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` para resolver el siguiente problema:\nGenera un Triángulo de Pascal hasta el número especificado de filas.\nEn el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.\nLa función devuelve una lista de listas, donde cada lista interna representa una fila en el triángulo.\n\nEjemplo:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "arb": "اكتب دالة Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` لحل المشكلة التالية:\nتوليد مثلث باسكال حتى العدد المحدد من الصفوف.\nفي مثلث باسكال، كل عدد هو مجموع العددين الموجودين مباشرة فوقه.\nتعيد الدالة قائمة من القوائم، حيث تمثل كل قائمة داخلية صفًا في المثلث.\n\nمثال:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "sw": "Andika kazi ya Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` kutatua tatizo lifuatalo:\nInazalisha Pembetatu ya Pascal hadi idadi maalum ya safu.\nKatika Pembetatu ya Pascal, kila namba ni jumla ya namba mbili zilizo juu yake moja kwa moja.\nKazi inarudisha orodha ya orodha, ambapo kila orodha ya ndani inawakilisha safu katika pembetatu.\n\nMfano:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "tr": "Bir Kotlin fonksiyonu `fun generatePascalsTriangle(rows: Int): List<List<Int>>` yazın ve aşağıdaki problemi çözün:\nBelirtilen satır sayısına kadar Pascal Üçgeni oluşturur.\nPascal Üçgeni'nde, her sayı doğrudan üstündeki iki sayının toplamıdır.\nFonksiyon, her bir iç listenin üçgendeki bir satırı temsil ettiği bir liste listesi döndürür.\n\nÖrnek:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "vi": "Viết một hàm Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` để giải quyết vấn đề sau:\nTạo ra Tam giác Pascal lên đến số hàng được chỉ định.\nTrong Tam giác Pascal, mỗi số là tổng của hai số trực tiếp phía trên nó.\nHàm trả về một danh sách các danh sách, trong đó mỗi danh sách con đại diện cho một hàng trong tam giác.\n\nVí dụ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]"
    },
    "instruction_bertscore": {
      "es": "0.9980148879719374",
      "arb": "0.9897294188878291",
      "sw": "0.9887557327599961",
      "tr": "0.9865674218521346",
      "vi": "0.9865608670495605"
    },
    "level": "middle",
    "test": "fun main() {\n    check(generatePascalsTriangle(1) == listOf(listOf(1)))\n    check(generatePascalsTriangle(2) == listOf(listOf(1), listOf(1, 1)))\n    check(generatePascalsTriangle(3) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1)))\n    check(generatePascalsTriangle(4) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1)))\n    check(generatePascalsTriangle(5) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1)))\n    check(generatePascalsTriangle(6) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1), listOf(1, 5, 10, 10, 5, 1)))\n\n}\n\nmain()",
    "entry_point": "generatePascalsTriangle",
    "signature": "fun generatePascalsTriangle(rows: Int): List<List<Int>>",
    "docstring": {
      "en": "Generates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "es": "Genera un Triángulo de Pascal hasta el número especificado de filas.  \nEn el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.  \nLa función devuelve una lista de listas, donde cada lista interna representa una fila en el triángulo.\n\nEjemplo:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "arb": "ينشئ مثلث باسكال حتى عدد الصفوف المحدد. \nفي مثلث باسكال، كل رقم هو مجموع الرقمين الموجودين مباشرة فوقه. \nتعيد الدالة قائمة من القوائم، حيث تمثل كل قائمة داخلية صفًا في المثلث.\n\nمثال:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "sw": "Hutengeneza Pembetatu ya Pascal hadi idadi maalum ya safu.\nKatika Pembetatu ya Pascal, kila namba ni jumla ya namba mbili moja kwa moja juu yake.\nKazi inarudisha orodha ya orodha, ambapo kila orodha ya ndani inawakilisha safu katika pembetatu.\n\nMfano:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "tr": "Belirtilen satır sayısına kadar Pascal Üçgeni oluşturur.\nPascal Üçgeni'nde, her sayı doğrudan üstündeki iki sayının toplamıdır.\nFonksiyon, her bir iç listenin üçgendeki bir satırı temsil ettiği, listelerin bir listesini döndürür.\n\nÖrnek:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "vi": "Tạo ra Tam giác Pascal lên đến số hàng được chỉ định.  \nTrong Tam giác Pascal, mỗi số là tổng của hai số trực tiếp phía trên nó.  \nHàm trả về một danh sách các danh sách, trong đó mỗi danh sách con đại diện cho một hàng trong tam giác.  \n\nVí dụ:  \n>>> generatePascalsTriangle(3)  \n[[1], [1, 1], [1, 2, 1]]  \n>>> generatePascalsTriangle(5)  \n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]"
    },
    "docstring_bertscore": {
      "es": "0.9976104765161503",
      "arb": "0.9803647909435582",
      "sw": "0.9778268905650754",
      "tr": "0.993617807226968",
      "vi": "0.9760030664064131"
    }
  },
  {
    "task_id": "Kotlin/8",
    "prompt": {
      "en": "/**\n * Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n * - For profit up to 100,000, the bonus is 10%.\n * - For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n * - For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n * - For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n * - For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n * - For profit above 1,000,000, it's 1% for the amount over 1,000,000. \n * The function returns the total bonus amount.\n * Example:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "es": "/**\n * Calcula el bono basado en la cantidad de ganancia dada. El bono se calcula en un sistema escalonado:\n * - Para ganancias de hasta 100,000, el bono es del 10%.\n * - Para ganancias superiores a 100,000 y hasta 200,000, es del 10% para los primeros 100,000 y del 7.5% para el resto.\n * - Para ganancias entre 200,000 y 400,000, es del 5% para la cantidad superior a 200,000.\n * - Para ganancias entre 400,000 y 600,000, es del 3% para la cantidad superior a 400,000.\n * - Para ganancias entre 600,000 y 1,000,000, es del 1.5% para la cantidad superior a 600,000.\n * - Para ganancias superiores a 1,000,000, es del 1% para la cantidad superior a 1,000,000. \n * La función devuelve la cantidad total del bono.\n * Ejemplo:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "arb": "/**\n * يحسب المكافأة بناءً على مبلغ الربح المعطى. يتم حساب المكافأة بنظام متدرج:\n * - للربح حتى 100,000، تكون المكافأة 10%.\n * - للربح فوق 100,000 وحتى 200,000، تكون 10% لأول 100,000 و 7.5% للباقي.\n * - للربح بين 200,000 و 400,000، تكون 5% للمبلغ فوق 200,000.\n * - للربح بين 400,000 و 600,000، تكون 3% للمبلغ فوق 400,000.\n * - للربح بين 600,000 و 1,000,000، تكون 1.5% للمبلغ فوق 600,000.\n * - للربح فوق 1,000,000، تكون 1% للمبلغ فوق 1,000,000.\n * تعيد الدالة مبلغ المكافأة الإجمالي.\n * مثال:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "sw": "/**\n * Inahesabu bonasi kulingana na kiasi cha faida kilichotolewa. Bonasi inahesabiwa kwa mfumo wa viwango:\n * - Kwa faida hadi 100,000, bonasi ni 10%.\n * - Kwa faida zaidi ya 100,000 na hadi 200,000, ni 10% kwa 100,000 za kwanza na 7.5% kwa zilizobaki.\n * - Kwa faida kati ya 200,000 na 400,000, ni 5% kwa kiasi zaidi ya 200,000.\n * - Kwa faida kati ya 400,000 na 600,000, ni 3% kwa kiasi zaidi ya 400,000.\n * - Kwa faida kati ya 600,000 na 1,000,000, ni 1.5% kwa kiasi zaidi ya 600,000.\n * - Kwa faida zaidi ya 1,000,000, ni 1% kwa kiasi zaidi ya 1,000,000. \n * Kazi inarudisha kiasi cha jumla cha bonasi.\n * Mfano:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "tr": "/**\n * Verilen kar miktarına göre primi hesaplar. Prim, kademeli bir sistem üzerinden hesaplanır:\n * - Kar 100.000'e kadar ise, prim %10'dur.\n * - Kar 100.000'in üzerinde ve 200.000'e kadar ise, ilk 100.000 için %10 ve geri kalanı için %7.5'tir.\n * - Kar 200.000 ile 400.000 arasında ise, 200.000'in üzerindeki miktar için %5'tir.\n * - Kar 400.000 ile 600.000 arasında ise, 400.000'in üzerindeki miktar için %3'tür.\n * - Kar 600.000 ile 1.000.000 arasında ise, 600.000'in üzerindeki miktar için %1.5'tir.\n * - Kar 1.000.000'un üzerinde ise, 1.000.000'un üzerindeki miktar için %1'dir.\n * Fonksiyon toplam prim miktarını döndürür.\n * Örnek:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "vi": "/**\n * Tính toán tiền thưởng dựa trên số lợi nhuận đã cho. Tiền thưởng được tính theo hệ thống bậc thang:\n * - Đối với lợi nhuận lên đến 100,000, tiền thưởng là 10%.\n * - Đối với lợi nhuận trên 100,000 và lên đến 200,000, là 10% cho 100,000 đầu tiên và 7.5% cho phần còn lại.\n * - Đối với lợi nhuận giữa 200,000 và 400,000, là 5% cho số tiền trên 200,000.\n * - Đối với lợi nhuận giữa 400,000 và 600,000, là 3% cho số tiền trên 400,000.\n * - Đối với lợi nhuận giữa 600,000 và 1,000,000, là 1.5% cho số tiền trên 600,000.\n * - Đối với lợi nhuận trên 1,000,000, là 1% cho số tiền trên 1,000,000. \n * Hàm trả về tổng số tiền thưởng.\n * Ví dụ:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double "
    },
    "prompt_bertscore": {
      "es": "0.9895772680159564",
      "arb": "0.9959878649334762",
      "sw": "0.9811223672168252",
      "tr": "0.9641770107803579",
      "vi": "0.9884260063274781"
    },
    "canonical_solution": "{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateBonus(profit: Double): Double` to solve the following problem:\nCalculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "es": "Escribe una función en Kotlin `fun calculateBonus(profit: Double): Double` para resolver el siguiente problema:\nCalcula el bono basado en la cantidad de ganancia dada. El bono se calcula en un sistema escalonado:\n- Para ganancias de hasta 100,000, el bono es del 10%.\n- Para ganancias superiores a 100,000 y hasta 200,000, es del 10% para los primeros 100,000 y del 7.5% para el resto.\n- Para ganancias entre 200,000 y 400,000, es del 5% para la cantidad superior a 200,000.\n- Para ganancias entre 400,000 y 600,000, es del 3% para la cantidad superior a 400,000.\n- Para ganancias entre 600,000 y 1,000,000, es del 1.5% para la cantidad superior a 600,000.\n- Para ganancias superiores a 1,000,000, es del 1% para la cantidad superior a 1,000,000.\nLa función devuelve la cantidad total del bono.\nEjemplo:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "arb": "اكتب دالة في لغة كوتلن `fun calculateBonus(profit: Double): Double` لحل المشكلة التالية:\nتحسب المكافأة بناءً على مبلغ الربح المعطى. يتم حساب المكافأة بنظام متدرج:\n- للربح حتى 100,000، تكون المكافأة 10%.\n- للربح فوق 100,000 وحتى 200,000، تكون 10% لأول 100,000 و 7.5% للباقي.\n- للربح بين 200,000 و 400,000، تكون 5% للمبلغ فوق 200,000.\n- للربح بين 400,000 و 600,000، تكون 3% للمبلغ فوق 400,000.\n- للربح بين 600,000 و 1,000,000، تكون 1.5% للمبلغ فوق 600,000.\n- للربح فوق 1,000,000، تكون 1% للمبلغ فوق 1,000,000.\nتُرجع الدالة مبلغ المكافأة الإجمالي.\nمثال:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "sw": "Andika kazi ya Kotlin `fun calculateBonus(profit: Double): Double` kutatua tatizo lifuatalo:\nHesabu bonasi kulingana na kiasi cha faida kilichotolewa. Bonasi inahesabiwa kwa mfumo wa ngazi:\n- Kwa faida hadi 100,000, bonasi ni 10%.\n- Kwa faida zaidi ya 100,000 na hadi 200,000, ni 10% kwa 100,000 za kwanza na 7.5% kwa kiasi kilichobaki.\n- Kwa faida kati ya 200,000 na 400,000, ni 5% kwa kiasi zaidi ya 200,000.\n- Kwa faida kati ya 400,000 na 600,000, ni 3% kwa kiasi zaidi ya 400,000.\n- Kwa faida kati ya 600,000 na 1,000,000, ni 1.5% kwa kiasi zaidi ya 600,000.\n- Kwa faida zaidi ya 1,000,000, ni 1% kwa kiasi zaidi ya 1,000,000.\nKazi inarudisha kiasi cha jumla cha bonasi.\nMfano:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "tr": "Bir Kotlin fonksiyonu `fun calculateBonus(profit: Double): Double` yazın ve aşağıdaki problemi çözün:\nVerilen kar miktarına göre bonusu hesaplar. Bonus, kademeli bir sisteme göre hesaplanır:\n- Kar 100.000'e kadar olduğunda, bonus %10'dur.\n- Kar 100.000'in üzerinde ve 200.000'e kadar olduğunda, ilk 100.000 için %10 ve geri kalanı için %7.5'tir.\n- Kar 200.000 ile 400.000 arasında olduğunda, 200.000'in üzerindeki miktar için %5'tir.\n- Kar 400.000 ile 600.000 arasında olduğunda, 400.000'in üzerindeki miktar için %3'tür.\n- Kar 600.000 ile 1.000.000 arasında olduğunda, 600.000'in üzerindeki miktar için %1.5'tir.\n- Kar 1.000.000'un üzerinde olduğunda, 1.000.000'un üzerindeki miktar için %1'dir.\nFonksiyon toplam bonus miktarını döndürür.\nÖrnek:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "vi": "Viết một hàm Kotlin `fun calculateBonus(profit: Double): Double` để giải quyết vấn đề sau:\nTính toán tiền thưởng dựa trên số tiền lợi nhuận đã cho. Tiền thưởng được tính dựa trên hệ thống phân bậc:\n- Đối với lợi nhuận lên đến 100,000, tiền thưởng là 10%.\n- Đối với lợi nhuận trên 100,000 và lên đến 200,000, là 10% cho 100,000 đầu tiên và 7.5% cho phần còn lại.\n- Đối với lợi nhuận giữa 200,000 và 400,000, là 5% cho số tiền trên 200,000.\n- Đối với lợi nhuận giữa 400,000 và 600,000, là 3% cho số tiền trên 400,000.\n- Đối với lợi nhuận giữa 600,000 và 1,000,000, là 1.5% cho số tiền trên 600,000.\n- Đối với lợi nhuận trên 1,000,000, là 1% cho số tiền trên 1,000,000.\nHàm trả về tổng số tiền thưởng.\nVí dụ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00"
    },
    "instruction_bertscore": {
      "es": "0.9798012765525622",
      "arb": "0.9888985480039602",
      "sw": "0.9777293630479873",
      "tr": "0.9614021443573005",
      "vi": "0.9886371504225182"
    },
    "level": "middle",
    "test": "fun main(){\n    check(calculateBonus(50_000.00) == 5000.00)\n    check(calculateBonus(210_000.00) == 18000.00)\n    check(calculateBonus(150_000.00) == 13750.00)\n    check(calculateBonus(250_000.00) == 20000.00)\n    check(calculateBonus(450_000.00) == 29000.00)\n    check(calculateBonus(650_000.00) == 34250.00)\n    check(calculateBonus(1_050_000.00) == 40000.00)\n    check(calculateBonus(2_000_000.00) == 49500.00)\n}\n\nmain()",
    "entry_point": "calculateBonus",
    "signature": "fun calculateBonus(profit: Double): Double",
    "docstring": {
      "en": "Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "es": "Calcula el bono basado en la cantidad de ganancia dada. El bono se calcula en un sistema escalonado:\n- Para ganancias de hasta 100,000, el bono es del 10%.\n- Para ganancias superiores a 100,000 y hasta 200,000, es del 10% para los primeros 100,000 y del 7.5% para el resto.\n- Para ganancias entre 200,000 y 400,000, es del 5% para la cantidad superior a 200,000.\n- Para ganancias entre 400,000 y 600,000, es del 3% para la cantidad superior a 400,000.\n- Para ganancias entre 600,000 y 1,000,000, es del 1.5% para la cantidad superior a 600,000.\n- Para ganancias superiores a 1,000,000, es del 1% para la cantidad superior a 1,000,000.\nLa función devuelve la cantidad total del bono.\nEjemplo:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "arb": "يحسب المكافأة بناءً على مبلغ الربح المعطى. تُحسب المكافأة بنظام متدرج:\n- بالنسبة للربح حتى 100,000، تكون المكافأة 10%.\n- بالنسبة للربح الذي يزيد عن 100,000 وحتى 200,000، تكون 10% لأول 100,000 و 7.5% للباقي.\n- بالنسبة للربح بين 200,000 و 400,000، تكون 5% للمبلغ الذي يزيد عن 200,000.\n- بالنسبة للربح بين 400,000 و 600,000، تكون 3% للمبلغ الذي يزيد عن 400,000.\n- بالنسبة للربح بين 600,000 و 1,000,000، تكون 1.5% للمبلغ الذي يزيد عن 600,000.\n- بالنسبة للربح الذي يزيد عن 1,000,000، تكون 1% للمبلغ الذي يزيد عن 1,000,000.\nتعيد الدالة إجمالي مبلغ المكافأة.\nمثال:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "sw": "Hesabu bonasi kulingana na kiasi cha faida kilichotolewa. Bonasi inahesabiwa kwa mfumo wa viwango:\n- Kwa faida hadi 100,000, bonasi ni 10%.\n- Kwa faida zaidi ya 100,000 na hadi 200,000, ni 10% kwa 100,000 za kwanza na 7.5% kwa kiasi kilichobaki.\n- Kwa faida kati ya 200,000 na 400,000, ni 5% kwa kiasi zaidi ya 200,000.\n- Kwa faida kati ya 400,000 na 600,000, ni 3% kwa kiasi zaidi ya 400,000.\n- Kwa faida kati ya 600,000 na 1,000,000, ni 1.5% kwa kiasi zaidi ya 600,000.\n- Kwa faida zaidi ya 1,000,000, ni 1% kwa kiasi zaidi ya 1,000,000.\nKazi inarudisha kiasi cha jumla cha bonasi.\nMfano:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "tr": "Verilen kâr miktarına göre primi hesaplar. Prim, kademeli bir sisteme göre hesaplanır:\n- 100.000'e kadar olan kâr için prim %10'dur.\n- 100.000'in üzerinde ve 200.000'e kadar olan kâr için, ilk 100.000 için %10 ve geri kalan için %7,5'tir.\n- 200.000 ile 400.000 arasındaki kâr için, 200.000'in üzerindeki miktar için %5'tir.\n- 400.000 ile 600.000 arasındaki kâr için, 400.000'in üzerindeki miktar için %3'tür.\n- 600.000 ile 1.000.000 arasındaki kâr için, 600.000'in üzerindeki miktar için %1,5'tir.\n- 1.000.000'un üzerindeki kâr için, 1.000.000'un üzerindeki miktar için %1'dir.\nFonksiyon toplam prim miktarını döndürür.\nÖrnek:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "vi": "Tính toán tiền thưởng dựa trên số lợi nhuận đã cho. Tiền thưởng được tính theo hệ thống bậc thang:\n- Đối với lợi nhuận lên đến 100.000, tiền thưởng là 10%.\n- Đối với lợi nhuận trên 100.000 và lên đến 200.000, là 10% cho 100.000 đầu tiên và 7,5% cho phần còn lại.\n- Đối với lợi nhuận từ 200.000 đến 400.000, là 5% cho số tiền trên 200.000.\n- Đối với lợi nhuận từ 400.000 đến 600.000, là 3% cho số tiền trên 400.000.\n- Đối với lợi nhuận từ 600.000 đến 1.000.000, là 1,5% cho số tiền trên 600.000.\n- Đối với lợi nhuận trên 1.000.000, là 1% cho số tiền trên 1.000.000.\nHàm trả về tổng số tiền thưởng.\nVí dụ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00"
    },
    "docstring_bertscore": {
      "es": "0.986871127704737",
      "arb": "0.9816237102985573",
      "sw": "0.9735982483832237",
      "tr": "0.9874666215870795",
      "vi": "0.9790623715351124"
    }
  },
  {
    "task_id": "Kotlin/9",
    "prompt": {
      "en": "/**\n    * Returns the top ten highest scores from a given list of scores, sorted in descending order.\n    * If there are fewer than ten scores in the list, all scores are returned.\n    * Example:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "es": "/**\n    * Devuelve las diez puntuaciones más altas de una lista dada de puntuaciones, ordenadas en orden descendente.\n    * Si hay menos de diez puntuaciones en la lista, se devuelven todas las puntuaciones.\n    * Ejemplo:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "arb": "/**\n    * يعيد أعلى عشر درجات من قائمة الدرجات المعطاة، مرتبة بترتيب تنازلي.\n    * إذا كان هناك أقل من عشر درجات في القائمة، يتم إرجاع جميع الدرجات.\n    * مثال:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "sw": "/**\n    * Inarudisha alama kumi za juu zaidi kutoka kwenye orodha iliyotolewa ya alama, zikiwa zimepangwa kwa mpangilio wa kushuka.\n    * Ikiwa kuna alama chache kuliko kumi kwenye orodha, alama zote zitarudishwa.\n    * Mfano:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "tr": "/**\n    * Verilen bir puan listesinden en yüksek on puanı, azalan sırayla döndürür.\n    * Listede ondan az puan varsa, tüm puanlar döndürülür.\n    * Örnek:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "vi": "/**\n    * Trả về mười điểm số cao nhất từ một danh sách điểm số đã cho, được sắp xếp theo thứ tự giảm dần.\n    * Nếu có ít hơn mười điểm số trong danh sách, tất cả các điểm số đều được trả về.\n    * Ví dụ:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> "
    },
    "prompt_bertscore": {
      "es": "0.9935300125985506",
      "arb": "0.9913277975640168",
      "sw": "0.9914394278381584",
      "tr": "0.984428967169913",
      "vi": "0.9935300125985506"
    },
    "canonical_solution": "{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun topTenScores(scores: List<Double>): List<Double>` to solve the following problem:\nReturns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "es": "Escribe una función de Kotlin `fun topTenScores(scores: List<Double>): List<Double>` para resolver el siguiente problema:\nDevuelve las diez puntuaciones más altas de una lista dada de puntuaciones, ordenadas en orden descendente.\nSi hay menos de diez puntuaciones en la lista, se devuelven todas las puntuaciones.\nEjemplo:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "arb": "اكتب دالة كوتلن `fun topTenScores(scores: List<Double>): List<Double>` لحل المشكلة التالية:\nتعيد أعلى عشرة درجات من قائمة الدرجات المعطاة، مرتبة بترتيب تنازلي.\nإذا كان هناك أقل من عشر درجات في القائمة، يتم إرجاع جميع الدرجات.\nمثال:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "sw": "Andika kazi ya Kotlin `fun topTenScores(scores: List<Double>): List<Double>` kutatua tatizo lifuatalo:\nInarudisha alama kumi za juu zaidi kutoka kwenye orodha iliyotolewa ya alama, zilizopangwa kwa mpangilio wa kushuka.\nIkiwa kuna alama chache kuliko kumi kwenye orodha, alama zote zitarudishwa.\nMfano:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "tr": "Bir Kotlin fonksiyonu `fun topTenScores(scores: List<Double>): List<Double>` yazın ve aşağıdaki problemi çözün:\nVerilen bir skor listesinden en yüksek on skoru, azalan sırayla sıralanmış olarak döndürür.\nListede ondan az skor varsa, tüm skorlar döndürülür.\nÖrnek:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "vi": "Viết một hàm Kotlin `fun topTenScores(scores: List<Double>): List<Double>` để giải quyết vấn đề sau:\nTrả về mười điểm số cao nhất từ một danh sách điểm số đã cho, được sắp xếp theo thứ tự giảm dần.\nNếu có ít hơn mười điểm số trong danh sách, tất cả các điểm số đều được trả về.\nVí dụ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]"
    },
    "instruction_bertscore": {
      "es": "0.9925565251010986",
      "arb": "0.9917347912147573",
      "sw": "0.9842682751916558",
      "tr": "0.9893267951054713",
      "vi": "0.9925565251010986"
    },
    "level": "easy",
    "test": "fun main(){\n    check(topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5)) == listOf(22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5))\n    check(topTenScores(listOf(5.0, 3.0, 4.0)) == listOf(5.0, 4.0, 3.0))\n    check(topTenScores(listOf(8.0, 7.5, 9.0, 10.0)) == listOf(10.0, 9.0, 8.0, 7.5))\n    check(topTenScores(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) == listOf(12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0))\n    check(topTenScores(listOf(32.0, 31.5, 33.0, 30.0)) == listOf(33.0, 32.0, 31.5, 30.0))\n}\n\nmain()",
    "entry_point": "topTenScores",
    "signature": "fun topTenScores(scores: List<Double>): List<Double>",
    "docstring": {
      "en": "Returns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "es": "Devuelve las diez puntuaciones más altas de una lista dada de puntuaciones, ordenadas en orden descendente. Si hay menos de diez puntuaciones en la lista, se devuelven todas las puntuaciones. Ejemplo:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "arb": "يعيد أعلى عشر درجات من قائمة الدرجات المعطاة، مرتبة بترتيب تنازلي. إذا كان هناك أقل من عشر درجات في القائمة، يتم إرجاع جميع الدرجات.\n\nمثال:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "sw": "Inarejesha alama kumi za juu zaidi kutoka kwenye orodha iliyotolewa ya alama, zilizopangwa kwa mpangilio wa kushuka.\nIkiwa kuna alama chache kuliko kumi kwenye orodha, alama zote zitarudishwa.\nMfano:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "tr": "Verilen bir puan listesinde en yüksek on puanı döndürür, azalan sırayla sıralanmış olarak.\nListede ondan az puan varsa, tüm puanlar döndürülür.\nÖrnek:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "vi": "Trả về mười điểm số cao nhất từ danh sách điểm số đã cho, được sắp xếp theo thứ tự giảm dần. Nếu có ít hơn mười điểm số trong danh sách, tất cả điểm số sẽ được trả về. Ví dụ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]"
    },
    "docstring_bertscore": {
      "es": "0.9937931978534218",
      "arb": "0.9899872411224123",
      "sw": "0.9913242222171581",
      "tr": "0.9929905324836599",
      "vi": "0.987303744674631"
    }
  },
  {
    "task_id": "Kotlin/10",
    "prompt": {
      "en": "/**\n * Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\n * If multiple elements have the same absolute value, the one with the smallest row index is returned,\n * and if there is still a tie, the one with the smallest column index is chosen.\n *\n * Example:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolute value 12 at row 2, column 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "es": "/**\n * Encuentra el elemento con el valor absoluto más grande en una matriz de 3x4 y devuelve su valor absoluto e índices.\n * Si múltiples elementos tienen el mismo valor absoluto, se devuelve el que tiene el índice de fila más pequeño,\n * y si todavía hay un empate, se elige el que tiene el índice de columna más pequeño.\n *\n * Ejemplo:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Valor absoluto 12 en la fila 2, columna 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Valor absoluto 4 en la fila 0, columna 0 (primera ocurrencia)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "arb": "/**\n * يجد العنصر ذو القيمة المطلقة الأكبر في مصفوفة 3x4 ويعيد قيمته المطلقة وفهارسه.\n * إذا كان هناك عدة عناصر لها نفس القيمة المطلقة، يتم اختيار العنصر ذو فهرس الصف الأصغر،\n * وإذا كان هناك تعادل، يتم اختيار العنصر ذو فهرس العمود الأصغر.\n *\n * مثال:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // القيمة المطلقة 12 في الصف 2، العمود 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // القيمة المطلقة 4 في الصف 0، العمود 0 (الظهور الأول)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "sw": "/**\n * Inapata kipengele chenye thamani kubwa kabisa katika matrix ya 3x4 na kurudisha thamani yake kabisa na fahirisi zake.\n * Ikiwa vipengele vingi vina thamani sawa kabisa, kile chenye fahirisi ndogo zaidi ya safu kitarudishwa,\n * na ikiwa bado kuna usawa, kile chenye fahirisi ndogo zaidi ya safu wima kitachaguliwa.\n *\n * Mfano:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Thamani kabisa 12 katika safu 2, safu wima 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Thamani kabisa 4 katika safu 0, safu wima 0 (tukio la kwanza)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "tr": "/**\n * 3x4 boyutunda bir matris içinde en büyük mutlak değere sahip elemanı bulur ve bu elemanın mutlak değerini ve indekslerini döndürür.\n * Birden fazla eleman aynı mutlak değere sahipse, satır indeksi en küçük olan eleman döndürülür,\n * ve hala eşitlik varsa, sütun indeksi en küçük olan eleman seçilir.\n *\n * Örnek:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Satır 2, sütun 3'te mutlak değer 12\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Satır 0, sütun 0'da mutlak değer 4 (ilk oluşum)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "vi": "/**\n * Tìm phần tử có giá trị tuyệt đối lớn nhất trong ma trận 3x4 và trả về giá trị tuyệt đối và chỉ số của nó.\n * Nếu nhiều phần tử có cùng giá trị tuyệt đối, phần tử ở hàng có chỉ số nhỏ nhất sẽ được trả về,\n * và nếu vẫn có sự ràng buộc, phần tử ở cột có chỉ số nhỏ nhất sẽ được chọn.\n *\n * Ví dụ:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Giá trị tuyệt đối 12 tại hàng 2, cột 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Giá trị tuyệt đối 4 tại hàng 0, cột 0 (lần xuất hiện đầu tiên)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.998724792953756",
      "arb": "0.9835814113340372",
      "sw": "0.9890052125185759",
      "tr": "0.9793497896964699",
      "vi": "0.9673020625651798"
    },
    "canonical_solution": "{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` to solve the following problem:\nFinds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)",
      "es": "Escribe una función en Kotlin `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` para resolver el siguiente problema:\nEncuentra el elemento con el valor absoluto más grande en una matriz de 3x4 y devuelve su valor absoluto e índices.\nSi varios elementos tienen el mismo valor absoluto, se devuelve el que tiene el índice de fila más pequeño,\ny si todavía hay un empate, se elige el que tiene el índice de columna más pequeño.\n\nEjemplo:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Valor absoluto 12 en la fila 2, columna 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Valor absoluto 4 en la fila 0, columna 0 (primera aparición)",
      "arb": "اكتب دالة كوتلن `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` لحل المشكلة التالية:\nتجد العنصر ذو القيمة المطلقة الأكبر في مصفوفة 3x4 وتعيد قيمته المطلقة وفهارسه.\nإذا كان هناك عناصر متعددة لها نفس القيمة المطلقة، يتم اختيار العنصر ذو فهرس الصف الأصغر،\nوإذا كان هناك تعادل، يتم اختيار العنصر ذو فهرس العمود الأصغر.\n\nمثال:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // القيمة المطلقة 12 في الصف 2، العمود 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // القيمة المطلقة 4 في الصف 0، العمود 0 (الظهور الأول)",
      "sw": "Andika kazi ya Kotlin `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` kutatua tatizo lifuatalo:\nInapata kipengele chenye thamani kubwa zaidi ya kabisa katika matrix ya 3x4 na kurudisha thamani yake ya kabisa na fahirisi zake.\nIkiwa vipengele vingi vina thamani sawa ya kabisa, kinachorudishwa ni kile chenye fahirisi ndogo zaidi ya safu,\nna ikiwa bado kuna usawa, kinachorudishwa ni kile chenye fahirisi ndogo zaidi ya safu wima.\n\nMfano:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Thamani ya kabisa 12 katika safu 2, safu wima 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Thamani ya kabisa 4 katika safu 0, safu wima 0 (tukio la kwanza)",
      "tr": "Bir Kotlin fonksiyonu `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` yazarak aşağıdaki problemi çözün:\n3x4 bir matris içinde en büyük mutlak değere sahip elemanı bulur ve bu elemanın mutlak değerini ve indekslerini döndürür.\nBirden fazla eleman aynı mutlak değere sahipse, en küçük satır indeksine sahip olan döndürülür,\nve hala eşitlik varsa, en küçük sütun indeksine sahip olan seçilir.\n\nÖrnek:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Satır 2, sütun 3'te mutlak değeri 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Satır 0, sütun 0'da mutlak değeri 4 (ilk oluşum)",
      "vi": "Viết một hàm Kotlin `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` để giải quyết vấn đề sau:\nTìm phần tử có giá trị tuyệt đối lớn nhất trong ma trận 3x4 và trả về giá trị tuyệt đối và chỉ số của nó.\nNếu nhiều phần tử có cùng giá trị tuyệt đối, phần tử có chỉ số hàng nhỏ nhất sẽ được trả về,\nvà nếu vẫn còn hòa, phần tử có chỉ số cột nhỏ nhất sẽ được chọn.\n\nVí dụ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Giá trị tuyệt đối 12 tại hàng 2, cột 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Giá trị tuyệt đối 4 tại hàng 0, cột 0 (lần xuất hiện đầu tiên)"
    },
    "instruction_bertscore": {
      "es": "0.9856938454363432",
      "arb": "0.9809577026309474",
      "sw": "0.9710823959770358",
      "tr": "0.9811313055839719",
      "vi": "0.9916177979203277"
    },
    "level": "middle",
    "test": "fun main() {\n    check(findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(1, -2, 3, -4), arrayOf(0, 6, -7, 8), arrayOf(9, -10, -11, -12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(4, 4, -3, -2), arrayOf(-1, 0, 4, 4), arrayOf(-2, -3, 4, -4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0))) == Triple(0, 0, 0))\n}\nmain()",
    "entry_point": "findMaxAbsElement",
    "signature": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)",
      "es": "Encuentra el elemento con el valor absoluto más grande en una matriz de 3x4 y devuelve su valor absoluto e índices. Si varios elementos tienen el mismo valor absoluto, se devuelve el que tiene el índice de fila más pequeño, y si todavía hay un empate, se elige el que tiene el índice de columna más pequeño.\n\nEjemplo:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Valor absoluto 12 en la fila 2, columna 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Valor absoluto 4 en la fila 0, columna 0 (primera ocurrencia)",
      "arb": "يعثر على العنصر الذي يحتوي على أكبر قيمة مطلقة في مصفوفة 3x4 ويعيد قيمته المطلقة وفهارسه. إذا كان هناك عدة عناصر لها نفس القيمة المطلقة، يتم إرجاع العنصر الذي له أصغر فهرس صف، وإذا كان هناك تعادل، يتم اختيار العنصر الذي له أصغر فهرس عمود.\n\nمثال:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // القيمة المطلقة 12 في الصف 2، العمود 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // القيمة المطلقة 4 في الصف 0، العمود 0 (الظهور الأول)",
      "sw": "Inapata kipengele chenye thamani kubwa kabisa katika matrix ya 3x4 na inarejesha thamani yake kabisa na fahirisi zake. \nIkiwa vipengele vingi vina thamani sawa kabisa, kile chenye fahirisi ndogo zaidi ya safu kitarudishwa, \nna ikiwa bado kuna sare, kile chenye fahirisi ndogo zaidi ya safu wima kitachaguliwa.\n\nMfano:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Thamani kabisa 12 katika safu 2, safu wima 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Thamani kabisa 4 katika safu 0, safu wima 0 (tukio la kwanza)",
      "tr": "3x4 boyutunda bir matristen en büyük mutlak değere sahip elemanı bulur ve bu elemanın mutlak değerini ve indekslerini döndürür. Eğer birden fazla eleman aynı mutlak değere sahipse, en küçük satır indeksine sahip olan döndürülür ve eğer hala eşitlik varsa, en küçük sütun indeksine sahip olan seçilir.\n\nÖrnek:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Satır 2, sütun 3'te mutlak değeri 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Satır 0, sütun 0'da mutlak değeri 4 (ilk oluşum)",
      "vi": "Tìm phần tử có giá trị tuyệt đối lớn nhất trong ma trận 3x4 và trả về giá trị tuyệt đối và chỉ số của nó. Nếu nhiều phần tử có cùng giá trị tuyệt đối, phần tử có chỉ số hàng nhỏ nhất sẽ được trả về, và nếu vẫn còn hòa, phần tử có chỉ số cột nhỏ nhất sẽ được chọn.\n\nVí dụ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Giá trị tuyệt đối 12 tại hàng 2, cột 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Giá trị tuyệt đối 4 tại hàng 0, cột 0 (lần xuất hiện đầu tiên)"
    },
    "docstring_bertscore": {
      "es": "0.992410333140657",
      "arb": "0.9858906881439488",
      "sw": "0.9829513557653945",
      "tr": "0.9817337515296507",
      "vi": "0.9761057583134082"
    }
  },
  {
    "task_id": "Kotlin/11",
    "prompt": {
      "en": "/**\n    * Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\n    * The interest is compounded monthly based on the total amount in the account at the end of each month.\n    Example:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "es": "/**\n    * Calcula el ahorro total acumulado durante un período de meses con depósitos mensuales y una tasa de interés fija.\n    * El interés se capitaliza mensualmente basado en el monto total en la cuenta al final de cada mes.\n    Ejemplo:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depósito mensual, 1% interés mensual, durante 6 meses\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depósito mensual, 2% interés mensual, durante 12 meses\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "arb": "/**\n    * يحسب إجمالي المدخرات المتراكمة على مدى فترة من الأشهر مع الودائع الشهرية ومعدل فائدة ثابت.\n    * يتم تجميع الفائدة شهريًا بناءً على المبلغ الإجمالي في الحساب في نهاية كل شهر.\n    مثال:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // إيداع شهري 1000، فائدة شهرية 1%، على مدى 6 أشهر\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // إيداع شهري 500، فائدة شهرية 2%، على مدى 12 شهرًا\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "sw": "/**\n    * Inahesabu akiba ya jumla iliyokusanywa kwa kipindi cha miezi na amana za kila mwezi na kiwango cha riba kisichobadilika.\n    * Riba inakokotolewa kila mwezi kulingana na jumla ya kiasi kilichopo kwenye akaunti mwishoni mwa kila mwezi.\n    Mfano:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 amana ya kila mwezi, 1% riba ya kila mwezi, kwa miezi 6\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 amana ya kila mwezi, 2% riba ya kila mwezi, kwa miezi 12\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "tr": "/**\n    * Aylık mevduatlar ve sabit faiz oranı ile birikmiş toplam tasarrufları hesaplar.\n    * Faiz, her ayın sonunda hesaptaki toplam miktara göre aylık olarak bileşik faiz şeklinde hesaplanır.\n    Örnek:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 aylık mevduat, %1 aylık faiz, 6 ay boyunca\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 aylık mevduat, %2 aylık faiz, 12 ay boyunca\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "vi": "/**\n    * Tính toán tổng số tiền tiết kiệm tích lũy trong một khoảng thời gian với các khoản tiền gửi hàng tháng và lãi suất cố định.\n    * Lãi suất được tính gộp hàng tháng dựa trên tổng số tiền trong tài khoản vào cuối mỗi tháng.\n    Ví dụ:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 tiền gửi hàng tháng, 1% lãi suất hàng tháng, trong 6 tháng\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 tiền gửi hàng tháng, 2% lãi suất hàng tháng, trong 12 tháng\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double "
    },
    "prompt_bertscore": {
      "es": "0.998843772551996",
      "arb": "0.9688480028207743",
      "sw": "0.9838016924266049",
      "tr": "0.9636641471365258",
      "vi": "0.9847159880705084"
    },
    "canonical_solution": "{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` to solve the following problem:\nCalculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17",
      "es": "Escribe una función de Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` para resolver el siguiente problema:\nCalcula el total de ahorros acumulados durante un período de meses con depósitos mensuales y una tasa de interés fija.\nEl interés se capitaliza mensualmente basado en el monto total en la cuenta al final de cada mes.\nEjemplo:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depósito mensual, 1% interés mensual, durante 6 meses\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depósito mensual, 2% interés mensual, durante 12 meses\n6840.17",
      "arb": "اكتب دالة Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` لحل المشكلة التالية:\nتحسب إجمالي المدخرات المتراكمة على مدى فترة من الأشهر مع الودائع الشهرية ومعدل فائدة ثابت.\nيتم تجميع الفائدة شهريًا بناءً على المبلغ الإجمالي في الحساب في نهاية كل شهر.\nمثال:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 وديعة شهرية، 1% فائدة شهرية، على مدى 6 أشهر\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 وديعة شهرية، 2% فائدة شهرية، على مدى 12 شهرًا\n6840.17",
      "sw": "Andika kazi ya Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` kutatua tatizo lifuatalo:\nInakokotoa jumla ya akiba iliyokusanywa kwa kipindi cha miezi na amana za kila mwezi na kiwango cha riba kisichobadilika.\nRiba inakokotolewa kila mwezi kulingana na jumla ya kiasi kilichopo kwenye akaunti mwishoni mwa kila mwezi.\nMfano:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 amana ya kila mwezi, 1% riba ya kila mwezi, kwa miezi 6\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 amana ya kila mwezi, 2% riba ya kila mwezi, kwa miezi 12\n6840.17",
      "tr": "Bir Kotlin fonksiyonu `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` yazın ve aşağıdaki problemi çözün:\nAylık mevduatlar ve sabit bir faiz oranı ile aylar boyunca biriken toplam tasarrufları hesaplar.\nFaiz, her ayın sonunda hesaptaki toplam miktara göre aylık olarak bileşikleştirilir.\nÖrnek:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 aylık mevduat, %1 aylık faiz, 6 ay boyunca\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 aylık mevduat, %2 aylık faiz, 12 ay boyunca\n6840.17",
      "vi": "Viết một hàm Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` để giải quyết vấn đề sau:\nTính toán tổng số tiền tiết kiệm tích lũy được trong một khoảng thời gian tính theo tháng với các khoản tiền gửi hàng tháng và một lãi suất cố định.\nLãi suất được tính gộp hàng tháng dựa trên tổng số tiền trong tài khoản vào cuối mỗi tháng.\nVí dụ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 tiền gửi hàng tháng, 1% lãi suất hàng tháng, trong 6 tháng\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 tiền gửi hàng tháng, 2% lãi suất hàng tháng, trong 12 tháng\n6840.17"
    },
    "instruction_bertscore": {
      "es": "0.9975649901588933",
      "arb": "0.9942583902058055",
      "sw": "0.9819143065460113",
      "tr": "0.9839089528323637",
      "vi": "0.9871426554356116"
    },
    "level": "easy",
    "test": "fun main(){\n    check(calculateSavingsInterest(1000.0, 0.01, 6) == 6213.54)\n    check(calculateSavingsInterest(500.0, 0.02, 12) == 6840.17)\n    check(calculateSavingsInterest(2000.0, 0.005, 3) == 6060.2)\n    check(calculateSavingsInterest(750.0, 0.01, 10) == 7925.13)\n}\nmain()",
    "entry_point": "calculateSavingsInterest",
    "signature": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double",
    "docstring": {
      "en": "Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17",
      "es": "Calcula el total de ahorros acumulados durante un período de meses con depósitos mensuales y una tasa de interés fija. El interés se capitaliza mensualmente basado en el monto total en la cuenta al final de cada mes.\nEjemplo:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depósito mensual, 1% interés mensual, durante 6 meses\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depósito mensual, 2% interés mensual, durante 12 meses\n6840.17",
      "arb": "يحسب إجمالي المدخرات المتراكمة على مدى فترة من الأشهر مع الودائع الشهرية وسعر فائدة ثابت.\nيتم تراكم الفائدة شهريًا بناءً على المبلغ الإجمالي في الحساب في نهاية كل شهر.\nمثال:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // إيداع شهري 1000، فائدة شهرية 1%، على مدى 6 أشهر\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // إيداع شهري 500، فائدة شهرية 2%، على مدى 12 شهرًا\n6840.17",
      "sw": "Hesabu akiba jumla iliyokusanywa kwa kipindi cha miezi na amana za kila mwezi na kiwango cha riba kisichobadilika.\nRiba inakokotolewa kila mwezi kulingana na jumla ya kiasi kilichopo kwenye akaunti mwishoni mwa kila mwezi.\nMfano:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 amana ya kila mwezi, 1% riba ya kila mwezi, kwa miezi 6\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 amana ya kila mwezi, 2% riba ya kila mwezi, kwa miezi 12\n6840.17",
      "tr": "Aylık mevduatlar ve sabit bir faiz oranı ile aylar boyunca biriken toplam tasarrufları hesaplar.\nFaiz, her ayın sonunda hesaptaki toplam tutara göre aylık olarak bileşiklenir.\nÖrnek:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 aylık mevduat, %1 aylık faiz, 6 ay boyunca\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 aylık mevduat, %2 aylık faiz, 12 ay boyunca\n6840.17",
      "vi": "Tính tổng số tiền tiết kiệm tích lũy trong một khoảng thời gian tính bằng tháng với các khoản tiền gửi hàng tháng và lãi suất cố định. Lãi suất được tính gộp hàng tháng dựa trên tổng số tiền trong tài khoản vào cuối mỗi tháng. Ví dụ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // khoản gửi hàng tháng 1000, lãi suất hàng tháng 1%, trong 6 tháng\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // khoản gửi hàng tháng 500, lãi suất hàng tháng 2%, trong 12 tháng\n6840.17"
    },
    "docstring_bertscore": {
      "es": "0.9900805974014987",
      "arb": "0.969546188610112",
      "sw": "0.9802241606337855",
      "tr": "0.9833559658515626",
      "vi": "0.9546832730884144"
    }
  },
  {
    "task_id": "Kotlin/12",
    "prompt": {
      "en": "/**\n * Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n * \n * Example:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "es": "/**\n * Genera y devuelve una lista de enteros dentro de un rango especificado (incluyendo ambos extremos) que son divisibles por un divisor dado.\n * \n * Ejemplo:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "arb": "/**\n * ينشئ ويعيد قائمة من الأعداد الصحيحة ضمن نطاق محدد (بما في ذلك كلا الطرفين) التي تقبل القسمة على مقسوم عليه معين.\n * \n * مثال:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "sw": "/**\n * Hutoa na kurejesha orodha ya namba nzima ndani ya safu iliyobainishwa (ikijumuisha ncha zote mbili) ambazo zinagawanyika kwa mgawanyaji uliotolewa.\n * \n * Mfano:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "tr": "/**\n * Belirtilen bir aralıkta (her iki uç dahil) verilen bir bölen ile bölünebilen tamsayıların bir listesini oluşturur ve döndürür.\n * \n * Örnek:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "vi": "/**\n * Tạo và trả về một danh sách các số nguyên trong một phạm vi xác định (bao gồm cả hai đầu) mà có thể chia hết cho một số chia cho trước.\n * \n * Ví dụ:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9871654979294306",
      "arb": "0.9846605701941997",
      "sw": "0.9816556897899039",
      "tr": "0.9630261463526417",
      "vi": "0.9779826167838068"
    },
    "canonical_solution": "{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` to solve the following problem:\nGenerates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "es": "Escribe una función de Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` para resolver el siguiente problema:\nGenera y devuelve una lista de enteros dentro de un rango especificado (incluyendo ambos extremos) que son divisibles por un divisor dado.\n\nEjemplo:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "arb": "اكتب دالة Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` لحل المشكلة التالية:\nتقوم بتوليد وإرجاع قائمة من الأعداد الصحيحة ضمن نطاق محدد (شاملة كلا الطرفين) التي تقبل القسمة على مقسوم عليه معين.\n\nمثال:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "sw": "Andika kazi ya Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` kutatua tatizo lifuatalo:\nInazalisha na kurudisha orodha ya namba nzima ndani ya safu maalum (ikijumuisha ncha zote mbili) ambazo zinagawanyika kwa mgawanyiko uliotolewa.\n\nMfano:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "tr": "Bir Kotlin fonksiyonu `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir aralıkta (her iki uç dahil) verilen bir bölen ile bölünebilen tamsayıların bir listesini oluşturur ve döndürür.\n\nÖrnek:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "vi": "Viết một hàm Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` để giải quyết vấn đề sau:\nTạo và trả về một danh sách các số nguyên trong một phạm vi xác định (bao gồm cả hai đầu) mà chia hết cho một số chia cho trước.\n\nVí dụ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]"
    },
    "instruction_bertscore": {
      "es": "0.9884991023076989",
      "arb": "0.9956567480882912",
      "sw": "0.988949596011886",
      "tr": "0.9730802203494847",
      "vi": "0.990230364708799"
    },
    "level": "easy",
    "test": "fun main() {\n    check(printDivisibleNumbersInRange(1, 10, 2) == listOf(2, 4, 6, 8, 10))\n    check(printDivisibleNumbersInRange(3, 15, 3) == listOf(3, 6, 9, 12, 15))\n    check(printDivisibleNumbersInRange(5, 20, 5) == listOf(5, 10, 15, 20))\n    check(printDivisibleNumbersInRange(7, 21, 7) == listOf(7, 14, 21))\n    check(printDivisibleNumbersInRange(10, 30, 10) == listOf(10, 20, 30))\n}\n\nmain()",
    "entry_point": "printDivisibleNumbersInRange",
    "signature": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>",
    "docstring": {
      "en": "Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "es": "Genera y devuelve una lista de enteros dentro de un rango especificado (incluyendo ambos extremos) que son divisibles por un divisor dado.\n\nEjemplo:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "arb": "ينشئ ويعيد قائمة من الأعداد الصحيحة ضمن نطاق محدد (يشمل كلا الطرفين) التي تقبل القسمة على مقسوم عليه معين.\n\nمثال:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "sw": "Hutengeneza na kurudisha orodha ya nambari za mzima ndani ya safu maalum (ikiwemo ncha zote mbili) ambazo zinagawanyika kwa mgawanyiko uliotolewa.\n\nMfano:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "tr": "Belirtilen bir aralıkta (her iki uç dahil) verilen bölen ile bölünebilen tamsayıların bir listesini oluşturur ve döndürür.\n\nÖrnek:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "vi": "Tạo và trả về một danh sách các số nguyên trong một phạm vi xác định (bao gồm cả hai đầu) mà có thể chia hết cho một số chia đã cho.\n\nVí dụ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]"
    },
    "docstring_bertscore": {
      "es": "0.980397962217191",
      "arb": "0.9925845319848245",
      "sw": "0.9670009389075309",
      "tr": "0.9478072851881296",
      "vi": "0.9623353098874025"
    }
  },
  {
    "task_id": "Kotlin/13",
    "prompt": {
      "en": "/**\n * Converts a given integer to its octal, decimal, and hexadecimal representations.\n * Args:\n *   number: An integer number to be converted.\n * Returns:\n *   A Triple containing the octal, decimal, and hexadecimal representations of the number.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "es": "/**\n * Convierte un número entero dado a sus representaciones octal, decimal y hexadecimal.\n * Argumentos:\n *   number: Un número entero que se va a convertir.\n * Devuelve:\n *   Un Triple que contiene las representaciones octal, decimal y hexadecimal del número.\n * Ejemplos:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */ \n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "arb": "/**\n * يحول عددًا صحيحًا معينًا إلى تمثيلاته بالنظام الثماني والعشري والسداسي عشر.\n * يعيدالحجج:\n *   number: عدد صحيح ليتم تحويله.\n * يعيد:\n *   ثلاثي يحتوي على التمثيلات بالنظام الثماني والعشري والسداسي عشر للعدد.\n * امثله:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "sw": "/**\n * Hubadilisha nambari kamili aliyopewa kuwa uwakilishi wake wa oktali, desimali, na heksadesimali.\n * Hoja:\n *   number: Nambari kamili ya kubadilishwa.\n * Inarejesha:\n *   Triple inayojumuisha uwakilishi wa oktali, desimali, na heksadesimali wa nambari.\n * Mifano:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "tr": "/**\n * Verilen bir tam sayıyı sekizlik, ondalık ve onaltılık gösterimlerine dönüştürür.\n * Argümanlar:\n *   number: Dönüştürülecek bir tam sayı.\n * Döndürür:\n *   Sayının sekizlik, ondalık ve onaltılık gösterimlerini içeren bir Üçlü döner.\n * Örnekler:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "vi": "/**\n * Chuyển đổi một số nguyên đã cho thành các biểu diễn ở hệ bát phân, thập phân và thập lục phân.\n * Tham số:\n *   number: Một số nguyên cần được chuyển đổi.\n * Trả về:\n *   Một Triple chứa các biểu diễn ở hệ bát phân, thập phân và thập lục phân của số đó.\n * Ví dụ:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> "
    },
    "prompt_bertscore": {
      "es": "0.9944466918070266",
      "arb": "0.9957177276152689",
      "sw": "0.9846913579032601",
      "tr": "0.9948679868452016",
      "vi": "0.9764563409359347"
    },
    "canonical_solution": "{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` to solve the following problem:\nConverts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "es": "Escribe una función de Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` para resolver el siguiente problema:\nConvierte un número entero dado a sus representaciones octal, decimal y hexadecimal.\nArgumentos:\nnumber: Un número entero a ser convertido.\nDevuelve:\nUn Triple que contiene las representaciones octal, decimal y hexadecimal del número.\nEjemplos:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "arb": "اكتب دالة Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` لحل المشكلة التالية:\nتحول عددًا صحيحًا معطى إلى تمثيلاته في الأنظمة الثمانية والعشرية والسداسية العشرية.\nالمعطيات:\nnumber: عدد صحيح ليتم تحويله.\nالقيم المعادة:\nثلاثي يحتوي على التمثيلات في الأنظمة الثمانية والعشرية والسداسية العشرية للعدد.\nأمثلة:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "sw": "Andika kazi ya Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` kutatua tatizo lifuatalo:\nInabadilisha nambari kamili iliyotolewa kuwa uwakilishi wake wa oktali, desimali, na hekza.\nHoja:\nnumber: Nambari kamili ya kubadilishwa.\nInarejesha:\nTriple inayojumuisha uwakilishi wa oktali, desimali, na hekza wa nambari.\nMifano:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "tr": "Bir Kotlin fonksiyonu `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` yazın. Aşağıdaki problemi çözmek için:\nVerilen bir tam sayıyı sekizli, ondalık ve onaltılı tabanlardaki gösterimlerine dönüştürür.\nArgümanlar:\nnumber: Dönüştürülecek bir tam sayı.\nDöndürür:\nSayının sekizli, ondalık ve onaltılı tabanlardaki gösterimlerini içeren bir Triple döndürür.\nÖrnekler:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "vi": "Viết một hàm Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` để giải quyết vấn đề sau:\nChuyển đổi một số nguyên cho trước sang các biểu diễn bát phân, thập phân và thập lục phân.\nTham số:\nnumber: Một số nguyên cần được chuyển đổi.\nTrả về:\nMột Triple chứa các biểu diễn bát phân, thập phân và thập lục phân của số đó.\nVí dụ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")"
    },
    "instruction_bertscore": {
      "es": "0.9908784956421158",
      "arb": "0.9649604090031595",
      "sw": "0.9866858055592315",
      "tr": "0.9669437333577928",
      "vi": "0.9793996459221097"
    },
    "level": "easy",
    "test": "fun main() {\n    check(convertNumberToDifferentBases(10) == Triple(\"12\", \"10\", \"A\"))\n    check(convertNumberToDifferentBases(255) == Triple(\"377\", \"255\", \"FF\"))\n    check(convertNumberToDifferentBases(16) == Triple(\"20\", \"16\", \"10\"))\n    check(convertNumberToDifferentBases(1) == Triple(\"1\", \"1\", \"1\"))\n    check(convertNumberToDifferentBases(0) == Triple(\"0\", \"0\", \"0\"))\n    check(convertNumberToDifferentBases(100) == Triple(\"144\", \"100\", \"64\"))\n    check(convertNumberToDifferentBases(500) == Triple(\"764\", \"500\", \"1F4\"))\n}\n\nmain()",
    "entry_point": "convertNumberToDifferentBases",
    "signature": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>",
    "docstring": {
      "en": "Converts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "es": "Convierte un número entero dado a sus representaciones octal, decimal y hexadecimal.\nArgumentos:\nnumber: Un número entero a ser convertido.\nDevuelve:\nUn Triple que contiene las representaciones octal, decimal y hexadecimal del número.\nEjemplos:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "arb": "يقوم بتحويل عدد صحيح معين إلى تمثيلاته بالنظام الثماني والعشري والسداسي عشر.\n\nيعيدالحجج:\nnumber: عدد صحيح ليتم تحويله.\n\nيعيد:\nثلاثي يحتوي على التمثيلات بالنظام الثماني والعشري والسداسي عشر للعدد.\n\nامثله:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "sw": "Hufasiri nambari kamili iliyotolewa kuwa uwakilishi wake wa oktali, desimali, na hekzadesimali.\nHoja:\nnumber: Nambari kamili ya kubadilishwa.\nInarejesha:\nTriple inayojumuisha uwakilishi wa oktali, desimali, na hekzadesimali wa nambari.\nMifano:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "tr": "Verilen bir tam sayıyı sekizlik, ondalık ve onaltılık gösterimlerine dönüştürür.\nArgümanlar:\nnumber: Dönüştürülecek bir tam sayı.\nDöndürür:\nSayının sekizlik, ondalık ve onaltılık gösterimlerini içeren bir Üçlü.\nÖrnekler:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "vi": "Chuyển đổi một số nguyên đã cho sang các biểu diễn bát phân, thập phân và thập lục phân.  \nTham số:  \nnumber: Một số nguyên cần được chuyển đổi.  \nTrả về:  \nA Triple chứa các biểu diễn bát phân, thập phân và thập lục phân của số đó.  \nVí dụ:  \n>>> convertNumberToDifferentBases(10)  \nTriple(\"12\", \"10\", \"A\")  \n>>> convertNumberToDifferentBases(255)  \nTriple(\"377\", \"255\", \"FF\")  \n>>> convertNumberToDifferentBases(16)  \nTriple(\"20\", \"16\", \"10\")  "
    },
    "docstring_bertscore": {
      "es": "0.9961598788434525",
      "arb": "0.9949754458813415",
      "sw": "0.9845948235380771",
      "tr": "0.9961598788434525",
      "vi": "0.9840120420001208"
    }
  },
  {
    "task_id": "Kotlin/14",
    "prompt": {
      "en": "/**\n * Returns a list of all factors of the given number, excluding the number itself.\n * A factor is a number that divides the given number without leaving a remainder.\n * Examples:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "es": "/**\n * Devuelve una lista de todos los factores del número dado, excluyendo el propio número.\n * Un factor es un número que divide al número dado sin dejar un residuo.\n * Ejemplos:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "arb": "/**\n * يُرجع قائمة بجميع عوامل الرقم المعطى، باستثناء الرقم نفسه.\n * العامل هو رقم يقسم الرقم المعطى دون ترك باقي.\n * أمثلة:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "sw": "/**\n * Inarudisha orodha ya vipengele vyote vya nambari iliyotolewa, isipokuwa nambari yenyewe.\n * Kipengele ni nambari inayogawanya nambari iliyotolewa bila kuacha baki.\n * Mifano:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "tr": "/**\n * Verilen sayının kendisi hariç tüm bölenlerinin bir listesini döndürür.\n * Bir bölen, verilen sayıyı kalansız bölen bir sayıdır.\n * Örnekler:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "vi": "/**\n * Trả về danh sách tất cả các ước số của số đã cho, ngoại trừ chính số đó.\n * Một ước số là một số chia hết cho số đã cho mà không để lại dư.\n * Ví dụ:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9974897092444811",
      "tr": "0.9593530733465446",
      "vi": "0.962566515650927"
    },
    "canonical_solution": "{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun listFactors(number: Int): List<Int>` to solve the following problem:\nReturns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "es": "Escribe una función de Kotlin `fun listFactors(number: Int): List<Int>` para resolver el siguiente problema:\nDevuelve una lista de todos los factores del número dado, excluyendo el propio número.\nUn factor es un número que divide al número dado sin dejar un resto.\nEjemplos:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "arb": "اكتب دالة Kotlin `fun listFactors(number: Int): List<Int>` لحل المشكلة التالية:\nتعيد قائمة بجميع عوامل الرقم المعطى، باستثناء الرقم نفسه.\nالعامل هو رقم يقسم الرقم المعطى دون ترك باقي.\nأمثلة:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "sw": "Andika kazi ya Kotlin `fun listFactors(number: Int): List<Int>` kutatua tatizo lifuatalo:\nInarudisha orodha ya vipengele vyote vya nambari iliyotolewa, isipokuwa nambari yenyewe.\nKipengele ni nambari inayogawanya nambari iliyotolewa bila kuacha baki.\nMifano:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "tr": "Bir Kotlin fonksiyonu `fun listFactors(number: Int): List<Int>` yazın ve aşağıdaki problemi çözün:\nVerilen sayının tüm bölenlerinin bir listesini döndürür, sayının kendisi hariç.\nBir bölen, verilen sayıyı kalansız bölen bir sayıdır.\nÖrnekler:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "vi": "Viết một hàm Kotlin `fun listFactors(number: Int): List<Int>` để giải quyết vấn đề sau:\nTrả về một danh sách tất cả các ước số của số đã cho, ngoại trừ chính số đó.\nMột ước số là một số chia hết cho số đã cho mà không để lại dư.\nVí dụ:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]"
    },
    "instruction_bertscore": {
      "es": "0.9953733025345544",
      "arb": "1",
      "sw": "0.9932030669913672",
      "tr": "0.9613767196685281",
      "vi": "0.9966489068415604"
    },
    "level": "easy",
    "test": "fun main(){\n    check(listFactors(10) == listOf(1, 2, 5))\n    check(listFactors(15) == listOf(1, 3, 5))\n    check(listFactors(7) == listOf(1))\n    check(listFactors(12) == listOf(1, 2, 3, 4, 6))\n    check(listFactors(9) == listOf(1, 3))\n    check(listFactors(17) == listOf(1))\n    check(listFactors(20) == listOf(1, 2, 4, 5, 10))\n}\n\nmain()",
    "entry_point": "listFactors",
    "signature": "fun listFactors(number: Int): List<Int>",
    "docstring": {
      "en": "Returns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "es": "Devuelve una lista de todos los factores del número dado, excluyendo el propio número.  \nUn factor es un número que divide al número dado sin dejar un residuo.  \nEjemplos:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]",
      "arb": "يعيد قائمة بجميع عوامل الرقم المعطى، باستثناء الرقم نفسه.\nالعامل هو رقم يقسم الرقم المعطى دون ترك باقي.\nأمثلة:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "sw": "Inarudisha orodha ya vipengele vyote vya nambari iliyotolewa, isipokuwa nambari yenyewe. \nKipengele ni nambari inayogawanya nambari iliyotolewa bila kuacha baki. \nMifano:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "tr": "Verilen sayının kendisi hariç tüm çarpanlarının bir listesini döndürür.  \nBir çarpan, verilen sayıyı kalan bırakmadan bölen bir sayıdır.  \nÖrnekler:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]",
      "vi": "Trả về danh sách tất cả các ước số của số đã cho, ngoại trừ chính số đó.  \nMột ước số là một số chia hết cho số đã cho mà không để lại dư.  \nVí dụ:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]  "
    },
    "docstring_bertscore": {
      "es": "0.9960708924327488",
      "arb": "1",
      "sw": "0.9931073271477083",
      "tr": "0.9765347999364434",
      "vi": "0.9456614811818098"
    }
  },
  {
    "task_id": "Kotlin/15",
    "prompt": {
      "en": "import java.util.LinkedList\n\n/**\n    * Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n    * \n    * The process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\n    * the current number is removed from the sequence. This process continues until only one number remains in the sequence.\n    *\n    * Examples:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "es": "import java.util.LinkedList\n\n/**\n    * Encuentra el último número restante en una secuencia de n números, donde los números se eliminan en un ciclo de cada tercer elemento.\n    * \n    * El proceso comienza con el primer elemento en una secuencia de 1 a n, contando hasta tres. Cada vez que la cuenta llega a tres,\n    * el número actual se elimina de la secuencia. Este proceso continúa hasta que solo queda un número en la secuencia.\n    *\n    * Ejemplos:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "arb": "import java.util.LinkedList\n\n/**\n    * يجد الرقم الأخير المتبقي في تسلسل من n أرقام، حيث يتم إقصاء الأرقام في دورة كل عنصر ثالث.\n    * \n    * تبدأ العملية بالعنصر الأول في تسلسل من 1 إلى n، مع العد حتى ثلاثة. في كل مرة يصل العد إلى ثلاثة،\n    * يتم إزالة الرقم الحالي من التسلسل. تستمر هذه العملية حتى يبقى رقم واحد فقط في التسلسل.\n    *\n    * أمثلة:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "sw": "import java.util.LinkedList\n\n/**\n    * Inapata nambari ya mwisho iliyobaki katika mlolongo wa nambari n, ambapo nambari zinaondolewa katika mzunguko wa kila kipengele cha tatu.\n    * \n    * Mchakato huanza na kipengele cha kwanza katika mlolongo kutoka 1 hadi n, ukihesabu hadi tatu. Kila wakati hesabu inapofikia tatu,\n    * nambari ya sasa inaondolewa kutoka kwenye mlolongo. Mchakato huu unaendelea hadi nambari moja tu ibaki katika mlolongo.\n    *\n    * Mifano:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "tr": "import java.util.LinkedList\n\n/**\n    * n sayısından oluşan bir dizide, her üçüncü elemanın döngüsel olarak elenmesiyle kalan son sayıyı bulur.\n    * \n    * İşlem, 1'den n'e kadar olan bir dizideki ilk elemanla başlar ve üçe kadar sayılır. Her sayım üçe ulaştığında,\n    * mevcut sayı diziden çıkarılır. Bu işlem, dizide sadece bir sayı kalana kadar devam eder.\n    *\n    * Örnekler:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "vi": "import java.util.LinkedList\n\n/**\n    * Tìm số cuối cùng còn lại trong một dãy số n, nơi các số bị loại bỏ theo chu kỳ cứ mỗi phần tử thứ ba.\n    * \n    * Quá trình bắt đầu với phần tử đầu tiên trong một dãy từ 1 đến n, đếm đến ba. Mỗi khi đếm đến ba,\n    * số hiện tại sẽ bị loại bỏ khỏi dãy. Quá trình này tiếp tục cho đến khi chỉ còn một số duy nhất trong dãy.\n    *\n    * Ví dụ:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9961986117677543",
      "arb": "0.9911196329246922",
      "sw": "0.9829152050360461",
      "tr": "0.9275720137505815",
      "vi": "0.9560113158160136"
    },
    "canonical_solution": "{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findLastRemaining(n: Int): Int` to solve the following problem:\nFinds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "es": "Escribe una función en Kotlin `fun findLastRemaining(n: Int): Int` para resolver el siguiente problema:\nEncuentra el último número restante en una secuencia de n números, donde los números se eliminan en un ciclo de cada tercer elemento.\n\nEl proceso comienza con el primer elemento en una secuencia del 1 al n, contando hasta tres. Cada vez que la cuenta llega a tres,\nel número actual se elimina de la secuencia. Este proceso continúa hasta que solo queda un número en la secuencia.\n\nEjemplos:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "arb": "اكتب دالة Kotlin `fun findLastRemaining(n: Int): Int` لحل المشكلة التالية: \n\nتجد الرقم الأخير المتبقي في تسلسل من n أرقام، حيث يتم إقصاء الأرقام في دورة كل عنصر ثالث.\n\nتبدأ العملية مع العنصر الأول في تسلسل من 1 إلى n، مع العد حتى ثلاثة. في كل مرة يصل العد إلى ثلاثة، يتم إزالة الرقم الحالي من التسلسل. تستمر هذه العملية حتى يبقى رقم واحد فقط في التسلسل.\n\nأمثلة:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "sw": "Andika kazi ya Kotlin `fun findLastRemaining(n: Int): Int` kutatua tatizo lifuatalo: \n\nInapata nambari ya mwisho iliyobaki katika mlolongo wa nambari n, ambapo nambari zinaondolewa katika mzunguko wa kila kipengele cha tatu.\n\nMchakato huanza na kipengele cha kwanza katika mlolongo kutoka 1 hadi n, ukihesabu hadi tatu. Kila wakati hesabu inapofikia tatu, nambari ya sasa huondolewa kutoka kwenye mlolongo. Mchakato huu unaendelea hadi nambari moja tu ibaki katika mlolongo.\n\nMifano:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "tr": "Bir Kotlin fonksiyonu `fun findLastRemaining(n: Int): Int` yazarak aşağıdaki problemi çözün:\nn sayısından oluşan bir dizide, her üçüncü elemanın bir döngü içinde elendiği durumda son kalan sayıyı bulun.\n\nİşlem, 1'den n'e kadar olan bir dizideki ilk elemanla başlar ve üçe kadar sayılır. Her sayma üçe ulaştığında,\nmevcut sayı diziden çıkarılır. Bu işlem, dizide sadece bir sayı kalana kadar devam eder.\n\nÖrnekler:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "vi": "Viết một hàm Kotlin `fun findLastRemaining(n: Int): Int` để giải quyết vấn đề sau:  \nTìm số cuối cùng còn lại trong một dãy số n, nơi các số bị loại bỏ theo chu kỳ của mỗi phần tử thứ ba.\n\nQuá trình bắt đầu với phần tử đầu tiên trong một dãy từ 1 đến n, đếm đến ba. Mỗi khi đếm đến ba, số hiện tại sẽ bị loại khỏi dãy. Quá trình này tiếp tục cho đến khi chỉ còn một số duy nhất trong dãy.\n\nVí dụ:  \n>>> findLastRemaining(5)  \n4  \n>>> findLastRemaining(10)  \n4  "
    },
    "instruction_bertscore": {
      "es": "0.9878744097593443",
      "arb": "0.9877891973258802",
      "sw": "0.9911400918539388",
      "tr": "0.939918282344567",
      "vi": "0.9651425530625685"
    },
    "level": "easy",
    "test": "fun main(){\n    check(findLastRemaining(5) == 4)\n    check(findLastRemaining(10) == 4)\n    check(findLastRemaining(6) == 1)\n    check(findLastRemaining(7) == 4)\n    check(findLastRemaining(15) == 5)\n    check(findLastRemaining(20) == 20)\n    check(findLastRemaining(1) == 1)\n}\nmain()",
    "entry_point": "findLastRemaining",
    "signature": "fun findLastRemaining(n: Int): Int",
    "docstring": {
      "en": "Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "es": "Encuentra el último número restante en una secuencia de n números, donde los números se eliminan en un ciclo de cada tercer elemento.\n\nEl proceso comienza con el primer elemento en una secuencia de 1 a n, contando hasta tres. Cada vez que la cuenta llega a tres,\nel número actual se elimina de la secuencia. Este proceso continúa hasta que solo queda un número en la secuencia.\n\nEjemplos:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "arb": "يعثر على الرقم الأخير المتبقي في تسلسل من n أرقام، حيث يتم إقصاء الأرقام في دورة كل عنصر ثالث.\n\nتبدأ العملية مع العنصر الأول في تسلسل من 1 إلى n، حيث يتم العد حتى ثلاثة. في كل مرة يصل العد إلى ثلاثة، يتم إزالة الرقم الحالي من التسلسل. تستمر هذه العملية حتى يبقى رقم واحد فقط في التسلسل.\n\nأمثلة:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "sw": "Inapata nambari ya mwisho iliyobaki katika mlolongo wa nambari n, ambapo nambari zinaondolewa katika mzunguko wa kila kipengele cha tatu.\n\nMchakato huanza na kipengele cha kwanza katika mlolongo kutoka 1 hadi n, ukihesabu hadi tatu. Kila wakati hesabu inapofikia tatu,\nnambari ya sasa inaondolewa kutoka kwenye mlolongo. Mchakato huu unaendelea hadi nambari moja tu ibaki katika mlolongo.\n\nMifano:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "tr": "Son kalan sayıyı, her üçüncü elemanın bir döngü içinde elendiği n sayılık bir dizide bulur.\n\nİşlem, 1'den n'e kadar olan bir dizideki ilk elemanla başlar ve üçe kadar sayılır. Her seferinde sayma üçe ulaştığında, mevcut sayı diziden çıkarılır. Bu işlem, dizide yalnızca bir sayı kalana kadar devam eder.\n\nÖrnekler:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "vi": "Tìm số cuối cùng còn lại trong một dãy gồm n số, trong đó các số bị loại bỏ theo chu kỳ mỗi phần tử thứ ba.\n\nQuá trình bắt đầu với phần tử đầu tiên trong một dãy từ 1 đến n, đếm đến ba. Mỗi khi đếm đến ba, số hiện tại sẽ bị loại khỏi dãy. Quá trình này tiếp tục cho đến khi chỉ còn một số duy nhất trong dãy.\n\nVí dụ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9876519437325851",
      "arb": "0.9901749468324903",
      "sw": "0.9873730666776122",
      "tr": "0.9373203955910118",
      "vi": "0.9473921476917667"
    }
  },
  {
    "task_id": "Kotlin/16",
    "prompt": {
      "en": "/**\n    * Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\n    * starting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\n    Examples:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "es": "/**\n    * Extrae una secuencia específica de 4 bits de la representación binaria de un número entero decimal positivo dado,\n    * comenzando desde el 4º bit hasta el 7º bit (contando desde 0 desde la derecha), y luego devuelve su valor decimal.\n    Ejemplos:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "arb": "/**\n    * يستخرج تسلسلًا محددًا من 4 بتات من التمثيل الثنائي لعدد عشري موجب معين،\n    * بدءًا من البت الرابع إلى البت السابع (يتم العد من 0 من اليمين)، ثم يعيد قيمته العشرية.\n    أمثلة:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/ \n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "sw": "/**\n    * Hutoa mlolongo maalum wa biti 4 kutoka kwenye uwakilishi wa binary wa nambari ya desimali chanya iliyotolewa,\n    * kuanzia biti ya 4 hadi biti ya 7 (kuhesabu kutoka 0 kutoka kulia), na kisha inarudisha thamani yake ya desimali.\n    Mifano:\n    >>> extractAndConvertToDecimal(173) // Binary ya 173 ni 10101101, biti 4-7 ni 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary ya 59 ni 111011, biti 4-7 ni 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "tr": "/**\n    * Belirli bir pozitif ondalık tam sayının ikili gösteriminden, sağdan 0'dan başlayarak 4. bitten 7. bite kadar olan\n    * belirli bir 4 bitlik diziyi çıkarır ve ardından onun ondalık değerini döndürür.\n    Örnekler:\n    >>> extractAndConvertToDecimal(173) // 173'ün ikilisi 10101101'dir, 4-7 bitleri 1010'dır\n        10\n    >>> extractAndConvertToDecimal(59) // 59'un ikilisi 111011'dir, 4-7 bitleri 0011'dir\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "vi": "/**\n    * Trích xuất một chuỗi 4 bit cụ thể từ biểu diễn nhị phân của một số nguyên dương cho trước,\n    * bắt đầu từ bit thứ 4 đến bit thứ 7 (đếm từ 0 từ bên phải), và sau đó trả về giá trị thập phân của nó.\n    Ví dụ:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9941771503799622",
      "arb": "0.9716766980770922",
      "sw": "0.9643504151030013",
      "tr": "0.9639992365893317",
      "vi": "0.9802172085704492"
    },
    "canonical_solution": "{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun extractAndConvertToDecimal(number: Int): Int` to solve the following problem:\nExtracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "es": "Escribe una función de Kotlin `fun extractAndConvertToDecimal(number: Int): Int` para resolver el siguiente problema:\nExtrae una secuencia específica de 4 bits de la representación binaria de un número entero decimal positivo dado,\ncomenzando desde el 4º bit hasta el 7º bit (contando desde 0 desde la derecha), y luego devuelve su valor decimal.\nEjemplos:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "arb": "اكتب دالة Kotlin `fun extractAndConvertToDecimal(number: Int): Int` لحل المشكلة التالية:\nتستخرج تسلسل محدد من 4 بتات من التمثيل الثنائي لعدد صحيح عشري موجب معين، بدءًا من البت الرابع إلى البت السابع (يتم العد من 0 من اليمين)، ثم تعيد قيمته العشرية.\nأمثلة:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "sw": "Andika kazi ya Kotlin `fun extractAndConvertToDecimal(number: Int): Int` kutatua tatizo lifuatalo:\nInachukua mlolongo maalum wa biti 4 kutoka kwenye uwakilishi wa binary wa namba ya desimali chanya iliyotolewa,\nkuanzia biti ya 4 hadi biti ya 7 (kuhesabu kutoka 0 kutoka kulia), kisha inarudisha thamani yake ya desimali.\nMifano:\n>>> extractAndConvertToDecimal(173) // Binary ya 173 ni 10101101, biti 4-7 ni 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary ya 59 ni 111011, biti 4-7 ni 0011\n3",
      "tr": "Bir Kotlin fonksiyonu `fun extractAndConvertToDecimal(number: Int): Int` yazın ve aşağıdaki problemi çözün:\nVerilen pozitif ondalık bir tam sayının ikili gösteriminden belirli bir 4 bitlik diziyi çıkarır, sağdan 0'dan sayarak 4. bitten 7. bite kadar olan kısmı alır ve ardından onun ondalık değerini döndürür.\nÖrnekler:\n>>> extractAndConvertToDecimal(173) // 173'ün ikilisi 10101101'dir, bitler 4-7 arası 1010'dır\n10\n>>> extractAndConvertToDecimal(59) // 59'un ikilisi 111011'dir, bitler 4-7 arası 0011'dir\n3",
      "vi": "Viết một hàm Kotlin `fun extractAndConvertToDecimal(number: Int): Int` để giải quyết vấn đề sau:\nTrích xuất một dãy 4 bit cụ thể từ biểu diễn nhị phân của một số nguyên thập phân dương đã cho, bắt đầu từ bit thứ 4 đến bit thứ 7 (đếm từ 0 từ bên phải), và sau đó trả về giá trị thập phân của nó.\nVí dụ:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3"
    },
    "instruction_bertscore": {
      "es": "0.9896543366037979",
      "arb": "0.9741778518350835",
      "sw": "0.9606413899979369",
      "tr": "0.9599561151833665",
      "vi": "0.9938847664590789"
    },
    "level": "easy",
    "test": "fun main(){\n    check(extractAndConvertToDecimal(217) == 13)  // 173 in binary is 10101101, bits 4-7 are 1101\n    check(extractAndConvertToDecimal(173) == 10)  // 173 in binary is 10101101, bits 4-7 are 1010\n    check(extractAndConvertToDecimal(59) == 3)    // 59 in binary is 111011, bits 4-7 are 0011\n    check(extractAndConvertToDecimal(32) == 2)    // 32 in binary is 100000, bits 4-7 are 0010\n    check(extractAndConvertToDecimal(255) == 15)  // 255 in binary is 11111111, bits 4-7 are 1111\n    check(extractAndConvertToDecimal(1) == 0)     // 1 in binary is 1, bits 4-7 are 0000\n\n}\n\nmain()",
    "entry_point": "extractAndConvertToDecimal",
    "signature": "fun extractAndConvertToDecimal(number: Int): Int",
    "docstring": {
      "en": "Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "es": "Extrae una secuencia específica de 4 bits de la representación binaria de un número entero decimal positivo dado, comenzando desde el cuarto bit hasta el séptimo bit (contando desde 0 desde la derecha), y luego devuelve su valor decimal.  \nEjemplos:  \n>>> extractAndConvertToDecimal(173) // Binario de 173 es 10101101, bits 4-7 son 1010  \n10  \n>>> extractAndConvertToDecimal(59) // Binario de 59 es 111011, bits 4-7 son 0011  \n3  ",
      "arb": "يستخرج تسلسل مكون من 4 بتات محددة من التمثيل الثنائي لعدد صحيح عشري موجب معين، بدءًا من البت الرابع إلى البت السابع (يتم العد من 0 من اليمين)، ثم يعيد قيمته العشرية.\nأمثلة:\n>>> extractAndConvertToDecimal(173) // الثنائي لـ 173 هو 10101101، البتات 4-7 هي 1010\n10\n>>> extractAndConvertToDecimal(59) // الثنائي لـ 59 هو 111011، البتات 4-7 هي 0011\n3",
      "sw": "Hutoa mlolongo maalum wa biti 4 kutoka kwa uwakilishi wa binary wa nambari kamili chanya iliyotolewa, kuanzia biti ya 4 hadi biti ya 7 (kuhesabu kutoka 0 kutoka kulia), kisha inarudisha thamani yake ya desimali. \nMifano:\n>>> extractAndConvertToDecimal(173) // Binary ya 173 ni 10101101, biti 4-7 ni 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary ya 59 ni 111011, biti 4-7 ni 0011\n3",
      "tr": "Belirtilen pozitif ondalık tam sayının ikili gösteriminden, sağdan 0'dan başlayarak 4. bitten 7. bite kadar olan belirli bir 4 bitlik diziyi çıkarır ve ardından ondalık değerini döndürür.\nÖrnekler:\n>>> extractAndConvertToDecimal(173) // 173'ün ikilisi 10101101'dir, 4-7 bitleri 1010'dır\n10\n>>> extractAndConvertToDecimal(59) // 59'un ikilisi 111011'dir, 4-7 bitleri 0011'dir\n3",
      "vi": "Trích xuất một chuỗi 4-bit cụ thể từ biểu diễn nhị phân của một số nguyên thập phân dương đã cho, bắt đầu từ bit thứ 4 đến bit thứ 7 (đếm từ 0 từ bên phải), và sau đó trả về giá trị thập phân của nó. \n\nVí dụ:\n>>> extractAndConvertToDecimal(173) // Nhị phân của 173 là 10101101, các bit 4-7 là 1010\n10\n>>> extractAndConvertToDecimal(59) // Nhị phân của 59 là 111011, các bit 4-7 là 0011\n3"
    },
    "docstring_bertscore": {
      "es": "0.9709518958166958",
      "arb": "0.9650249638769959",
      "sw": "0.9643659082727221",
      "tr": "0.9214198349587879",
      "vi": "0.9865850999560467"
    }
  },
  {
    "task_id": "Kotlin/17",
    "prompt": {
      "en": "/**\n * Performs a right circular shift on a given unsigned 32-bit integer.\n * The function shifts the bits of the input number to the right by a specified number of positions.\n * The bits that are shifted out on the right are reinserted on the left side.\n * \n * Example:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "es": "/**\n * Realiza un desplazamiento circular a la derecha en un entero sin signo de 32 bits dado.\n * La función desplaza los bits del número de entrada hacia la derecha por un número especificado de posiciones.\n * Los bits que se desplazan hacia afuera por la derecha se reinserta en el lado izquierdo.\n * \n * Ejemplo:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "arb": "/**\n * يقوم بإجراء إزاحة دائرية لليمين على عدد صحيح غير موقع 32 بت.\n * تقوم الدالة بإزاحة بتات الرقم المدخل إلى اليمين بعدد محدد من المواضع.\n * يتم إعادة إدخال البتات التي تم إزاحتها إلى الخارج على اليمين إلى الجانب الأيسر.\n * \n * مثال:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */ \nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "sw": "/**\n * Inafanya mzunguko wa kulia kwenye nambari iliyotolewa ya biti 32 isiyo na ishara.\n * Kazi inasogeza biti za nambari ya ingizo kwenda kulia kwa nafasi maalum.\n * Biti ambazo zinasogezwa nje upande wa kulia zinaingizwa tena upande wa kushoto.\n * \n * Mfano:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "tr": "/**\n * Belirtilen bir işaretsiz 32-bit tam sayı üzerinde sağa dairesel kaydırma işlemi gerçekleştirir.\n * Fonksiyon, giriş numarasının bitlerini belirtilen pozisyon sayısı kadar sağa kaydırır.\n * Sağdan dışarı kaydırılan bitler, sol tarafa yeniden eklenir.\n * \n * Örnek:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "vi": "/**\n * Thực hiện dịch vòng sang phải trên một số nguyên không dấu 32-bit cho trước.\n * Hàm này dịch các bit của số đầu vào sang phải theo số vị trí được chỉ định.\n * Các bit bị dịch ra bên phải sẽ được chèn lại vào phía bên trái.\n * \n * Ví dụ:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt "
    },
    "prompt_bertscore": {
      "es": "0.9975796888070899",
      "arb": "0.9847428031719482",
      "sw": "0.9805223048357189",
      "tr": "0.9760511349586235",
      "vi": "0.9723125139267849"
    },
    "canonical_solution": "{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun circularRightShift(num: UInt, shift: Int): UInt` to solve the following problem:\nPerforms a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "es": "Escribe una función de Kotlin `fun circularRightShift(num: UInt, shift: Int): UInt` para resolver el siguiente problema:\nRealiza un desplazamiento circular a la derecha en un entero sin signo de 32 bits dado.\nLa función desplaza los bits del número de entrada a la derecha por un número especificado de posiciones.\nLos bits que se desplazan hacia afuera por la derecha se reintegran en el lado izquierdo.\n\nEjemplo:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "arb": "اكتب دالة في كوتلن `fun circularRightShift(num: UInt, shift: Int): UInt` لحل المشكلة التالية:\nتنفذ إزاحة دائرية لليمين على عدد صحيح غير موقع مكون من 32 بت.\nتقوم الدالة بإزاحة بتات العدد المدخل إلى اليمين بعدد محدد من المواضع.\nيتم إعادة إدخال البتات التي يتم إزاحتها على اليمين إلى الجانب الأيسر.\n\nمثال:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "sw": "Andika kazi ya Kotlin `fun circularRightShift(num: UInt, shift: Int): UInt` kutatua tatizo lifuatalo:\nInafanya mzunguko wa kulia kwenye nambari iliyotolewa ya biti 32 isiyo na ishara.\nKazi inahamisha biti za nambari ya ingizo kwenda kulia kwa idadi maalum ya nafasi.\nBiti ambazo zinahamishwa nje upande wa kulia zinaingizwa tena upande wa kushoto.\n\nMfano:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "tr": "Bir Kotlin fonksiyonu `fun circularRightShift(num: UInt, shift: Int): UInt` yazın:\nVerilen bir işaretsiz 32-bit tamsayı üzerinde sağa dairesel kaydırma işlemi gerçekleştirir.\nFonksiyon, giriş numarasının bitlerini belirtilen pozisyon sayısı kadar sağa kaydırır.\nSağdan dışarı kaydırılan bitler, sol tarafa yeniden eklenir.\n\nÖrnek:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "vi": "Viết một hàm Kotlin `fun circularRightShift(num: UInt, shift: Int): UInt` để giải quyết vấn đề sau:\nThực hiện dịch vòng sang phải trên một số nguyên không dấu 32-bit đã cho.\nHàm dịch các bit của số đầu vào sang phải theo số vị trí được chỉ định.\nCác bit bị dịch ra bên phải sẽ được chèn lại vào phía bên trái.\n\nVí dụ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u"
    },
    "instruction_bertscore": {
      "es": "0.9844675014638338",
      "arb": "0.9845846933886444",
      "sw": "0.9823238823917053",
      "tr": "0.9514879061487062",
      "vi": "0.9745512769514291"
    },
    "level": "easy",
    "test": "fun main() {\n    check(circularRightShift(1023u, 20) == 4190208u)\n    check(circularRightShift(15u, 2) == 3221225475u)\n    check(circularRightShift(256u, 8) == 1u)\n    check(circularRightShift(123u, 5) == 3623878659u)\n    check(circularRightShift(4294967295u, 1) == 4294967295u)\n    check(circularRightShift(1024u, 10) == 1u)\n    check(circularRightShift(0u, 15) == 0u)\n}\nmain()",
    "entry_point": "circularRightShift",
    "signature": "fun circularRightShift(num: UInt, shift: Int): UInt",
    "docstring": {
      "en": "Performs a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "es": "Realiza un desplazamiento circular a la derecha en un entero sin signo de 32 bits dado.  \nLa función desplaza los bits del número de entrada hacia la derecha por un número especificado de posiciones.  \nLos bits que se desplazan hacia fuera por la derecha se reintegran en el lado izquierdo.  \n\nEjemplo:  \n>>> circularRightShift(1023u, 20)  \n4190208u  \n>>> circularRightShift(15u, 2)  \n3221225475u  \n>>> circularRightShift(256u, 8)  \n1u  ",
      "arb": "ينفذ عملية تدوير دائري لليمين على عدد صحيح غير موقع مكون من 32 بت.\nتقوم الدالة بتحريك البتات للعدد المدخل إلى اليمين بعدد محدد من المواضع.\nيتم إعادة إدخال البتات التي تُحرك خارجًا من اليمين إلى الجانب الأيسر.\n\nمثال:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "sw": "Inafanya mzunguko wa kulia kwenye nambari kamili isiyotiwa sahihi ya biti 32.\nKazi hii inasogeza biti za nambari ya pembejeo kwenda kulia kwa nafasi maalum.\nBiti ambazo zinasogezwa nje upande wa kulia zinaingizwa tena upande wa kushoto.\n\nMfano:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "tr": "Verilen işaretsiz 32 bitlik bir tam sayı üzerinde sağa dairesel kaydırma gerçekleştirir.\nFonksiyon, giriş numarasının bitlerini belirtilen pozisyon sayısı kadar sağa kaydırır.\nSağdan dışarı kaydırılan bitler, sol tarafa yeniden eklenir.\n\nÖrnek:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "vi": "Thực hiện dịch vòng tròn sang phải trên một số nguyên không dấu 32-bit cho trước. Hàm này dịch các bit của số đầu vào sang phải theo số vị trí được chỉ định. Các bit bị dịch ra bên phải sẽ được chèn lại vào phía bên trái.\n\nVí dụ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u"
    },
    "docstring_bertscore": {
      "es": "0.9857317838391209",
      "arb": "0.9712482523452",
      "sw": "0.9645067372128758",
      "tr": "0.9650438337631941",
      "vi": "0.958558551822405"
    }
  },
  {
    "task_id": "Kotlin/18",
    "prompt": {
      "en": "/**\n    * Determines if a given integer is a perfect number. A perfect number is one whose\n    * sum of all positive divisors (excluding itself) equals the number itself.\n    * \n    * Examples:\n    * - isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "es": "/**\n    * Determina si un entero dado es un número perfecto. Un número perfecto es aquel cuya\n    * suma de todos los divisores positivos (excluyéndose a sí mismo) es igual al número mismo.\n    * \n    * Ejemplos:\n    * - isPerfectNumber(6) devuelve true porque 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) devuelve true porque 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) devuelve false porque 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "arb": "/**\n    * يحدد ما إذا كان عدد صحيح معين هو عدد مثالي. العدد المثالي هو الذي\n    * مجموع جميع القواسم الموجبة (باستثناء نفسه) يساوي العدد نفسه.\n    * \n    * أمثلة:\n    * - isPerfectNumber(6) يعيد true لأن 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) يعيد true لأن 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) يعيد false لأن 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "sw": "/**\n    * Huamua ikiwa nambari iliyotolewa ni nambari kamilifu. Nambari kamilifu ni ile ambayo\n    * jumla ya wagawanyaji wote chanya (isipokuwa yenyewe) ni sawa na nambari yenyewe.\n    * \n    * Mifano:\n    * - isPerfectNumber(6) inarudisha true kwa sababu 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) inarudisha true kwa sababu 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) inarudisha false kwa sababu 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "tr": "/**\n    * Verilen bir tam sayının mükemmel sayı olup olmadığını belirler. Mükemmel sayı, \n    * tüm pozitif bölenlerinin (kendisi hariç) toplamı sayının kendisine eşit olan sayıdır.\n    * \n    * Örnekler:\n    * - isPerfectNumber(6) true döndürür çünkü 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) true döndürür çünkü 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) false döndürür çünkü 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "vi": "/**\n    * Xác định xem một số nguyên cho trước có phải là số hoàn hảo hay không. Một số hoàn hảo là\n    * tổng của tất cả các ước dương (không bao gồm chính nó) bằng chính số đó.\n    * \n    * Ví dụ:\n    * - isPerfectNumber(6) trả về true vì 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) trả về true vì 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) trả về false vì 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean "
    },
    "prompt_bertscore": {
      "es": "0.9891815962969348",
      "arb": "0.9955635904395858",
      "sw": "0.9869992443005045",
      "tr": "0.97266091161512",
      "vi": "0.9760265047913752"
    },
    "canonical_solution": "{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun isPerfectNumber(number: Int): Boolean` to solve the following problem:\nDetermines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10",
      "es": "Escribe una función en Kotlin `fun isPerfectNumber(number: Int): Boolean` para resolver el siguiente problema:\nDetermina si un entero dado es un número perfecto. Un número perfecto es aquel cuya\nsuma de todos los divisores positivos (excluyéndose a sí mismo) es igual al propio número.\n\nEjemplos:\n- isPerfectNumber(6) devuelve true porque 1 + 2 + 3 = 6\n- isPerfectNumber(28) devuelve true porque 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) devuelve false porque 1 + 2 + 5 ≠ 10",
      "arb": "اكتب دالة Kotlin `fun isPerfectNumber(number: Int): Boolean` لحل المشكلة التالية:\nتحديد ما إذا كان عدد صحيح معين هو عدد مثالي. العدد المثالي هو الذي يكون مجموع جميع القواسم الموجبة له (باستثناء نفسه) يساوي العدد نفسه.\n\nأمثلة:\n- isPerfectNumber(6) تعيد true لأن 1 + 2 + 3 = 6\n- isPerfectNumber(28) تعيد true لأن 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) تعيد false لأن 1 + 2 + 5 ≠ 10",
      "sw": "Andika kazi ya Kotlin `fun isPerfectNumber(number: Int): Boolean` kutatua tatizo lifuatalo:  \nInabainisha ikiwa nambari kamili iliyotolewa ni nambari kamili. Nambari kamili ni ile ambayo  \njumla ya wagawanyaji wote chanya (isipokuwa yenyewe) ni sawa na nambari yenyewe.\n\nMifano:  \n- isPerfectNumber(6) inarudisha true kwa sababu 1 + 2 + 3 = 6  \n- isPerfectNumber(28) inarudisha true kwa sababu 1 + 2 + 4 + 7 + 14 = 28  \n- isPerfectNumber(10) inarudisha false kwa sababu 1 + 2 + 5 ≠ 10  ",
      "tr": "Bir Kotlin fonksiyonu `fun isPerfectNumber(number: Int): Boolean` yazın ve aşağıdaki problemi çözün:\nVerilen bir tam sayının mükemmel bir sayı olup olmadığını belirler. Mükemmel bir sayı, tüm pozitif bölenlerinin (kendisi hariç) toplamının sayının kendisine eşit olduğu bir sayıdır.\n\nÖrnekler:\n- isPerfectNumber(6) true döndürür çünkü 1 + 2 + 3 = 6\n- isPerfectNumber(28) true döndürür çünkü 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false döndürür çünkü 1 + 2 + 5 ≠ 10",
      "vi": "Viết một hàm Kotlin `fun isPerfectNumber(number: Int): Boolean` để giải quyết vấn đề sau:\nXác định xem một số nguyên cho trước có phải là số hoàn hảo hay không. Một số hoàn hảo là số có tổng của tất cả các ước dương (không bao gồm chính nó) bằng chính số đó.\n\nVí dụ:\n- isPerfectNumber(6) trả về true vì 1 + 2 + 3 = 6\n- isPerfectNumber(28) trả về true vì 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) trả về false vì 1 + 2 + 5 ≠ 10"
    },
    "instruction_bertscore": {
      "es": "0.9834737536675162",
      "arb": "0.9909648998578661",
      "sw": "0.9843401793895904",
      "tr": "0.9706174022550331",
      "vi": "0.9670776102346104"
    },
    "level": "easy",
    "test": "fun main(){\n    check(isPerfectNumber(1) == false)  // 6 is a perfect number\n    check(isPerfectNumber(6) == true)  // 6 is a perfect number\n    check(isPerfectNumber(28) == true)  // 28 is a perfect number\n    check(isPerfectNumber(10) == false)  // 10 is not a perfect number\n    check(isPerfectNumber(496) == true)  // 496 is a perfect number\n    check(isPerfectNumber(8128) == true)  // 8128 is a perfect number\n    check(isPerfectNumber(15) == false)  // 15 is not a perfect number\n    check(isPerfectNumber(20) == false)  // 20 is not a perfect number\n\n\n}\nmain()",
    "entry_point": "isPerfectNumber",
    "signature": "fun isPerfectNumber(number: Int): Boolean",
    "docstring": {
      "en": "Determines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10",
      "es": "Determina si un número entero dado es un número perfecto. Un número perfecto es aquel cuya suma de todos los divisores positivos (excluyéndose a sí mismo) es igual al número mismo.\n\nEjemplos:\n- isPerfectNumber(6) devuelve true porque 1 + 2 + 3 = 6\n- isPerfectNumber(28) devuelve true porque 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) devuelve false porque 1 + 2 + 5 ≠ 10",
      "arb": "يحدد ما إذا كان العدد الصحيح المعطى هو عدد مثالي. العدد المثالي هو الذي يكون مجموع جميع القواسم الموجبة له (باستثناء نفسه) يساوي العدد نفسه.\n\nأمثلة:\n- isPerfectNumber(6) يعيد true لأن 1 + 2 + 3 = 6\n- isPerfectNumber(28) يعيد true لأن 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) يعيد false لأن 1 + 2 + 5 ≠ 10",
      "sw": "Inabainisha ikiwa nambari kamili ni kamilifu. Nambari kamilifu ni ile ambayo jumla ya wagawanyaji wote chanya (isipokuwa yenyewe) ni sawa na nambari yenyewe.\n\nMifano:\n- isPerfectNumber(6) inarudisha kweli kwa sababu 1 + 2 + 3 = 6\n- isPerfectNumber(28) inarudisha kweli kwa sababu 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) inarudisha uongo kwa sababu 1 + 2 + 5 ≠ 10",
      "tr": "Verilen bir tam sayının mükemmel bir sayı olup olmadığını belirler. Mükemmel sayı, tüm pozitif bölenlerinin (kendisi hariç) toplamı sayının kendisine eşit olan bir sayıdır.\n\nÖrnekler:\n- isPerfectNumber(6) true döndürür çünkü 1 + 2 + 3 = 6\n- isPerfectNumber(28) true döndürür çünkü 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false döndürür çünkü 1 + 2 + 5 ≠ 10",
      "vi": "Xác định xem một số nguyên cho trước có phải là số hoàn hảo hay không. Một số hoàn hảo là số có tổng tất cả các ước dương (không bao gồm chính nó) bằng chính số đó.\n\nVí dụ:\n- isPerfectNumber(6) trả về true vì 1 + 2 + 3 = 6\n- isPerfectNumber(28) trả về true vì 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) trả về false vì 1 + 2 + 5 ≠ 10"
    },
    "docstring_bertscore": {
      "es": "0.9875212449418642",
      "arb": "0.9917252569564676",
      "sw": "0.9850409473738815",
      "tr": "0.9689838660014022",
      "vi": "0.9854245026396599"
    }
  },
  {
    "task_id": "Kotlin/19",
    "prompt": {
      "en": "\n/**\n * Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\n * Example:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "es": "/**\n * El tiempo pasó rápidamente, y Wang Wang había alcanzado la edad de meses para la vacunación. Wang Wang vino al hospital y quería darse una inyección de vacuna contra la rabia, pero no pudo resistir la tentación del médico. Necesita un total de 4 inyecciones. Primero recibió tres inyecciones de Miao Sanduo, y luego la vacuna contra la rabia. Una inyección de Miao Sanduo cuesta 120 yuanes, y una inyección de vacuna contra la rabia cuesta 100 yuanes. Sin embargo, Wang Wang solo tiene a yuanes de dinero y no puede recibir todas las inyecciones de una vez. En este momento, el médico dijo: \"¿Cómo podemos completar la inyección de una vez? Debe haber un intervalo de un mes entre cada dos inyecciones...\" Así que Wang Wang decidió ahorrar dinero mientras se daba inyecciones (porque Wang Wang es un meow que ama las inyecciones), Wang Wang Si puedo ahorrar B yuanes cada mes, ¿cuántas vacunas puede recibir Wangwang a tiempo?\n * Ejemplo:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "arb": "/**\n * مر الوقت بسرعة، ووصل وانغ وانغ إلى سن الأشهر للتطعيم. جاء وانغ وانغ إلى المستشفى وأراد أن يعطي نفسه حقنة من لقاح داء الكلب، لكنه لم يستطع مقاومة إغراء الطبيب. يحتاج إلى إجمالي 4 حقنات. حصل أولاً على ثلاث حقنات من مياو ساندو، ثم لقاح داء الكلب. تكلف حقنة مياو ساندو 120 يوان، وتكلف حقنة لقاح داء الكلب 100 يوان. ومع ذلك، فإن وانغ وانغ لديه فقط يوان من المال ولا يمكنه أخذ جميع الحقنات دفعة واحدة. في هذا الوقت، قال الطبيب: \"كيف يمكننا إكمال الحقن في وقت واحد؟ يجب أن يكون هناك فاصل زمني لمدة شهر بين كل حقنتين...\" لذلك قرر وانغ وانغ توفير المال أثناء إعطاء نفسه الحقن (لأن وانغ وانغ هو مياو يحب الحقن)، إذا كان بإمكاني توفير B يوان كل شهر، كم عدد الحقنات التي يمكن أن يحصل عليها وانغ وانغ في الوقت المحدد؟\n * مثال:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */ \n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "sw": "/**\n * Muda ulipita haraka, na Wang Wang alikuwa amefikia umri wa miezi kwa ajili ya chanjo. Wang Wang alifika hospitalini na alitaka kujipiga sindano ya chanjo ya kichaa cha mbwa, lakini hakuweza kuzuia kishawishi cha daktari. Anahitaji jumla ya sindano 4. Kwanza alipokea sindano tatu za Miao Sanduo, na kisha chanjo ya kichaa cha mbwa. Sindano moja ya Miao Sanduo inagharimu yuan 120, na sindano moja ya chanjo ya kichaa cha mbwa inagharimu yuan 100. Hata hivyo, Wang Wang ana yuan moja tu ya pesa na hawezi kuchukua sindano zote mara moja. Wakati huu, daktari alisema: \"Tunawezaje kukamilisha sindano kwa wakati mmoja? Inahitaji kuwa na muda wa mwezi mmoja kati ya kila sindano mbili...\" Kwa hiyo Wang Wang aliamua kuokoa pesa wakati akijipiga sindano (kwa sababu Wang Wang ni meow anayependa sindano), Wang Wang Ikiwa naweza kuokoa B yuan kila mwezi, ni chanjo ngapi Wangwang anaweza kupata kwa wakati?\n * Mfano:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "tr": "/**\n * Zaman hızla geçti ve Wang Wang aşı için aylık yaşına ulaştı. Wang Wang hastaneye geldi ve kendisine kuduz aşısı yaptırmak istedi, ancak doktorun cazibesine karşı koyamadı. Toplamda 4 enjeksiyon yapması gerekiyor. Önce üç doz Miao Sanduo aldı, sonra kuduz aşısı. Bir doz Miao Sanduo 120 yuan, bir doz kuduz aşısı 100 yuan. Ancak, Wang Wang'ın sadece bir miktar parası var ve tüm enjeksiyonları bir kerede alamaz. Bu sırada doktor dedi ki: \"Enjeksiyonu bir kerede nasıl tamamlayabiliriz? Her iki enjeksiyon arasında bir ay ara olması gerekiyor...\" Bu yüzden Wang Wang, kendisine enjeksiyon yaparken para biriktirmeye karar verdi (çünkü Wang Wang enjeksiyonları seven bir meow), eğer Wang Wang her ay B yuan biriktirebilirse, Wang Wang zamanında kaç aşı alabilir?\n * Örnek:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "vi": "/**\n * Thời gian trôi qua nhanh chóng, và Wang Wang đã đến tuổi tiêm phòng theo tháng. Wang Wang đến bệnh viện và muốn tự tiêm một mũi vắc-xin dại, nhưng anh không thể cưỡng lại sự cám dỗ của bác sĩ. Anh cần tổng cộng 4 mũi tiêm. Đầu tiên anh nhận ba mũi Miao Sanduo, sau đó là vắc-xin dại. Một mũi Miao Sanduo có giá 120 nhân dân tệ, và một mũi vắc-xin dại có giá 100 nhân dân tệ. Tuy nhiên, Wang Wang chỉ có một số tiền nhân dân tệ và không thể tiêm tất cả các mũi cùng một lúc. Lúc này, bác sĩ nói: \"Làm thế nào để hoàn thành việc tiêm một lần? Cần phải có khoảng cách một tháng giữa mỗi hai lần tiêm...\" Vì vậy, Wang Wang quyết định tiết kiệm tiền trong khi tự tiêm phòng (vì Wang Wang là một chú mèo yêu thích tiêm phòng), nếu Wang Wang có thể tiết kiệm được B nhân dân tệ mỗi tháng, Wang Wang có thể tiêm được bao nhiêu mũi đúng thời gian?\n * Ví dụ:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */ \n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int "
    },
    "prompt_bertscore": {
      "es": "0.9550672256149548",
      "arb": "0.947188948811968",
      "sw": "0.9567275769700254",
      "tr": "0.9096432382976104",
      "vi": "0.9284634669006661"
    },
    "canonical_solution": "{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` to solve the following problem:\nTime passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "es": "Escribe una función de Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` para resolver el siguiente problema:\nEl tiempo pasó rápidamente, y Wang Wang había alcanzado la edad de meses para la vacunación. Wang Wang fue al hospital y quería darse una inyección de vacuna contra la rabia, pero no pudo resistir la tentación del médico. Necesita un total de 4 inyecciones. Primero recibió tres inyecciones de Miao Sanduo, y luego la vacuna contra la rabia. Una inyección de Miao Sanduo cuesta 120 yuanes, y una inyección de vacuna contra la rabia cuesta 100 yuanes. Sin embargo, Wang Wang solo tiene a yuanes de dinero y no puede tomar todas las inyecciones de una vez. En este momento, el médico dijo: \"¿Cómo podemos completar la inyección de una vez? Debe haber un intervalo de un mes entre cada dos inyecciones...\" Así que Wang Wang decidió ahorrar dinero mientras se daba inyecciones (porque Wang Wang es un meow que ama las inyecciones), Wang Wang Si puedo ahorrar B yuanes cada mes, ¿cuántas vacunaciones puede recibir Wangwang a tiempo?\nEjemplo:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "arb": "اكتب دالة Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` لحل المشكلة التالية:\nمر الوقت بسرعة، ووصل وانغ وانغ إلى سن الأشهر للتطعيم. جاء وانغ وانغ إلى المستشفى وأراد أن يأخذ لنفسه حقنة من لقاح داء الكلب، لكنه لم يستطع مقاومة إغراء الطبيب. يحتاج إلى إجمالي 4 حقنات. حصل أولاً على ثلاث حقنات من مياو ساندو، ثم لقاح داء الكلب. تكلفة حقنة مياو ساندو 120 يوان، وتكلفة حقنة لقاح داء الكلب 100 يوان. ومع ذلك، لدى وانغ وانغ فقط يوان من المال ولا يمكنه أخذ جميع الحقنات دفعة واحدة. في هذا الوقت، قال الطبيب: \"كيف يمكننا إكمال الحقن في وقت واحد؟ يجب أن يكون هناك فاصل زمني لمدة شهر بين كل حقنتين...\" لذلك قرر وانغ وانغ توفير المال أثناء إعطاء نفسه الحقن (لأن وانغ وانغ هو مياو يحب الحقن)، إذا كان بإمكان وانغ وانغ توفير B يوان كل شهر، كم عدد التطعيمات التي يمكن لوانغ وانغ الحصول عليها في الوقت المحدد؟\nمثال:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "sw": "Andika kazi ya Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` kutatua tatizo lifuatalo:\nMuda ulipita haraka, na Wang Wang alikuwa amefikia umri wa miezi kwa ajili ya chanjo. Wang Wang alifika hospitalini na alitaka kujidunga sindano ya chanjo ya kichaa cha mbwa, lakini hakuweza kupinga kishawishi cha daktari. Anahitaji sindano 4 kwa jumla. Kwanza alipokea sindano tatu za Miao Sanduo, kisha chanjo ya kichaa cha mbwa. Sindano moja ya Miao Sanduo inagharimu yuan 120, na sindano moja ya chanjo ya kichaa cha mbwa inagharimu yuan 100. Hata hivyo, Wang Wang ana yuan a tu za pesa na hawezi kuchukua sindano zote mara moja. Wakati huu, daktari alisema: \"Je, tunawezaje kukamilisha sindano kwa wakati mmoja? Inahitaji kuwa na muda wa mwezi mmoja kati ya kila sindano mbili...\" Kwa hivyo Wang Wang aliamua kuweka akiba ya pesa wakati anajidunga sindano (kwa sababu Wang Wang ni meow anayependa sindano), Wang Wang Ikiwa naweza kuweka akiba ya yuan B kila mwezi, ni sindano ngapi Wangwang anaweza kupata kwa wakati?\nMfano:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "tr": "Kotlin fonksiyonu `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` aşağıdaki problemi çözmek için yazın:\nZaman hızla geçti ve Wang Wang aşı yaşı olan aylara ulaştı. Wang Wang hastaneye geldi ve kendisine kuduz aşısı yaptırmak istedi, ancak doktorun cazibesine karşı koyamadı. Toplamda 4 enjeksiyona ihtiyacı var. Önce üç doz Miao Sanduo aldı ve ardından kuduz aşısı. Bir doz Miao Sanduo 120 yuan, bir doz kuduz aşısı 100 yuan. Ancak, Wang Wang'ın sadece a yuan parası var ve tüm enjeksiyonları bir kerede yaptıramaz. Bu sırada doktor dedi ki: \"Enjeksiyonu bir kerede nasıl tamamlayabiliriz? Her iki enjeksiyon arasında bir ay ara olmalı...\" Bu yüzden Wang Wang, kendisine enjeksiyon yaparken para biriktirmeye karar verdi (çünkü Wang Wang enjeksiyonları seven bir meow), Wang Wang her ay B yuan biriktirebilirse, Wang Wang zamanında kaç aşı olabilir?\nÖrnek:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "vi": "Viết một hàm Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` để giải quyết vấn đề sau:\nThời gian trôi qua nhanh chóng, và Wang Wang đã đến tuổi tiêm phòng hàng tháng. Wang Wang đến bệnh viện và muốn tự tiêm một mũi vắc-xin dại, nhưng anh không thể cưỡng lại sự cám dỗ của bác sĩ. Anh cần tổng cộng 4 mũi tiêm. Đầu tiên anh nhận ba mũi Miao Sanduo, sau đó là vắc-xin dại. Một mũi Miao Sanduo có giá 120 nhân dân tệ, và một mũi vắc-xin dại có giá 100 nhân dân tệ. Tuy nhiên, Wang Wang chỉ có a nhân dân tệ và không thể tiêm tất cả các mũi cùng một lúc. Lúc này, bác sĩ nói: \"Làm thế nào để hoàn thành việc tiêm một lần? Cần phải có khoảng cách một tháng giữa mỗi hai mũi tiêm...\" Vì vậy, Wang Wang quyết định tiết kiệm tiền trong khi tự tiêm (vì Wang Wang là một chú mèo yêu thích tiêm), Wang Wang nếu có thể tiết kiệm B nhân dân tệ mỗi tháng, Wang Wang có thể tiêm được bao nhiêu mũi đúng hạn?\nVí dụ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4"
    },
    "instruction_bertscore": {
      "es": "0.9624977895390889",
      "arb": "0.9502494457229537",
      "sw": "0.9635429826040945",
      "tr": "0.9392510828946709",
      "vi": "0.9335601238476402"
    },
    "level": "hard",
    "test": "fun main(){\n    check(calculateMaxVaccinations(10, 200) == 0)\n    check(calculateMaxVaccinations(150, 100) == 2)\n    check(calculateMaxVaccinations(500, 100) == 4)\n    check(calculateMaxVaccinations(300, 50) == 3)\n    check(calculateMaxVaccinations(0, 200) == 0)\n    check(calculateMaxVaccinations(100, 20) == 0)\n    check(calculateMaxVaccinations(120, 100) == 1)\n    check(calculateMaxVaccinations(400, 0) == 3)\n\n}\nmain()",
    "entry_point": "calculateMaxVaccinations",
    "signature": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int",
    "docstring": {
      "en": "Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "es": "El tiempo pasó rápidamente, y Wang Wang había alcanzado la edad de meses para la vacunación. Wang Wang vino al hospital y quería darse una inyección de vacuna contra la rabia, pero no pudo resistir la tentación del médico. Necesita un total de 4 inyecciones. Primero recibió tres inyecciones de Miao Sanduo, y luego la vacuna contra la rabia. Una inyección de Miao Sanduo cuesta 120 yuanes, y una inyección de vacuna contra la rabia cuesta 100 yuanes. Sin embargo, Wang Wang solo tiene a yuanes de dinero y no puede recibir todas las inyecciones de una vez. En este momento, el médico dijo: \"¿Cómo podemos completar la inyección de una vez? Debe haber un intervalo de un mes entre cada dos inyecciones...\" Así que Wang Wang decidió ahorrar dinero mientras se daba las inyecciones (porque Wang Wang es un meow que ama las inyecciones), Wang Wang Si puedo ahorrar B yuanes cada mes, ¿cuántas vacunas puede recibir Wangwang a tiempo?\nEjemplo:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "arb": "مر الوقت بسرعة، ووصل وانغ وانغ إلى سن الأشهر للتطعيم. جاء وانغ وانغ إلى المستشفى وأراد أن يعطي نفسه حقنة من لقاح داء الكلب، لكنه لم يستطع مقاومة إغراء الطبيب. يحتاج إلى إجمالي 4 حقنات. تلقى أولاً ثلاث حقنات من مياو ساندو، ثم لقاح داء الكلب. تكلفة حقنة مياو ساندو 120 يوان، وتكلفة حقنة لقاح داء الكلب 100 يوان. ومع ذلك، فإن وانغ وانغ لديه فقط يوان من المال ولا يمكنه أخذ جميع الحقنات دفعة واحدة. في هذا الوقت، قال الطبيب: \"كيف يمكننا إكمال الحقن في وقت واحد؟ يجب أن يكون هناك شهر من الفاصل الزمني بين كل حقنتين...\" لذلك قرر وانغ وانغ توفير المال أثناء إعطاء نفسه الحقن (لأن وانغ وانغ هو مياو يحب الحقن)، إذا كان بإمكان وانغ وانغ توفير B يوان كل شهر، كم عدد التطعيمات التي يمكن لوانغ وانغ الحصول عليها في الوقت المحدد؟\nمثال:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "sw": "Muda ulipita haraka, na Wang Wang alikuwa amefikia umri wa miezi kwa ajili ya chanjo. Wang Wang alifika hospitalini na alitaka kujipiga sindano ya chanjo ya kichaa cha mbwa, lakini hakuweza kuzuia kishawishi cha daktari. Anahitaji jumla ya sindano 4. Kwanza alipokea sindano tatu za Miao Sanduo, kisha chanjo ya kichaa cha mbwa. Sindano moja ya Miao Sanduo inagharimu yuan 120, na sindano moja ya chanjo ya kichaa cha mbwa inagharimu yuan 100. Hata hivyo, Wang Wang ana yuan moja tu ya pesa na hawezi kuchukua sindano zote mara moja. Wakati huu, daktari alisema: \"Tunawezaje kukamilisha sindano kwa wakati mmoja? Inahitaji kuwa na muda wa mwezi mmoja kati ya kila sindano mbili...\" Kwa hiyo Wang Wang aliamua kuokoa pesa huku akijipiga sindano (kwa sababu Wang Wang ni meow anayependa sindano), Wang Wang Ikiwa naweza kuokoa yuan B kila mwezi, ni chanjo ngapi Wangwang anaweza kupata kwa wakati?\nMfano:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "tr": "Zaman hızla geçti ve Wang Wang aşı yaşı olan aylara ulaştı. Wang Wang hastaneye geldi ve kendine kuduz aşısı yaptırmak istedi, ancak doktorun cazibesine karşı koyamadı. Toplamda 4 enjeksiyon alması gerekiyor. Önce üç doz Miao Sanduo, ardından kuduz aşısı aldı. Bir doz Miao Sanduo 120 yuan, bir doz kuduz aşısı ise 100 yuan tutarındadır. Ancak Wang Wang'ın sadece bir yuan parası var ve tüm aşıları bir kerede yaptıramıyor. Bu sırada doktor dedi ki: \"Enjeksiyonu bir kerede nasıl tamamlayabiliriz? Her iki enjeksiyon arasında bir ay ara olması gerekiyor...\" Böylece Wang Wang, kendine enjeksiyon yaparken para biriktirmeye karar verdi (çünkü Wang Wang enjeksiyonları seven bir meow), Wang Wang her ay B yuan biriktirebilirse, Wang Wang zamanında kaç aşı yaptırabilir?\nÖrnek:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "vi": "Thời gian trôi qua nhanh chóng, và Wang Wang đã đến tuổi tiêm phòng. Wang Wang đến bệnh viện và muốn tự tiêm một mũi vắc-xin dại, nhưng anh không thể cưỡng lại sự cám dỗ của bác sĩ. Anh cần tổng cộng 4 mũi tiêm. Đầu tiên anh nhận ba mũi tiêm Miao Sanduo, và sau đó là vắc-xin dại. Một mũi tiêm Miao Sanduo có giá 120 nhân dân tệ, và một mũi vắc-xin dại có giá 100 nhân dân tệ. Tuy nhiên, Wang Wang chỉ có một số tiền và không thể tiêm tất cả các mũi cùng một lúc. Lúc này, bác sĩ nói: \"Làm thế nào để hoàn thành việc tiêm phòng một lần? Cần có khoảng cách một tháng giữa mỗi hai mũi tiêm...\" Vì vậy, Wang Wang quyết định tiết kiệm tiền trong khi tự tiêm phòng (vì Wang Wang là một chú mèo yêu thích tiêm phòng), Wang Wang Nếu tôi có thể tiết kiệm B nhân dân tệ mỗi tháng, Wangwang có thể tiêm bao nhiêu mũi đúng hạn?\nVí dụ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4"
    },
    "docstring_bertscore": {
      "es": "0.962645967803341",
      "arb": "0.9484881901343173",
      "sw": "0.9563416381396747",
      "tr": "0.9362213736927457",
      "vi": "0.9261206215563595"
    }
  },
  {
    "task_id": "Kotlin/20",
    "prompt": {
      "en": "\n/**\n * Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\n * on two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n * \n * Example:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "es": "/**\n * Realiza operaciones aritméticas básicas (suma, resta, multiplicación, división y módulo)\n * en dos enteros basados en un carácter de operación especificado. Cálculo ilegal devuelve \"invalid calcu\"\n * \n * Ejemplo:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "arb": "/**\n * تنفيذ العمليات الحسابية الأساسية (الجمع، الطرح، الضرب، القسمة، والباقي)\n * على عددين صحيحين بناءً على حرف العملية المحدد. الحساب غير القانوني يعيد \"invalid calcu\"\n * \n * مثال:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "sw": "/**\n * Fanya shughuli za kimsingi za hesabu (kujumlisha, kutoa, kuzidisha, kugawanya, na modulus)\n * kwenye nambari mbili za mzima kulingana na herufi maalum ya operesheni. Hesabu isiyo halali inarudisha \"invalid calcu\"\n * \n * Mfano:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "tr": "/**\n * İki tamsayı üzerinde belirtilen bir işlem karakterine göre temel aritmetik işlemleri (toplama, çıkarma, çarpma, bölme ve modül)\n * gerçekleştirin. Geçersiz hesaplama \"invalid calcu\" döndürür.\n * \n * Örnek:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "vi": "/**\n * Thực hiện các phép toán số học cơ bản (cộng, trừ, nhân, chia, và chia lấy dư)\n * trên hai số nguyên dựa trên ký tự phép toán được chỉ định. Phép tính không hợp lệ trả về \"invalid calcu\"\n * \n * Ví dụ:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any "
    },
    "prompt_bertscore": {
      "es": "0.9915264279450516",
      "arb": "0.9889990549767638",
      "sw": "0.9860420444942973",
      "tr": "0.9780473702880241",
      "vi": "0.9914970306486585"
    },
    "canonical_solution": "{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` to solve the following problem:\nPerform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "es": "Escribe una función de Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` para resolver el siguiente problema:\nRealizar operaciones aritméticas básicas (suma, resta, multiplicación, división y módulo)\nen dos enteros basados en un carácter de operación especificado. Cálculo ilegal devuelve \"invalid calcu\"\n\nEjemplo:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "arb": "اكتب دالة كوتلن `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` لحل المشكلة التالية:\nقم بإجراء العمليات الحسابية الأساسية (الجمع، الطرح، الضرب، القسمة، والباقي)\nعلى عددين صحيحين بناءً على حرف العملية المحدد. الحساب غير القانوني يعيد \"invalid calcu\"\n\nمثال:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "sw": "Andika kazi ya Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` kutatua tatizo lifuatalo:\nFanya operesheni za kimsingi za hesabu (kujumlisha, kutoa, kuzidisha, kugawanya, na modulus) kwenye namba mbili za mzima kulingana na herufi ya operesheni maalum. Hesabu isiyo halali inarudisha \"invalid calcu\"\n\nMfano:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "tr": "Bir Kotlin fonksiyonu `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` yazın ve aşağıdaki problemi çözün:\nBelirtilen bir işlem karakterine göre iki tam sayı üzerinde temel aritmetik işlemleri (toplama, çıkarma, çarpma, bölme ve modül) gerçekleştirin. Geçersiz hesaplama \"invalid calcu\" döndürür.\n\nÖrnek:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "vi": "Viết một hàm Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` để giải quyết vấn đề sau:\nThực hiện các phép toán số học cơ bản (cộng, trừ, nhân, chia, và chia lấy dư) trên hai số nguyên dựa trên ký tự phép toán được chỉ định. Phép tính không hợp lệ trả về \"invalid calcu\"\n\nVí dụ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2"
    },
    "instruction_bertscore": {
      "es": "1",
      "arb": "0.989381617090637",
      "sw": "0.9813635044994016",
      "tr": "0.9820056765212875",
      "vi": "0.9873404912951225"
    },
    "level": "easy",
    "test": "fun main(){\n    check(simpleCalculator(10, 5, '+') == 15)\n    check(simpleCalculator(10, 5, '-') == 5)\n    check(simpleCalculator(10, 5, '*') == 50)\n    check(simpleCalculator(10, 5, '/') == 2)\n    check(simpleCalculator(10, 5, '%') == 0)\n    check(simpleCalculator(15, 4, '/') == 3)\n    check(simpleCalculator(15, 4, '%') == 3)\n    check(simpleCalculator(15, 0, '/') == \"invalid calc\")\n    check(simpleCalculator(15, 0, '%') == \"invalid calc\")\n\n}\nmain()",
    "entry_point": "simpleCalculator",
    "signature": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any",
    "docstring": {
      "en": "Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "es": "Realizar operaciones aritméticas básicas (suma, resta, multiplicación, división y módulo) en dos enteros basados en un carácter de operación especificado. Cálculo ilegal devuelve \"calcu inválido\"\n\nEjemplo:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "arb": "إجراء العمليات الحسابية الأساسية (الجمع، الطرح، الضرب، القسمة، والباقي) على عددين صحيحين بناءً على رمز العملية المحدد. الحساب غير القانوني يعيد \"invalid calcu\"\n\nمثال:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "sw": "Fanya shughuli za kimsingi za hesabu (kujumlisha, kutoa, kuzidisha, kugawanya, na modulus) kwenye namba mbili nzima kulingana na alama maalum ya operesheni. Hesabu isiyo halali inarudisha \"invalid calcu\"\n\nMfano:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "tr": "Belirtilen bir işlem karakterine göre iki tamsayı üzerinde temel aritmetik işlemler (toplama, çıkarma, çarpma, bölme ve modül) gerçekleştirin. Geçersiz hesaplama \"invalid calcu\" döndürür.\n\nÖrnek:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "vi": "Thực hiện các phép toán số học cơ bản (cộng, trừ, nhân, chia, và chia lấy dư) trên hai số nguyên dựa trên ký tự phép toán được chỉ định. Phép tính không hợp lệ trả về \"invalid calcu\"\n\nVí dụ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2"
    },
    "docstring_bertscore": {
      "es": "0.9891998702919901",
      "arb": "0.9809134080559766",
      "sw": "0.9872415733653671",
      "tr": "0.985522030156748",
      "vi": "0.9800241398400834"
    }
  },
  {
    "task_id": "Kotlin/21",
    "prompt": {
      "en": "\n/**\n * Calculates the number of passengers on a bus at a specific station.\n * \n * The bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off, \n * so the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers \n * that got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the \n * previous station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n *\n * @param a The number of passengers boarding at the first station.\n * @param n The total number of stations.\n * @param m The number of passengers who get off at the last station.\n * @param x The station number for which the passenger count is required.\n * @return The number of passengers on the bus as it leaves station 'x'.\n *\n * Example:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "es": "/**\n * Calcula el número de pasajeros en un autobús en una estación específica.\n * \n * El autobús comienza en la primera estación con 'a' pasajeros. En la segunda estación, un número igual de pasajeros sube y baja,\n * por lo que la cuenta permanece 'a'. Desde la tercera estación en adelante, el número de pasajeros que suben es la suma de los pasajeros\n * que subieron en las dos últimas estaciones, y el número de pasajeros que bajan es el mismo que el número que subió en la\n * estación anterior. El proceso continúa hasta la penúltima estación. En la última estación, todos los pasajeros ('m') bajan.\n *\n * @param a El número de pasajeros que suben en la primera estación.\n * @param n El número total de estaciones.\n * @param m El número de pasajeros que bajan en la última estación.\n * @param x El número de la estación para la cual se requiere el conteo de pasajeros.\n * @return El número de pasajeros en el autobús al salir de la estación 'x'.\n *\n * Ejemplo:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "arb": "/**\n * يحسب عدد الركاب في الحافلة عند محطة معينة.\n * \n * تبدأ الحافلة عند المحطة الأولى مع 'a' ركاب. في المحطة الثانية، يصعد وينزل عدد متساوٍ من الركاب، \n * لذا يبقى العدد 'a'. من المحطة الثالثة فصاعدًا، عدد الركاب الذين يصعدون هو مجموع الركاب \n * الذين صعدوا في المحطتين السابقتين، وعدد الركاب الذين ينزلون هو نفس عدد الذين صعدوا في \n * المحطة السابقة. تستمر العملية حتى المحطة قبل الأخيرة. في المحطة الأخيرة ينزل جميع الركاب ('m').\n *\n * @param a عدد الركاب الذين يصعدون في المحطة الأولى.\n * @param n العدد الإجمالي للمحطات.\n * @param m عدد الركاب الذين ينزلون في المحطة الأخيرة.\n * @param x رقم المحطة التي يُطلب عدد الركاب عندها.\n * @return عدد الركاب في الحافلة عند مغادرتها المحطة 'x'.\n *\n * مثال:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "sw": "/**\n * Inahesabu idadi ya abiria kwenye basi katika kituo maalum.\n * \n * Basi linaanza katika kituo cha kwanza na abiria 'a'. Katika kituo cha pili, idadi sawa ya abiria wanapanda na kushuka, \n * hivyo idadi inabaki 'a'. Kuanzia kituo cha tatu na kuendelea, idadi ya abiria wanaopanda ni jumla ya abiria \n * waliopanda katika vituo viwili vilivyopita, na idadi ya abiria wanaoshuka ni sawa na idadi ya waliopanda katika \n * kituo kilichopita. Mchakato unaendelea hadi kituo cha pili kutoka mwisho. Kituo cha mwisho kinaona abiria wote ('m') wakishuka.\n *\n * @param a Idadi ya abiria wanaopanda katika kituo cha kwanza.\n * @param n Jumla ya idadi ya vituo.\n * @param m Idadi ya abiria wanaoshuka katika kituo cha mwisho.\n * @param x Nambari ya kituo ambacho idadi ya abiria inahitajika.\n * @return Idadi ya abiria kwenye basi wakati linaondoka kituo 'x'.\n *\n * Mfano:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int",
      "tr": "/**\n * Belirli bir istasyonda otobüsteki yolcu sayısını hesaplar.\n * \n * Otobüs, ilk istasyonda 'a' yolcuyla başlar. İkinci istasyonda, eşit sayıda yolcu biner ve iner,\n * bu yüzden sayı 'a' olarak kalır. Üçüncü istasyondan itibaren, binen yolcu sayısı, son iki istasyonda\n * binen yolcuların toplamıdır ve inen yolcu sayısı, bir önceki istasyonda binen yolcu sayısı ile aynıdır.\n * Bu süreç sondan bir önceki istasyona kadar devam eder. Son istasyonda tüm yolcular ('m') iner.\n *\n * @param a İlk istasyonda binen yolcu sayısı.\n * @param n Toplam istasyon sayısı.\n * @param m Son istasyonda inen yolcu sayısı.\n * @param x Yolcu sayısının gerekli olduğu istasyon numarası.\n * @return Otobüs istasyon 'x'ten ayrılırken otobüsteki yolcu sayısı.\n *\n * Örnek:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "vi": "/**\n * Tính toán số lượng hành khách trên xe buýt tại một trạm cụ thể.\n * \n * Xe buýt bắt đầu tại trạm đầu tiên với 'a' hành khách. Tại trạm thứ hai, một số lượng hành khách bằng nhau lên và xuống xe,\n * vì vậy số lượng vẫn là 'a'. Từ trạm thứ ba trở đi, số hành khách lên xe là tổng số hành khách đã lên ở hai trạm trước đó,\n * và số hành khách xuống xe bằng với số hành khách đã lên ở trạm trước đó. Quá trình này tiếp tục cho đến trạm áp chót.\n * Trạm cuối cùng tất cả hành khách ('m') xuống xe.\n *\n * @param a Số hành khách lên xe tại trạm đầu tiên.\n * @param n Tổng số trạm.\n * @param m Số hành khách xuống xe tại trạm cuối cùng.\n * @param x Số trạm mà cần tính số lượng hành khách.\n * @return Số lượng hành khách trên xe buýt khi rời khỏi trạm 'x'.\n *\n * Ví dụ:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9684807352462408",
      "arb": "0.9298793042566827",
      "sw": "0.940419228165537",
      "tr": "0.9328919312458389",
      "vi": "0.9235815293955906"
    },
    "canonical_solution": "{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` to solve the following problem:\nCalculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "es": "Escribe una función de Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` para resolver el siguiente problema:\nCalcula el número de pasajeros en un autobús en una estación específica.\n\nEl autobús comienza en la primera estación con 'a' pasajeros. En la segunda estación, un número igual de pasajeros sube y baja,\npor lo que el conteo permanece en 'a'. Desde la tercera estación en adelante, el número de pasajeros que suben es la suma de los pasajeros\nque subieron en las dos últimas estaciones, y el número de pasajeros que bajan es el mismo que el número que subió en la\nestación anterior. El proceso continúa hasta la penúltima estación. En la última estación, todos los pasajeros ('m') bajan.\n\n@param a El número de pasajeros que suben en la primera estación.\n@param n El número total de estaciones.\n@param m El número de pasajeros que bajan en la última estación.\n@param x El número de estación para el cual se requiere el conteo de pasajeros.\n@return El número de pasajeros en el autobús al salir de la estación 'x'.\n\nEjemplo:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "arb": "اكتب دالة Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` لحل المشكلة التالية:\nتحسب عدد الركاب في حافلة عند محطة معينة.\n\nتبدأ الحافلة عند المحطة الأولى مع 'a' ركاب. في المحطة الثانية، يصعد وينزل نفس العدد من الركاب، لذا يبقى العدد 'a'. من المحطة الثالثة فصاعدًا، يكون عدد الركاب الذين يصعدون هو مجموع الركاب الذين صعدوا في المحطتين السابقتين، وعدد الركاب الذين ينزلون هو نفس عدد الذين صعدوا في المحطة السابقة. تستمر العملية حتى المحطة قبل الأخيرة. في المحطة الأخيرة ينزل جميع الركاب ('m').\n\n@param a عدد الركاب الذين يصعدون في المحطة الأولى.\n@param n العدد الإجمالي للمحطات.\n@param m عدد الركاب الذين ينزلون في المحطة الأخيرة.\n@param x رقم المحطة التي يُطلب عدد الركاب عندها.\n@return عدد الركاب في الحافلة عند مغادرتها المحطة 'x'.\n\nمثال:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "sw": "Andika kazi ya Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` kutatua tatizo lifuatalo:\nHesabu idadi ya abiria kwenye basi katika kituo maalum.\n\nBasi linaanza katika kituo cha kwanza na abiria 'a'. Katika kituo cha pili, idadi sawa ya abiria wanapanda na kushuka,\nkwa hivyo idadi inabaki 'a'. Kuanzia kituo cha tatu na kuendelea, idadi ya abiria wanaopanda ni jumla ya abiria\nwaliopanda katika vituo viwili vilivyopita, na idadi ya abiria wanaoshuka ni sawa na idadi ya waliopanda katika\nkituo kilichopita. Mchakato unaendelea hadi kituo cha pili kutoka mwisho. Kituo cha mwisho kinaona abiria wote ('m') wakishuka.\n\n@param a Idadi ya abiria wanaopanda katika kituo cha kwanza.\n@param n Jumla ya idadi ya vituo.\n@param m Idadi ya abiria wanaoshuka katika kituo cha mwisho.\n@param x Nambari ya kituo ambacho idadi ya abiria inahitajika.\n@return Idadi ya abiria kwenye basi linapoondoka kituo 'x'.\n\nMfano:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "tr": "Kotlin fonksiyonu `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` yazın ve aşağıdaki problemi çözün:\nBelirli bir istasyonda otobüsteki yolcu sayısını hesaplar.\n\nOtobüs, ilk istasyonda 'a' yolcu ile başlar. İkinci istasyonda, eşit sayıda yolcu biner ve iner,\nbu yüzden sayı 'a' olarak kalır. Üçüncü istasyondan itibaren, binen yolcu sayısı son iki istasyonda\nbinen yolcuların toplamıdır ve inen yolcu sayısı önceki istasyonda binen yolcu sayısı ile aynıdır.\nBu süreç sondan bir önceki istasyona kadar devam eder. Son istasyonda tüm yolcular ('m') iner.\n\n@param a İlk istasyonda binen yolcu sayısı.\n@param n Toplam istasyon sayısı.\n@param m Son istasyonda inen yolcu sayısı.\n@param x Yolcu sayısının gerekli olduğu istasyon numarası.\n@return İstasyon 'x'ten ayrılırken otobüsteki yolcu sayısı.\n\nÖrnek:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "vi": "Viết một hàm Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` để giải quyết vấn đề sau:\nTính toán số lượng hành khách trên xe buýt tại một trạm cụ thể.\n\nXe buýt bắt đầu tại trạm đầu tiên với 'a' hành khách. Tại trạm thứ hai, một số lượng hành khách bằng nhau lên và xuống xe,\nvì vậy số lượng vẫn là 'a'. Từ trạm thứ ba trở đi, số lượng hành khách lên xe là tổng số hành khách\nđã lên tại hai trạm trước đó, và số lượng hành khách xuống xe bằng với số lượng đã lên tại\ntrạm trước đó. Quá trình tiếp tục cho đến trạm áp chót. Trạm cuối cùng tất cả hành khách ('m') xuống xe.\n\n@param a Số lượng hành khách lên xe tại trạm đầu tiên.\n@param n Tổng số trạm.\n@param m Số lượng hành khách xuống xe tại trạm cuối cùng.\n@param x Số trạm mà số lượng hành khách cần được tính toán.\n@return Số lượng hành khách trên xe buýt khi rời khỏi trạm 'x'.\n\nVí dụ:\n>>> busStationPassengers(5, 7, 32, 4)\n13"
    },
    "instruction_bertscore": {
      "es": "0.9787983917587171",
      "arb": "0.9328327393922905",
      "sw": "0.9421715453870267",
      "tr": "0.9299011535985966",
      "vi": "0.9368806279274005"
    },
    "level": "hard",
    "test": "fun main() {\n    check(busStationPassengers(5, 7, 32, 5) == 21)\n    check(busStationPassengers(5, 7, 32, 4) == 13)\n    check(busStationPassengers(5, 7, 32, 3) == 10)\n    check(busStationPassengers(5, 7, 32, 2) == 5)\n    \n\n}\nmain()",
    "entry_point": "busStationPassengers",
    "signature": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int",
    "docstring": {
      "en": "Calculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "es": "Calcula el número de pasajeros en un autobús en una estación específica.\n\nEl autobús comienza en la primera estación con 'a' pasajeros. En la segunda estación, un número igual de pasajeros sube y baja, por lo que el conteo permanece 'a'. Desde la tercera estación en adelante, el número de pasajeros que suben es la suma de los pasajeros que subieron en las dos últimas estaciones, y el número de pasajeros que bajan es el mismo que el número que subió en la estación anterior. El proceso continúa hasta la penúltima estación. En la última estación, todos los pasajeros ('m') bajan.\n\n@param a El número de pasajeros que suben en la primera estación.\n@param n El número total de estaciones.\n@param m El número de pasajeros que bajan en la última estación.\n@param x El número de estación para el cual se requiere el conteo de pasajeros.\n@return El número de pasajeros en el autobús al salir de la estación 'x'.\n\nEjemplo:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "arb": "يحسب عدد الركاب في الحافلة عند محطة معينة.\n\nتبدأ الحافلة في المحطة الأولى مع 'a' ركاب. في المحطة الثانية، يصعد وينزل نفس العدد من الركاب، لذا يبقى العدد 'a'. من المحطة الثالثة فصاعدًا، يكون عدد الركاب الذين يصعدون هو مجموع الركاب الذين صعدوا في المحطتين السابقتين، وعدد الركاب الذين ينزلون هو نفس عدد الذين صعدوا في المحطة السابقة. تستمر العملية حتى المحطة قبل الأخيرة. في المحطة الأخيرة ينزل جميع الركاب ('m').\n\n@param a عدد الركاب الذين يصعدون في المحطة الأولى.\n@param n إجمالي عدد المحطات.\n@param m عدد الركاب الذين ينزلون في المحطة الأخيرة.\n@param x رقم المحطة التي يُطلب فيها عدد الركاب.\n@return عدد الركاب في الحافلة عند مغادرتها المحطة 'x'.\n\nمثال:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "sw": "Hesabu idadi ya abiria kwenye basi katika kituo maalum.\n\nBasi linaanza katika kituo cha kwanza na abiria 'a'. Katika kituo cha pili, idadi sawa ya abiria wanapanda na kushuka, hivyo idadi inabaki 'a'. Kuanzia kituo cha tatu na kuendelea, idadi ya abiria wanaopanda ni jumla ya abiria waliopanda katika vituo viwili vilivyopita, na idadi ya abiria wanaoshuka ni sawa na idadi ya waliopanda katika kituo kilichopita. Mchakato huu unaendelea hadi kituo cha pili kutoka mwisho. Kituo cha mwisho kinaona abiria wote ('m') wakishuka.\n\n@param a Idadi ya abiria wanaopanda katika kituo cha kwanza.\n@param n Jumla ya vituo vya basi.\n@param m Idadi ya abiria wanaoshuka katika kituo cha mwisho.\n@param x Nambari ya kituo ambacho idadi ya abiria inahitajika.\n@return Idadi ya abiria kwenye basi linapoondoka kituo 'x'.\n\nMfano:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "tr": "Otobüste belirli bir istasyondaki yolcu sayısını hesaplar.\n\nOtobüs, ilk istasyonda 'a' yolcu ile başlar. İkinci istasyonda, eşit sayıda yolcu biner ve iner, bu yüzden sayı 'a' olarak kalır. Üçüncü istasyondan itibaren, binen yolcu sayısı son iki istasyonda binen yolcuların toplamıdır ve inen yolcu sayısı, bir önceki istasyonda binen yolcu sayısı ile aynıdır. Bu süreç sondan bir önceki istasyona kadar devam eder. Son istasyonda tüm yolcular ('m') iner.\n\n@param a İlk istasyonda binen yolcu sayısı.\n@param n Toplam istasyon sayısı.\n@param m Son istasyonda inen yolcu sayısı.\n@param x Yolcu sayısının gerekli olduğu istasyon numarası.\n@return Otobüs istasyon 'x'ten ayrılırken otobüsteki yolcu sayısı.\n\nÖrnek:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "vi": "Tính toán số lượng hành khách trên xe buýt tại một trạm cụ thể.\n\nXe buýt bắt đầu tại trạm đầu tiên với 'a' hành khách. Tại trạm thứ hai, một số lượng hành khách bằng nhau lên và xuống xe, vì vậy số lượng vẫn là 'a'. Từ trạm thứ ba trở đi, số lượng hành khách lên xe là tổng số hành khách đã lên tại hai trạm trước đó, và số lượng hành khách xuống xe bằng với số lượng đã lên tại trạm trước đó. Quá trình này tiếp tục cho đến trạm áp chót. Trạm cuối cùng tất cả hành khách ('m') xuống xe.\n\n@param a Số lượng hành khách lên xe tại trạm đầu tiên.\n@param n Tổng số trạm.\n@param m Số lượng hành khách xuống xe tại trạm cuối cùng.\n@param x Số trạm mà số lượng hành khách được yêu cầu.\n@return Số lượng hành khách trên xe buýt khi rời khỏi trạm 'x'.\n\nVí dụ:\n>>> busStationPassengers(5, 7, 32, 4)\n13"
    },
    "docstring_bertscore": {
      "es": "0.9789926522713692",
      "arb": "0.932772753017218",
      "sw": "0.9155252797711966",
      "tr": "0.9237559268701392",
      "vi": "0.9235056525900353"
    }
  },
  {
    "task_id": "Kotlin/22",
    "prompt": {
      "en": "\n/**\n    * Calculate the number of ways a person can mistakenly put letters in envelopes\n    * such that each letter ends up in the wrong envelope.\n    *\n    * This is based on a derangement problem where each item (letter) must not be\n    * in its original position (envelope).\n    *\n    * Parameters:\n    * n - the number of letters and envelopes.\n    *\n    * Returns:\n    * The total number of ways to wrongly place all the letters.\n    *\n    * Examples:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "es": "/**\n    * Calcular el número de formas en que una persona puede colocar por error cartas en sobres\n    * de tal manera que cada carta termine en el sobre incorrecto.\n    *\n    * Esto se basa en un problema de desarreglo donde cada elemento (carta) no debe estar\n    * en su posición original (sobre).\n    *\n    * Parámetros:\n    * n - el número de cartas y sobres.\n    *\n    * Devuelve:\n    * El número total de formas de colocar incorrectamente todas las cartas.\n    *\n    * Ejemplos:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "arb": "/**\n    * حساب عدد الطرق التي يمكن أن يضع بها الشخص الرسائل في المظاريف بشكل خاطئ\n    * بحيث ينتهي كل خطاب في الظرف الخطأ.\n    *\n    * هذا يعتمد على مشكلة الترتيب الخاطئ حيث يجب ألا يكون كل عنصر (رسالة)\n    * في موضعه الأصلي (الظرف).\n    *\n    * المعاملات:\n    * n - عدد الرسائل والمظاريف.\n    *\n    * يعيد:\n    * العدد الإجمالي للطرق لوضع جميع الرسائل بشكل خاطئ.\n    *\n    * أمثلة:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/ \nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "sw": "/**\n    * Hesabu idadi ya njia ambazo mtu anaweza kuweka barua kwenye bahasha kimakosa\n    * kiasi kwamba kila barua inaishia kwenye bahasha isiyo sahihi.\n    *\n    * Hii inategemea tatizo la derangement ambapo kila kipengee (barua) hakipaswi kuwa\n    * katika nafasi yake ya awali (bahasha).\n    *\n    * Vigezo:\n    * n - idadi ya barua na bahasha.\n    *\n    * Inarudisha:\n    * Jumla ya idadi ya njia za kuweka vibaya barua zote.\n    *\n    * Mifano:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "tr": "/**\n    * Bir kişinin mektupları zarflara yanlışlıkla yerleştirme yollarının sayısını hesaplayın\n    * öyle ki her mektup yanlış zarfa düşsün.\n    *\n    * Bu, her öğenin (mektubun) orijinal konumunda (zarf) olmaması gereken\n    * bir yer değiştirme problemine dayanmaktadır.\n    *\n    * Parametreler:\n    * n - mektup ve zarf sayısı.\n    *\n    * Döndürür:\n    * Tüm mektupları yanlış yerleştirmenin toplam yolları.\n    *\n    * Örnekler:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "vi": "/**\n    * Tính số cách một người có thể đặt nhầm thư vào phong bì\n    * sao cho mỗi lá thư đều nằm trong phong bì sai.\n    *\n    * Đây là một bài toán hoán vị sai chỗ (derangement) mà mỗi mục (thư) không được\n    * ở vị trí ban đầu của nó (phong bì).\n    *\n    * Tham số:\n    * n - số lượng thư và phong bì.\n    *\n    * Trả về:\n    * Tổng số cách để đặt sai tất cả các lá thư.\n    *\n    * Ví dụ:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long "
    },
    "prompt_bertscore": {
      "es": "0.9692246060232165",
      "arb": "0.9724253359832127",
      "sw": "0.9935937729508628",
      "tr": "0.9523114277084768",
      "vi": "0.9687355780251086"
    },
    "canonical_solution": "{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countWrongEnvelopeCombinations(n: Int): Long` to solve the following problem:\nCalculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "es": "Escribe una función de Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` para resolver el siguiente problema:\nCalcular el número de formas en que una persona puede colocar erróneamente cartas en sobres\nde tal manera que cada carta termine en el sobre incorrecto.\n\nEsto se basa en un problema de desarreglo donde cada elemento (carta) no debe estar\nen su posición original (sobre).\n\nParámetros:\nn - el número de cartas y sobres.\n\nDevuelve:\nEl número total de formas de colocar incorrectamente todas las cartas.\n\nEjemplos:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "arb": "اكتب دالة Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` لحل المشكلة التالية:\nاحسب عدد الطرق التي يمكن أن يضع بها شخص الرسائل في المظاريف بشكل خاطئ\nبحيث ينتهي كل خطاب في المظروف الخطأ.\n\nهذا يعتمد على مشكلة التوزيع الخاطئ حيث يجب ألا يكون كل عنصر (خطاب)\nفي موضعه الأصلي (المظروف).\n\nالمعاملات:\nn - عدد الرسائل والمظاريف.\n\nالإرجاع:\nإجمالي عدد الطرق لوضع جميع الرسائل بشكل خاطئ.\n\nأمثلة:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "sw": "Andika kazi ya Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` kutatua tatizo lifuatalo: \nHesabu idadi ya njia ambazo mtu anaweza kuweka barua kwenye bahasha kimakosa \nhivyo kwamba kila barua inaishia kwenye bahasha isiyo sahihi.\n\nHii inategemea tatizo la derangement ambapo kila kipengee (barua) hakipaswi kuwa \nkatika nafasi yake ya asili (bahasha).\n\nVigezo:\nn - idadi ya barua na bahasha.\n\nInarejesha:\nJumla ya njia za kuweka vibaya barua zote.\n\nMifano:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "tr": "Bir Kotlin fonksiyonu `fun countWrongEnvelopeCombinations(n: Int): Long` yazın ve aşağıdaki problemi çözün:\nBir kişinin mektupları zarflara yanlış yerleştirebileceği yolların sayısını hesaplayın\nöyle ki her mektup yanlış zarfta olsun.\n\nBu, her öğenin (mektup) orijinal konumunda (zarf) olmaması gereken bir yer değiştirme problemine dayanmaktadır.\n\nParametreler:\nn - mektup ve zarf sayısı.\n\nDöndürür:\nTüm mektupları yanlış yerleştirmenin toplam yolları.\n\nÖrnekler:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "vi": "Viết một hàm Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` để giải quyết vấn đề sau:  \nTính toán số cách mà một người có thể nhầm lẫn đặt thư vào phong bì sao cho mỗi thư đều nằm sai phong bì.  \n\nĐây là dựa trên một bài toán hoán vị sai chỗ, nơi mà mỗi mục (thư) không được nằm ở vị trí ban đầu của nó (phong bì).  \n\nTham số:  \nn - số lượng thư và phong bì.  \n\nTrả về:  \nTổng số cách để đặt sai tất cả các thư.  \n\nVí dụ:  \n>>> countWrongEnvelopeCombinations(2)  \n1  \n>>> countWrongEnvelopeCombinations(3)  \n2  "
    },
    "instruction_bertscore": {
      "es": "0.991824174886223",
      "arb": "0.9766718548993576",
      "sw": "0.9855766535115327",
      "tr": "0.9667933701593494",
      "vi": "0.9828530337267822"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countWrongEnvelopeCombinations(2) == 1L)\n    check(countWrongEnvelopeCombinations(3) == 2L)\n    check(countWrongEnvelopeCombinations(4) == 9L) // Additional test case for 4 letters\n    check(countWrongEnvelopeCombinations(5) == 44L) // Additional test case for 5 letters\n    check(countWrongEnvelopeCombinations(15) == 481066515734L) // Additional test case for 15 letters\n}\nmain()",
    "entry_point": "countWrongEnvelopeCombinations",
    "signature": "fun countWrongEnvelopeCombinations(n: Int): Long",
    "docstring": {
      "en": "Calculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "es": "Calcular el número de formas en que una persona puede colocar erróneamente cartas en sobres de manera que cada carta termine en el sobre incorrecto.\n\nEsto se basa en un problema de desarreglo donde cada elemento (carta) no debe estar en su posición original (sobre).\n\nParámetros:\nn - el número de cartas y sobres.\n\nDevuelve:\nEl número total de formas de colocar incorrectamente todas las cartas.\n\nEjemplos:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "arb": "احسب عدد الطرق التي يمكن أن يضع بها شخص ما الرسائل في المظاريف بشكل خاطئ بحيث ينتهي كل خطاب في مظروف خاطئ.\n\nهذا يعتمد على مشكلة التبديل حيث يجب ألا يكون كل عنصر (رسالة) في موضعه الأصلي (المظروف).\n\nالمعلمات:\nn - عدد الرسائل والمظاريف.\n\nالإرجاع:\nإجمالي عدد الطرق لوضع جميع الرسائل بشكل خاطئ.\n\nأمثلة:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "sw": "Hesabu idadi ya njia ambazo mtu anaweza kuweka barua kwenye bahasha kimakosa\nhivyo kwamba kila barua inamalizika kwenye bahasha isiyo sahihi.\n\nHii inategemea tatizo la derangement ambapo kila kipengee (barua) hakipaswi kuwa\nkatika nafasi yake ya asili (bahasha).\n\nVigezo:\nn - idadi ya barua na bahasha.\n\nInarejesha:\nJumla ya idadi ya njia za kuweka barua zote vibaya.\n\nMifano:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "tr": "Zarf içine mektupların yanlış yerleştirilme sayısını hesaplayın\nöyle ki her mektup yanlış zarfta son bulur.\n\nBu, her öğenin (mektubun) kendi orijinal konumunda (zarfında) olmaması gereken bir bozma problemi temelindedir.\n\nParametreler:\nn - mektup ve zarf sayısı.\n\nDöndürür:\nTüm mektupları yanlış yerleştirmenin toplam yolu sayısı.\n\nÖrnekler:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "vi": "Tính số cách một người có thể nhầm lẫn khi đặt thư vào phong bì\nsao cho mỗi lá thư đều nằm sai phong bì.\n\nĐiều này dựa trên một bài toán hoán vị sai chỗ, trong đó mỗi mục (thư) không được\nở vị trí ban đầu của nó (phong bì).\n\nTham số:\nn - số lượng thư và phong bì.\n\nTrả về:\nTổng số cách để đặt sai tất cả các lá thư.\n\nVí dụ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2"
    },
    "docstring_bertscore": {
      "es": "0.958763141114871",
      "arb": "0.9662739517129433",
      "sw": "0.9797391052432983",
      "tr": "0.9611200892162309",
      "vi": "0.974568359164198"
    }
  },
  {
    "task_id": "Kotlin/23",
    "prompt": {
      "en": "/**\n * Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\n * It is required that all three denominations are used in the exchange.\n * Example:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "es": "/**\n * Calcula el número de formas de cambiar una cantidad dada de dinero (más de 10 unidades) en denominaciones de 5, 2 y 1 unidad.\n * Se requiere que las tres denominaciones se utilicen en el intercambio.\n * Ejemplo:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "arb": "/**\n * يحسب عدد الطرق لتبادل مبلغ معين من المال (أكثر من 10 وحدات) إلى فئات 5 و 2 و 1 وحدة.\n * من المطلوب استخدام جميع الفئات الثلاث في التبادل.\n * مثال:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "sw": "/**\n * Inahesabu idadi ya njia za kubadilisha kiasi fulani cha pesa (zaidi ya vitengo 10) katika madhehebu ya vitengo 5, 2, na 1.\n * Inahitajika kwamba madhehebu yote matatu yatumiwe katika kubadilisha.\n * Mfano:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "tr": "/**\n * Belirli bir miktar parayı (10 birimden fazla) 5, 2 ve 1 birimlik para birimlerine çevirmenin kaç yolu olduğunu hesaplar.\n * Değişim sırasında tüm üç para biriminin kullanılması gerekmektedir.\n * Örnek:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "vi": "/**\n * Tính số cách để đổi một số tiền nhất định (hơn 10 đơn vị) thành các mệnh giá 5, 2, và 1 đơn vị.\n * Yêu cầu rằng cả ba mệnh giá đều phải được sử dụng trong việc đổi tiền.\n * Ví dụ:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */ \n\nfun countExchangeWays(amount: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9836086236962389",
      "arb": "0.9771581020721309",
      "sw": "0.9783604117685352",
      "tr": "0.9690605373284816",
      "vi": "0.9758582648586387"
    },
    "canonical_solution": "{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countExchangeWays(amount: Int): Int` to solve the following problem:\nCalculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "es": "Escribe una función en Kotlin `fun countExchangeWays(amount: Int): Int` para resolver el siguiente problema:\nCalcula el número de formas de intercambiar una cantidad dada de dinero (más de 10 unidades) en denominaciones de 5, 2 y 1 unidad.\nSe requiere que las tres denominaciones se usen en el intercambio.\nEjemplo:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "arb": "اكتب دالة Kotlin `fun countExchangeWays(amount: Int): Int` لحل المشكلة التالية:\nتحسب عدد الطرق لتبادل مبلغ معين من المال (أكثر من 10 وحدات) إلى فئات 5 و 2 و 1 وحدة.\nمن المطلوب استخدام جميع الفئات الثلاث في التبادل.\nمثال:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "sw": "Andika kazi ya Kotlin `fun countExchangeWays(amount: Int): Int` kutatua tatizo lifuatalo:\nHesabu idadi ya njia za kubadilisha kiasi fulani cha pesa (zaidi ya vitengo 10) katika madhehebu ya vitengo 5, 2, na 1.\nInahitajika kwamba madhehebu yote matatu yatumiwe katika kubadilisha.\nMfano:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "tr": "Bir Kotlin fonksiyonu `fun countExchangeWays(amount: Int): Int` yazın ve aşağıdaki problemi çözün:\nBelirli bir para miktarını (10 birimden fazla) 5, 2 ve 1 birimlik mezheplere çevirmenin kaç yolu olduğunu hesaplar.\nDeğişimde tüm üç mezhebin kullanılması gerekmektedir.\nÖrnek:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "vi": "Viết một hàm Kotlin `fun countExchangeWays(amount: Int): Int` để giải quyết vấn đề sau:  \nTính toán số cách để đổi một số tiền nhất định (nhiều hơn 10 đơn vị) thành các mệnh giá 5, 2 và 1 đơn vị.  \nYêu cầu rằng cả ba mệnh giá đều được sử dụng trong việc đổi tiền.  \nVí dụ:  \n>>> countExchangeWays(50)  \n106  \n>>> countExchangeWays(20)  \n13  "
    },
    "instruction_bertscore": {
      "es": "0.9789672275825967",
      "arb": "0.9745556468198119",
      "sw": "0.9680787073550262",
      "tr": "0.9623706660952266",
      "vi": "0.9820992314307548"
    },
    "level": "easy",
    "test": "fun main(){\n\n    check(countExchangeWays(50) == 106)\n    check(countExchangeWays(20) == 13)\n    check(countExchangeWays(15) == 6)\n    check(countExchangeWays(12) == 3)\n\n}\n\nmain()",
    "entry_point": "countExchangeWays",
    "signature": "fun countExchangeWays(amount: Int): Int",
    "docstring": {
      "en": "Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "es": "Calcula el número de formas de cambiar una cantidad dada de dinero (más de 10 unidades) en denominaciones de 5, 2 y 1 unidad. \nSe requiere que las tres denominaciones sean utilizadas en el cambio.\nEjemplo:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "arb": "يحسب عدد الطرق لتبادل مبلغ معين من المال (أكثر من 10 وحدات) إلى فئات 5 و 2 و 1 وحدة.  \nمن المطلوب استخدام جميع الفئات الثلاث في التبادل.  \nمثال:  \n>>> countExchangeWays(50)  \n106  \n>>> countExchangeWays(20)  \n13  ",
      "sw": "Hesabu idadi ya njia za kubadilisha kiasi fulani cha pesa (zaidi ya vitengo 10) kuwa katika madhehebu ya vitengo 5, 2, na 1. \nInahitajika kwamba madhehebu yote matatu yatumiwe katika kubadilisha. \nMfano:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "tr": "Verilen bir miktar parayı (10 birimden fazla) 5, 2 ve 1 birimlik para birimlerine çevirmenin yollarını hesaplar. \nTakas sırasında tüm üç para biriminin kullanılması gerekmektedir.\nÖrnek:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "vi": "Tính toán số cách để đổi một số tiền nhất định (hơn 10 đơn vị) thành các mệnh giá 5, 2 và 1 đơn vị. Yêu cầu là tất cả ba mệnh giá phải được sử dụng trong việc đổi tiền. Ví dụ: >>> countExchangeWays(50) 106 >>> countExchangeWays(20) 13"
    },
    "docstring_bertscore": {
      "es": "0.9615866719812819",
      "arb": "0.9683998926811597",
      "sw": "0.9618454873677704",
      "tr": "0.9395232065166886",
      "vi": "0.9573155228978888"
    }
  },
  {
    "task_id": "Kotlin/24",
    "prompt": {
      "en": "/**\n    * Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\n    * Hours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n    * \n    * Example:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "es": "/**\n    * Suma dos tiempos juntos. Cada tiempo se representa como un Triple de horas, minutos y segundos.\n    * Las horas, minutos y segundos se normalizan para asegurar que los minutos y segundos estén dentro de 0 a 59.\n    * \n    * Ejemplo:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "arb": "/**\n    * يضيف وقتين معًا. يتم تمثيل كل وقت كثلاثية من الساعات والدقائق والثواني.\n    * يتم تطبيع الساعات والدقائق والثواني لضمان أن تكون الدقائق والثواني ضمن 0 إلى 59.\n    * \n    * مثال:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "sw": "/**\n    * Huongeza nyakati mbili pamoja. Kila wakati unawakilishwa kama Triple ya saa, dakika, na sekunde.\n    * Saa, dakika, na sekunde zimenormalishwa kuhakikisha dakika na sekunde ziko kati ya 0 hadi 59.\n    * \n    * Mfano:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "tr": "/**\n    * İki zamanı toplar. Her zaman, saat, dakika ve saniye üçlüsü olarak temsil edilir.\n    * Saatler, dakikalar ve saniyeler, dakikaların ve saniyelerin 0 ile 59 arasında olmasını sağlamak için normalize edilir.\n    * \n    * Örnek:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "vi": "/**\n    * Cộng hai khoảng thời gian với nhau. Mỗi khoảng thời gian được biểu diễn dưới dạng một Triple gồm giờ, phút và giây.\n    * Giờ, phút và giây được chuẩn hóa để đảm bảo phút và giây nằm trong khoảng từ 0 đến 59.\n    * \n    * Ví dụ:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.9904570019735598",
      "arb": "0.988830020522503",
      "sw": "0.9960023649512918",
      "tr": "0.9828989173448013",
      "vi": "0.9641188120787147"
    },
    "canonical_solution": "{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` to solve the following problem:\nAdds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "es": "Escribe una función de Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` para resolver el siguiente problema:\nSuma dos tiempos. Cada tiempo se representa como un Triple de horas, minutos y segundos.\nLas horas, minutos y segundos se normalizan para asegurar que los minutos y segundos estén dentro de 0 a 59.\n\nEjemplo:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "arb": "اكتب دالة Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` لحل المشكلة التالية:\nجمع وقتين معًا. يتم تمثيل كل وقت كـ Triple من الساعات والدقائق والثواني.\nيتم تطبيع الساعات والدقائق والثواني لضمان أن تكون الدقائق والثواني بين 0 و 59.\n\nمثال:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "sw": "Andika kazi ya Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` kutatua tatizo lifuatalo:\nHuongeza nyakati mbili pamoja. Kila wakati unawakilishwa kama Triple ya saa, dakika, na sekunde.\nSaa, dakika, na sekunde zinarekebishwa ili kuhakikisha dakika na sekunde ziko kati ya 0 hadi 59.\n\nMfano:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "tr": "Bir Kotlin fonksiyonu `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` yazın:\nİki zamanı toplar. Her zaman, saat, dakika ve saniyeden oluşan bir Üçlü olarak temsil edilir.\nSaatler, dakikalar ve saniyeler, dakikaların ve saniyelerin 0 ile 59 arasında olmasını sağlamak için normalize edilir.\n\nÖrnek:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "vi": "Viết một hàm Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` để giải quyết vấn đề sau:\nCộng hai khoảng thời gian với nhau. Mỗi khoảng thời gian được biểu diễn dưới dạng một Triple của giờ, phút và giây.\nGiờ, phút và giây được chuẩn hóa để đảm bảo phút và giây nằm trong khoảng từ 0 đến 59.\n\nVí dụ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)"
    },
    "instruction_bertscore": {
      "es": "0.9902571798102388",
      "arb": "0.9867336754810608",
      "sw": "0.9913323660627806",
      "tr": "0.9632541740300699",
      "vi": "0.9749020582043367"
    },
    "level": "easy",
    "test": "fun main(){\n\n\ncheck(addTimes(Triple(1, 2, 3), Triple(4, 5, 6)) == Triple(5, 7, 9))\ncheck(addTimes(Triple(23, 59, 59), Triple(0, 0, 1)) == Triple(24, 0, 0))\ncheck(addTimes(Triple(10, 30, 30), Triple(2, 35, 40)) == Triple(13, 6, 10))\ncheck(addTimes(Triple(0, 0, 0), Triple(0, 0, 0)) == Triple(0, 0, 0))\n\n}\n\nmain()",
    "entry_point": "addTimes",
    "signature": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "es": "Suma dos tiempos juntos. Cada tiempo se representa como un Triple de horas, minutos y segundos. Las horas, minutos y segundos se normalizan para asegurar que los minutos y segundos estén entre 0 y 59.\n\nEjemplo:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "arb": "يجمع وقتين معًا. يتم تمثيل كل وقت كثلاثية من الساعات والدقائق والثواني. يتم تطبيع الساعات والدقائق والثواني لضمان أن تكون الدقائق والثواني ضمن 0 إلى 59.\n\nمثال:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "sw": "Huongeza nyakati mbili pamoja. Kila wakati unawakilishwa kama Triple ya saa, dakika, na sekunde. Saa, dakika, na sekunde zinarekebishwa ili kuhakikisha dakika na sekunde ziko kati ya 0 hadi 59.\n\nMfano:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "tr": "İki zamanı toplar. Her zaman, saat, dakika ve saniye üçlüsü olarak temsil edilir. Dakikalar ve saniyeler, 0 ile 59 arasında olmalarını sağlamak için normalize edilir.\n\nÖrnek:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "vi": "Cộng hai thời gian với nhau. Mỗi thời gian được biểu diễn dưới dạng một Bộ ba của giờ, phút và giây. Giờ, phút và giây được chuẩn hóa để đảm bảo phút và giây nằm trong khoảng từ 0 đến 59.\n\nVí dụ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9739142693194502",
      "arb": "0.9859472978025438",
      "sw": "0.9868117372208076",
      "tr": "0.9629127284050708",
      "vi": "0.9766883412209835"
    }
  },
  {
    "task_id": "Kotlin/25",
    "prompt": {
      "en": "/**\n    * Finds the mode (most frequent element) and its count in a given list of integers.\n    * If there are multiple modes, the smallest one is returned.\n    *\n    * Example:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 is the mode and it appears 3 times\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Both 1 and 3 are modes but 1 is smaller\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "es": "/**\n    * Encuentra la moda (elemento más frecuente) y su cuenta en una lista dada de enteros.\n    * Si hay múltiples modas, se devuelve la más pequeña.\n    *\n    * Ejemplo:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 es la moda y aparece 3 veces\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Tanto 1 como 3 son modas pero 1 es más pequeño\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "arb": "/**\n    * يجد النمط (العنصر الأكثر تكرارًا) وعدد مرات ظهوره في قائمة معينة من الأعداد الصحيحة.\n    * إذا كان هناك عدة أنماط، يتم إرجاع الأصغر منها.\n    *\n    * مثال:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 هو النمط ويظهر 3 مرات\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // كل من 1 و 3 هما الأنماط ولكن 1 هو الأصغر\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "sw": "/**\n    * Inapata modi (kipengele kinachojitokeza mara nyingi zaidi) na idadi yake katika orodha iliyotolewa ya nambari za mzima.\n    * Ikiwa kuna modi nyingi, ndogo zaidi inarejeshwa.\n    *\n    * Mfano:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 ni modi na inajitokeza mara 3\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Zote 1 na 3 ni modi lakini 1 ni ndogo zaidi\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "tr": "/**\n    * Bir tamsayı listesindeki modu (en sık görülen eleman) ve sayısını bulur.\n    * Birden fazla mod varsa, en küçüğü döndürülür.\n    *\n    * Örnek:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 moddur ve 3 kez görünür\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Hem 1 hem de 3 moddur ama 1 daha küçüktür\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "vi": "/**\n    * Tìm mode (phần tử xuất hiện nhiều nhất) và số lần xuất hiện của nó trong một danh sách số nguyên cho trước.\n    * Nếu có nhiều mode, phần tử nhỏ nhất sẽ được trả về.\n    *\n    * Ví dụ:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 là mode và nó xuất hiện 3 lần\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Cả 1 và 3 đều là mode nhưng 1 nhỏ hơn\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.9909944957846403",
      "arb": "0.9641333120965302",
      "sw": "0.9759621485479198",
      "tr": "0.9909180230879419",
      "vi": "0.9755728330010915"
    },
    "canonical_solution": "{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` to solve the following problem:\nFinds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller",
      "es": "Escribe una función de Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` para resolver el siguiente problema:\nEncuentra la moda (elemento más frecuente) y su conteo en una lista dada de enteros.\nSi hay múltiples modas, se devuelve la más pequeña.\n\nEjemplo:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 es la moda y aparece 3 veces\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Tanto 1 como 3 son modas pero 1 es más pequeño",
      "arb": "اكتب دالة كوتلن `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` لحل المشكلة التالية:\nتجد النمط (العنصر الأكثر تكرارًا) وعدد مرات ظهوره في قائمة الأعداد الصحيحة المعطاة.\nإذا كان هناك عدة أنماط، يتم إرجاع الأصغر منها.\n\nمثال:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 هو النمط ويظهر 3 مرات\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // كلا من 1 و 3 هما الأنماط ولكن 1 أصغر",
      "sw": "Andika kazi ya Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` kutatua tatizo lifuatalo:\nInapata modi (kipengele kinachojitokeza mara nyingi) na idadi yake katika orodha iliyotolewa ya namba nzima.\nKama kuna modi nyingi, ile ndogo zaidi inarejeshwa.\n\nMfano:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 ni modi na inajitokeza mara 3\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Zote 1 na 3 ni modi lakini 1 ni ndogo zaidi",
      "tr": "Bir Kotlin fonksiyonu `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı listesindeki modu (en sık görülen eleman) ve sayısını bulun.\nBirden fazla mod varsa, en küçük olanı döndürülür.\n\nÖrnek:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 moddur ve 3 kez görünür\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Hem 1 hem de 3 moddur ama 1 daha küçüktür",
      "vi": "Viết một hàm Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` để giải quyết vấn đề sau:\nTìm mode (phần tử xuất hiện nhiều nhất) và số lần xuất hiện của nó trong một danh sách số nguyên cho trước.\nNếu có nhiều mode, trả về phần tử nhỏ nhất.\n\nVí dụ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 là mode và nó xuất hiện 3 lần\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Cả 1 và 3 đều là mode nhưng 1 nhỏ hơn"
    },
    "instruction_bertscore": {
      "es": "0.9920869628803322",
      "arb": "0.9635552976877187",
      "sw": "0.9752371476571425",
      "tr": "0.9833108767550677",
      "vi": "0.983825130811567"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findModeAndCount(listOf(1, 2, 2, 2, 3, 5)) == Pair(2, 3))\n    check(findModeAndCount(listOf(1, 1, 2, 3, 3)) == Pair(1, 2))\n    check(findModeAndCount(listOf(4, 4, 4, 5, 5, 6, 6, 6)) == Pair(4, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9)) == Pair(9, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9, 1, 1, 1, 1, 1)) == Pair(1, 5))\n}\n\nmain()",
    "entry_point": "findModeAndCount",
    "signature": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller",
      "es": "Encuentra la moda (elemento más frecuente) y su cuenta en una lista dada de enteros.  \nSi hay múltiples modas, se devuelve la más pequeña.\n\nEjemplo:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 es la moda y aparece 3 veces\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Tanto 1 como 3 son modas, pero 1 es más pequeño",
      "arb": "يجد النمط (العنصر الأكثر تكرارًا) وعدد مرات ظهوره في قائمة معينة من الأعداد الصحيحة. إذا كان هناك أنماط متعددة، يتم إرجاع الأصغر منها.\n\nمثال:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 هو النمط ويظهر 3 مرات\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // كل من 1 و 3 هما أنماط ولكن 1 هو الأصغر",
      "sw": "Inapata modi (kipengele kinachojitokeza mara nyingi zaidi) na idadi yake katika orodha iliyotolewa ya nambari za mzima. Ikiwa kuna modi nyingi, ile ndogo zaidi inarudishwa.\n\nMfano:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 ni modi na inajitokeza mara 3\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Zote 1 na 3 ni modi lakini 1 ni ndogo zaidi",
      "tr": "Verilen bir tamsayı listesindeki modu (en sık görülen eleman) ve sayısını bulur. Birden fazla mod varsa, en küçük olanı döndürülür.\n\nÖrnek:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 moddur ve 3 kez görünür\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Hem 1 hem de 3 moddur ama 1 daha küçüktür",
      "vi": "Tìm giá trị mode (phần tử xuất hiện nhiều nhất) và số lần xuất hiện của nó trong một danh sách số nguyên cho trước. Nếu có nhiều giá trị mode, giá trị nhỏ nhất sẽ được trả về.\n\nVí dụ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 là giá trị mode và nó xuất hiện 3 lần\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Cả 1 và 3 đều là mode nhưng 1 nhỏ hơn"
    },
    "docstring_bertscore": {
      "es": "0.989598521466727",
      "arb": "0.9647758813791781",
      "sw": "0.977476903833692",
      "tr": "0.9927716418037594",
      "vi": "0.9437874035367456"
    }
  },
  {
    "task_id": "Kotlin/26",
    "prompt": {
      "en": "/**\n * Processes a given 2D array representing an image, applying a series of operations.\n * Each operation is represented by a character:\n * 'A' - Rotate the image 90 degrees clockwise.\n * 'B' - Rotate the image 90 degrees counterclockwise.\n * 'C' - Flip the image horizontally.\n * 'D' - Flip the image vertically.\n *\n * @param image A 2D array of integers representing the image's pixel grayscale values.\n * @param operations A string of characters representing the operations to be applied in sequence.\n * @return A 2D array of integers representing the processed image.\n *\n * Example:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "es": "/**\n * Procesa un arreglo 2D dado que representa una imagen, aplicando una serie de operaciones.\n * Cada operación está representada por un carácter:\n * 'A' - Rota la imagen 90 grados en el sentido de las agujas del reloj.\n * 'B' - Rota la imagen 90 grados en sentido contrario a las agujas del reloj.\n * 'C' - Voltea la imagen horizontalmente.\n * 'D' - Voltea la imagen verticalmente.\n *\n * @param image Un arreglo 2D de enteros que representa los valores de escala de grises de los píxeles de la imagen.\n * @param operations Una cadena de caracteres que representa las operaciones a aplicar en secuencia.\n * @return Un arreglo 2D de enteros que representa la imagen procesada.\n *\n * Ejemplo:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "arb": "/**\n * يعالج مصفوفة ثنائية الأبعاد تمثل صورة، بتطبيق سلسلة من العمليات.\n * كل عملية تمثل بحرف:\n * 'A' - تدوير الصورة 90 درجة في اتجاه عقارب الساعة.\n * 'B' - تدوير الصورة 90 درجة عكس اتجاه عقارب الساعة.\n * 'C' - قلب الصورة أفقيًا.\n * 'D' - قلب الصورة عموديًا.\n *\n * @param image مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل قيم تدرج الرمادي لبكسلات الصورة.\n * @param operations سلسلة من الأحرف تمثل العمليات التي سيتم تطبيقها بالتسلسل.\n * @return مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل الصورة المعالجة.\n *\n * مثال:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "sw": "/**\n * Inachakata safu mbili-dimensionali iliyotolewa inayowakilisha picha, ikitumia mfululizo wa operesheni.\n * Kila operesheni inawakilishwa na herufi:\n * 'A' - Geuza picha kwa nyuzi 90 kwa saa.\n * 'B' - Geuza picha kwa nyuzi 90 kinyume na saa.\n * 'C' - Geuza picha mlalo.\n * 'D' - Geuza picha wima.\n *\n * @param image Safu mbili-dimensionali ya nambari za mzima inayowakilisha thamani za kijivu za pikseli za picha.\n * @param operations Mfuatano wa herufi zinazowakilisha operesheni zitakazotumika kwa mpangilio.\n * @return Safu mbili-dimensionali ya nambari za mzima inayowakilisha picha iliyochakatwa.\n *\n * Mfano:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "tr": "/**\n * Bir görüntüyü temsil eden verilen 2D diziyi işleyerek bir dizi işlemi uygular.\n * Her işlem bir karakter ile temsil edilir:\n * 'A' - Görüntüyü saat yönünde 90 derece döndür.\n * 'B' - Görüntüyü saat yönünün tersine 90 derece döndür.\n * 'C' - Görüntüyü yatay olarak çevir.\n * 'D' - Görüntüyü dikey olarak çevir.\n *\n * @param image Görüntünün piksel gri tonlama değerlerini temsil eden bir 2D tamsayı dizisi.\n * @param operations Sırasıyla uygulanacak işlemleri temsil eden bir karakter dizisi.\n * @return İşlenmiş görüntüyü temsil eden bir 2D tamsayı dizisi.\n *\n * Örnek:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "vi": "/**\n * Xử lý một mảng 2D đại diện cho một hình ảnh, áp dụng một loạt các thao tác.\n * Mỗi thao tác được đại diện bởi một ký tự:\n * 'A' - Xoay hình ảnh 90 độ theo chiều kim đồng hồ.\n * 'B' - Xoay hình ảnh 90 độ ngược chiều kim đồng hồ.\n * 'C' - Lật hình ảnh theo chiều ngang.\n * 'D' - Lật hình ảnh theo chiều dọc.\n *\n * @param image Một mảng 2D các số nguyên đại diện cho giá trị mức xám của điểm ảnh.\n * @param operations Một chuỗi các ký tự đại diện cho các thao tác sẽ được áp dụng theo thứ tự.\n * @return Một mảng 2D các số nguyên đại diện cho hình ảnh đã được xử lý.\n *\n * Ví dụ:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> "
    },
    "prompt_bertscore": {
      "es": "0.9840622954865227",
      "arb": "0.9751245242310957",
      "sw": "0.9630211805931159",
      "tr": "0.9813166277294774",
      "vi": "0.9801264344863163"
    },
    "canonical_solution": "{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` to solve the following problem:\nProcesses a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "es": "Escribe una función de Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` para resolver el siguiente problema:\nProcesa un arreglo 2D dado que representa una imagen, aplicando una serie de operaciones.\nCada operación está representada por un carácter:\n'A' - Rota la imagen 90 grados en el sentido de las agujas del reloj.\n'B' - Rota la imagen 90 grados en sentido contrario a las agujas del reloj.\n'C' - Voltea la imagen horizontalmente.\n'D' - Voltea la imagen verticalmente.\n\n@param image Un arreglo 2D de enteros que representa los valores de escala de grises de los píxeles de la imagen.\n@param operations Una cadena de caracteres que representa las operaciones a aplicar en secuencia.\n@return Un arreglo 2D de enteros que representa la imagen procesada.\n\nEjemplo:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "arb": "اكتب دالة Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` لحل المشكلة التالية:\nمعالجة مصفوفة ثنائية الأبعاد تمثل صورة، بتطبيق سلسلة من العمليات.\nكل عملية تمثل بواسطة حرف:\n'A' - تدوير الصورة 90 درجة في اتجاه عقارب الساعة.\n'B' - تدوير الصورة 90 درجة عكس اتجاه عقارب الساعة.\n'C' - قلب الصورة أفقيًا.\n'D' - قلب الصورة عموديًا.\n\n@param image مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل قيم تدرج الرمادي لبكسلات الصورة.\n@param operations سلسلة من الأحرف تمثل العمليات التي سيتم تطبيقها بالتتابع.\n@return مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل الصورة بعد المعالجة.\n\nمثال:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "sw": "Andika kazi ya Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` kutatua tatizo lifuatalo:\nInachakata safu ya 2D iliyopewa inayowakilisha picha, ikitumia mfululizo wa operesheni.\nKila operesheni inawakilishwa na herufi:\n'A' - Geuza picha kwa nyuzi 90 kwa mwendo wa saa.\n'B' - Geuza picha kwa nyuzi 90 kinyume cha mwendo wa saa.\n'C' - Pindua picha kwa usawa.\n'D' - Pindua picha kwa wima.\n\n@param image Safu ya 2D ya nambari za integer zinazowakilisha thamani za kijivu za pikseli za picha.\n@param operations Mfuatano wa herufi zinazowakilisha operesheni zitakazotumika kwa mpangilio.\n@return Safu ya 2D ya nambari za integer zinazowakilisha picha iliyochakatwa.\n\nMfano:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "tr": "Bir Kotlin fonksiyonu `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` yazın ve aşağıdaki problemi çözün:\nVerilen bir 2D diziyi temsil eden bir görüntüyü işler, bir dizi işlemi uygular.\nHer işlem bir karakterle temsil edilir:\n'A' - Görüntüyü saat yönünde 90 derece döndür.\n'B' - Görüntüyü saat yönünün tersine 90 derece döndür.\n'C' - Görüntüyü yatay olarak çevir.\n'D' - Görüntüyü dikey olarak çevir.\n\n@param image Görüntünün piksel gri tonlama değerlerini temsil eden bir 2D tamsayı dizisi.\n@param operations Sırasıyla uygulanacak işlemleri temsil eden karakterlerden oluşan bir dize.\n@return İşlenmiş görüntüyü temsil eden bir 2D tamsayı dizisi.\n\nÖrnek:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "vi": "Viết một hàm Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` để giải quyết vấn đề sau:\nXử lý một mảng 2D đại diện cho một hình ảnh, áp dụng một loạt các thao tác.\nMỗi thao tác được biểu diễn bởi một ký tự:\n'A' - Xoay hình ảnh 90 độ theo chiều kim đồng hồ.\n'B' - Xoay hình ảnh 90 độ ngược chiều kim đồng hồ.\n'C' - Lật hình ảnh theo chiều ngang.\n'D' - Lật hình ảnh theo chiều dọc.\n\n@param image Một mảng 2D các số nguyên đại diện cho giá trị thang độ xám của điểm ảnh trong hình ảnh.\n@param operations Một chuỗi ký tự đại diện cho các thao tác sẽ được áp dụng theo thứ tự.\n@return Một mảng 2D các số nguyên đại diện cho hình ảnh đã được xử lý.\n\nVí dụ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))"
    },
    "instruction_bertscore": {
      "es": "0.988721766964839",
      "arb": "0.9671524938882605",
      "sw": "0.9580985238599282",
      "tr": "0.980768010617059",
      "vi": "0.9846635496499152"
    },
    "level": "hard",
    "test": "fun main() {\n    val image1 = arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10))\n    val result1 = processImage(image1, \"AC\")\n    check(result1.contentDeepEquals(arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))))\n\n    val image2 = arrayOf(arrayOf(1, 2), arrayOf(3, 4))\n    val result2 = processImage(image2, \"A\")\n    check(result2.contentDeepEquals(arrayOf(arrayOf(3, 1), arrayOf(4, 2))))\n\n    val result3 = processImage(image2, \"B\")\n    check(result3.contentDeepEquals(arrayOf(arrayOf(2, 4), arrayOf(1, 3))))\n\n    val result4 = processImage(image2, \"BD\")\n    check(result4.contentDeepEquals(arrayOf(arrayOf(1, 3), arrayOf(2, 4))))\n\n}\n\nmain()",
    "entry_point": "processImage",
    "signature": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>",
    "docstring": {
      "en": "Processes a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "es": "Procesa un arreglo 2D dado que representa una imagen, aplicando una serie de operaciones.  \nCada operación está representada por un carácter:  \n'A' - Rota la imagen 90 grados en el sentido de las agujas del reloj.  \n'B' - Rota la imagen 90 grados en sentido contrario a las agujas del reloj.  \n'C' - Voltea la imagen horizontalmente.  \n'D' - Voltea la imagen verticalmente.  \n\n@param image Un arreglo 2D de enteros que representa los valores de escala de grises de los píxeles de la imagen.  \n@param operations Una cadena de caracteres que representa las operaciones a aplicar en secuencia.  \n@return Un arreglo 2D de enteros que representa la imagen procesada.  \n\nEjemplo:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  ",
      "arb": "يعالج مصفوفة ثنائية الأبعاد تمثل صورة، ويطبق سلسلة من العمليات. \nكل عملية تمثل بحرف: \n'A' - تدوير الصورة 90 درجة في اتجاه عقارب الساعة. \n'B' - تدوير الصورة 90 درجة عكس اتجاه عقارب الساعة. \n'C' - قلب الصورة أفقيًا. \n'D' - قلب الصورة عموديًا.\n\n@param image مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل قيم تدرج الرمادي لبكسلات الصورة.\n@param operations سلسلة من الحروف تمثل العمليات التي سيتم تطبيقها بالتسلسل.\n@return مصفوفة ثنائية الأبعاد من الأعداد الصحيحة تمثل الصورة المعالجة.\n\nمثال:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "sw": "Inashughulikia safu ya 2D iliyotolewa inayowakilisha picha, ikitumia mfululizo wa operesheni.\nKila operesheni inawakilishwa na herufi:\n'A' - Zungusha picha kwa nyuzi 90 kwa mwelekeo wa saa.\n'B' - Zungusha picha kwa nyuzi 90 kinyume na mwelekeo wa saa.\n'C' - Geuza picha kwa usawa.\n'D' - Geuza picha kwa wima.\n\n@param image Safu ya 2D ya namba nzima inayowakilisha thamani za kijivu za pikseli za picha.\n@param operations Mfuatano wa herufi zinazowakilisha operesheni zitakazotumika kwa mpangilio.\n@return Safu ya 2D ya namba nzima inayowakilisha picha iliyosindikwa.\n\nMfano:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "tr": "Verilen bir görüntüyü temsil eden 2D diziyi işler, bir dizi işlem uygular. Her işlem bir karakterle temsil edilir:\n'A' - Görüntüyü saat yönünde 90 derece döndür.\n'B' - Görüntüyü saat yönünün tersine 90 derece döndür.\n'C' - Görüntüyü yatay olarak çevir.\n'D' - Görüntüyü dikey olarak çevir.\n\n@param image Görüntünün piksel gri tonlama değerlerini temsil eden bir tamsayı 2D dizisi.\n@param operations Sıra ile uygulanacak işlemleri temsil eden bir karakter dizisi.\n@return İşlenmiş görüntüyü temsil eden bir tamsayı 2D dizisi.\n\nÖrnek:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "vi": "Xử lý một mảng 2D cho trước đại diện cho một hình ảnh, áp dụng một loạt các thao tác.  \nMỗi thao tác được đại diện bởi một ký tự:  \n'A' - Xoay hình ảnh 90 độ theo chiều kim đồng hồ.  \n'B' - Xoay hình ảnh 90 độ ngược chiều kim đồng hồ.  \n'C' - Lật hình ảnh theo chiều ngang.  \n'D' - Lật hình ảnh theo chiều dọc.  \n\n@param image Một mảng 2D của các số nguyên đại diện cho giá trị thang độ xám của điểm ảnh.  \n@param operations Một chuỗi ký tự đại diện cho các thao tác sẽ được áp dụng theo thứ tự.  \n@return Một mảng 2D của các số nguyên đại diện cho hình ảnh đã được xử lý.  \n\nVí dụ:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  "
    },
    "docstring_bertscore": {
      "es": "0.981058408234132",
      "arb": "0.9683889680102027",
      "sw": "0.9549059377455545",
      "tr": "0.9856100234155465",
      "vi": "0.9843238916983456"
    }
  },
  {
    "task_id": "Kotlin/27",
    "prompt": {
      "en": "/**\n    * Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\n    * A prime pair is defined as two prime numbers where the difference between them is exactly 2.\n    * Example:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "es": "/**\n    * Encuentra todos los pares de primos donde cada primo es menor o igual a un número dado y el par difiere en 2.\n    * Un par de primos se define como dos números primos donde la diferencia entre ellos es exactamente 2.\n    * Ejemplo:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "arb": "/**\n    * يجد جميع أزواج الأعداد الأولية حيث يكون كل عدد أولي أقل من أو يساوي رقم معين والفرق بين الزوجين هو 2.\n    * يتم تعريف زوج الأعداد الأولية على أنه عددان أوليان يكون الفرق بينهما بالضبط 2.\n    * مثال:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "sw": "/**\n    * Inapata jozi zote za nambari za kwanza ambapo kila nambari ya kwanza ni ndogo au sawa na nambari iliyotolewa na jozi inatofautiana kwa 2.\n    * Jozi ya nambari za kwanza inafafanuliwa kama nambari mbili za kwanza ambapo tofauti kati yao ni haswa 2.\n    * Mfano:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "tr": "/**\n    * Her asal sayı verilen bir sayıdan küçük veya ona eşit olan ve çiftlerin farkı 2 olan tüm asal çiftleri bulur.\n    * Bir asal çift, aralarındaki fark tam olarak 2 olan iki asal sayı olarak tanımlanır.\n    * Örnek:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/ \n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "vi": "/**\n    * Tìm tất cả các cặp số nguyên tố mà mỗi số nguyên tố nhỏ hơn hoặc bằng một số cho trước và cặp số chênh lệch nhau 2 đơn vị.\n    * Một cặp số nguyên tố được định nghĩa là hai số nguyên tố mà sự chênh lệch giữa chúng là chính xác 2 đơn vị.\n    * Ví dụ:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> "
    },
    "prompt_bertscore": {
      "es": "0.996111015769718",
      "arb": "0.9714258279058451",
      "sw": "0.966836472952034",
      "tr": "0.9830171024215171",
      "vi": "0.9805753391474552"
    },
    "canonical_solution": "{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` to solve the following problem:\nFinds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "es": "Escribe una función de Kotlin `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` para resolver el siguiente problema:\nEncuentra todos los pares de primos donde cada primo es menor o igual a un número dado y el par difiere en 2.\nUn par de primos se define como dos números primos donde la diferencia entre ellos es exactamente 2.\nEjemplo:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "arb": "اكتب دالة كوتلن `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` لحل المشكلة التالية:\nإيجاد جميع الأزواج الأولية حيث يكون كل عدد أولي أقل من أو يساوي عدد معين ويختلف الزوج بمقدار 2.\nيُعرّف الزوج الأولي على أنه عددان أوليان يكون الفرق بينهما بالضبط 2.\nمثال:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "sw": "Andika kazi ya Kotlin `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` kutatua tatizo lifuatalo:\nInapata jozi zote za nambari za kwanza ambapo kila nambari ya kwanza ni ndogo au sawa na nambari iliyotolewa na jozi hiyo inatofautiana kwa 2.\nJozi ya nambari za kwanza inafafanuliwa kama nambari mbili za kwanza ambapo tofauti kati yao ni haswa 2.\nMfano:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "tr": "Kotlin fonksiyonu `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` yazın ve aşağıdaki problemi çözün:\nHer asal sayının verilen bir sayıdan küçük veya ona eşit olduğu ve çiftin 2 farkla ayrıldığı tüm asal çiftleri bulun.\nBir asal çifti, aralarındaki fark tam olarak 2 olan iki asal sayı olarak tanımlanır.\nÖrnek:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "vi": "Viết một hàm Kotlin `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` để giải quyết vấn đề sau:\nTìm tất cả các cặp số nguyên tố mà mỗi số nguyên tố nhỏ hơn hoặc bằng một số cho trước và cặp số khác nhau 2 đơn vị.\nMột cặp số nguyên tố được định nghĩa là hai số nguyên tố mà sự chênh lệch giữa chúng là chính xác 2.\nVí dụ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]"
    },
    "instruction_bertscore": {
      "es": "0.9962258241299561",
      "arb": "0.977892438590817",
      "sw": "0.971470718371959",
      "tr": "0.9690726537817248",
      "vi": "0.9711139782076204"
    },
    "level": "easy",
    "test": "fun main(){\n    check(findPrimePairs(10) == listOf(Pair(3, 5), Pair(5, 7)))\n    check(findPrimePairs(100) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13), Pair(17, 19), Pair(29, 31), Pair(41, 43), Pair(59, 61), Pair(71, 73)))\n    check(findPrimePairs(15) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13)))\n    check(findPrimePairs(1) == emptyList<Pair<Int, Int>>())\n}\n\n\nmain()",
    "entry_point": "findPrimePairs",
    "signature": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>",
    "docstring": {
      "en": "Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "es": "Encuentra todos los pares de primos donde cada primo es menor o igual a un número dado y el par difiere en 2.  \nUn par de primos se define como dos números primos donde la diferencia entre ellos es exactamente 2.  \nEjemplo:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "arb": "يجد جميع أزواج الأعداد الأولية حيث يكون كل عدد أولي أقل من أو يساوي عددًا معينًا ويختلف الزوج بمقدار 2. يُعرّف زوج الأعداد الأولية على أنه عددان أوليان يكون الفرق بينهما بالضبط 2.\nمثال:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "sw": "Inapata jozi zote za nambari za kwanza ambapo kila nambari ya kwanza ni ndogo au sawa na nambari iliyotolewa na jozi inatofautiana kwa 2.  \nJozi ya nambari za kwanza inafafanuliwa kama nambari mbili za kwanza ambapo tofauti kati yao ni haswa 2.  \nMfano:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "tr": "Verilen bir sayıdan küçük veya ona eşit olan tüm asal çiftleri bulur ve çiftler 2 farkla ayrılır.\nBir asal çifti, aralarındaki fark tam olarak 2 olan iki asal sayı olarak tanımlanır.\nÖrnek:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "vi": "Tìm tất cả các cặp số nguyên tố mà mỗi số nguyên tố nhỏ hơn hoặc bằng một số cho trước và cặp số đó khác nhau 2 đơn vị.  \nMột cặp số nguyên tố được định nghĩa là hai số nguyên tố mà sự khác biệt giữa chúng chính xác là 2.  \nVí dụ:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]  "
    },
    "docstring_bertscore": {
      "es": "0.9692540033196096",
      "arb": "0.9629854271245296",
      "sw": "0.9622008371194418",
      "tr": "0.9571836323248816",
      "vi": "0.9633032357341854"
    }
  },
  {
    "task_id": "Kotlin/28",
    "prompt": {
      "en": "/**\n * Converts a number from one base to another.\n * The function takes an input number as a string (which can include digits and letters),\n * the base of this number, and the target base for conversion. The bases can range from 2 to 16.\n * The output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n *\n * Examples:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "es": "/**\n * Convierte un número de una base a otra.\n * La función toma un número de entrada como una cadena (que puede incluir dígitos y letras),\n * la base de este número, y la base objetivo para la conversión. Las bases pueden variar de 2 a 16.\n * La salida es el número convertido como una cadena en la base objetivo, usando letras mayúsculas para bases superiores a 10.\n *\n * Ejemplos:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */ \n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "arb": "/**\n * يحول رقمًا من قاعدة إلى أخرى.\n * تأخذ الدالة رقم الإدخال كسلسلة (يمكن أن تشمل أرقامًا وحروفًا)،\n * قاعدة هذا الرقم، والقاعدة المستهدفة للتحويل. يمكن أن تتراوح القواعد من 2 إلى 16.\n * المخرج هو الرقم المحول كسلسلة في القاعدة المستهدفة، باستخدام حروف كبيرة للقواعد التي تزيد عن 10.\n *\n * أمثلة:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */ \n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "sw": "/**\n * Hubadilisha nambari kutoka msingi mmoja hadi mwingine.\n * Kazi inachukua nambari ya ingizo kama kamba (ambayo inaweza kujumuisha tarakimu na herufi),\n * msingi wa nambari hii, na msingi lengwa kwa ubadilishaji. Misingi inaweza kuwa kati ya 2 hadi 16.\n * Matokeo ni nambari iliyobadilishwa kama kamba katika msingi lengwa, ikitumia herufi kubwa kwa misingi zaidi ya 10.\n *\n * Mifano:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "tr": "/**\n * Bir sayıyı bir tabandan diğerine dönüştürür.\n * Fonksiyon, bir sayıyı string olarak alır (rakamlar ve harfler içerebilir),\n * bu sayının tabanını ve dönüştürme için hedef tabanı alır. Tabanlar 2 ile 16 arasında olabilir.\n * Çıktı, hedef tabanda büyük harfler kullanılarak dönüştürülmüş sayıyı string olarak verir.\n *\n * Örnekler:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "vi": "/**\n * Chuyển đổi một số từ hệ cơ số này sang hệ cơ số khác.\n * Hàm nhận vào một số dưới dạng chuỗi (có thể bao gồm chữ số và chữ cái),\n * hệ cơ số của số này, và hệ cơ số đích để chuyển đổi. Các hệ cơ số có thể từ 2 đến 16.\n * Đầu ra là số đã được chuyển đổi dưới dạng chuỗi trong hệ cơ số đích, sử dụng chữ cái viết hoa cho các hệ cơ số lớn hơn 10.\n *\n * Ví dụ:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String "
    },
    "prompt_bertscore": {
      "es": "0.9926218744964591",
      "arb": "0.9920504148902217",
      "sw": "0.9876428067350576",
      "tr": "0.962093775344064",
      "vi": "0.9798938383101244"
    },
    "canonical_solution": "{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` to solve the following problem:\nConverts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "es": "Escribe una función en Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` para resolver el siguiente problema:\nConvierte un número de una base a otra.\nLa función toma un número de entrada como una cadena (que puede incluir dígitos y letras),\nla base de este número, y la base objetivo para la conversión. Las bases pueden variar de 2 a 16.\nLa salida es el número convertido como una cadena en la base objetivo, usando letras mayúsculas para bases superiores a 10.\n\nEjemplos:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "arb": "اكتب دالة كوتلن `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` لحل المشكلة التالية:\nتحويل رقم من قاعدة إلى أخرى.\nتأخذ الدالة رقم الإدخال كسلسلة (يمكن أن تتضمن أرقامًا وحروفًا)،\nقاعدة هذا الرقم، والقاعدة المستهدفة للتحويل. يمكن أن تتراوح القواعد من 2 إلى 16.\nالناتج هو الرقم المحول كسلسلة في القاعدة المستهدفة، باستخدام أحرف كبيرة للقواعد التي تزيد عن 10.\n\nأمثلة:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "sw": "Andika kazi ya Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` kutatua tatizo lifuatalo:\nInabadilisha nambari kutoka msingi mmoja hadi mwingine.\nKazi inachukua nambari ya pembejeo kama kamba (ambayo inaweza kujumuisha tarakimu na herufi),\nmsingi wa nambari hii, na msingi lengwa kwa ubadilishaji. Misingi inaweza kuwa kati ya 2 hadi 16.\nPato ni nambari iliyobadilishwa kama kamba katika msingi lengwa, ikitumia herufi kubwa kwa misingi zaidi ya 10.\n\nMifano:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "tr": "Bir Kotlin fonksiyonu `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` yazın:\nBir sayıyı bir tabandan başka bir tabana dönüştürür.\nFonksiyon, bir sayıyı string olarak (rakamlar ve harfler içerebilir),\nbu sayının tabanını ve dönüştürme için hedef tabanı alır. Tabanlar 2 ile 16 arasında olabilir.\nÇıktı, hedef tabandaki sayıyı büyük harfler kullanarak bir string olarak verir.\n\nÖrnekler:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "vi": "Viết một hàm Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` để giải quyết vấn đề sau:\nChuyển đổi một số từ một cơ số này sang cơ số khác.\nHàm nhận một số đầu vào dưới dạng chuỗi (có thể bao gồm chữ số và chữ cái),\ncơ số của số này và cơ số đích để chuyển đổi. Các cơ số có thể từ 2 đến 16.\nĐầu ra là số đã chuyển đổi dưới dạng chuỗi trong cơ số đích, sử dụng chữ cái in hoa cho các cơ số trên 10.\n\nVí dụ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\""
    },
    "instruction_bertscore": {
      "es": "0.9887104450331201",
      "arb": "0.9904961321586238",
      "sw": "0.9939681912191135",
      "tr": "0.9453730698685471",
      "vi": "0.9916724212751123"
    },
    "level": "easy",
    "test": "fun main() {\n    check(convertBase(\"Aab3\", 15, 7) == \"210306\")\n    check(convertBase(\"101\", 2, 10) == \"5\")\n    check(convertBase(\"FF\", 16, 2) == \"11111111\")\n    check(convertBase(\"123\", 10, 16) == \"7B\")\n}\n\nmain()",
    "entry_point": "convertBase",
    "signature": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String",
    "docstring": {
      "en": "Converts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "es": "Convierte un número de una base a otra.  \nLa función toma un número de entrada como una cadena (que puede incluir dígitos y letras),  \nla base de este número, y la base objetivo para la conversión. Las bases pueden variar de 2 a 16.  \nLa salida es el número convertido como una cadena en la base objetivo, utilizando letras mayúsculas para bases superiores a 10.\n\nEjemplos:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "arb": "يحوّل رقمًا من قاعدة إلى أخرى.  \nتأخذ الدالة رقم الإدخال كسلسلة (يمكن أن تشمل أرقامًا وحروفًا)،  \nقاعدة هذا الرقم، والقاعدة المستهدفة للتحويل. يمكن أن تتراوح القواعد من 2 إلى 16.  \nالناتج هو الرقم المحول كسلسلة في القاعدة المستهدفة، باستخدام حروف كبيرة للقواعد التي تزيد عن 10.\n\nأمثلة:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "sw": "Inabadilisha nambari kutoka msingi mmoja hadi mwingine.  \nKazi hii inachukua nambari ya ingizo kama kamba (ambayo inaweza kujumuisha tarakimu na herufi),  \nmsingi wa nambari hii, na msingi lengwa kwa ubadilishaji. Misingi inaweza kuwa kati ya 2 hadi 16.  \nPato ni nambari iliyobadilishwa kama kamba katika msingi lengwa, ikitumia herufi kubwa kwa misingi zaidi ya 10.\n\nMifano:  \n>>> convertBase(\"Aab3\", 15, 7)  \n\"210306\"  \n>>> convertBase(\"101\", 2, 10)  \n\"5\"  \n>>> convertBase(\"FF\", 16, 2)  \n\"11111111\"",
      "tr": "Bir sayıyı bir tabandan diğerine dönüştürür.\nFonksiyon, bir sayıyı string olarak alır (rakamlar ve harfler içerebilir),\nbu sayının tabanını ve dönüştürme için hedef tabanı alır. Tabanlar 2 ile 16 arasında olabilir.\nÇıktı, hedef tabanda büyük harfler kullanarak dönüştürülmüş sayıyı string olarak verir.\n\nÖrnekler:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "vi": "Chuyển đổi một số từ một cơ số này sang cơ số khác.  \nHàm nhận một số đầu vào dưới dạng chuỗi (có thể bao gồm các chữ số và chữ cái),  \ncơ số của số này và cơ số đích để chuyển đổi. Các cơ số có thể nằm trong khoảng từ 2 đến 16.  \nĐầu ra là số đã được chuyển đổi dưới dạng chuỗi trong cơ số đích, sử dụng chữ cái in hoa cho các cơ số lớn hơn 10.\n\nVí dụ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\""
    },
    "docstring_bertscore": {
      "es": "0.990116152239704",
      "arb": "0.9904526321051771",
      "sw": "0.9897359736904032",
      "tr": "0.9549937323739719",
      "vi": "0.9902450633569956"
    }
  },
  {
    "task_id": "Kotlin/29",
    "prompt": {
      "en": "/**\n * Determines whether a given number string is a cyclic number.\n * A cyclic number is one where multiplying it by any number from 1 to its length,\n * results in a permutation of the original number.\n *\n * Examples:\n * >>> isCyclicNumber(\"142857\")\n *     1 // since 142857 is a cyclic number\n * >>> isCyclicNumber(\"123456\")\n *     0 // since 123456 is not a cyclic number\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "es": "/**\n * Determina si una cadena de número dada es un número cíclico.\n * Un número cíclico es aquel donde multiplicarlo por cualquier número del 1 a su longitud,\n * resulta en una permutación del número original.\n *\n * Ejemplos:\n * >>> isCyclicNumber(\"142857\")\n *     1 // ya que 142857 es un número cíclico\n * >>> isCyclicNumber(\"123456\")\n *     0 // ya que 123456 no es un número cíclico\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "arb": "/**\n * يحدد ما إذا كانت سلسلة الأرقام المعطاة هي رقم دوري.\n * الرقم الدوري هو الرقم الذي عند ضربه بأي عدد من 1 إلى طوله،\n * ينتج عنه تبديل للرقم الأصلي.\n *\n * أمثلة:\n * >>> isCyclicNumber(\"142857\")\n *     1 // لأن 142857 هو رقم دوري\n * >>> isCyclicNumber(\"123456\")\n *     0 // لأن 123456 ليس رقمًا دوريًا\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "sw": "/**\n * Huamua kama namba iliyotolewa kwa njia ya maandishi ni namba ya mzunguko.\n * Namba ya mzunguko ni ile ambapo kuizidisha na namba yoyote kutoka 1 hadi urefu wake,\n * husababisha mpangilio wa namba asilia.\n *\n * Mifano:\n * >>> isCyclicNumber(\"142857\")\n *     1 // kwa kuwa 142857 ni namba ya mzunguko\n * >>> isCyclicNumber(\"123456\")\n *     0 // kwa kuwa 123456 si namba ya mzunguko\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "tr": "/**\n * Belirtilen bir sayı dizisinin döngüsel bir sayı olup olmadığını belirler.\n * Döngüsel bir sayı, 1'den uzunluğuna kadar herhangi bir sayı ile çarpıldığında,\n * orijinal sayının bir permütasyonu olan bir sayıdır.\n *\n * Örnekler:\n * >>> isCyclicNumber(\"142857\")\n *     1 // çünkü 142857 döngüsel bir sayıdır\n * >>> isCyclicNumber(\"123456\")\n *     0 // çünkü 123456 döngüsel bir sayı değildir\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "vi": "/**\n * Xác định xem một chuỗi số cho trước có phải là số tuần hoàn hay không.\n * Một số tuần hoàn là số mà khi nhân nó với bất kỳ số nào từ 1 đến độ dài của nó,\n * kết quả là một hoán vị của số gốc.\n *\n * Ví dụ:\n * >>> isCyclicNumber(\"142857\")\n *     1 // vì 142857 là một số tuần hoàn\n * >>> isCyclicNumber(\"123456\")\n *     0 // vì 123456 không phải là một số tuần hoàn\n */\n\nfun isCyclicNumber(numberString: String): Int "
    },
    "prompt_bertscore": {
      "es": "0.9992271291873932",
      "arb": "0.9695271200935326",
      "sw": "0.9817363337246041",
      "tr": "0.9610906919198379",
      "vi": "0.9606753557930938"
    },
    "canonical_solution": "{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun isCyclicNumber(numberString: String): Int` to solve the following problem:\nDetermines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number",
      "es": "Escriba una función de Kotlin `fun isCyclicNumber(numberString: String): Int` para resolver el siguiente problema:\nDetermina si una cadena de número dada es un número cíclico.\nUn número cíclico es aquel que al multiplicarlo por cualquier número del 1 a su longitud,\nresulta en una permutación del número original.\n\nEjemplos:\n>>> isCyclicNumber(\"142857\")\n1 // ya que 142857 es un número cíclico\n>>> isCyclicNumber(\"123456\")\n0 // ya que 123456 no es un número cíclico",
      "arb": "اكتب دالة Kotlin `fun isCyclicNumber(numberString: String): Int` لحل المشكلة التالية:\nتحديد ما إذا كانت سلسلة الأرقام المعطاة هي رقم دوري.\nالرقم الدوري هو الرقم الذي عند ضربه بأي رقم من 1 إلى طوله،\nينتج عنه تبديل للأرقام الأصلية.\n\nأمثلة:\n>>> isCyclicNumber(\"142857\")\n1 // لأن 142857 هو رقم دوري\n>>> isCyclicNumber(\"123456\")\n0 // لأن 123456 ليس رقمًا دوريًا",
      "sw": "Andika kazi ya Kotlin `fun isCyclicNumber(numberString: String): Int` kutatua tatizo lifuatalo:\nInabainisha kama namba iliyotolewa ni namba ya mzunguko.\nNamba ya mzunguko ni ile ambapo kuizidisha na namba yoyote kutoka 1 hadi urefu wake,\ninatoa mpangilio mpya wa namba ya awali.\n\nMifano:\n>>> isCyclicNumber(\"142857\")\n1 // kwa kuwa 142857 ni namba ya mzunguko\n>>> isCyclicNumber(\"123456\")\n0 // kwa kuwa 123456 si namba ya mzunguko",
      "tr": "Bir Kotlin fonksiyonu `fun isCyclicNumber(numberString: String): Int` yazın ve aşağıdaki problemi çözün:\nVerilen bir sayı dizgisinin döngüsel bir sayı olup olmadığını belirler.\nDöngüsel bir sayı, 1'den uzunluğuna kadar herhangi bir sayı ile çarpıldığında,\norijinal sayının bir permütasyonu olan bir sayıdır.\n\nÖrnekler:\n>>> isCyclicNumber(\"142857\")\n1 // çünkü 142857 döngüsel bir sayıdır\n>>> isCyclicNumber(\"123456\")\n0 // çünkü 123456 döngüsel bir sayı değildir",
      "vi": "Viết một hàm Kotlin `fun isCyclicNumber(numberString: String): Int` để giải quyết vấn đề sau:  \nXác định xem một chuỗi số cho trước có phải là một số tuần hoàn hay không.  \nMột số tuần hoàn là số mà khi nhân nó với bất kỳ số nào từ 1 đến độ dài của nó,  \nkết quả là một hoán vị của số gốc.\n\nVí dụ:  \n>>> isCyclicNumber(\"142857\")  \n1 // vì 142857 là một số tuần hoàn  \n>>> isCyclicNumber(\"123456\")  \n0 // vì 123456 không phải là một số tuần hoàn  "
    },
    "instruction_bertscore": {
      "es": "0.9821586219146843",
      "arb": "0.9591594087250356",
      "sw": "0.985669811160238",
      "tr": "0.9678828577993258",
      "vi": "0.9665766644136404"
    },
    "level": "middle",
    "test": "fun main(){\n    check(isCyclicNumber(\"142857\") == 1)\n    check(isCyclicNumber(\"123456\") == 0)\n    check(isCyclicNumber(\"076923\") == 0)\n    check(isCyclicNumber(\"1\") == 1)\n    check(isCyclicNumber(\"0\") == 1)\n\n}\n\nmain()",
    "entry_point": "isCyclicNumber",
    "signature": "fun isCyclicNumber(numberString: String): Int",
    "docstring": {
      "en": "Determines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number",
      "es": "Determina si una cadena de números dada es un número cíclico.  \nUn número cíclico es aquel donde multiplicarlo por cualquier número desde 1 hasta su longitud,  \nresulta en una permutación del número original.\n\nEjemplos:  \n>>> isCyclicNumber(\"142857\")  \n1 // ya que 142857 es un número cíclico  \n>>> isCyclicNumber(\"123456\")  \n0 // ya que 123456 no es un número cíclico",
      "arb": "يحدد ما إذا كانت سلسلة الأرقام المعطاة هي رقم دوري.\nالرقم الدوري هو الرقم الذي عند ضربه بأي رقم من 1 إلى طوله،\nينتج عنه تبديل للأرقام الأصلية.\n\nأمثلة:\n>>> isCyclicNumber(\"142857\")\n1 // لأن 142857 هو رقم دوري\n>>> isCyclicNumber(\"123456\")\n0 // لأن 123456 ليس رقمًا دوريًا",
      "sw": "Inabainisha kama namba iliyotolewa kwa njia ya maandishi ni namba ya mzunguko.\nNamba ya mzunguko ni ile ambapo kuizidisha na namba yoyote kutoka 1 hadi urefu wake,\nhusababisha mpangilio upya wa namba ya awali.\n\nMifano:\n>>> isCyclicNumber(\"142857\")\n1 // kwa kuwa 142857 ni namba ya mzunguko\n>>> isCyclicNumber(\"123456\")\n0 // kwa kuwa 123456 si namba ya mzunguko",
      "tr": "Verilen bir sayı dizisinin döngüsel bir sayı olup olmadığını belirler.\nDöngüsel bir sayı, 1'den uzunluğuna kadar herhangi bir sayı ile çarpıldığında,\norijinal sayının bir permütasyonu olan bir sayıdır.\n\nÖrnekler:\n>>> isCyclicNumber(\"142857\")\n1 // çünkü 142857 döngüsel bir sayıdır\n>>> isCyclicNumber(\"123456\")\n0 // çünkü 123456 döngüsel bir sayı değildir",
      "vi": "Xác định xem một chuỗi số cho trước có phải là số tuần hoàn hay không.  \nMột số tuần hoàn là số mà khi nhân nó với bất kỳ số nào từ 1 đến độ dài của nó,  \nkết quả là một hoán vị của số gốc.  \n\nVí dụ:  \n>>> isCyclicNumber(\"142857\")  \n1 // vì 142857 là một số tuần hoàn  \n>>> isCyclicNumber(\"123456\")  \n0 // vì 123456 không phải là một số tuần hoàn  "
    },
    "docstring_bertscore": {
      "es": "0.9841463161377004",
      "arb": "0.9614752403375214",
      "sw": "0.945611426325789",
      "tr": "0.9520101054204468",
      "vi": "0.945207213500383"
    }
  },
  {
    "task_id": "Kotlin/30",
    "prompt": {
      "en": "/**\n    * Sum the given list of fractions and simplify the resulting fraction.\n    * The simplification process involves finding the greatest common divisor (GCD)\n    * of the numerator and the denominator and dividing both by this GCD. \n    * If the denominator after simplification is 1, only the numerator is returned.\n    *\n    * Example:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "es": "/**\n    * Sumar la lista dada de fracciones y simplificar la fracción resultante.\n    * El proceso de simplificación implica encontrar el máximo común divisor (MCD)\n    * del numerador y el denominador y dividir ambos por este MCD.\n    * Si el denominador después de la simplificación es 1, solo se devuelve el numerador.\n    *\n    * Ejemplo:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "arb": "/**\n    * جمع قائمة الكسور المعطاة وتبسيط الكسر الناتج.\n    * تتضمن عملية التبسيط إيجاد القاسم المشترك الأكبر (GCD)\n    * للبسط والمقام وقسمة كلاهما على هذا القاسم المشترك الأكبر.\n    * إذا كان المقام بعد التبسيط هو 1، يتم إرجاع البسط فقط.\n    *\n    * مثال:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "sw": "/**\n    * Jumlisha orodha iliyotolewa ya sehemu na rahisisha sehemu inayopatikana.\n    * Mchakato wa urahisishaji unahusisha kutafuta mgawanyiko mkubwa zaidi (GCD)\n    * wa numerator na denominator na kugawanya zote mbili kwa GCD hii.\n    * Ikiwa denominator baada ya urahisishaji ni 1, ni numerator pekee inayorejeshwa.\n    *\n    * Mfano:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "tr": "/**\n    * Verilen kesirler listesini topla ve ortaya çıkan kesiri sadeleştir.\n    * Sadeleştirme süreci, pay ve paydanın en büyük ortak bölenini (EBOB) bulmayı\n    * ve her ikisini de bu EBOB ile bölmeyi içerir.\n    * Sadeleştirme sonrası payda 1 ise, sadece pay döndürülür.\n    *\n    * Örnek:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "vi": "/**\n    * Tính tổng danh sách các phân số đã cho và rút gọn phân số kết quả.\n    * Quá trình rút gọn bao gồm việc tìm ước số chung lớn nhất (GCD)\n    * của tử số và mẫu số và chia cả hai cho GCD này.\n    * Nếu mẫu số sau khi rút gọn là 1, chỉ trả về tử số.\n    *\n    * Ví dụ:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String"
    },
    "prompt_bertscore": {
      "es": "0.9942635545957125",
      "arb": "0.9852636120310216",
      "sw": "0.9906280227316309",
      "tr": "0.9980411071822339",
      "vi": "0.9767487248568181"
    },
    "canonical_solution": "{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b",
    "instruction": {
      "en": "Write a Kotlin function `fun sumAndSimplifyFractions(fractions: List<String>): String` to solve the following problem:\nSum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "es": "Escribe una función en Kotlin `fun sumAndSimplifyFractions(fractions: List<String>): String` para resolver el siguiente problema:\nSuma la lista dada de fracciones y simplifica la fracción resultante.\nEl proceso de simplificación implica encontrar el máximo común divisor (GCD)\ndel numerador y el denominador y dividir ambos por este GCD.\nSi el denominador después de la simplificación es 1, solo se devuelve el numerador.\n\nEjemplo:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "arb": "اكتب دالة كوتلن `fun sumAndSimplifyFractions(fractions: List<String>): String` لحل المشكلة التالية:\nاجمع قائمة الكسور المعطاة وبسط الكسر الناتج.\nتشمل عملية التبسيط إيجاد القاسم المشترك الأكبر (GCD)\nللبسط والمقام وقسمة كلاهما على هذا القاسم المشترك.\nإذا كان المقام بعد التبسيط هو 1، يتم إرجاع البسط فقط.\n\nمثال:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "sw": "Andika kazi ya Kotlin `fun sumAndSimplifyFractions(fractions: List<String>): String` kutatua tatizo lifuatalo:\nJumlisha orodha iliyotolewa ya sehemu na rahisisha sehemu inayotokana.\nMchakato wa kurahisisha unahusisha kutafuta mgawanyiko mkuu zaidi (GCD)\nwa kipatanishi na kipatanishi na kugawa vyote viwili kwa GCD hii.\nIkiwa kipatanishi baada ya kurahisishwa ni 1, basi kipatanishi pekee ndicho kinachorejeshwa.\n\nMfano:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "tr": "Bir Kotlin fonksiyonu `fun sumAndSimplifyFractions(fractions: List<String>): String` yazın ve aşağıdaki problemi çözün:\nVerilen kesirler listesini toplayın ve ortaya çıkan kesiri sadeleştirin.\nSadeleştirme işlemi, pay ve paydanın en büyük ortak bölenini (GCD) bulmayı\nve her ikisini de bu GCD ile bölmeyi içerir.\nSadeleştirmeden sonra payda 1 ise, sadece pay döndürülür.\n\nÖrnek:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "vi": "Viết một hàm Kotlin `fun sumAndSimplifyFractions(fractions: List<String>): String` để giải quyết vấn đề sau:\nTính tổng danh sách các phân số đã cho và rút gọn phân số kết quả.\nQuá trình rút gọn bao gồm việc tìm ước chung lớn nhất (GCD)\ncủa tử số và mẫu số và chia cả hai cho GCD này.\nNếu mẫu số sau khi rút gọn là 1, chỉ trả về tử số.\n\nVí dụ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\""
    },
    "instruction_bertscore": {
      "es": "0.9954986383049874",
      "arb": "0.987975512623291",
      "sw": "0.9921119903083425",
      "tr": "0.9871317307646548",
      "vi": "0.9787427752520274"
    },
    "level": "hard",
    "test": "fun main() {\n    check(sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\")) == \"5/6\")\n    check(sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\")) == \"3/4\")\n    check(sumAndSimplifyFractions(listOf(\"1/8\", \"3/8\")) == \"1/2\")\n    check(sumAndSimplifyFractions(listOf(\"2/3\", \"1/3\")) == \"1\")\n}\n\n\nmain()",
    "entry_point": "sumAndSimplifyFractions",
    "signature": "fun sumAndSimplifyFractions(fractions: List<String>): String",
    "docstring": {
      "en": "Sum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "es": "Suma la lista dada de fracciones y simplifica la fracción resultante. El proceso de simplificación implica encontrar el máximo común divisor (MCD) del numerador y el denominador y dividir ambos por este MCD. Si el denominador después de la simplificación es 1, solo se devuelve el numerador.\n\nEjemplo:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "arb": "جمع قائمة الكسور المعطاة وتبسيط الكسر الناتج. تتضمن عملية التبسيط إيجاد القاسم المشترك الأكبر (GCD) للبسط والمقام وقسمة كليهما على هذا القاسم المشترك. إذا كان المقام بعد التبسيط هو 1، يتم إرجاع البسط فقط.\n\nمثال:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "sw": "Jumlisha orodha iliyotolewa ya sehemu na rahisisha sehemu inayopatikana. Mchakato wa kurahisisha unahusisha kutafuta mgawanyiko mkubwa zaidi wa kawaida (GCD) wa kizio na kipeo na kugawa vyote viwili kwa GCD hii. Ikiwa kipeo baada ya kurahisisha ni 1, ni kizio pekee kinachorejeshwa.\n\nMfano:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "tr": "Verilen kesirler listesini toplayın ve ortaya çıkan kesiri sadeleştirin. Sadeleştirme işlemi, pay ve paydanın en büyük ortak bölenini (EBOB) bulmayı ve her ikisini de bu EBOB ile bölmeyi içerir. Sadeleştirme sonrası payda 1 ise, yalnızca pay döndürülür.\n\nÖrnek:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "vi": "Tính tổng danh sách các phân số đã cho và rút gọn phân số kết quả. Quá trình rút gọn bao gồm việc tìm ước số chung lớn nhất (GCD) của tử số và mẫu số và chia cả hai cho GCD này. Nếu mẫu số sau khi rút gọn là 1, chỉ trả về tử số.\n\nVí dụ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\""
    },
    "docstring_bertscore": {
      "es": "0.9930213201927203",
      "arb": "0.986461154598281",
      "sw": "0.9890675824582208",
      "tr": "0.9936591223462232",
      "vi": "0.9734359673619182"
    }
  },
  {
    "task_id": "Kotlin/31",
    "prompt": {
      "en": "/**\n    * Calculate the number of various denominations of currency required to make up a given amount.\n    * The function takes an integer representing the total amount and returns a list of integers.\n    * The list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\n    * The goal is to minimize the total number of notes by using larger denominations where possible.\n    *\n    * Example:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "es": "/**\n    * Calcular el número de varias denominaciones de moneda necesarias para componer una cantidad dada.\n    * La función toma un entero que representa la cantidad total y devuelve una lista de enteros.\n    * La lista contiene el número de billetes de 100, 50, 20, 10, 5 y 1 yuan necesarios, en ese orden.\n    * El objetivo es minimizar el número total de billetes utilizando denominaciones más grandes cuando sea posible.\n    *\n    * Ejemplo:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "arb": "/**\n    * حساب عدد الفئات المختلفة من العملة المطلوبة لتكوين مبلغ معين.\n    * تأخذ الدالة عددًا صحيحًا يمثل المبلغ الإجمالي وتعيد قائمة من الأعداد الصحيحة.\n    * تحتوي القائمة على عدد الأوراق النقدية من فئة 100، 50، 20، 10، 5، و1 يوان المطلوبة، بهذا الترتيب.\n    * الهدف هو تقليل العدد الإجمالي للأوراق النقدية باستخدام الفئات الأكبر حيثما أمكن.\n    *\n    * مثال:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "sw": "/**\n    * Hesabu idadi ya aina mbalimbali za sarafu zinazohitajika kutengeneza kiasi kilichopewa.\n    * Kazi inachukua nambari nzima inayowakilisha jumla ya kiasi na inarudisha orodha ya nambari nzima.\n    * Orodha ina idadi ya noti za yuan 100, 50, 20, 10, 5, na 1 zinazohitajika, kwa mpangilio huo.\n    * Lengo ni kupunguza jumla ya idadi ya noti kwa kutumia sarafu kubwa inapowezekana.\n    *\n    * Mfano:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "tr": "/**\n    * Belirli bir miktarı oluşturmak için gereken çeşitli para birimlerinin sayısını hesaplayın.\n    * Fonksiyon, toplam miktarı temsil eden bir tamsayı alır ve bir tamsayı listesi döndürür.\n    * Liste, sırasıyla gereken 100, 50, 20, 10, 5 ve 1 yuan banknotlarının sayısını içerir.\n    * Amaç, mümkün olduğunca büyük banknotları kullanarak toplam banknot sayısını en aza indirmektir.\n    *\n    * Örnek:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "vi": "/**\n    * Tính số lượng các mệnh giá tiền khác nhau cần thiết để tạo thành một số tiền cho trước.\n    * Hàm nhận một số nguyên đại diện cho tổng số tiền và trả về một danh sách các số nguyên.\n    * Danh sách chứa số lượng tờ tiền 100, 50, 20, 10, 5, và 1 nhân dân tệ cần thiết, theo thứ tự đó.\n    * Mục tiêu là giảm thiểu tổng số lượng tờ tiền bằng cách sử dụng các mệnh giá lớn hơn nếu có thể.\n    *\n    * Ví dụ:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9755783946517605",
      "arb": "0.9773259447441054",
      "sw": "0.9730321517972743",
      "tr": "0.9537681829229867",
      "vi": "0.9769739717089116"
    },
    "canonical_solution": "{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateCurrency(amount: Int): List<Int>` to solve the following problem:\nCalculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "es": "Escribe una función de Kotlin `fun calculateCurrency(amount: Int): List<Int>` para resolver el siguiente problema:\nCalcular el número de varias denominaciones de moneda necesarias para componer una cantidad dada.\nLa función toma un entero que representa la cantidad total y devuelve una lista de enteros.\nLa lista contiene el número de billetes de 100, 50, 20, 10, 5 y 1 yuan necesarios, en ese orden.\nEl objetivo es minimizar el número total de billetes utilizando denominaciones más grandes cuando sea posible.\n\nEjemplo:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "arb": "اكتب دالة كوتلن `fun calculateCurrency(amount: Int): List<Int>` لحل المشكلة التالية:\nاحسب عدد الفئات المختلفة من العملة المطلوبة لتكوين مبلغ معين.\nتأخذ الدالة عددًا صحيحًا يمثل المبلغ الإجمالي وتعيد قائمة من الأعداد الصحيحة.\nتحتوي القائمة على عدد الأوراق النقدية من فئات 100، 50، 20، 10، 5، و1 يوان، بهذا الترتيب.\nالهدف هو تقليل العدد الإجمالي للأوراق باستخدام الفئات الأكبر حيثما أمكن.\n\nمثال:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "sw": "Andika kazi ya Kotlin `fun calculateCurrency(amount: Int): List<Int>` kutatua tatizo lifuatalo:\nHesabu idadi ya madhehebu mbalimbali ya sarafu yanayohitajika kutengeneza kiasi kilichopewa.\nKazi inachukua nambari nzima inayowakilisha jumla ya kiasi na inarejesha orodha ya nambari nzima.\nOrodha ina idadi ya noti za yuan 100, 50, 20, 10, 5, na 1 zinazohitajika, kwa mpangilio huo.\nLengo ni kupunguza idadi ya jumla ya noti kwa kutumia madhehebu makubwa inapowezekana.\n\nMfano:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "tr": "Bir Kotlin fonksiyonu `fun calculateCurrency(amount: Int): List<Int>` yazın ve aşağıdaki problemi çözün:\nBelirli bir miktarı oluşturmak için gereken çeşitli para birimlerinin sayısını hesaplayın.\nFonksiyon, toplam miktarı temsil eden bir tam sayı alır ve bir tam sayı listesi döndürür.\nListe, sırasıyla 100, 50, 20, 10, 5 ve 1 yuan banknotlarının sayısını içerir.\nAmaç, mümkün olduğunca büyük para birimlerini kullanarak toplam banknot sayısını en aza indirmektir.\n\nÖrnek:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "vi": "Viết một hàm Kotlin `fun calculateCurrency(amount: Int): List<Int>` để giải quyết vấn đề sau:  \nTính toán số lượng các mệnh giá tiền tệ khác nhau cần thiết để tạo thành một số tiền nhất định.  \nHàm nhận một số nguyên đại diện cho tổng số tiền và trả về một danh sách các số nguyên.  \nDanh sách chứa số lượng tờ tiền 100, 50, 20, 10, 5, và 1 nhân dân tệ cần thiết, theo thứ tự đó.  \nMục tiêu là giảm thiểu tổng số tờ tiền bằng cách sử dụng các mệnh giá lớn hơn nếu có thể.  \n\nVí dụ:  \n>>> calculateCurrency(735)  \n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735  \n>>> calculateCurrency(123)  \n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123  "
    },
    "instruction_bertscore": {
      "es": "0.9822219850062344",
      "arb": "0.9803004347001029",
      "sw": "0.995968995047278",
      "tr": "0.9591190867576855",
      "vi": "0.9853845779330719"
    },
    "level": "easy",
    "test": "fun main() {\n    check(calculateCurrency(735) == listOf(7, 0, 1, 1, 1, 0))\n    check(calculateCurrency(123) == listOf(1, 0, 1, 0, 0, 3))\n    check(calculateCurrency(980) == listOf(9, 1, 1, 1, 0, 0))\n    check(calculateCurrency(50) == listOf(0, 1, 0, 0, 0, 0))\n}\n\nmain()",
    "entry_point": "calculateCurrency",
    "signature": "fun calculateCurrency(amount: Int): List<Int>",
    "docstring": {
      "en": "Calculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "es": "Calcular el número de diversas denominaciones de moneda necesarias para formar una cantidad dada. La función toma un entero que representa el monto total y devuelve una lista de enteros. La lista contiene el número de billetes de 100, 50, 20, 10, 5 y 1 yuan necesarios, en ese orden. El objetivo es minimizar el número total de billetes utilizando denominaciones más grandes cuando sea posible.\n\nEjemplo:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "arb": "حساب عدد الفئات المختلفة من العملة المطلوبة لتكوين مبلغ معين.\nتأخذ الدالة عددًا صحيحًا يمثل المبلغ الإجمالي وتعيد قائمة من الأعداد الصحيحة.\nتحتوي القائمة على عدد الأوراق النقدية من فئات 100، 50، 20، 10، 5، و1 يوان المطلوبة، بهذا الترتيب.\nالهدف هو تقليل العدد الإجمالي للأوراق النقدية باستخدام الفئات الأكبر حيثما أمكن.\n\nمثال:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "sw": "Hesabu idadi ya madhehebu mbalimbali ya sarafu yanayohitajika kutengeneza kiasi kilichopewa.\nKazi inachukua nambari nzima inayowakilisha jumla ya kiasi na inarudisha orodha ya nambari nzima.\nOrodha ina idadi ya noti za yuan 100, 50, 20, 10, 5, na 1 zinazohitajika, kwa mpangilio huo.\nLengo ni kupunguza jumla ya idadi ya noti kwa kutumia madhehebu makubwa inapowezekana.\n\nMfano:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "tr": "Verilen bir miktarı oluşturmak için gereken çeşitli para birimlerinin sayısını hesaplayın.\nFonksiyon, toplam miktarı temsil eden bir tamsayı alır ve bir tamsayı listesi döndürür.\nListe, sırasıyla gereken 100, 50, 20, 10, 5 ve 1 yuan banknotlarının sayısını içerir.\nAmaç, mümkün olduğunca büyük para birimlerini kullanarak toplam banknot sayısını en aza indirmektir.\n\nÖrnek:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "vi": "Tính số lượng các mệnh giá tiền tệ khác nhau cần thiết để tạo thành một số tiền cho trước. Hàm nhận một số nguyên đại diện cho tổng số tiền và trả về một danh sách các số nguyên. Danh sách chứa số lượng tờ tiền 100, 50, 20, 10, 5 và 1 nhân dân tệ cần thiết, theo thứ tự đó. Mục tiêu là giảm thiểu tổng số tờ tiền bằng cách sử dụng các mệnh giá lớn hơn nếu có thể.\n\nVí dụ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123"
    },
    "docstring_bertscore": {
      "es": "0.9796999750582345",
      "arb": "0.9658143210112285",
      "sw": "0.9800018932374075",
      "tr": "0.9562035900248554",
      "vi": "0.9784118570372232"
    }
  },
  {
    "task_id": "Kotlin/32",
    "prompt": {
      "en": "\n/**\n * Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\n * The search is conducted in ascending order.\n *\n * Example:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "es": "/**\n * Encuentra el n-ésimo número de tres dígitos que es un cuadrado perfecto y tiene al menos dos dígitos idénticos.\n * La búsqueda se realiza en orden ascendente.\n *\n * Ejemplo:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "arb": "/**\n * يجد العدد ذو الثلاثة أرقام الذي هو مربع كامل وله على الأقل رقمين متطابقين في الترتيب n.\n * يتم البحث بترتيب تصاعدي.\n *\n * مثال:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "sw": "/**\n * Inapata nambari ya tatu ya tarakimu tatu ambayo ni mraba kamili na ina angalau tarakimu mbili zinazofanana.\n * Utafutaji unafanywa kwa mpangilio wa kupanda.\n *\n * Mfano:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "tr": "/**\n * En az iki aynı rakama sahip olan ve mükemmel kare olan n'inci üç basamaklı sayıyı bulur.\n * Arama artan sırayla yapılır.\n *\n * Örnek:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "vi": "/**\n * Tìm số có ba chữ số thứ n là số chính phương và có ít nhất hai chữ số giống nhau.\n * Việc tìm kiếm được thực hiện theo thứ tự tăng dần.\n *\n * Ví dụ:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9784893228858268",
      "sw": "0.9773384584581106",
      "tr": "0.9783757063078748",
      "vi": "0.9837315759020996"
    },
    "canonical_solution": "{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` to solve the following problem:\nFinds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "es": "Escribe una función en Kotlin `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` para resolver el siguiente problema:\nEncuentra el n-ésimo número de tres dígitos que es un cuadrado perfecto y tiene al menos dos dígitos idénticos.\nLa búsqueda se realiza en orden ascendente.\n\nEjemplo:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "arb": "اكتب دالة كوتلن `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` لحل المشكلة التالية:\nتجد الرقم ذو الثلاثة أرقام الذي هو مربع كامل وله على الأقل رقمين متطابقين.\nيتم البحث بترتيب تصاعدي.\n\nمثال:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "sw": "Andika kazi ya Kotlin `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` kutatua tatizo lifuatalo:\nInapata nambari ya tatu yenye tarakimu tatu ambayo ni mraba kamili na ina angalau tarakimu mbili zinazofanana.\nUtafutaji unafanywa kwa mpangilio wa kupanda.\n\nMfano:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "tr": "Bir Kotlin fonksiyonu `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` yazarak aşağıdaki problemi çözün:\nEn az iki aynı rakama sahip, üç basamaklı ve mükemmel kare olan n-inci sayıyı bulur.\nArama artan sırayla yapılır.\n\nÖrnek:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "vi": "Viết một hàm Kotlin `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` để giải quyết vấn đề sau:\nTìm số thứ n có ba chữ số là số chính phương và có ít nhất hai chữ số giống nhau.\nViệc tìm kiếm được thực hiện theo thứ tự tăng dần.\n\nVí dụ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121"
    },
    "instruction_bertscore": {
      "es": "0.9905491664703601",
      "arb": "0.9767350193605266",
      "sw": "0.975558531613657",
      "tr": "0.9728778159912101",
      "vi": "0.9866963329694263"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findNthSquareNumberWithDuplicateDigits(1) == 100)\n    check(findNthSquareNumberWithDuplicateDigits(2) == 121)\n    check(findNthSquareNumberWithDuplicateDigits(3) == 144)  // Example of another test case\n    check(findNthSquareNumberWithDuplicateDigits(4) == 225)  // Example of another test case\n}\n\n\nmain()",
    "entry_point": "findNthSquareNumberWithDuplicateDigits",
    "signature": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
    "docstring": {
      "en": "Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "es": "Encuentra el n-ésimo número de tres dígitos que es un cuadrado perfecto y tiene al menos dos dígitos idénticos.  \nLa búsqueda se realiza en orden ascendente.\n\nEjemplo:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "arb": "يجد الرقم الثلاثي الأرقام n الذي يكون مربعًا كاملاً وله على الأقل رقمين متطابقين. يتم إجراء البحث بترتيب تصاعدي.\n\nمثال:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "sw": "Inapata nambari ya tatu ya tarakimu tatu ambayo ni mraba kamili na ina angalau tarakimu mbili zinazofanana. Utafutaji unafanywa kwa mpangilio wa kupanda.\n\nMfano:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "tr": "n'inci üç basamaklı, en az iki aynı rakama sahip ve tam kare olan sayıyı bulur. Arama artan sırayla yapılır.\n\nÖrnek:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "vi": "Tìm số có ba chữ số thứ n là số chính phương và có ít nhất hai chữ số giống nhau. \nViệc tìm kiếm được thực hiện theo thứ tự tăng dần.\n\nVí dụ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121"
    },
    "docstring_bertscore": {
      "es": "0.9893049457635574",
      "arb": "0.9658071703175113",
      "sw": "0.9565257685028941",
      "tr": "0.993458505661378",
      "vi": "0.9797617491067363"
    }
  },
  {
    "task_id": "Kotlin/33",
    "prompt": {
      "en": "/**\n    * Finds the longest word in a given simple English sentence. The sentence ends with a period,\n    * and words are separated by spaces. It assumes no abbreviations or special forms are present.\n    * If there are multiple longest words of the same length, the first one is returned.\n    *\n    * Example:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "es": "/**\n    * Encuentra la palabra más larga en una oración simple en inglés dada. La oración termina con un punto,\n    * y las palabras están separadas por espacios. Se asume que no hay abreviaturas o formas especiales presentes.\n    * Si hay múltiples palabras más largas de la misma longitud, se devuelve la primera.\n    *\n    * Ejemplo:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "arb": "/**\n    * يجد أطول كلمة في جملة إنجليزية بسيطة معطاة. تنتهي الجملة بنقطة،\n    * والكلمات مفصولة بمسافات. يفترض عدم وجود اختصارات أو أشكال خاصة.\n    * إذا كانت هناك عدة كلمات طويلة بنفس الطول، يتم إرجاع الأولى.\n    *\n    * مثال:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "sw": "/**\n    * Inapata neno refu zaidi katika sentensi rahisi ya Kiingereza iliyotolewa. Sentensi inaishia na nukta,\n    * na maneno yanatenganishwa na nafasi. Inadhani hakuna vifupisho au aina maalum zilizopo.\n    * Ikiwa kuna maneno marefu zaidi ya moja yenye urefu sawa, la kwanza litarudishwa.\n    *\n    * Mfano:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String ",
      "tr": "/**\n    * Verilen basit bir İngilizce cümledeki en uzun kelimeyi bulur. Cümle bir nokta ile biter\n    * ve kelimeler boşluklarla ayrılır. Kısaltmalar veya özel biçimler olmadığı varsayılır.\n    * Aynı uzunlukta birden fazla en uzun kelime varsa, ilki döndürülür.\n    *\n    * Örnek:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String ",
      "vi": "/**\n    * Tìm từ dài nhất trong một câu tiếng Anh đơn giản cho trước. Câu kết thúc bằng dấu chấm,\n    * và các từ được ngăn cách bằng dấu cách. Giả sử không có chữ viết tắt hoặc dạng đặc biệt nào.\n    * Nếu có nhiều từ dài nhất có cùng độ dài, từ đầu tiên sẽ được trả về.\n    *\n    * Ví dụ:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String "
    },
    "prompt_bertscore": {
      "es": "0.9815537924044331",
      "arb": "0.9828043692834287",
      "sw": "0.9785183229214579",
      "tr": "0.9823270604778018",
      "vi": "0.9780642538704121"
    },
    "canonical_solution": "{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findLongestWord(sentence: String): String` to solve the following problem:\nFinds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "es": "Escribe una función en Kotlin `fun findLongestWord(sentence: String): String` para resolver el siguiente problema:\nEncuentra la palabra más larga en una oración simple en inglés dada. La oración termina con un punto, y las palabras están separadas por espacios. Se asume que no hay abreviaturas ni formas especiales presentes. Si hay múltiples palabras más largas de la misma longitud, se devuelve la primera.\n\nEjemplo:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "arb": "اكتب دالة Kotlin `fun findLongestWord(sentence: String): String` لحل المشكلة التالية:\nتجد أطول كلمة في جملة إنجليزية بسيطة معطاة. تنتهي الجملة بنقطة، والكلمات مفصولة بمسافات. تفترض عدم وجود اختصارات أو أشكال خاصة.\nإذا كانت هناك عدة كلمات طويلة بنفس الطول، يتم إرجاع الأولى.\n\nمثال:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "sw": "Andika kazi ya Kotlin `fun findLongestWord(sentence: String): String` kutatua tatizo lifuatalo:\nInapata neno refu zaidi katika sentensi rahisi ya Kiingereza iliyotolewa. Sentensi inaishia na nukta,\nna maneno yanatenganishwa na nafasi. Inadhaniwa hakuna vifupisho au aina maalum zilizopo.\nKama kuna maneno marefu zaidi yenye urefu sawa, la kwanza ndilo linalorejeshwa.\n\nMfano:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "tr": "Bir Kotlin fonksiyonu `fun findLongestWord(sentence: String): String` yazın ve aşağıdaki problemi çözün:\nVerilen basit bir İngilizce cümledeki en uzun kelimeyi bulur. Cümle bir nokta ile biter ve kelimeler boşluklarla ayrılır. Kısaltmalar veya özel biçimler olmadığı varsayılır. Aynı uzunlukta birden fazla en uzun kelime varsa, ilk olanı döndürülür.\n\nÖrnek:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "vi": "Viết một hàm Kotlin `fun findLongestWord(sentence: String): String` để giải quyết vấn đề sau:\nTìm từ dài nhất trong một câu tiếng Anh đơn giản đã cho. Câu kết thúc bằng dấu chấm, và các từ được ngăn cách bằng dấu cách. Giả sử không có viết tắt hoặc dạng đặc biệt nào có mặt.\nNếu có nhiều từ dài nhất có cùng độ dài, từ đầu tiên sẽ được trả về.\n\nVí dụ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\""
    },
    "instruction_bertscore": {
      "es": "0.9749566815591213",
      "arb": "0.9840885146968192",
      "sw": "0.975450278055993",
      "tr": "0.9738290568859862",
      "vi": "0.9831390614754725"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findLongestWord(\"I am a student of Peking University.\") == \"University\")\n    check(findLongestWord(\"Hello world.\") == \"Hello\")\n    check(findLongestWord(\"Short sentences are sweet.\") == \"sentences\")\n    check(findLongestWord(\"Each word has its own length.\") == \"length\")\n}\n\n\nmain()",
    "entry_point": "findLongestWord",
    "signature": "fun findLongestWord(sentence: String): String",
    "docstring": {
      "en": "Finds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "es": "Encuentra la palabra más larga en una oración simple en inglés dada. La oración termina con un punto, y las palabras están separadas por espacios. Se asume que no hay abreviaturas o formas especiales presentes. Si hay múltiples palabras más largas de la misma longitud, se devuelve la primera.\n\nEjemplo:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "arb": "يجد أطول كلمة في جملة إنجليزية بسيطة معينة. تنتهي الجملة بنقطة، والكلمات مفصولة بمسافات. يفترض عدم وجود اختصارات أو أشكال خاصة. إذا كانت هناك عدة كلمات طويلة بنفس الطول، يتم إرجاع الأولى.\n\nمثال:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "sw": "Inapata neno refu zaidi katika sentensi rahisi ya Kiingereza iliyotolewa. Sentensi inamalizika na nukta, na maneno yanatenganishwa na nafasi. Inadhaniwa hakuna vifupisho au aina maalum zilizopo. Ikiwa kuna maneno marefu zaidi ya moja yenye urefu sawa, la kwanza ndilo linalorejeshwa.\n\nMfano:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "tr": "Verilen basit bir İngilizce cümledeki en uzun kelimeyi bulur. Cümle bir nokta ile biter ve kelimeler boşluklarla ayrılır. Kısaltmalar veya özel biçimler olmadığı varsayılır. Aynı uzunlukta birden fazla en uzun kelime varsa, ilk bulunan kelime döndürülür.\n\nÖrnek:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "vi": "Tìm từ dài nhất trong một câu tiếng Anh đơn giản cho trước. Câu kết thúc bằng dấu chấm, và các từ được ngăn cách bởi dấu cách. Giả sử không có chữ viết tắt hoặc dạng đặc biệt nào có mặt. Nếu có nhiều từ dài nhất có cùng độ dài, từ đầu tiên sẽ được trả về.\n\nVí dụ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\""
    },
    "docstring_bertscore": {
      "es": "0.9713273072368518",
      "arb": "0.9675485628680441",
      "sw": "0.9699327233316059",
      "tr": "0.9718608284403115",
      "vi": "0.976839101680189"
    }
  },
  {
    "task_id": "Kotlin/34",
    "prompt": {
      "en": "/**\n    * Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\n    * Assumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n    *\n    * Example:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // For a leap year\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // For end of the year\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "es": "/**\n    * Calcula la fecha del día siguiente basada en una fecha dada en el formato aaaa-mm-dd.\n    * Asume fechas de entrada válidas que van desde 1600-01-01 hasta 2999-12-30.\n    *\n    * Ejemplo:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Para un año bisiesto\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Para fin de año\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "arb": "/**\n    * يحسب تاريخ اليوم التالي بناءً على تاريخ معين بالتنسيق yyyy-mm-dd.\n    * يفترض تواريخ إدخال صالحة تتراوح من 1600-01-01 إلى 2999-12-30.\n    *\n    * مثال:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // لسنة كبيسة\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // لنهاية السنة\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "sw": "/**\n    * Inahesabu tarehe ya siku inayofuata kulingana na tarehe iliyotolewa katika muundo wa yyyy-mm-dd.\n    * Inadhani tarehe za pembejeo halali kuanzia 1600-01-01 hadi 2999-12-30.\n    *\n    * Mfano:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Kwa mwaka wa kuruka\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Kwa mwisho wa mwaka\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "tr": "/**\n    * Verilen bir tarihe göre yyyy-aa-gg formatında bir sonraki günün tarihini hesaplar.\n    * 1600-01-01 ile 2999-12-30 arasındaki geçerli giriş tarihlerini varsayar.\n    *\n    * Örnek:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Artık yıl için\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Yıl sonu için\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "vi": "/**\n    * Tính toán ngày của ngày tiếp theo dựa trên một ngày cho trước theo định dạng yyyy-mm-dd.\n    * Giả định các ngày nhập hợp lệ trong khoảng từ 1600-01-01 đến 2999-12-30.\n    *\n    * Ví dụ:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Đối với năm nhuận\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Đối với cuối năm\n**/\n\nfun getNextDayDate(currentDate: String): String "
    },
    "prompt_bertscore": {
      "es": "0.9977354150258212",
      "arb": "0.9973268323320325",
      "sw": "0.99508648026434",
      "tr": "0.9790671386642573",
      "vi": "0.9857294002745485"
    },
    "canonical_solution": "{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun getNextDayDate(currentDate: String): String` to solve the following problem:\nCalculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year",
      "es": "Escribe una función de Kotlin `fun getNextDayDate(currentDate: String): String` para resolver el siguiente problema:\nCalcula la fecha del día siguiente basada en una fecha dada en el formato yyyy-mm-dd.\nAsume fechas de entrada válidas que van desde 1600-01-01 hasta 2999-12-30.\n\nEjemplo:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Para un año bisiesto\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Para el final del año",
      "arb": "اكتب دالة Kotlin `fun getNextDayDate(currentDate: String): String` لحل المشكلة التالية:\nتحسب تاريخ اليوم التالي بناءً على تاريخ معين بالتنسيق yyyy-mm-dd.\nتفترض تواريخ إدخال صالحة تتراوح من 1600-01-01 إلى 2999-12-30.\n\nمثال:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // لسنة كبيسة\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // لنهاية السنة",
      "sw": "Andika kazi ya Kotlin `fun getNextDayDate(currentDate: String): String` kutatua tatizo lifuatalo:\nHesabu tarehe ya siku inayofuata kulingana na tarehe iliyotolewa katika muundo wa yyyy-mm-dd.\nKudhani tarehe za pembejeo halali zinazoanzia 1600-01-01 hadi 2999-12-30.\n\nMfano:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Kwa mwaka wa kuruka\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Kwa mwisho wa mwaka",
      "tr": "Bir Kotlin fonksiyonu `fun getNextDayDate(currentDate: String): String` yazın ve aşağıdaki problemi çözün:\nyyyy-mm-dd formatında verilen bir tarihe göre bir sonraki günün tarihini hesaplar.\nGeçerli giriş tarihlerini 1600-01-01 ile 2999-12-30 arasında varsayar.\n\nÖrnek:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Bir artık yıl için\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Yıl sonu için",
      "vi": "Viết một hàm Kotlin `fun getNextDayDate(currentDate: String): String` để giải quyết vấn đề sau:\nTính toán ngày của ngày tiếp theo dựa trên một ngày cho trước theo định dạng yyyy-mm-dd.\nGiả định các ngày đầu vào hợp lệ từ 1600-01-01 đến 2999-12-30.\n\nVí dụ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Đối với năm nhuận\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Đối với cuối năm"
    },
    "instruction_bertscore": {
      "es": "0.9967792083715193",
      "arb": "0.9925507648200486",
      "sw": "0.9947227880366651",
      "tr": "0.9791523510977213",
      "vi": "0.9904997075054823"
    },
    "level": "hard",
    "test": "fun main() {\n    check(getNextDayDate(\"2010-07-05\") == \"2010-07-06\")\n    check(getNextDayDate(\"2020-02-28\") == \"2020-02-29\") // Leap year case\n    check(getNextDayDate(\"2020-12-31\") == \"2021-01-01\") // End of the year case\n    check(getNextDayDate(\"2019-02-28\") == \"2019-03-01\") // Non-leap year February case\n}\n\nmain()",
    "entry_point": "getNextDayDate",
    "signature": "fun getNextDayDate(currentDate: String): String",
    "docstring": {
      "en": "Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year",
      "es": "Calcula la fecha del día siguiente basada en una fecha dada en el formato aaaa-mm-dd. Supone fechas de entrada válidas que van desde 1600-01-01 hasta 2999-12-30.\n\nEjemplo:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Para un año bisiesto\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Para el final del año",
      "arb": "يحسب تاريخ اليوم التالي بناءً على تاريخ معين بالتنسيق yyyy-mm-dd.  \nيفترض تواريخ إدخال صالحة تتراوح من 1600-01-01 إلى 2999-12-30.\n\nمثال:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // للسنة الكبيسة\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // لنهاية السنة",
      "sw": "Hesabu tarehe ya siku inayofuata kulingana na tarehe iliyotolewa katika muundo wa yyyy-mm-dd. Inadhani tarehe za pembejeo halali zinazoanzia 1600-01-01 hadi 2999-12-30.\n\nMfano:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Kwa mwaka wa kuruka\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Kwa mwisho wa mwaka",
      "tr": "Verilen tarihe göre yyyy-aa-gg formatında bir sonraki günün tarihini hesaplar.\nGeçerli giriş tarihlerini 1600-01-01 ile 2999-12-30 arasında varsayar.\n\nÖrnek:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Bir artık yıl için\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Yıl sonu için",
      "vi": "Tính toán ngày của ngày tiếp theo dựa trên một ngày cho trước theo định dạng yyyy-mm-dd. Giả định các ngày đầu vào hợp lệ trong khoảng từ 1600-01-01 đến 2999-12-30.\n\nVí dụ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Đối với năm nhuận\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Đối với cuối năm"
    },
    "docstring_bertscore": {
      "es": "0.9957769194688172",
      "arb": "0.9873661146142759",
      "sw": "0.9901542892728626",
      "tr": "0.9774248626738609",
      "vi": "0.9885455818168611"
    }
  },
  {
    "task_id": "Kotlin/35",
    "prompt": {
      "en": "/**\n    * Calculates the number of days between two given dates.\n    * The dates are provided as year, month, and day.\n    * Accounts for leap years in the calculation.\n    *\n    * Example:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "es": "/**\n    * Calcula el número de días entre dos fechas dadas.\n    * Las fechas se proporcionan como año, mes y día.\n    * Tiene en cuenta los años bisiestos en el cálculo.\n    *\n    * Ejemplo:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "arb": "/**\n    * يحسب عدد الأيام بين تاريخين معطيين.\n    * يتم تقديم التواريخ كسنة وشهر ويوم.\n    * يأخذ في الاعتبار السنوات الكبيسة في الحساب.\n    *\n    * مثال:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "sw": "/**\n    * Inahesabu idadi ya siku kati ya tarehe mbili zilizotolewa.\n    * Tarehe zinatolewa kama mwaka, mwezi, na siku.\n    * Inazingatia miaka ya kuruka katika hesabu.\n    *\n    * Mfano:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "tr": "/**\n    * İki tarih arasındaki gün sayısını hesaplar.\n    * Tarihler yıl, ay ve gün olarak sağlanır.\n    * Hesaplamada artık yılları dikkate alır.\n    *\n    * Örnek:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "vi": "/**\n    * Tính số ngày giữa hai ngày đã cho.\n    * Các ngày được cung cấp dưới dạng năm, tháng và ngày.\n    * Tính toán bao gồm cả năm nhuận.\n    *\n    * Ví dụ:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int"
    },
    "prompt_bertscore": {
      "es": "0.9909633108148178",
      "arb": "0.9909633108148178",
      "sw": "0.9885501503156249",
      "tr": "0.9856515371651828",
      "vi": "0.9837901718645048"
    },
    "canonical_solution": "{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` to solve the following problem:\nCalculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "es": "Escribe una función de Kotlin `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` para resolver el siguiente problema:\nCalcula el número de días entre dos fechas dadas.\nLas fechas se proporcionan como año, mes y día.\nTiene en cuenta los años bisiestos en el cálculo.\n\nEjemplo:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "arb": "اكتب دالة كوتلن `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` لحل المشكلة التالية:\nتحسب عدد الأيام بين تاريخين محددين.\nيتم تقديم التواريخ كسنة وشهر ويوم.\nيأخذ في الاعتبار السنوات الكبيسة في الحساب.\n\nمثال:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "sw": "Andika kazi ya Kotlin `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` kutatua tatizo lifuatalo:\nInahesabu idadi ya siku kati ya tarehe mbili zilizotolewa.\nTarehe zinatolewa kama mwaka, mwezi, na siku.\nInazingatia miaka ya kuruka katika hesabu.\n\nMfano:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "tr": "Bir Kotlin fonksiyonu `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` yazın ve aşağıdaki problemi çözün:\nİki verilen tarih arasındaki gün sayısını hesaplar.\nTarihler yıl, ay ve gün olarak sağlanır.\nHesaplamada artık yılları dikkate alır.\n\nÖrnek:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "vi": "Viết một hàm Kotlin `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` để giải quyết vấn đề sau:\nTính toán số ngày giữa hai ngày đã cho.\nCác ngày được cung cấp dưới dạng năm, tháng và ngày.\nTính đến năm nhuận trong phép tính.\n\nVí dụ:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2"
    },
    "instruction_bertscore": {
      "es": "0.9920875587714753",
      "arb": "0.9812540591594514",
      "sw": "0.9874135872753432",
      "tr": "0.9882011567361466",
      "vi": "0.9766680809221179"
    },
    "level": "hard",
    "test": "fun main() {\n    check(daysBetweenDates(2008, 1, 1, 2009, 1, 1) == 366)\n    check(daysBetweenDates(2010, 1, 1, 2010, 1, 3) == 2)\n    check(daysBetweenDates(2020, 5, 15, 2020, 5, 20) == 5)\n    check(daysBetweenDates(2019, 12, 31, 2020, 1, 1) == 1)\n}\n\n\nmain()",
    "entry_point": "daysBetweenDates",
    "signature": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
    "docstring": {
      "en": "Calculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "es": "Calcula el número de días entre dos fechas dadas.  \nLas fechas se proporcionan como año, mes y día.  \nTiene en cuenta los años bisiestos en el cálculo.\n\nEjemplo:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "arb": "يحسب عدد الأيام بين تاريخين محددين.\nيتم تقديم التواريخ كسنة وشهر ويوم.\nيأخذ في الاعتبار السنوات الكبيسة في الحساب.\n\nمثال:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "sw": "Hesabu idadi ya siku kati ya tarehe mbili zilizotolewa.  \nTarehe zinatolewa kama mwaka, mwezi, na siku.  \nInazingatia miaka ya kuruka katika hesabu.  \n\nMfano:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2",
      "tr": "İki verilen tarih arasındaki gün sayısını hesaplar.  \nTarihler yıl, ay ve gün olarak sağlanır.  \nHesaplamada artık yılları dikkate alır.  \n\nÖrnek:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2",
      "vi": "Tính toán số ngày giữa hai ngày đã cho.  \nCác ngày được cung cấp dưới dạng năm, tháng và ngày.  \nTính đến năm nhuận trong phép tính.\n\nVí dụ:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2  "
    },
    "docstring_bertscore": {
      "es": "0.9813440387220602",
      "arb": "0.9783689528749197",
      "sw": "0.9798900643328848",
      "tr": "0.9821997384035585",
      "vi": "0.975882696395506"
    }
  },
  {
    "task_id": "Kotlin/36",
    "prompt": {
      "en": "\n/**\n * Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\n * An n-gram is a contiguous sequence of n characters from the text.\n * \n * Args:\n * n (Int): The length of each n-gram.\n * text (String): The text to analyze for n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\n * and the second element is a list of n-grams with that frequency, in the order they first appear in the text.\n * If the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "es": "/**\n * Encuentra los n-gramas más frecuentes (subcadenas de longitud n) en el texto dado y su frecuencia.\n * Un n-grama es una secuencia contigua de n caracteres del texto.\n * \n * Argumentos:\n * n (Int): La longitud de cada n-grama.\n * text (String): El texto a analizar para n-gramas.\n * \n * Devuelve:\n * Pair<Int, List<String>>: Un par donde el primer elemento es la frecuencia más alta de cualquier n-grama,\n * y el segundo elemento es una lista de n-gramas con esa frecuencia, en el orden en que aparecen por primera vez en el texto.\n * Si la frecuencia más alta no es mayor que 1, devuelve \"NO\" como el único elemento en la lista.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "arb": "/**\n * يجد n-grams الأكثر تكرارًا (سلاسل فرعية بطول n) في النص المعطى وتكرارها.\n * n-gram هو تسلسل متصل من n أحرف من النص.\n * \n * يعيدالحجج:\n * n (Int): طول كل n-gram.\n * text (String): النص لتحليله من أجل n-grams.\n * \n * يعيد:\n * Pair<Int, List<String>>: زوج حيث أن العنصر الأول هو أعلى تكرار لأي n-gram،\n * والعنصر الثاني هو قائمة من n-grams مع ذلك التكرار، بترتيب ظهورها الأول في النص.\n * إذا لم يكن التكرار الأعلى أكبر من 1، يعيد \"NO\" كالعنصر الوحيد في القائمة.\n * \n * أمثلة:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "sw": "/**\n * Inapata n-gramu (vifungu vya herufi zenye urefu n) zinazojitokeza mara nyingi zaidi katika maandishi yaliyotolewa na marudio yao.\n * N-gramu ni mfululizo wa herufi n zinazofuatana kutoka kwenye maandishi.\n * \n * Hoja:\n * n (Int): Urefu wa kila n-gramu.\n * text (String): Maandishi ya kuchambua kwa n-gramu.\n * \n * Inarejesha:\n * Pair<Int, List<String>>: Jozi ambapo kipengele cha kwanza ni marudio ya juu zaidi ya n-gramu yoyote,\n * na kipengele cha pili ni orodha ya n-gramu zenye marudio hayo, kwa mpangilio wa jinsi zinavyojitokeza kwanza katika maandishi.\n * Ikiwa marudio ya juu zaidi si zaidi ya 1, inarejesha \"NO\" kama kipengele pekee katika orodha.\n * \n * Mifano:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "tr": "/**\n * Verilen metindeki en sık n-gramları (n uzunluğundaki alt diziler) ve bunların sıklığını bulur.\n * Bir n-gram, metinden ardışık n karakterlik bir dizidir.\n * \n * Argümanlar:\n * n (Int): Her n-gramın uzunluğu.\n * text (String): n-gramlar için analiz edilecek metin.\n * \n * Döndürür:\n * Pair<Int, List<String>>: İlk elemanı herhangi bir n-gramın en yüksek sıklığı olan bir çift\n * ve ikinci elemanı, metinde ilk göründükleri sırayla bu sıklığa sahip n-gramların bir listesidir.\n * Eğer en yüksek sıklık 1'den büyük değilse, listede tek eleman olarak \"NO\" döndürür.\n * \n * Örnekler:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "vi": "/**\n * Tìm các n-gram (chuỗi con có độ dài n) xuất hiện nhiều nhất trong văn bản đã cho và tần suất của chúng.\n * Một n-gram là một chuỗi liên tiếp gồm n ký tự từ văn bản.\n * \n * Tham số:\n * n (Int): Độ dài của mỗi n-gram.\n * text (String): Văn bản để phân tích n-gram.\n * \n * Trả về:\n * Pair<Int, List<String>>: Một cặp mà phần tử đầu tiên là tần suất cao nhất của bất kỳ n-gram nào,\n * và phần tử thứ hai là danh sách các n-gram có tần suất đó, theo thứ tự chúng xuất hiện đầu tiên trong văn bản.\n * Nếu tần suất cao nhất không lớn hơn 1, trả về \"NO\" như phần tử duy nhất trong danh sách.\n * \n * Ví dụ:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> "
    },
    "prompt_bertscore": {
      "es": "0.9972712158253427",
      "arb": "0.9936966634882388",
      "sw": "0.9749433733235919",
      "tr": "0.9822734302749224",
      "vi": "0.9820108409111943"
    },
    "canonical_solution": "{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` to solve the following problem:\nFinds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "es": "Escribe una función en Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` para resolver el siguiente problema:\nEncuentra los n-gramas más frecuentes (subcadenas de longitud n) en el texto dado y su frecuencia.\nUn n-grama es una secuencia contigua de n caracteres del texto.\n\nArgumentos:\nn (Int): La longitud de cada n-grama.\ntext (String): El texto a analizar para n-gramas.\n\nDevuelve:\nPair<Int, List<String>>: Un par donde el primer elemento es la frecuencia más alta de cualquier n-grama,\ny el segundo elemento es una lista de n-gramas con esa frecuencia, en el orden en que aparecen por primera vez en el texto.\nSi la frecuencia más alta no es mayor que 1, devuelve \"NO\" como el único elemento en la lista.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "arb": "اكتب دالة Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` لحل المشكلة التالية:\nتجد أكثر n-grams (سلاسل فرعية بطول n) تكرارًا في النص المعطى وتكرارها.\nn-gram هو تسلسل متجاور من n حروف من النص.\n\nالمعطيات:\nn (Int): طول كل n-gram.\ntext (String): النص لتحليل n-grams.\n\nالقيم المعادة:\nPair<Int, List<String>>: زوج حيث العنصر الأول هو أعلى تكرار لأي n-gram،\nوالعنصر الثاني هو قائمة بـ n-grams مع ذلك التكرار، بالترتيب الذي تظهر فيه لأول مرة في النص.\nإذا لم يكن التكرار الأعلى أكبر من 1، يتم إرجاع \"NO\" كالعنصر الوحيد في القائمة.\n\nأمثلة:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "sw": "Andika kazi ya Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` kutatua tatizo lifuatalo:\nInapata n-gramu (mfuatano wa herufi n) zinazojitokeza mara nyingi zaidi katika maandishi yaliyotolewa na marudio yao.\nN-gramu ni mfuatano wa herufi n kutoka kwenye maandishi.\n\nHoja:\nn (Int): Urefu wa kila n-gramu.\ntext (String): Maandishi ya kuchanganua kwa n-gramu.\n\nInarejesha:\nPair<Int, List<String>>: Jozi ambapo kipengele cha kwanza ni marudio ya juu zaidi ya n-gramu yoyote,\nna kipengele cha pili ni orodha ya n-gramu zenye marudio hayo, kwa mpangilio wa jinsi zinavyojitokeza kwanza kwenye maandishi.\nIkiwa marudio ya juu zaidi si zaidi ya 1, inarudisha \"NO\" kama kipengele pekee kwenye orodha.\n\nMifano:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "tr": "Bir Kotlin fonksiyonu `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` yazarak aşağıdaki problemi çözün:\nVerilen metinde en sık görülen n-gramları (n uzunluğundaki alt dizgiler) ve bunların sıklığını bulun.\nBir n-gram, metinden ardışık n karakterden oluşan bir dizidir.\n\nArgümanlar:\nn (Int): Her n-gramın uzunluğu.\ntext (String): n-gramlar için analiz edilecek metin.\n\nDöndürür:\nPair<Int, List<String>>: İlk elemanı herhangi bir n-gramın en yüksek sıklığı olan bir çift ve ikinci elemanı bu sıklıkla metinde ilk göründükleri sırayla n-gramların bir listesi.\nEğer en yüksek sıklık 1'den büyük değilse, listede tek eleman olarak \"NO\" döner.\n\nÖrnekler:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "vi": "Viết một hàm Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` để giải quyết vấn đề sau:\nTìm các n-gram (chuỗi con có độ dài n) xuất hiện nhiều nhất trong văn bản đã cho và tần suất của chúng.\nMột n-gram là một dãy liền kề của n ký tự từ văn bản.\n\nTham số:\nn (Int): Độ dài của mỗi n-gram.\ntext (String): Văn bản cần phân tích để tìm n-gram.\n\nTrả về:\nPair<Int, List<String>>: Một cặp mà phần tử đầu tiên là tần suất cao nhất của bất kỳ n-gram nào,\nvà phần tử thứ hai là một danh sách các n-gram có tần suất đó, theo thứ tự chúng xuất hiện đầu tiên trong văn bản.\nNếu tần suất cao nhất không lớn hơn 1, trả về \"NO\" là phần tử duy nhất trong danh sách.\n\nVí dụ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))"
    },
    "instruction_bertscore": {
      "es": "0.9963156050621839",
      "arb": "0.9888705411202342",
      "sw": "0.9744179959657547",
      "tr": "0.9805020445368533",
      "vi": "0.9862327296600909"
    },
    "level": "middle",
    "test": "fun main() {\n    check(findMostFrequentNGrams(3, \"abcdefabcd\") == Pair(2, listOf(\"abc\", \"bcd\")))\n    check(findMostFrequentNGrams(2, \"abcabc\") == Pair(2, listOf(\"ab\", \"bc\")))\n    check(findMostFrequentNGrams(4, \"abcdefg\") == Pair(1, listOf(\"NO\")))\n    check(findMostFrequentNGrams(2, \"abcdabcd\") == Pair(2, listOf(\"ab\", \"bc\", \"cd\")))\n}\n\n\nmain()",
    "entry_point": "findMostFrequentNGrams",
    "signature": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>",
    "docstring": {
      "en": "Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "es": "Encuentra los n-gramas más frecuentes (subcadenas de longitud n) en el texto dado y su frecuencia. Un n-grama es una secuencia contigua de n caracteres del texto.\n\nArgumentos:\nn (Int): La longitud de cada n-grama.\ntext (String): El texto a analizar para n-gramas.\n\nDevuelve:\nPair<Int, List<String>>: Un par donde el primer elemento es la frecuencia más alta de cualquier n-grama, y el segundo elemento es una lista de n-gramas con esa frecuencia, en el orden en que aparecen por primera vez en el texto. Si la frecuencia más alta no es mayor que 1, devuelve \"NO\" como el único elemento en la lista.\n\nEjemplos:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "arb": "يجد أكثر n-grams (تسلسلات فرعية بطول n) تكراراً في النص المعطى وتكرارها. \nn-gram هو تسلسل متجاور من n حروف من النص.\n\nالمعطيات:\nn (عدد صحيح): طول كل n-gram.\ntext (سلسلة نصية): النص لتحليل n-grams.\n\nالقيم المعادة:\nزوج<عدد صحيح، قائمة<سلسلة نصية>>: زوج حيث العنصر الأول هو أعلى تكرار لأي n-gram، \nوالعنصر الثاني هو قائمة من n-grams مع هذا التكرار، بترتيب ظهورها الأول في النص. \nإذا لم يكن التكرار الأعلى أكبر من 1، يعيد \"NO\" كالعنصر الوحيد في القائمة.\n\nأمثلة:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "sw": "Inapata n-grams (vipande vya herufi zenye urefu n) zinazojitokeza mara nyingi zaidi katika maandishi yaliyotolewa na marudio yao. N-gram ni mlolongo unaoendelea wa herufi n kutoka kwenye maandishi.\n\nHoja:\nn (Int): Urefu wa kila n-gram.\ntext (String): Maandishi ya kuchambua kwa n-grams.\n\nInarejesha:\nPair<Int, List<String>>: Jozi ambapo kipengele cha kwanza ni marudio ya juu zaidi ya n-gram yoyote,\nna kipengele cha pili ni orodha ya n-grams zenye marudio hayo, kwa mpangilio wa jinsi zinavyojitokeza kwanza kwenye maandishi.\nIkiwa marudio ya juu zaidi si zaidi ya 1, inarudisha \"NO\" kama kipengele pekee katika orodha.\n\nMifano:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "tr": "Verilen metindeki en sık n-gramları (n uzunluğundaki alt diziler) ve bunların sıklığını bulur. Bir n-gram, metinden ardışık n karakterlik bir dizidir.\n\nArgümanlar:\nn (Int): Her n-gramın uzunluğu.\ntext (String): n-gramlar için analiz edilecek metin.\n\nDöndürür:\nPair<Int, List<String>>: İlk elemanı herhangi bir n-gramın en yüksek sıklığı olan ve ikinci elemanı bu sıklığa sahip n-gramların, metinde ilk göründükleri sırayla listesi olan bir çift. En yüksek sıklık 1'den büyük değilse, listede tek eleman olarak \"NO\" döner.\n\nÖrnekler:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "vi": "Tìm các n-gram (chuỗi con có độ dài n) xuất hiện nhiều nhất trong văn bản đã cho và tần suất của chúng. Một n-gram là một dãy liên tiếp gồm n ký tự từ văn bản.\n\nTham số:\nn (Int): Độ dài của mỗi n-gram.\ntext (String): Văn bản để phân tích tìm n-grams.\n\nTrả về:\nPair<Int, List<String>>: Một cặp mà phần tử đầu tiên là tần suất cao nhất của bất kỳ n-gram nào,\nvà phần tử thứ hai là danh sách các n-gram có tần suất đó, theo thứ tự chúng xuất hiện đầu tiên trong văn bản.\nNếu tần suất cao nhất không lớn hơn 1, trả về \"NO\" là phần tử duy nhất trong danh sách.\n\nVí dụ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))"
    },
    "docstring_bertscore": {
      "es": "0.995296829837856",
      "arb": "0.9694542227436929",
      "sw": "0.9751376338362441",
      "tr": "0.9821572315020171",
      "vi": "0.9792039949967903"
    }
  },
  {
    "task_id": "Kotlin/37",
    "prompt": {
      "en": "/**\n * Divide a large number (as a string) by 13 and return the quotient and remainder.\n * The input number can be up to 100 digits long.\n *\n * Example:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "es": "/**\n * Divide un número grande (como una cadena) por 13 y devuelve el cociente y el resto.\n * El número de entrada puede tener hasta 100 dígitos.\n *\n * Ejemplo:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "arb": "/**\n * قسّم عددًا كبيرًا (كسلسلة نصية) على 13 وأعد الحاصل والباقي.\n * يمكن أن يكون الرقم المدخل طوله يصل إلى 100 رقم.\n *\n * مثال:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "sw": "/**\n * Gawa namba kubwa (kama kamba) kwa 13 na rudisha sehemu ya mgawo na baki.\n * Namba ya ingizo inaweza kuwa na urefu wa hadi tarakimu 100.\n *\n * Mfano:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "tr": "/**\n * Büyük bir sayıyı (string olarak) 13'e böl ve bölümü ve kalanı döndür.\n * Girdi sayısı 100 basamağa kadar uzun olabilir.\n *\n * Örnek:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "vi": "/**\n * Chia một số lớn (dưới dạng chuỗi) cho 13 và trả về thương và số dư.\n * Số đầu vào có thể dài tới 100 chữ số.\n *\n * Ví dụ:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> "
    },
    "prompt_bertscore": {
      "es": "0.9909696669870108",
      "arb": "1",
      "sw": "0.9885060543710351",
      "tr": "1",
      "vi": "0.9943696232191851"
    },
    "canonical_solution": "{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun divideByThirteen(number: String): Pair<String, String>` to solve the following problem:\nDivide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "es": "Escribe una función de Kotlin `fun divideByThirteen(number: String): Pair<String, String>` para resolver el siguiente problema:\nDivide un número grande (como cadena) por 13 y devuelve el cociente y el resto.\nEl número de entrada puede tener hasta 100 dígitos.\n\nEjemplo:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "arb": "اكتب دالة Kotlin `fun divideByThirteen(number: String): Pair<String, String>` لحل المشكلة التالية:\nقسّم عددًا كبيرًا (كسلسلة نصية) على 13 وأعد خارج القسمة والباقي.\nيمكن أن يصل طول الرقم المدخل إلى 100 رقم.\n\nمثال:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "sw": "Andika kazi ya Kotlin `fun divideByThirteen(number: String): Pair<String, String>` kutatua tatizo lifuatalo:\nGawanya nambari kubwa (kama kamba) kwa 13 na rudisha sehemu ya mgawo na baki.\nNambari ya ingizo inaweza kuwa hadi tarakimu 100 kwa urefu.\n\nMfano:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "tr": "Kotlin fonksiyonu `fun divideByThirteen(number: String): Pair<String, String>` yazın ve aşağıdaki problemi çözün:\nBüyük bir sayıyı (string olarak) 13'e bölün ve bölüm ile kalanı döndürün.\nGirdi sayısı en fazla 100 basamak uzunluğunda olabilir.\n\nÖrnek:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "vi": "Viết một hàm Kotlin `fun divideByThirteen(number: String): Pair<String, String>` để giải quyết vấn đề sau:\nChia một số lớn (dưới dạng chuỗi) cho 13 và trả về thương và số dư.\nSố đầu vào có thể dài tới 100 chữ số.\n\nVí dụ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")"
    },
    "instruction_bertscore": {
      "es": "0.994682664699696",
      "arb": "1",
      "sw": "0.9837027744968495",
      "tr": "0.9793321115925578",
      "vi": "0.9930380051447272"
    },
    "level": "easy",
    "test": "fun main() {\n    check(divideByThirteen(\"2132104848488485\") == Pair(\"164008065268345\", \"0\"))\n    check(divideByThirteen(\"169\") == Pair(\"13\", \"0\"))\n    check(divideByThirteen(\"20\") == Pair(\"1\", \"7\"))\n    check(divideByThirteen(\"130\") == Pair(\"10\", \"0\"))\n    check(divideByThirteen(\"0\") == Pair(\"0\", \"0\"))\n}\n\n\nmain()",
    "entry_point": "divideByThirteen",
    "signature": "fun divideByThirteen(number: String): Pair<String, String>",
    "docstring": {
      "en": "Divide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "es": "Dividir un número grande (como una cadena) por 13 y devolver el cociente y el resto.  \nEl número de entrada puede tener hasta 100 dígitos.\n\nEjemplo:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "arb": "قسّم عددًا كبيرًا (كسلسلة نصية) على 13 وأعد خارج القسمة والباقي. يمكن أن يصل طول الرقم المدخل إلى 100 رقم.\n\nمثال:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "sw": "Gawa nambari kubwa (kama kamba) kwa 13 na rudisha sehemu ya mgawanyiko na baki. Nambari ya ingizo inaweza kuwa hadi tarakimu 100 kwa urefu.\n\nMfano:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "tr": "On üçe bölün ve bölümü ve kalanı döndürün.\nGirdi numarası 100 basamağa kadar uzun olabilir.\n\nÖrnek:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "vi": "Chia một số lớn (dưới dạng chuỗi) cho 13 và trả về thương và số dư. Số đầu vào có thể dài tới 100 chữ số.\n\nVí dụ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")"
    },
    "docstring_bertscore": {
      "es": "0.9931120942768532",
      "arb": "1",
      "sw": "1",
      "tr": "0.9598488547776077",
      "vi": "0.9919489147655128"
    }
  },
  {
    "task_id": "Kotlin/38",
    "prompt": {
      "en": "/**\n    * Extracts all integer numbers from a given string and returns them as a sorted list.\n    * The integers in the string are assumed to be non-negative and separated by non-digit characters.\n    * If no integers are found, returns a list containing only zero.\n    *\n    * Example:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "es": "/**\n    * Extrae todos los números enteros de una cadena dada y los devuelve como una lista ordenada.\n    * Se asume que los enteros en la cadena son no negativos y están separados por caracteres no numéricos.\n    * Si no se encuentran enteros, devuelve una lista que contiene solo cero.\n    *\n    * Ejemplo:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "arb": "/**\n    * يستخرج جميع الأعداد الصحيحة من سلسلة معينة ويعيدها كقائمة مرتبة.\n    * يُفترض أن الأعداد الصحيحة في السلسلة غير سالبة ومفصولة بأحرف غير رقمية.\n    * إذا لم يتم العثور على أي أعداد صحيحة، يعيد قائمة تحتوي فقط على الصفر.\n    *\n    * مثال:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "sw": "/**\n    * Hutoa namba zote za mzima kutoka kwa mfuatano uliotolewa na kuzirejesha kama orodha iliyopangwa.\n    * Namba katika mfuatano zinadhaniwa kuwa zisizo na alama hasi na zimetenganishwa na herufi zisizo za namba.\n    * Ikiwa hakuna namba zilizopatikana, inarejesha orodha iliyo na sifuri pekee.\n    *\n    * Mfano:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/ \n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "tr": "/**\n    * Verilen bir string'den tüm tam sayı değerlerini çıkarır ve bunları sıralı bir liste olarak döndürür.\n    * String'deki tam sayıların negatif olmadığı ve rakam olmayan karakterlerle ayrıldığı varsayılır.\n    * Eğer hiçbir tam sayı bulunamazsa, sadece sıfır içeren bir liste döndürür.\n    *\n    * Örnek:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/ \n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "vi": "/**\n    * Trích xuất tất cả các số nguyên từ một chuỗi đã cho và trả về chúng dưới dạng danh sách đã sắp xếp.\n    * Các số nguyên trong chuỗi được giả định là không âm và được ngăn cách bởi các ký tự không phải chữ số.\n    * Nếu không tìm thấy số nguyên nào, trả về danh sách chỉ chứa số không.\n    *\n    * Ví dụ:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/ \n\nfun extractAndSortIntegers(input: String): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.98664905893874",
      "arb": "0.9804833732810361",
      "sw": "0.9611739180494915",
      "tr": "0.9911333384209836",
      "vi": "0.9895879940565322"
    },
    "canonical_solution": "{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun extractAndSortIntegers(input: String): List<Int>` to solve the following problem:\nExtracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "es": "Escribe una función de Kotlin `fun extractAndSortIntegers(input: String): List<Int>` para resolver el siguiente problema:\nExtrae todos los números enteros de una cadena dada y los devuelve como una lista ordenada.\nSe asume que los enteros en la cadena son no negativos y están separados por caracteres no numéricos.\nSi no se encuentran enteros, devuelve una lista que contiene solo cero.\n\nEjemplo:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "arb": "اكتب دالة كوتلن `fun extractAndSortIntegers(input: String): List<Int>` لحل المشكلة التالية:\nتستخرج جميع الأعداد الصحيحة من سلسلة نصية معينة وتعيدها كقائمة مرتبة.\nيُفترض أن الأعداد الصحيحة في السلسلة النصية غير سالبة ومفصولة بأحرف غير رقمية.\nإذا لم يتم العثور على أي أعداد صحيحة، تعيد قائمة تحتوي فقط على الصفر.\n\nمثال:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "sw": "Andika kazi ya Kotlin `fun extractAndSortIntegers(input: String): List<Int>` kutatua tatizo lifuatalo:\nInachukua namba zote za mzima kutoka kwa kamba iliyotolewa na kuzirudisha kama orodha iliyopangwa.\nNamba katika kamba zinadhaniwa kuwa zisizo na alama hasi na zimetenganishwa na herufi zisizo za namba.\nKama hakuna namba zilizopatikana, inarudisha orodha iliyo na sifuri pekee.\n\nMfano:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "tr": "Bir Kotlin fonksiyonu `fun extractAndSortIntegers(input: String): List<Int>` yazın ve aşağıdaki problemi çözün:\nVerilen bir string içinden tüm tam sayı değerlerini çıkarır ve bunları sıralı bir liste olarak döndürür.\nString içindeki tam sayılar negatif olmayan ve rakam olmayan karakterlerle ayrılmış olarak varsayılır.\nEğer hiçbir tam sayı bulunamazsa, yalnızca sıfır içeren bir liste döndürür.\n\nÖrnek:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "vi": "Viết một hàm Kotlin `fun extractAndSortIntegers(input: String): List<Int>` để giải quyết vấn đề sau:\nTrích xuất tất cả các số nguyên từ một chuỗi cho trước và trả về chúng dưới dạng một danh sách đã được sắp xếp.\nCác số nguyên trong chuỗi được giả định là không âm và được ngăn cách bởi các ký tự không phải số.\nNếu không tìm thấy số nguyên nào, trả về một danh sách chỉ chứa số không.\n\nVí dụ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]"
    },
    "instruction_bertscore": {
      "es": "0.982811519977146",
      "arb": "0.9793708445168596",
      "sw": "0.9721655274448191",
      "tr": "0.9747002497372053",
      "vi": "0.9881153484115396"
    },
    "level": "easy",
    "test": "check(extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\") == listOf(9, 9, 81, 88, 345, 1234, 6781, 11101))\ncheck(extractAndSortIntegers(\"no numbers\") == listOf(0))\ncheck(extractAndSortIntegers(\"123&456*789\") == listOf(123, 456, 789))\ncheck(extractAndSortIntegers(\"abc\") == listOf(0))",
    "entry_point": "extractAndSortIntegers",
    "signature": "fun extractAndSortIntegers(input: String): List<Int>",
    "docstring": {
      "en": "Extracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "es": "Extrae todos los números enteros de una cadena dada y los devuelve como una lista ordenada.  \nSe asume que los enteros en la cadena son no negativos y están separados por caracteres no numéricos.  \nSi no se encuentran enteros, devuelve una lista que contiene solo cero.\n\nEjemplo:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "arb": "يستخرج جميع الأعداد الصحيحة من سلسلة نصية معينة ويعيدها كقائمة مرتبة.\nمن المفترض أن تكون الأعداد الصحيحة في السلسلة غير سالبة ومفصولة بأحرف غير رقمية.\nإذا لم يتم العثور على أعداد صحيحة، يعيد قائمة تحتوي على الصفر فقط.\n\nمثال:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "sw": "Hutoa namba zote za mzima kutoka kwa mfuatano uliotolewa na kuzirudisha kama orodha iliyopangwa.\nNamba katika mfuatano zinadhaniwa kuwa zisizo na alama hasi na zimetenganishwa na herufi zisizo za namba.\nKama hakuna namba zilizopatikana, inarudisha orodha iliyo na sifuri pekee.\n\nMfano:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "tr": "Verilen bir string içindeki tüm tam sayıları çıkarır ve bunları sıralı bir liste olarak döndürür.\nString içindeki tam sayıların negatif olmadığı ve rakam olmayan karakterlerle ayrıldığı varsayılır.\nEğer hiçbir tam sayı bulunamazsa, yalnızca sıfır içeren bir liste döndürür.\n\nÖrnek:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "vi": "Trích xuất tất cả các số nguyên từ một chuỗi cho trước và trả về chúng dưới dạng một danh sách đã được sắp xếp.\nCác số nguyên trong chuỗi được giả định là không âm và được ngăn cách bởi các ký tự không phải chữ số.\nNếu không tìm thấy số nguyên nào, trả về một danh sách chỉ chứa số không.\n\nVí dụ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]"
    },
    "docstring_bertscore": {
      "es": "0.9690190235788454",
      "arb": "0.9914092360202411",
      "sw": "0.9593282445489153",
      "tr": "0.9783226719961385",
      "vi": "0.9873104981075862"
    }
  },
  {
    "task_id": "Kotlin/39",
    "prompt": {
      "en": "/**\n * Determines whether a given number x is an element of a set M generated from a starting number k.\n * The set M is generated as follows:\n *   (1) k is an element of M.\n *   (2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n *   (3) No other elements are in M except those generated by the above rules.\n * \n * Example:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "es": "/**\n * Determina si un número dado x es un elemento de un conjunto M generado a partir de un número inicial k.\n * El conjunto M se genera de la siguiente manera:\n *   (1) k es un elemento de M.\n *   (2) Si y es un elemento de M, entonces tanto (2y + 1) como (3y + 1) son elementos de M.\n *   (3) No hay otros elementos en M excepto los generados por las reglas anteriores.\n * \n * Ejemplo:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "arb": "/**\n * يحدد ما إذا كان الرقم المعطى x هو عنصر من المجموعة M المولدة من رقم البداية k.\n * يتم توليد المجموعة M كما يلي:\n *   (1) k هو عنصر في M.\n *   (2) إذا كان y عنصرًا في M، فإن كلا من (2y + 1) و (3y + 1) هما عنصران في M.\n *   (3) لا توجد عناصر أخرى في M باستثناء تلك التي تم توليدها بواسطة القواعد أعلاه.\n * \n * مثال:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "sw": "/**\n * Huamua kama namba fulani x ni kipengele cha seti M inayozalishwa kutoka kwa namba ya kuanzia k.\n * Seti M inazalishwa kama ifuatavyo:\n *   (1) k ni kipengele cha M.\n *   (2) Ikiwa y ni kipengele cha M, basi wote (2y + 1) na (3y + 1) ni vipengele vya M.\n *   (3) Hakuna vipengele vingine katika M isipokuwa vile vilivyozalishwa na sheria zilizo hapo juu.\n * \n * Mfano:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "tr": "/**\n * Verilen bir sayı x'in, k ile başlayan bir küme M'nin elemanı olup olmadığını belirler.\n * Küme M aşağıdaki şekilde oluşturulur:\n *   (1) k, M'nin bir elemanıdır.\n *   (2) Eğer y, M'nin bir elemanıysa, o zaman hem (2y + 1) hem de (3y + 1) M'nin elemanıdır.\n *   (3) Yukarıdaki kurallarla oluşturulanlar dışında M'de başka eleman yoktur.\n * \n * Örnek:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "vi": "/**\n * Xác định liệu một số x cho trước có phải là một phần tử của tập hợp M được tạo ra từ một số bắt đầu k hay không.\n * Tập hợp M được tạo ra như sau:\n *   (1) k là một phần tử của M.\n *   (2) Nếu y là một phần tử của M, thì cả (2y + 1) và (3y + 1) đều là phần tử của M.\n *   (3) Không có phần tử nào khác trong M ngoại trừ những phần tử được tạo ra bởi các quy tắc trên.\n * \n * Ví dụ:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String "
    },
    "prompt_bertscore": {
      "es": "0.9839083569412206",
      "arb": "0.9877387452090974",
      "sw": "0.9888892123760514",
      "tr": "0.9719811984512187",
      "vi": "0.9896646653836116"
    },
    "canonical_solution": "{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun isElementOfGeneratedSet(k: Int, x: Int): String` to solve the following problem:\nDetermines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "es": "Escriba una función de Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` para resolver el siguiente problema:\nDetermina si un número dado x es un elemento de un conjunto M generado a partir de un número inicial k.\nEl conjunto M se genera de la siguiente manera:\n(1) k es un elemento de M.\n(2) Si y es un elemento de M, entonces tanto (2y + 1) como (3y + 1) son elementos de M.\n(3) No hay otros elementos en M excepto aquellos generados por las reglas anteriores.\n\nEjemplo:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "arb": "اكتب دالة في Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` لحل المشكلة التالية:\nتحديد ما إذا كان الرقم المعطى x هو عنصر من مجموعة M المولدة من رقم البداية k.\nيتم توليد المجموعة M كما يلي:\n(1) k هو عنصر في M.\n(2) إذا كان y عنصرًا في M، فإن كلا من (2y + 1) و (3y + 1) هما عنصران في M.\n(3) لا توجد عناصر أخرى في M باستثناء تلك المولدة بواسطة القواعد المذكورة أعلاه.\n\nمثال:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "sw": "Andika kazi ya Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` kutatua tatizo lifuatalo:\nInabainisha kama nambari fulani x ni kipengele cha seti M inayozalishwa kutoka kwa nambari ya kuanzia k.\nSeti M inazalishwa kama ifuatavyo:\n(1) k ni kipengele cha M.\n(2) Ikiwa y ni kipengele cha M, basi (2y + 1) na (3y + 1) zote ni vipengele vya M.\n(3) Hakuna vipengele vingine katika M isipokuwa vile vilivyozalishwa na sheria zilizo juu.\n\nMfano:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "tr": "Bir Kotlin fonksiyonu `fun isElementOfGeneratedSet(k: Int, x: Int): String` yazın ve aşağıdaki problemi çözün:\nVerilen bir x sayısının, k başlangıç sayısından üretilen bir M kümesinin elemanı olup olmadığını belirler.\nM kümesi şu şekilde üretilir:\n(1) k, M'nin bir elemanıdır.\n(2) Eğer y, M'nin bir elemanı ise, o zaman hem (2y + 1) hem de (3y + 1) M'nin elemanlarıdır.\n(3) Yukarıdaki kurallarla üretilenler dışında M'de başka eleman yoktur.\n\nÖrnek:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "vi": "Viết một hàm Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` để giải quyết vấn đề sau:\nXác định liệu một số x cho trước có phải là một phần tử của tập hợp M được tạo ra từ số bắt đầu k hay không.\nTập hợp M được tạo ra như sau:\n(1) k là một phần tử của M.\n(2) Nếu y là một phần tử của M, thì cả (2y + 1) và (3y + 1) đều là phần tử của M.\n(3) Không có phần tử nào khác trong M ngoại trừ những phần tử được tạo ra bởi các quy tắc trên.\n\nVí dụ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\""
    },
    "instruction_bertscore": {
      "es": "0.9880617182086601",
      "arb": "0.9755267507526915",
      "sw": "0.9868671550971163",
      "tr": "0.9893230211282317",
      "vi": "0.98865284222262"
    },
    "level": "middle",
    "test": "fun main() {\n    check(isElementOfGeneratedSet(0, 22) == \"YES\")\n    check(isElementOfGeneratedSet(1, 10) == \"YES\")\n    check(isElementOfGeneratedSet(2, 13) == \"NO\")\n    check(isElementOfGeneratedSet(3, 30) == \"NO\")\n}\n\n\nmain()",
    "entry_point": "isElementOfGeneratedSet",
    "signature": "fun isElementOfGeneratedSet(k: Int, x: Int): String",
    "docstring": {
      "en": "Determines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "es": "Determina si un número dado x es un elemento de un conjunto M generado a partir de un número inicial k.  \nEl conjunto M se genera de la siguiente manera:  \n(1) k es un elemento de M.  \n(2) Si y es un elemento de M, entonces tanto (2y + 1) como (3y + 1) son elementos de M.  \n(3) No hay otros elementos en M excepto los generados por las reglas anteriores.  \n\nEjemplo:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "arb": "يحدد ما إذا كان الرقم المعطى x هو عنصر في المجموعة M المولدة من رقم البداية k.  \nيتم توليد المجموعة M كما يلي:  \n(1) k هو عنصر في M.  \n(2) إذا كان y عنصرًا في M، فإن كل من (2y + 1) و (3y + 1) هما عنصران في M.  \n(3) لا توجد عناصر أخرى في M باستثناء تلك التي تم توليدها بواسطة القواعد المذكورة أعلاه.  \n\nمثال:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "sw": "Inabainisha kama nambari fulani x ni kipengele cha seti M inayozalishwa kutoka kwa nambari ya kuanzia k.  \nSeti M inazalishwa kama ifuatavyo:  \n(1) k ni kipengele cha M.  \n(2) Ikiwa y ni kipengele cha M, basi (2y + 1) na (3y + 1) zote ni vipengele vya M.  \n(3) Hakuna vipengele vingine katika M isipokuwa vile vilivyozalishwa na sheria zilizo hapo juu.  \n\nMfano:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"",
      "tr": "Verilen bir sayı x'in, k başlangıç sayısından üretilen bir M kümesinin elemanı olup olmadığını belirler.\nKüme M şu şekilde üretilir:\n(1) k, M'nin bir elemanıdır.\n(2) Eğer y, M'nin bir elemanıysa, o zaman hem (2y + 1) hem de (3y + 1) M'nin elemanlarıdır.\n(3) Yukarıdaki kurallarla üretilenler dışında M'de başka eleman yoktur.\n\nÖrnek:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "vi": "Xác định liệu một số x cho trước có phải là một phần tử của tập hợp M được tạo ra từ một số bắt đầu k hay không.  \nTập hợp M được tạo ra như sau:  \n(1) k là một phần tử của M.  \n(2) Nếu y là một phần tử của M, thì cả (2y + 1) và (3y + 1) đều là phần tử của M.  \n(3) Không có phần tử nào khác trong M ngoài những phần tử được tạo ra bởi các quy tắc trên.  \n\nVí dụ:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  "
    },
    "docstring_bertscore": {
      "es": "0.9838153979228963",
      "arb": "0.9790518441249176",
      "sw": "0.983085034011831",
      "tr": "0.9905690295084635",
      "vi": "0.9835957127214717"
    }
  },
  {
    "task_id": "Kotlin/40",
    "prompt": {
      "en": "/**\n    * Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\n    * The input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\n    * The function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\n    Example:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "es": "/**\n    * Encuentra el autor que ha publicado más libros y devuelve la inicial del autor junto con los IDs de los libros a los que ha contribuido.\n    * La entrada es una lista de pares, donde cada par consiste en un ID de libro (Int) y una cadena de letras mayúsculas únicas que representan autores.\n    * La función devuelve un par con la inicial del autor más publicado (Char) y una lista de IDs de libros (List<Int>) a los que ha contribuido.\n    Ejemplo:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "arb": "/**\n    * العثور على المؤلف الذي نشر أكبر عدد من الكتب وإرجاع الحرف الأول من اسم المؤلف مع معرفات الكتب التي ساهموا فيها.\n    * المدخل هو قائمة من الأزواج، حيث يتكون كل زوج من معرف كتاب (Int) وسلسلة من الأحرف الكبيرة الفريدة التي تمثل المؤلفين.\n    * ترجع الدالة زوجًا مع الحرف الأول للمؤلف الأكثر نشرًا (Char) وقائمة بمعرفات الكتب (List<Int>) التي ساهموا فيها.\n    مثال:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "sw": "/**\n    * Tafuta mwandishi ambaye amechapisha vitabu vingi zaidi na rudisha herufi ya kwanza ya mwandishi pamoja na vitambulisho vya vitabu walivyoshiriki.\n    * Ingizo ni orodha ya jozi, ambapo kila jozi inajumuisha kitambulisho cha kitabu (Int) na mfuatano wa herufi kubwa za kipekee zinazowakilisha waandishi.\n    * Kazi inarudisha jozi yenye herufi ya kwanza ya mwandishi aliyechapisha zaidi (Char) na orodha ya vitambulisho vya vitabu (List<Int>) walivyoshiriki.\n    Mfano:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "tr": "/**\n    * En çok kitap yayımlamış olan yazarı bulun ve yazarın baş harfi ile katkıda bulundukları kitapların kimliklerini döndürün.\n    * Girdi, her biri bir kitap kimliği (Int) ve yazarları temsil eden benzersiz büyük harflerden oluşan bir dizi içeren çiftlerden oluşan bir listedir.\n    * Fonksiyon, en çok yayımlanan yazarın baş harfi (Char) ve katkıda bulundukları kitap kimliklerinin listesi (List<Int>) ile bir çift döndürür.\n    Örnek:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "vi": "/**\n    * Tìm tác giả đã xuất bản nhiều sách nhất và trả về chữ cái đầu của tác giả cùng với các ID của sách mà họ đã đóng góp.\n    * Đầu vào là một danh sách các cặp, mỗi cặp bao gồm một ID sách (Int) và một chuỗi các chữ cái viết hoa duy nhất đại diện cho các tác giả.\n    * Hàm trả về một cặp với chữ cái đầu của tác giả xuất bản nhiều nhất (Char) và danh sách các ID sách (List<Int>) mà họ đã đóng góp.\n    Ví dụ:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> "
    },
    "prompt_bertscore": {
      "es": "0.9905030842219599",
      "arb": "0.9627194610443239",
      "sw": "0.9698298327942299",
      "tr": "0.9454505357171508",
      "vi": "0.9829888969074101"
    },
    "canonical_solution": "{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` to solve the following problem:\nFind the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "es": "Escribe una función de Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` para resolver el siguiente problema:\nEncuentra al autor que ha publicado la mayor cantidad de libros y devuelve la inicial del autor junto con los IDs de los libros a los que ha contribuido.\nLa entrada es una lista de pares, donde cada par consiste en un ID de libro (Int) y una cadena de letras mayúsculas únicas que representan a los autores.\nLa función devuelve un par con la inicial del autor más publicado (Char) y una lista de IDs de libros (List<Int>) a los que ha contribuido.\nEjemplo:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "arb": "اكتب دالة كوتلن `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` لحل المشكلة التالية:\nابحث عن المؤلف الذي نشر أكبر عدد من الكتب وأعد الحرف الأول من اسم المؤلف مع معرفات الكتب التي ساهم فيها.\nالإدخال هو قائمة من الأزواج، حيث يتكون كل زوج من معرف كتاب (Int) وسلسلة من الأحرف الكبيرة الفريدة التي تمثل المؤلفين.\nتعيد الدالة زوجًا مع الحرف الأول للمؤلف الذي نشر أكبر عدد من الكتب (Char) وقائمة من معرفات الكتب (List<Int>) التي ساهم فيها.\nمثال:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "sw": "Andika kazi ya Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` kutatua tatizo lifuatalo:\nTafuta mwandishi ambaye amechapisha vitabu vingi zaidi na rudisha herufi ya kwanza ya mwandishi huyo pamoja na vitambulisho vya vitabu walivyoshiriki.\nIngizo ni orodha ya jozi, ambapo kila jozi inajumuisha kitambulisho cha kitabu (Int) na kamba ya herufi kubwa za kipekee zinazowakilisha waandishi.\nKazi inarudisha jozi yenye herufi ya kwanza ya mwandishi aliyechapisha zaidi (Char) na orodha ya vitambulisho vya vitabu (List<Int>) walivyoshiriki.\nMfano:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "tr": "Bir Kotlin fonksiyonu `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` yazarak aşağıdaki problemi çözün:\nEn çok kitap yayınlamış olan yazarı bulun ve yazarın baş harfi ile katkıda bulundukları kitapların kimliklerini döndürün.\nGirdi, her biri bir kitap kimliği (Int) ve yazarları temsil eden benzersiz büyük harflerden oluşan bir dize içeren çiftlerden oluşan bir listedir.\nFonksiyon, en çok yayın yapan yazarın baş harfi (Char) ve katkıda bulundukları kitap kimliklerinin (List<Int>) yer aldığı bir çift döndürür.\nÖrnek:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "vi": "Viết một hàm Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` để giải quyết vấn đề sau:\nTìm tác giả đã xuất bản nhiều sách nhất và trả về chữ cái đầu của tác giả cùng với các ID sách mà họ đã đóng góp.\nĐầu vào là một danh sách các cặp, trong đó mỗi cặp bao gồm một ID sách (Int) và một chuỗi các chữ cái viết hoa duy nhất đại diện cho các tác giả.\nHàm trả về một cặp với chữ cái đầu của tác giả xuất bản nhiều nhất (Char) và danh sách các ID sách (List<Int>) mà họ đã đóng góp.\nVí dụ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))"
    },
    "instruction_bertscore": {
      "es": "0.9865705999382313",
      "arb": "0.9554464110123504",
      "sw": "0.9693713938748013",
      "tr": "0.974305968430851",
      "vi": "0.9838338705483325"
    },
    "level": "hard",
    "test": "fun main() {\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"HF\"))) == Pair('F', listOf(307,895)))\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"H\"), Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\"), Pair(834, \"BXPRD\"), Pair(872, \"LJU\"), Pair(791, \"BPJWIA\"), Pair(580, \"AGMVY\"), Pair(619, \"NAFL\"), Pair(233, \"PDJWXK\"))) == Pair('P', listOf(410,567,822,834,791,233)))\n\n \n}\nmain()",
    "entry_point": "findMostPublishedAuthor",
    "signature": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>",
    "docstring": {
      "en": "Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "es": "Encuentra el autor que ha publicado más libros y devuelve la inicial del autor junto con los IDs de los libros a los que ha contribuido.\nLa entrada es una lista de pares, donde cada par consiste en un ID de libro (Int) y una cadena de letras mayúsculas únicas que representan a los autores.\nLa función devuelve un par con la inicial del autor más publicado (Char) y una lista de IDs de libros (List<Int>) a los que ha contribuido.\nEjemplo:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "arb": "ابحث عن المؤلف الذي نشر أكبر عدد من الكتب وأعد الحرف الأول من اسم المؤلف مع معرفات الكتب التي ساهم فيها.\nالمدخل هو قائمة من الأزواج، حيث يتكون كل زوج من معرف كتاب (Int) وسلسلة من الأحرف الكبيرة الفريدة التي تمثل المؤلفين.\nتعيد الدالة زوجًا مع الحرف الأول للمؤلف الأكثر نشرًا (Char) وقائمة بمعرفات الكتب (List<Int>) التي ساهم فيها.\nمثال:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "sw": "Tafuta mwandishi ambaye amechapisha vitabu vingi zaidi na rudisha herufi ya kwanza ya mwandishi pamoja na vitambulisho vya vitabu walivyoshiriki.\nIngizo ni orodha ya jozi, ambapo kila jozi inajumuisha kitambulisho cha kitabu (Int) na mfuatano wa herufi kubwa za kipekee zinazowakilisha waandishi.\nKazi inarudisha jozi yenye herufi ya kwanza ya mwandishi aliyechapisha zaidi (Char) na orodha ya vitambulisho vya vitabu (List<Int>) walivyoshiriki.\nMfano:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "tr": "Kitapları en çok yayımlayan yazarı bulun ve yazarın baş harfi ile katkıda bulundukları kitapların kimliklerini döndürün.\nGirdi, her biri bir kitap kimliği (Int) ve yazarları temsil eden benzersiz büyük harflerden oluşan bir dizi içeren çiftlerden oluşan bir listedir.\nFonksiyon, en çok yayımlanan yazarın baş harfi (Char) ve katkıda bulundukları kitap kimliklerinin (List<Int>) bir listesini içeren bir çift döndürür.\nÖrnek:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "vi": "Tìm tác giả đã xuất bản nhiều sách nhất và trả về chữ cái đầu của tác giả đó cùng với các ID của sách mà họ đã đóng góp.\nĐầu vào là một danh sách các cặp, trong đó mỗi cặp bao gồm một ID sách (Int) và một chuỗi các chữ cái viết hoa duy nhất đại diện cho các tác giả.\nHàm trả về một cặp với chữ cái đầu của tác giả xuất bản nhiều nhất (Char) và một danh sách các ID sách (List<Int>) mà họ đã đóng góp.\nVí dụ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))"
    },
    "docstring_bertscore": {
      "es": "0.9852534818815889",
      "arb": "0.9551047667569704",
      "sw": "0.9829839311478842",
      "tr": "0.9754751068536224",
      "vi": "0.980192578403201"
    }
  },
  {
    "task_id": "Kotlin/41",
    "prompt": {
      "en": "/**\n * Counts the number of pairs of students who are considered \"equal competitors\".\n * Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n * is not greater than 5, and the difference in their total scores is not greater than 10.\n * \n * @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n * @return The number of pairs of students who are considered equal competitors.\n * \n * Example:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "es": "/**\n * Cuenta el número de pares de estudiantes que se consideran \"competidores iguales\".\n * Se considera que dos estudiantes son competidores iguales si la diferencia en sus puntuaciones para cada materia (Matemáticas, Inglés y Chino)\n * no es mayor que 5, y la diferencia en sus puntuaciones totales no es mayor que 10.\n * \n * @param scores Una lista de tríos, cada uno representando las puntuaciones de Matemáticas, Inglés y Chino de un estudiante.\n * @return El número de pares de estudiantes que se consideran competidores iguales.\n * \n * Ejemplo:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "arb": "/**\n * يحسب عدد أزواج الطلاب الذين يعتبرون \"متنافسين متساوين\".\n * يعتبر طالبان متنافسين متساوين إذا كان الفرق في درجاتهم لكل مادة (الرياضيات، الإنجليزية، والصينية)\n * لا يزيد عن 5، والفرق في مجموع درجاتهم لا يزيد عن 10.\n * \n * @param scores قائمة من الثلاثيات، كل منها تمثل درجات الرياضيات، الإنجليزية، والصينية لطالب.\n * @return عدد أزواج الطلاب الذين يعتبرون متنافسين متساوين.\n * \n * مثال:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */ \n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "sw": "/**\n * Inahesabu idadi ya jozi za wanafunzi wanaochukuliwa kama \"washindani sawa\".\n * Wanafunzi wawili wanachukuliwa kuwa washindani sawa ikiwa tofauti katika alama zao kwa kila somo (Hisabati, Kiingereza, na Kichina)\n * haizidi 5, na tofauti katika jumla ya alama zao haizidi 10.\n * \n * @param scores Orodha ya matatu, kila moja ikiwakilisha alama za Hisabati, Kiingereza, na Kichina za mwanafunzi.\n * @return Idadi ya jozi za wanafunzi wanaochukuliwa kuwa washindani sawa.\n * \n * Mfano:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "tr": "/**\n * \"Eşit rakip\" olarak kabul edilen öğrenci çiftlerinin sayısını sayar.\n * İki öğrenci, her bir ders (Matematik, İngilizce ve Çince) için puanlarındaki fark 5'ten büyük değilse\n * ve toplam puanlarındaki fark 10'dan büyük değilse eşit rakip olarak kabul edilir.\n * \n * @param scores Her biri bir öğrencinin Matematik, İngilizce ve Çince puanlarını temsil eden üçlülerin bir listesi.\n * @return Eşit rakip olarak kabul edilen öğrenci çiftlerinin sayısı.\n * \n * Örnek:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "vi": "/**\n * Đếm số cặp học sinh được coi là \"đối thủ ngang tài\".\n * Hai học sinh được coi là đối thủ ngang tài nếu sự chênh lệch điểm số của họ cho mỗi môn học (Toán, Anh, và Trung)\n * không lớn hơn 5, và sự chênh lệch trong tổng điểm của họ không lớn hơn 10.\n * \n * @param scores Một danh sách các bộ ba, mỗi bộ đại diện cho điểm Toán, Anh, và Trung của một học sinh.\n * @return Số cặp học sinh được coi là đối thủ ngang tài.\n * \n * Ví dụ:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int "
    },
    "prompt_bertscore": {
      "es": "0.986603771211864",
      "arb": "0.9800644618074335",
      "sw": "0.9719347189420565",
      "tr": "0.9381109445075305",
      "vi": "0.9836924457170357"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` to solve the following problem:\nCounts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "es": "Escribe una función de Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` para resolver el siguiente problema:\nCuenta el número de pares de estudiantes que se consideran \"competidores iguales\".\n  Dos estudiantes se consideran competidores iguales si la diferencia en sus puntuaciones para cada materia (Matemáticas, Inglés y Chino)\n  no es mayor que 5, y la diferencia en sus puntuaciones totales no es mayor que 10.\n  \n  @param scores Una lista de tríos, cada uno representando las puntuaciones de Matemáticas, Inglés y Chino de un estudiante.\n  @return El número de pares de estudiantes que se consideran competidores iguales.\n  \n  Ejemplo:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "arb": "اكتب دالة Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` لحل المشكلة التالية:\nتحسب عدد الأزواج من الطلاب الذين يعتبرون \"متنافسين متساوين\".\nيعتبر طالبان متنافسين متساوين إذا كان الفرق في درجاتهم لكل مادة (الرياضيات، الإنجليزية، والصينية)\nلا يزيد عن 5، والفرق في مجموع درجاتهم لا يزيد عن 10.\n\n@param scores قائمة من الثلاثيات، كل منها يمثل درجات الرياضيات، الإنجليزية، والصينية لطالب.\n@return عدد الأزواج من الطلاب الذين يعتبرون متنافسين متساوين.\n\nمثال:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "sw": "Andika kazi ya Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` kutatua tatizo lifuatalo:\nHesabu idadi ya wanandoa wa wanafunzi wanaochukuliwa kuwa \"washindani sawa\".\n  Wanafunzi wawili wanachukuliwa kuwa washindani sawa ikiwa tofauti ya alama zao kwa kila somo (Hisabati, Kiingereza, na Kichina)\n  haizidi 5, na tofauti ya alama zao jumla haizidi 10.\n  \n  @param scores Orodha ya tatu, kila moja ikiwakilisha alama za Hisabati, Kiingereza, na Kichina za mwanafunzi.\n  @return Idadi ya wanandoa wa wanafunzi wanaochukuliwa kuwa washindani sawa.\n  \n  Mfano:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "tr": "Bir Kotlin fonksiyonu `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` yazın ve aşağıdaki problemi çözün:\nÖğrencilerin \"eşit rakipler\" olarak kabul edildiği çiftlerin sayısını sayar.\n  İki öğrenci, her bir ders (Matematik, İngilizce ve Çince) için puanlarındaki fark 5'ten büyük değilse ve toplam puanlarındaki fark 10'dan büyük değilse eşit rakip olarak kabul edilir.\n  \n  @param scores Her biri bir öğrencinin Matematik, İngilizce ve Çince puanlarını temsil eden üçlülerin bir listesi.\n  @return Eşit rakipler olarak kabul edilen öğrenci çiftlerinin sayısı.\n  \n  Örnek:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "vi": "Viết một hàm Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` để giải quyết vấn đề sau:\nĐếm số cặp học sinh được coi là \"đối thủ cạnh tranh ngang bằng\".\n  Hai học sinh được coi là đối thủ cạnh tranh ngang bằng nếu sự khác biệt trong điểm số của họ cho mỗi môn học (Toán, Tiếng Anh và Tiếng Trung)\n  không lớn hơn 5, và sự khác biệt trong tổng điểm của họ không lớn hơn 10.\n  \n  @param scores Một danh sách các bộ ba, mỗi bộ đại diện cho điểm Toán, Tiếng Anh và Tiếng Trung của một học sinh.\n  @return Số cặp học sinh được coi là đối thủ cạnh tranh ngang bằng.\n  \n  Ví dụ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2"
    },
    "instruction_bertscore": {
      "es": "0.984098644846252",
      "arb": "0.9865052505428707",
      "sw": "0.9729590558170534",
      "tr": "0.9815134704370829",
      "vi": "0.9882474376149277"
    },
    "level": "hard",
    "test": "fun main() {\n    check(countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91))) == 2)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(92, 93, 95), Triple(101, 102, 103))) == 1)\n    check(countEqualCompetitors(listOf(Triple(90, 91, 92), Triple(86, 87, 88), Triple(93, 94, 95))) == 1)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(105, 105, 105), Triple(100, 100, 100))) == 1)\n}\n\n\nmain()",
    "entry_point": "countEqualCompetitors",
    "signature": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "es": "Cuenta el número de pares de estudiantes que se consideran \"competidores iguales\".\n  Dos estudiantes se consideran competidores iguales si la diferencia en sus puntuaciones para cada materia (Matemáticas, Inglés y Chino)\n  no es mayor que 5, y la diferencia en sus puntuaciones totales no es mayor que 10.\n  \n  @param scores Una lista de tríos, cada uno representando las puntuaciones de Matemáticas, Inglés y Chino de un estudiante.\n  @return El número de pares de estudiantes que se consideran competidores iguales.\n  \n  Ejemplo:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "arb": "يحسب عدد أزواج الطلاب الذين يعتبرون \"منافسين متساوين\".\nيعتبر طالبان منافسين متساوين إذا كان الفرق في درجاتهم لكل مادة (الرياضيات، الإنجليزية، والصينية)\nلا يزيد عن 5، والفرق في مجموع درجاتهم لا يزيد عن 10.\n\n@param scores قائمة من الثلاثيات، كل منها تمثل درجات الرياضيات والإنجليزية والصينية لطالب.\n@return عدد أزواج الطلاب الذين يعتبرون منافسين متساوين.\n\nمثال:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "sw": "Hesabu idadi ya jozi za wanafunzi wanaoonekana kuwa \"washindani sawa\".\n  Wanafunzi wawili wanachukuliwa kuwa washindani sawa ikiwa tofauti ya alama zao kwa kila somo (Hisabati, Kiingereza, na Kichina)\n  haizidi 5, na tofauti ya alama zao jumla haizidi 10.\n  \n  @param scores Orodha ya tatu, kila moja ikiwakilisha alama za Hisabati, Kiingereza, na Kichina za mwanafunzi.\n  @return Idadi ya jozi za wanafunzi wanaoonekana kuwa washindani sawa.\n  \n  Mfano:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "tr": "Öğrencilerin \"eşit rakip\" olarak kabul edildiği çiftlerin sayısını sayar.\nİki öğrenci, her bir ders (Matematik, İngilizce ve Çince) için puanlarındaki fark 5'ten büyük değilse ve toplam puanlarındaki fark 10'dan büyük değilse eşit rakip olarak kabul edilir.\n\n@param scores Her biri bir öğrencinin Matematik, İngilizce ve Çince puanlarını temsil eden üçlülerin bir listesi.\n@return Eşit rakip olarak kabul edilen öğrenci çiftlerinin sayısı.\n\nÖrnek:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "vi": "Đếm số cặp học sinh được coi là \"đối thủ ngang tài ngang sức\".  \nHai học sinh được coi là đối thủ ngang tài ngang sức nếu chênh lệch điểm số của họ cho mỗi môn học (Toán, Tiếng Anh và Tiếng Trung) không lớn hơn 5, và chênh lệch tổng điểm của họ không lớn hơn 10.\n\n@param scores Một danh sách các bộ ba, mỗi bộ đại diện cho điểm Toán, Tiếng Anh và Tiếng Trung của một học sinh.\n@return Số cặp học sinh được coi là đối thủ ngang tài ngang sức.\n\nVí dụ:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9907968585555105",
      "arb": "0.9830790751003999",
      "sw": "0.9757998675266144",
      "tr": "0.9817603680007093",
      "vi": "0.9755962713860536"
    }
  },
  {
    "task_id": "Kotlin/42",
    "prompt": {
      "en": "/**\n * Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n * Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n * \n * Example:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "es": "/**\n * Calcular el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una proporción de colillas de cigarrillos por cigarrillos nuevos.\n * Peter guarda las colillas de los cigarrillos fumados y las intercambia por nuevos a una tasa dada.\n * \n * Ejemplo:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "arb": "/**\n * احسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى عدد السجائر الأولي ونسبة أعقاب السجائر إلى السجائر الجديدة.\n * بيتر يحتفظ بأعقاب السجائر المدخنة ويستبدلها بأخرى جديدة بمعدل معين.\n * \n * مثال:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "sw": "/**\n * Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kutokana na idadi ya awali ya sigara na uwiano wa vipande vya sigara kwa sigara mpya.\n * Peter huokoa vipande vya sigara zilizovutwa na kubadilisha kwa sigara mpya kwa kiwango kilichopewa.\n * \n * Mfano:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int",
      "tr": "/**\n * Peter'ın, başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara oranı verildiğinde, toplam kaç sigara içebileceğini hesaplayın.\n * Peter, içilen sigaralardan izmaritleri biriktirir ve bunları belirli bir oranda yenileriyle değiştirir.\n * \n * Örnek:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "vi": "/**\n * Tính tổng số điếu thuốc mà Peter có thể hút được với một số lượng thuốc ban đầu và tỷ lệ đầu mẩu thuốc đổi lấy thuốc mới.\n * Peter tiết kiệm đầu mẩu từ các điếu thuốc đã hút và đổi chúng lấy thuốc mới theo một tỷ lệ nhất định.\n * \n * Ví dụ:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9880468209300824",
      "arb": "0.9796548859617396",
      "sw": "0.9679629058428829",
      "tr": "0.9777897466838219",
      "vi": "0.9679605222783104"
    },
    "canonical_solution": "{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` to solve the following problem:\nCalculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "es": "Escribe una función en Kotlin `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` para resolver el siguiente problema:\nCalcula el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una proporción de colillas de cigarrillo para nuevos cigarrillos.\n  Peter guarda colillas de cigarrillos fumados y las intercambia por nuevos a una tasa dada.\n  \n  Ejemplo:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "arb": "اكتب دالة كوتلن `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` لحل المشكلة التالية:\nاحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بناءً على عدد السجائر الأولي ونسبة أعقاب السجائر للسجائر الجديدة.\n  يقوم بيتر بتجميع أعقاب السجائر المدخنة ويستبدلها بأخرى جديدة بمعدل معين.\n  \n  مثال:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "sw": "Andika kazi ya Kotlin `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` kutatua tatizo lifuatalo:\nHesabu jumla ya sigara ambazo Peter anaweza kuvuta kwa kuzingatia idadi ya awali ya sigara na uwiano wa vipande vya sigara kwa sigara mpya.\n  Peter huokoa vipande vya sigara zilizovutwa na kubadilisha kwa mpya kwa kiwango kilichopewa.\n  \n  Mfano:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "tr": "Bir Kotlin fonksiyonu `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` yazın ve aşağıdaki problemi çözün:\nPeter'ın, başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara oranı verildiğinde, toplamda kaç sigara içebileceğini hesaplayın.\n  Peter, içilen sigaralardan izmaritleri biriktirir ve belirli bir oranda yeni sigaralarla değiştirir.\n  \n  Örnek:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "vi": "Viết một hàm Kotlin `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` để giải quyết vấn đề sau:\nTính tổng số điếu thuốc mà Peter có thể hút được với số lượng điếu thuốc ban đầu và tỷ lệ đầu lọc thuốc lá để đổi lấy điếu thuốc mới.\n  Peter tiết kiệm đầu lọc từ những điếu thuốc đã hút và đổi chúng lấy điếu thuốc mới theo một tỷ lệ nhất định.\n  \n  Ví dụ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14"
    },
    "instruction_bertscore": {
      "es": "0.9837488567452496",
      "arb": "0.9717146364798699",
      "sw": "0.9728476241732928",
      "tr": "0.9636502430098534",
      "vi": "0.9611008220692706"
    },
    "level": "easy",
    "test": "fun main() {\n    check(totalCigarettesSmoked(4, 3) == 5)\n    check(totalCigarettesSmoked(10, 3) == 14)\n    check(totalCigarettesSmoked(1, 2) == 1) // Edge case: Not enough cigarettes to exchange\n    check(totalCigarettesSmoked(20, 5) == 24) // More cigarettes, different exchange rate\n}\n\nmain()",
    "entry_point": "totalCigarettesSmoked",
    "signature": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int",
    "docstring": {
      "en": "Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "es": "Calcular el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una proporción de colillas de cigarrillos a cigarrillos nuevos. \n  Peter guarda las colillas de los cigarrillos fumados y las intercambia por nuevos a una tasa dada.\n  \n  Ejemplo:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "arb": "احسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر بالنظر إلى عدد أولي من السجائر ونسبة أعقاب السجائر إلى السجائر الجديدة.  \n  يقوم بيتر بحفظ أعقاب السجائر المدخنة ويستبدلها بأخرى جديدة بمعدل معين.\n  \n  مثال:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta ukizingatia idadi ya awali ya sigara na uwiano wa vipande vya sigara hadi sigara mpya. Peter huokoa vipande vya sigara zilizovutwa na kubadilisha kwa mpya kwa kiwango kilichopewa.\n\nMfano:\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "tr": "Peter'in başlangıçtaki sigara sayısı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde, Peter'in toplam kaç sigara içebileceğini hesaplayın. \n  Peter, içilen sigaralardan kalan izmaritleri biriktirir ve bunları belirli bir oranda yeni sigaralarla değiştirir.\n  \n  Örnek:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút được với số điếu thuốc ban đầu và tỷ lệ đầu mẩu thuốc lá đổi lấy điếu thuốc mới. \nPeter giữ lại đầu mẩu từ những điếu thuốc đã hút và đổi chúng lấy điếu thuốc mới theo một tỷ lệ nhất định.\n\nVí dụ:\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14"
    },
    "docstring_bertscore": {
      "es": "0.9840402475142278",
      "arb": "0.964934785684006",
      "sw": "0.9678014193431015",
      "tr": "0.8988665469745626",
      "vi": "0.9229681587789549"
    }
  },
  {
    "task_id": "Kotlin/43",
    "prompt": {
      "en": "/**\n * Finds the length of the longest consecutive sequence in a given list of integers.\n * Consecutive sequence means numbers that come sequentially without any gap.\n * \n * Example:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "es": "/**\n * Encuentra la longitud de la secuencia consecutiva más larga en una lista dada de enteros.\n * Secuencia consecutiva significa números que vienen secuencialmente sin ninguna interrupción.\n * \n * Ejemplo:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "arb": "/**\n * يجد طول أطول تسلسل متتابع في قائمة معينة من الأعداد الصحيحة.\n * تسلسل متتابع يعني الأرقام التي تأتي بشكل متسلسل دون أي فجوة.\n * \n * مثال:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "sw": "/**\n * Inapata urefu wa mlolongo mrefu zaidi wa nambari mfululizo katika orodha iliyotolewa ya nambari za mzima.\n * Mlolongo mfululizo unamaanisha nambari zinazokuja mfululizo bila pengo lolote.\n * \n * Mfano:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "tr": "/**\n * Verilen bir tamsayı listesindeki en uzun ardışık dizinin uzunluğunu bulur.\n * Ardışık dizi, arada boşluk olmadan sıralı gelen sayılar anlamına gelir.\n * \n * Örnek:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "vi": "/**\n * Tìm độ dài của dãy số liên tiếp dài nhất trong một danh sách các số nguyên đã cho.\n * Dãy số liên tiếp nghĩa là các số đến liên tiếp mà không có khoảng cách.\n * \n * Ví dụ:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int "
    },
    "prompt_bertscore": {
      "es": "0.9905698240299876",
      "arb": "0.9862567639361961",
      "sw": "0.9868524564489197",
      "tr": "0.9817800324084318",
      "vi": "0.9786077065929236"
    },
    "canonical_solution": "{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun longestConsecutiveSequence(numbers: List<Int>): Int` to solve the following problem:\nFinds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "es": "Escribe una función en Kotlin `fun longestConsecutiveSequence(numbers: List<Int>): Int` para resolver el siguiente problema:\nEncuentra la longitud de la secuencia consecutiva más larga en una lista dada de enteros.\n  Secuencia consecutiva significa números que vienen secuencialmente sin ningún hueco.\n  \n  Ejemplo:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "arb": "اكتب دالة كوتلن `fun longestConsecutiveSequence(numbers: List<Int>): Int` لحل المشكلة التالية:\nإيجاد طول أطول تسلسل متتابع في قائمة معينة من الأعداد الصحيحة.\n  التسلسل المتتابع يعني الأرقام التي تأتي بشكل متسلسل دون أي فجوة.\n  \n  مثال:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "sw": "Andika kazi ya Kotlin `fun longestConsecutiveSequence(numbers: List<Int>): Int` kutatua tatizo lifuatalo:\nInapata urefu wa mlolongo mrefu zaidi wa namba mfululizo katika orodha iliyotolewa ya namba nzima.\n  Mlolongo mfululizo unamaanisha namba zinazokuja kwa mpangilio bila pengo lolote.\n  \n  Mfano:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "tr": "Bir Kotlin fonksiyonu `fun longestConsecutiveSequence(numbers: List<Int>): Int` yazın ve aşağıdaki problemi çözün:\nVerilen bir tamsayı listesindeki en uzun ardışık dizinin uzunluğunu bulun.\n  Ardışık dizi, arada boşluk olmadan sıralı gelen sayılar anlamına gelir.\n  \n  Örnek:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "vi": "Viết một hàm Kotlin `fun longestConsecutiveSequence(numbers: List<Int>): Int` để giải quyết vấn đề sau:\nTìm độ dài của dãy số liên tiếp dài nhất trong một danh sách số nguyên đã cho.\n  Dãy số liên tiếp có nghĩa là các số xuất hiện liên tục mà không có khoảng cách nào.\n  \n  Ví dụ:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4"
    },
    "instruction_bertscore": {
      "es": "0.9930463476207306",
      "arb": "0.9781417197190158",
      "sw": "0.9754925863271534",
      "tr": "0.964729600500397",
      "vi": "0.9632502014224491"
    },
    "level": "middle",
    "test": "fun main() {\n    check(longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9)) == 6)\n    check(longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2)) == 4)\n    check(longestConsecutiveSequence(listOf(1, 2, 3, 4, 5, 6)) == 6)\n    check(longestConsecutiveSequence(listOf(100, 4, 200, 1, 3, 2)) == 4)\n}\n\n\nmain()",
    "entry_point": "longestConsecutiveSequence",
    "signature": "fun longestConsecutiveSequence(numbers: List<Int>): Int",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga en una lista dada de enteros.\n  Secuencia consecutiva significa números que vienen secuencialmente sin ningún hueco.\n  \n  Ejemplo:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "arb": "يجد طول أطول تسلسل متتابع في قائمة معينة من الأعداد الصحيحة.  \nالتسلسل المتتابع يعني الأرقام التي تأتي بشكل متسلسل دون أي فجوة.\n\nمثال:\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa mfululizo katika orodha iliyotolewa ya nambari za mzima.\n  Mlolongo wa mfululizo unamaanisha nambari zinazokuja mfululizo bila pengo lolote.\n  \n  Mfano:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "tr": "Verilen bir tamsayı listesindeki en uzun ardışık dizinin uzunluğunu bulur.\n  Ardışık dizi, arada boşluk olmadan sıralı gelen sayılar anlamına gelir.\n  \n  Örnek:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong một danh sách các số nguyên đã cho.  \nDãy số liên tiếp có nghĩa là các số xuất hiện liên tục mà không có khoảng cách nào.  \n  \nVí dụ:  \n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))  \n      6  \n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))  \n      4"
    },
    "docstring_bertscore": {
      "es": "0.9925922785696849",
      "arb": "0.9899264602258157",
      "sw": "0.9767240946895698",
      "tr": "0.9695207639213396",
      "vi": "0.9514163992115336"
    }
  },
  {
    "task_id": "Kotlin/44",
    "prompt": {
      "en": "/**\n * Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n * Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n * \n * Example:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "es": "/**\n * Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'.\n * Devuelve \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n * \n * Ejemplo:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "arb": "/**\n * يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.\n * يعيد \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n * \n * مثال:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "sw": "/**\n * Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n * Inarudisha \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n * \n * Mfano:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "tr": "/**\n * 'a' kenar uzunluğuna sahip bir karenin alanını, 'b' ve 'c' kenarlarına sahip bir dikdörtgenin alanı ile karşılaştırır.\n * Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" döner.\n * \n * Örnek:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "vi": "/**\n * So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'.\n * Trả về \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n * \n * Ví dụ:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String "
    },
    "prompt_bertscore": {
      "es": "0.9957632139725259",
      "arb": "0.9965315162863688",
      "sw": "1",
      "tr": "0.9966405643655569",
      "vi": "0.9922329562103928"
    },
    "canonical_solution": "{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun compareAreas(a: Int, b: Int, c: Int): String` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "es": "Escribe una función de Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` para resolver el siguiente problema:\nCompara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'.\nDevuelve \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n\nEjemplo:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "arb": "اكتب دالة Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` لحل المشكلة التالية:\nيقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.\n  يُرجع \"Alice\" إذا كانت مساحة المربع أكبر، و\"Bob\" إذا كانت مساحة المستطيل أكبر.\n  \n  مثال:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "sw": "Andika kazi ya Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` kutatua tatizo lifuatalo:\nInalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'.\n  Inarudisha \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n  \n  Mfano:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "tr": "Bir Kotlin fonksiyonu `fun compareAreas(a: Int, b: Int, c: Int): String` yazın ve aşağıdaki problemi çözün:\nKenar uzunluğu 'a' olan bir karenin alanını, kenarları 'b' ve 'c' olan bir dikdörtgenin alanı ile karşılaştırır.\nKarenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" döner.\n\nÖrnek:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "vi": "Viết một hàm Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` để giải quyết vấn đề sau:\nSo sánh diện tích của một hình vuông có độ dài cạnh 'a' với diện tích của một hình chữ nhật có các cạnh 'b' và 'c'.\nTrả về \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\""
    },
    "instruction_bertscore": {
      "es": "0.9904685225356599",
      "arb": "0.9937697594684597",
      "sw": "0.9851146392452454",
      "tr": "0.9958754401378106",
      "vi": "0.9937697594684597"
    },
    "level": "easy",
    "test": "fun main() {\n    check(compareAreas(5, 4, 6) == \"Alice\")\n    check(compareAreas(7, 5, 10) == \"Bob\")\n    // Additional test cases for edge cases\n    check(compareAreas(1, 1, 1) == \"Bob\") // Edge case where all sides are equal\n    check(compareAreas(10, 5, 20) == \"Bob\") // Test case where rectangle is clearly larger\n}\n\n\nmain()",
    "entry_point": "compareAreas",
    "signature": "fun compareAreas(a: Int, b: Int, c: Int): String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "es": "Compara el área de un cuadrado con longitud de lado 'a' con el área de un rectángulo con lados 'b' y 'c'. Devuelve \"Alice\" si el área del cuadrado es mayor, y \"Bob\" si el área del rectángulo es mayor.\n\n  Ejemplo:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "arb": "يقارن مساحة مربع بطول ضلع 'a' مع مساحة مستطيل بأضلاع 'b' و 'c'.  \nيعيد \"Alice\" إذا كانت مساحة المربع أكبر، و \"Bob\" إذا كانت مساحة المستطيل أكبر.\n\nمثال:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "sw": "Inalinganisha eneo la mraba lenye urefu wa upande 'a' na eneo la mstatili wenye pande 'b' na 'c'. Inarejesha \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, na \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi.\n\nMfano:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "tr": "Bir kenar uzunluğu 'a' olan bir karenin alanını, kenarları 'b' ve 'c' olan bir dikdörtgenin alanı ile karşılaştırır. Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" döner.\n\nÖrnek:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "vi": "So sánh diện tích của một hình vuông với độ dài cạnh 'a' với diện tích của một hình chữ nhật với các cạnh 'b' và 'c'. Trả về \"Alice\" nếu diện tích của hình vuông lớn hơn, và \"Bob\" nếu diện tích của hình chữ nhật lớn hơn.\n\nVí dụ:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9799381328850952",
      "arb": "0.9984945803421366",
      "sw": "1",
      "tr": "0.9427916694366177",
      "vi": "0.9848826389601967"
    }
  },
  {
    "task_id": "Kotlin/45",
    "prompt": {
      "en": "\n/**\n    * Finds M positive integers whose sum is N and their product is as large as possible.\n    * Outputs the lexicographically smallest sequence of these M integers.\n    * \n    * Example:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "es": "/**\n    * Encuentra M enteros positivos cuya suma es N y cuyo producto es lo más grande posible.\n    * Devuelve la secuencia lexicográficamente más pequeña de estos M enteros.\n    * \n    * Ejemplo:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "arb": "/**\n    * يجد M من الأعداد الصحيحة الموجبة التي يكون مجموعها N ويكون حاصل ضربها أكبر ما يمكن.\n    * يخرج التسلسل الأصغر لغوياً لهذه الأعداد M.\n    * \n    * مثال:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "sw": "/**\n    * Inapata nambari M zisizo hasi ambazo jumla yake ni N na bidhaa yao ni kubwa iwezekanavyo.\n    * Inatoa mlolongo mdogo zaidi wa leksikografia wa hizi nambari M.\n    * \n    * Mfano:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "tr": "/**\n    * Toplamı N olan ve çarpımları mümkün olduğunca büyük olan M pozitif tam sayı bulur.\n    * Bu M tam sayının sözlük sırasına göre en küçük dizisini çıktılar.\n    * \n    * Örnek:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "vi": "/**\n    * Tìm M số nguyên dương có tổng là N và tích của chúng là lớn nhất có thể.\n    * Xuất ra dãy số nhỏ nhất theo thứ tự từ điển của M số nguyên này.\n    * \n    * Ví dụ:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> "
    },
    "prompt_bertscore": {
      "es": "0.9792431251818542",
      "arb": "0.9668688497041428",
      "sw": "0.964809449913573",
      "tr": "0.9792568306781456",
      "vi": "0.9735859332995995"
    },
    "canonical_solution": "{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun maxProductPartition(N: Int, M: Int): List<Int>` to solve the following problem:\nFinds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "es": "Escribe una función en Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` para resolver el siguiente problema:\nEncuentra M números enteros positivos cuya suma sea N y cuyo producto sea lo más grande posible.\n     Devuelve la secuencia lexicográficamente más pequeña de estos M enteros.\n     \n     Ejemplo:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "arb": "اكتب دالة Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` لحل المشكلة التالية:\nتجد M أعداد صحيحة موجبة يكون مجموعها N ويكون حاصل ضربها بأكبر قدر ممكن.\n     تُخرج التسلسل الأصغر لغويًا لهذه الأعداد M.\n\n     مثال:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "sw": "Andika kazi ya Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` kutatua tatizo lifuatalo:\nInapata nambari M za kimaandishi chanya ambazo jumla yake ni N na bidhaa yao ni kubwa iwezekanavyo.\n     Inatoa mlolongo mdogo zaidi wa leksikografia wa nambari hizi M.\n\n     Mfano:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "tr": "Bir Kotlin fonksiyonu `fun maxProductPartition(N: Int, M: Int): List<Int>` yazın ve aşağıdaki problemi çözün:\nToplamı N olan ve çarpımları mümkün olduğunca büyük olan M pozitif tam sayı bulun.\n     Bu M tam sayısının sözlük sırasına göre en küçük dizisini çıktılar.\n     \n     Örnek:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "vi": "Viết một hàm Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` để giải quyết vấn đề sau:\nTìm M số nguyên dương có tổng là N và tích của chúng là lớn nhất có thể.\n     Xuất ra dãy số nhỏ nhất theo thứ tự từ điển của M số nguyên này.\n     \n     Ví dụ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]"
    },
    "instruction_bertscore": {
      "es": "0.9796773311947965",
      "arb": "0.981063969884801",
      "sw": "0.9910028382606437",
      "tr": "0.9723436988966073",
      "vi": "0.9677954604316705"
    },
    "level": "easy",
    "test": "fun main() {\n    check(maxProductPartition(6, 3) == listOf(2, 2, 2))\n    check(maxProductPartition(8, 3) == listOf(2, 3, 3))\n    check(maxProductPartition(10, 2) == listOf(5, 5))\n    check(maxProductPartition(7, 3) == listOf(2, 2, 3))\n}\n\nmain()",
    "entry_point": "maxProductPartition",
    "signature": "fun maxProductPartition(N: Int, M: Int): List<Int>",
    "docstring": {
      "en": "Finds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "es": "Encuentra M enteros positivos cuya suma es N y cuyo producto es lo más grande posible.\n     Devuelve la secuencia lexicográficamente más pequeña de estos M enteros.\n     \n     Ejemplo:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "arb": "يجد M عددًا صحيحًا موجبًا يكون مجموعها N ويكون حاصل ضربها كبيرًا قدر الإمكان.  \n     يُخرج التسلسل الأصغر في الترتيب المعجمي لهذه الأعداد الصحيحة M.\n\n     مثال:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "sw": "Inapata nambari M za asili chanya ambazo jumla yake ni N na bidhaa yao iwe kubwa kadri inavyowezekana. \n     Inatoa mlolongo mdogo zaidi wa leksikografia wa hizi nambari M.\n     \n     Mfano:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "tr": "M pozitif tam sayısının toplamı N olan ve çarpımları mümkün olduğunca büyük olan sayıları bulur.\n     Bu M tam sayısının sözlük sırasına göre en küçük dizisini çıktılar.\n     \n     Örnek:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "vi": "Tìm M số nguyên dương có tổng là N và tích của chúng là lớn nhất có thể. \n     Xuất ra dãy số nhỏ nhất theo thứ tự từ điển của M số nguyên này.\n     \n     Ví dụ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9681224060388539",
      "arb": "0.9571188788206642",
      "sw": "0.9505821516111871",
      "tr": "0.9351398312680107",
      "vi": "0.9636836129138673"
    }
  },
  {
    "task_id": "Kotlin/46",
    "prompt": {
      "en": "/**\n * Calculates the number of characters in the essay title, excluding spaces and newline characters.\n * \n * Example:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.\n */\nfun countTitleCharacters(title: String): Int ",
      "es": "/**\n * Calcula el número de caracteres en el título del ensayo, excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * La función cuenta letras mayúsculas y minúsculas en inglés, dígitos, pero ignora espacios y caracteres de nueva línea.\n */\nfun countTitleCharacters(title: String): Int ",
      "arb": "/**\n * يحسب عدد الأحرف في عنوان المقال، باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * تقوم الدالة بحساب الأحرف الإنجليزية الكبيرة والصغيرة، والأرقام، لكنها تتجاهل المسافات وأحرف السطر الجديد.\n */\nfun countTitleCharacters(title: String): Int ",
      "sw": "/**\n * Inahesabu idadi ya herufi kwenye kichwa cha insha, bila kujumuisha nafasi na herufi mpya.\n * \n * Mfano:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Kazi hii inahesabu herufi kubwa na ndogo za Kiingereza, nambari, lakini inapuuza nafasi na herufi mpya.\n */\nfun countTitleCharacters(title: String): Int ",
      "tr": "/**\n * Makale başlığındaki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç, hesaplar.\n * \n * Örnek:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Fonksiyon büyük ve küçük İngilizce harfleri, rakamları sayar, ancak boşlukları ve yeni satır karakterlerini görmezden gelir.\n */\nfun countTitleCharacters(title: String): Int ",
      "vi": "/**\n * Tính số ký tự trong tiêu đề bài luận, không bao gồm khoảng trắng và ký tự xuống dòng.\n * \n * Ví dụ:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Hàm đếm các chữ cái tiếng Anh viết hoa và viết thường, chữ số, nhưng bỏ qua khoảng trắng và ký tự xuống dòng.\n */\nfun countTitleCharacters(title: String): Int "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.982390423569352",
      "sw": "0.9744605028672961",
      "tr": "0.9868967510238905",
      "vi": "0.998673149054687"
    },
    "canonical_solution": "{\n    return title.count { it != ' ' && it != '\\n' }\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countTitleCharacters(title: String): Int` to solve the following problem:\nCalculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.",
      "es": "Escribe una función de Kotlin `fun countTitleCharacters(title: String): Int` para resolver el siguiente problema:\nCalcula el número de caracteres en el título del ensayo, excluyendo espacios y caracteres de nueva línea.\n  \n  Ejemplo:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  La función cuenta letras mayúsculas y minúsculas en inglés, dígitos, pero ignora espacios y caracteres de nueva línea.",
      "arb": "اكتب دالة كوتلن `fun countTitleCharacters(title: String): Int` لحل المشكلة التالية:\nتحسب عدد الأحرف في عنوان المقال، باستثناء المسافات وأحرف السطر الجديد.\n\n  مثال:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  تقوم الدالة بعد الأحرف الإنجليزية الكبيرة والصغيرة، والأرقام، لكنها تتجاهل المسافات وأحرف السطر الجديد.",
      "sw": "Andika kazi ya Kotlin `fun countTitleCharacters(title: String): Int` kutatua tatizo lifuatalo:\nHesabu idadi ya herufi katika kichwa cha insha, ukiondoa nafasi na herufi za kurudi kwenye mstari mpya.\n\n  Mfano:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Kazi hii inahesabu herufi kubwa na ndogo za Kiingereza, nambari, lakini inapuuzia nafasi na herufi za kurudi kwenye mstari mpya.",
      "tr": "Bir Kotlin fonksiyonu `fun countTitleCharacters(title: String): Int` yazın:\nAşağıdaki problemi çözmek için:\nMakale başlığındaki karakter sayısını, boşluk ve yeni satır karakterleri hariç hesaplar.\n\n  Örnek:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Fonksiyon büyük ve küçük harf İngilizce harfleri, rakamları sayar, ancak boşluk ve yeni satır karakterlerini görmezden gelir.",
      "vi": "Viết một hàm Kotlin `fun countTitleCharacters(title: String): Int` để giải quyết vấn đề sau:  \nTính số ký tự trong tiêu đề bài luận, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Hàm đếm các chữ cái tiếng Anh viết hoa và viết thường, chữ số, nhưng bỏ qua khoảng trắng và ký tự xuống dòng."
    },
    "instruction_bertscore": {
      "es": "0.99814399771961",
      "arb": "0.9778974043503428",
      "sw": "0.9828935543245133",
      "tr": "0.9849732144139486",
      "vi": "0.99814399771961"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countTitleCharacters(\"234\") == 3)\n    check(countTitleCharacters(\"Ca\\n45\") == 4)\n    check(countTitleCharacters(\"Hello, World!\") == 12) // Assuming \",\" is considered a valid character\n    check(countTitleCharacters(\"A B C D E\") == 5)\n    check(countTitleCharacters(\"\\n\\n\\n\\n\") == 0)\n}\n\n\nmain()",
    "entry_point": "countTitleCharacters",
    "signature": "fun countTitleCharacters(title: String): Int",
    "docstring": {
      "en": "Calculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.",
      "es": "Calcula el número de caracteres en el título del ensayo, excluyendo espacios y caracteres de nueva línea.\n  \n  Ejemplo:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  La función cuenta letras mayúsculas y minúsculas en inglés, dígitos, pero ignora espacios y caracteres de nueva línea.",
      "arb": "يحسب عدد الأحرف في عنوان المقالة، باستثناء المسافات وأحرف السطر الجديد.\n\nمثال:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nتقوم الدالة بحساب الأحرف الإنجليزية الكبيرة والصغيرة، والأرقام، لكنها تتجاهل المسافات وأحرف السطر الجديد.",
      "sw": "Hesabu idadi ya herufi katika kichwa cha insha, ukiondoa nafasi na herufi mpya.\n\nMfano:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nKazi hii inahesabu herufi kubwa na ndogo za Kiingereza, tarakimu, lakini inapuuzia nafasi na herufi mpya.",
      "tr": "Karakter sayısını boşluklar ve yeni satır karakterleri hariç tutarak makale başlığında hesaplar.\n\n  Örnek:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Fonksiyon büyük ve küçük harf İngilizce harfleri, rakamları sayar, ancak boşlukları ve yeni satır karakterlerini görmezden gelir.",
      "vi": "Tính số ký tự trong tiêu đề bài luận, không bao gồm khoảng trắng và ký tự xuống dòng.\n\n  Ví dụ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Hàm đếm các chữ cái tiếng Anh viết hoa và viết thường, chữ số, nhưng bỏ qua khoảng trắng và ký tự xuống dòng."
    },
    "docstring_bertscore": {
      "es": "0.9956404603970462",
      "arb": "0.975797483962042",
      "sw": "0.9446335689599542",
      "tr": "0.9633928180360322",
      "vi": "0.9851962763318508"
    }
  },
  {
    "task_id": "Kotlin/47",
    "prompt": {
      "en": "/**\n * Counts the number of students who have enrolled in both courses A and B.\n * The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n * and the second list contains the IDs of students enrolled in course B.\n * \n * Example:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "es": "/**\n * Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n * La función toma dos listas como argumentos: la primera lista contiene los IDs de los estudiantes inscritos en el curso A,\n * y la segunda lista contiene los IDs de los estudiantes inscritos en el curso B.\n * \n * Ejemplo:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "arb": "/**\n * يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.\n * تأخذ الدالة قائمتين كوسيطتين: تحتوي القائمة الأولى على معرفات الطلاب المسجلين في الدورة A،\n * وتحتوي القائمة الثانية على معرفات الطلاب المسجلين في الدورة B.\n * \n * مثال:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "sw": "/**\n * Inahesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote mbili A na B.\n * Kazi hii inachukua orodha mbili kama hoja: orodha ya kwanza ina vitambulisho vya wanafunzi waliojiandikisha katika kozi A,\n * na orodha ya pili ina vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n * \n * Mfano:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "tr": "/**\n * Hem A hem de B derslerine kayıtlı olan öğrencilerin sayısını sayar.\n * Fonksiyon, iki listeyi argüman olarak alır: ilk liste, A dersine kayıtlı öğrencilerin kimliklerini içerir,\n * ve ikinci liste, B dersine kayıtlı öğrencilerin kimliklerini içerir.\n * \n * Örnek:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "vi": "/**\n * Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.\n * Hàm nhận hai danh sách làm đối số: danh sách đầu tiên chứa ID của sinh viên đã đăng ký khóa học A,\n * và danh sách thứ hai chứa ID của sinh viên đã đăng ký khóa học B.\n * \n * Ví dụ:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int "
    },
    "prompt_bertscore": {
      "es": "0.9935449098771282",
      "arb": "0.9903847005148632",
      "sw": "0.9924542304548656",
      "tr": "0.9910801054788663",
      "vi": "0.9750085240885714"
    },
    "canonical_solution": "{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` to solve the following problem:\nCounts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "es": "Escribe una función de Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` para resolver el siguiente problema:\nCuenta el número de estudiantes que se han inscrito en ambos cursos A y B.\n  La función toma dos listas como argumentos: la primera lista contiene los IDs de los estudiantes inscritos en el curso A,\n  y la segunda lista contiene los IDs de los estudiantes inscritos en el curso B.\n  \n  Ejemplo:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "arb": "اكتب دالة كوتلن `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` لحل المشكلة التالية:\nتحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.\nتأخذ الدالة قائمتين كوسيطتين: تحتوي القائمة الأولى على معرفات الطلاب المسجلين في الدورة A،\nوتحتوي القائمة الثانية على معرفات الطلاب المسجلين في الدورة B.\n\nمثال:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "sw": "Andika kazi ya Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` kutatua tatizo lifuatalo:\nHesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote A na B.\n  Kazi hii inachukua orodha mbili kama hoja: orodha ya kwanza ina vitambulisho vya wanafunzi waliojiandikisha katika kozi A,\n  na orodha ya pili ina vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n  \n  Mfano:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "tr": "Kotlin fonksiyonu `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` yazın. Aşağıdaki problemi çözmek için:\nHer iki A ve B kurslarına da kayıtlı olan öğrencilerin sayısını sayar.\n  Fonksiyon iki listeyi argüman olarak alır: ilk liste A kursuna kayıtlı öğrencilerin kimliklerini içerir,\n  ve ikinci liste B kursuna kayıtlı öğrencilerin kimliklerini içerir.\n  \n  Örnek:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "vi": "Viết một hàm Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` để giải quyết vấn đề sau:\nĐếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.\nHàm nhận hai danh sách làm đối số: danh sách đầu tiên chứa ID của sinh viên đã đăng ký khóa học A,\nvà danh sách thứ hai chứa ID của sinh viên đã đăng ký khóa học B.\n\nVí dụ:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1"
    },
    "instruction_bertscore": {
      "es": "0.9951432885533159",
      "arb": "0.9908711463180175",
      "sw": "0.9938015403294252",
      "tr": "0.9754000245695912",
      "vi": "0.980226742828739"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6)) == 4)\n    check(countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14)) == 1)\n    check(countCommonStudents(listOf(1, 2, 3), listOf(4, 5, 6)) == 0)\n    check(countCommonStudents(listOf(1, 2, 3, 4), listOf(2, 4)) == 2)\n}\n\n\nmain()",
    "entry_point": "countCommonStudents",
    "signature": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "es": "Cuenta el número de estudiantes que se han inscrito en ambos cursos A y B.  \nLa función toma dos listas como argumentos: la primera lista contiene los IDs de los estudiantes inscritos en el curso A,  \ny la segunda lista contiene los IDs de los estudiantes inscritos en el curso B.\n\nEjemplo:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "arb": "يحسب عدد الطلاب الذين سجلوا في كلا الدورتين A و B.  \nتأخذ الدالة قائمتين كوسيطين: تحتوي القائمة الأولى على معرفات الطلاب المسجلين في الدورة A،  \nوتحتوي القائمة الثانية على معرفات الطلاب المسجلين في الدورة B.\n\nمثال:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "sw": "Hesabu idadi ya wanafunzi ambao wamejiandikisha katika kozi zote A na B. \nKazi hii inachukua orodha mbili kama hoja: orodha ya kwanza ina vitambulisho vya wanafunzi waliojiandikisha katika kozi A, \nna orodha ya pili ina vitambulisho vya wanafunzi waliojiandikisha katika kozi B.\n\nMfano:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "tr": "Her iki kursa da kayıtlı olan öğrencilerin sayısını sayar.\n  Fonksiyon iki listeyi argüman olarak alır: ilk liste, A kursuna kayıtlı öğrencilerin kimliklerini içerir,\n  ve ikinci liste, B kursuna kayıtlı öğrencilerin kimliklerini içerir.\n  \n  Örnek:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "vi": "Đếm số lượng sinh viên đã đăng ký cả hai khóa học A và B.  \nHàm này nhận hai danh sách làm đối số: danh sách đầu tiên chứa ID của sinh viên đăng ký khóa học A,  \nvà danh sách thứ hai chứa ID của sinh viên đăng ký khóa học B.\n\nVí dụ:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9936680607133699",
      "arb": "0.987042148462808",
      "sw": "0.9813551620233981",
      "tr": "0.9729930216122104",
      "vi": "0.973093131324252"
    }
  },
  {
    "task_id": "Kotlin/48",
    "prompt": {
      "en": "/**\n * Calculates the number of whole apples left after a given time has passed, \n * assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n * \n * @param appleCount The total number of apples initially available.\n * @param timePerApple The time in minutes it takes to eat a single apple.\n * @param timePassed The time in minutes that has elapsed.\n * @return The number of whole apples remaining.\n * \n * Example:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "es": "/**\n * Calcula el número de manzanas enteras que quedan después de que ha pasado un cierto tiempo,\n * asumiendo que cada manzana se come una tras otra y cada una toma una cierta cantidad de tiempo para comer.\n * \n * @param appleCount El número total de manzanas disponibles inicialmente.\n * @param timePerApple El tiempo en minutos que toma comer una sola manzana.\n * @param timePassed El tiempo en minutos que ha transcurrido.\n * @return El número de manzanas enteras restantes.\n * \n * Ejemplo:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "arb": "/**\n * يحسب عدد التفاح الكامل المتبقي بعد مرور وقت معين،\n * بافتراض أن كل تفاحة تؤكل واحدة تلو الأخرى وكل منها يستغرق وقتًا معينًا للأكل.\n * \n * @param appleCount العدد الإجمالي للتفاح المتاح في البداية.\n * @param timePerApple الوقت بالدقائق الذي يستغرقه أكل تفاحة واحدة.\n * @param timePassed الوقت بالدقائق الذي انقضى.\n * @return عدد التفاح الكامل المتبقي.\n * \n * مثال:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "sw": "/**\n * Inahesabu idadi ya tufaha nzima zilizobaki baada ya muda fulani kupita, \n * kwa kudhani kila tufaha inaliwa moja baada ya nyingine na kila moja inachukua muda fulani kuliwa.\n * \n * @param appleCount Jumla ya idadi ya tufaha zilizopo mwanzoni.\n * @param timePerApple Muda kwa dakika unaochukua kula tufaha moja.\n * @param timePassed Muda kwa dakika ambao umepita.\n * @return Idadi ya tufaha nzima zilizobaki.\n * \n * Mfano:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "tr": "/**\n * Belirli bir süre geçtikten sonra kalan bütün elma sayısını hesaplar,\n * her bir elmanın art arda yendiği ve her birinin yenmesinin belirli bir süre aldığı varsayılır.\n * \n * @param appleCount Başlangıçta mevcut olan toplam elma sayısı.\n * @param timePerApple Tek bir elmayı yemek için geçen süre (dakika cinsinden).\n * @param timePassed Geçen süre (dakika cinsinden).\n * @return Kalan bütün elma sayısı.\n * \n * Örnek:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "vi": "/**\n * Tính số lượng táo nguyên còn lại sau khi một khoảng thời gian đã trôi qua,\n * giả sử mỗi quả táo được ăn lần lượt và mỗi quả mất một khoảng thời gian nhất định để ăn.\n * \n * @param appleCount Tổng số lượng táo ban đầu có sẵn.\n * @param timePerApple Thời gian tính bằng phút để ăn một quả táo.\n * @param timePassed Thời gian tính bằng phút đã trôi qua.\n * @return Số lượng táo nguyên còn lại.\n * \n * Ví dụ:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int "
    },
    "prompt_bertscore": {
      "es": "0.9893007745255558",
      "arb": "0.9808498463340454",
      "sw": "0.9604163417762244",
      "tr": "0.9495421229360884",
      "vi": "0.9703085320125239"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` to solve the following problem:\nCalculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "es": "Escribe una función en Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` para resolver el siguiente problema:\nCalcula el número de manzanas enteras que quedan después de que ha pasado un tiempo determinado,\n  asumiendo que cada manzana se come una tras otra y cada una toma una cierta cantidad de tiempo para comer.\n  \n  @param appleCount El número total de manzanas disponibles inicialmente.\n  @param timePerApple El tiempo en minutos que se tarda en comer una sola manzana.\n  @param timePassed El tiempo en minutos que ha transcurrido.\n  @return El número de manzanas enteras restantes.\n  \n  Ejemplo:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "arb": "اكتب دالة Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` لحل المشكلة التالية:\nتحسب عدد التفاح الكامل المتبقي بعد مرور وقت معين، \n  بافتراض أن كل تفاحة تؤكل واحدة تلو الأخرى وكل منها يستغرق وقتًا معينًا للأكل.\n  \n  @param appleCount العدد الإجمالي للتفاح المتاح في البداية.\n  @param timePerApple الوقت بالدقائق الذي يستغرقه أكل تفاحة واحدة.\n  @param timePassed الوقت بالدقائق الذي انقضى.\n  @return عدد التفاح الكامل المتبقي.\n  \n  مثال:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "sw": "Andika kazi ya Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` kutatua tatizo lifuatalo:\nInahesabu idadi ya tufaha nzima zilizobaki baada ya muda fulani kupita, \n  ikizingatiwa kila tufaha inaliwa moja baada ya nyingine na kila moja inachukua muda fulani kuliwa.\n  \n  @param appleCount Jumla ya idadi ya tufaha zilizopo awali.\n  @param timePerApple Muda kwa dakika unaochukua kula tufaha moja.\n  @param timePassed Muda kwa dakika ambao umepita.\n  @return Idadi ya tufaha nzima zilizobaki.\n  \n  Mfano:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "tr": "Bir Kotlin fonksiyonu `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` yazın ve aşağıdaki problemi çözün:\nBelirli bir zaman geçtikten sonra kalan bütün elma sayısını hesaplar, \n  her bir elmanın art arda yendiğini ve her birinin yenmesinin belirli bir süre aldığını varsayar.\n  \n  @param appleCount Başlangıçta mevcut olan toplam elma sayısı.\n  @param timePerApple Bir elmayı yemek için geçen süre (dakika cinsinden).\n  @param timePassed Geçen süre (dakika cinsinden).\n  @return Kalan bütün elma sayısı.\n  \n  Örnek:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "vi": "Viết một hàm Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` để giải quyết vấn đề sau:\nTính toán số lượng táo nguyên còn lại sau khi một khoảng thời gian đã trôi qua, \n  giả sử mỗi quả táo được ăn lần lượt và mỗi quả mất một khoảng thời gian nhất định để ăn.\n  \n  @param appleCount Tổng số lượng táo ban đầu có sẵn.\n  @param timePerApple Thời gian tính bằng phút để ăn một quả táo.\n  @param timePassed Thời gian tính bằng phút đã trôi qua.\n  @return Số lượng táo nguyên còn lại.\n  \n  Ví dụ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4"
    },
    "instruction_bertscore": {
      "es": "0.9791841319586868",
      "arb": "0.9809803464943854",
      "sw": "0.9578325577797225",
      "tr": "0.9663746573161279",
      "vi": "0.9717803831359924"
    },
    "level": "hard",
    "test": "fun main() {\n    check(remainingApples(50, 10, 200) == 30) // Test case based on example 1\n    check(remainingApples(5, 5, 3) == 4) // Test case based on example 2\n    check(remainingApples(10, 0, 100) == 0) // Test for edge case where timePerApple is 0\n    check(remainingApples(100, 1, 10000) == 0) // Test for case where all apples can be eaten\n}\n\n\nmain()",
    "entry_point": "remainingApples",
    "signature": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int",
    "docstring": {
      "en": "Calculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "es": "Calcula el número de manzanas enteras que quedan después de que ha pasado un tiempo determinado, \n  asumiendo que cada manzana se come una tras otra y cada una toma una cierta cantidad de tiempo para comer.\n  \n  @param appleCount El número total de manzanas disponibles inicialmente.\n  @param timePerApple El tiempo en minutos que se tarda en comer una sola manzana.\n  @param timePassed El tiempo en minutos que ha transcurrido.\n  @return El número de manzanas enteras restantes.\n  \n  Ejemplo:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "arb": "يحسب عدد التفاح الكامل المتبقي بعد مرور فترة زمنية معينة، \n  بافتراض أن كل تفاحة تؤكل واحدة تلو الأخرى وكل واحدة تستغرق وقتًا معينًا للأكل.\n  \n  @param appleCount العدد الإجمالي للتفاح المتاح في البداية.\n  @param timePerApple الوقت بالدقائق الذي يستغرقه أكل تفاحة واحدة.\n  @param timePassed الوقت بالدقائق الذي انقضى.\n  @return عدد التفاح الكامل المتبقي.\n  \n  مثال:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "sw": "Hesabu idadi ya maapulo kamili yaliyobaki baada ya muda fulani kupita, \n  ukizingatia kila tunda la tufaha linaliwa moja baada ya lingine na kila moja linachukua muda fulani kuliwa.\n  \n  @param appleCount Jumla ya idadi ya maapulo yaliyopo mwanzoni.\n  @param timePerApple Muda kwa dakika unaochukua kula tunda moja la tufaha.\n  @param timePassed Muda kwa dakika ambao umepita.\n  @return Idadi ya maapulo kamili yaliyobaki.\n  \n  Mfano:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "tr": "Belli bir süre geçtikten sonra kalan bütün elma sayısını hesaplar, \n  her bir elmanın art arda yendiği ve her birinin yenmesinin belirli bir süre aldığı varsayılır.\n  \n  @param appleCount Başlangıçta mevcut olan toplam elma sayısı.\n  @param timePerApple Bir elmayı yemek için geçen süre (dakika cinsinden).\n  @param timePassed Geçen süre (dakika cinsinden).\n  @return Kalan bütün elma sayısı.\n  \n  Örnek:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "vi": "Tính toán số lượng táo nguyên còn lại sau khi một khoảng thời gian nhất định đã trôi qua, \n  giả sử mỗi quả táo được ăn lần lượt và mỗi quả mất một khoảng thời gian nhất định để ăn.\n  \n  @param appleCount Tổng số lượng táo ban đầu có sẵn.\n  @param timePerApple Thời gian tính bằng phút để ăn một quả táo.\n  @param timePassed Thời gian tính bằng phút đã trôi qua.\n  @return Số lượng táo nguyên còn lại.\n  \n  Ví dụ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4"
    },
    "docstring_bertscore": {
      "es": "0.986364818863479",
      "arb": "0.9650138405756579",
      "sw": "0.9275022944868382",
      "tr": "0.9213997732903033",
      "vi": "0.9597175600957436"
    }
  },
  {
    "task_id": "Kotlin/49",
    "prompt": {
      "en": "/**\n * Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n * IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n * \n * Example:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Note:\n * - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n * - The discontinuous ID cannot be the minimum or maximum of the entire ID set.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "es": "/**\n * Encuentra los números de identificación faltantes (discontinuos) y duplicados de una lista de listas de números de identificación.\n * Se espera que los IDs sean continuos, pero debido a un error, falta uno y otro está duplicado.\n * \n * Ejemplo:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Nota:\n * - La función asume que los números de identificación son enteros positivos y que la lista contiene al menos un duplicado y un ID faltante.\n * - El ID discontinuo no puede ser el mínimo o el máximo de todo el conjunto de IDs.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "arb": "/**\n * يعثر على أرقام الهوية المفقودة (غير المتصلة) والمكررة من قائمة من قوائم أرقام الهوية.\n * من المتوقع أن تكون الأرقام متصلة ولكن بسبب خطأ، هناك رقم مفقود وآخر مكرر.\n * \n * مثال:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * ملاحظة:\n * - تفترض الدالة أن أرقام الهوية هي أعداد صحيحة موجبة وأن القائمة تحتوي على الأقل على رقم مكرر وآخر مفقود.\n * - لا يمكن أن يكون الرقم غير المتصل هو الحد الأدنى أو الأقصى لمجموعة الأرقام الكاملة.\n */",
      "sw": "/**\n * Inapata namba za ID zilizopotea (zisizoendelea) na zilizorudiwa kutoka kwenye orodha ya orodha za namba za ID.\n * ID zinatarajiwa kuwa endelevu lakini kutokana na kosa, moja imepotea na nyingine imerudiwa.\n * \n * Mfano:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Kumbuka:\n * - Kazi inadhani namba za ID ni namba kamili chanya na orodha ina angalau ID moja iliyorudiwa na moja iliyopotea.\n * - ID isiyoendelea haiwezi kuwa ndogo au kubwa zaidi ya seti nzima ya ID.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "tr": "/**\n * Bir ID numaraları listesinden eksik (sürekli olmayan) ve yinelenen ID numaralarını bulur.\n * ID'lerin sürekli olması beklenir ancak bir hata nedeniyle biri eksik ve diğeri yinelenmiştir.\n * \n * Örnek:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Not:\n * - Fonksiyon, ID numaralarının pozitif tam sayılar olduğunu ve listenin en az bir yinelenen ve bir eksik ID içerdiğini varsayar.\n * - Sürekli olmayan ID, tüm ID kümesinin minimumu veya maksimumu olamaz.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "vi": "/**\n * Tìm các số ID bị thiếu (không liên tục) và trùng lặp từ một danh sách các danh sách số ID.\n * Các ID được kỳ vọng là liên tục nhưng do lỗi, một ID bị thiếu và một ID khác bị trùng lặp.\n * \n * Ví dụ:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Lưu ý:\n * - Hàm giả định rằng các số ID là số nguyên dương và danh sách chứa ít nhất một ID trùng lặp và một ID bị thiếu.\n * - ID không liên tục không thể là giá trị nhỏ nhất hoặc lớn nhất của toàn bộ tập hợp ID.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> "
    },
    "prompt_bertscore": {
      "es": "0.9730516175746157",
      "arb": "0.8996749726253745",
      "sw": "0.9583458186843167",
      "tr": "0.971101067232853",
      "vi": "0.9507360901564891"
    },
    "canonical_solution": "{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` to solve the following problem:\nFinds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.",
      "es": "Escribe una función de Kotlin `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` para resolver el siguiente problema:\nEncuentra los números de ID faltantes (discontinuos) y duplicados de una lista de listas de números de ID.\n  Se espera que los IDs sean continuos pero debido a un error, uno falta y otro está duplicado.\n  \n  Ejemplo:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Nota:\n  - La función asume que los números de ID son enteros positivos y la lista contiene al menos un ID duplicado y uno faltante.\n  - El ID discontinuo no puede ser el mínimo o máximo de todo el conjunto de IDs.",
      "arb": "اكتب دالة كوتلن `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` لحل المشكلة التالية:\nتجد أرقام الهوية المفقودة (غير المتسلسلة) والمكررة من قائمة من قوائم أرقام الهوية.\nمن المتوقع أن تكون الأرقام متسلسلة ولكن بسبب خطأ، يوجد رقم مفقود وآخر مكرر.\n\nمثال:\n>>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n    Pair(7, 9)\n\nملاحظة:\n- تفترض الدالة أن أرقام الهوية هي أعداد صحيحة موجبة وأن القائمة تحتوي على الأقل على رقم مكرر ورقم مفقود.\n- لا يمكن أن يكون الرقم غير المتسلسل هو الحد الأدنى أو الأقصى لمجموعة الأرقام بالكامل.",
      "sw": "Andika kazi ya Kotlin `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` kutatua tatizo lifuatalo:\nInapata namba za vitambulisho ambazo hazipo (zisizoendelea) na zilizorudiwa kutoka kwenye orodha ya orodha za namba za vitambulisho.\n  Vitambulisho vinatarajiwa kuwa vinaendelea lakini kutokana na hitilafu, kimoja hakipo na kingine kimerudiwa.\n  \n  Mfano:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Kumbuka:\n  - Kazi inadhani namba za vitambulisho ni namba kamili chanya na orodha ina angalau kitambulisho kimoja kilichorudiwa na kimoja kisichokuwepo.\n  - Kitambulisho kisichoendelea hakiwezi kuwa cha chini kabisa au cha juu kabisa katika seti nzima ya vitambulisho.",
      "tr": "Bir Kotlin fonksiyonu `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` yazarak aşağıdaki problemi çözün:\nBir ID numaraları listesi listesinden eksik (kesintili) ve yinelenen ID numaralarını bulur.\n  ID'lerin sürekli olması beklenir ancak bir hata nedeniyle biri eksik ve diğeri yinelenmiştir.\n  \n  Örnek:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Not:\n  - Fonksiyon, ID numaralarının pozitif tamsayılar olduğunu ve listenin en az bir yinelenen ve bir eksik ID içerdiğini varsayar.\n  - Kesintili ID, tüm ID kümesinin minimumu veya maksimumu olamaz.",
      "vi": "Viết một hàm Kotlin `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` để giải quyết vấn đề sau:\nTìm các số ID bị thiếu (không liên tục) và trùng lặp từ một danh sách các danh sách số ID.\n  ID được kỳ vọng là liên tục nhưng do lỗi, một số bị thiếu và một số khác bị trùng lặp.\n  \n  Ví dụ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Lưu ý:\n  - Hàm giả định rằng các số ID là số nguyên dương và danh sách chứa ít nhất một ID trùng lặp và một ID bị thiếu.\n  - ID không liên tục không thể là giá trị nhỏ nhất hoặc lớn nhất của toàn bộ tập hợp ID."
    },
    "instruction_bertscore": {
      "es": "0.989780069634993",
      "arb": "0.9466967427277636",
      "sw": "0.9634398934363374",
      "tr": "0.9802146263754958",
      "vi": "0.9600147111457719"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9))) == Pair(7, 9))\n    // Add more tests to ensure robustness\n    check(findMissingAndDuplicateIds(listOf(listOf(1, 2, 4,7), listOf(3, 5, 5))) == Pair(6, 5))\n    check(findMissingAndDuplicateIds(listOf(listOf(10, 11,17, 12, 14), listOf(13, 15, 12))) == Pair(16, 12))\n}\n\n\nmain()",
    "entry_point": "findMissingAndDuplicateIds",
    "signature": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.",
      "es": "Encuentra los números de identificación faltantes (discontinuos) y duplicados de una lista de listas de números de identificación. \n  Se espera que los IDs sean continuos, pero debido a un error, falta uno y otro está duplicado.\n  \n  Ejemplo:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Nota:\n  - La función asume que los números de identificación son enteros positivos y que la lista contiene al menos un ID duplicado y uno faltante.\n  - El ID discontinuo no puede ser el mínimo o máximo de todo el conjunto de IDs.",
      "arb": "يعثر على أرقام الهوية المفقودة (غير المتتابعة) والمكررة من قائمة قوائم لأرقام الهوية.\n  من المتوقع أن تكون أرقام الهوية متتابعة ولكن بسبب خطأ، هناك رقم مفقود وآخر مكرر.\n  \n  مثال:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  ملاحظة:\n  - تفترض الدالة أن أرقام الهوية هي أعداد صحيحة موجبة وأن القائمة تحتوي على الأقل على رقم هوية مكرر وآخر مفقود.\n  - لا يمكن أن يكون رقم الهوية غير المتتابع هو الحد الأدنى أو الأقصى لمجموعة أرقام الهوية بأكملها.",
      "sw": "Inapata namba za kitambulisho zinazokosekana (zisizoendelea) na zinazojirudia kutoka kwenye orodha ya orodha za namba za kitambulisho. \n  Vitambulisho vinatarajiwa kuwa vinaendelea lakini kutokana na hitilafu, moja inakosekana na nyingine inajirudia.\n  \n  Mfano:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Kumbuka:\n  - Kazi inadhani namba za kitambulisho ni namba kamili chanya na orodha ina angalau kitambulisho kimoja kinachojirudia na kimoja kinachokosekana.\n  - Kitambulisho kisichoendelea hakiwezi kuwa cha chini kabisa au cha juu kabisa katika seti nzima ya vitambulisho.",
      "tr": "Eksik (kesintili) ve yinelenen kimlik numaralarını bir kimlik numaraları listesinden bulur.\n  Kimlik numaralarının kesintisiz olması beklenir, ancak bir hata nedeniyle biri eksik ve diğeri yinelenmiştir.\n  \n  Örnek:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Not:\n  - Fonksiyon, kimlik numaralarının pozitif tamsayılar olduğunu ve listenin en az bir yinelenen ve bir eksik kimlik numarası içerdiğini varsayar.\n  - Kesintili kimlik numarası, tüm kimlik numarası kümesinin minimumu veya maksimumu olamaz.",
      "vi": "Tìm các số ID bị thiếu (không liên tục) và trùng lặp từ một danh sách các danh sách số ID. \n  Các ID được kỳ vọng là liên tục nhưng do lỗi, một ID bị thiếu và một ID khác bị trùng lặp.\n  \n  Ví dụ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Lưu ý:\n  - Hàm giả định rằng các số ID là số nguyên dương và danh sách chứa ít nhất một ID trùng lặp và một ID bị thiếu.\n  - ID không liên tục không thể là giá trị nhỏ nhất hoặc lớn nhất của toàn bộ tập hợp ID."
    },
    "docstring_bertscore": {
      "es": "0.9754053875898792",
      "arb": "0.9276647741385248",
      "sw": "0.9508864533549325",
      "tr": "0.9623929126979025",
      "vi": "0.9414479349089167"
    }
  },
  {
    "task_id": "Kotlin/50",
    "prompt": {
      "en": "/**\n * Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n * \n * @param s The input string of length 8.\n * @return A Triple of integers where the first element is the count of digits,\n * the second element is the count of lowercase letters, and the third element\n * is the count of uppercase letters in the string.\n * \n * Example:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "es": "/**\n * Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n * \n * @param s La cadena de entrada de longitud 8.\n * @return Un Triple de enteros donde el primer elemento es el conteo de dígitos,\n * el segundo elemento es el conteo de letras minúsculas, y el tercer elemento\n * es el conteo de letras mayúsculas en la cadena.\n * \n * Ejemplo:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "arb": "/**\n * يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n * \n * @param s السلسلة المدخلة بطول 8.\n * @return ثلاثي من الأعداد الصحيحة حيث العنصر الأول هو عدد الأرقام،\n * العنصر الثاني هو عدد الأحرف الصغيرة، والعنصر الثالث\n * هو عدد الأحرف الكبيرة في السلسلة.\n * \n * مثال:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "sw": "/**\n * Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano wa herufi uliotolewa wa urefu wa 8.\n * \n * @param s Mfuatano wa herufi wa urefu wa 8.\n * @return Triple ya nambari ambapo kipengele cha kwanza ni hesabu ya tarakimu,\n * kipengele cha pili ni hesabu ya herufi ndogo, na kipengele cha tatu\n * ni hesabu ya herufi kubwa katika mfuatano wa herufi.\n * \n * Mfano:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "tr": "/**\n * Verilen 8 karakter uzunluğundaki bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n * \n * @param s 8 karakter uzunluğundaki giriş stringi.\n * @return İlk elemanı rakamların sayısını, ikinci elemanı küçük harflerin sayısını ve üçüncü elemanı\n * stringdeki büyük harflerin sayısını içeren bir Tamsayı Üçlüsü.\n * \n * Örnek:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "vi": "/**\n * Đếm số chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi có độ dài 8.\n * \n * @param s Chuỗi đầu vào có độ dài 8.\n * @return Một Triple của các số nguyên trong đó phần tử đầu tiên là số lượng chữ số,\n * phần tử thứ hai là số lượng chữ cái viết thường, và phần tử thứ ba\n * là số lượng chữ cái viết hoa trong chuỗi.\n * \n * Ví dụ:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9838573089332946",
      "sw": "0.9601213756603876",
      "tr": "0.9450757201881379",
      "vi": "0.9724797607076162"
    },
    "canonical_solution": "{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countCharacters(s: String): Triple<Int, Int, Int>` to solve the following problem:\nCounts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "es": "Escribe una función de Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` para resolver el siguiente problema:\nCuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n  \n  @param s La cadena de entrada de longitud 8.\n  @return Un Triple de enteros donde el primer elemento es el conteo de dígitos,\n  el segundo elemento es el conteo de letras minúsculas, y el tercer elemento\n  es el conteo de letras mayúsculas en la cadena.\n  \n  Ejemplo:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "arb": "اكتب دالة Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` لحل المشكلة التالية:\nتحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n@param s السلسلة المدخلة بطول 8.\n@return ثلاثية من الأعداد الصحيحة حيث العنصر الأول هو عدد الأرقام،\nالعنصر الثاني هو عدد الأحرف الصغيرة، والعنصر الثالث هو عدد الأحرف الكبيرة في السلسلة.\n\nمثال:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "sw": "Andika kazi ya Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` kutatua tatizo lifuatalo:\nHesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyotolewa ya urefu wa 8.\n\n@param s Kamba ya ingizo ya urefu wa 8.\n@return Triple ya namba ambapo kipengele cha kwanza ni hesabu ya tarakimu,\nkipengele cha pili ni hesabu ya herufi ndogo, na kipengele cha tatu\nni hesabu ya herufi kubwa katika kamba.\n\nMfano:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "tr": "Bir Kotlin fonksiyonu `fun countCharacters(s: String): Triple<Int, Int, Int>` yazın:\nVerilen uzunluğu 8 olan bir stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  @param s Uzunluğu 8 olan giriş stringi.\n  @return Birinci elemanı rakamların sayısını, ikinci elemanı küçük harflerin sayısını ve üçüncü elemanı büyük harflerin sayısını içeren bir tamsayı Üçlüsü döndürür.\n\n  Örnek:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "vi": "Viết một hàm Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` để giải quyết vấn đề sau:\nĐếm số chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi có độ dài 8.\n\n@param s Chuỗi đầu vào có độ dài 8.\n@return Một Triple của các số nguyên, trong đó phần tử đầu tiên là số lượng chữ số,\nphần tử thứ hai là số lượng chữ cái thường, và phần tử thứ ba là số lượng chữ cái hoa trong chuỗi.\n\nVí dụ:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)"
    },
    "instruction_bertscore": {
      "es": "0.9964745093670118",
      "arb": "0.9823681769666761",
      "sw": "0.9773176022681019",
      "tr": "0.9657664510893991",
      "vi": "0.9739665091096624"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countCharacters(\"yLOI2022\") == Triple(4, 1, 3))\n    check(countCharacters(\"IAKIOIOI\") == Triple(0, 0, 8))\n    check(countCharacters(\"1n2s0e1s\") == Triple(4, 4, 0))\n}\n\n\nmain()",
    "entry_point": "countCharacters",
    "signature": "fun countCharacters(s: String): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "es": "Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena dada de longitud 8.\n\n@param s La cadena de entrada de longitud 8.\n@return Un Triple de enteros donde el primer elemento es el conteo de dígitos,\nel segundo elemento es el conteo de letras minúsculas, y el tercer elemento\nes el conteo de letras mayúsculas en la cadena.\n\nEjemplo:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "arb": "يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n\n@param s السلسلة المدخلة بطول 8.\n@return ثلاثية من الأعداد الصحيحة حيث أن العنصر الأول هو عدد الأرقام، العنصر الثاني هو عدد الأحرف الصغيرة، والعنصر الثالث هو عدد الأحرف الكبيرة في السلسلة.\n\nمثال:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "sw": "Hesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano wa herufi uliotolewa wa urefu wa 8.\n\n@param s Mfuatano wa herufi wa urefu wa 8 unaoingizwa.\n\n@return Utatu wa nambari ambapo kipengele cha kwanza ni idadi ya tarakimu, kipengele cha pili ni idadi ya herufi ndogo, na kipengele cha tatu ni idadi ya herufi kubwa katika mfuatano wa herufi.\n\nMfano:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "tr": "Verilen uzunluğu 8 olan bir string içindeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  @param s Uzunluğu 8 olan giriş stringi.\n  @return İlk elemanı rakamların sayısını, ikinci elemanı küçük harflerin sayısını ve üçüncü elemanı string içindeki büyük harflerin sayısını içeren bir Tiple döner.\n  \n  Örnek:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "vi": "Đếm số chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi có độ dài 8.\n\n  @param s Chuỗi đầu vào có độ dài 8.\n  @return Một bộ ba số nguyên mà phần tử đầu tiên là số lượng chữ số,\n  phần tử thứ hai là số lượng chữ cái viết thường, và phần tử thứ ba\n  là số lượng chữ cái viết hoa trong chuỗi.\n\n  Ví dụ:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9791183853025642",
      "sw": "0.9349700022922259",
      "tr": "0.9495065680978831",
      "vi": "0.9667089522474096"
    }
  }
]