[
  {
    "task_id": "C/1",
    "prompt": {
      "en": "#include <assert.h>\n#include <string.h>\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "sq": "#include <assert.h>\n#include <string.h>\n// Kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "hy": "#include <assert.h>\n#include <string.h>\n// Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "bn": "#include <assert.h>\n#include <string.h>\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nchar *hello_mmcodeeval()",
      "bg": "#include <assert.h>\n#include <string.h>\n// Връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "zh": "#include <assert.h>\n#include <string.h>\n// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "fr": "#include <assert.h>\n#include <string.h>\n// Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "de": "#include <assert.h>\n#include <string.h>\n// Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "ha": "#include <assert.h>\n#include <string.h>\n// Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "hi": "#include <assert.h>\n#include <string.h>\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nchar *hello_mmcodeeval()",
      "hu": "#include <assert.h>\n#include <string.h>\n// Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "sq": "0.9328045338781835",
      "hy": "0.999999801369619",
      "bn": "0.9355251742072184",
      "bg": "0.9328045338781835",
      "zh": "0.999999801369619",
      "fr": "0.9978188397858558",
      "de": "0.999999801369619",
      "ha": "0.9355251742072184",
      "hi": "0.999999801369619",
      "hu": "0.9874948271011865"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\n请用不超过500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。",
      "fr": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9464321670602251",
      "bn": "0.9231671864207518",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main()\n{\n    assert(strcmp(hello_mmcodeeval(), \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\") == 0);\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "char *hello_mmcodeeval()",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "রিটার্ন \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation",
      "bg": "Върнете \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Komawa \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "रिटर्न \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hu": "Visszatér \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "sq": "0.9361431133226179",
      "hy": "0.999999801369619",
      "bn": "0.8909985989513896",
      "bg": "0.9625917417093185",
      "zh": "0.8731603989521705",
      "fr": "0.9993989444669884",
      "de": "0.999999801369619",
      "ha": "0.8514866462951676",
      "hi": "0.9520081191166365",
      "hu": "0.9625917417093185"
    }
  },
  {
    "task_id": "C/2",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n​    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n​    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n​    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n​    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\nPërndryshe, kthe \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n​    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n​    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում, վերադարձնել \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n​    প্যারামিটার:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n​    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন।\nঅন্যথায়, \"-1\" ফেরত দিন\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислява площта на триъгълник, дадени неговите три страни.\n​    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n​    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\nВ противен случай връща \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定三边的三角形面积。\n    参数：\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回：\n- str: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné ses trois côtés.\n    Paramètres :\n- a (float) : Longueur du côté 'a'.\n- b (float) : Longueur du côté 'b'.\n- c (float) : Longueur du côté 'c'.\n    Renvoie :\n- str : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks anhand seiner drei Seiten.\n​    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n​    Rückgabe:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika idan aka ba da gefenta uku.\n​    Sigogi:\n- a (float): Tsawon gefe 'a'.\n- b (float): Tsawon gefe 'b'.\n- c (float): Tsawon gefe 'c'.\n​    Mayarwa:\n- str: Idan gefen da aka bayar sun samar da alwatika, mayar da yankin da aka ƙididdige tare da wurare biyu na goma.\nIn ba haka ba, mayar da \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकिसी त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\nअन्यथा, \"-1\" लौटाएं\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét a három oldalának ismeretében.\n​    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n​    Visszatér:\n- str: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEllenkező esetben térjen vissza \"-1\" értékkel.\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "sq": "0.9868639770110197",
      "hy": "0.9875011832733797",
      "bn": "0.9875011832733797",
      "bg": "0.9860023184180904",
      "zh": "0.9790919674618866",
      "fr": "0.9767775262620682",
      "de": "0.9818217447884491",
      "ha": "0.9863076133137411",
      "hi": "0.9858972429465229",
      "hu": "0.9769209373971753"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "en": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nC कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9070022487513705",
      "bn": "0.9231671864207518",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9524868183349307",
      "hi": "0.9368593744766297",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = calculate_triangle_area(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculate_triangle_area(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n    Parametra:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\nPërndryshe, kthen \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\n    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնում է \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "bn": "ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- a (float): 'a' বাহুর দৈর্ঘ্য।\n- b (float): 'b' বাহুর দৈর্ঘ্য।\n- c (float): 'c' বাহুর দৈর্ঘ্য।\n    রিটার্ন:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন।\nঅন্যথায়, \"-1\" ফেরত দিন\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\n    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\nВ противен случай, връща \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "zh": "计算给定三边的三角形面积。\n    参数:\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回:\n- str: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n    Paramètres:\n- a (float): Longueur du côté 'a'.\n- b (float): Longueur du côté 'b'.\n- c (float): Longueur du côté 'c'.\n    Renvoie:\n- str: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabewert:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "ha": "Calculate the area of a triangle given its three sides.\n    Sigogi:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n    Abin da ake dawowa da shi:\n- str: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka lissafa tare da wurare guda 2 na adadi.\nIn ba haka ba, dawo da \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, \"-1\" लौटाएँ\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n    Visszatérési érték:\n- str: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEgyébként térjen vissza \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9789650426484053",
      "hy": "0.9928961830526682",
      "bn": "0.9904089334213494",
      "bg": "0.9952702133667972",
      "zh": "0.9845016658893718",
      "fr": "0.9792892074302543",
      "de": "0.9853017490641803",
      "ha": "0.9957602345168103",
      "hi": "0.9879389646331805",
      "hu": "0.9561797543791313"
    }
  },
  {
    "task_id": "C/3",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit vlerën e funksionit për një hyrje të dhënë.\n    Parametrat:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։\n    Պարամետրեր:\n- x (int): Մուտքագրված արժեքը ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը, կլորացված մինչև 5 տասնորդական թվանշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটার:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্ন:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислява стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в дефинираното множество, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\n    Дефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定输入的函数值。\n    参数：\n- x (int): 函数的输入值。\n    返回：\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算的函数值，保留到小数点后5位。\n\n    函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou chaîne: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabe:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige ƙimar aikin don wani shigarwar da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n    Mayar da:\n- double ko string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na ɗigo.\n\n    Ma'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न करता है:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatér:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\"-t ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve.\n\n    Függvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "sq": "0.9853251874491424",
      "hy": "0.9594917173525069",
      "bn": "0.9825298620968385",
      "bg": "0.9812254563845824",
      "zh": "0.9798060436817071",
      "fr": "0.980865140873385",
      "de": "0.9775996574091715",
      "ha": "0.9831013217030758",
      "hi": "0.9876646560769714",
      "hu": "0.9779081303909187"
    },
    "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}",
    "instruction": {
      "en": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nՏվեք C կոդի համառոտ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9132285166752901",
      "bn": "0.8955724607354799",
      "bg": "0.9075615919043648",
      "zh": "0.8856772910434649",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9096346971912259",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    const char* result = calculate_function_value(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(calculate_function_value(40), \"Not define\") == 0);\n    assert(strcmp(calculate_function_value(5), \"-0.14550\") == 0);\n    assert(strcmp(calculate_function_value(15), \"0.76266\") == 0);\n    assert(strcmp(calculate_function_value(25), \"0.31314\") == 0);\n    assert(strcmp(calculate_function_value(-1), \"Not define\") == 0);\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "const char* calculate_function_value(int x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define\n",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n    Parametrat:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրման համար։\n    Պարամետրեր:\n- x (int): Մուտքագրման արժեք ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নস:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "bg": "Изчислява стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n\n    Определения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "zh": "计算给定输入的函数值。\n    参数:\n- x (int): 函数的输入值。\n    返回:\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留小数点后5位。\n\n    函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabewerte:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Nicht definiert\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Nicht definiert",
      "ha": "Ƙididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n\n    Returns:\n- double or string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa da ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na decimal.\n\n    Function Definitions:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\n    >>> calculate_function_value(40)\n    Not define",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hu": "Számítsa ki a függvény értékét egy adott bemenethez.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési értékek:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket, 5 tizedesjegyre kerekítve.\n\n    Függvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define"
    },
    "docstring_bertscore": {
      "sq": "0.986233325551234",
      "hy": "0.9494402255506175",
      "bn": "0.9916406404141467",
      "bg": "0.9854672081715824",
      "zh": "0.9745641879261964",
      "fr": "0.9762060666558308",
      "de": "0.9654841973179485",
      "ha": "0.9820126285846237",
      "hi": "0.9901376043208557",
      "hu": "0.9651560599284789"
    }
  },
  {
    "task_id": "C/4",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të dallueshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrja e shembullit: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\nՊարամետրեր՝\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է՝\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը, մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ զանգ՝ \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nতিনটি পৃথক পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটার:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nTuple[int, int]: C তে একটি টিউপল ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n找到三个不同整数中的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir per Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a da ma'anar tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में एक टपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापसी करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia útján térünk vissza.\n\n>>> Példa hívás:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9929384913238287",
      "bn": "0.9758131757621438",
      "bg": "0.9929384913238287",
      "zh": "0.9720715752745895",
      "fr": "1",
      "de": "0.9842843642525196",
      "ha": "0.9599177795198268",
      "hi": "0.9790774674440711",
      "hu": "0.9924297989179983"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}",
    "instruction": {
      "en": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\n请用不超过500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。",
      "fr": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakter felhasználásával."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9464321670602251",
      "bn": "0.8821972867677337",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9397117067482907"
    },
    "level": "",
    "test": "int main() {\n    int max, min;\n\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrja e shembullit:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bn": "তিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্সের মাধ্যমে রিটার্ন করব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "zh": "找到三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组在C语言中不是一个概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.  \n\n>>> Appel d'exemple :  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "ha": "Find the maximum and minimum na lambobi guda uku daban-daban.\nnSigogi:\na (int): Lamba na farko.\nb (int): Lamba na biyu.\nc (int): Lamba na uku.\n\nReturns:\nTuple[int, int]: Tuple ba wani abu ne a cikin C ba; maimakon haka, za mu mayar ta hanyar nuni.\n\n>>> Misali kira:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम खोजें।  \nपैरामीटर्स:  \na (int): पहला पूर्णांक।  \nb (int): दूसरा पूर्णांक।  \nc (int): तीसरा पूर्णांक।  \n\nवापसी:  \nTuple[int, int]: एक ट्यूपल C में एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।  \n\n>>> उदाहरण कॉल:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatér:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia szerint fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "docstring_bertscore": {
      "sq": "0.9965237697015085",
      "hy": "0.9898650834380759",
      "bn": "0.9836650347244529",
      "bg": "0.9885149927381818",
      "zh": "0.9799033725684142",
      "fr": "1",
      "de": "0.9805677911929759",
      "ha": "0.9370818405033888",
      "hi": "0.9722209453211278",
      "hu": "0.9816715802203867"
    }
  },
  {
    "task_id": "C/5",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n    \n    Վերադարձնում է:\n    double: A և B կետերի միջև հեռավորությունը։\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটার:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算两个点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres:\n- xa (double): coordonnée x du point A.\n- ya (double): coordonnée y du point A.\n- xb (double): coordonnée x du point B.\n- yb (double): coordonnée y du point B.\n    \n    Renvoie:\n    double: La distance entre les points A et B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabe:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-ƙudurin maki A.\n- ya (double): y-ƙudurin maki A.\n- xb (double): x-ƙudurin maki B.\n- yb (double): y-ƙudurin maki B.\n    \n    Mayar da:\n    double: Nisan tsakanin maki A da B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदुओं A और B के बीच की दूरी।\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatérési érték:\n    double: A távolság A és B pontok között.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9970292840212422",
      "bg": "0.9988721766964839",
      "zh": "0.9970292840212422",
      "fr": "1",
      "de": "0.9988721766964839",
      "ha": "1",
      "hi": "0.9970292840212422",
      "hu": "0.9703301827240567"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "en": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nПредоставете кратко описание на C кода на естествен език (документация) на български, като използвате не повече от 500 знака.",
      "zh": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\n请用不超过500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。",
      "fr": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nC कोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8657044103392638",
      "bg": "0.8492184859741302",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9245738867792409",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(fabs(calculate_distance(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametra:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hy": "Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև:\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը:\n- ya (double): A կետի y-կոորդինատը:\n- xb (double): B կետի x-կոորդինատը:\n- yb (double): B կետի y-կոորդինատը:\n    \n    Վերադարձնում է:\n    double: Հեռավորությունը A և B կետերի միջև:\n    >>> calculate_distance(0,0,3,4)\n    5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> calculate_distance(0,0,3,4)\n    5",
      "bg": "Изчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> calculate_distance(0,0,3,4)\n    5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres:\n- xa (double): coordonnée x du point A.\n- ya (double): coordonnée y du point A.\n- xb (double): coordonnée x du point B.\n- yb (double): coordonnée y du point B.\n    \n    Retourne:\n    double: La distance entre les points A et B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabewert:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "ha": "Calculate the distance tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-hadin gwiwa na maki A.\n- ya (double): y-hadin gwiwa na maki A.\n- xb (double): x-hadin gwiwa na maki B.\n- yb (double): y-hadin gwiwa na maki B.\n    \n    Returns:\n    double: Nisan tsakanin maki A da B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न:\n    double: बिंदु A और B के बीच की दूरी।\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatér:\n    double: A távolság A és B pontok között.\n    >>> calculate_distance(0,0,3,4)\n    5"
    },
    "docstring_bertscore": {
      "sq": "0.9608779587817494",
      "hy": "0.9533309974543289",
      "bn": "0.9968675988910798",
      "bg": "0.9973435172840394",
      "zh": "0.9711090124480944",
      "fr": "1",
      "de": "0.99424965046904",
      "ha": "0.9968675988910798",
      "hi": "0.9955596178319651",
      "hu": "0.964370874032248"
    }
  },
  {
    "task_id": "C/6",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n​    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n​    Returns:\n​    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjej faktorielin e N dhe merr modulo 10007 të rezultatit.\n​    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n​    Kthen:\n​    int: Rezultati pas marrjes së modulo 10007 të daljes.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n​    Պարամետրեր:\n- N (int): Անթերի թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n​    Վերադարձնում է:\n​    int: Արդյունքը՝ 10007 մոդուլը վերցնելուց հետո։\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете факториела на N и вземете модуло 10007 от резултата.\n​    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n​    Връща:\n​    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到N的阶乘并对结果取模10007。\n    参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n    返回：\n    int: 对输出取模10007后的结果。\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver le factoriel de N et prendre le modulo 10007 du résultat.\n    Paramètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n    Renvoie :\n    int : Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Fakultät von N und nehme das Modulo 10007 des Ergebnisses.\n​    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n​    Rückgabe:\n​    int: Das Ergebnis nach der Modulo-Operation 10007 des Outputs.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n​    Sigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n​    Komawa:\n​    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से माड्यूलो लेने के बाद का परिणाम।\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n​    Paraméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n​    Visszatér:\n​    int: Az eredmény, miután vettük az output 10007-es modulóját.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9686803587791809",
      "hy": "0.9604040266926002",
      "bn": "0.9673743640238766",
      "bg": "0.9686803587791809",
      "zh": "0.963186838330899",
      "fr": "0.9834018494695816",
      "de": "0.9619076586770343",
      "ha": "0.9771880952596672",
      "hi": "0.9606332461523145",
      "hu": "0.9587438739679106"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9251232984131834",
      "bn": "0.8843822209591174",
      "bg": "0.9075615919043648",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9524868183349307",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "en": "Find the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n",
      "sq": "Gjej faktorielin e N dhe merr modulo 10007 të rezultatit.\n    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n    Kthen:\n    int: Rezultati pasi të merret modulo 10007 i daljes.\n    >>> process_request(1)\n    1",
      "hy": "Գտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n    Պարամետրեր:  \n- N (int): Ընդհանուր թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):  \n    Վերադարձնում է:  \n    int: Արդյունքը՝ 10007-ի մոդուլո վերցնելուց հետո:  \n    >>> process_request(1)  \n    1  ",
      "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n    >>> process_request(1)\n    1",
      "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n    Връща:\n    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> process_request(1)\n    1",
      "zh": "计算N的阶乘并对结果取模10007。\n    参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n    返回：\n    int: 对输出取模10007后的结果。\n    >>> process_request(1)\n    1",
      "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n    Paramètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n    Renvoie:\n    int: Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> process_request(1)\n    1",
      "de": "Finde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n    Rückgabe:\n    int: Das Ergebnis nach dem Nehmen des Modulo 10007 der Ausgabe.\n    >>> process_request(1)\n    1",
      "ha": "Nemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n    Sigogi:\n- N (int): Wani lamba mai nuna ƙimar shigarwa (N <= 10000).\n    Dawowa:\n    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> process_request(1)\n    1",
      "hi": "N का फैक्टरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n    >>> process_request(1)\n    1",
      "hu": "Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n    Paraméterek:  \n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).  \nVisszatérési érték:  \nint: Az eredmény, miután az outputot 10007-tel vettük modulo.  \n>>> process_request(1)  \n1  "
    },
    "docstring_bertscore": {
      "sq": "0.9845402001832926",
      "hy": "0.9366404837967293",
      "bn": "0.991984072342956",
      "bg": "0.9845402001832926",
      "zh": "0.9485869094336916",
      "fr": "1",
      "de": "1",
      "ha": "0.991984072342956",
      "hi": "1",
      "hu": "0.9672887543296504"
    }
  },
  {
    "task_id": "C/7",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյունու մակերեսը՝ հաշվի առնելով դրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյունու հիմքի երկարությունը։\n- height (int): Եռանկյունու բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյունու հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n    প্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчисляване на лицето на триъгълник, като се дадат неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定底和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n    Renvoie :\n    float : L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> calculate_triangle_area(1,2)\n    1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika la'akari da ginshiƙinsa da tsayinsa.\n​    Sigogi:\n- base (int): Tsawon ginshiƙin alwatika.\n- height (int): Tsayin alwatika.\n​    Komawa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wurin ɗaya na goma.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nत्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "sq": "0.9780992128174743",
      "hy": "0.9780992128174743",
      "bn": "0.9692041470939698",
      "bg": "0.9769858895317737",
      "zh": "0.9533627783152945",
      "fr": "0.9795349132115945",
      "de": "0.9776596437842441",
      "ha": "0.9716121432032558",
      "hi": "0.97042870339305",
      "hu": "0.9753600998630032"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "en": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nԱպահովեք C կոդի կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9070022487513705",
      "bn": "0.8821972867677337",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9160367530023614",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hy": "Եռանկյան մակերեսը հաշվարկել՝ հաշվի առնելով նրա հիմքը և բարձրությունը:\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে তার ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে গোলাকার।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bg": "Изчисляване на лицето на триъгълник, дадени неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n    Връща:\n    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算的三角形面积，四舍五入到小数点后一位。\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewerte:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "ha": "Ƙididdige yanki na alwatika la'akari da tushenta da tsayinta.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsawo na alwatika.\n    Returns:\n    float: Yankin da aka lissafa na alwatika, an zagaye zuwa wurin goma daya.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hi": "त्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hu": "Számítsa ki a háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9864204353701689",
      "hy": "0.9864204353701689",
      "bn": "0.9881099853912516",
      "bg": "0.9854977972502618",
      "zh": "0.9838747884068257",
      "fr": "0.9881099853912516",
      "de": "1",
      "ha": "0.9770095265471168",
      "hi": "0.9886514518099527",
      "hu": "0.9766958891754628"
    }
  },
  {
    "task_id": "C/8",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në paraqitjen binare.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացմամբ։\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն\n​         x-ը y-ի վերածելու համար երկբայն համակարգում։\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n​    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n​    রিটার্নস:\n​    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчислява разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се трансформира x в y в двоична форма.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n​    Paramètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le second entier positif (y <= 1,000,000,000).\n​    Renvoie :\n​    int : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n​         pour transformer x en y en binaire.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabe:\n    int: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen,\n         um x in y in binär zu transformieren.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Komawa:\n​    int: Nisan Hamming tsakanin x da y, wato, yawan bits da ake buƙatar a juya\n​         don canza x zuwa y a cikin binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदो पूर्णांकों के द्विआधारी अभ्यावेदन में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को y में द्विआधारी में बदलने के लिए कितने बिट्स को उलटना होगा\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n​    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n​    Visszatérési érték:\n​    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n​         ahhoz, hogy x-ből y-t alakítsunk binárisan.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "sq": "0.9680050154836622",
      "hy": "0.9690531880043833",
      "bn": "0.960237971694055",
      "bg": "0.9729274735864689",
      "zh": "0.9765234780047245",
      "fr": "0.9804112704527204",
      "de": "0.9804112704527204",
      "ha": "0.9660594309014255",
      "hi": "0.9585764285566982",
      "hu": "0.9671669939060761"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "en": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nՏվեք C կոդի կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n将以下C代码的功能用中文自然语言简洁描述（文档字符串），字数不超过500个字符。",
      "fr": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9070022487513705",
      "bn": "0.9089325387942676",
      "bg": "0.9075615919043648",
      "zh": "0.8309520388733997",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9400299126187086",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> hamming_distance(1,2)\n    2",
      "hy": "Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացման մեջ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն՝ x-ը y-ի վերածելու համար երկբայականում։\n    >>> hamming_distance(1,2)\n    2",
      "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> hamming_distance(1,2)\n    2",
      "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична репрезентация.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат променени, за да се трансформира x в y в двоичен вид.\n    >>> hamming_distance(1,2)\n    2",
      "zh": "计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即在二进制中将 x 转换为 y 需要翻转的位数。\n    >>> hamming_distance(1,2)\n    2",
      "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> hamming_distance(1,2)\n    2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits, die umgekippt werden müssen, um x in y in binär zu transformieren.\n    >>> hamming_distance(1,2)\n    2",
      "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba na farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba na biyu mai kyau (y <= 1,000,000,000).\n    Returns:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\n    >>> hamming_distance(1,2)\n    2",
      "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जिन बिट्स को उलटना आवश्यक है उनकी संख्या।\n    >>> hamming_distance(1,2)\n    2",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz hány bitet kell megváltoztatni ahhoz, hogy x-ből y-t kapjunk binárisan.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9930175462154806",
      "hy": "0.9846911592728791",
      "bn": "0.9788188506879637",
      "bg": "0.9871978746815394",
      "zh": "0.9915458937223931",
      "fr": "0.999999801369619",
      "de": "0.9941390133468035",
      "ha": "0.988055163406086",
      "hi": "0.9897387545157377",
      "hu": "0.9660381774506548"
    }
  },
  {
    "task_id": "C/9",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë e numrave të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e dhënë.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nՀաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցուցակում գտնվող կենտ թվերի քանակը:\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nএকটি প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    রিটার্ন:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nБройте броя на нечетните цели числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в входния списък.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 一系列整数。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de nombres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Retourne:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "de": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nZählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabe:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nƘirga adadin lambobin da ba su da ma'ana a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su da ma'ana a cikin jerin shigarwa.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nदी गई संख्या की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों की एक श्रृंखला।\n    रिटर्न्स:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nSzámolja meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): A kiértékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatér:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9743693315224011",
      "hy": "0.9848876047197226",
      "bn": "0.990640139184874",
      "bg": "0.9884309720870039",
      "zh": "0.9782549390362056",
      "fr": "0.9926780868942919",
      "de": "0.9836682128105494",
      "ha": "0.973901755605445",
      "hi": "0.9928802926221855",
      "hu": "0.9926780868942919"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "en": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9251232984131834",
      "bn": "0.9231671864207518",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë numrash të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e dhënë.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hy": "Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցանկում կենտ թվերի քանակը:\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    Parameters:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    Returns:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в списъка на входа.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "zh": "计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 整数序列。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de chiffres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Renvoie:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabewert:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "ha": "Kirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों का एक अनुक्रम।\n    रिटर्न्स:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hu": "Számolja meg a páratlan egész számokat egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egy egész számok sorozata.\n    Visszatér:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9513570087276042",
      "hy": "0.966756424908477",
      "bn": "0.985607242590212",
      "bg": "0.9831831574200622",
      "zh": "0.9717597255763648",
      "fr": "0.9834596509104628",
      "de": "0.9759730732188768",
      "ha": "0.9630436258261729",
      "hi": "0.9962560159478734",
      "hu": "0.9684612694688994"
    }
  },
  {
    "task_id": "C/10",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë e numrave të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën hyrëse.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Deklarim i fiksuar",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել զույգ թվերի գումարը տրված ցուցակում։\n    Պարամետրեր:\n- numbers (list): Թվերի ցուցակ։\n- size (int): Ցուցակի չափը։\n    Վերադարձնում է:\n    int: Մուտքային ցուցակի զույգ թվերի գումարը։\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Ֆիքսված հայտարարություն",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n    প্যারামিটার:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকার জোড় সংখ্যাগুলির যোগফল।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчислява сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Фиксирана декларация",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算给定列表中偶数的和。\n    参数:\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回:\n    int: 输入列表中偶数的和。\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // 固定声明",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la somme des nombres pairs dans une liste donnée.\n    Paramètres:\n- numbers (list): Une liste d'entiers.\n- size (int): La taille de la liste.\n    Renvoie:\n    int: La somme des nombres pairs dans la liste d'entrée.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Déclaration corrigée",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabewert:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Feste Deklaration",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige jimillar lambobin da suka zama ma'aurata a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobi masu cikakken lamba.\n- size (int): Girman jerin.\n    Komawa:\n    int: Jimillar lambobin da suka zama ma'aurata a cikin jerin shigarwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Gyaran sanarwa",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न करता है:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámolja ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatérési érték:\n    int: A bemeneti listában található páros számok összege.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Rögzített deklaráció"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9744412357203358",
      "bn": "1",
      "bg": "0.9928050117077732",
      "zh": "0.9823463276247623",
      "fr": "0.9931359299225774",
      "de": "0.9865767574800433",
      "ha": "0.961103007003462",
      "hi": "0.9959940224752883",
      "hu": "0.9873325460798811"
    },
    "canonical_solution": "int calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9251232984131834",
      "bn": "0.8843822209591174",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9160367530023614",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6);\n    assert(calculate_even_sum(sample2, 4) == 4);\n    assert(calculate_even_sum(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(int *numbers, int size)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n",
      "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (list): Një listë e numrave të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën hyrëse.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hy": "Հաշվել տրված ցուցակի զույգ թվերի գումարը։\n    Պարամետրեր:\n- numbers (list): ամբողջ թվերի ցուցակ։\n- size (int): ցուցակի չափը։\n    Վերադարձնում է:\n    int: մուտքային ցուցակի զույգ թվերի գումարը։\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "bn": "দেওয়া তালিকায় জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকায় জোড় সংখ্যাগুলির যোগফল।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "bg": "Изчисляване на сумата от четни числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата от четните числа в входния списък.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "zh": "计算给定列表中偶数的和。\n    参数：\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回：\n    int: 输入列表中偶数的和。\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "fr": "Calculer la somme des nombres pairs dans une liste donnée.\n    Paramètres:\n- numbers (list): Une liste d'entiers.\n- size (int): La taille de la liste.\n    Renvoie:\n    int: La somme des nombres pairs dans la liste d'entrée.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "de": "Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabe:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "ha": "Ƙididdige jimillar lambobin da ke daidai a cikin jerin da aka bayar.\n    Ma'auni:\n- numbers (list): Jerin lambobi.\n- size (int): Girman jerin.\n    Mayarwa:\n    int: Jimillar lambobin da ke daidai a cikin jerin shigarwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hi": "दिए गए सूची में सम संख्या का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न्स:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hu": "Számítsa ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatér:\n    int: A bemeneti listában található páros számok összege.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9743012013017062",
      "bn": "0.9836934388689409",
      "bg": "0.9764827587766124",
      "zh": "0.9794056048335408",
      "fr": "1",
      "de": "0.9891321373320572",
      "ha": "0.9651999572426876",
      "hi": "0.9944018013409127",
      "hu": "0.9896801585533324"
    }
  },
  {
    "task_id": "C/11",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n​    Args:\n​    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n​    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n​    Argumentet:\n​    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n​    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n​    Kthen:\n​    int: 1 nëse intervalet ndërpriten, 0 përndryshe.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՊարզել՝ արդյոք երկու փակ միջակայքեր հատվում են:\n​    Արգումենտներ:\n​    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n​    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n​    Վերադարձնում է:\n​    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি বন্ধ ইন্টারভাল ছেদ করে কিনা নির্ধারণ করুন।\n​    আর্গুমেন্ট:\n​    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] প্রতিনিধিত্ব করছে যেখানে 0 <= a <= b <= 1000।\n​    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] প্রতিনিধিত্ব করছে যেখানে 0 <= c <= d <= 1000।\n​    রিটার্নস:\n​    int: ইন্টারভালগুলি ছেদ করলে 1, অন্যথায় 0।\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nОпределете дали два затворени интервала се пресичат.\n​    Аргументи:\n​    a, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n​    c, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n​    Връща:\n​    int: 1 ако интервалите се пресичат, 0 в противен случай.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n确定两个闭区间是否相交。\n    参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回:\n    int: 如果区间相交返回 1，否则返回 0。\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nDéterminer si deux intervalles fermés s'intersectent.\n​    Args:\n​    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n​    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n​    Retourne:\n​    int: 1 si les intervalles s'intersectent, 0 sinon.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n​    Argumente:\n​    a, b: Repräsentieren das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n​    c, d: Repräsentieren das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n​    Rückgabe:\n​    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nKayyade idan tazara biyu masu rufewa suna haduwa.\n​    Args:\n​    a, b: Wakiltar tazara na farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\n​    c, d: Wakiltar tazara na biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 idan tazarorin suna haduwa, 0 in ba haka ba.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nनिर्धारित करें कि क्या दो बंद अंतराल परस्पर हैं।\n​    तर्क:\n​    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहां 0 <= a <= b <= 1000।\n​    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहां 0 <= c <= d <= 1000।\n​    वापसी:\n​    int: 1 यदि अंतराल परस्पर हैं, अन्यथा 0।\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\n​    Args:\n​    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n​    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n​    Visszatérési érték:\n​    int: 1, ha az intervallumok metszik egymást, 0 különben.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9556188221830887",
      "hy": "0.9501835004364501",
      "bn": "0.9499199179208168",
      "bg": "0.9493285952764758",
      "zh": "0.9391809663701656",
      "fr": "0.999999801369619",
      "de": "0.9504887953321006",
      "ha": "0.9629085571670691",
      "hi": "0.9539396009418197",
      "hu": "0.9816237102985573"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nՏրամադրել C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।",
      "bg": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (докстринг) на български, използвайки не повече от 500 знака.",
      "zh": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9355907222329599",
      "hy": "0.9625347347899614",
      "bn": "0.9488008343540661",
      "bg": "0.8985000739215532",
      "zh": "0.8796399206119095",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n    Argumentet:\n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Երկու փակ միջակայքերի հատման որոշում։\n    Արձանագրումներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000։\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000։\n    Վերադարձնում է:\n    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։",
      "bn": "নির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n    আর্গুমেন্ট:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করে যেখানে 0 <= c <= d <= 1000।\n    Returns:\n    int: 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।",
      "bg": "Определете дали два затворени интервала се пресичат.\n    Аргументи:\n    a, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n    Връща:\n    int: 1 ако интервалите се пресичат, 0 в противен случай.",
      "zh": "确定两个闭区间是否相交。\n    参数：\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回：\n    int: 如果区间相交则返回 1，否则返回 0。",
      "fr": "Déterminer si deux intervalles fermés s'intersectent.\n    Args:\n    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Bestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n    Argumente:\n    a, b: Repräsentiert das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentiert das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Kayyade idan tsaka-tsakin rufe guda biyu suna haduwa.\n    Args:\n    a, b: Wakiltar farkon rufaffiyar tazara [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar tazara ta biyu rufaffiya [c, d] inda 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 idan tazarorin sun yi karo, 0 in ba haka ba.",
      "hi": "दो बंद अंतरालों के प्रतिच्छेदन का निर्धारण करें।\n    तर्क:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n    वापसी:\n    int: 1 यदि अंतराल प्रतिच्छेद करते हैं, अन्यथा 0।",
      "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\n    Args:\n    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, ha az intervallumok metszik egymást, különben 0."
    },
    "docstring_bertscore": {
      "sq": "0.9874467585489761",
      "hy": "0.9518551737232397",
      "bn": "0.976458128609364",
      "bg": "0.9748416745685021",
      "zh": "0.9414677979470202",
      "fr": "1",
      "de": "0.9720968013329809",
      "ha": "0.9874467585489761",
      "hi": "0.9537918199383298",
      "hu": "0.973343604234737"
    }
  },
  {
    "task_id": "C/12",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu janë dhënë tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nՁեզ տրված են երեք թվանշան a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է հենց մեկ անգամ։\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতোমাকে তিনটি অঙ্ক দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে আলাদা। যে মানটি ঠিক একবার ঘটে সেটি খুঁজে বের করো।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAn ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na ukun ya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआपको तीन अंक a, b, c दिए गए हैं। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nHárom számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "sq": "0.9905910774807584",
      "hy": "0.990247248291187",
      "bn": "0.9930719709398841",
      "bg": "0.9960977075341886",
      "zh": "0.9748498184141245",
      "fr": "0.9877607931813922",
      "de": "0.9858781744299436",
      "ha": "0.9780501511133587",
      "hi": "0.9733851179843732",
      "hu": "0.9873661146142759"
    },
    "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}",
    "instruction": {
      "en": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakter felhasználásával."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9132285166752901",
      "bn": "0.9097558617236572",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9500444591697256"
    },
    "level": "",
    "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "en": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n",
      "sq": "Ju jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që shfaqet saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hy": "Ձեզ տրված են երեք թվանշան՝ a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է հենց մեկ անգամ։\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "bn": "তোমাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে আলাদা। সেই মানটি খুঁজে বের কর যা ঠিক একবার ঘটে।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "bg": "Дадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "zh": "你有三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "fr": "Vous avez trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "de": "Du hast drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finde den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "ha": "An a ba ka lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku ya bambanta daga sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hi": "आपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hu": "Három számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9742471738380647",
      "hy": "0.9783234665176627",
      "bn": "0.9639666612068419",
      "bg": "0.9685967353887652",
      "zh": "0.9597054436425005",
      "fr": "0.9623063098517713",
      "de": "0.9681130704109453",
      "ha": "0.9368818197096866",
      "hi": "0.9572056802971765",
      "hu": "0.9718385818376356"
    }
  },
  {
    "task_id": "C/13",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (listë): Një listë që përmban rezultatet për secilën lëndë.\n    Kthen:\n    int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա։\n    Պարամետրեր:\n- subject_scores (ցանկ): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի համար ստացած միավորները։\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարումով։\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকজন ছাত্রের জন্য বিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে মোট স্কোর গণনা করুন।\n    প্যারামিটার:\n- subject_scores (list): প্রতিটি বিষয়ে স্কোর ধারণকারী একটি তালিকা।\n    রিটার্নস:\n    int: সব বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете общия резултат за ученик въз основа на резултатите в различни предмети.\n    Параметри:\n- subject_scores (списък): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算学生在不同科目中的总分。\n    参数:\n- subject_scores (list): 包含每个科目分数的列表。\n    返回:\n    int: 通过将所有科目的分数相加得到的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (liste): Une liste contenant les scores pour chaque matière.\n    Retourne:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabe:\n    int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erreicht wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige jimillar maki ga ɗalibi bisa la'akari da maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ƙunshe da maki don kowane fanni.\n    Komawa:\n    int: Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nविभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंक शामिल करने वाली एक सूची।\n    रिटर्न करता है:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल स्कोर।\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatér:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "sq": "0.9933059575287433",
      "hy": "0.9871774157522928",
      "bn": "0.9793994472917287",
      "bg": "0.9955246588849029",
      "zh": "0.9698034149535522",
      "fr": "0.9881230949963999",
      "de": "0.9930298612991048",
      "ha": "0.9865811273484261",
      "hi": "0.9706583201135263",
      "hu": "0.9860291335195301"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nՀամառոտ բնական լեզվով նկարագրություն (docstring) տրամադրեք C կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9031519974453902",
      "bn": "0.9125454267949111",
      "bg": "0.9075615919043648",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9413998663567062",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n",
      "sq": "Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (list): Një listë që përmban pikët për secilën lëndë.\n    Kthen:\n    int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n    Պարամետրեր:\n- subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները։\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորները գումարելով։\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "bn": "ছাত্রের মোট স্কোর বিভিন্ন বিষয়ে প্রাপ্ত স্কোরের ভিত্তিতে গণনা করুন।\n    Parameters:\n- subject_scores (list): প্রতিটি বিষয়ের স্কোর ধারণকারী একটি তালিকা।\n    Returns:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "bg": "Изчислете общия резултат за ученик въз основа на резултатите от различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите от всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "zh": "计算学生在不同科目中的总分。\n    参数：\n- subject_scores (list): 包含每个科目分数的列表。\n    返回：\n    int: 通过将所有科目的分数相加得到的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabewert:\n    int: Die Gesamtpunktzahl, die durch Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "ha": "Ƙididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki ga kowane fanni.\n    Dawowa:\n    int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hi": "छात्र के विभिन्न विषयों में प्राप्त अंकों के आधार पर कुल स्कोर की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंकों की सूची।\n    रिटर्न्स:\n    int: सभी विषयों के अंकों को जोड़कर प्राप्त कुल स्कोर।\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hu": "Számítsa ki a hallgató összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatérési érték:\n    int: Az összpontszám, amelyet az összes tantárgyban elért pontszámok összeadásával kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"
    },
    "docstring_bertscore": {
      "sq": "0.9888329999782186",
      "hy": "0.9822575398444396",
      "bn": "0.9757589496681212",
      "bg": "0.9849485842467003",
      "zh": "0.9534293194929412",
      "fr": "0.9761568063213341",
      "de": "0.9869529634217233",
      "ha": "0.9790840222466453",
      "hi": "0.9345677757706302",
      "hu": "0.9719170408381445"
    }
  },
  {
    "task_id": "C/14",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë secila shifër përfaqëson.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու համար օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ \nեն ներկայացնում յուրաքանչյուր թվանշան:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին:\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করার জন্য এবং প্রতিটি অঙ্ক আসলে কোন মানটি উপস্থাপন করে তা বোঝার জন্য।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিং এর সমীকরণের ডান দিকের মানের সাথে সংশ্লিষ্ট ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, \nкоито всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRetourne :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimomin da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani igiyar haruffa da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowane igiyar bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि \nप्रत्येक अंक वास्तव में क्या मान दर्शाता है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप होता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekódolja a számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy karakterlánc, amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "sq": "0.9859302155897748",
      "hy": "0.9460112692828122",
      "bn": "0.9743796603022149",
      "bg": "0.9910020437391196",
      "zh": "0.9587778397630676",
      "fr": "0.9834459454141714",
      "de": "0.9862218049891339",
      "ha": "0.9663059312042899",
      "hi": "0.9778940276338652",
      "hu": "0.981900799680101"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9625347347899614",
      "bn": "0.8746368185744028",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.8839080902395872",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n",
      "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që secila shifër përfaqëson.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);",
      "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան։\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարք ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);",
      "bn": "সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্নটি প্রকাশ করুন এবং প্রতিটি অঙ্ক আসলে কোন মানগুলি উপস্থাপন করে তা বোঝার চেষ্টা করুন।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য ১০০ অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডান দিকের সাথে সঙ্গতিপূর্ণ।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);",
      "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);",
      "zh": "解码一系列数字以揭示模式并理解每个数字实际代表的值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数:\n- data_str: 一个表示一系列数字的字符串。长度不超过100。\n\n返回:\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法:\nassert(decode_numbers(\"0000\") == 4);",
      "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres:\n- data_str: Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie:\nint: Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation:\nassert(decode_numbers(\"0000\") == 4);",
      "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);",
      "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowanne kirtani na bayanan da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);",
      "hi": "संख्या की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और प्रत्येक अंक का वास्तविक मान समझा जा सके।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);",
      "hu": "Dekódoljon egy számsorozatot, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "sq": "0.9767566700720595",
      "hy": "0.9624604470274544",
      "bn": "0.9639644762726506",
      "bg": "0.9881681840928949",
      "zh": "0.9730398983821347",
      "fr": "0.9809227436838852",
      "de": "0.9811537508170288",
      "ha": "0.9460190158676726",
      "hi": "0.9820672519394082",
      "hu": "0.9840938777171072"
    }
  },
  {
    "task_id": "C/15",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\nduke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվում է n քառակուսիների համար տարբեր գունավորման մեթոդների քանակը m գույներով,\nհաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ։\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը։\n- m (int): Գույների քանակը։\n    Վերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որը բավարարում է նշված պայմանները։ Արդյունքը մոդուլ 1000003։\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nn টি বর্গক্ষেত্র এবং m টি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nযেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nБрои броя на различните методи за оцветяване на n квадрата с m цвята,\nкато се има предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват указаните условия. Резултатът е по модул 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算使用 m 种颜色对 n 个方格进行不同着色的方法数，\n考虑到相邻方格以及首尾方格必须具有不同颜色的要求。\n    参数:\n- n (int): 方格的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的数量。结果取模 1000003。\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\nen tenant compte de l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\n    Argumente:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n    Rückgabe:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nYana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m,\nla'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'i na farko/na ƙarshe\ndole ne su kasance da launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Adadin hanyoyin canza launi daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamakon yana cikin modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nn वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की गिनती करता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\nरंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    लौटाता है:\n    int: निर्दिष्ट शर्तों को संतोषजनक बनाने वाले विभिन्न रंगने के तरीकों की गिनती। परिणाम 1000003 के माड्यूलो में है।\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nMegszámolja az n négyzet különböző színezési módszereinek számát m színnel,\nfigyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\nkülönböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9745363796728514",
      "hy": "0.9705850255029245",
      "bn": "0.9636125032374567",
      "bg": "0.9712238208083327",
      "zh": "0.9578260029771484",
      "fr": "0.9831617053389105",
      "de": "0.9784422474855216",
      "ha": "0.9655344508043503",
      "hi": "0.9626147828335185",
      "hu": "0.9774153284155711"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9625347347899614",
      "bn": "0.8818808685707451",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9160367530023614",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n",
      "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët fqinjë dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "hy": "Հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը:\n- m (int): Գույների քանակը:\n    Վերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները: Արդյունքը մոդուլո 1000003 է:\n    >>> count_coloring_methods(1,1)\n    1",
      "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1",
      "bg": "Брои броя на различните методи за оцветяване на n квадрата с m цвята, като се взема предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "zh": "计算使用 m 种颜色对 n 个方格进行不同着色的方法数量，考虑到相邻方格以及第一个/最后一个方格必须具有不同颜色的要求。\n    参数：\n- n (int): 方格的数量。\n- m (int): 颜色的数量。\n    返回：\n    int: 满足指定条件的不同着色方法的数量。结果取模 1000003。\n    >>> count_coloring_methods(1,1)\n    1",
      "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\nArgs:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\nReturns:\nint: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n>>> count_coloring_methods(1,1)\n1",
      "ha": "Yana ƙididdige yawan hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Adadin hanyoyin launuka daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamakon yana daidai da modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "hi": "विभिन्न रंगाई विधियों की संख्या की गणना करता है n वर्गों के लिए m रंगों के साथ, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    वापसी:\n    int: निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की संख्या। परिणाम 1000003 के मापांक में है।\n    >>> count_coloring_methods(1,1)\n    1",
      "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9683260021794147",
      "hy": "0.9519092011868812",
      "bn": "0.3504083388610293",
      "bg": "0.969290352679339",
      "zh": "0.944535644182104",
      "fr": "0.991431283992536",
      "de": "0.9840769941347193",
      "ha": "0.9788019671055757",
      "hi": "0.9591439155553149",
      "hu": "0.9717078830469147"
    }
  },
  {
    "task_id": "C/16",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n​    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n​    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ժամանակ հաջորդական գլուխներ չկան։\n​    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n​    Վերադարձնում է:\n​    unsigned long long: Վավեր հաջորդականությունների քանակը։\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকোনো পরপর হেড না থাকা n টসের বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\n    রিটার্নস:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБрой на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n​    Параметри:\n- n (int): Броят на хвърлянията на монета.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算在 n 次投掷中没有连续正面的有效投币序列的数量。\n​    参数:\n- n (int): 投币次数。\n​    返回:\n​    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n    Paramètres:\n- n (int): Le nombre de lancers de pièces.\n    Renvoie:\n    unsigned long long: Le nombre de séquences valides.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n​    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabe:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘirga adadin sahihan jerin jefa tsabar kudi ba tare da kanun kai a jere ba a cikin jefa tsabar kudi n.\n​    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n​    Komawa:\n​    unsigned long long: Adadin sahihan jerin.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nn उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n​    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n​    रिटर्न करता है:\n​    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg az érvényes pénzfeldobási sorozatok számát, ahol n dobásban nincs egymást követő fej.\n​    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatérési érték:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9705389432545244",
      "hy": "0.9640288325161059",
      "bn": "0.9631135437202971",
      "bg": "0.9683150775084577",
      "zh": "0.9677881111075722",
      "fr": "0.9761736899037221",
      "de": "0.9672899461119366",
      "ha": "0.9690150509712246",
      "hi": "0.9723198632508832",
      "hu": "0.9736985567256463"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nՏվեք C կոդի համառոտ բնութագիր (docstring) հայերեն՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar C cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9132285166752901",
      "bn": "0.8821972867677337",
      "bg": "0.9075615919043648",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.8610818841118199",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa kokërradhë kokash në n hedhje.\n    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hy": "Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկան հաջորդական գլուխներ:\n    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը.\n    Վերադարձնում է:\n    unsigned long long: Վավեր հաջորդականությունների քանակը:\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "bn": "n টি টসে কোনো পরপর হেড ছাড়াই বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    Parameters:\n- n (int): কয়েন টসের সংখ্যা।\n    Returns:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n    Параметри:\n- n (int): Броят на хвърлянията на монетата.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n    参数:\n- n (int): 硬币投掷的次数。\n    返回:\n    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "fr": "Compter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n    Paramètres:\n- n (int): Le nombre de lancers de pièces.\n    Renvoie:\n    unsigned long long: Le nombre de séquences valides.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabe:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "ha": "Ƙirga adadin sahihan jeri na jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n​    Komawa:\n​    unsigned long long: Adadin sahihan jeri.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hi": "n उछालों में कोई लगातार हेड्स नहीं होने वाले वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n​    रिटर्न्स:\n​    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n    Paraméterek:\n- n (int): A pénzfeldobások száma.\n    Visszatér:\n    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.961029513762479",
      "hy": "0.9401874265108693",
      "bn": "0.926276745035853",
      "bg": "0.9674341517685681",
      "zh": "0.9611814660039708",
      "fr": "0.9722998015823986",
      "de": "0.9722998015823986",
      "ha": "0.9525509759480049",
      "hi": "0.9431275534109477",
      "hu": "0.9650078816642269"
    }
  },
  {
    "task_id": "C/17",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n​    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n​    Returns:\n​    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n​    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n​    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n​    Kthen:\n​    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n​    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ:\n​    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n​    Վերադարձնում է:\n​    int: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը:\n​    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n    \n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n​    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n​    Връща:\n​    int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n​    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到非负整数的二进制表示中最长连续1的序列长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n​    Paramètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n​    Renvoie :\n​    int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n​    \n    Exemples :\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n​    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n​    Rückgabe:\n​    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n​    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary na lamba maras kyau.\n​    Sigogi:\n- n (unsigned long long): Lamba maras kyau (0 ≤ n ≤ 2^64 - 1).\n​    Dawowa:\n​    int: Tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n​    \n    Misalai:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकिसी गैर-ऋणात्मक पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न करता है:\n    int: दिए गए पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTaláld meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n​    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n​    Visszatérési érték:\n​    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n​    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "sq": "0.9634408865882427",
      "hy": "0.9525660718569635",
      "bn": "0.9766941015020335",
      "bg": "0.9743359616183873",
      "zh": "0.9767872591507388",
      "fr": "0.9811843398957082",
      "de": "0.9748859691434729",
      "ha": "0.9582482911672285",
      "hi": "0.9611377673201431",
      "hu": "0.9737503992550964"
    },
    "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}",
    "instruction": {
      "en": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\n请用最多500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nBa da kwatancin gajeren bayani (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8665056852963585",
      "bg": "0.8985000739215532",
      "zh": "0.8764584577988737",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9012141594480139",
      "hi": "0.9095919916593034",
      "hu": "0.9304201747842408"
    },
    "level": "",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n    Kthen:\n    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ։\n    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n    Վերադարձնում է:\n    int: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    Returns:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য।\n\n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "bg": "Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n    Връща:\n    int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "zh": "找到非负整数的二进制表示中最长连续1的序列的长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列的长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n    Paramètres:\n- n (unsigned long long): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n    Renvoie:\n    int: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n    \n    Exemples:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabewert:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n    Sigogi:\n- n (unsigned long long): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न्स:\n    int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे लगातार अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hu": "Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n    Visszatérési érték:\n    int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9670877403840432",
      "hy": "0.9899157341852398",
      "bn": "0.9978671069684474",
      "bg": "0.9889507877941722",
      "zh": "0.9937028210300509",
      "fr": "1",
      "de": "0.9793009266227354",
      "ha": "0.9880567524491343",
      "hi": "0.9978671069684474",
      "hu": "0.9842223915736368"
    }
  },
  {
    "task_id": "C/18",
    "prompt": {
      "en": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n​Parameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n​Returns:\n​char*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "sq": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\n​Parametrat:\n- word1 (char*): Fjala e parë që do të përdoret në ID.\n- word2 (char*): Fjala e dytë që do të përdoret në ID.\n​Kthen:\n​char*: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "hy": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nՍտեղծում է ID՝ երկու բառերը հատուկ կերպով համադրելով։\nՊարամետրեր:\n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում։\n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում։\nՎերադարձնում է:\nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ \n        տառը շրջելով և այն առաջին բառի հետ համադրելով։\nօր.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "bn": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nএকটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\n​প্যারামিটারসমূহ:\n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\n​ফেরত দেয়:\n​char*: দ্বিতীয় শব্দের প্রতিটি অন্য অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে \n        একত্রিত করে একটি অনন্য আইডি তৈরি করে।\nউদাহরণ:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "bg": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на \n       втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "zh": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n通过以特定方式组合两个单词来创建ID。\n参数:\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回:\nchar*: 一个神圣的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "fr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'ID.\n- word2 (char*): Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nchar*: Un ID divin formé en inversant chaque autre caractère du deuxième \n        mot et en le combinant avec le premier mot.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "de": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabe:\nchar*: Eine göttliche ID, die gebildet wird, indem jedes zweite Zeichen des \n        zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "ha": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\n​Sigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n​Yana dawowa:\n​char*: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu \n        da haɗa shi da kalma ta farko.\nmisali:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "hi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nविशिष्ट तरीके से दो शब्दों को मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।\nरिटर्न करता है:\n​char*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और \n        पहले शब्द के साथ मिलाकर बनाई जाती है।\nउदाहरण:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "hu": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nLétrehoz egy azonosítót két szó speciális módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.\n- word2 (char*): A második szó, amelyet az azonosítóban használunk.\nVisszatér:\nchar*: Egy isteni azonosító, amelyet a második szó minden második karakterének \n       megfordításával és az első szóval való kombinálásával hozunk létre.\npl.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)"
    },
    "prompt_bertscore": {
      "sq": "0.9790953441783642",
      "hy": "0.9500714729015464",
      "bn": "0.9498396712468786",
      "bg": "0.9662443557861691",
      "zh": "0.9262556902154633",
      "fr": "0.9712758619681637",
      "de": "0.9762277173673636",
      "ha": "0.9505599050085112",
      "hi": "0.9343858303416023",
      "hu": "0.9483189570496755"
    },
    "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}",
    "instruction": {
      "en": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nՏրամադրեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nনিচের C কোডটির একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8665056852963585",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.926846814229423",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "char* create_id(const char* word1, const char* word2)",
    "docstring": {
      "en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n",
      "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.  \nParametrat:  \n- word1 (char*): Fjala e parë që do të përdoret në ID.  \n- word2 (char*): Fjala e dytë që do të përdoret në ID.  \nKthen:  \nchar*: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.  \np.sh.:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համատեղելով։  \nՊարամետրեր:  \n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ նիշը շրջելով և այն առաջին բառի հետ համատեղելով։  \nօր.՝  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "bn": "একটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (char*): প্রথম শব্দ যা আইডিতে ব্যবহৃত হবে।\n- word2 (char*): দ্বিতীয় শব্দ যা আইডিতে ব্যবহৃত হবে।\nফেরত দেয়:\nchar*: একটি ঐশ্বরিক আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টে এবং প্রথম শব্দের সাথে একত্রিত করে গঠিত হয়।\nউদাহরণ:\n    >>> create_id(fish,cat)\n    ftiasch",
      "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествен ID, образуван чрез обръщане на всеки втори символ от втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "zh": "通过以特定方式组合两个单词来创建一个ID。\n参数：\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回：\nchar*: 一个神奇的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> create_id(fish,cat)\n    ftiasch",
      "fr": "Crée un identifiant en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'identifiant.\n- word2 (char*): Le deuxième mot à utiliser dans l'identifiant.\nRenvoie :\nchar*: Un identifiant divin formé en inversant chaque autre caractère du deuxième mot et en le combinant avec le premier mot.\nex. :\n    >>> create_id(fish,cat)\n    ftiasch",
      "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "ha": "Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu ta wata hanya ta musamman.\n\nSigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n\nDawowa:\nchar*: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu da haɗa shi da kalma ta farko.\n\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "hi": "दो शब्दों को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nमापदंड:  \n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।  \n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।  \nवापसी:  \nchar*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और इसे पहले शब्द के साथ जोड़कर बनाई जाती है।  \nउदाहरण:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "hu": "Létrehoz egy azonosítót két szó meghatározott módon történő kombinálásával.  \nParaméterek:  \n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.  \n- word2 (char*): A második szó, amelyet az azonosítóban használunk.  \nVisszatér:  \nchar*: Egy isteni azonosító, amely a második szó minden második karakterének megfordításával és az első szóval való kombinálásával jön létre.  \npélda:  \n    >>> create_id(fish,cat)  \n    ftiasch  "
    },
    "docstring_bertscore": {
      "sq": "0.990474878707853",
      "hy": "0.9775825751964026",
      "bn": "0.9462647216490128",
      "bg": "0.990474878707853",
      "zh": "0.938272431007312",
      "fr": "0.9557236990242751",
      "de": "0.9710228068627254",
      "ha": "0.965811341555513",
      "hi": "0.9574321189315562",
      "hu": "0.9389195687887236"
    }
  },
  {
    "task_id": "C/19",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել տարբեր փոխատեղման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n​    Պարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n​    Վերադարձնում է:\n​    int: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস পরিকল্পনার সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n    প্যারামিটার:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n    রিটার্ন:\n    int: বিভিন্ন বিন্যাস পরিকল্পনার মোট সংখ্যা।\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБройте броя на различните схеми на пермутации за двоичен низ с дължина n,\nкъдето броят на '1'-ците е m, а броят на '0'-ите е n - m.\n    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутации.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算长度为 n 的二进制字符串的不同排列方案数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n    参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n    返回：\n    int: 不同排列方案的总数量。\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n    Renvoie:\n    int: Le nombre total de différents schémas de permutation.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n    Rückgabe:\n    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n​    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n​    Yana dawowa:\n​    int: Jimillar adadin tsarin juyawa daban-daban.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nएक बाइनरी स्ट्रिंग की विभिन्न क्रमचय योजनाओं की संख्या गिनें जिसकी लंबाई n है,\nजहां '1's की संख्या m है और '0's की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n    रिटर्न करता है:\n    int: विभिन्न क्रमचय योजनाओं की कुल संख्या।\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\nahol az '1'-ek száma m, és a '0'-k száma n - m.\n    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n    Visszatérési érték:\n    int: A különböző permutációs sémák teljes száma.\n*/\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9826263964620214",
      "hy": "0.9769125949211719",
      "bn": "0.9699361000480835",
      "bg": "0.9856433933195603",
      "zh": "0.9660810816129584",
      "fr": "0.9774044037446142",
      "de": "0.9852387832333923",
      "ha": "0.9673072269550868",
      "hi": "0.975694990685428",
      "hu": "0.9784362885740905"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "en": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9132285166752901",
      "bn": "0.8665056852963585",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9524868183349307",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametra:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր տեղաբաշխման սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m:\n​    Պարամետրեր:\n- n (int): Երկբանական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբանական տողի մեջ։\n​    Վերադարձնում է:\n​    int: Տարբեր տեղաբաշխման սխեմաների ընդհանուր քանակը։",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nParameters:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nReturns:\nint: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n    Параметри:\n- n (int): Дължина на двоичната низ.\n- m (int): Брой на '1'-ците в двоичната низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\nint: 不同排列方案的总数量。",
      "fr": "Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n    Renvoie:\n    int: Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m.  \n​    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n​    Rückgabe:\n​    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m da adadin '0's shine n - m. \n    Parameters:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n    Returns:\n    int: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n    रिटर्न्स:\n    int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n    Visszatér:\n    int: A különböző permutációs sémák összesített száma."
    },
    "docstring_bertscore": {
      "sq": "0.9790013920081347",
      "hy": "0.9456914743693461",
      "bn": "0.9482442720264064",
      "bg": "0.9828051638049529",
      "zh": "0.9338366173380408",
      "fr": "0.9679571455618329",
      "de": "0.9828051638049529",
      "ha": "0.9790013920081347",
      "hi": "0.9790013920081347",
      "hu": "0.9704928610061243"
    }
  },
  {
    "task_id": "C/20",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Answer a series of questions by providing choices A, B, C, or D for each question.\n​    Question 1:\n​    Constants like 1e6 belong to which data type?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n​        A. int\n​        B. long long\n​        C. double\n​        D. None of the above\n​    Question 3:\n​    Which statement about left values in expressions is incorrect?\n​        A. Variable name expressions are left values.\n​        B. Increment operation requires the operand to be a left value.\n​        C. Pointer dereference expressions are left values.\n​        D. Prefix increment operation expressions are left values.\n​    Question 4:\n​    Which statement about functions is incorrect?\n​        A. Formal parameters of a function are local variables.\n​        B. Local variables are allocated space in the stack.\n​        C. The function type is the same as the return value type.\n​        D. A function can call itself from within its body.\n​    Question 5:\n​    Which statement about pointers is incorrect?\n​        A. Subtracting two pointers equals the difference in their address values.\n​        B. Pointer dereference involves resolving based on the pointer's type.\n​        C. int *p[4], p is an array of int pointers.\n​        D. Function names can be assigned to function pointers.\n\t>>> answer_questions()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* answer_questions()",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Përgjigju një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje.\n​    Pyetja 1:\n​    Konstantet si 1e6 i përkasin cilit lloj të dhënash?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pyetja 2:\n​    Duke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Asnjë nga të mësipërmet\n​    Pyetja 3:\n​    Cila deklaratë në lidhje me vlerat e majta në shprehje është e pasaktë?\n​        A. Shprehjet e emrave të variablave janë vlera të majta.\n​        B. Operacioni i inkrementimit kërkon që operand të jetë një vlerë e majtë.\n​        C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n​        D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n​    Pyetja 4:\n​    Cila deklaratë në lidhje me funksionet është e pasaktë?\n​        A. Parametrat formalë të një funksioni janë variabla lokale.\n​        B. Variablat lokale kanë hapësirë të caktuar në stack.\n​        C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n​        D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n​    Pyetja 5:\n​    Cila deklaratë në lidhje me treguesit është e pasaktë?\n​        A. Zbritja e dy treguesve është e barabartë me ndryshimin në vlerat e adresave të tyre.\n​        B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n​        C. int *p[4], p është një varg treguesish int.\n​        D. Emrat e funksioneve mund të caktohen në tregues të funksioneve.\n\t>>> answer_questions()\n\tAAAAA\nTi supozohet të kthesh vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n*/\nconst char* answer_questions()",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\n​    Հարց 1:\n​    Նման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Հարց 2:\n​    Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Վերը նշվածներից ոչ մեկը\n​    Հարց 3:\n​    Ո՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n​        A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n​        B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n​        C. Ցուցիչի դերհղման արտահայտությունները ձախ արժեքներ են:\n​        D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n​    Հարց 4:\n​    Ո՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n​        A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n​        B. Տեղական փոփոխականների համար տարածքը հատկացվում է ստեկում:\n​        C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n​        D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n​    Հարց 5:\n​    Ո՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n​        A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n​        B. Ցուցիչի դերհղումը ներառում է լուծում՝ հիմնված ցուցիչի տիպի վրա:\n​        C. int *p[4], p-ն int ցուցիչների զանգված է:\n​        D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\t>>> answer_questions()\n\tAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\"-ն, որոնք ներկայացնում են հարցի ընտրանքները:\n*/\nconst char* answer_questions()",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    প্রতিটি প্রশ্নের জন্য A, B, C, বা D পছন্দ প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n​    প্রশ্ন ১:\n​    1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    প্রশ্ন ২:\n​    প্রদত্ত 21! = 51,090,942,171,709,440,000, কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n​        A. int\n​        B. long long\n​        C. double\n​        D. উপরোক্ত কোনোটিই নয়\n​    প্রশ্ন ৩:\n​    এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n​        A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n​        B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n​        C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n​        D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n​    প্রশ্ন ৪:\n​    ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n​        A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n​        B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n​        C. ফাংশনের টাইপ এবং রিটার্ন মানের টাইপ একই।\n​        D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n​    প্রশ্ন ৫:\n​    পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n​        A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n​        B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n​        C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n​        D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\t>>> answer_questions()\n\tAAAAA\nআপনার শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।\n*/\nconst char* answer_questions()",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n​    Въпрос 1:\n​    Константи като 1e6 принадлежат към кой тип данни?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Въпрос 2:\n​    Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Нито едно от горните\n​    Въпрос 3:\n​    Кое твърдение за левите стойности в изразите е неправилно?\n​        A. Изразите с имена на променливи са леви стойности.\n​        B. Операцията за инкрементиране изисква операндът да е лява стойност.\n​        C. Изразите за разименование на указатели са леви стойности.\n​        D. Изразите за префиксно инкрементиране са леви стойности.\n​    Въпрос 4:\n​    Кое твърдение за функциите е неправилно?\n​        A. Формалните параметри на функцията са локални променливи.\n​        B. Локалните променливи се разпределят в стека.\n​        C. Типът на функцията е същият като типа на стойността на връщане.\n​        D. Функцията може да извика себе си от тялото си.\n​    Въпрос 5:\n​    Кое твърдение за указателите е неправилно?\n​        A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n​        B. Разименованието на указател включва разрешаване на базата на типа на указателя.\n​        C. int *p[4], p е масив от указатели към int.\n​        D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\t>>> answer_questions()\n\tAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n*/\nconst char* answer_questions()",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    通过为每个问题提供选择A、B、C或D来回答一系列问题。\n​    问题1：\n​    常量如1e6属于哪种数据类型？\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    问题2：\n​    给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n​        A. int\n​        B. long long\n​        C. double\n​        D. 以上都不是\n​    问题3：\n​    关于表达式中的左值，哪种说法是不正确的？\n​        A. 变量名表达式是左值。\n​        B. 增量操作要求操作数是左值。\n​        C. 指针解引用表达式是左值。\n​        D. 前缀增量操作表达式是左值。\n​    问题4：\n​    关于函数，哪种说法是不正确的？\n​        A. 函数的形式参数是局部变量。\n​        B. 局部变量在栈中分配空间。\n​        C. 函数类型与返回值类型相同。\n​        D. 函数可以在其主体内调用自身。\n​    问题5：\n​    关于指针，哪种说法是不正确的？\n​        A. 减去两个指针等于它们地址值的差。\n​        B. 指针解引用涉及根据指针的类型进行解析。\n​        C. int *p[4]，p是一个int指针数组。\n​        D. 函数名可以赋值给函数指针。\n\t>>> answer_questions()\n\tAAAAA\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。\n*/\nconst char* answer_questions()",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Répondez à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n​    Question 1:\n​    Les constantes comme 1e6 appartiennent à quel type de données ?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Aucun des précédents\n​    Question 3:\n​    Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n​        A. Les expressions de nom de variable sont des valeurs à gauche.\n​        B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n​        C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n​        D. Les expressions d'opération d'incrément préfixé sont des valeurs à gauche.\n​    Question 4:\n​    Quelle affirmation concernant les fonctions est incorrecte ?\n​        A. Les paramètres formels d'une fonction sont des variables locales.\n​        B. Les variables locales sont allouées dans la pile.\n​        C. Le type de la fonction est le même que le type de la valeur de retour.\n​        D. Une fonction peut s'appeler elle-même à l'intérieur de son corps.\n​    Question 5:\n​    Quelle affirmation concernant les pointeurs est incorrecte ?\n​        A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n​        B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n​        C. int *p[4], p est un tableau de pointeurs int.\n​        D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\t>>> answer_questions()\n\tAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n*/\nconst char* answer_questions()",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n​    Frage 1:\n​    Konstanten wie 1e6 gehören zu welchem Datentyp?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Frage 2:\n​    Gegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Keine der oben genannten\n​    Frage 3:\n​    Welche Aussage über linke Werte in Ausdrücken ist falsch?\n​        A. Variablennamenausdrücke sind linke Werte.\n​        B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n​        C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n​        D. Präfix-Inkrement-Ausdrucksoperationen sind linke Werte.\n​    Frage 4:\n​    Welche Aussage über Funktionen ist falsch?\n​        A. Formale Parameter einer Funktion sind lokale Variablen.\n​        B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n​        C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n​        D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n​    Frage 5:\n​    Welche Aussage über Zeiger ist falsch?\n​        A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n​        B. Die Zeiger-Dereferenzierung beinhaltet das Auflösen basierend auf dem Typ des Zeigers.\n​        C. int *p[4], p ist ein Array von int-Zeigern.\n​        D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\t>>> answer_questions()\n\tAAAAA\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n*/\nconst char* answer_questions()",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n​    Tambaya ta 1:\n​    Kwatankwacin kamar 1e6 suna cikin wane nau'in bayanai?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Tambaya ta 2:\n​    An ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Babu ɗaya daga cikin waɗannan\n​    Tambaya ta 3:\n​    Wane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n​        A. Maganganun sunayen masu canji ƙimar hagu ne.\n​        B. Aikin ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n​        C. Maganganun cire alamar mai nuna suna ƙimar hagu ne.\n​        D. Maganganun aikin ƙara na farko ƙimar hagu ne.\n​    Tambaya ta 4:\n​    Wane bayani game da ayyuka ba daidai ba ne?\n​        A. Ma'auni na yau da kullun na aiki masu canji ne na gida.\n​        B. Ana ware sarari don masu canji na gida a cikin tsari.\n​        C. Nau'in aikin yana daidai da nau'in ƙimar dawowa.\n​        D. Aiki na iya kiran kansa daga cikin jikinsa.\n​    Tambaya ta 5:\n​    Wane bayani game da masu nuna ba daidai ba ne?\n​        A. Cire masu nuna biyu yana daidai da bambancin a cikin ƙimar adireshinsu.\n​        B. Cire alamar mai nuna yana da alaƙa da nau'in mai nuna.\n​        C. int *p[4], p tsari ne na masu nuna int.\n​        D. Ana iya ba da sunayen ayyuka ga masu nuna ayyuka.\n\t>>> answer_questions()\n\tAAAAA\nAna tsammanin ka dawo da kirtani iri ɗaya da \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.\n*/\nconst char* answer_questions()",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n​    प्रश्न 1:\n​    1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    प्रश्न 2:\n​    दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n​        A. int\n​        B. long long\n​        C. double\n​        D. उपरोक्त में से कोई नहीं\n​    प्रश्न 3:\n​    अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n​        A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n​        B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n​        C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n​        D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n​    प्रश्न 4:\n​    कार्यों के बारे में कौन सा कथन गलत है?\n​        A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n​        B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित किए जाते हैं।\n​        C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n​        D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n​    प्रश्न 5:\n​    पॉइंटर्स के बारे में कौन सा कथन गलत है?\n​        A. दो पॉइंटर्स को घटाने से उनके पते के मानों का अंतर मिलता है।\n​        B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n​        C. int *p[4], p इंट पॉइंटर्स की एक सरणी है।\n​        D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\t>>> answer_questions()\n\tAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n*/\nconst char* answer_questions()",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n​    1. kérdés:\n​    Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    2. kérdés:\n​    Adott 21! = 51,090,942,171,709,440,000, melyik adattípussal tárolható ez az érték?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Egyik sem a fentiek közül\n​    3. kérdés:\n​    Melyik állítás helytelen a baloldali értékekről a kifejezésekben?\n​        A. A változónév kifejezések baloldali értékek.\n​        B. Az inkrementáló művelet megköveteli, hogy az operandus baloldali érték legyen.\n​        C. A pointer dereferálás kifejezések baloldali értékek.\n​        D. A prefix inkrementáló művelet kifejezések baloldali értékek.\n​    4. kérdés:\n​    Melyik állítás helytelen a függvényekről?\n​        A. A függvény formális paraméterei lokális változók.\n​        B. A lokális változók a veremben kapnak helyet.\n​        C. A függvény típusa megegyezik a visszatérési érték típusával.\n​        D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n​    5. kérdés:\n​    Melyik állítás helytelen a pointerekről?\n​        A. Két pointer kivonása egyenlő a címértékeik különbségével.\n​        B. A pointer dereferálás a pointer típusának alapján történik.\n​        C. int *p[4], p egy int pointerek tömbje.\n​        D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\t>>> answer_questions()\n\tAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választásait jelentik.\n*/\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "sq": "0.9558524115111857",
      "hy": "0.9081487433107039",
      "bn": "0.9091615596236008",
      "bg": "0.9059207063266356",
      "zh": "0.9019755096985206",
      "fr": "0.9097614233743262",
      "de": "0.9140774629238333",
      "ha": "0.878481309599333",
      "hi": "0.9078748320152568",
      "hu": "0.8928816149636003"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nAdj meg egy tömör, legfeljebb 500 karakteres természetes nyelvű leírást (docstring) a C kódról magyarul."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9625347347899614",
      "bn": "0.9089325387942676",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.892806135418807",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg i treguesve int.\n    D. Emrat e funksioneve mund t'u caktohen treguesve të funksioneve.\n\n>>> answer_questions()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունը ձախ արժեքների վերաբերյալ արտահայտություններում սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահանել արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր հայտարարությունը ֆունկցիաների վերաբերյալ սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են կույտում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր հայտարարությունը ցուցիչների վերաբերյալ սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիաների անունները կարող են նշանակվել ֆունկցիայի ցուցիչներին:\n\n>>> answer_questions()\nAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "প্রশ্নগুলির একটি সিরিজের উত্তর দিন প্রতিটি প্রশ্নের জন্য পছন্দগুলি A, B, C, বা D প্রদান করে।\n\nপ্রশ্ন ১:\n1e6 এর মতো ধ্রুবকগুলি কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপটি এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের টাইপটি রিটার্ন ভ্যালু টাইপের সমান।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা জড়িত।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\n>>> answer_questions()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи се разпределят в стека.\n    C. Типът на функцията е същият като типа на върнатата стойност.\n    D. Функцията може да извика себе си от своето тяло.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\n>>> answer_questions()\nAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпроса.",
      "zh": "回答一系列问题，为每个问题提供选项 A、B、C 或 D。\n\n问题 1：\n像 1e6 这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题 3：\n关于表达式中的左值，哪种说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量运算要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量运算表达式是左值。\n\n问题 4：\n关于函数，哪种说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其内部调用自身。\n\n问题 5：\n关于指针，哪种说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4], p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n>>> answer_questions()\nAAAAA\n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选项。",
      "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\n>>> answer_questions()\nAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix des questions.",
      "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keiner der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeigerdereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementierungsoperationen sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeigerdereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\n>>> answer_questions()\nAAAAA\nDu sollst nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWace magana game da ƙimar hagu a cikin maganganu ba daidai ba ce?\n    A. Maganganun sunayen masu canji ƙimar hagu ne.\n    B. Aiki na ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cire alamar adireshi ƙimar hagu ne.\n    D. Maganganun aikin ƙara na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWace magana game da ayyuka ba daidai ba ce?\n    A. Sigogin aiki na aiki masu canji na gida ne.\n    B. Ana ware sarari don masu canji na gida a cikin faifai.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWace magana game da pointers ba daidai ba ce?\n    A. Ragewa pointers biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire alamar adireshi yana haɗawa da warwarewa bisa nau'in pointer.\n    C. int *p[4], p tsari ne na pointers int.\n    D. Ana iya sanya sunayen ayyuka ga pointers ayyuka.\n\n>>> answer_questions()\nAAAAA\nAna tsammanin ka dawo da igiyoyi makamantan \"AAAAA\", waɗanda suke wakiltar zaɓuɓɓukan tambayoyin.",
      "hi": "प्रश्नों की एक श्रृंखला का उत्तर A, B, C, या D विकल्प देकर दें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nकिस अभिव्यक्ति के बारे में बाएँ मानों के संबंध में कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nकिस कथन के बारे में कार्य गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो वापसी मूल्य प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से खुद को कॉल कर सकता है।\n\nप्रश्न 5:\nकिस कथन के बारे में पॉइंटर्स गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मूल्यों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\n>>> answer_questions()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának alapján történik.\n    C. int *p[4], p egy int pointerekből álló tömb.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\n>>> answer_questions()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdés választásait jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9564191039882783",
      "hy": "0.9353267424565646",
      "bn": "0.9484313818453413",
      "bg": "0.9380193759018735",
      "zh": "0.9442303492864534",
      "fr": "0.9526908117362535",
      "de": "0.9394588502732333",
      "ha": "0.9322678345886273",
      "hi": "0.9448756993944357",
      "hu": "0.9424071210189342"
    }
  },
  {
    "task_id": "C/21",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetyra është të përcaktohet nëse është e mundur të montohet katrorët prej druri nga n kovë,\nku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nHyrja: gjatësia e listës, vargu i numrave\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԽնդիրը որոշելն է՝ արդյոք հնարավոր է n դույլերից հավաքել փայտե քառակուսիներ,\nորտեղ յուրաքանչյուր դույլ պարունակում է $a_i$ քառակուսիներ՝ կողքի երկարությունը 1, մեկ մեծ քառակուսի մեջ:\nՄուտքագրում: ցուցակի երկարություն, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকাজটি হল n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা তা নির্ধারণ করা,\nযেখানে প্রতিটি বালতিতে ১ পার্শ্ব দৈর্ঘ্যের $a_i$ বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nЗадачата е да се определи дали е възможно да се сглобят дървените квадратчета от n кофи,\nкъдето всяка кофа съдържа $a_i$ квадратчета със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n任务是确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 $a_i$ 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表长度，数字数组\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDie Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern,\nwobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Array von Zahlen\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAikin shi ne tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowanne guga yana dauke da $a_i$ murabba'ai tare da tsawon gefe 1, zuwa cikin babban murabba'i guda.\nShigarwa: tsawon jerin, jerin lambobi\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nA feladat annak meghatározása, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani,\nahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: a lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])"
    },
    "prompt_bertscore": {
      "sq": "0.9638856200113798",
      "hy": "0.9687500780429241",
      "bn": "0.9665353492943851",
      "bg": "0.9903336525069372",
      "zh": "0.9726158225186251",
      "fr": "0.9939161500592824",
      "de": "0.9937645950785527",
      "ha": "0.9669596237882757",
      "hi": "0.9820787725015082",
      "hu": "0.9723774660613833"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}",
    "instruction": {
      "en": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nՏվեք C կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\n请为以下C代码提供一个简洁的中文自然语言描述（文档字符串），不超过500个字符。",
      "fr": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9251232984131834",
      "bn": "0.9231671864207518",
      "bg": "0.8985000739215532",
      "zh": "0.86688983645328",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9160367530023614",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "int Is_Square(int length, int squares[])",
    "docstring": {
      "en": "The task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n",
      "sq": "Detyra është të përcaktohet nëse është e mundur të montohen katrorët prej druri nga n kovë, ku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nHyrja: gjatësia e listës, vargu i numrave\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hy": "Առաջադրանքը որոշելն է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիներ n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է $a_i$ կողքի երկարությամբ 1 քառակուսի, մեկ ավելի մեծ քառակուսի մեջ:\nՄուտք: ցուցակի երկարությունը, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1",
      "bn": "কাজটি হল নির্ধারণ করা সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে $a_i$ সংখ্যা 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nInput: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1",
      "bg": "Задачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1",
      "zh": "任务是确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 $a_i$ 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表长度，数字数组\n    >>> Is_Square(1, (int[]){9})\n    1",
      "fr": "La tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> Is_Square(1, (int[]){9})\n    1",
      "de": "Die Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Zahlenarray\n    >>> Is_Square(1, (int[]){9})\n    1",
      "ha": "Manufar ita ce tantance ko yana yiwuwa a tara murabba'ai na katako daga kwanduna n, inda kowanne kwando ya ƙunshi $a_i$ murabba'ai tare da tsawon gefe 1, cikin babban murabba'i guda ɗaya.\nShigarwa: tsawon jerin, jerin lambobi\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hi": "कार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 है, एक बड़े वर्ग में।\n\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hu": "A feladat annak meghatározása, hogy lehetséges-e a fa négyzeteket n vödörből, ahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté összeállítani.\nBemenet: lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9844261863445786",
      "hy": "0.945281699893271",
      "bn": "0.9946101646106184",
      "bg": "0.9840332954508916",
      "zh": "0.9327922187945594",
      "fr": "0.9911482356995612",
      "de": "0.9874378201818296",
      "ha": "0.9403630157677041",
      "hi": "0.9587242095601881",
      "hu": "0.9685862079785703"
    }
  },
  {
    "task_id": "C/22",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, shfaqni grupin me vlerën më të vogël të a.\n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, արտածել խումբը ամենափոքր a-ով:\n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չկան,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তবে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    প্যারামিটার:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্ন:\n    Optional[int]: a এর একটি সম্ভাব্য মান। বৈধ মান বিদ্যমান না থাকলে -1 ফেরত দেয়,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个组合，输出 a 最小的组合。\n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的可能值。如果不存在有效值，则返回 -1。\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donnés les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il existe plusieurs groupes, afficher le groupe avec le plus petit a.\n    Paramètres :\n    - c (int) : La somme de a et b.\n    - d (int) : Le produit de a et b.\n\n    Renvoie :\n    Optional[int] : Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabe:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba lambobi c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar darajar a (a <= b). Idan akwai kungiyoyi da dama, fitar da kungiyar da ke da karamin a.\n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Returns:\n    Optional[int]: Yiwuwar darajar a. Yana dawowa -1 idan babu ingantattun ƙimomi,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभव मान खोजें और लौटाएँ (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभव मान। यदि मान्य मान मौजूद नहीं हैं, तो -1 लौटाता है।\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdottak a c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értéket (a <= b). Ha több csoport is van, adja vissza azt a csoportot, amelyikben a legkisebb az a.\n    Paraméterek:\n    - c (int): Az a és b összege.\n    - d (int): Az a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: Egy lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9717172186748233",
      "hy": "0.9458513718260791",
      "bn": "0.9887295135496994",
      "bg": "0.9883141774229555",
      "zh": "0.9496321024986972",
      "fr": "0.9909768176807281",
      "de": "0.9770738827905722",
      "ha": "0.9581114348346955",
      "hi": "0.9494322803353761",
      "hu": "0.9715074649924504"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9070022487513705",
      "bn": "0.8821972867677337",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n    \n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\n    >>> find_integers(7,11)\n    -1",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n    \n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չեն գոյություն ունենում,\n\n    >>> find_integers(7,11)\n    -1",
      "bn": "প্রদত্ত পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গোষ্ঠী থাকে, তাহলে সবচেয়ে ছোট a সহ গোষ্ঠীটি আউটপুট করুন।\n    \n    Parameters:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    Returns:\n    Optional[int]: a এর একটি সম্ভাব্য মান। বৈধ মান বিদ্যমান না থাকলে -1 ফেরত দেয়,\n\n    >>> find_integers(7,11)\n    -1",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности.\n\n    >>> find_integers(7,11)\n    -1",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找出并返回可能的 a 的值（a <= b）。如果有多个组合，输出 a 最小的组合。\n    \n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的可能值。如果不存在有效值，则返回 -1。\n\n    >>> find_integers(7,11)\n    -1",
      "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.\n    Paramètres:\n    - c (int): La somme de a et b.\n    - d (int): Le produit de a et b.\n\n    Renvoie:\n    Optional[int]: Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\n    >>> find_integers(7,11)\n    -1",
      "de": "Gegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    \n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabe:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren,\n\n    >>> find_integers(7,11)\n    -1",
      "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai rukuni da yawa, fitar da rukunin da ke da ƙaramin a.\n    \n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Komawa:\n    Optional[int]: Yiwuwar ƙimar a. Yana dawowa -1 idan ƙimomi masu inganci ba su wanzu,\n\n    >>> find_integers(7,11)\n    -1",
      "hi": "दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    \n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं तो -1 लौटाता है,\n\n    >>> find_integers(7,11)\n    -1",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értéket (a <= b). Ha több csoport is van, adja vissza azt a csoportot, ahol a a legkisebb.\n    Paraméterek:\n    - c (int): a és b összege.\n    - d (int): a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: a lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> find_integers(7,11)\n    -1"
    },
    "docstring_bertscore": {
      "sq": "0.9626958240289808",
      "hy": "0.9654055396870587",
      "bn": "0.9843405766503526",
      "bg": "0.9866953398175211",
      "zh": "0.9575934068009565",
      "fr": "0.9914882909118929",
      "de": "0.9826909513358578",
      "ha": "0.9772200747510138",
      "hi": "0.9772977392299985",
      "hu": "0.9697863327407832"
    }
  },
  {
    "task_id": "C/23",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nNumëron numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n    \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n    \nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n    \nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nՀաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n    \nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվային արգումենտների կամայական քանակ:\n    \nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n    \nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n    \nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি ইচ্ছামত সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n    \nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n    \nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nБрои броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n    \nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели числа, представляващи дължините на ръбовете.\n    \nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n    \nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n    \n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n    \n返回：\nint: 可以形成的不同锐角三角形的数量。\n    \n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCompter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n    \nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n    \nReturns:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n    \nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n    \nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n    \nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane gefuna 3 daga cikin wani saiti na gefuna da aka bayar.\n    \nArgs:\n- edges_count: Yawan gefuna da aka bayar.\n- Wani adadi na hujjojin lamba waɗanda ke wakiltar tsawon gefuna.\n    \nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n    \nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोणीय त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्र कोणीय त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nSzámolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n    \nArgumentumok:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész típusú argumentum, amelyek az élek hosszát képviselik.\n    \nVisszatérési érték:\nint: Az alkotható különböző hegyesszögű háromszögek száma.\n    \nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9699913192940112",
      "hy": "0.943846595390294",
      "bn": "0.9753513601262376",
      "bg": "0.9612523770500002",
      "zh": "0.9605637255189523",
      "fr": "0.9780837196477535",
      "de": "0.965543587801878",
      "ha": "0.9713153894139898",
      "hi": "0.9907279338132914",
      "hu": "0.9762026899393531"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "en": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nՏվեք C կոդի համառոտ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n请用中文为以下C代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9070022487513705",
      "bn": "0.9231671864207518",
      "bg": "0.9075615919043648",
      "zh": "0.8856772910434649",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9424089086923635"
    },
    "level": "",
    "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër i pacaktuar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hy": "Սուր անկյուններով եռանկյունների քանակը հաշվել, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողմեր տրված կողմերի հավաքածուից:\n\nԱրգումենտներ:\n- edges_count: Անցած կողմերի քանակը:\n- Կողմերի երկարությունները ներկայացնող ամբողջ թվային կամայական քանակի արգումենտներ:\n\nՎերադարձնում է:\nint: Սուր անկյուններով տարբեր եռանկյունների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bn": "তীক্ষ্ণ-কোণ বিশিষ্ট ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে গঠন করা যেতে পারে।\n\nআর্গস:\n- edges_count: প্রদত্ত প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি নির্বিচারে সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠন করা যেতে পারে এমন পৃথক তীক্ষ্ণ-কোণ বিশিষ্ট ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bg": "Бройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "zh": "计算可以通过从给定的一组边中选择任意3条边来形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArgs:\n- edges_count: Le nombre de côtés passés.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des côtés.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von Ganzzahlargumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "ha": "Count adadin kusurwoyi masu kaifi waɗanda za a iya ƙirƙira ta hanyar zaɓar kowane gefuna 3 daga cikin wani saitin gefuna da aka bayar.\n\nArgs:\n- edges_count: Adadin gefuna da aka wuce.\n- Yawan hujjojin lamba masu zaman kansu waɗanda ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi na musamman waɗanda za a iya ƙirƙira.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nरिटर्न्स:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek bármely 3 élének kiválasztásával képezhetők.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész számú argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az alkotható különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9453988918180817",
      "hy": "0.9194271749762459",
      "bn": "0.9805564692612568",
      "bg": "0.9407402148612893",
      "zh": "0.9346269676241786",
      "fr": "0.9504182815468333",
      "de": "0.9369509430822869",
      "ha": "0.9449297268580773",
      "hi": "0.9855001808148341",
      "hu": "0.9507547614123064"
    }
  },
  {
    "task_id": "C/24",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin të ndarë nga një presje.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով:\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը:\n- char_value (char): Մուտքային սիմվոլը:\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով:\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলোকে একটি কমা দ্বারা পৃথক করা ফরম্যাটেড স্ট্রিং হিসেবে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "de": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLiest eine ganze Zahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nKaranta lamba mai cikakken adadi da kuma harafi, sannan ya mayar da su a matsayin jeren haruffa da aka raba su da alamar kwalliya.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Harafin da aka shigar.\nDawowa:\n- char*: Jeren haruffa da ke dauke da lambar da harafin da aka raba su da alamar kwalliya.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होकर होते हैं।\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatér:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "sq": "0.9776526917209079",
      "hy": "0.9951069391935866",
      "bn": "0.9892036442692297",
      "bg": "0.9867934632257523",
      "zh": "0.9964220709464185",
      "fr": "0.997033653889625",
      "de": "0.981820950266925",
      "ha": "0.981684689825535",
      "hi": "0.9842221929432557",
      "hu": "0.9858932703389023"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "en": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nՏրամադրել C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 символа.",
      "zh": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar C a Hausa ta amfani da haruffa 500 kawai.",
      "hi": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9312144976779992",
      "bn": "0.8821972867677337",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n",
      "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin të ndarë me një presje.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով:\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n>>> process_integer_and_char(234,H)\n\t234,H",
      "bn": "একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\nপ্যারামিটারসমূহ:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n>>> process_integer_and_char(234,H)\n\t234,H",
      "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 包含用逗号分隔的整数和字符的字符串。\n>>> process_integer_and_char(234,H)\n\t234,H",
      "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "de": "Liest eine ganze Zahl und ein Zeichen ein und gibt sie als formatierten String, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\nRückgabewert:\n- char*: Ein String, der die ganze Zahl und das Zeichen durch ein Komma getrennt enthält.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alama ta koma.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Alamar da aka shigar.\nDawowa:\n- char*: Wani tsari na rubutu da ke dauke da lambar da alamar da aka raba su da alama ta koma.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hi": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \nपैरामीटर्स:  \n- integer_value (int): इनपुट पूर्णांक।  \n- char_value (char): इनपुट अक्षर।  \nरिटर्न्स:  \n- char*: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम द्वारा अलग किए गए हैं।  \n>>> process_integer_and_char(234,H)  \n\t234,H  ",
      "hu": "Egész számot és karaktert olvas be, majd visszaadja őket egy formázott, vesszővel elválasztott sztringként.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatér:\n- char*: Egy sztring, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> process_integer_and_char(234,H)\n\t234,H"
    },
    "docstring_bertscore": {
      "sq": "0.9723899797753884",
      "hy": "0.9917864351138264",
      "bn": "0.9866866000807556",
      "bg": "0.9917864351138264",
      "zh": "0.9801852290791027",
      "fr": "0.9958883511125778",
      "de": "0.9813043126458533",
      "ha": "0.9639233597837764",
      "hi": "0.9715720198662868",
      "hu": "0.9778342398891737"
    }
  },
  {
    "task_id": "C/25",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n​\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti hyrës që do të përpunohet.\n​\n​    Kthen:\n​    str: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի:\n​\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը՝ տառերը տեղափոխված 5 դիրքով:\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে 5 অবস্থান দ্বারা স্থানান্তরিত হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n​    রিটার্নস:\n​    str: পরিবর্তিত টেক্সট যা অক্ষরগুলি 5 অবস্থান দ্বারা স্থানান্তরিত হয়েছে।\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзмества всички символи с 5 позиции в азбучен ред. Само букви се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст, който ще бъде обработен.\n​\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n将所有字符在字母顺序中移动5个位置。只有字母被替换，且所有字母均为大写。\n​    参数:\n​    text (str): 要处理的输入文本。\n​\n​    返回:\n​    str: 字符移动5个位置后的转换文本。\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres :\n​    text (str) : Le texte d'entrée à traiter.\n​\n​    Renvoie :\n​    str : Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n​\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMatsar da dukkan haruffa ta wurin matsayi 5 a cikin tsari na haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigarwa da za a sarrafa.\n​\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da su ta wurin matsayi 5.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसभी अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n    पैरामीटर्स:\n    text (str): प्रोसेस किए जाने वाले इनपुट टेक्स्ट।\n\n    रिटर्न्स:\n    str: परिवर्तित टेक्स्ट जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n    >>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMinden karaktert 5 pozícióval eltol az ábécé sorrendjében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n​    Paraméterek:\n​    text (str): A feldolgozandó bemeneti szöveg.\n​\n​    Visszatér:\n​    str: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)"
    },
    "prompt_bertscore": {
      "sq": "0.9665162807778058",
      "hy": "0.9556817880138768",
      "bn": "0.9511961181189659",
      "bg": "0.9687979479647536",
      "zh": "0.9502653361534364",
      "fr": "0.9685363517529306",
      "de": "0.9703897718383672",
      "ha": "0.8338406274383873",
      "hi": "0.9555822741929783",
      "hu": "0.9619724121812517"
    },
    "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "en": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n提供一段中文描述（文档字符串），简要说明该C代码的功能，限制在500个字符以内。",
      "fr": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9350838175005589",
      "hy": "0.9312144976779992",
      "bn": "0.8880709857653164",
      "bg": "0.8985000739215532",
      "zh": "0.8455372691224106",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}",
    "entry_point": "shift_characters",
    "signature": "char* shift_characters(char* text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n",
      "sq": "Zhvendos të gjitha shkronjat me 5 pozicione në rendin alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti i hyrjes që do të përpunohet.\n\n​    Kthen:\n​    str: Teksti i transformuar me shkronja të zhvendosura me 5 pozicione.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hy": "Տեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով։ Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի։\n\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով։\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "bn": "বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তরিত করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n​    রিটার্নস:\n​    str: স্থানান্তরিত অক্ষর সহ পরিবর্তিত টেক্সট।\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "bg": "Изместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст, който ще бъде обработен.\n\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "zh": "将所有字符在字母表中向后移动5个位置。只有字母会被替换，且所有字母都为大写。\n\n参数:\ntext (str): 要处理的输入文本。\n\n返回:\nstr: 字符被移动5个位置后的转换文本。\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres:\n​    text (str): Le texte d'entrée à traiter.\n\n​    Renvoie:\n​    str: Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigarwa da za a sarrafa.\n\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da su zuwa matsayi 5.\n\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hi": "सभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nParameters:\ntext (str): इनपुट पाठ जिसे संसाधित किया जाना है।\n\nReturns:\nstr: परिवर्तित पाठ जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"
    },
    "docstring_bertscore": {
      "sq": "0.953633511524645",
      "hy": "0.9513299949957834",
      "bn": "0.9242999754837937",
      "bg": "0.9629890024713883",
      "zh": "0.9426993063094364",
      "fr": "0.9586342299975794",
      "de": "0.9719371025066289",
      "ha": "0.9719371025066289",
      "hi": "0.9482448679175496",
      "hu": "0.947029051355235"
    }
  },
  {
    "task_id": "C/26",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n​    Returns:\n​    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa klasa të përcaktohet.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n​    Kthen:\n​    int: Klasa në të cilën i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԴասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով.\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգման ենթակա ամբողջ թիվը:\n​    Վերադարձնում է:\n​    int: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটার:\n- x (char*): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n​    রিটার্নস:\n​    int: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което да бъде класифицирано.\n​    Връща:\n​    int: Класът, към който принадлежи цялото число x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n参数：\n- x (char*): 要分类的整数。\n    返回：\n    int: 整数 x 所属的类别。\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\nParamètres :\n- x (char*): L'entier à classer.\n    Renvoie :\n    int : La classe à laquelle appartient l'entier x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n​    Rückgabe:\n​    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x na cikin ajin sa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\nSigogi:\n- x (char*): Lambar da za a rarraba.\n​    Komawa:\n​    int: Aji da lambar x ke ciki.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि वर्ग निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वह पूर्णांक जिसे वर्गीकृत किया जाना है।\n    रिटर्न:\n    int: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nOsztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEllenkező esetben összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n    Visszatérési érték:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)"
    },
    "prompt_bertscore": {
      "sq": "0.9895597885424252",
      "hy": "0.9525015169831272",
      "bn": "0.9512233304811677",
      "bg": "0.988237307465495",
      "zh": "0.9543062726252102",
      "fr": "0.9742298929949147",
      "de": "0.982435909926609",
      "ha": "0.9540498408032941",
      "hi": "0.9787584670521291",
      "hu": "0.9802170099400682"
    },
    "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8821972867677337",
      "bg": "0.9075615919043648",
      "zh": "0.8856772910434649",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.9095919916593034",
      "hu": "0.9304201747842408"
    },
    "level": "",
    "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(char *x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme: Nëse x është një numër me një shifër, x i përket klasës së vet. Përndryshe, mbledh shifrat e x, merr një x të ri dhe përsërit deri sa të përcaktohet klasa. Parametrat: - x (char*): Numri i plotë që do të klasifikohet.\n\n    Kthen:\n    int: Klasa së cilës i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6",
      "hy": "Դասակարգեք ամբողջ թիվ x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի։  \nՊարամետրեր:  \n- x (char*): Դասակարգվող ամբողջ թիվը։  \n\n    Վերադարձնում է:  \n    int: Դասը, որին պատկանում է ամբողջ թիվը x։  \n\t>>> classify_integer(24)  \n\t6  ",
      "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটারসমূহ:\n- x (char*): শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\n    রিটার্নস:\n    int: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\t>>> classify_integer(24)\n\t6",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което ще бъде класифицирано.\n\n    Връща:\n    int: Класът, към който принадлежи цялото число x.\n\t>>> classify_integer(24)\n\t6",
      "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (char*): 要分类的整数。\n\n    返回：\n    int: 整数 x 所属的类。\n\t>>> classify_integer(24)\n\t6",
      "fr": "Classifiez l'entier x selon la méthode suivante:\nSi x est un nombre à un chiffre, x appartient à sa propre classe.  \nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.  \nParamètres :  \n- x (char*) : L'entier à classer.\n\n    Renvoie :  \n    int : La classe à laquelle appartient l'entier x.  \n\t>>> classify_integer(24)\n\t6",
      "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen den Vorgang, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n\n    Rückgabewert:\n    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6",
      "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗigo ɗaya, x yana cikin ajin kansa. In ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba da maimaitawa har sai an tantance ajin. Parameters: - x (char*): Lambar da za a tantance. Returns: int: Aji wanda lambar x take ciki. >>> classify_integer(24) 6",
      "hi": "पूर्णांक x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एक एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\nParameters:\n- x (char*): वर्गीकृत करने के लिए पूर्णांक।\n\n    Returns:\n    int: वह श्रेणी जिससे पूर्णांक x संबंधित है।\n\t>>> classify_integer(24)\n\t6",
      "hu": "Osztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n\n    Visszatér:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6"
    },
    "docstring_bertscore": {
      "sq": "0.9877304027330939",
      "hy": "0.9868284221728145",
      "bn": "0.942917998358956",
      "bg": "0.9982055731377308",
      "zh": "0.9535624018482345",
      "fr": "0.9818499503025561",
      "de": "0.9762064639165928",
      "ha": "0.9726708431341718",
      "hi": "0.9637682294561881",
      "hu": "0.9864162641321671"
    }
  },
  {
    "task_id": "C/27",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nTransformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՓոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): রূপান্তরিত হওয়ার জন্য ইনপুট অক্ষর।\n    রিটার্নস:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nПреобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n转换给定字母的大小写。\n    参数:\n- letter (char): 要转换的输入字母。\n    返回:\n- char: 大小写被反转的字母。如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nCanza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Komawa:\n- char: Harafin tare da yanayinsa da aka juya. Idan shigarwar tana cikin ƙananan baƙaƙe, yana dawowa da babba,\nkuma idan shigarwar tana cikin babba, yana dawowa da ƙananan baƙaƙe.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए अक्षर के मामले को बदलता है।\n    पैरामीटर:\n- letter (char): परिवर्तित होने वाला इनपुट अक्षर।\n    रिटर्न करता है:\n- char: अक्षर जिसका मामला उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nÁtalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű megfordított esettel. Ha a bemenet kisbetű, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetű, akkor a kisbetűs változatot adja vissza.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9703222375088153",
      "bn": "0.9688035096154225",
      "bg": "0.9914594895066429",
      "zh": "0.9623186249353956",
      "fr": "0.9875148887696711",
      "de": "0.9840559393143296",
      "ha": "0.949779287611044",
      "hi": "0.9866574014147435",
      "hu": "0.9942935477832487"
    },
    "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\n将以下 C 代码的功能用中文自然语言简洁描述（文档字符串），字数不超过 500 个字符。",
      "fr": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9438332871547647",
      "bn": "0.8821972867677337",
      "bg": "0.8985000739215532",
      "zh": "0.8309520388733997",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n",
      "sq": "Transformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> transform_letter_case('b')\n    'Z'",
      "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ հակառակ ռեգիստրով։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> transform_letter_case('b')\n    'Z'",
      "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n    Returns:\n- char: অক্ষরটি যার কেস উল্টানো হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n    >>> transform_letter_case('b')\n    'Z'",
      "bg": "Преобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'",
      "zh": "将给定字母的大小写转换。\n    参数:\n- letter (char): 要转换的输入字母。\n\n返回:\n- char: 大小写反转后的字母。如果输入为小写，则返回大写版本；如果输入为大写，则返回小写版本。\n\n    >>> transform_letter_case('b')\n    'Z'",
      "fr": "Transforme la casse d'une lettre donnée.\n    Paramètres:\n- letter (char): La lettre d'entrée à transformer.\n    Renvoie:\n- char: La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'",
      "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'",
      "ha": "Canza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Returns:\n- char: Harafin tare da canza yanayin rubutunsa. Idan shigarwar tana cikin ƙananan haruffa, zai dawo da babbar harafi,\nkuma idan shigarwar tana cikin babbar haruffa, zai dawo da ƙananan harafi.\n    >>> transform_letter_case('b')\n    'Z'",
      "hi": "दिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): परिवर्तित होने वाला इनपुट अक्षर।\n    रिटर्न्स:\n- char: अक्षर जिसके केस को उल्टा कर दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'",
      "hu": "Átalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű az esetével megfordítva. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n    >>> transform_letter_case('b')\n    'Z'"
    },
    "docstring_bertscore": {
      "sq": "0.9913603729465065",
      "hy": "0.9624962004960407",
      "bn": "0.9719742463878824",
      "bg": "0.9636822225012001",
      "zh": "0.9556462331756715",
      "fr": "0.9774038078534711",
      "de": "0.9476710247467397",
      "ha": "0.9580383388544746",
      "hi": "0.9758527032079697",
      "hu": "0.9966222903705018"
    }
  },
  {
    "task_id": "C/28",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n​    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n​    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nShfaq informacionin ASCII për një karakter të dhënë.\n​    Parametrat:\n- character (char): Karakteri i futur për të cilin informacioni ASCII do të shfaqet.\n​    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՑուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար։\n​    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n​    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n​    প্যারামিটার:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n​    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nПоказва ASCII информацията за даден символ.\n​    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информация.\n​    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n显示给定字符的ASCII信息。\n    参数:\n- character (char): 要显示ASCII信息的输入字符。\n    返回:\n- int: 对应的ASCII代码\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nAfficher les informations ASCII pour un caractère donné.\n​    Paramètres :\n- character (char) : Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n​    Renvoie :\n- int : code ASCII correspondant\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nZeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n​    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n​    Rückgabewert:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nNuna bayanin ASCII don wata alama da aka bayar.\n​    Sigogi:\n- character (char): Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n​    Komawa:\n- int: lambar ASCII da ta dace\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n​    पैरामीटर्स:\n- character (char): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n​    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nMegjeleníti a megadott karakter ASCII információit.\n​    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n​    Visszatérési érték:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{"
    },
    "prompt_bertscore": {
      "sq": "0.9691854758381526",
      "hy": "0.9665961301909818",
      "bn": "0.9596883614297315",
      "bg": "0.9416415995304257",
      "zh": "0.9445990072736542",
      "fr": "0.9696496750386312",
      "de": "0.9597922451190127",
      "ha": "0.9409706261032899",
      "hi": "0.9697495861202917",
      "hu": "0.9511134878804554"
    },
    "canonical_solution": "return character;\n}",
    "instruction": {
      "en": "int display_ascii_info(char character)\nreturn character;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int display_ascii_info(char character)\nreturn character;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int display_ascii_info(char character)\nreturn character;\n}\n\nՏվեք C կոդի հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int display_ascii_info(char character)\nreturn character;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "int display_ascii_info(char character)\nreturn character;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int display_ascii_info(char character)\nreturn character;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int display_ascii_info(char character)\nreturn character;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int display_ascii_info(char character)\nreturn character;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int display_ascii_info(char character)\nreturn character;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int display_ascii_info(char character)\nreturn character;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int display_ascii_info(char character)\nreturn character;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9132285166752901",
      "bn": "0.9125454267949111",
      "bg": "0.9079759348792036",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9304201747842408"
    },
    "level": "",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "en": "Display the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n",
      "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n    Parametra:\n- character (char): Karakteri i hyrjes për të cilin do të shfaqet informacioni ASCII.\n\n    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65",
      "hy": "Տպել տրված սիմվոլի ASCII տեղեկատվությունը։\n\n    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է տպել ASCII տեղեկատվությունը։\n\n    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65",
      "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\n    প্যারামিটারসমূহ:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\n    Returns:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65",
      "bg": "Показва ASCII информацията за даден символ.\n\n    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информацията.\n\n    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65",
      "zh": "显示给定字符的ASCII信息。\n\n    参数：\n- character (char): 要显示其ASCII信息的输入字符。\n\n    返回：\n- int: 对应的ASCII码\n    >>> display_ascii_info('A')\n    65",
      "fr": "Afficher les informations ASCII pour un caractère donné.\n\n    Paramètres:\n- character (char): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\n    Renvoie:\n- int: code ASCII correspondant\n    >>> display_ascii_info('A')\n    65",
      "de": "Zeige die ASCII-Informationen für ein gegebenes Zeichen an.\n\n    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\n    Rückgabewerte:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65",
      "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n    Sigogi:\n- character (char): Harafin shigarwa wanda za a nuna bayanin ASCII.\n\n    Dawowa:\n- int: lambar ASCII mai dacewa\n    >>> display_ascii_info('A')\n    65",
      "hi": "Display के लिए दिए गए वर्ण की ASCII जानकारी।\n\n    पैरामीटर्स:\n- character (char): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\n    Returns:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65",
      "hu": "Jelenítse meg egy adott karakter ASCII-információját.\n\n    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII-információját meg kell jeleníteni.\n\n    Visszatér:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65"
    },
    "docstring_bertscore": {
      "sq": "0.9730559874429985",
      "hy": "0.9500595550786842",
      "bn": "0.9618401243474825",
      "bg": "0.9721220273913724",
      "zh": "0.9588811275612057",
      "fr": "0.9807765517234435",
      "de": "0.9659450198019495",
      "ha": "0.9275434109757125",
      "hi": "0.9721156712191793",
      "hu": "0.9636186607792688"
    }
  },
  {
    "task_id": "C/29",
    "prompt": {
      "en": "#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n​​    char: The grade corresponding to the input score.\n​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n​​         Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "sq": "#include <assert.h> // Përdoret për të testuar funksionin me pohime\n#include <math.h> // Nuk nevojitet për këtë funksion\n#include <stdbool.h> // Nuk nevojitet për këtë funksion\n#include <stdio.h> // Nevojitet për funksionet e hyrje/dalje\n#include <string.h> // Nuk nevojitet për këtë funksion\n/*\nVlerëson notën për një numër të plotë hyrës.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n​​    char: Nota që korrespondon me notën hyrëse.\n​​         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n​​         Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "hy": "#include <assert.h> // Օգտագործվում է ֆունկցիան ստուգելու համար հաստատումներով\n#include <math.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdbool.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdio.h> // Անհրաժեշտ է մուտք/ելքի ֆունկցիաների համար\n#include <string.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n/*\nԳնահատել մուտքային ամբողջ թվի գնահատականը։\n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը։\n    Վերադարձնում է:\n​​    char: Մուտքային գնահատականին համապատասխան գնահատականը։\n​​         Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A'։\n​​         Հակառակ դեպքում, վերադարձնում է 'B'։\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "bn": "#include <assert.h> // ফাংশনটি পরীক্ষার জন্য assertions ব্যবহার করা হয়\n#include <math.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdbool.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdio.h> // ইনপুট/আউটপুট ফাংশনের জন্য প্রয়োজন\n#include <string.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n/*\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    প্যারামিটার:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    রিটার্ন:\n​​    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n​​         যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, 'A' রিটার্ন করে।\n​​         অন্যথায়, 'B' রিটার্ন করে।\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "bg": "#include <assert.h> // Използва се за тестване на функцията с твърдения\n#include <math.h> // Не е необходимо за тази функция\n#include <stdbool.h> // Не е необходимо за тази функция\n#include <stdio.h> // Необходимо за входно/изходни функции\n#include <string.h> // Не е необходимо за тази функция\n/*\nОценете оценката за входящо цяло число.\n    Параметри:\n- score (int): Целочислената оценка, която трябва да бъде оценена.\n    Връща:\n​​    char: Оценката, съответстваща на входящата оценка.\n​​         Ако оценката е между 90 и 100 (включително), връща 'A'.\n​​         В противен случай връща 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "zh": "#include <assert.h> // 用于使用断言测试函数\n#include <math.h> // 此函数不需要\n#include <stdbool.h> // 此函数不需要\n#include <stdio.h> // 需要用于输入/输出函数\n#include <string.h> // 此函数不需要\n/*\n评估输入整数的等级。\n    参数:\n- score (int): 要评估的整数分数。\n    返回:\n​​    char: 与输入分数对应的等级。\n​​         如果分数在90到100之间（包括90和100），返回 'A'。\n​​         否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "fr": "#include <assert.h> // Utilisé pour tester la fonction avec des assertions\n#include <math.h> // Pas nécessaire pour cette fonction\n#include <stdbool.h> // Pas nécessaire pour cette fonction\n#include <stdio.h> // Nécessaire pour les fonctions d'entrée/sortie\n#include <string.h> // Pas nécessaire pour cette fonction\n/*\nÉvaluer la note pour un entier en entrée.\n    Paramètres :\n- score (int) : Le score entier à évaluer.\n    Renvoie :\n​​    char : La note correspondant au score d'entrée.\n​​         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n​​         Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "de": "#include <assert.h> // Wird für das Testen der Funktion mit Assertions verwendet\n#include <math.h> // Nicht benötigt für diese Funktion\n#include <stdbool.h> // Nicht benötigt für diese Funktion\n#include <stdio.h> // Benötigt für Ein-/Ausgabefunktionen\n#include <string.h> // Nicht benötigt für diese Funktion\n/*\nBewertet die Note für eine Eingabe als Ganzzahl.\n    Parameter:\n- score (int): Die zu bewertende Ganzzahl.\n    Rückgabe:\n​​    char: Die Note, die der Eingabe entspricht.\n​​         Wenn der Score zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n​​         Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "ha": "#include <assert.h> // Ana amfani da wannan don gwada aikin tare da tabbaci\n#include <math.h> // Ba a bukata don wannan aikin\n#include <stdbool.h> // Ba a bukata don wannan aikin\n#include <stdio.h> // Ana bukata don ayyukan shigarwa/fitarwa\n#include <string.h> // Ba a bukata don wannan aikin\n/*\nKimanta darajar wani cikakken lamba.\n    Sigogi:\n- score (int): Cikakken lambar da za a kimanta.\n    Komawa:\n​​    char: Darajar da ta dace da cikakken lambar da aka shigar.\n​​         Idan lambar tana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n​​         In ba haka ba, zai dawo da 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "hi": "#include <assert.h> // assert के साथ फ़ंक्शन का परीक्षण करने के लिए उपयोग किया जाता है\n#include <math.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdbool.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdio.h> // इनपुट/आउटपुट फ़ंक्शंस के लिए आवश्यक है\n#include <string.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n/*\nएक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर्स:\n- score (int): पूर्णांक स्कोर जिसका मूल्यांकन किया जाना है।\n    रिटर्न्स:\n​​    char: इनपुट स्कोर के अनुरूप ग्रेड।\n​​         यदि स्कोर 90 और 100 के बीच (समावेशी) है, तो 'A' लौटाता है।\n​​         अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "hu": "#include <assert.h> // A függvény teszteléséhez használt állításokhoz\n#include <math.h> // Erre a függvényre nincs szükség\n#include <stdbool.h> // Erre a függvényre nincs szükség\n#include <stdio.h> // Szükséges a bemeneti/kimeneti függvényekhez\n#include <string.h> // Erre a függvényre nincs szükség\n/*\nÉrtékeli a bemeneti egész szám osztályzatát.\n    Paraméterek:\n- score (int): Az értékelendő egész szám pontszám.\n    Visszatér:\n​​    char: Az osztályzat, amely megfelel a bemeneti pontszámnak.\n​​         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n​​         Egyébként 'B'-t ad vissza.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "sq": "0.9695686338431689",
      "hy": "0.9678302207483516",
      "bn": "0.9435476566668365",
      "bg": "0.9656719030280265",
      "zh": "0.9447436101910476",
      "fr": "0.9637763733018105",
      "de": "0.9764384642016416",
      "ha": "0.9683387145238009",
      "hi": "0.9573119475510301",
      "hu": "0.9471571679510025"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "en": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nՏրամադրեք C կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n请用不超过500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.8999782812172148",
      "bn": "0.8863867987645215",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n",
      "sq": "Vlerësoni notën për një numër të plotë hyrës.\n    Parametrat:\n- score (int): Rezultati i plotë që do të vlerësohet.\n    Kthen:\n    char: Nota që korrespondon me rezultatin hyrës.\n    Nëse rezultati është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "hy": "Մուտքային ամբողջ թիվի գնահատականի գնահատում։  \n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը։\n    Վերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։  \n    Հակառակ դեպքում, վերադարձնում է 'B'։  \n>>> evaluate_integer_grade(90)\nA",
      "bn": "ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    Args:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    Returns:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তাহলে 'A' প্রদান করে।\n    অন্যথায়, 'B' প্রদান করে।\n>>> evaluate_integer_grade(90)\nA",
      "bg": "Оценете оценката за входящо цяло число.\n    Параметри:\n- score (int): Цялочислената оценка, която трябва да бъде оценена.\n    Връща:\n    char: Оценката, съответстваща на входящата оценка.\n    Ако оценката е между 90 и 100 (включително), връща 'A'.\n    В противен случай връща 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "zh": "评估输入整数的等级。\n    参数:\n- score (int): 要评估的整数分数。\n    返回:\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA",
      "fr": "Évaluer la note pour un entier en entrée.\n    Paramètres:\n- score (int): Le score entier à évaluer.\n    Renvoie:\n    char: La note correspondant au score d'entrée.\n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n    Parameter:\n- score (int): Die zu bewertende ganze Zahl.\n    Rückgabewerte:\n    char: Die Note, die dem eingegebenen Score entspricht.\n    Wenn der Score zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA",
      "ha": "Duba darajar don wani lamba mai shigarwa.\n    Sigogi:\n- score (int): Lambar maki da za a tantance.\n    Mayarwa:\n    char: Darajar da ta dace da maki da aka shigar.\n    Idan maki yana tsakanin 90 da 100 (ciki har da), yana mayar da 'A'.\n    In ba haka ba, yana mayar da 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    Returns:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA",
      "hu": "Értékeli a jegyet egy bemeneti egész számhoz.\n    Paraméterek:\n- score (int): Az értékelendő egész szám.\n    Visszatér:\n    char: A bemeneti pontszámnak megfelelő jegy.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Egyébként 'B'-t ad vissza.\n>>> evaluate_integer_grade(90)\nA"
    },
    "docstring_bertscore": {
      "sq": "0.9911822014947183",
      "hy": "0.9670569526749827",
      "bn": "0.9645377235523173",
      "bg": "0.9522051604546231",
      "zh": "0.9632215986475801",
      "fr": "0.9900380904999573",
      "de": "0.9603152389122777",
      "ha": "0.9703363402658688",
      "hi": "0.9687417355669207",
      "hu": "0.9929144570477235"
    }
  },
  {
    "task_id": "C/30",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n​\nArgs:\n    s (char array): The three-character string to be checked.\n​\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողում կա՞ն երկու նույնական նիշեր:\n​\nԱրձանագրություններ:\n    s (char զանգված): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n​\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքում կա երկու նույնական նիշ, հակառակ դեպքում՝ 'No':\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nআর্গুমেন্ট:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\n    str: 'Yes' ফেরত দেয় যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nПроверява дали низ от три знака има точно два еднакви знака.\n​\nАргументи:\n    s (масив от символи): Низът от три знака, който ще бъде проверен.\n​\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n检查一个三字符的字符串是否恰好有两个字符相同。\n\n参数:\n    s (char array): 要检查的三字符字符串。\n\n返回:\n    str: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n​\nArguments :\n    s (tableau de char) : La chaîne de trois caractères à vérifier.\n​\nRenvoie :\n    str : Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPrüft, ob ein drei Zeichen langer String genau zwei gleiche Zeichen hat.\n\nArgumente:\n    s (char array): Der drei Zeichen lange String, der überprüft werden soll.\n\nRückgabewerte:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, ansonsten 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n​\nArgs:\n    s (char array): Kirtani mai haruffa uku da za a duba.\n​\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu masu daidaito, in ba haka ba 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nजांचता है कि क्या तीन-अक्षर वाली स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षर वाली स्ट्रिंग जिसे जांचना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEllenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgumentumok:\n    s (karakter tömb): A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nVisszatér:\n    str: 'Yes'-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'-t.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "sq": "0.9609850205571273",
      "hy": "0.9320519233644423",
      "bn": "0.9576220095758256",
      "bg": "0.9454038575776075",
      "zh": "0.9523092427742854",
      "fr": "0.951811475039412",
      "de": "0.9555814796714541",
      "ha": "0.9671673911668381",
      "hi": "0.9448035965661201",
      "hu": "0.9567450564435566"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9464321670602251",
      "bn": "0.8843822209591174",
      "bg": "0.8985000739215532",
      "zh": "0.8856772910434649",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9207242313644037",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n",
      "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Po' nëse inputi ka saktësisht dy karaktere të barabartë, përndryshe 'Jo'.\n    >>> check_two_equal_digits(112)\n    Po",
      "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ ճիշտ երկու նույնական նիշ:\n\nԱրձագանքներ:\n    s (char array): Երեք նիշից բաղկացած տողը, որը պետք է ստուգվի:\n\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքագրումը ունի ճիշտ երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n    >>> check_two_equal_digits(112)\n    Yes",
      "bn": "তিন-অক্ষরের একটি স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা তা পরীক্ষা করে।\n\nআর্গস:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nরিটার্নস:\n    str: 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n    >>> check_two_equal_digits(112)\n    Yes",
      "bg": "Проверява дали низ от три знака има точно два еднакви знака.\n\nАргументи:\n    s (char array): Низът от три знака, който ще бъде проверен.\n\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n    s (char array): 要检查的三字符字符串。\n\n返回：\n    str: 如果输入恰好有两个相等的字符，则返回 'Yes'，否则返回 'No'。\n    >>> check_two_equal_digits(112)\n    Yes",
      "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n    s (char array): La chaîne de trois caractères à vérifier.\n\nReturns:\n    str: Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n",
      "de": "Überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgs:\n    s (char array): Der dreistellige String, der überprüft werden soll.\n\nReturns:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "ha": "Duba idan wani igiyar haruffa mai haruffa uku yana daidai da haruffa biyu waɗanda suke daidai.\n\nArgs:\n    s (char array): Igiyar haruffa mai haruffa uku da za a duba.\n\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana daidai da haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "hi": "तीन-अक्षरों की स्ट्रिंग में जाँच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n    >>> check_two_equal_digits(112)\n    Yes",
      "hu": "Ellenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgs:\n    s (char array): A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nReturns:\n    str: 'Yes' értéket ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'.\n    >>> check_two_equal_digits(112)\n    Yes"
    },
    "docstring_bertscore": {
      "sq": "0.9498855548648977",
      "hy": "0.9556365002870009",
      "bn": "0.9649939775375544",
      "bg": "0.934173494464276",
      "zh": "0.9378046564599748",
      "fr": "0.9488268549339818",
      "de": "0.963579530594205",
      "ha": "0.920452703633529",
      "hi": "0.9423679908338704",
      "hu": "0.9589589906705714"
    }
  },
  {
    "task_id": "C/31",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshëm për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՈւնենալով փոքրատառ անգլերեն տառերից բաղկացած տող, յուրաքանչյուր փուլում կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি স্ট্রিং দেওয়া আছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n例如：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba da wata ƙirtani mai ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirtanin ya ƙunshi harafi ɗaya iri ɗaya?\nMisali:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdott egy, kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc azonos karakterekből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "sq": "0.996510064205217",
      "hy": "0.9787970013460499",
      "bn": "0.9808468668783299",
      "bg": "1",
      "zh": "0.9952920627087111",
      "fr": "0.9887064724254994",
      "de": "0.9630519683021763",
      "ha": "0.9843799054657975",
      "hi": "0.9690343181181851",
      "hu": "0.9809537300233266"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "en": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n请用中文为以下 C 代码提供一个简洁的自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nBa da takaitaccen bayanin yanayi na dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nC कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रींग) हिंदी में 500 अक्षरों तक दें।",
      "hu": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9464321670602251",
      "bn": "0.8955724607354799",
      "bg": "0.8985000739215532",
      "zh": "0.8796399206119095",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9524868183349307",
      "hi": "0.9414401883240563",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ՝\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "bn": "একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি অক্ষরগুলোর মধ্যে একটি অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？\n\n例如：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "de": "Gegeben ein String, der aus Kleinbuchstaben des englischen Alphabets besteht, können Sie in jeder Runde eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu komponieren?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "ha": "An ba da wata ƙirari mai ƙunshe da ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirarin ta ƙunshi harafi ɗaya?\nMisali:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों से मिलकर बना है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9944657603236059",
      "hy": "0.9527047158629259",
      "bn": "0.9725282265205888",
      "bg": "0.9946149317397631",
      "zh": "0.9907366735500569",
      "fr": "0.9852753312235027",
      "de": "0.9674764600397284",
      "ha": "0.9398074465919496",
      "hi": "0.9563434258131039",
      "hu": "0.9810895932039545"
    }
  },
  {
    "task_id": "C/32",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, nën kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը կայանում է n-րդ իրադարձության տեղի ունենալու Y_n տարին գտնելու մեջ, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո տարում։\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন n-তম ঘটনা ঘটে, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর শুরু হতে পারে।\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато n-тото събитие се случва, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща след събитието i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个由 n 个事件组成的序列，每个事件以 a_i 年的周期发生，问题是找出第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生的下一年开始。\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement l'occurrence de l'événement i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten des Ereignisses i beginnen kann.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na shekaru a_i, matsalar ita ce nemo shekarar Y_n lokacin da abin n-nth ya faru, a ƙarƙashin yanayin cewa ƙidayar lokaci don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n घटनाओं की एक श्रृंखला में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद के वर्ष में ही शुरू हो सकती है।\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenként fordul elő, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődhet meg.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "sq": "0.9965642902992395",
      "hy": "0.9735495839398701",
      "bn": "0.9532473740639132",
      "bg": "0.9789143919012414",
      "zh": "0.9630553450186539",
      "fr": "0.9897842408729947",
      "de": "0.9855530164961894",
      "ha": "0.9678532618725516",
      "hi": "0.9752101339253219",
      "hu": "0.948236724071927"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "en": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nՏվեք C կոդի կարճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\n请用最多500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9355907222329599",
      "hy": "0.9070022487513705",
      "bn": "0.8720458838841837",
      "bg": "0.8985000739215532",
      "zh": "0.8764584577988737",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n",
      "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, այն պայմանով, որ իրադարձություն i+1-ի համար հետհաշվարկը կարող է սկսվել միայն իրադարձություն i-ի տեղի ունենալուց անմիջապես հետո։ \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "bn": "প্রদত্ত nটি ঘটনার একটি ক্রমে, প্রতিটি ঘটনা a_i বছর পরপর ঘটে, সমস্যাটি হল n-তম ঘটনা যে বছর Y_n-এ ঘটে তা খুঁজে বের করা, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরবর্তী বছরেই শুরু হতে পারে। \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината непосредствено след настъпването на събитие i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "zh": "给定一个由 n 个事件组成的序列，每个事件以 a_i 年的周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。",
      "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n où le n-ième événement se produit, à condition que le compte à rebours pour l'événement i+1 ne puisse commencer que l'année suivant immédiatement la survenue de l'événement i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "de": "Angenommen, es gibt eine Folge von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i beginnen kann.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce gano shekarar Y_n lokacin da abin n-th ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hi": "दिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है। \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hu": "Adott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenkénti periodicitással következik be, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36"
    },
    "docstring_bertscore": {
      "sq": "0.9912461604774114",
      "hy": "0.9580200648594195",
      "bn": "0.947820394793278",
      "bg": "0.9685609819201789",
      "zh": "0.8542311222699266",
      "fr": "0.9701387030367391",
      "de": "0.9660643966609515",
      "ha": "0.9442883493577156",
      "hi": "0.9742344614936784",
      "hu": "0.9558551923365203"
    }
  },
  {
    "task_id": "C/33",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x pjesëtuar me y. Përndryshe, ndani x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Pastaj rezultati është mbetja e x' pjesëtuar me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth, prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nԱյս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" նշանով: Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է: Հակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնակի, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, և վերջնական արժեքը նշանակեք որպես x': Ապա արդյունքը x'-ի y-ով բաժանման մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" প্রতীকে চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, ফলাফল হবে x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হবে x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া আছে, এবং কিছু প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া থাকবে, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nТози проблем въвежда нова операция на модуло, обозначена със символа \"⊕\". Когато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като обозначите крайната стойност като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко запитвания. За всяко запитване се дава цяло число n и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n这个问题引入了一种新的模运算，用符号“⊕”表示。计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，记最终值为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，将有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" bezeichnet wird. Beim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nWannan matsalar tana gabatar da wani sabon aiki na modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne saura na x raba y. In ba haka ba, raba x da y akai-akai har sai x ba shi ne sau na y ba, ana nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne saura na x' raba y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai lamba p, za a sami tambayoyi da yawa. Don kowace tambaya, an ba da lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobin da suka fi n ƙasa ko daidai da n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nयह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" प्रतीक द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान निकालना है, जहाँ n! n का फैक्टोरियल है, यानी n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és a végső értéket jelöljük x'-vel. Ekkor az eredmény x' maradéka y-nal osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítani n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes n-nél kisebb vagy egyenlő pozitív egész szám szorzata.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "sq": "0.9825191360562626",
      "hy": "0.9819530394703132",
      "bn": "0.9664316642354849",
      "bg": "0.9972384418124719",
      "zh": "0.972638069121301",
      "fr": "0.9919409695502714",
      "de": "0.9839274254578",
      "ha": "0.9804025307159548",
      "hi": "0.9655884782679919",
      "hu": "0.9715946637297248"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "en": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9132285166752901",
      "bn": "0.8720458838841837",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9207242313644037",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y. Përndryshe, ndani x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Atëherë rezultati është mbetja e x' e ndarë me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të thjeshtë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "hy": "Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" սիմվոլով: Երբ հաշվում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի բաժանումը y-ի մնացորդն է: Հակառակ դեպքում, բազմիցս բաժանում ենք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x': Ապա արդյունքը x'-ի բաժանումը y-ի մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> newModuloFactorial(3, 7)\n    6",
      "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে। অন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হল x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4। একটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর সমান বা তার চেয়ে ছোট সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bg": "Този проблем въвежда нова операция за модуло, обозначена със символа \"⊕\". При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като отбелязвате крайната стойност като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4. Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "zh": "这个问题引入了一种新的取模运算，用符号“⊕”表示。当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，将会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6",
      "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "de": "Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der endgültige Wert als x' bezeichnet wird. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen, die kleiner oder gleich n sind.\n    >>> newModuloFactorial(3, 7)\n    6",
      "ha": "Wannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba ya raba y ba tare da saura ba, sakamakon shine saura na x raba y. In ba haka ba, raba x da y akai-akai har sai x ba ya raba y ba tare da saura ba, ana nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shine saura na x' raba y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lambar farko p, za a sami tambayoyi da yawa. Domin kowace tambaya, an bayar da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobi masu kyau da suka fi ko daidai da n.\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hi": "यह समस्या एक नया माड्यूलो ऑपरेशन प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान गणना करना है, जहाँ n! n का फैक्टोरियल है, अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hu": "Ez a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y értéket számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva. Ellenkező esetben, osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként. Ekkor az eredmény x' maradéka y-nal osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes n-nél kisebb vagy egyenlő pozitív egész szám szorzata.\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9916547431712002",
      "hy": "0.9719784176258842",
      "bn": "0.9681821937835454",
      "bg": "0.9932495465005293",
      "zh": "0.9823181221106553",
      "fr": "0.9893645348778679",
      "de": "0.9804579485922635",
      "ha": "0.9501306647550948",
      "hi": "0.968612824449629",
      "hu": "0.964325586305372"
    }
  },
  {
    "task_id": "C/34",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի բոլոր տարրերը զանգվածում դառնան հավասար:\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতোমাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। তুমি সর্বাধিক একটি অপারেশন করতে পার যেখানে তুমি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন কর এবং a[i] থেকে a[j] পর্যন্ত সব উপাদানকে x দিয়ে প্রতিস্থাপন কর, যার খরচ (j - i + 1)।\nঅ্যারের সব উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের কর।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个由 n 个整数组成的数组 a。你可以执行最多一次操作，其中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] mit x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da akalla aiki ɗaya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको n पूर्णांकों की एक सरणी a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहां आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "sq": "0.9963783722625909",
      "hy": "0.9556400756338594",
      "bn": "0.9946330071044374",
      "bg": "0.9896708229254237",
      "zh": "0.9877089506519422",
      "fr": "0.9987156559562285",
      "de": "0.9879512797168047",
      "ha": "0.9737843650502533",
      "hi": "0.9873202309962569",
      "hu": "0.9762527447953739"
    },
    "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\n请用最多500个字符的中文，为以下C代码提供简明的自然语言描述（文档字符串）。",
      "fr": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8843822209591174",
      "bg": "0.8985000739215532",
      "zh": "0.8764584577988737",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hy": "Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը x-ով, արժեքով (j - i + 1): Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն:\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "zh": "你有一个由 n 个整数组成的数组 a。你最多可以执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "fr": "Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation ausführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1).\nFinde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "ha": "An ba ku wani tsari a na lamba n integers. Kuna iya aiwatar da mafi yawan aiki daya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1).\nNemo mafi ƙarancin kuɗi don sanya duk abubuwan a cikin tsari su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hi": "आपको n पूर्णांकों के एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hu": "Ön kap egy n egész számot tartalmazó tömböt, amelyet a-nak nevezünk. Legfeljebb egy műveletet hajthat végre, ahol kiválaszt három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-szel helyettesíti, (j - i + 1) költséggel. Találja meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9926167101065522",
      "hy": "0.9294081529928679",
      "bn": "0.9961175705722921",
      "bg": "0.9854370163536651",
      "zh": "0.9807535105992434",
      "fr": "0.9919121681450215",
      "de": "0.9884001843779435",
      "ha": "0.986199359756077",
      "hi": "0.9875502449774953",
      "hu": "0.9786575628185633"
    }
  },
  {
    "task_id": "C/35",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin me radhë duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo-bosh në grumbullin ngjitur në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni se kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով քարերի N կույտերից բաղկացած հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են քարերի դրական քանակություն ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ։ Խաղացողը, որը կարող է միայն քարեր տեղափոխել վերջին կույտում, պարտվում է։ Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը։\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না হওয়া স্তূপ থেকে ডান পাশের সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরায়। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে, সে হেরে যায়। ধরে নেওয়া হয় যে উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни. Определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个从1到N编号的N堆石头序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的赢家。Charlie先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils prennent à tour de rôle un nombre positif de pierres du tas le plus à gauche non vide pour les déplacer vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie wechseln sich ab, indem sie eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowace tarin dauke da adadin duwatsu masu kyau, tantance wanda zai ci wasa da Charlie da Dan suka buga. Charlie ne zai fara, kuma suna juyawa suna motsa adadin duwatsu masu kyau daga tarin da ba komai a hagu zuwa tarin da ke makwabta a dama. Dan wasan da zai iya motsa duwatsu a cikin tarin karshe kadai zai rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci wasan.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\n1 से N तक क्रमांकित पत्थरों के N ढेरों की एक श्रृंखला दी गई है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, यह पता लगाएं कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy N halomból álló kőhalom sorozat, amelyeket 1-től N-ig számoztak, és mindegyik halom pozitív számú követ tartalmaz. Határozd meg, ki nyeri a játékot, amelyet Charlie és Dan játszanak. Charlie kezd, és felváltva mozgatnak pozitív számú követ a bal szélső nem üres halomból a szomszédos jobb halomba. Az a játékos veszít, aki csak az utolsó halomban tud követ mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki, ki fogja megnyerni a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])"
    },
    "prompt_bertscore": {
      "sq": "0.9653439642689379",
      "hy": "0.9806245994819518",
      "bn": "0.9546596360730712",
      "bg": "0.9821143273397135",
      "zh": "0.9548789240137338",
      "fr": "0.9859915923775145",
      "de": "0.9843276656755853",
      "ha": "0.9334385620544469",
      "hi": "0.9834624317357973",
      "hu": "0.9702888676048014"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9625347347899614",
      "bn": "0.8955724607354799",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.8498020620336106",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, int piles[])",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni se kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hy": "Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է դրական քանակությամբ քարեր: Պարզել խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են դրական քանակությամբ քարեր ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Խաղացողը, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզել, թե ով կհաղթի խաղը:\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "bn": "একটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যেগুলি 1 থেকে N পর্যন্ত নম্বরযুক্ত, এবং প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে। চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম পূর্ণ স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর স্থানান্তর করে। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর স্থানান্তর করতে পারে, সে হেরে যায়। উভয় খেলোয়াড়ই সেরা সম্ভাব্য কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват възможно най-добрата стратегия, разберете кой ще спечели играта.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每个石堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流从最左边的非空石堆中移动一个正数的石头到相邻的右侧石堆。只能在最后一个石堆中移动石头的玩家输掉游戏。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, die von 1 bis N nummeriert sind, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin dauke da adadin duwatsu masu kyau, a tantance wanda zai ci wasa da Charlie da Dan suka yi. Charlie ne zai fara, kuma suna jujjuya motsa adadin duwatsu masu kyau daga tarin da ba komai a hagu zuwa tarin da ke makwabta a dama. Dan wasan da kawai zai iya motsa duwatsu a cikin tarin karshe zai rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci wasan.\n\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hi": "N पत्थरों के ढेरों के अनुक्रम को दिया गया है, जिन्हें 1 से N तक क्रमांकित किया गया है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है। चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सर्वोत्तम संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztunk, és mindegyik halom pozitív számú követ tartalmaz. Határozd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki, ki nyeri meg a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.9862579557184823",
      "hy": "0.9756240796393986",
      "bn": "0.9264324712545843",
      "bg": "0.9873124844113965",
      "zh": "0.9682401938548076",
      "fr": "0.9801288180508888",
      "de": "0.9476128260450966",
      "ha": "0.9157817115931126",
      "hi": "0.9430498889319631",
      "hu": "0.9639124351128194"
    }
  },
  {
    "task_id": "C/36",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է n դռներ, որոնք դասավորված են շրջանի մեջ, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլում խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այդ դիրքում դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշելու բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে সরতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে হয়। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nসমস্ত দরজা খুলতে প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 扇门排列成一个圆圈，玩家从门1前面开始。每一回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum requis pour ouvrir toutes les portes.\n\nExemple:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben sind n Türen, die in einem Kreis angeordnet sind. Der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shine a tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofin.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n दरवाजे एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} के लिए 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत कितनी होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ajtót azon a helyen. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat meghatározni a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)"
    },
    "prompt_bertscore": {
      "sq": "0.997489311983719",
      "hy": "0.9701333400164511",
      "bn": "0.9599346631022148",
      "bg": "0.9866043671030071",
      "zh": "0.9875923546182747",
      "fr": "0.9718566572023098",
      "de": "0.9766337178661989",
      "ha": "0.9852916189147476",
      "hi": "0.968675393019655",
      "hu": "0.9767916290191216"
    },
    "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}",
    "instruction": {
      "en": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9464321670602251",
      "bn": "0.8843822209591174",
      "bg": "0.9075615919043648",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, int *C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hy": "Տրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այն դիրքի դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1-এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত করা হয়েছে যে C_i >= C_{i+1} যেখানে 1 <= i < n। কাজটি হল সমস্ত দরজা খুলতে প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "zh": "给定 n 个门按圆形排列，玩家从门 1 前开始。每一回合，玩家可以选择一个数字 i 并支付一个费用 C_i 向右移动 i 步，然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总费用。\n\n示例：\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "ha": "An ba ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasa na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wancan matsayi. Ana tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne a tantance mafi ƙarancin jimillar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n। कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1. ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9859810649673196",
      "hy": "0.9724231510490213",
      "bn": "0.9611965619129295",
      "bg": "0.9973691406031929",
      "zh": "0.9803024210039133",
      "fr": "0.9951814255864746",
      "de": "0.9954769875934546",
      "ha": "0.9791660565940127",
      "hi": "0.9550841091973428",
      "hu": "0.9698145382548901"
    }
  },
  {
    "task_id": "C/37",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të shkojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով դասարան մուտք գործող ուսանողների ID-ների հաջորդականություն, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ձեռքսեղմումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի արդեն դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, ում ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մուտք գործելու կարգը։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nশ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত রয়েছে, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от идентификатори на ученици, влизащи в класната стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък идентификатор. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个学生ID进入教室的序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n例子:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence d'ID d'étudiants entrant dans une salle de classe, où les ID vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der stattfindenden Händedrücke. Jeder Student wird jedem Studenten, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin lambar ID ɗalibai da ke shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, ƙididdige jimlar yawan musabaha da ke faruwa. Kowanne ɗalibi zai yi musabaha da kowanne ɗalibi da ke cikin aji wanda ke da lambar ID ƙasa da shi. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nछात्र आईडी की एक अनुक्रमणा दी गई है जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें जो होती है। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनकी आईडी संख्या उससे छोटी है। अनुक्रमणा उस क्रम का प्रतिनिधित्व करती है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy osztályterembe belépő diákok azonosítóinak sorozata, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden már a teremben lévő diákkal, akinek kisebb az azonosítója. A sorozat azt az sorrendet jelenti, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])"
    },
    "prompt_bertscore": {
      "sq": "0.9758270798888162",
      "hy": "0.9809346615067472",
      "bn": "0.9563241586661436",
      "bg": "0.9778296713904099",
      "zh": "0.989119623618052",
      "fr": "0.9973476885220411",
      "de": "0.9847217483515585",
      "ha": "0.9412060031048162",
      "hi": "0.9296949752630823",
      "hu": "0.9846780496677308"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nՏվեք C կոդի համառոտ բնութագրությունը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nনিচে দেওয়া C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9132285166752901",
      "bn": "0.8602812050458682",
      "bg": "0.9075615919043648",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, int order[])",
    "docstring": {
      "en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n",
      "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hy": "Տրված է ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվարկել ընդհանուր ձեռքսեղմումների քանակը, որոնք տեղի են ունենում։ Յուրաքանչյուր ուսանող ձեռք կսեղմի արդեն իսկ դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, որի ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մտնելու կարգը։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "bn": "শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র তার থেকে ছোট আইডি নম্বর সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "bg": "Дадена е последователност от студентски идентификационни номера, които влизат в класната стая, където идентификационните номера варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък идентификационен номер. Последователността представлява реда, по който студентите влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中已经存在的ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n示例：\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n",
      "de": "Gegeben ist eine Sequenz von Schüler-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Schüler wird mit jedem Schüler, der sich bereits im Klassenzimmer befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler das Klassenzimmer betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "ha": "An ba da jerin lambobin dalibai da ke shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai yi gaisuwar hannu da kowane dalibi da ke a cikin aji wanda ke da ƙaramin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hi": "छात्र आईडी के अनुक्रम को ध्यान में रखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से छोटे आईडी नंबर के साथ कक्षा में हैं। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hu": "Adott egy tanulói azonosítók sorozata, akik belépnek egy tanterembe, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden már a tanteremben lévő diákkal, akinek kisebb az azonosító száma. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek a tanterembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9763447106617931",
      "hy": "0.9832177191063622",
      "bn": "0.9460132555866225",
      "bg": "0.9806448597808174",
      "zh": "0.9863278736126065",
      "fr": "0.9964894066455894",
      "de": "1",
      "ha": "0.9250035242934194",
      "hi": "0.9857633660697054",
      "hu": "0.9750383186457267"
    }
  },
  {
    "task_id": "C/38",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër\nelementet më të shpeshta në një sekuencë.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների \nհամար, որոնք կազմված են այս թվերից: Մոդան հաջորդականության ամենահաճախ հանդիպող \nտարրերի մեջ ամենամեծ թիվն է:\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է:\n*/\nlong long maxModeSum(int n, const int* counts)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা প্রতিনিধিত্বকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে,\nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক \nযোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n*/\nlong long maxModeSum(int n, const int* counts)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, съставена от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是序列中最频繁元素中最大的数字。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    达到其最大值的序列是 (3,2,3,1,2,2)。\n*/\nlong long maxModeSum(int n, const int* counts)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\ntrouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une\nséquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\nles éléments les plus fréquents dans une séquence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahlentyps von 1 bis n darstellen. \nFinde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, \ndie aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den \nhäufigsten Elementen in einer Sequenz.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (abu mafi yawan faruwa) don dukkanin farkon\njerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin\nmafi yawan abubuwa a cikin jerin.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nइन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें।\nमोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुंचता है वह है (3,2,3,1,2,2)।\n*/\nlong long maxModeSum(int n, const int* counts)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét a\nezekből a számokból felépített sorozat minden prefixére. A módusz a legnagyobb szám a\nsorozat leggyakoribb elemei között.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "sq": "0.9943326779683126",
      "hy": "0.9672700830738332",
      "bn": "0.9810184835275441",
      "bg": "0.9854151670117512",
      "zh": "0.9478440318086211",
      "fr": "0.999999801369619",
      "de": "0.9788826110402759",
      "ha": "0.9728474255429118",
      "hi": "0.9453450629848212",
      "hu": "0.9596120873634141"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9464321670602251",
      "bn": "0.8821972867677337",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e çdo numri nga 1 deri në n, \ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e \nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար \nայդ թվերից կազմված հաջորդականության։ Մոդան ամենամեծ թիվն է հաջորդականության \nամենահաճախ հանդիպող տարրերի մեջ։\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։",
      "bn": "প্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা প্রতিনিধিত্বকারী nটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, \nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    达到最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. La mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Gegeben sind n positive ganze Zahlen, die die Anzahl jedes einzelnen Wertes von 1 bis n darstellen. \nFinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).",
      "ha": "An bayar da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, \nnemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkan farkon jerin \nda aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin \nabin da aka fi samu a cikin jerin.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Wani jerin da ya kai matsakaicin ƙimar sa shine (3,2,3,1,2,2).",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) के अधिकतम योग को खोजें जो इन संख्याओं से निर्मित होता है। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát képviselik. \nTalálja meg a maximális összegét a módusznak (leggyakrabban előforduló elem) az összes prefixre \negy ezekből a számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "sq": "0.9930397928181565",
      "hy": "0.9660771090053376",
      "bn": "0.9729721654222018",
      "bg": "0.9892151648313298",
      "zh": "0.9744726193205393",
      "fr": "0.9999996027392379",
      "de": "0.9999996027392379",
      "ha": "0.9999996027392379",
      "hi": "0.9710704781541737",
      "hu": "0.9486735122798228"
    }
  },
  {
    "task_id": "C/39",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg është i përcaktuar nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma e XOR-it të një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ամբողջ թվերի A զանգվածը, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се определя от двойка индекси (L, R), такива че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n子数组的异或和是从L到R的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例：\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemples de cas :\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani tsari A na lambobin cikakke, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan tsaruka.\nAna ayyana ƙaramin tsari ta hanyar ma'aurata na alamomin (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\nJimillar XOR na ƙaramin tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n\nMisalan shari'o'i:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उपसरणियों के XOR का योग गणना करना है।\nएक उपसरणी को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n सरणी का आकार है।\nएक उपसरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उपसरणियों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az eredmény, amelyet az L-től R-ig terjedő összes elem XOR-olásával kapunk.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9964896052759704",
      "hy": "0.979446919952796",
      "bn": "0.9816991898433506",
      "bg": "0.9931216285351429",
      "zh": "0.9641480107447268",
      "fr": "0.991671030862445",
      "de": "0.9931216285351429",
      "ha": "0.9791974401942162",
      "hi": "0.979139638753335",
      "hu": "0.9771688281127069"
    },
    "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}",
    "instruction": {
      "en": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8843822209591174",
      "bg": "0.9075615919043648",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9524868183349307",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(int A[], int n)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L deri në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR-ի գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "zh": "给定一个整数数组 A，任务是计算所有子数组的异或和之和。  \n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。  \n子数组的异或和是从 L 到 R 的所有元素的异或结果。  \n最终结果是所有可能子数组的异或和之和。\n\n示例案例：\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen. Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist. Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R. Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "ha": "An ba da jerin A na lambobin cikakke, aikin shi ne lissafin jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) ta yadda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar jimillan XOR don dukkan yiwuwar ƙananan jerin.\n\nMisalan lamura:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hi": "दिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-समुच्चयों के XOR का योग गणना करना है। एक उप-समुच्चय को (L, R) सूचकांकों की एक जोड़ी द्वारा परिभाषित किया जाता है, जिससे 1 <= L <= R <= n, जहाँ n array का आकार है। एक उप-समुच्चय का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। अंतिम परिणाम सभी संभव उप-समुच्चयों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "sq": "0.9923926550367448",
      "hy": "0.991300585201815",
      "bn": "0.9712512318009154",
      "bg": "0.9839786720961069",
      "zh": "0.96299317370939",
      "fr": "0.9907644818034018",
      "de": "0.9924031824469397",
      "ha": "0.9669065894765394",
      "hi": "0.9895492611322304",
      "hu": "0.971083587759322"
    }
  },
  {
    "task_id": "C/40",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b আকারে প্রকাশ করা যায় এবং a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.\nРазличните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，使得 x 可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n同一个数字的不同合法表示只计数一次。\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nÉtant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nLes différentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nAn ba lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nAna ƙidaya wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nदो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nKét pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "sq": "0.9920033394899165",
      "hy": "0.9789183645088622",
      "bn": "0.9653250943827396",
      "bg": "0.999999801369619",
      "zh": "0.9639428255611178",
      "fr": "0.999999801369619",
      "de": "0.9863290653948927",
      "ha": "0.999999801369619",
      "hi": "0.9863290653948927",
      "hu": "0.9666205617278492"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "en": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9388852057328045",
      "hy": "0.9177245153500149",
      "bn": "0.8955724607354799",
      "bg": "0.8985000739215532",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9400299126187086",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme ligjore të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hy": "Տրված երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "给定两个正整数 n 和 k，找到多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示仅计算一次。\n    >>> countPowerNumbers(99, 1)\n    99",
      "fr": "Étant donnés deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nDifférentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "An ba lambobi biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su da x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Két pozitív egész szám, n és k esetén, találja meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző jogszerű ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9813478126992998",
      "bn": "0.960448917158714",
      "bg": "0.9865372300342173",
      "zh": "0.9583978598441478",
      "fr": "1",
      "de": "0.9813478126992998",
      "ha": "0.9708690669478043",
      "hi": "0.9676341725622701",
      "hu": "0.9514432143129733"
    }
  },
  {
    "task_id": "C/41",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՈւնենալով երեք ամբողջ թիվ n, m և k, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредица да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定三个整数 n, m 和 k，找到由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模计算。\n\n例如:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné trois entiers n, m, et k, trouvez le nombre de séquences consistant en n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba lambobi guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon subsequence mai daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott három egész szám: n, m és k. Meg kell találni azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "0.9922812233929842",
      "hy": "0.9847906730937775",
      "bn": "0.97012162082397",
      "bg": "0.9864802231148604",
      "zh": "0.9789056521644759",
      "fr": "0.9976088874731021",
      "de": "0.9820505669874013",
      "ha": "0.9566781180051478",
      "hi": "0.9813416551574877",
      "hu": "0.9500104933745687"
    },
    "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n请用中文为以下C代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9251232984131834",
      "bn": "0.8821972867677337",
      "bg": "0.9075615919043648",
      "zh": "0.8796399206119095",
      "fr": "0.9627375364089981",
      "de": "0.9224505280059779",
      "ha": "0.9212462320057634",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënpasuesi më i gjatë i balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n '(' এবং m ')' নিয়ে গঠিত এমন কতগুলি সিকোয়েন্স আছে তা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长平衡子序列的长度为 2 * k。结果应取模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Étant donné trois entiers n, m et k, trouvez le nombre de séquences constituées de n '(' et m ')', de telle sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1,000,000,007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "An ba integers guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin lambobi masu daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9996007529341199",
      "hy": "0.9643160520470824",
      "bn": "0.9495365612854194",
      "bg": "0.9849038924109674",
      "zh": "0.9623327276924489",
      "fr": "0.9964647764783411",
      "de": "0.9841463161377004",
      "ha": "0.9838465828927188",
      "hi": "0.9620182957992708",
      "hu": "0.9605236021819832"
    }
  },
  {
    "task_id": "C/42",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ kartezian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m),\nduhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\nNë secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության դեկարտյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում,\nպետք է հաշվարկել սպասվող գործողությունների քանակը, որպեսզի կտրենք թուղթը այնպես, որ մնացած մակերեսը լինի փոքր քան k:\nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը): Թղթի այս գծի երկայնքով ներքևի կամ աջ հատվածը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি আয়তাকার কাগজের টুকরো যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, \nতোমাকে অপারেশনগুলোর প্রত্যাশিত সংখ্যা গণনা করতে হবে যাতে কাগজের অবশিষ্ট এলাকা k এর চেয়ে কম হয়। \nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সাথে সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ পয়েন্টগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m),\nтрябва да изчислите очаквания брой операции за изрязване на хартията така, че останалата площ да е по-малка от k.\nПри всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модуло 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，\n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触碰边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésien plan avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m),\nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k.\nÀ chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (non pas juste touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors éliminée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m).\nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist.\nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur die Kante berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba takarda rectangle mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian na jirgin sama tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m),\nkana buƙatar lissafin adadin ayyukan da ake tsammani don yanke takardar don haka yankin da ya rage ya zama ƙasa da k.\nA kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए एक आयताकार कागज का आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर (0,0) और ऊपरी-दाईं कोने पर (n,m) है। \nआपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। \nप्रत्येक ऑपरेशन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के अलावा)। इस रेखा के साथ कागज के निचले या दाएँ भाग को फिर हटा दिया जाता है।\nउत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n x m méretű téglalap alakú papír, amely a síkbeli Descartes-koordináta-rendszerben helyezkedik el úgy, hogy az alsó-bal sarka a (0,0) pontban van, a jobb-felső sarka pedig az (n,m) pontban,\nki kell számítania a várt műveletek számát, hogy a papír maradék területe kisebb legyen, mint k.\nMinden művelet során véletlenszerűen választanak egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét elvetik.\nA válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "0.9662141639682518",
      "hy": "0.96347107840616",
      "bn": "0.9569232278953448",
      "bg": "0.9475182779837239",
      "zh": "0.9597668204302403",
      "fr": "0.9673765489580679",
      "de": "0.9624610429185975",
      "ha": "0.9634978935075996",
      "hi": "0.9435905608291401",
      "hu": "0.9501751579604466"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (докстринг) на български, използвайки не повече от 500 знака.",
      "zh": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9464321670602251",
      "bn": "0.8955724607354799",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9207242313644037",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n",
      "sq": "Duke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritshëm të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hy": "Տրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթ Cartesian համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \nանհրաժեշտ է հաշվել գործողությունների սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի փոքր k-ից։ \nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը)։ Գծի երկայնքով թղթի ներքևի կամ աջ մասը ապա հեռացվում է։\nՊատասխանը պետք է լինի 10^9+7 մոդուլով։\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "bn": "একটি আয়তাকার কাগজের আকার n x m একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, \nআপনাকে কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট ক্ষেত্রফল k এর চেয়ে কম হয়। \nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ করে না)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 দ্বারা মডুলো হতে হবে।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m), трябва да изчислите очаквания брой операции за рязане на хартията така, че останалата площ да е по-малка от k. \nПри всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，\n您需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n在每次操作中，随机选择一条与坐标轴平行的线，该线通过具有整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应为模 10^9+7。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. \nÀ chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupe (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3",
      "de": "Gegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nBeispiel:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "ha": "An ba takarda mai siffar rectangle mai girman n x m wanda aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \nkana buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya kasance ƙasa da k. \nA kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hi": "दी गई एक आयताकार कागज की शीट का आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने का स्थान (0,0) और ऊपरी-दाईं कोने का स्थान (n,m) है। \nआपको यह गणना करनी है कि कागज को काटने के लिए अपेक्षित संचालन की संख्या कितनी होगी ताकि शेष क्षेत्रफल k से कम हो जाए। \nप्रत्येक संचालन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज के निचले या दाईं हिस्से को फिर त्याग दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hu": "Adott egy n x m méretű téglalap alakú papír, amely a derékszögű koordináta-rendszer síkján helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. \nKi kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk fel, hogy a megmaradó terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobjuk.\nA válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9540766559047339",
      "hy": "0.9226420076932955",
      "bn": "0.9594035254633275",
      "bg": "0.9421347987665354",
      "zh": "0.9427749844846108",
      "fr": "0.9559213362534048",
      "de": "0.9972477774403806",
      "ha": "0.9244457701834734",
      "hi": "0.9281746583266414",
      "hu": "0.9249973667516073"
    }
  },
  {
    "task_id": "C/43",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sq": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (domethënë, zgjidhni $ k-1 $ pika ndarëse $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hy": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nՏրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն բաժանելով հենց k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bn": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা ঠিক k টি non-empty contiguous segment এ p কে ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যেতে পারে (অর্থাৎ, $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bg": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи, като се раздели p на точно k непразни съседни сегмента и се сортира всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "zh": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序可以获得的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "fr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la plus petite permutation lexicographique qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et le diviser en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "de": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch das Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und das Sortieren jedes Segments erhalten werden kann (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "ha": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nAn ba da wata permutation q na abubuwa n da kuma wani lamba k, nemo yawan permutations p na abubuwa n irin haka f(p) = q, inda f(p) shine permutation mafi ƙaranci a cikin tsarin lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa kuma a jera kowane sashe (wato, zaɓi $ k-1 $ wuraren tsayawa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, $ k-1 $ ब्रेकपॉइंट चुनें $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम को 998244353 से मापांकित किया जाना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hu": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nEgy n elemű q permutáció és egy egész szám k esetén találjuk meg azon n elemű p permutációk számát, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kapunk, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszuk ki a $ k-1 $ töréspontokat $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredményt 998244353-mal vett maradékként kell megadni.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "sq": "0.9734101454123837",
      "hy": "0.9629778791700503",
      "bn": "0.9855198452225566",
      "bg": "0.9927418472466042",
      "zh": "0.9635503319281928",
      "fr": "0.988254985569407",
      "de": "0.9946518769906356",
      "ha": "0.9511470564148503",
      "hi": "0.9661913214744328",
      "hu": "0.953946751635537"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakter felhasználásával."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9312144976779992",
      "bn": "0.8665056852963585",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9160367530023614",
      "hi": "0.9095919916593034",
      "hu": "0.9397117067482907"
    },
    "level": "",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n",
      "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (kjo është, zgjidhni $ k-1 $ pika ndarëse $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն, ընտրել $ k-1 $ բաժանման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশন p-এর সংখ্যা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা p কে ঠিক k টি খালি নয় এমন ধারাবাহিক সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে পাওয়া যায় (অর্থাৎ, $ k-1 $ ব্রেকপয়েন্ট $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序后可以获得的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其划分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et le diviser en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "ha": "An ba da wata permutation q na abubuwa n da kuma wani lamba k, nemo yawan permutations p na abubuwa n da suke cika f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za a iya samu ta hanyar raba p zuwa k daidai baƙaƙen sassa masu ɗorewa kuma a tsara kowane sashe (wato, zaɓi $ k-1 $ wuraren tsagewa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें जिनके लिए f(p) = q है, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ चुनें, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hu": "Adott egy q permutáció n elemről és egy k egész szám, keresse meg az n elemű p permutációk számát úgy, hogy f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst rendezünk (azaz válasszunk $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredménynek 998244353-mal vett maradéka legyen.\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9695455927189689",
      "hy": "0.9797168586406224",
      "bn": "0.9703117100986204",
      "bg": "0.9904224402872598",
      "zh": "0.985885921014804",
      "fr": "0.9905922692630446",
      "de": "0.9979527166626734",
      "ha": "0.9645911551248156",
      "hi": "0.9856427974284172",
      "hu": "0.9614297539802644"
    }
  },
  {
    "task_id": "C/44",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDuke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, \ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) \ni vlerave maksimale dhe minimale të treshes të jetë 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nՏրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\nգտնել եռյակ (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nকিরার বন্ধুদের উচ্চতা উপস্থাপনকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\nতিনটি (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের \nমহানতম সাধারণ বিভাজক (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\nнамерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД)\nна максималната и минималната стойност на тройката да е 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\ntrouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand diviseur commun (PGCD)\ndes valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGegeben ein Array von n verschiedenen ganzen Zahlen, die die Größen von Kiras Freunden darstellen,\nfinde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\nnemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kowa da kowa (GCD)\nna mafi girma da ƙananan ƙimomi na triplet shine 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nकिरा के दोस्तों की ऊंचाइयों का प्रतिनिधित्व करने वाले n विभिन्न पूर्णांकों की एक array दी गई है,\nऐसे त्रिक (a, b, c) को चुनने के तरीकों की संख्या खोजें ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAdott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\ntalálja meg, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas \nmaximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9949261855468449",
      "bn": "0.9870320183133753",
      "bg": "0.9982409293455551",
      "zh": "0.9932147861838482",
      "fr": "1",
      "de": "0.9966077903526862",
      "ha": "0.9693672226367995",
      "hi": "0.9894461719644733",
      "hu": "0.971960739521972"
    },
    "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nՏվեք C կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nПредоставете кратко описание на C кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nBayar da takaitaccen bayanin harshen dabi'a (docstring) na lambar C cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9070022487513705",
      "bn": "0.8818808685707451",
      "bg": "0.8367214569209391",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9524868183349307",
      "hi": "0.9095919916593034",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(int heights[], int n)",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n",
      "sq": "Duke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "hy": "Տրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների մեծագույն ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1",
      "bn": "একটি n সংখ্যক স্বতন্ত্র পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইজর (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1",
      "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира. Намерете броя на начините да изберете тройка (a, b, c), така че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> countTriplets([1, 5, 7])\n    1",
      "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1",
      "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira, nemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda babbar mai raba kowa da kowa (GCD) na mafi girma da mafi ƙarancin ƙimar triplet ɗin ya zama 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "hi": "n अद्वितीय पूर्णांकों की एक array दी गई है जो कि Kira के दोस्तों की ऊंचाई का प्रतिनिधित्व करती है, उन तरीकों की संख्या खोजें जिनसे एक triplet (a, b, c) चुना जा सके ताकि triplet के अधिकतम और न्यूनतम मानों का सबसे बड़ा सामान्य भाजक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1",
      "hu": "Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát jelképezik, meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n    >>> countTriplets([1, 5, 7])\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9929831831595616",
      "hy": "0.9614545827778938",
      "bn": "0.9721095136773672",
      "bg": "0.9792355772273749",
      "zh": "1",
      "fr": "1",
      "de": "0.9946872331984599",
      "ha": "0.9019196945614498",
      "hi": "0.9374397724500136",
      "hu": "0.9441493080909912"
    }
  },
  {
    "task_id": "C/45",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով։ Երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնի։\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nআপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ রয়েছে যা একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nদ্রষ্টব্য: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен от цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个 1 x n 像素图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的同色像素更改为所选颜色。如果两个像素相邻且颜色相同，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n例子:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nVous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour rendre tous les pixels de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein 1 mal n Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku hoton pixel 1 ta n, inda kowane pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launi da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको एक 1 बाय n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या खोजें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nEgy 1 x n pixeles képet kapunk, ahol minden pixel színét egy egész szám képviseli. Végrehajthat egy műveletet, amely során kiválaszt egy színt, és az összes összekapcsolt, azonos színű pixelt a kiválasztott színre változtatja. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Keresse meg a minimális műveletszámot, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "sq": "0.984821460802838",
      "hy": "0.9904790499458547",
      "bn": "0.9866228397284433",
      "bg": "0.9799583931839608",
      "zh": "0.9589613742351438",
      "fr": "0.9917808734631574",
      "de": "0.9895826310362442",
      "ha": "0.9892562813202039",
      "hi": "0.9784696584781043",
      "hu": "0.9598031697899697"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "en": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nՏվեք C կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9438332871547647",
      "bn": "0.9231671864207518",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9656764715267903",
      "hi": "0.892806135418807",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "sq": "Ju jepet një imazh me përmasa 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hy": "Դուք ունեք 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարևան են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնից:\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেল নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেল একই রঙের করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "bg": "Дадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "zh": "您有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。您可以执行一个操作，选择一种颜色并将所有相连的相同颜色的像素更改为所选颜色。如果两个像素相邻并且具有相同的颜色，则它们是相连的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "de": "Du hast ein 1 mal n Pixel-Bild, wobei jeder Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "ha": "An ba ku hoton pixel 1 ta n, inda kowanne pixel ke da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hi": "आपको 1 बाय n पिक्सेल की छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जिसमें आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सेल को चुने हुए रंग में बदल देते हैं। दो पिक्सेल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hu": "Önnek adott egy 1 x n pixeles kép, ahol minden pixel színe egy egész számmal van reprezentálva. Végezhet egy olyan műveletet, ahol kiválaszt egy színt, és az összes összekapcsolt, azonos színű pixelt a kiválasztott színre változtatja. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Találja meg a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9645256070990741",
      "hy": "0.9829904859504583",
      "bn": "0.9878221699691321",
      "bg": "0.9779770551331378",
      "zh": "0.9644499289238998",
      "fr": "0.982214039790993",
      "de": "0.9916400445230036",
      "ha": "0.986569408155945",
      "hi": "0.9705218610417553",
      "hu": "0.9482148747300133"
    }
  },
  {
    "task_id": "C/46",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվի առնվի միայն մեկ անգամ։\nՕրինակ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ বা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\nНапример:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只计算一次。\n例如：\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et 5, il ne doit être compté qu'une seule fois.\nPar exemple :\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani lamba n, rubuta wata aiki don lissafin jumlar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙidaya ta sau ɗaya kawai.\nMisali:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám 3-nak és 5-nek is többszöröse, akkor csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9920259833533545",
      "hy": "0.9877639712674888",
      "bn": "0.9926709362005747",
      "bg": "0.9920259833533545",
      "zh": "0.9802356811958856",
      "fr": "0.9926709362005747",
      "de": "0.9970741744873561",
      "ha": "0.9834179385304455",
      "hi": "0.986694743926378",
      "hu": "0.9913705030959393"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nՏվեք C կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9464321670602251",
      "bn": "0.8843822209591174",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.87230430200991",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n",
      "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hy": "Տրված է n ամբողջ թիվը, գրեք ֆունկցիա՝ հաշվելու համար 1-ից մինչև n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\nՕրինակ՝\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ বা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়ের গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\nНапример:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则它只应被计算一次。\n\n例如：\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ",
      "de": "Geben Sie eine ganze Zahl n an, und schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "ha": "An ba da wani cikakken lamba n, rubuta wata aiki don lissafin jimillar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan wata lamba tana da yawa na duka 3 da 5, ya kamata a ƙidaya ta sau ɗaya kawai.\nMisali:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hi": "दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए। \nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "sq": "0.9904657417103254",
      "hy": "0.9851531735391662",
      "bn": "0.9908419476520054",
      "bg": "0.9900519946266297",
      "zh": "0.9851692626000301",
      "fr": "0.9908419476520054",
      "de": "1",
      "ha": "0.9635260990217066",
      "hi": "0.9794900227454806",
      "hu": "0.9866351548120675"
    }
  },
  {
    "task_id": "C/47",
    "prompt": {
      "en": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "sq": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "hy": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՈրոշել՝ արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "bn": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা বা অন্য কোনো অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, যতিচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "bg": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "zh": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n确定给定的字符串是否为回文。回文是指正着读和反着读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "fr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation et les majuscules).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "de": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "ha": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKafa ko wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da babban ba).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "hi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "hu": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHatározza meg, hogy egy adott sztring palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterek sorozata, amely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9974827571811449",
      "bn": "0.9992021017593828",
      "bg": "0.9992021017593828",
      "zh": "0.9914743867852205",
      "fr": "1",
      "de": "0.9874924435366141",
      "ha": "1",
      "hi": "0.9789467686533502",
      "hu": "0.9992021017593828"
    },
    "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "en": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nՏվեք C կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\n请用中文为以下C代码提供简明的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9546769169162213",
      "hy": "0.9070022487513705",
      "bn": "0.9125454267949111",
      "bg": "0.8985000739215532",
      "zh": "0.8841561795854997",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9400299126187086",
      "hi": "0.9095919916593034",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "hy": "Որոշել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը նույնն է կարդացվում առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা বা অন্যান্য অক্ষরগুলির ক্রম যা সামনের এবং পিছনের দিক থেকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "zh": "确定给定的字符串是否为回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "ha": "Gano idan wata kirtani da aka bayar palindrome ce. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya a gaba da baya (ba tare da la'akari da sarari, alamar rubutu, da manyan haruffa ba).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम होता है जो आगे और पीछे से एक जैसा पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े/छोटे अक्षरों की अनदेखी करते हुए)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterek sorozata, amely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9956925015568774",
      "bn": "0.9699595384330456",
      "bg": "1",
      "zh": "0.9956925015568774",
      "fr": "1",
      "de": "0.9924345660471432",
      "ha": "0.9853774272393546",
      "hi": "0.941916503977778",
      "hu": "0.9989989028795841"
    }
  },
  {
    "task_id": "C/48",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint addDigits(int num)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n*/\nint addDigits(int num)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։\n*/\nint addDigits(int num)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলটি শুধুমাত্র এক অঙ্কের হয়।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এর শুধুমাত্র এক অঙ্ক রয়েছে, 2 হল ফলাফল।\n*/\nint addDigits(int num)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    >>> addDigits(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n*/\nint addDigits(int num)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个非负整数 num，重复将所有位数相加，直到结果只有一位数字。\n例如：\n    >>> addDigits(38)\n    2\n    因为 3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。\n*/\nint addDigits(int num)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n*/\nint addDigits(int num)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    >>> addDigits(38)\n    2\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n*/\nint addDigits(int num)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    >>> addDigits(38)\n    2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n*/\nint addDigits(int num)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिया गया एक गैर-ऋणात्मक पूर्णांक num, इसकी सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न हो।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n*/\nint addDigits(int num)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    >>> addDigits(38)\n    2\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9880567524491343",
      "bn": "0.9861562569633925",
      "bg": "0.9562957545216556",
      "zh": "0.966552034246392",
      "fr": "1",
      "de": "1",
      "ha": "0.9790760770314039",
      "hi": "1",
      "hu": "0.9685623723328461"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nՏրամադրեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nসি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n请用不超过500个字符的中文，为以下C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nदिए गए C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9464321670602251",
      "bn": "0.8880709857653164",
      "bg": "0.9075615919043648",
      "zh": "0.8698778332751879",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.892806135418807",
      "hu": "0.9407561052917722"
    },
    "level": "",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան։\nՕրինակ՝\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, ফলাফল এক অঙ্কের না হওয়া পর্যন্ত এর সমস্ত অঙ্ক বারবার যোগ করুন। \nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর মাত্র এক অঙ্ক আছে, তাই 2 হল ফলাফল।",
      "bg": "Като се даде неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не остане само с една цифра.\nНапример:\n    >>> addDigits(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.",
      "zh": "给定一个非负整数 num，重复相加它的所有数字，直到结果只有一位数字。\n\n例如：\n    >>> addDigits(38)\n    2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。",
      "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Comme 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Einen nicht-negativen Integer num gegeben, addiere wiederholt alle seine Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    >>> addDigits(38)\n    2\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "An ba da wani lamba mara tabbatacce num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai. \n\nMisali:\n    >>> addDigits(38)\n    2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.",
      "hi": "गैर-ऋणात्मक पूर्णांक num को दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Adott egy nemnegatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredménynek csak egy számjegye lesz.  \nPéldául:  \n    >>> addDigits(38)  \n    2  \n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2-nek csak egy számjegye van, 2 az eredmény."
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.989102541405283",
      "bn": "0.9773805680988901",
      "bg": "0.999999801369619",
      "zh": "0.9500347262810549",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.994215486043502",
      "hi": "0.97704468412456",
      "hu": "0.9883223212685779"
    }
  },
  {
    "task_id": "C/49",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë luani të parët.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালাক্রমে ১ থেকে ৩টি পাথর সরাতে পারো। যে শেষ পাথরটি সরাবে সে গেমটি জিতবে। পাথরের সংখ্যা n দেওয়া আছে, যদি তুমি ও তোমার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলে তবে তুমি গেমটি জিততে পারবে কিনা তা নির্ধারণ করো।\nনোট: তুমি সর্বদা প্রথম পালা নাও।\n\nকিছু উদাহরণ:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否可以赢得游戏。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nDu spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nKana kunna wani wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na karshe shi ne ya ci wasan. An ba da adadin duwatsu n, tabbatar idan za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kake fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम तरीके से खेलते हैं।\nनोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ उदाहरण हैं:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te és az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy megnyerheted-e a játékot, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);"
    },
    "prompt_bertscore": {
      "sq": "0.9900404740645297",
      "hy": "0.9800823385417265",
      "bn": "0.9692849896590511",
      "bg": "0.986791675552323",
      "zh": "0.9726299252756786",
      "fr": "0.990879488794021",
      "de": "0.9869960662144079",
      "ha": "0.9783860350876886",
      "hi": "0.9855359342834205",
      "hu": "0.9856793454185276"
    },
    "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}",
    "instruction": {
      "en": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nՏվեք C կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nসি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nПредоставете кратко описание на C кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nC कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.954459218018607",
      "hy": "0.9312144976779992",
      "bn": "0.8843822209591174",
      "bg": "0.8985000739215532",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9366663057462639",
      "ha": "0.9345733374212992",
      "hi": "0.9095919916593034",
      "hu": "0.9304201747842408"
    },
    "level": "",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni kthesën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք ու ձեր հակառակորդը հերթով հանում եք 1-ից 3 քար կույտից։ Նա, ով կհանի վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը՝ n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true",
      "bn": "আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n সংখ্যক পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩টি পাথর স্তূপ থেকে সরিয়ে নেন। যে ব্যক্তি শেষ পাথরটি সরায় সে গেমটি জেতে। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> canWinNim(1)\n    true",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. \nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式进行游戏，你是否能赢得比赛。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle de 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe shi ne zai ci wasan. An ba da adadin duwatsu n, tantance idan za ka iya cin wasan idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों इष्टतम रूप से खेलते हैं। \nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha mind te, mind az ellenfeled optimálisan játszik. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9673846928036903",
      "bn": "0.9771579034417499",
      "bg": "0.9824970880839677",
      "zh": "0.9759559910061079",
      "fr": "0.9780644525007932",
      "de": "0.9825962046441041",
      "ha": "0.9699013397314024",
      "hi": "0.9867195727240073",
      "hu": "0.9694343597055893"
    }
  },
  {
    "task_id": "C/50",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni prodhimin e a dhe b nëse shuma është tek.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি জোড় হলে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定两个整数 a 和 b，如果它们的和是偶数则返回和，如果和是奇数则返回 a 和 b 的乘积。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lambobi guda biyu a da b, a mayar da jumlar idan jumlar ta zama lamba mai mafarin biyu, ko kuma a mayar da samfurin a da b idan jumlar ta zama lamba mai mafarin daya.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nKét egész szám, a és b esetén térj vissza az összeggel, ha az összeg páros, vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.9698687643489127",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9689787016114954",
      "hi": "0.999999801369619",
      "hu": "0.9890791030203208"
    },
    "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "en": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProvide a concise natural language description (docstring) of the C code in English using at most 500 characters.",
      "sq": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nՏրամադրեք C կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nনিচের C কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nПредоставете кратко описание на C кода на естествен език на български, използвайки най-много 500 знака.",
      "zh": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\n请用最多500个字符的中文对该C代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C en français en utilisant au maximum 500 caractères.",
      "de": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nनिम्नलिखित C कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9355907222329599",
      "hy": "0.9464321670602251",
      "bn": "0.8720458838841837",
      "bg": "0.8472595931563641",
      "zh": "0.9336369938051008",
      "fr": "0.9689943934115971",
      "de": "0.9224505280059779",
      "ha": "0.9345733374212992",
      "hi": "0.8877567525025192",
      "hu": "0.9530592710930732"
    },
    "level": "",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n",
      "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni produktin e a dhe b nëse shuma është tek.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։",
      "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।  \n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "fr": "Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "ha": "An ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma dawo da samfurin a da b idan jumlar tana da lamba marar ma'ana.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएँ, या यदि योग विषम है तो a और b का गुणनफल लौटाएँ।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hu": "Két egész szám, a és b esetén add vissza az összeget, ha az összeg páros, vagy add vissza a és b szorzatát, ha az összeg páratlan.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10"
    },
    "docstring_bertscore": {
      "sq": "0.9996492187470923",
      "hy": "0.8544867595703185",
      "bn": "1",
      "bg": "1",
      "zh": "0.9493939446718364",
      "fr": "1",
      "de": "1",
      "ha": "0.9367225181440967",
      "hi": "0.9783957679763593",
      "hu": "0.9804805924557015"
    }
  }
]