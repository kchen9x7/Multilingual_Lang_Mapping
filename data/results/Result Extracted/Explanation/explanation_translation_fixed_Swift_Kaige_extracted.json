[
  {
    "task_id": "Swift/1",
    "prompt": {
      "en": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "sq": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nKontrollo nëse në vargun e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\npragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "hy": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nՍտուգել, արդյոք տրված թվերի զանգվածում որևէ երկու թիվ միմյանց ավելի մոտ են, քան\nտրված շեմը։\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "bn": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nদেওয়া সংখ্যার অ্যারেতে, যদি কোনো দুটি সংখ্যা পরস্পরের থেকে প্রদত্ত থ্রেশহোল্ডের চেয়ে কাছাকাছি থাকে তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "bg": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nПроверете дали в дадения масив от числа, някои две числа са по-близо едно до друго\nот дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "zh": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\n检查在给定的数字数组中，是否有任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "fr": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nVérifiez si, dans le tableau de nombres donné, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "de": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nÜberprüfen Sie, ob in dem gegebenen Array von Zahlen zwei beliebige Zahlen näher beieinander liegen als der gegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "ha": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nDuba idan a cikin jerin lambobin da aka bayar, ko akwai wasu lambobi biyu da suke kusa da juna fiye da\niyakar da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "hi": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nजाँचें कि दिए गए संख्याओं के array में कोई दो संख्याएँ एक-दूसरे के जितना करीब हैं\nदिए गए सीमा से कम।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "hu": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nEllenőrizze, hogy a megadott szám tömbben bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9805550788485896",
      "bn": "0.9805550788485896",
      "bg": "1",
      "zh": "0.9722715960682917",
      "fr": "0.992889230989332",
      "de": "0.9794941939834823",
      "ha": "0.9796491256806895",
      "hi": "0.9895168843801218",
      "hu": "0.9757573606250729"
    },
    "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}",
    "instruction": {
      "en": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nনিচের Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки не повече от 500 знака.",
      "zh": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8798107427395995",
      "bg": "0.9346778170017236",
      "zh": "0.8526498258065078",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)",
    "entry_point": "hasCloseElements",
    "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {",
    "docstring": {
      "en": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "sq": "Kontrolloni nëse në vargun e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Ստուգել, արդյոք տրված թվերի զանգվածում որևէ երկու թիվ ավելի մոտ են միմյանց, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "প্রদত্ত সংখ্যার অ্যারেতে, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে একে অপরের কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Проверете дали в дадения масив от числа, някои две числа са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "检查在给定的数字数组中，是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "fr": "Vérifiez si, dans le tableau de nombres donné, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Überprüfen Sie, ob in dem gegebenen Zahlenarray zwei Zahlen näher beieinander liegen als der gegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Duba idan a cikin jerin lambobi da aka bayar, ko akwai wasu lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden tazara.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "दिए गए संख्याओं के एरे में जांचें कि क्या कोई दो संख्याएं दी गई सीमा से अधिक निकट हैं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Ellenőrizze, hogy a megadott szám tömbben bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9657283140562404",
      "bn": "0.962549632068539",
      "bg": "1",
      "zh": "0.9490145606440598",
      "fr": "0.9916217705279484",
      "de": "0.9638045788159175",
      "ha": "0.9592638883054599",
      "hi": "0.9483906626172292",
      "hu": "0.9650023200135579"
    }
  },
  {
    "task_id": "Swift/2",
    "prompt": {
      "en": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "sq": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nGjen dhe kthen vargun e parë palindrom në vargun e dhënë të fjalëve.\nNëse nuk gjendet asnjë varg palindrom, kthen një varg bosh \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "hy": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nԳտնում և վերադարձնում է առաջին պալինդրոմ տողը տրված բառերի զանգվածում:\nԵթե պալինդրոմ տող չի գտնվել, վերադարձնում է դատարկ տող \"\":\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "bn": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nপ্রদত্ত শব্দের অ্যারেতে প্রথম প্যালিনড্রোম স্ট্রিংটি খুঁজে বের করে এবং ফেরত দেয়।\nযদি কোনো প্যালিনড্রোম স্ট্রিং পাওয়া না যায়, তাহলে একটি খালি স্ট্রিং \"\" ফেরত দেয়।\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "bg": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nНамира и връща първия палиндромен низ в дадения масив от думи.\nАко не е намерен палиндромен низ, връща празен низ \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "zh": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\n找到并返回给定单词数组中的第一个回文字符串。\n如果没有找到回文字符串，则返回空字符串 \"\"。\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "fr": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nTrouve et retourne la première chaîne de caractères palindrome dans le tableau de mots donné.\nSi aucune chaîne palindrome n'est trouvée, retourne une chaîne vide \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "de": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFindet und gibt die erste Palindrom-Zeichenkette im gegebenen Array von Wörtern zurück.\nWenn keine Palindrom-Zeichenkette gefunden wird, wird ein leerer String \"\" zurückgegeben.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "ha": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nNemo kuma ya dawo da kalmar palindrome ta farko a cikin jerin kalmomin da aka bayar.\nIdan ba a sami kalmar palindrome ba, ya dawo da kirtani mara komai \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "hi": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nदिए गए शब्दों की सूची में पहला पालिंड्रोम स्ट्रिंग खोजता है और उसे लौटाता है।\nयदि कोई पालिंड्रोम स्ट्रिंग नहीं मिलती है, तो एक खाली स्ट्रिंग \"\" लौटाता है।\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "hu": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nMegkeresi és visszaadja az első palindróm szót a megadott szavak tömbjében.\nHa nem található palindróm szó, akkor egy üres karakterláncot ad vissza \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9935409372695075",
      "bn": "0.999999801369619",
      "bg": "0.9855067356174083",
      "zh": "0.9933595877316227",
      "fr": "0.999999801369619",
      "de": "0.9851114611591489",
      "ha": "0.9808605723746213",
      "hi": "0.9956329124425669",
      "hu": "0.9888953699178635"
    },
    "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}",
    "instruction": {
      "en": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\n请用中文为以下 Swift 代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nBayar da gajeriyar bayanin harshen halitta (docstring) na lambar Swift cikin harshen Hausa ba tare da wuce haruffa 500 ba.",
      "hi": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8815584914623255",
      "bg": "0.840216358475248",
      "zh": "0.8602410817088992",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9351845231037436",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)",
    "entry_point": "firstPalindrome",
    "signature": "func firstPalindrome(_ words: [String]) -> String {",
    "docstring": {
      "en": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n",
      "sq": "Gjen dhe kthen string-un e parë palindrome në vargun e dhënë të fjalëve. Nëse nuk gjendet asnjë string palindrome, kthen një string bosh \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hy": "Գտնում և վերադարձնում է առաջին պալինդրոմ տողը տրված բառերի զանգվածում:\nԵթե պալինդրոմ տող չի գտնվել, վերադարձնում է դատարկ տող \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "bn": "প্রদত্ত শব্দের অ্যারেতে প্রথম প্যালিনড্রোম স্ট্রিং খুঁজে এবং ফেরত দেয়।  \nযদি কোনো প্যালিনড্রোম স্ট্রিং পাওয়া না যায়, তাহলে একটি খালি স্ট্রিং \"\" ফেরত দেয়।  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "bg": "Намира и връща първия палиндромен низ в дадения масив от думи.  \nАко не се намери палиндромен низ, връща празен низ \"\".  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "zh": "查找并返回给定单词数组中的第一个回文字符串。\n如果未找到回文字符串，则返回空字符串 \"\"。\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "fr": "Trouve et renvoie la première chaîne palindrome dans le tableau de mots donné. Si aucune chaîne palindrome n'est trouvée, renvoie une chaîne vide \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "de": "Findet und gibt den ersten Palindrom-String im gegebenen Array von Wörtern zurück.  \nWenn kein Palindrom-String gefunden wird, wird ein leerer String \"\" zurückgegeben.  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "ha": "Nemi kuma dawo da farkon kalmar palindrome a cikin jerin kalmomin da aka bayar. Idan ba a sami kalmar palindrome ba, dawo da kirtani mara komai \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hi": "दिए गए शब्दों की सूची में पहला पालिंड्रोम स्ट्रिंग खोजता है और लौटाता है।  \nयदि कोई पालिंड्रोम स्ट्रिंग नहीं मिलती है, तो एक खाली स्ट्रिंग \"\" लौटाता है।  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "hu": "Megkeresi és visszaadja az első palindróm sztringet a megadott szavak tömbjében.\nHa nem található palindróm sztring, akkor egy üres sztringet ad vissza \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\""
    },
    "docstring_bertscore": {
      "sq": "0.9892755484671644",
      "hy": "0.999999801369619",
      "bn": "0.9673123913449936",
      "bg": "0.9848061662634983",
      "zh": "0.9892755484671644",
      "fr": "0.9892755484671644",
      "de": "0.9841524736795125",
      "ha": "0.9735400496815805",
      "hi": "0.9948467333944309",
      "hu": "0.994119348939081"
    }
  },
  {
    "task_id": "Swift/3",
    "prompt": {
      "en": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "sq": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nKthen numrin maksimal të fjalëve të gjetura në çdo fjali të vetme brenda vargut të dhënë të fjalive.\nNjë fjali përbëhet nga fjalë të ndara me një hapësirë të vetme, dhe nuk ka hapësira në fillim apo në fund.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "hy": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nՎերադարձնում է առավելագույն բառերի քանակը, որը գտնվել է տրված նախադասությունների զանգվածի որևէ առանձին նախադասության մեջ:\nՆախադասությունը բաղկացած է բառերից, որոնք բաժանված են մեկական բացատով, և բացատներ չկան նախադասության սկզբում կամ վերջում:\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "bn": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nপ্রদত্ত বাক্যসমূহের অ্যারের মধ্যে যেকোনো একক বাক্যে পাওয়া সর্বাধিক শব্দের সংখ্যা প্রদান করে।\nএকটি বাক্য একক স্পেস দ্বারা পৃথক করা শব্দ নিয়ে গঠিত, এবং কোন প্রারম্ভিক বা শেষের স্পেস নেই।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "bg": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nВръща максималния брой думи, намерени в което и да е отделно изречение в дадения масив от изречения.\nИзречението се състои от думи, разделени с единично пространство, и няма водещи или завършващи интервали.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "zh": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\n返回在给定句子数组中任一单个句子中找到的最大单词数。\n一个句子由用单个空格分隔的单词组成，并且没有前导或尾随空格。\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "fr": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nRenvoie le nombre maximum de mots trouvés dans une seule phrase au sein du tableau de phrases donné.\nUne phrase est composée de mots séparés par un espace unique, et il n'y a pas d'espaces en début ou en fin.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "de": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nGibt die maximale Anzahl von Wörtern zurück, die in einem einzelnen Satz innerhalb des gegebenen Arrays von Sätzen gefunden werden.\nEin Satz besteht aus Wörtern, die durch ein einzelnes Leerzeichen getrennt sind, und es gibt keine führenden oder nachgestellten Leerzeichen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "ha": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nYana dawo da mafi girman adadin kalmomi da aka samu a cikin kowace jumla guda a cikin jerin jumlolin da aka bayar.\nJumla tana kunshe da kalmomi da aka raba su da sarari guda, kuma babu sarari a farkon ko a karshen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "hi": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nदिए गए वाक्यों की सूची में किसी भी एकल वाक्य में पाए गए शब्दों की अधिकतम संख्या लौटाता है।\nएक वाक्य शब्दों से बना होता है जो एकल स्पेस द्वारा अलग होते हैं, और कोई अग्रणी या पिछला स्पेस नहीं होता।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "hu": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nVisszaadja a maximális szavak számát, amely bármelyik mondatban található a megadott mondatok tömbjében.\nEgy mondat szavakból áll, amelyeket egyetlen szóköz választ el, és nincsenek vezető vagy záró szóközök.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.973622679920091",
      "hy": "0.9594259706963845",
      "bn": "0.9895691241703339",
      "bg": "0.9919060106032094",
      "zh": "0.990423632069546",
      "fr": "0.9723931578614851",
      "de": "0.9898476039645447",
      "ha": "0.955654774282056",
      "hi": "0.9859874211395128",
      "hu": "0.9818145940947318"
    },
    "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}",
    "instruction": {
      "en": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简明的自然语言描述（文档字符串）。",
      "fr": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9040293478384214",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9346315361229425",
      "hi": "0.9102601842611048",
      "hu": "0.9430238683520475"
    },
    "level": "",
    "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)",
    "entry_point": "maxWordCount",
    "signature": "func maxWordCount(_ sentences: [String]) -> Int {",
    "docstring": {
      "en": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n",
      "sq": "Kthen numrin maksimal të fjalëve të gjetura në çdo fjali të vetme brenda vargut të dhënë të fjalive. Një fjali përbëhet nga fjalë të ndara nga një hapësirë e vetme, dhe nuk ka hapësira në fillim apo në fund.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hy": "Վերադարձնում է առավելագույն բառերի քանակը, որը գտնվել է որևէ մեկ նախադասության մեջ տրված նախադասությունների զանգվածի մեջ:\nՆախադասությունը բաղկացած է բառերից, որոնք բաժանված են մեկ բացատով, և չկան առաջատար կամ հետևող բացատներ:\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "bn": "প্রদত্ত বাক্যগুলির অ্যারেতে যেকোনো একটি বাক্যে পাওয়া সর্বাধিক শব্দের সংখ্যা প্রদান করে। একটি বাক্য শব্দ দ্বারা গঠিত যা একটি একক স্পেস দ্বারা পৃথক হয়, এবং কোনো প্রাথমিক বা শেষের স্পেস নেই।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "bg": "Връща максималния брой думи, намерени в което и да е изречение в дадения масив от изречения. Изречението се състои от думи, разделени с единично пространство, и няма водещи или завършващи интервали.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "zh": "返回给定句子数组中任何单个句子中找到的最大单词数。  \n一个句子由用单个空格分隔的单词组成，没有前导或尾随空格。  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "fr": "Retourne le nombre maximum de mots trouvés dans une seule phrase au sein du tableau de phrases donné.  \nUne phrase est composée de mots séparés par un espace unique, et il n'y a pas d'espaces en début ou fin de phrase.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "de": "Gibt die maximale Anzahl von Wörtern zurück, die in einem einzelnen Satz innerhalb des gegebenen Arrays von Sätzen gefunden werden.\nEin Satz besteht aus Wörtern, die durch ein einzelnes Leerzeichen getrennt sind, und es gibt keine führenden oder nachgestellten Leerzeichen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "ha": "Yana mayar da mafi girman adadin kalmomi da aka samu a cikin kowace jumla guda a cikin jerin jumlolin da aka bayar. \nJumla tana kunshe da kalmomi da aka raba su da sarari guda, kuma babu sarari a farkon ko a ƙarshen.\n\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hi": "दिए गए वाक्यों के समूह में किसी भी एकल वाक्य में पाए गए शब्दों की अधिकतम संख्या लौटाता है। एक वाक्य शब्दों से बना होता है जो एकल स्पेस द्वारा अलग होते हैं, और इसमें कोई अग्रणी या अंतिम स्पेस नहीं होते हैं।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hu": "Visszaadja a maximális szavak számát, amelyet bármelyik mondatban találunk a megadott mondatok tömbjében.\nEgy mondat szavakból áll, amelyeket egyetlen szóköz választ el, és nincsenek vezető vagy záró szóközök.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5"
    },
    "docstring_bertscore": {
      "sq": "0.9697332984290469",
      "hy": "0.9783910008472145",
      "bn": "0.98972385723716",
      "bg": "0.9822341014594775",
      "zh": "0.9721716849866311",
      "fr": "0.9607621572696061",
      "de": "0.9883693966688831",
      "ha": "0.9744279274848064",
      "hi": "0.9723238358585039",
      "hu": "0.9750373254938215"
    }
  },
  {
    "task_id": "Swift/4",
    "prompt": {
      "en": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "sq": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nKontrollon nëse matrica e dhënë `n x n` është një matricë e vlefshme. Një matricë është e vlefshme nëse secila rresht dhe kolonë përmban të gjitha numrat nga 1 deri në n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "hy": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nՍտուգում է, արդյոք տրված `n x n` մատրիցը վավեր մատրից է: Մատրիցը վավեր է, եթե յուրաքանչյուր տող և \nսյունակ պարունակում է բոլոր ամբողջ թվերը 1-ից մինչև n:\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "bn": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nপ্রদত্ত `n x n` ম্যাট্রিক্সটি একটি বৈধ ম্যাট্রিক্স কিনা তা পরীক্ষা করে। একটি ম্যাট্রিক্স বৈধ যদি প্রতিটি সারি এবং কলামে 1 থেকে n পর্যন্ত সমস্ত পূর্ণসংখ্যা থাকে।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "bg": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nПроверява дали дадената `n x n` матрица е валидна. Една матрица е валидна, ако всеки ред и \nколона съдържат всички цели числа от 1 до n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "zh": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\n检查给定的 `n x n` 矩阵是否为有效矩阵。如果每一行和每一列都包含从 1 到 n 的所有整数，则矩阵是有效的。\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "fr": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nVérifie si la matrice `n x n` donnée est une matrice valide. Une matrice est valide si chaque ligne et \ncolonne contient tous les entiers de 1 à n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "de": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nÜberprüft, ob die gegebene `n x n` Matrix eine gültige Matrix ist. Eine Matrix ist gültig, wenn jede Zeile und \njede Spalte alle Ganzzahlen von 1 bis n enthält.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "ha": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nDuba idan matrix `n x n` da aka bayar matrix ne mai inganci. Matrix yana da inganci idan kowace layi da \nsafiyo suna dauke da dukkan lambobi daga 1 zuwa n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "hi": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nदिए गए `n x n` मैट्रिक्स की जाँच करता है कि यह एक वैध मैट्रिक्स है या नहीं। एक मैट्रिक्स वैध है यदि प्रत्येक पंक्ति और स्तंभ में 1 से n तक के सभी पूर्णांक शामिल हैं।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "hu": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nEllenőrzi, hogy a megadott `n x n` mátrix érvényes mátrix-e. Egy mátrix akkor érvényes, ha minden sor és oszlop tartalmazza az összes egész számot 1-től n-ig.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9948274662474704",
      "hy": "0.99850292281814",
      "bn": "0.99850292281814",
      "bg": "0.9881620265510828",
      "zh": "0.9921614492732203",
      "fr": "1",
      "de": "0.9940859790350672",
      "ha": "0.9930431695346341",
      "hi": "0.9862156474473218",
      "hu": "0.9971170786496596"
    },
    "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}",
    "instruction": {
      "en": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9404853720824217",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)",
    "entry_point": "isValidMatrix",
    "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {",
    "docstring": {
      "en": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n",
      "sq": "Kontrollon nëse matrica e dhënë `n x n` është një matricë e vlefshme. Një matricë është e vlefshme nëse çdo rresht dhe kolonë përmban të gjitha numrat e plotë nga 1 deri në n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hy": "Ստուգում է, արդյոք տրված `n x n` մատրիցը վավեր մատրից է։ Մատրիցը վավեր է, եթե յուրաքանչյուր տող և սյունակ պարունակում է բոլոր ամբողջ թվերը 1-ից մինչև n։  \n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])  \nTrue  \n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])  \nFalse  ",
      "bn": "প্রদত্ত `n x n` ম্যাট্রিক্সটি একটি বৈধ ম্যাট্রিক্স কিনা তা পরীক্ষা করে। একটি ম্যাট্রিক্স বৈধ যদি প্রতিটি সারি এবং কলামে 1 থেকে n পর্যন্ত সমস্ত পূর্ণসংখ্যা থাকে।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "bg": "Проверява дали дадената `n x n` матрица е валидна матрица. Една матрица е валидна, ако всеки ред и колона съдържат всички цели числа от 1 до n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "zh": "检查给定的 `n x n` 矩阵是否为有效矩阵。如果每一行和每一列都包含从 1 到 n 的所有整数，则该矩阵是有效的。\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "fr": "Vérifie si la matrice `n x n` donnée est une matrice valide. Une matrice est valide si chaque ligne et colonne contient tous les entiers de 1 à n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "de": "Überprüft, ob die gegebene `n x n` Matrix eine gültige Matrix ist. Eine Matrix ist gültig, wenn jede Zeile und Spalte alle ganzen Zahlen von 1 bis n enthält.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "ha": "Duba idan matrix ɗin `n x n` da aka bayar matrix ne mai inganci. Matrix yana da inganci idan kowace jere da ginshiƙi suna ɗauke da duk lambobi daga 1 zuwa n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hi": "यह जांचता है कि दिया गया `n x n` मैट्रिक्स एक मान्य मैट्रिक्स है या नहीं। एक मैट्रिक्स मान्य है यदि प्रत्येक पंक्ति और स्तंभ में 1 से n तक के सभी पूर्णांक शामिल हैं।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hu": "Ellenőrzi, hogy a megadott `n x n` mátrix érvényes mátrix-e. Egy mátrix akkor érvényes, ha minden sor és oszlop tartalmazza az összes egész számot 1-től n-ig.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse"
    },
    "docstring_bertscore": {
      "sq": "0.9983565322273174",
      "hy": "1",
      "bn": "0.9895516446968028",
      "bg": "0.9983565322273174",
      "zh": "0.987742320555956",
      "fr": "0.9952827270808025",
      "de": "1",
      "ha": "0.9887487806966598",
      "hi": "0.9691536949771871",
      "hu": "0.9932950328577863"
    }
  },
  {
    "task_id": "Swift/5",
    "prompt": {
      "en": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/",
      "sq": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nLlogarit koston minimale totale për të blerë të gjitha karamelet nën një promovim ku\nduke blerë dy karamele, merr një karamele falas (me çmimin e saj më të vogël ose të barabartë me më të voglin nga dy të blerat).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Bli karamelet që kushtojnë 4 dhe 3, merr 2 falas; paguaj për 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Bli të dyja karamelet, nuk ka karamele falas në dispozicion.\n*/",
      "hy": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nՀաշվարկում է կոնֆետների ձեռքբերման նվազագույն ընդհանուր արժեքը այնպիսի ակցիայի պայմաններում, որտեղ\nերկու կոնֆետ գնելիս ստանում եք մեկ անվճար կոնֆետ (որի գինը փոքր կամ հավասար է գնված երկուսի փոքրագույնին):\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Գնել 4 և 3 արժեք ունեցող կոնֆետները, ստանալ 2-ը անվճար; վճարել 1-ի համար։\n>>> minCostToBuyCandies([1, 2])\n3 // Գնել երկու կոնֆետները, անվճար կոնֆետներ չկան։\n*/",
      "bn": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nসব ক্যান্ডি কেনার জন্য সর্বনিম্ন মোট খরচ হিসাব করে যেখানে একটি প্রচারে দুটি ক্যান্ডি কিনলে একটি ক্যান্ডি বিনামূল্যে পাওয়া যায় (যার মূল্য কেনা দুটি ক্যান্ডির মধ্যে কম দামের সমান বা তার চেয়ে কম)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 এবং 3 মূল্যের ক্যান্ডি কিনুন, 2 বিনামূল্যে পান; 1 এর জন্য অর্থ প্রদান করুন।\n>>> minCostToBuyCandies([1, 2])\n3 // উভয় ক্যান্ডি কিনুন, কোন বিনামূল্যের ক্যান্ডি পাওয়া যায় না।\n*/",
      "bg": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nИзчислява минималната обща цена за придобиване на всички бонбони при промоция, където\nкупуването на два бонбона получава един безплатно (с цена, по-малка или равна на по-евтиния от двата купени).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Купете бонбони на стойност 4 и 3, получете 2 безплатно; платете за 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Купете и двата бонбона, няма налични безплатни бонбони.\n*/",
      "zh": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\n计算在促销活动下获取所有糖果的最低总成本，其中购买两颗糖果可以免费获得一颗糖果（其价格小于或等于所购买的两颗糖果中较便宜的那个）。\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 购买价格为4和3的糖果，免费获得价格为2的糖果；支付价格为1的糖果。\n>>> minCostToBuyCandies([1, 2])\n3 // 购买两颗糖果，没有免费糖果。\n*/",
      "fr": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalcule le coût total minimum pour acquérir tous les bonbons sous une promotion où\nl'achat de deux bonbons en obtient un gratuit (avec son prix inférieur ou égal au moins cher des deux achetés).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Acheter des bonbons coûtant 4 et 3, obtenir 2 gratuitement ; payer pour 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Acheter les deux bonbons, pas de bonbons gratuits disponibles.\n*/",
      "de": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nBerechnet die minimalen Gesamtkosten, um alle Süßigkeiten unter einer Aktion zu erwerben, bei der\nbeim Kauf von zwei Süßigkeiten eine kostenlose Süßigkeit (mit einem Preis kleiner oder gleich dem der günstigeren der beiden gekauften) erhältlich ist.\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Kaufe Süßigkeiten, die 4 und 3 kosten, erhalte 2 kostenlos; bezahle für 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Kaufe beide Süßigkeiten, keine kostenlosen Süßigkeiten verfügbar.\n*/",
      "ha": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nYana ƙididdige mafi ƙarancin jimillar kuɗi don siyan duk alewa a ƙarƙashin talla inda\nsiyan alewa biyu yana samun alewa ɗaya kyauta (tare da farashinsa ƙasa ko daidai da ƙaramin daga cikin biyun da aka saya).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Sayi alewa masu tsada 4 da 3, sami 2 kyauta; biya don 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Sayi duk alewa biyu, babu alewa kyauta da ake da su.\n*/",
      "hi": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nसभी कैंडीज प्राप्त करने की न्यूनतम कुल लागत की गणना करता है एक प्रमोशन के तहत जहां\nदो कैंडीज खरीदने पर एक मुफ्त कैंडी मिलती है (जिसकी कीमत खरीदी गई दो में से कम कीमत के बराबर या उससे कम होती है)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 और 3 की कीमत वाली कैंडीज खरीदें, 2 मुफ्त में मिलती है; 1 के लिए भुगतान करें।\n>>> minCostToBuyCandies([1, 2])\n3 // दोनों कैंडीज खरीदें, कोई मुफ्त कैंडी उपलब्ध नहीं है।\n*/",
      "hu": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nKiszámítja a minimális összköltséget az összes cukorka megszerzéséhez egy olyan akció keretében, ahol\nkét cukorka vásárlásakor egy harmadikat ingyen kapunk (amelynek ára kisebb vagy egyenlő a megvásárolt két cukorka közül az olcsóbbikkal).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Vásároljuk meg a 4 és 3 árú cukorkákat, a 2 ingyen van; fizessünk az 1-ért.\n>>> minCostToBuyCandies([1, 2])\n3 // Vásároljuk meg mindkét cukorkát, nincs ingyen cukorka.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.957538982076553",
      "hy": "0.9440031161305495",
      "bn": "0.9326944926470903",
      "bg": "0.9739955091452934",
      "zh": "0.9320876768330286",
      "fr": "0.9864194422182636",
      "de": "0.9638673460163245",
      "ha": "0.9747141538638777",
      "hi": "0.9640177092147679",
      "hu": "0.9225939391410851"
    },
    "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}",
    "instruction": {
      "en": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nনিচের Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Swift cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9229242614647462",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9165571646006728",
      "hi": "0.9102601842611048",
      "hu": "0.9430238683520475"
    },
    "level": "",
    "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)",
    "entry_point": "minCostToBuyCandies",
    "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n",
      "sq": "Llogarit koston totale minimale për të blerë të gjitha karamelet nën një promovim ku blerja e dy karameleve të jep një karamele falas (me çmimin më të vogël ose të barabartë me më të voglin nga dy të blerat).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Bli karamele që kushtojnë 4 dhe 3, merr 2 falas; paguaj për 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Bli të dyja karamelet, nuk ka karamele falas të disponueshme.",
      "hy": "Հաշվում է բոլոր կոնֆետները ձեռք բերելու նվազագույն ընդհանուր արժեքը այնպիսի ակցիայի պայմաններում, որտեղ երկու կոնֆետ գնելիս ստանում եք մեկ անվճար կոնֆետ (որի գինը հավասար է կամ փոքր է գնված երկուսի փոքրագույնից):\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Գնեք 4 և 3 արժողությամբ կոնֆետները, ստացեք 2-ը անվճար; վճարեք 1-ի համար:\n>>> minCostToBuyCandies([1, 2])\n3 // Գնեք երկու կոնֆետներն էլ, անվճար կոնֆետներ չկան:",
      "bn": "ক্যান্ডি কেনার প্রচারের অধীনে সমস্ত ক্যান্ডি অর্জনের জন্য সর্বনিম্ন মোট খরচ গণনা করে যেখানে দুটি ক্যান্ডি কিনলে একটি বিনামূল্যে ক্যান্ডি পাওয়া যায় (এর দাম কেনা দুটি ক্যান্ডির মধ্যে কম দামের সমান বা তার চেয়ে কম)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 এবং 3 দামের ক্যান্ডি কিনুন, 2 বিনামূল্যে পান; 1 এর জন্য অর্থ প্রদান করুন।\n>>> minCostToBuyCandies([1, 2])\n3 // উভয় ক্যান্ডি কিনুন, কোন বিনামূল্যের ক্যান্ডি পাওয়া যায় না।",
      "bg": "Изчислява минималната обща цена за придобиване на всички бонбони при промоция, където купуването на два бонбона осигурява един безплатен бонбон (с цена по-малка или равна на по-евтиния от двата купени).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Купете бонбони на стойност 4 и 3, получете 2 безплатно; платете за 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Купете и двата бонбона, няма налични безплатни бонбони.",
      "zh": "计算在一种促销活动下获得所有糖果的最低总成本，该促销活动是买两颗糖果送一颗免费糖果（其价格小于或等于所购买的两颗糖果中较便宜的那颗）。\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 购买价格为4和3的糖果，免费获得价格为2的糖果；支付价格为1的糖果。\n>>> minCostToBuyCandies([1, 2])\n3 // 购买两颗糖果，没有免费糖果可得。",
      "fr": "Calcule le coût total minimum pour acquérir tous les bonbons dans le cadre d'une promotion où l'achat de deux bonbons permet d'obtenir un bonbon gratuit (dont le prix est inférieur ou égal au moins cher des deux achetés).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Achetez des bonbons coûtant 4 et 3, obtenez 2 gratuitement; payez pour 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Achetez les deux bonbons, aucun bonbon gratuit disponible.",
      "de": "Berechnet die minimalen Gesamtkosten, um alle Süßigkeiten unter einer Aktion zu erwerben, bei der beim Kauf von zwei Süßigkeiten eine Süßigkeit kostenlos ist (deren Preis kleiner oder gleich dem der günstigeren der beiden gekauften ist).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Kaufe Süßigkeiten, die 4 und 3 kosten, bekomme 2 kostenlos; zahle für 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Kaufe beide Süßigkeiten, keine kostenlosen Süßigkeiten verfügbar.",
      "ha": "Yana lissafin mafi ƙarancin jimillar kuɗi don siyan dukkan alewa a ƙarƙashin tayin inda\nsiyan alewa biyu yana samun alewa ɗaya kyauta (tare da farashinta ƙasa ko daidai da ƙaramin na biyun da aka saya).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Saya alewa masu tsada 4 da 3, sami 2 kyauta; biya don 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Saya dukkan alewa, babu alewa kyauta da ake da su.",
      "hi": "सभी मिठाइयों को एक प्रमोशन के तहत प्राप्त करने की न्यूनतम कुल लागत की गणना करता है जहाँ दो मिठाइयाँ खरीदने पर एक मुफ्त मिठाई मिलती है (जिसकी कीमत खरीदी गई दो में से कम कीमत वाली के बराबर या उससे कम होती है)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 और 3 की कीमत वाली मिठाइयाँ खरीदें, 2 मुफ्त में प्राप्त करें; 1 के लिए भुगतान करें।\n>>> minCostToBuyCandies([1, 2])\n3 // दोनों मिठाइयाँ खरीदें, कोई मुफ्त मिठाई उपलब्ध नहीं है।",
      "hu": "Kiszámítja a minimális összköltséget az összes cukorka megszerzéséhez egy olyan promóció keretében, ahol két cukorka vásárlása esetén egy cukorkát ingyen kapunk (amelynek ára kisebb vagy egyenlő a megvásárolt kettő közül a kisebbikkel).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Vásárolj cukorkákat, amelyek 4 és 3-ba kerülnek, kapd meg a 2-t ingyen; fizess az 1-ért.\n>>> minCostToBuyCandies([1, 2])\n3 // Vásárold meg mindkét cukorkát, nincs ingyen cukorka."
    },
    "docstring_bertscore": {
      "sq": "0.9613723498001453",
      "hy": "0.9708291422412163",
      "bn": "0.9515848377746512",
      "bg": "0.9735309126840529",
      "zh": "0.9130650438716984",
      "fr": "0.9559694048056153",
      "de": "0.9701935250219047",
      "ha": "0.9614968910490541",
      "hi": "0.9316256625667415",
      "hu": "0.9328379037821974"
    }
  },
  {
    "task_id": "Swift/6",
    "prompt": {
      "en": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n*/",
      "sq": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nNumëron numrin e elementeve në varg që kanë të paktën një element rreptësisht më të vogël dhe\nnjë element rreptësisht më të madh.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një më të madh (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një më të madh (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nuk ka elemente me si një element më të vogël ashtu edhe një më të madh.\n*/",
      "hy": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nՀաշվում է զանգվածի այն տարրերի քանակը, որոնք ունեն առնվազն մեկ խիստ փոքր և \nմեկ խիստ մեծ տարր։\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր։\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր։\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Չկան տարրեր, որոնք ունեն և՛ փոքր, և՛ մեծ տարր։\n*/",
      "bn": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nঅ্যারের মধ্যে কতগুলি উপাদান রয়েছে যা অন্তত একটি কঠোরভাবে ছোট এবং একটি কঠোরভাবে বড় উপাদান রয়েছে তা গণনা করে।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // শুধুমাত্র উপাদান '2'-এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // শুধুমাত্র উপাদান '2'-এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // এমন কোনও উপাদান নেই যার উভয় একটি ছোট এবং একটি বড় উপাদান রয়েছে।\n*/",
      "bg": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nБрои броя на елементите в масива, които имат поне един строго по-малък и \nедин строго по-голям елемент.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Няма елементи с както по-малък, така и по-голям елемент.\n*/",
      "zh": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\n计算数组中至少有一个严格较小和一个严格较大元素的元素数量。\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // 没有元素同时具有较小和较大的元素。\n*/",
      "fr": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCompte le nombre d'éléments dans le tableau qui ont au moins un élément strictement plus petit et un élément strictement plus grand.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Il n'y a pas d'éléments avec à la fois un élément plus petit et un élément plus grand.\n*/",
      "de": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nZählt die Anzahl der Elemente im Array, die mindestens ein strikt kleineres und \nein strikt größeres Element haben.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Es gibt keine Elemente mit sowohl einem kleineren als auch einem größeren Element.\n*/",
      "ha": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nYana ƙididdige adadin abubuwan da ke cikin jerin waɗanda ke da aƙalla ɗaya da ya fi ƙarami sosai kuma\nɗaya da ya fi girma sosai.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Abun '2' kawai yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Abun '2' kawai yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Babu abubuwan da ke da ƙarami da kuma babba abu.\n*/",
      "hi": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nऐरे में उन तत्वों की संख्या गिनता है जिनके पास कम से कम एक सख्ती से छोटा और \nएक सख्ती से बड़ा तत्व होता है।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // ऐसे कोई तत्व नहीं हैं जिनके पास एक छोटा और एक बड़ा तत्व हो।\n*/",
      "hu": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nMegszámolja a tömb azon elemeit, amelyeknek van legalább egy szigorúan kisebb és egy szigorúan nagyobb eleme.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nincsenek olyan elemek, amelyeknek mind kisebb, mind nagyobb eleme lenne.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9740745640369454",
      "hy": "0.9968550851770747",
      "bn": "0.9835833976378475",
      "bg": "1",
      "zh": "0.970309127903667",
      "fr": "0.9753525519085239",
      "de": "1",
      "ha": "0.9611844454596863",
      "hi": "0.988493739287411",
      "hu": "0.9878172042096062"
    },
    "canonical_solution": "guard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}",
    "instruction": {
      "en": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8512246528225825",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9346315361229425",
      "hi": "0.9102601842611048",
      "hu": "0.930809291700688"
    },
    "level": "",
    "test": "func checkCountElementsWithStrictBounds(_ countElementsWithStrictBounds: ([Int]) -> Int) {\nassert(countElementsWithStrictBounds([2, 1, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 2, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 1, 1]) == 0)\nassert(countElementsWithStrictBounds([3, 3, 5, 2, 2, 7, 4]) == 4)\nassert(countElementsWithStrictBounds([10, 5, 9, 1, 7, 6, 8]) == 5)\nassert(countElementsWithStrictBounds([-2, -1, 0, 1, 2]) == 3)\nassert(countElementsWithStrictBounds([]) == 0)\n}\n\ncheckCountElementsWithStrictBounds(countElementsWithStrictBounds)",
    "entry_point": "countElementsWithStrictBounds",
    "signature": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n",
      "sq": "Numëron numrin e elementeve në varg që kanë të paktën një element rreptësisht më të vogël dhe një element rreptësisht më të madh.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një më të madh (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një më të madh (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nuk ka elemente me si një element më të vogël ashtu edhe një më të madh.",
      "hy": "Հաշվում է զանգվածի այն տարրերի քանակը, որոնք ունեն առնվազն մեկ խիստ փոքր և մեկ խիստ մեծ տարր:\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Չկան տարրեր, որոնք ունեն և՛ փոքր, և՛ մեծ տարր:",
      "bn": "Counts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // শুধুমাত্র উপাদান '2' এর একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // শুধুমাত্র উপাদান '2' এর একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // এমন কোনো উপাদান নেই যার একটি ছোট এবং একটি বড় উপাদান রয়েছে।",
      "bg": "Брои броя на елементите в масива, които имат поне един строго по-малък и един строго по-голям елемент.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Няма елементи с както по-малък, така и по-голям елемент.",
      "zh": "计算数组中至少有一个严格较小和一个严格较大元素的元素数量。\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // 没有元素同时具有较小和较大的元素。",
      "fr": "Compte le nombre d'éléments dans le tableau qui ont au moins un élément strictement plus petit et un élément strictement plus grand.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Il n'y a pas d'éléments avec à la fois un élément plus petit et un élément plus grand.",
      "de": "Zählt die Anzahl der Elemente im Array, die mindestens ein strikt kleineres und ein strikt größeres Element haben.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Es gibt keine Elemente mit sowohl einem kleineren als auch einem größeren Element.",
      "ha": "Counts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Daya tilo daga cikin abubuwa '2' yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Daya tilo daga cikin abubuwa '2' yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Babu abubuwa da ke da ƙarami da babba abu.",
      "hi": "गिनती करता है कि कितने तत्व ऐसे हैं जिनके पास कम से कम एक सख्ती से छोटा और एक सख्ती से बड़ा तत्व है।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // ऐसे कोई तत्व नहीं हैं जिनके पास एक छोटा और एक बड़ा तत्व हो।",
      "hu": "Számolja meg azokat az elemeket a tömbben, amelyeknek van legalább egy szigorúan kisebb és egy szigorúan nagyobb eleme.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nincsenek olyan elemek, amelyeknek mind kisebb, mind nagyobb eleme lenne."
    },
    "docstring_bertscore": {
      "sq": "0.9725758978120371",
      "hy": "0.996220063848906",
      "bn": "0.9802408455857924",
      "bg": "1",
      "zh": "0.966124184405643",
      "fr": "0.9706384570754228",
      "de": "1",
      "ha": "0.9693431883606943",
      "hi": "0.9584115653404393",
      "hu": "0.9789147891620035"
    }
  },
  {
    "task_id": "Swift/7",
    "prompt": {
      "en": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/",
      "sq": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nDyfishon vazhdimisht vlerën e 'original' nëse gjendet në vargun 'nums'.\nKthen vlerën përfundimtare të 'original' pasi të përsëritet ky proces.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 gjendet, bëhet 6; 6 gjendet, bëhet 12; 12 gjendet, bëhet 24; 24 nuk gjendet.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nuk gjendet, original mbetet 4.\n*/",
      "hy": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nՇարունակաբար կրկնապատկում է 'original'-ի արժեքը, եթե այն գտնվի 'nums' զանգվածում:\nՎերադարձնում է 'original'-ի վերջնական արժեքը այս գործընթացը կրկնելուց հետո:\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3-ը գտնվեց, դառնում է 6; 6-ը գտնվեց, դառնում է 12; 12-ը գտնվեց, դառնում է 24; 24-ը չի գտնվել:\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4-ը չի գտնվել, original-ը մնում է 4:\n*/",
      "bn": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n'original' মানটি যদি 'nums' অ্যারেতে পাওয়া যায় তবে এটি ক্রমাগত দ্বিগুণ হয়।\nএই প্রক্রিয়া পুনরাবৃত্তি করার পরে 'original' এর চূড়ান্ত মানটি ফেরত দেয়।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 পাওয়া যায়, 6 হয়; 6 পাওয়া যায়, 12 হয়; 12 পাওয়া যায়, 24 হয়; 24 পাওয়া যায় না।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 পাওয়া যায় না, original 4 থাকে।\n*/",
      "bg": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nНепрекъснато удвоява стойността на 'original', ако тя се намери в масива 'nums'.\nВръща крайната стойност на 'original' след повтаряне на този процес.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 е намерено, става 6; 6 е намерено, става 12; 12 е намерено, става 24; 24 не е намерено.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 не е намерено, original остава 4.\n*/",
      "zh": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n如果在数组 'nums' 中找到 'original' 的值，则不断将其加倍。\n返回重复此过程后的 'original' 的最终值。\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 找到 3，变为 6；找到 6，变为 12；找到 12，变为 24；24 未找到。\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 未找到，original 保持为 4。\n*/",
      "fr": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nDouble continuellement la valeur de 'original' si elle est trouvée dans le tableau 'nums'.\nRenvoie la valeur finale de 'original' après avoir répété ce processus.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 est trouvé, devient 6; 6 est trouvé, devient 12; 12 est trouvé, devient 24; 24 non trouvé.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 n'est pas trouvé, original reste 4.\n*/",
      "de": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nVerdoppelt kontinuierlich den Wert von 'original', wenn er im Array 'nums' gefunden wird.\nGibt den Endwert von 'original' zurück, nachdem dieser Prozess wiederholt wurde.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 wird gefunden, wird zu 6; 6 wird gefunden, wird zu 12; 12 wird gefunden, wird zu 24; 24 wird nicht gefunden.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 wird nicht gefunden, original bleibt 4.\n*/",
      "ha": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nA ci gaba da ninka ƙimar 'original' idan an same shi a cikin jerin 'nums'.\nDawowa da ƙimar ƙarshe na 'original' bayan maimaita wannan tsari.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 an same shi, ya zama 6; 6 an same shi, ya zama 12; 12 an same shi, ya zama 24; 24 ba a same shi ba.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 ba a same shi ba, original ya kasance 4.\n*/",
      "hi": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n'original' के मान को लगातार दोगुना करता है यदि यह 'nums' array में पाया जाता है।\nइस प्रक्रिया को दोहराने के बाद 'original' का अंतिम मान लौटाता है।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 पाया गया, 6 बन जाता है; 6 पाया गया, 12 बन जाता है; 12 पाया गया, 24 बन जाता है; 24 नहीं पाया गया।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 नहीं पाया गया, original 4 ही रहता है।\n*/",
      "hu": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nFolyamatosan megduplázza az 'original' értékét, ha az megtalálható a 'nums' tömbben.\nVisszaadja az 'original' végső értékét a folyamat ismétlése után.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 megtalálható, 6 lesz belőle; 6 megtalálható, 12 lesz belőle; 12 megtalálható, 24 lesz belőle; 24 nem található.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nem található, az eredeti marad 4.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9897246517586842",
      "hy": "0.9901836865692558",
      "bn": "0.9712323619147172",
      "bg": "0.9982111347883998",
      "zh": "0.9554785891340781",
      "fr": "0.9991566154021259",
      "de": "0.9931585737860154",
      "ha": "0.9831043011587913",
      "hi": "0.9798092217678036",
      "hu": "0.9799717014194902"
    },
    "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}",
    "instruction": {
      "en": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nনিচের Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Swift a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9165571646006728",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)",
    "entry_point": "findFinalValue",
    "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {",
    "docstring": {
      "en": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n",
      "sq": "Vazhdimisht dyfishon vlerën e 'original' nëse gjendet në vargun 'nums'.\nKthen vlerën përfundimtare të 'original' pasi të përsëritet ky proces.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 gjendet, bëhet 6; 6 gjendet, bëhet 12; 12 gjendet, bëhet 24; 24 nuk gjendet.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nuk gjendet, original mbetet 4.",
      "hy": "Շարունակաբար կրկնապատկում է 'original'-ի արժեքը, եթե այն գտնվի 'nums' զանգվածում:\nՎերադարձնում է 'original'-ի վերջնական արժեքը այս գործընթացը կրկնելուց հետո:\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3-ը գտնվեց, դարձավ 6; 6-ը գտնվեց, դարձավ 12; 12-ը գտնվեց, դարձավ 24; 24-ը չգտնվեց:\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4-ը չգտնվեց, original-ը մնաց 4:",
      "bn": "'original' এর মান 'nums' অ্যারেতে পাওয়া গেলে ক্রমাগত দ্বিগুণ করে। এই প্রক্রিয়া পুনরাবৃত্তির পরে 'original' এর চূড়ান্ত মান ফেরত দেয়।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 পাওয়া যায়, 6 হয়; 6 পাওয়া যায়, 12 হয়; 12 পাওয়া যায়, 24 হয়; 24 পাওয়া যায় না।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 পাওয়া যায় না, original 4 থাকে।",
      "bg": "Непрекъснато удвоява стойността на 'original', ако тя се намери в масива 'nums'.  \nВръща крайната стойност на 'original' след повтаряне на този процес.  \n>>> findFinalValue([5, 3, 6, 1, 12], 3)  \n24 // 3 се намира, става 6; 6 се намира, става 12; 12 се намира, става 24; 24 не се намира.  \n>>> findFinalValue([2, 7, 9], 4)  \n4 // 4 не се намира, original остава 4.  ",
      "zh": "连续将“original”的值加倍，如果在数组“nums”中找到它。\n返回重复此过程后的“original”的最终值。\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 找到 3，变为 6；找到 6，变为 12；找到 12，变为 24；24 未找到。\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 未找到，original 保持为 4。",
      "fr": "Double continuellement la valeur de 'original' si elle est trouvée dans le tableau 'nums'.\nRenvoie la valeur finale de 'original' après avoir répété ce processus.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 est trouvé, devient 6 ; 6 est trouvé, devient 12 ; 12 est trouvé, devient 24 ; 24 non trouvé.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 n'est pas trouvé, original reste 4.",
      "de": "Verdoppelt kontinuierlich den Wert von 'original', wenn er im Array 'nums' gefunden wird.\nGibt den endgültigen Wert von 'original' zurück, nachdem dieser Prozess wiederholt wurde.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 wird gefunden, wird zu 6; 6 wird gefunden, wird zu 12; 12 wird gefunden, wird zu 24; 24 wird nicht gefunden.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 wird nicht gefunden, original bleibt 4.",
      "ha": "Yana ci gaba da ninka ƙimar 'original' idan an same shi a cikin jerin 'nums'. \nYa dawo da ƙimar ƙarshe na 'original' bayan maimaita wannan tsari.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 an same shi, ya zama 6; 6 an same shi, ya zama 12; 12 an same shi, ya zama 24; 24 ba a same shi ba.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 ba a same shi ba, original ya kasance 4.",
      "hi": "निरंतर 'original' के मान को दोगुना करता है यदि यह 'nums' array में पाया जाता है।\nइस प्रक्रिया को दोहराने के बाद 'original' का अंतिम मान लौटाता है।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 पाया जाता है, 6 बन जाता है; 6 पाया जाता है, 12 बन जाता है; 12 पाया जाता है, 24 बन जाता है; 24 नहीं पाया जाता।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 नहीं पाया जाता, original 4 ही रहता है।",
      "hu": "Folyamatosan megduplázza az 'original' értékét, ha megtalálható a 'nums' tömbben.\nVisszaadja az 'original' végső értékét a folyamat ismétlése után.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 megtalálva, 6 lesz belőle; 6 megtalálva, 12 lesz belőle; 12 megtalálva, 24 lesz belőle; 24 nem található.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nem található, az eredeti marad 4."
    },
    "docstring_bertscore": {
      "sq": "0.9869893127814527",
      "hy": "0.9800640645466714",
      "bn": "0.9458599129324636",
      "bg": "0.997278565149441",
      "zh": "0.9680824813322659",
      "fr": "0.995901063456964",
      "de": "0.9883088144026675",
      "ha": "0.9630197901804487",
      "hi": "0.9865088258897293",
      "hu": "0.9702417922044961"
    }
  },
  {
    "task_id": "Swift/8",
    "prompt": {
      "en": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "sq": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nRiorendon vargun 'nums' duke renditur indeksat tek në rend zbritës dhe indeksat çift në rend rritës.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indekset çift (0, 2) të renditura si [2, 4], indekset tek (1, 3) të renditura si [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "hy": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nՎերադասավորում է 'nums' զանգվածը՝ զույգ ինդեքսները դասավորելով չնվազող կարգով և կենտ ինդեքսները՝ չաճող կարգով։\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Զույգ ինդեքսները (0, 2) դասավորված են որպես [2, 4], կենտ ինդեքսները (1, 3) դասավորված են որպես [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "bn": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nঅ্যারে 'nums' পুনর্বিন্যাস করে যাতে বিজোড় সূচকগুলি অবনমিত ক্রমে সাজানো হয় এবং জোড় সূচকগুলি আরোহী ক্রমে সাজানো হয়।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // জোড় সূচক (0, 2) সাজানো হয়েছে [2, 4] হিসাবে, বিজোড় সূচক (1, 3) সাজানো হয়েছে [3, 1] হিসাবে।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "bg": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nПреурежда масива 'nums', като сортира нечетните индекси в низходящ ред и четните индекси във възходящ ред.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Четните индекси (0, 2) сортирани като [2, 4], нечетните индекси (1, 3) сортирани като [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "zh": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\n将数组 'nums' 重新排序，偶数索引按非递减顺序排序，奇数索引按非递增顺序排序。\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // 偶数索引 (0, 2) 排序为 [2, 4]，奇数索引 (1, 3) 排序为 [3, 1]。\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "fr": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nRéorganise le tableau 'nums' en triant les indices impairs par ordre décroissant et les indices pairs par ordre croissant.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indices pairs (0, 2) triés comme [2, 4], indices impairs (1, 3) triés comme [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "de": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nOrdnet das Array 'nums' neu, indem ungerade Indizes in nicht-zunehmender Reihenfolge und gerade Indizes in nicht-abnehmender Reihenfolge sortiert werden.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Gerade Indizes (0, 2) sortiert als [2, 4], ungerade Indizes (1, 3) sortiert als [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "ha": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nSake tsara jerin 'nums' ta hanyar tsara alamomin da ba su daidai ba a cikin tsari mai raguwa kuma alamomin da suka dace a cikin tsari mai karuwa.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Alamomin da suka dace (0, 2) an tsara su kamar [2, 4], alamomin da ba su dace ba (1, 3) an tsara su kamar [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "hi": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\n'nums' array को पुनः क्रमबद्ध करता है ताकि विषम सूचकांक घटते क्रम में और सम सूचकांक बढ़ते क्रम में व्यवस्थित हों।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // सम सूचकांक (0, 2) को [2, 4] के रूप में क्रमबद्ध किया गया, विषम सूचकांक (1, 3) को [3, 1] के रूप में क्रमबद्ध किया गया।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "hu": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nÚjrarendezi a 'nums' tömböt úgy, hogy a páratlan indexeket nem növekvő sorrendbe, a páros indexeket pedig nem csökkenő sorrendbe rendezi.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Páros indexek (0, 2) rendezve: [2, 4], páratlan indexek (1, 3) rendezve: [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.953884183065511",
      "hy": "0.9720004655981791",
      "bn": "0.9572638789988197",
      "bg": "0.9554829590024608",
      "zh": "0.9855198452225566",
      "fr": "0.9564449259378128",
      "de": "1",
      "ha": "0.9527619214126639",
      "hi": "0.9550982119543963",
      "hu": "0.9638997227684332"
    },
    "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}",
    "instruction": {
      "en": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nՏվյալ Swift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки не повече от 500 знака.",
      "zh": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8825260200483465",
      "bn": "0.8779922816012251",
      "bg": "0.9346778170017236",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9217926641839904",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)",
    "entry_point": "reorderArray",
    "signature": "func reorderArray(_ nums: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n",
      "sq": "Riorganizon vargun 'nums' duke renditur indeksat tek në rend zbritës dhe indeksat çift në rend rritës.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indeksat çift (0, 2) të renditura si [2, 4], indeksat tek (1, 3) të renditura si [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hy": "Վերադասավորում է 'nums' զանգվածը՝ զույգ ինդեքսները դասավորելով աճման կարգով և կենտ ինդեքսները՝ նվազման կարգով:\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Զույգ ինդեքսները (0, 2) դասավորված են որպես [2, 4], կենտ ինդեքսները (1, 3) դասավորված են որպես [3, 1]:\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "bn": "অ্যারে 'nums' পুনর্বিন্যাস করে যাতে বিজোড় সূচকগুলি অবনমিত ক্রমে এবং জোড় সূচকগুলি আরোহী ক্রমে সাজানো হয়।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // জোড় সূচক (0, 2) সাজানো হয়েছে [2, 4] হিসাবে, বিজোড় সূচক (1, 3) সাজানো হয়েছে [3, 1] হিসাবে।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "bg": "Преурежда масива 'nums', като сортира нечетните индекси в намаляващ ред и четните индекси в нарастващ ред.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Четните индекси (0, 2) сортирани като [2, 4], нечетните индекси (1, 3) сортирани като [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "zh": "重新排序数组 'nums'，通过将奇数索引按非递增顺序排序和偶数索引按非递减顺序排序。\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // 偶数索引 (0, 2) 排序为 [2, 4]，奇数索引 (1, 3) 排序为 [3, 1]。\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "fr": "Réorganise le tableau 'nums' en triant les indices impairs par ordre décroissant et les indices pairs par ordre croissant.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indices pairs (0, 2) triés comme [2, 4], indices impairs (1, 3) triés comme [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "de": "Ordnet das Array 'nums' neu, indem ungerade Indizes in nicht-zunehmender Reihenfolge und gerade Indizes in nicht-abnehmender Reihenfolge sortiert werden.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Gerade Indizes (0, 2) sortiert als [2, 4], ungerade Indizes (1, 3) sortiert als [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "ha": "Sake tsara jerin 'nums' ta hanyar tsara alamun lambobi masu ban mamaki a cikin tsari mai raguwa kuma alamun lambobi masu ma'ana a cikin tsari mai karuwa.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Alamun lambobi masu ma'ana (0, 2) an tsara su kamar [2, 4], alamun lambobi masu ban mamaki (1, 3) an tsara su kamar [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hi": "'nums' array को पुनः क्रमबद्ध करता है, जिसमें विषम सूचकांक को अवरोही क्रम में और सम सूचकांक को आरोही क्रम में क्रमबद्ध किया जाता है।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // सम सूचकांक (0, 2) को [2, 4] के रूप में क्रमबद्ध किया गया, विषम सूचकांक (1, 3) को [3, 1] के रूप में क्रमबद्ध किया गया।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hu": "Átrendezi a 'nums' tömböt úgy, hogy a páratlan indexeket nem növekvő sorrendbe, a páros indexeket pedig nem csökkenő sorrendbe rendezi.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Páros indexek (0, 2) rendezve [2, 4], páratlan indexek (1, 3) rendezve [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]"
    },
    "docstring_bertscore": {
      "sq": "0.9457224607087875",
      "hy": "0.9394139598071194",
      "bn": "0.9398561110353031",
      "bg": "0.9536825732287606",
      "zh": "0.9964852354075876",
      "fr": "0.9427553200768883",
      "de": "0.9914741881548395",
      "ha": "0.9343353782248194",
      "hi": "0.9398082411134737",
      "hu": "0.9460070980448105"
    }
  },
  {
    "task_id": "Swift/9",
    "prompt": {
      "en": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/",
      "sq": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nNumëron numrin e çifteve (i, j) në vargun 'nums' ku nums[i] == nums[j] dhe (i * j) është i pjesëtueshëm me 'k'.\nKushtet: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftet (0, 3) plotësojnë kushtet.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Të gjitha çiftet plotësojnë kushtet pasi çdo (i * j) është i pjesëtueshëm me 1.\n*/",
      "hy": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nՀաշվում է զույգերի (i, j) քանակը 'nums' զանգվածում, որտեղ nums[i] == nums[j] և (i * j)-ն բաժանվում է 'k'-ի վրա:\nՊայմաններ: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Զույգերը (0, 3) բավարարում են պայմանները:\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Բոլոր զույգերը բավարարում են պայմանները, քանի որ յուրաքանչյուր (i * j) բաժանվում է 1-ի վրա:\n*/",
      "bn": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nঅ্যারে 'nums' এর মধ্যে (i, j) জোড়ার সংখ্যা গণনা করে যেখানে nums[i] == nums[j] এবং (i * j) 'k' দ্বারা বিভাজ্য।\nশর্তাবলী: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // জোড়া (0, 3) শর্তগুলি পূরণ করে।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // সমস্ত জোড়া শর্তগুলি পূরণ করে কারণ প্রতিটি (i * j) 1 দ্বারা বিভাজ্য।\n*/",
      "bg": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nБрои броя на двойките (i, j) в масива 'nums', където nums[i] == nums[j] и (i * j) се дели на 'k'.\nУсловия: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Двойката (0, 3) отговаря на условията.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Всички двойки отговарят на условията, тъй като всяко (i * j) се дели на 1.\n*/",
      "zh": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\n计算数组 'nums' 中满足 nums[i] == nums[j] 且 (i * j) 能被 'k' 整除的对数 (i, j)。\n条件: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // 对 (0, 3) 满足条件。\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // 所有对都满足条件，因为每个 (i * j) 都能被 1 整除。\n*/",
      "fr": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCompte le nombre de paires (i, j) dans le tableau 'nums' où nums[i] == nums[j] et (i * j) est divisible par 'k'.\nConditions : 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Les paires (0, 3) satisfont les conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Toutes les paires satisfont les conditions puisque chaque (i * j) est divisible par 1.\n*/",
      "de": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nZählt die Anzahl der Paare (i, j) im Array 'nums', bei denen nums[i] == nums[j] und (i * j) durch 'k' teilbar ist.\nBedingungen: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Die Paare (0, 3) erfüllen die Bedingungen.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Alle Paare erfüllen die Bedingungen, da jedes (i * j) durch 1 teilbar ist.\n*/",
      "ha": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nYana ƙidaya adadin ma'aurata (i, j) a cikin jerin 'nums' inda nums[i] == nums[j] kuma (i * j) yana raba 'k' ba tare da saura ba.\nYanayi: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Ma'aurata (0, 3) suna cika yanayin.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Duk ma'aurata suna cika yanayin tunda kowane (i * j) yana raba 1 ba tare da saura ba.\n*/",
      "hi": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nगणना करता है कि 'nums' array में कितने जोड़े (i, j) हैं जहाँ nums[i] == nums[j] और (i * j) 'k' से विभाज्य है।\nशर्तें: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // जोड़े (0, 3) शर्तों को पूरा करते हैं।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // सभी जोड़े शर्तों को पूरा करते हैं क्योंकि हर (i * j) 1 से विभाज्य है।\n*/",
      "hu": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nMegszámolja azokat a párokat (i, j) a 'nums' tömbben, ahol nums[i] == nums[j] és (i * j) osztható 'k'-val.\nFeltételek: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // A (0, 3) párok teljesítik a feltételeket.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Minden pár teljesíti a feltételeket, mivel minden (i * j) osztható 1-gyel.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9915355649425793",
      "hy": "0.9849684472848038",
      "bn": "0.9857909756926693",
      "bg": "0.9843310423920628",
      "zh": "0.9725715279436543",
      "fr": "0.9879800811220548",
      "de": "0.9841975627760075",
      "ha": "0.951600926835515",
      "hi": "0.9774705476614989",
      "hu": "0.9733660494677939"
    },
    "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}",
    "instruction": {
      "en": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.879147913158086",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)",
    "entry_point": "countDivisiblePairs",
    "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n",
      "sq": "Numëron numrin e çifteve (i, j) në vargun 'nums' ku nums[i] == nums[j] dhe (i * j) është i pjestueshëm me 'k'.\nKushtet: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftet (0, 3) plotësojnë kushtet.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Të gjitha çiftet plotësojnë kushtet pasi çdo (i * j) është i pjestueshëm me 1.",
      "hy": "Հաշվում է զույգերի (i, j) քանակը 'nums' զանգվածում, որտեղ nums[i] == nums[j] և (i * j) բաժանվում է 'k'-ի վրա:\nՊայմաններ: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Զույգերը (0, 3) բավարարում են պայմանները։\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Բոլոր զույգերը բավարարում են պայմանները, քանի որ յուրաքանչյուր (i * j) բաժանվում է 1-ի վրա։",
      "bn": "সংখ্যা গণনা করে (i, j) জোড়ার সংখ্যা 'nums' অ্যারেতে যেখানে nums[i] == nums[j] এবং (i * j) 'k' দ্বারা বিভাজ্য।\nশর্তাবলী: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // জোড়া (0, 3) শর্তগুলি পূরণ করে।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // সমস্ত জোড়া শর্তগুলি পূরণ করে কারণ প্রতিটি (i * j) 1 দ্বারা বিভাজ্য।",
      "bg": "Брои броя на двойките (i, j) в масива 'nums', където nums[i] == nums[j] и (i * j) е делимо на 'k'.\nУсловия: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Двойката (0, 3) удовлетворява условията.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Всички двойки удовлетворяват условията, тъй като всяко (i * j) е делимо на 1.",
      "zh": "计算数组 'nums' 中满足 nums[i] == nums[j] 且 (i * j) 能被 'k' 整除的对数 (i, j)。\n条件: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // 对 (0, 3) 满足条件。\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // 所有对都满足条件，因为每个 (i * j) 都能被 1 整除。",
      "fr": "Compte le nombre de paires (i, j) dans le tableau 'nums' où nums[i] == nums[j] et (i * j) est divisible par 'k'.\nConditions : 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Les paires (0, 3) satisfont les conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Toutes les paires satisfont les conditions puisque chaque (i * j) est divisible par 1.",
      "de": "Zählt die Anzahl der Paare (i, j) im Array 'nums', bei denen nums[i] == nums[j] und (i * j) durch 'k' teilbar ist.\nBedingungen: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Die Paare (0, 3) erfüllen die Bedingungen.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Alle Paare erfüllen die Bedingungen, da jedes (i * j) durch 1 teilbar ist.",
      "ha": "Yana ƙididdige adadin ma'aurata (i, j) a cikin jerin 'nums' inda nums[i] == nums[j] kuma (i * j) yana rarrabuwa da 'k'.\nYanayi: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Ma'aurata (0, 3) suna cika yanayin.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Duk ma'aurata suna cika yanayin tunda kowanne (i * j) yana rarrabuwa da 1.",
      "hi": "गिनती करता है कि 'nums' array में कितने जोड़े (i, j) हैं जहाँ nums[i] == nums[j] और (i * j) 'k' से विभाज्य है।\nशर्तें: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // जोड़े (0, 3) शर्तों को पूरा करते हैं।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // सभी जोड़े शर्तों को पूरा करते हैं क्योंकि हर (i * j) 1 से विभाज्य है।",
      "hu": "Számolja meg az 'nums' tömbben az (i, j) párok számát, ahol nums[i] == nums[j] és (i * j) osztható 'k'-val.\nFeltételek: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // A (0, 3) párok megfelelnek a feltételeknek.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Minden pár megfelel a feltételeknek, mivel minden (i * j) osztható 1-gyel."
    },
    "docstring_bertscore": {
      "sq": "0.9894429938783768",
      "hy": "0.9829749927807376",
      "bn": "0.9658097525124647",
      "bg": "0.9879790879701495",
      "zh": "0.949414204970702",
      "fr": "0.9793547554559958",
      "de": "0.9845527138972978",
      "ha": "0.9664477532963488",
      "hi": "0.9745308180221824",
      "hu": "0.9693135924339201"
    }
  },
  {
    "task_id": "Swift/10",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n*/",
      "sq": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nNumëron numrin e vargjeve në vargun 'words' që fillojnë me parashtesën 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", dhe \"application\" fillojnë me \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Vetëm \"hello\" fillon me \"he\".\n*/",
      "hy": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nՀաշվում է 'words' զանգվածում այն տողերի քանակը, որոնք սկսվում են 'pref' նախածանցով։\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", և \"application\" սկսվում են \"app\"-ով։\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Միայն \"hello\" սկսվում է \"he\"-ով։\n*/",
      "bn": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nঅ্যারে 'words'-এর মধ্যে কতগুলি স্ট্রিং 'pref' উপসর্গ দিয়ে শুরু হয় তা গণনা করে।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", এবং \"application\" \"app\" দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // শুধুমাত্র \"hello\" \"he\" দিয়ে শুরু হয়।\n*/",
      "bg": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nБрои броя на низовете в масива 'words', които започват с префикса 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" и \"application\" започват с \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Само \"hello\" започва с \"he\".\n*/",
      "zh": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\n计算数组 'words' 中以前缀 'pref' 开头的字符串数量。\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", 和 \"application\" 以 \"app\" 开头。\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // 只有 \"hello\" 以 \"he\" 开头。\n*/",
      "fr": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCompte le nombre de chaînes dans le tableau 'words' qui commencent par le préfixe 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", et \"application\" commencent par \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Seul \"hello\" commence par \"he\".\n*/",
      "de": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nZählt die Anzahl der Zeichenfolgen im Array 'words', die mit dem Präfix 'pref' beginnen.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" und \"application\" beginnen mit \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Nur \"hello\" beginnt mit \"he\".\n*/",
      "ha": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nYana ƙididdige adadin igiyoyi a cikin jerin 'words' waɗanda suka fara da maƙallan 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", da \"application\" suna farawa da \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sai dai \"hello\" ne kawai yake farawa da \"he\".\n*/",
      "hi": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nगणना करता है कि 'words' नामक array में कितने strings 'pref' उपसर्ग से शुरू होते हैं।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", और \"application\" \"app\" से शुरू होते हैं।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // केवल \"hello\" \"he\" से शुरू होता है।\n*/",
      "hu": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nMegszámolja azokat a sztringeket a 'words' tömbben, amelyek a 'pref' előtaggal kezdődnek.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // Az \"apple\", \"app\" és \"application\" az \"app\"-pal kezdődik.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Csak a \"hello\" kezdődik a \"he\"-vel.\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9867261275265815",
      "bn": "0.9863977915067309",
      "bg": "1",
      "zh": "0.992137613627496",
      "fr": "1",
      "de": "0.9969601606486421",
      "ha": "0.9945620960584078",
      "hi": "0.985271358615882",
      "hu": "0.9775206025175196"
    },
    "canonical_solution": "return words.filter { $0.hasPrefix(pref) }.count\n}",
    "instruction": {
      "en": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9240495025733088",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkCountPrefixStrings(_ countPrefixStrings: ([String], String) -> Int) {\nassert(countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\") == 3)\nassert(countPrefixStrings([\"hello\", \"world\"], \"he\") == 1)\nassert(countPrefixStrings([\"python\", \"php\", \"perl\", \"java\"], \"p\") == 3)\nassert(countPrefixStrings([\"swift\", \"scala\"], \"s\") == 2)\nassert(countPrefixStrings([\"go\", \"rust\", \"ruby\"], \"c\") == 0)\nassert(countPrefixStrings([], \"test\") == 0)\nassert(countPrefixStrings([\"prefix\", \"preference\", \"preliminary\"], \"pre\") == 3)\n}\n\ncheckCountPrefixStrings(countPrefixStrings)",
    "entry_point": "countPrefixStrings",
    "signature": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n",
      "sq": "Numëron numrin e vargjeve në vargun 'words' që fillojnë me parashtesën 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", dhe \"application\" fillojnë me \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Vetëm \"hello\" fillon me \"he\".",
      "hy": "Հաշվում է 'words' զանգվածում այն տողերի քանակը, որոնք սկսվում են 'pref' նախածանցով։\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" և \"application\" սկսվում են \"app\"-ով։\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Միայն \"hello\"-ն սկսվում է \"he\"-ով։",
      "bn": "গণনা করে কতগুলি স্ট্রিং অ্যারে 'words'-এ আছে যা 'pref' উপসর্গ দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", এবং \"application\" \"app\" দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // শুধুমাত্র \"hello\" \"he\" দিয়ে শুরু হয়।",
      "bg": "Брои броя на низовете в масива 'words', които започват с префикса 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" и \"application\" започват с \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Само \"hello\" започва с \"he\".",
      "zh": "计算数组 'words' 中以前缀 'pref' 开头的字符串数量。\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"、\"app\" 和 \"application\" 以 \"app\" 开头。\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // 只有 \"hello\" 以 \"he\" 开头。",
      "fr": "Compte le nombre de chaînes dans le tableau 'words' qui commencent par le préfixe 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" et \"application\" commencent par \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Seul \"hello\" commence par \"he\".",
      "de": "Zählt die Anzahl der Zeichenfolgen im Array 'words', die mit dem Präfix 'pref' beginnen.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" und \"application\" beginnen mit \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Nur \"hello\" beginnt mit \"he\".",
      "ha": "Yana ƙidaya adadin kirtani a cikin jerin 'words' waɗanda suka fara da farkon 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", da \"application\" suna farawa da \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sai dai \"hello\" ne kawai ke farawa da \"he\".",
      "hi": "गिनती करता है कि 'words' एरे में कितने स्ट्रिंग्स 'pref' उपसर्ग से शुरू होते हैं।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", और \"application\" \"app\" से शुरू होते हैं।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // केवल \"hello\" \"he\" से शुरू होता है।",
      "hu": "Számolja meg a 'words' tömbben lévő azon sztringek számát, amelyek a 'pref' előtaggal kezdődnek.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // Az \"apple\", \"app\" és \"application\" az \"app\" előtaggal kezdődik.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Csak a \"hello\" kezdődik a \"he\" előtaggal."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9817083268408782",
      "bn": "0.968493050329865",
      "bg": "1",
      "zh": "0.9867922714434662",
      "fr": "0.9926359772535126",
      "de": "1",
      "ha": "0.9836247127571028",
      "hi": "0.9800753864783903",
      "hu": "0.9571711186108763"
    }
  },
  {
    "task_id": "Swift/11",
    "prompt": {
      "en": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/",
      "sq": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nHeq në mënyrë të përsëritur një element nga 'words' në indeksin 'i' nëse 'words[i]' dhe 'words[i - 1]' janë anagrame,\nderisa të mos mbeten më çifte të tilla. Kthen vargun e modifikuar 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" dhe \"dc\" hiqen pasi janë anagrame të elementeve të mëparshme.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Heqja e njëpasnjëshme e anagrameve rezulton në [\"abc\", \"bac\"], pastaj [\"abc\"].\n*/",
      "hy": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nԿրկնվող կերպով հեռացնում է 'words'-ից 'i' ինդեքսում գտնվող տարրը, եթե 'words[i]' և 'words[i - 1]' բառերը անագրամներ են,\nմինչև այլևս նման զույգեր չլինեն: Վերադարձնում է փոփոխված 'words' զանգվածը:\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\"-ն և \"dc\"-ն հեռացվում են, քանի որ դրանք իրենց նախորդ տարրերի անագրամներն են:\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Անագրամների հաջորդական հեռացումը բերում է [\"abc\", \"bac\"], ապա [\"abc\"]:\n*/",
      "bn": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n'words' এর একটি উপাদান 'i' সূচকে বারবার অপসারণ করে যদি 'words[i]' এবং 'words[i - 1]' অ্যানাগ্রাম হয়,\nযতক্ষণ না এমন কোন জোড়া অবশিষ্ট থাকে না। পরিবর্তিত 'words' অ্যারে ফেরত দেয়।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" এবং \"dc\" অপসারণ করা হয় কারণ তারা তাদের পূর্ববর্তী উপাদানের অ্যানাগ্রাম।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // অ্যানাগ্রামগুলির ক্রমানুসারে অপসারণের ফলে [\"abc\", \"bac\"], তারপর [\"abc\"] হয়।\n*/",
      "bg": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nМногократно премахва елемент от 'words' на индекс 'i', ако 'words[i]' и 'words[i - 1]' са анаграми,\nдокато не останат такива двойки. Връща модифицирания масив 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" и \"dc\" са премахнати, тъй като са анаграми на предходните си елементи.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Последователното премахване на анаграми води до [\"abc\", \"bac\"], след това [\"abc\"].\n*/",
      "zh": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n重复地从 'words' 中移除索引 'i' 处的元素，如果 'words[i]' 和 'words[i - 1]' 是变位词，\n直到没有这样的对为止。返回修改后的 'words' 数组。\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" 和 \"dc\" 被移除，因为它们是其前一个元素的变位词。\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // 连续移除变位词结果为 [\"abc\", \"bac\"]，然后 [\"abc\"]。\n*/",
      "fr": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nSupprime de manière répétée un élément de 'words' à l'indice 'i' si 'words[i]' et 'words[i - 1]' sont des anagrammes,\njusqu'à ce qu'il ne reste plus de tels paires. Renvoie le tableau 'words' modifié.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" et \"dc\" sont supprimés car ce sont des anagrammes de leurs éléments précédents.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La suppression séquentielle des anagrammes aboutit à [\"abc\", \"bac\"], puis [\"abc\"].\n*/",
      "de": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nEntfernt wiederholt ein Element aus 'words' an Index 'i', wenn 'words[i]' und 'words[i - 1]' Anagramme sind,\nbis keine solchen Paare mehr vorhanden sind. Gibt das modifizierte 'words'-Array zurück.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" und \"dc\" werden entfernt, da sie Anagramme ihrer vorherigen Elemente sind.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Die sequentielle Entfernung von Anagrammen führt zu [\"abc\", \"bac\"], dann [\"abc\"].\n*/",
      "ha": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nAna cire wani abu daga cikin 'words' a ma'aunin 'i' idan 'words[i]' da 'words[i - 1]' suna da anagrams,\nhar sai babu irin waɗannan ma'aurata da suka rage. Ana mayar da jerin 'words' da aka gyara.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" da \"dc\" an cire su saboda suna da anagrams na abubuwan da suka gabata.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Cire anagrams a jere yana haifar da [\"abc\", \"bac\"], sannan [\"abc\"].\n*/",
      "hi": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n'words' से 'i' इंडेक्स पर तत्व को बार-बार हटाता है यदि 'words[i]' और 'words[i - 1]' एनाग्राम्स हैं,\nजब तक कि ऐसे जोड़े नहीं बचते। संशोधित 'words' array लौटाता है।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" और \"dc\" को हटा दिया जाता है क्योंकि वे उनके पिछले तत्वों के एनाग्राम्स हैं।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // एनाग्राम्स के क्रमिक हटाने से [\"abc\", \"bac\"], फिर [\"abc\"] प्राप्त होता है।\n*/",
      "hu": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nIsmételten eltávolít egy elemet a 'words' tömbből az 'i' indexnél, ha a 'words[i]' és a 'words[i - 1]' anagrammák,\namíg nincsenek ilyen párok. Visszaadja a módosított 'words' tömböt.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // A \"ba\" és a \"dc\" eltávolításra kerülnek, mivel anagrammák az előző elemeikhez képest.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Az anagrammák sorozatos eltávolítása eredményezi a [\"abc\", \"bac\"], majd a [\"abc\"] tömböt.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9826708896673733",
      "hy": "0.9746168249771706",
      "bn": "0.9904357485227891",
      "bg": "0.9815865664173038",
      "zh": "0.9801212700964095",
      "fr": "0.9941028626174552",
      "de": "0.9840213776280294",
      "ha": "0.9659456156930926",
      "hi": "0.9795905297182842",
      "hu": "0.9719819929727428"
    },
    "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}",
    "instruction": {
      "en": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nДайте кратко описание на кода на Swift на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.8990590198137853",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)",
    "entry_point": "removeAnagramWords",
    "signature": "func removeAnagramWords(_ words: [String]) -> [String] {",
    "docstring": {
      "en": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n",
      "sq": "Heq në mënyrë të përsëritur një element nga 'words' në indeksin 'i' nëse 'words[i]' dhe 'words[i - 1]' janë anagrame, deri sa të mos mbeten çifte të tilla. Kthen vargun e modifikuar 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" dhe \"dc\" hiqen pasi janë anagrame të elementeve të tyre të mëparshme.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Heqja e njëpasnjëshme e anagrameve rezulton në [\"abc\", \"bac\"], pastaj [\"abc\"].",
      "hy": "Կրկնվող կերպով հեռացնում է 'words'-ից այն տարրը, որը գտնվում է 'i' ինդեքսում, եթե 'words[i]' և 'words[i - 1]' տարրերը անագրամներ են, մինչև որ այլևս նման զույգեր չմնան։ Վերադարձնում է փոփոխված 'words' զանգվածը։\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" և \"dc\" հեռացվում են, քանի որ դրանք իրենց նախորդ տարրերի անագրամներն են։\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Անագրամների հաջորդական հեռացման արդյունքում ստացվում է [\"abc\", \"bac\"], ապա [\"abc\"]։",
      "bn": "Repeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams, until no such pairs are left. Returns the modified 'words' array. \n'words' তালিকা থেকে 'i' সূচকে একটি উপাদান বারবার সরিয়ে দেয় যদি 'words[i]' এবং 'words[i - 1]' অ্যানাগ্রাম হয়, যতক্ষণ না এমন কোনো জোড়া থাকে। পরিবর্তিত 'words' অ্যারে ফেরত দেয়।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" এবং \"dc\" সরানো হয়েছে কারণ তারা তাদের পূর্ববর্তী উপাদানের অ্যানাগ্রাম।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // অ্যানাগ্রামগুলির ধারাবাহিক অপসারণের ফলে [\"abc\", \"bac\"], তারপর [\"abc\"] হয়।",
      "bg": "Повтарящо се премахва елемент от 'words' на индекс 'i', ако 'words[i]' и 'words[i - 1]' са анаграми, докато не останат такива двойки. Връща модифицирания масив 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" и \"dc\" са премахнати, тъй като са анаграми на предходните си елементи.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Последователното премахване на анаграми води до [\"abc\", \"bac\"], след това [\"abc\"].",
      "zh": "反复从 'words' 中移除索引 'i' 处的元素，如果 'words[i]' 和 'words[i - 1]' 是字谜，直到没有这样的对出现。返回修改后的 'words' 数组。\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" 和 \"dc\" 被移除，因为它们是其前一个元素的字谜。\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // 连续移除字谜结果为 [\"abc\", \"bac\"]，然后是 [\"abc\"]。",
      "fr": "Supprime de manière répétée un élément de 'words' à l'index 'i' si 'words[i]' et 'words[i - 1]' sont des anagrammes, jusqu'à ce qu'il ne reste plus de tels paires. Renvoie le tableau 'words' modifié.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" et \"dc\" sont supprimés car ce sont des anagrammes de leurs éléments précédents.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La suppression séquentielle des anagrammes aboutit à [\"abc\", \"bac\"], puis [\"abc\"].",
      "de": "Entfernt wiederholt ein Element aus 'words' an der Position 'i', wenn 'words[i]' und 'words[i - 1]' Anagramme sind, bis keine solchen Paare mehr vorhanden sind. Gibt das modifizierte 'words'-Array zurück.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" und \"dc\" werden entfernt, da sie Anagramme ihrer vorherigen Elemente sind.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Die sequentielle Entfernung von Anagrammen führt zu [\"abc\", \"bac\"], dann [\"abc\"].",
      "ha": "Sosai yana cire wani abu daga 'words' a wurin 'i' idan 'words[i]' da 'words[i - 1]' anagrams ne,\nhar sai babu irin waɗannan ma'aurata da suka rage. Yana mayar da gyararren jerin 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" da \"dc\" an cire su saboda suna anagrams na abubuwan da suka gabata.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Cire anagrams a jere yana haifar da [\"abc\", \"bac\"], sannan [\"abc\"].",
      "hi": "बार-बार 'words' से 'i' इंडेक्स पर तत्व को हटाता है यदि 'words[i]' और 'words[i - 1]' एनाग्राम हैं, जब तक कि ऐसे कोई जोड़े नहीं बचते। संशोधित 'words' array लौटाता है।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" और \"dc\" को हटा दिया जाता है क्योंकि वे अपने पिछले तत्वों के एनाग्राम हैं।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // एनाग्राम के क्रमिक हटाने से परिणाम होता है [\"abc\", \"bac\"], फिर [\"abc\"]।",
      "hu": "Ismételten eltávolít egy elemet a 'words' listából az 'i' indexnél, ha a 'words[i]' és a 'words[i - 1]' anagrammák, amíg ilyen párok nem maradnak. Visszaadja a módosított 'words' tömböt.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // A \"ba\" és a \"dc\" eltávolításra kerül, mivel anagrammák az előző elemeikkel.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Az anagrammák sorozatos eltávolítása eredményezi a [\"abc\", \"bac\"], majd a [\"abc\"] listát."
    },
    "docstring_bertscore": {
      "sq": "0.9866967302301883",
      "hy": "0.9769795333595807",
      "bn": "0.9900486179101521",
      "bg": "0.9793948787929648",
      "zh": "0.9740600640191298",
      "fr": "0.981012325985732",
      "de": "0.9748214142696365",
      "ha": "0.9500442605393445",
      "hi": "0.9874564914376468",
      "hu": "0.9679305290907741"
    }
  },
  {
    "task_id": "Swift/12",
    "prompt": {
      "en": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/",
      "sq": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nGjen numrin e plotë 'target' që shfaqet më shpesh menjëherë pas 'key' të specifikuar në vargun 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Numri 2 shfaqet dy herë pas 1, më shpesh se çdo numër tjetër.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Numri 1 shfaqet një herë pas 1, që është më i shpeshti.\n*/",
      "hy": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nԳտնում է 'target' ամբողջ թիվը, որը ամենահաճախն է հայտնվում նշված 'key'-ից անմիջապես հետո 'nums' զանգվածում:\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Թիվը 2-ը հայտնվում է երկու անգամ 1-ից հետո, ավելի հաճախ, քան ցանկացած այլ թիվ:\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Թիվը 1-ը հայտնվում է մեկ անգամ 1-ից հետո, ինչը ամենահաճախն է:\n*/",
      "bn": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nনির্দিষ্ট 'key' এর পরে সরাসরি যে পূর্ণসংখ্যা 'target' সবচেয়ে বেশি সংখ্যায় উপস্থিত হয় তা খুঁজে বের করে 'nums' অ্যারেতে।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // সংখ্যা 2 দুইবার 1 এর পরে উপস্থিত হয়, যা অন্য যেকোন সংখ্যার চেয়ে বেশি।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // সংখ্যা 1 একবার 1 এর পরে উপস্থিত হয়, যা সবচেয়ে ঘন ঘন।\n*/",
      "bg": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nНамира целочисленото число 'target', което най-често се появява веднага след указаното 'key' в масива 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Числото 2 се появява два пъти след 1, по-често от всяко друго число.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Числото 1 се появява веднъж след 1, което е най-честото.\n*/",
      "zh": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\n找到在数组 'nums' 中紧跟在指定 'key' 之后最频繁出现的整数 'target'。\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 数字 2 在 1 之后出现两次，比其他任何数字都频繁。\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 数字 1 在 1 之后出现一次，这是最频繁的。\n*/",
      "fr": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nTrouve l'entier 'target' qui apparaît le plus fréquemment immédiatement après le 'key' spécifié dans le tableau 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Le nombre 2 apparaît deux fois après 1, plus fréquemment que tout autre nombre.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Le nombre 1 apparaît une fois après 1, ce qui est le plus fréquent.\n*/",
      "de": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFindet die Ganzzahl 'target', die am häufigsten unmittelbar nach dem angegebenen 'key' im Array 'nums' erscheint.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Die Zahl 2 erscheint zweimal nach 1, häufiger als jede andere Zahl.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Die Zahl 1 erscheint einmal nach 1, was am häufigsten ist.\n*/",
      "ha": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nNemo lamba 'target' wanda yafi yawan bayyana nan take bayan takamaiman 'key' a cikin jerin 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Lambar 2 ta bayyana sau biyu bayan 1, fiye da kowace lamba.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Lambar 1 ta bayyana sau daya bayan 1, wanda shine mafi yawa.\n*/",
      "hi": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nउस पूर्णांक 'target' को खोजता है जो सरणी 'nums' में निर्दिष्ट 'key' के तुरंत बाद सबसे अधिक बार प्रकट होता है।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // संख्या 2, 1 के बाद दो बार प्रकट होती है, जो किसी अन्य संख्या से अधिक बार है।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // संख्या 1, 1 के बाद एक बार प्रकट होती है, जो सबसे अधिक बार है।\n*/",
      "hu": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nMegkeresi azt az egész számot ('target'), amely a leggyakrabban jelenik meg közvetlenül a megadott 'key' után a 'nums' tömbben.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // A 2-es szám kétszer jelenik meg az 1-es után, gyakrabban, mint bármely más szám.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Az 1-es szám egyszer jelenik meg az 1-es után, ami a leggyakoribb.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9992898963878003",
      "hy": "0.9845916454519806",
      "bn": "0.9875848066637953",
      "bg": "0.9976736409773194",
      "zh": "0.995160172135704",
      "fr": "0.9992898963878003",
      "de": "0.9992898963878003",
      "ha": "0.9690029345179816",
      "hi": "0.9924683332119191",
      "hu": "0.9845946249076961"
    },
    "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}",
    "instruction": {
      "en": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），最多使用500个字符。",
      "fr": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Swift cikin harshen Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9296333998449615",
      "bn": "0.879147913158086",
      "bg": "0.8273796714704873",
      "zh": "0.8683384478221675",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9217926641839904",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)",
    "entry_point": "mostFrequentTargetAfterKey",
    "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {",
    "docstring": {
      "en": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n",
      "sq": "Gjen numrin e plotë 'target' që shfaqet më shpesh menjëherë pas 'key' të specifikuar në vargun 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Numri 2 shfaqet dy herë pas 1, më shpesh se çdo numër tjetër.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Numri 1 shfaqet një herë pas 1, që është më i shpeshti.",
      "hy": "Գտնում է 'target' ամբողջ թիվը, որը ամենահաճախն է հայտնվում նշված 'key'-ից անմիջապես հետո 'nums' զանգվածում:\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Թիվը 2-ը հայտնվում է երկու անգամ 1-ից հետո, ավելի հաճախ, քան ցանկացած այլ թիվ:\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Թիվը 1-ը հայտնվում է մեկ անգամ 1-ից հետո, որը ամենահաճախն է:",
      "bn": "Finds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\nনির্দিষ্ট 'key' এর পরে 'nums' অ্যারেতে যে পূর্ণসংখ্যা 'target' সবচেয়ে ঘন ঘন উপস্থিত হয় তা খুঁজে বের করে।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // সংখ্যা 2, 1 এর পরে দুবার উপস্থিত হয়, যা অন্য যেকোন সংখ্যার চেয়ে বেশি ঘন ঘন।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // সংখ্যা 1, 1 এর পরে একবার উপস্থিত হয়, যা সবচেয়ে ঘন ঘন।",
      "bg": "Намира целочислената стойност 'target', която най-често се появява непосредствено след зададения 'key' в масива 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Числото 2 се появява два пъти след 1, по-често от всяко друго число.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Числото 1 се появява веднъж след 1, което е най-честото.",
      "zh": "找到在数组 'nums' 中紧跟在指定 'key' 之后最频繁出现的整数 'target'。\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 数字 2 在 1 之后出现了两次，比其他任何数字都频繁。\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 数字 1 在 1 之后出现了一次，这是最频繁的。",
      "fr": "Trouve l'entier 'target' qui apparaît le plus fréquemment immédiatement après le 'key' spécifié dans le tableau 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Le nombre 2 apparaît deux fois après 1, plus fréquemment que tout autre nombre.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Le nombre 1 apparaît une fois après 1, ce qui est le plus fréquent.",
      "de": "Findet die ganze Zahl 'target', die am häufigsten unmittelbar nach dem angegebenen 'key' im Array 'nums' erscheint.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Die Zahl 2 erscheint zweimal nach 1, häufiger als jede andere Zahl.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Die Zahl 1 erscheint einmal nach 1, was am häufigsten ist.",
      "ha": "Nemo adadi 'manufa' wanda yafi yawan bayyana nan take bayan takamaiman 'mabuɗi' a cikin jerin 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Lambar 2 tana bayyana sau biyu bayan 1, fiye da kowace lamba.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Lambar 1 tana bayyana sau daya bayan 1, wanda shine mafi yawa.",
      "hi": "Finds the integer 'target' जो निर्दिष्ट 'key' के तुरंत बाद सबसे अधिक बार 'nums' array में प्रकट होता है।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // संख्या 2, 1 के बाद दो बार प्रकट होती है, जो किसी अन्य संख्या की तुलना में अधिक बार है।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // संख्या 1, 1 के बाद एक बार प्रकट होती है, जो सबसे अधिक बार है।",
      "hu": "Megkeresi azt az egész számot ('target'), amely a leggyakrabban jelenik meg közvetlenül a megadott 'key' után a 'nums' tömbben.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // A 2-es szám kétszer jelenik meg az 1-es után, gyakrabban, mint bármely más szám.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Az 1-es szám egyszer jelenik meg az 1-es után, ami a leggyakoribb."
    },
    "docstring_bertscore": {
      "sq": "0.9913885784606135",
      "hy": "0.984974803456997",
      "bn": "0.9183031256499694",
      "bg": "0.9877443068597663",
      "zh": "0.9920345244597389",
      "fr": "0.9920345244597389",
      "de": "0.9865449766190777",
      "ha": "0.9610052808559928",
      "hi": "0.9812590249189773",
      "hu": "0.9802458113453183"
    }
  },
  {
    "task_id": "Swift/13",
    "prompt": {
      "en": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/",
      "sq": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nKthen një listë të renditur të të gjithë indekseve fqinjë K të afërt në vargun 'nums'.\nNjë indeks fqinj K i afërt i plotëson të paktën një indeks j të tillë që |i - j| <= k dhe nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Çdo indeks është brenda 2 hapave nga një '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indekset 1, 2, 3 janë brenda 1 hapi nga një '3'.\n*/",
      "hy": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nՎերադարձնում է 'nums' զանգվածի բոլոր K մոտ հարևանների ինդեքսների դասավորված ցուցակը:\nK մոտ հարևանի ինդեքս i-ն բավարարում է առնվազն մեկ ինդեքս j, այնպես որ |i - j| <= k և nums[j] == key:\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Յուրաքանչյուր ինդեքս գտնվում է '2'-ից 2 քայլ հեռավորության վրա:\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Ինդեքսները 1, 2, 3 գտնվում են '3'-ից 1 քայլ հեռավորության վրա:\n*/",
      "bn": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nঅ্যারে 'nums' এর সমস্ত K নিকটবর্তী প্রতিবেশীর সূচকের একটি সাজানো তালিকা প্রদান করে।\nএকটি K নিকটবর্তী প্রতিবেশী সূচক i কমপক্ষে একটি সূচক j কে সন্তুষ্ট করে যাতে |i - j| <= k এবং nums[j] == key হয়।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // প্রতিটি সূচক '2' এর 2 ধাপের মধ্যে রয়েছে।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // সূচক 1, 2, 3 '3' এর 1 ধাপের মধ্যে রয়েছে।\n*/",
      "bg": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nВръща сортиран списък с всички индекси на K близки съседи в масива 'nums'.\nИндексът на K близък съсед i удовлетворява поне един индекс j, такъв че |i - j| <= k и nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Всеки индекс е на разстояние до 2 стъпки от '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Индексите 1, 2, 3 са на разстояние до 1 стъпка от '3'.\n*/",
      "zh": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\n返回数组 'nums' 中所有 K 个近邻索引的排序列表。\n一个 K 近邻索引 i 满足至少一个索引 j 使得 |i - j| <= k 且 nums[j] == key。\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // 每个索引都在 '2' 的 2 步范围内。\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // 索引 1, 2, 3 都在 '3' 的 1 步范围内。\n*/",
      "fr": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nRetourne une liste triée de tous les indices voisins proches K dans le tableau 'nums'.\nUn indice voisin proche K i satisfait au moins un indice j tel que |i - j| <= k et nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Chaque indice est à 2 pas d'un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Les indices 1, 2, 3 sont à 1 pas d'un '3'.\n*/",
      "de": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nGibt eine sortierte Liste aller K nahen Nachbarindizes im Array 'nums' zurück.\nEin K naher Nachbarindex i erfüllt mindestens einen Index j, sodass |i - j| <= k und nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Jeder Index ist innerhalb von 2 Schritten von einer '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indizes 1, 2, 3 sind innerhalb von 1 Schritt von einer '3'.\n*/",
      "ha": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nYana dawo da jerin da aka tsara na dukkan alamomin makwabta K kusa a cikin jerin 'nums'.\nAlamar makwabta K kusa i tana gamsar da aƙalla alamar j ɗaya irin cewa |i - j| <= k kuma nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kowace alama tana cikin matakai 2 na '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Alamomi 1, 2, 3 suna cikin mataki 1 na '3'.\n*/",
      "hi": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nऐरे 'nums' में सभी K निकटतम पड़ोसी इंडेक्स की एक क्रमबद्ध सूची लौटाता है।\nएक K निकटतम पड़ोसी इंडेक्स i कम से कम एक इंडेक्स j को संतुष्ट करता है, जिससे |i - j| <= k और nums[j] == key होता है।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // प्रत्येक इंडेक्स '2' से 2 कदम के भीतर है।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // इंडेक्स 1, 2, 3 '3' से 1 कदम के भीतर हैं।\n*/",
      "hu": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nVisszaadja az összes K közeli szomszéd indexének rendezett listáját a 'nums' tömbben.\nEgy K közeli szomszéd index i teljesíti legalább egy j indexet úgy, hogy |i - j| <= k és nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Minden index legfeljebb 2 lépésnyire van egy '2'-től.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Az 1, 2, 3 indexek legfeljebb 1 lépésnyire vannak egy '3'-tól.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9875212449418642",
      "hy": "0.9660596295318066",
      "bn": "0.9874908544935659",
      "bg": "0.9763913888013362",
      "zh": "0.981844190021506",
      "fr": "1",
      "de": "0.9855375233264687",
      "ha": "0.9676377479091288",
      "hi": "0.9915989280341294",
      "hu": "0.9670505965027897"
    },
    "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}",
    "instruction": {
      "en": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Swift a cikin Hausa ba tare da wucewa haruffa 500 ba.",
      "hi": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9296333998449615",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.916626486603654",
      "hi": "0.9102601842611048",
      "hu": "0.930809291700688"
    },
    "level": "",
    "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)",
    "entry_point": "kCloseNeighbors",
    "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {",
    "docstring": {
      "en": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n",
      "sq": "Kthen një listë të renditur të të gjithë indekseve fqinjë K të afërt në vargun 'nums'. Një indeks fqinj K i afërt i plotëson të paktën një indeks j të tillë që |i - j| <= k dhe nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Çdo indeks është brenda 2 hapave nga një '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indekset 1, 2, 3 janë brenda 1 hapi nga një '3'.",
      "hy": "Վերադարձնում է 'nums' զանգվածում K մոտ հարևան ինդեքսների դասավորված ցուցակը:\nK մոտ հարևան ինդեքս i-ն բավարարում է առնվազն մեկ ինդեքս j, այնպես որ |i - j| <= k և nums[j] == key:\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Յուրաքանչյուր ինդեքս գտնվում է '2'-ից 2 քայլ հեռավորության վրա:\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Ինդեքսները 1, 2, 3 գտնվում են '3'-ից 1 քայլ հեռավորության վրա:",
      "bn": "সকল K নিকটবর্তী প্রতিবেশীর সূচকের একটি সাজানো তালিকা প্রদান করে যা 'nums' অ্যারেতে রয়েছে। একটি K নিকটবর্তী প্রতিবেশীর সূচক i কমপক্ষে একটি সূচক j কে সন্তুষ্ট করে যেখানে |i - j| <= k এবং nums[j] == key।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // প্রতিটি সূচক একটি '2' এর 2 ধাপের মধ্যে রয়েছে।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // সূচক 1, 2, 3 একটি '3' এর 1 ধাপের মধ্যে রয়েছে।",
      "bg": "Връща сортиран списък на всички K близки съседни индекси в масива 'nums'. K близък съседен индекс i удовлетворява поне един индекс j, такъв че |i - j| <= k и nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Всеки индекс е на разстояние до 2 стъпки от '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Индексите 1, 2, 3 са на разстояние до 1 стъпка от '3'.",
      "zh": "返回数组 'nums' 中所有 K 近邻索引的排序列表。  \n一个 K 近邻索引 i 满足至少一个索引 j 使得 |i - j| <= k 且 nums[j] == key。  \n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)  \n[0, 1, 2, 3, 4, 5, 6] // 每个索引都在 '2' 的 2 步范围内。  \n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)  \n[1, 2, 3] // 索引 1, 2, 3 都在 '3' 的 1 步范围内。  ",
      "fr": "Retourne une liste triée de tous les indices des K voisins proches dans le tableau 'nums'.\nUn indice voisin proche K i satisfait au moins un indice j tel que |i - j| <= k et nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Chaque indice est à 2 pas d'un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Les indices 1, 2, 3 sont à 1 pas d'un '3'.",
      "de": "Gibt eine sortierte Liste aller K nahen Nachbarindizes im Array 'nums' zurück.\nEin K naher Nachbarindex i erfüllt mindestens einen Index j, sodass |i - j| <= k und nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Jeder Index ist innerhalb von 2 Schritten von einer '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indizes 1, 2, 3 sind innerhalb von 1 Schritt von einer '3'.",
      "ha": "Yana mayar da jerin da aka jera na dukkan K makwabta masu kusanci a cikin jerin 'nums'. \nWani K makwabcin kusa index i yana gamsar da aƙalla ɗaya index j ta yadda |i - j| <= k kuma nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kowanne index yana cikin matakai 2 na '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 suna cikin mataki 1 na '3'.",
      "hi": "सॉर्ट की गई सूची लौटाता है जिसमें 'nums' में सभी K निकटतम पड़ोसी इंडेक्स शामिल होते हैं।\nएक K निकटतम पड़ोसी इंडेक्स i कम से कम एक इंडेक्स j को संतुष्ट करता है जिससे |i - j| <= k और nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // प्रत्येक इंडेक्स '2' के 2 कदम के भीतर है।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // इंडेक्स 1, 2, 3 '3' के 1 कदम के भीतर हैं।",
      "hu": "Visszaad egy rendezett listát az összes K közeli szomszéd indexről a 'nums' tömbben.\nEgy K közeli szomszéd index i kielégít legalább egy j indexet úgy, hogy |i - j| <= k és nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Minden index legfeljebb 2 lépésre van egy '2'-től.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Az 1, 2, 3 indexek legfeljebb 1 lépésre vannak egy '3'-tól."
    },
    "docstring_bertscore": {
      "sq": "0.9862434557006667",
      "hy": "0.9724777744038059",
      "bn": "0.9504244390886454",
      "bg": "0.9860996473047975",
      "zh": "0.9561225488293932",
      "fr": "0.9612607195260037",
      "de": "0.9980524291139529",
      "ha": "0.9690660989791506",
      "hi": "0.9715402390053213",
      "hu": "0.9570942486534159"
    }
  },
  {
    "task_id": "Swift/14",
    "prompt": {
      "en": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/",
      "sq": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nPërcakton nëse vargu 'nums' mund të ndahet në çifte të tilla që secili çift përbëhet nga elemente të barabarta.\nÇdo element duhet të përkasë saktësisht në një çift.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Mund të ndahet në çifte (1,1) dhe (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nuk mund të formohen çifte me elemente të barabarta.\n*/",
      "hy": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nՍահմանում է՝ արդյոք 'nums' զանգվածը կարելի է բաժանել զույգերի, այնպես, որ յուրաքանչյուր զույգ կազմված լինի հավասար տարրերից:\nՅուրաքանչյուր տարր պետք է պատկանի միայն մեկ զույգի:\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Կարելի է բաժանել զույգերի (1,1) և (2,2):\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Չի կարող կազմել զույգեր հավասար տարրերով:\n*/",
      "bn": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nনির্ধারণ করে যে অ্যারে 'nums' কে এমনভাবে জোড়ায় বিভক্ত করা যায় কিনা যাতে প্রতিটি জোড়া সমান উপাদান নিয়ে গঠিত হয়।\nপ্রতিটি উপাদান অবশ্যই ঠিক একটি জোড়ার অন্তর্ভুক্ত হতে হবে।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // জোড়ায় বিভক্ত করা যেতে পারে (1,1) এবং (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // সমান উপাদান সহ জোড়া তৈরি করা সম্ভব নয়।\n*/",
      "bg": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nОпределя дали масивът 'nums' може да бъде разделен на двойки, така че всяка двойка да се състои от равни елементи.\nВсеки елемент трябва да принадлежи точно на една двойка.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Може да бъде разделен на двойки (1,1) и (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Не може да се образуват двойки с равни елементи.\n*/",
      "zh": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\n确定数组 'nums' 是否可以分成若干对，使得每对由相等的元素组成。\n每个元素必须恰好属于一个对。\n>>> canFormPairs([1, 2, 2, 1])\nTrue // 可以分成对 (1,1) 和 (2,2)。\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // 无法形成具有相等元素的对。\n*/",
      "fr": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDétermine si le tableau 'nums' peut être divisé en paires de sorte que chaque paire soit constituée d'éléments égaux.\nChaque élément doit appartenir à exactement une paire.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Peut être divisé en paires (1,1) et (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ne peut pas former de paires avec des éléments égaux.\n*/",
      "de": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nBestimmt, ob das Array 'nums' in Paare aufgeteilt werden kann, sodass jedes Paar aus gleichen Elementen besteht.\nJedes Element muss genau zu einem Paar gehören.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Kann in Paare (1,1) und (2,2) aufgeteilt werden.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Kann keine Paare mit gleichen Elementen bilden.\n*/",
      "ha": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nYana tantance ko za a iya raba jerin 'nums' zuwa ma'aurata inda kowace ma'aurata ta ƙunshi abubuwa masu daidaituwa.\nDole ne kowane abu ya kasance a cikin daidai ma'aurata ɗaya.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Ana iya raba zuwa ma'aurata (1,1) da (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ba za a iya yin ma'aurata da abubuwa masu daidaituwa ba.\n*/",
      "hi": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nयह निर्धारित करता है कि क्या 'nums' ऐरे को जोड़ों में विभाजित किया जा सकता है ताकि प्रत्येक जोड़ा समान तत्वों से बना हो।\nप्रत्येक तत्व को ठीक एक जोड़े का हिस्सा होना चाहिए।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // इसे जोड़ों (1,1) और (2,2) में विभाजित किया जा सकता है।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // समान तत्वों के साथ जोड़े नहीं बना सकते।\n*/",
      "hu": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nMeghatározza, hogy a 'nums' tömb felosztható-e párokra úgy, hogy minden pár egyenlő elemekből álljon.\nMinden elemnek pontosan egy párhoz kell tartoznia.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Felosztható párokra (1,1) és (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nem lehet párokat alkotni egyenlő elemekkel.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9992130264303398",
      "hy": "0.9943741917179488",
      "bn": "0.9808734833493885",
      "bg": "1",
      "zh": "0.9885149927381818",
      "fr": "0.9992130264303398",
      "de": "0.9931631422847792",
      "ha": "0.9703140936631929",
      "hi": "0.9772488761562639",
      "hu": "0.9954046861347579"
    },
    "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}",
    "instruction": {
      "en": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简明的自然语言描述（文档字符串）。",
      "fr": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.8990590198137853",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)",
    "entry_point": "canFormPairs",
    "signature": "func canFormPairs(_ nums: [Int]) -> Bool {",
    "docstring": {
      "en": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n",
      "sq": "Përcakton nëse vargu 'nums' mund të ndahet në çifte të tilla që secili çift përbëhet nga elemente të barabarta. Çdo element duhet të përkasë saktësisht në një çift.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Mund të ndahet në çifte (1,1) dhe (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nuk mund të formohen çifte me elemente të barabarta.",
      "hy": "Սահմանում է՝ արդյոք 'nums' զանգվածը կարելի է բաժանել զույգերի, այնպես որ յուրաքանչյուր զույգ բաղկացած լինի հավասար տարրերից։ Յուրաքանչյուր տարր պետք է պատկանի հենց մեկ զույգի։\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Կարելի է բաժանել զույգերի (1,1) և (2,2)։\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Չի կարելի կազմել զույգեր հավասար տարրերով։",
      "bn": "নির্ধারণ করে যে অ্যারে 'nums' কে এমনভাবে জোড়ায় বিভক্ত করা যায় কিনা যাতে প্রতিটি জোড়া সমান উপাদান নিয়ে গঠিত হয়। প্রতিটি উপাদান অবশ্যই ঠিক একটি জোড়ায় অন্তর্ভুক্ত হতে হবে।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // জোড়ায় বিভক্ত করা যায় (1,1) এবং (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // সমান উপাদান সহ জোড়া তৈরি করা সম্ভব নয়।",
      "bg": "Определя дали масивът 'nums' може да бъде разделен на двойки, така че всяка двойка да се състои от равни елементи. Всеки елемент трябва да принадлежи точно на една двойка.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Може да бъде разделен на двойки (1,1) и (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Не може да се формират двойки с равни елементи.",
      "zh": "确定数组 'nums' 是否可以被划分为对，使得每对由相等的元素组成。\n每个元素必须恰好属于一个对。\n>>> canFormPairs([1, 2, 2, 1])\nTrue // 可以被划分为对 (1,1) 和 (2,2)。\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // 无法形成具有相等元素的对。",
      "fr": "Détermine si le tableau 'nums' peut être divisé en paires de sorte que chaque paire soit constituée d'éléments égaux.  \nChaque élément doit appartenir à exactement une paire.  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // Peut être divisé en paires (1,1) et (2,2).  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // Ne peut pas former de paires avec des éléments égaux.  ",
      "de": "Bestimmt, ob das Array 'nums' in Paare unterteilt werden kann, sodass jedes Paar aus gleichen Elementen besteht. Jedes Element muss genau zu einem Paar gehören.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Kann in Paare (1,1) und (2,2) unterteilt werden.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Kann keine Paare mit gleichen Elementen bilden.",
      "ha": "Yana tantance ko za a iya raba jerin 'nums' zuwa ma'aurata inda kowace ma'aurata ta ƙunshi abubuwa masu daidaito.\nDole ne kowane abu ya kasance a cikin daidai ma'aurata ɗaya.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Ana iya raba shi zuwa ma'aurata (1,1) da (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ba za a iya ƙirƙirar ma'aurata tare da abubuwa masu daidaito ba.",
      "hi": "यह निर्धारित करता है कि 'nums' नामक array को इस प्रकार जोड़ों में विभाजित किया जा सकता है कि प्रत्येक जोड़ा समान तत्वों से बना हो। प्रत्येक तत्व को ठीक एक जोड़े का हिस्सा होना चाहिए।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // इसे जोड़ों में विभाजित किया जा सकता है (1,1) और (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // समान तत्वों के साथ जोड़े नहीं बना सकते।",
      "hu": "Meghatározza, hogy a 'nums' tömb felosztható-e párokra úgy, hogy minden pár egyenlő elemekből álljon.\nMinden elemnek pontosan egy párhoz kell tartoznia.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Felosztható párokra (1,1) és (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nem lehet párokat alkotni egyenlő elemekkel."
    },
    "docstring_bertscore": {
      "sq": "0.9918557571168075",
      "hy": "0.9957006454024998",
      "bn": "0.9532495589981046",
      "bg": "1",
      "zh": "0.9893373225156662",
      "fr": "0.9880867456366705",
      "de": "0.9853363107504804",
      "ha": "0.9552378491122638",
      "hi": "0.9622232823524988",
      "hu": "0.9934757865045281"
    }
  },
  {
    "task_id": "Swift/15",
    "prompt": {
      "en": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/",
      "sq": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nKthen dy lista: një me numra të plotë unikë në 'nums1' që nuk janë në 'nums2', dhe një tjetër me numra të plotë unikë në 'nums2' që nuk janë në 'nums1'.\nNumrat e plotë në secilën listë kthehen në rend rritës.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 është unik për nums1, 4 është unik për nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 janë unikë për nums1; 4, 5 janë unikë për nums2.\n*/",
      "hy": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nՎերադարձնում է երկու ցուցակներ՝ մեկը 'nums1'-ում գտնվող եզակի ամբողջ թվերով, որոնք չկան 'nums2'-ում, և մյուսը՝ 'nums2'-ում գտնվող եզակի ամբողջ թվերով, որոնք չկան 'nums1'-ում:\nՅուրաքանչյուր ցուցակում թվերը վերադարձվում են աճման կարգով:\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1-ը եզակի է nums1-ում, 4-ը եզակի է nums2-ում:\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2-ը եզակի են nums1-ում; 4, 5-ը եզակի են nums2-ում:\n*/",
      "bn": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nদুটি তালিকা প্রদান করে: একটি 'nums1' এ অনন্য পূর্ণসংখ্যাগুলি যা 'nums2' তে নেই, এবং অন্যটি 'nums2' এ অনন্য পূর্ণসংখ্যাগুলি যা 'nums1' তে নেই।\nপ্রত্যেক তালিকার পূর্ণসংখ্যাগুলি ঊর্ধ্বক্রমে ফেরত দেওয়া হয়।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 এর জন্য অনন্য, 4 nums2 এর জন্য অনন্য।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 এর জন্য অনন্য; 4, 5 nums2 এর জন্য অনন্য।\n*/",
      "bg": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nВръща два списъка: един с уникални цели числа в 'nums1', които не са в 'nums2', и друг с уникални цели числа в 'nums2', които не са в 'nums1'.\nЦелите числа във всеки списък се връщат в нарастващ ред.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 е уникално за nums1, 4 е уникално за nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 са уникални за nums1; 4, 5 са уникални за nums2.\n*/",
      "zh": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\n返回两个列表：一个包含在 'nums1' 中但不在 'nums2' 中的唯一整数，另一个包含在 'nums2' 中但不在 'nums1' 中的唯一整数。\n每个列表中的整数按升序返回。\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 是 nums1 独有的，4 是 nums2 独有的。\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 是 nums1 独有的；4, 5 是 nums2 独有的。\n*/",
      "fr": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nRenvoie deux listes : une avec des entiers uniques dans 'nums1' qui ne sont pas dans 'nums2', et une autre avec des entiers uniques dans 'nums2' qui ne sont pas dans 'nums1'.\nLes entiers dans chaque liste sont renvoyés par ordre croissant.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 est unique à nums1, 4 est unique à nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sont uniques à nums1 ; 4, 5 sont uniques à nums2.\n*/",
      "de": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nGibt zwei Listen zurück: eine mit eindeutigen ganzen Zahlen in 'nums1', die nicht in 'nums2' vorkommen, und eine andere mit eindeutigen ganzen Zahlen in 'nums2', die nicht in 'nums1' vorkommen.\nDie ganzen Zahlen in jeder Liste werden in aufsteigender Reihenfolge zurückgegeben.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ist eindeutig in nums1, 4 ist eindeutig in nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sind eindeutig in nums1; 4, 5 sind eindeutig in nums2.\n*/",
      "ha": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nYana dawo da jerin guda biyu: ɗaya tare da lambobin cikakke na musamman a cikin 'nums1' ba a cikin 'nums2' ba, da wani tare da lambobin cikakke na musamman a cikin 'nums2' ba a cikin 'nums1' ba.\nAna dawo da lambobin cikakke a cikin kowane jeri a cikin tsari mai ƙaruwa.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ya bambanta a nums1, 4 ya bambanta a nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sun bambanta a nums1; 4, 5 sun bambanta a nums2.\n*/",
      "hi": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nदो सूचियाँ लौटाता है: एक 'nums1' में अद्वितीय पूर्णांकों के साथ जो 'nums2' में नहीं हैं, और दूसरी 'nums2' में अद्वितीय पूर्णांकों के साथ जो 'nums1' में नहीं हैं।\nप्रत्येक सूची में पूर्णांक आरोही क्रम में लौटाए जाते हैं।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 के लिए अद्वितीय है, 4 nums2 के लिए अद्वितीय है।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 के लिए अद्वितीय हैं; 4, 5 nums2 के लिए अद्वितीय हैं।\n*/",
      "hu": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nKét listát ad vissza: az egyikben azok az egyedi egész számok vannak, amelyek 'nums1'-ben vannak, de 'nums2'-ben nincsenek, a másikban pedig azok az egyedi egész számok, amelyek 'nums2'-ben vannak, de 'nums1'-ben nincsenek.\nAz egyes listákban lévő egész számok növekvő sorrendben vannak visszaadva.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 egyedi a nums1-ben, 4 egyedi a nums2-ben.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 egyediek a nums1-ben; 4, 5 egyediek a nums2-ben.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.98324989722809",
      "hy": "0.970639648857709",
      "bn": "0.9736884265762136",
      "bg": "0.98324989722809",
      "zh": "0.9747145511246398",
      "fr": "0.97736904753679",
      "de": "0.9717104652418681",
      "ha": "0.9929084981362925",
      "hi": "0.9848143101091207",
      "hu": "0.9725745073993699"
    },
    "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}",
    "instruction": {
      "en": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nПредоставете кратко описание на кода на Swift на естествен език (docstring) на български, като използвате не повече от 500 символа.",
      "zh": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供一个简洁的自然语言描述（文档字符串）。",
      "fr": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8897005494113266",
      "bn": "0.8733351936874811",
      "bg": "0.897440182208351",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)",
    "entry_point": "findUniqueElements",
    "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {",
    "docstring": {
      "en": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n",
      "sq": "Kthen dy lista: një me numra të plotë unikë në 'nums1' që nuk janë në 'nums2', dhe një tjetër me numra të plotë unikë në 'nums2' që nuk janë në 'nums1'.\nNumrat e plotë në secilën listë kthehen në rend rritës.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 është unik për nums1, 4 është unik për nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 janë unikë për nums1; 4, 5 janë unikë për nums2.",
      "hy": "Վերադարձնում է երկու ցուցակներ՝ մեկը 'nums1'-ում առկա եզակի ամբողջ թվերով, որոնք չկան 'nums2'-ում, և մյուսը՝ 'nums2'-ում առկա եզակի ամբողջ թվերով, որոնք չկան 'nums1'-ում:\nՅուրաքանչյուր ցուցակում ամբողջ թվերը վերադարձվում են աճման կարգով:\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1-ը եզակի է nums1-ում, 4-ը եզակի է nums2-ում:\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2-ը եզակի են nums1-ում; 4, 5-ը եզակի են nums2-ում:",
      "bn": "'nums1' এর মধ্যে অনন্য পূর্ণসংখ্যাগুলি যা 'nums2' তে নেই এবং 'nums2' এর মধ্যে অনন্য পূর্ণসংখ্যাগুলি যা 'nums1' তে নেই, এমন দুটি তালিকা প্রদান করে। প্রতিটি তালিকার পূর্ণসংখ্যাগুলি ক্রমবর্ধমান ক্রমে প্রদান করা হয়।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 'nums1' এর জন্য অনন্য, 4 'nums2' এর জন্য অনন্য।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 'nums1' এর জন্য অনন্য; 4, 5 'nums2' এর জন্য অনন্য।",
      "bg": "Връща два списъка: един с уникални цели числа в 'nums1', които не са в 'nums2', и друг с уникални цели числа в 'nums2', които не са в 'nums1'. Целите числа във всеки списък се връщат във възходящ ред.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 е уникално за nums1, 4 е уникално за nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 са уникални за nums1; 4, 5 са уникални за nums2.",
      "zh": "返回两个列表：一个包含在 'nums1' 中但不在 'nums2' 中的唯一整数，另一个包含在 'nums2' 中但不在 'nums1' 中的唯一整数。\n每个列表中的整数按升序返回。\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 是 nums1 独有的，4 是 nums2 独有的。\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 是 nums1 独有的；4, 5 是 nums2 独有的。",
      "fr": "Renvoie deux listes : une avec des entiers uniques dans 'nums1' qui ne sont pas dans 'nums2', et une autre avec des entiers uniques dans 'nums2' qui ne sont pas dans 'nums1'.\nLes entiers dans chaque liste sont renvoyés par ordre croissant.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 est unique à nums1, 4 est unique à nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sont uniques à nums1 ; 4, 5 sont uniques à nums2.",
      "de": "Gibt zwei Listen zurück: eine mit eindeutigen ganzen Zahlen in 'nums1', die nicht in 'nums2' sind, und eine andere mit eindeutigen ganzen Zahlen in 'nums2', die nicht in 'nums1' sind. Die ganzen Zahlen in jeder Liste werden in aufsteigender Reihenfolge zurückgegeben.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ist eindeutig in nums1, 4 ist eindeutig in nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sind eindeutig in nums1; 4, 5 sind eindeutig in nums2.",
      "ha": "Yana mayar da jerin guda biyu: ɗaya tare da lambobin cikakke na musamman a cikin 'nums1' ba a cikin 'nums2', da wani tare da lambobin cikakke na musamman a cikin 'nums2' ba a cikin 'nums1'. \nAna mayar da lambobin cikakke a kowanne jeri a cikin tsari mai hawa sama. \n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 yana da musamman ga nums1, 4 yana da musamman ga nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 suna da musamman ga nums1; 4, 5 suna da musamman ga nums2.",
      "hi": "'nums1' में अद्वितीय पूर्णांक जो 'nums2' में नहीं हैं, और 'nums2' में अद्वितीय पूर्णांक जो 'nums1' में नहीं हैं, के साथ दो सूचियाँ लौटाता है। प्रत्येक सूची में पूर्णांक आरोही क्रम में लौटाए जाते हैं।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 'nums1' के लिए अद्वितीय है, 4 'nums2' के लिए अद्वितीय है।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 'nums1' के लिए अद्वितीय हैं; 4, 5 'nums2' के लिए अद्वितीय हैं।",
      "hu": "Két listát ad vissza: az egyik a 'nums1'-ben lévő egyedi egész számokkal, amelyek nincsenek a 'nums2'-ben, a másik pedig a 'nums2'-ben lévő egyedi egész számokkal, amelyek nincsenek a 'nums1'-ben.\nAz egyes listákban lévő egész számok növekvő sorrendben kerülnek visszaadásra.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 egyedi a nums1-ben, 4 egyedi a nums2-ben.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 egyediek a nums1-ben; 4, 5 egyediek a nums2-ben."
    },
    "docstring_bertscore": {
      "sq": "0.9807402023637142",
      "hy": "0.9655582864500746",
      "bn": "0.9310112987982005",
      "bg": "0.9807402023637142",
      "zh": "0.9685196668009237",
      "fr": "0.9807402023637142",
      "de": "0.9747095853651139",
      "ha": "0.999999801369619",
      "hi": "0.9304132227209045",
      "hu": "0.9718540750073563"
    }
  },
  {
    "task_id": "Swift/16",
    "prompt": {
      "en": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/",
      "sq": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nKthen numrin në vargun 'nums' që është më afër zeros.\nNëse ka disa numra të tillë, kthen numrin më të madh.\n>>> closestToZero([2, -1, 1])\n1 // 1 dhe -1 janë njësoj afër zeros, por 1 është më i madh.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 është më afër zeros.\n*/",
      "hy": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nՎերադարձնում է 'nums' զանգվածում զրոյին ամենամոտ թիվը։\nԵթե կան մի քանի այդպիսի թվեր, վերադարձնում է ամենամեծը։\n>>> closestToZero([2, -1, 1])\n1 // 1 և -1 հավասարապես մոտ են զրոյին, բայց 1-ը մեծ է։\n>>> closestToZero([-3, -2, -1])\n-1 // -1-ը ամենամոտն է զրոյին։\n*/",
      "bn": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nঅ্যারে 'nums' এর মধ্যে যে সংখ্যাটি শূন্যের সবচেয়ে কাছাকাছি, সেটি ফেরত দেয়।\nযদি এমন একাধিক সংখ্যা থাকে, তবে বৃহত্তমটি ফেরত দেয়।\n>>> closestToZero([2, -1, 1])\n1 // 1 এবং -1 উভয়ই শূন্যের সমান কাছাকাছি, কিন্তু 1 বড়।\n>>> closestToZero([-3, -2, -1])\n-1 // -1 শূন্যের সবচেয়ে কাছাকাছি।\n*/",
      "bg": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nВръща числото в масива 'nums', което е най-близо до нула.\nАко има няколко такива числа, връща най-голямото от тях.\n>>> closestToZero([2, -1, 1])\n1 // 1 и -1 са еднакво близо до нула, но 1 е по-голямо.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 е най-близо до нула.\n*/",
      "zh": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\n返回数组 'nums' 中最接近零的数字。\n如果有多个这样的数字，返回较大的那个。\n>>> closestToZero([2, -1, 1])\n1 // 1 和 -1 同样接近零，但 1 更大。\n>>> closestToZero([-3, -2, -1])\n-1 // -1 最接近零。\n*/",
      "fr": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nRenvoie le nombre dans le tableau 'nums' qui est le plus proche de zéro.\nS'il y a plusieurs nombres tels, renvoie le plus grand.\n>>> closestToZero([2, -1, 1])\n1 // 1 et -1 sont également proches de zéro, mais 1 est plus grand.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 est le plus proche de zéro.\n*/",
      "de": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nGibt die Zahl im Array 'nums' zurück, die am nächsten bei Null liegt.\nWenn es mehrere solche Zahlen gibt, wird die größte zurückgegeben.\n>>> closestToZero([2, -1, 1])\n1 // 1 und -1 sind gleich nah an Null, aber 1 ist größer.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 ist am nächsten bei Null.\n*/",
      "ha": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nYana dawo da lambar da ke cikin jerin 'nums' wanda ya fi kusa da sifili.\nIdan akwai lambobi da yawa irin haka, yana dawo da mafi girma.\n>>> closestToZero([2, -1, 1])\n1 // 1 da -1 suna da kusanci da sifili, amma 1 ya fi girma.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 shi ne mafi kusa da sifili.\n*/",
      "hi": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nऐरे 'nums' में वह संख्या लौटाता है जो शून्य के सबसे करीब है।\nयदि ऐसी कई संख्याएँ हैं, तो सबसे बड़ी संख्या लौटाता है।\n>>> closestToZero([2, -1, 1])\n1 // 1 और -1 शून्य के समान रूप से करीब हैं, लेकिन 1 बड़ा है।\n>>> closestToZero([-3, -2, -1])\n-1 // -1 शून्य के सबसे करीब है।\n*/",
      "hu": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nVisszaadja a 'nums' tömbben lévő számot, amely a legközelebb van a nullához.\nHa több ilyen szám is van, akkor a legnagyobbat adja vissza.\n>>> closestToZero([2, -1, 1])\n1 // 1 és -1 egyformán közel vannak a nullához, de 1 a nagyobb.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 van a legközelebb a nullához.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9952964325770939",
      "hy": "0.9847743854025327",
      "bn": "0.9912237152443545",
      "bg": "0.9915786677352638",
      "zh": "0.9929692790328891",
      "fr": "0.9918942914107283",
      "de": "0.9946548564463512",
      "ha": "0.9841071859526366",
      "hi": "0.9964627901745308",
      "hu": "0.9931677107835429"
    },
    "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}",
    "instruction": {
      "en": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nПредоставете кратко описание на естествен език (докстринг) на Swift кода на български, използвайки не повече от 500 знака.",
      "zh": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9240495025733088",
      "bn": "0.8679241048473287",
      "bg": "0.9346778170017236",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9346315361229425",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)",
    "entry_point": "closestToZero",
    "signature": "func closestToZero(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n",
      "sq": "Kthen numrin në vargun 'nums' që është më afër zeros.\nNëse ka disa numra të tillë, kthen më të madhin.\n>>> closestToZero([2, -1, 1])\n1 // 1 dhe -1 janë njësoj afër zeros, por 1 është më i madh.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 është më afër zeros.",
      "hy": "Վերադարձնում է 'nums' զանգվածում զրոյին ամենամոտ թիվը:  \nԵթե կան մի քանի այդպիսի թվեր, վերադարձնում է ամենամեծը:\n>>> closestToZero([2, -1, 1])\n1 // 1 և -1 հավասարապես մոտ են զրոյին, բայց 1-ը ավելի մեծ է:\n>>> closestToZero([-3, -2, -1])\n-1 // -1-ը ամենամոտն է զրոյին:",
      "bn": "Returns the number in the array 'nums' that is closest to zero.  \nঅ্যারে 'nums' এ যে সংখ্যা শূন্যের সবচেয়ে কাছাকাছি, তা ফেরত দেয়।  \nIf there are multiple such numbers, returns the largest one.  \nযদি একাধিক এমন সংখ্যা থাকে, তবে সবচেয়ে বড়টিকে ফেরত দেয়।  \n>>> closestToZero([2, -1, 1])  \n1 // 1 এবং -1 উভয়ই শূন্যের সমান কাছাকাছি, কিন্তু 1 বড়।  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 শূন্যের সবচেয়ে কাছাকাছি।  ",
      "bg": "Връща числото в масива 'nums', което е най-близо до нула.  \nАко има няколко такива числа, връща най-голямото.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 и -1 са еднакво близо до нула, но 1 е по-голямо.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 е най-близо до нула.  ",
      "zh": "返回数组 'nums' 中最接近零的数字。\n如果有多个这样的数字，返回其中较大的一个。\n>>> closestToZero([2, -1, 1])\n1 // 1 和 -1 都同样接近零，但 1 更大。\n>>> closestToZero([-3, -2, -1])\n-1 // -1 最接近零。",
      "fr": "Renvoie le nombre dans le tableau 'nums' qui est le plus proche de zéro.  \nS'il y a plusieurs de ces nombres, renvoie le plus grand.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 et -1 sont également proches de zéro, mais 1 est plus grand.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 est le plus proche de zéro.  ",
      "de": "Gibt die Zahl im Array 'nums' zurück, die am nächsten bei null liegt.  \nWenn es mehrere solcher Zahlen gibt, wird die größte zurückgegeben.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 und -1 sind gleich nah an null, aber 1 ist größer.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 ist am nächsten bei null.  ",
      "ha": "Yana dawo da lambar a cikin jerin 'nums' wanda ya fi kusa da sifili. Idan akwai lambobi da dama irin haka, yana dawo da mafi girma. \n\n>>> closestToZero([2, -1, 1]) \n1 // 1 da -1 suna da kusanci da sifili, amma 1 ya fi girma. \n\n>>> closestToZero([-3, -2, -1]) \n-1 // -1 ya fi kusa da sifili.",
      "hi": "सरणी 'nums' में उस संख्या को लौटाता है जो शून्य के सबसे करीब है।  \nयदि ऐसी कई संख्याएँ हैं, तो सबसे बड़ी संख्या लौटाता है।  \n>>> closestToZero([2, -1, 1])  \n1 // 1 और -1 दोनों शून्य के समान रूप से करीब हैं, लेकिन 1 बड़ा है।  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 शून्य के सबसे करीब है।  ",
      "hu": "Visszaadja a 'nums' tömbben lévő számot, amely a legközelebb van a nullához.\nHa több ilyen szám is van, akkor a legnagyobbat adja vissza.\n>>> closestToZero([2, -1, 1])\n1 // 1 és -1 egyformán közel van a nullához, de 1 nagyobb.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 van a legközelebb a nullához."
    },
    "docstring_bertscore": {
      "sq": "0.9896684393608514",
      "hy": "0.9754325999520809",
      "bn": "0.9843308437616818",
      "bg": "0.9955945767790272",
      "zh": "0.985891879926235",
      "fr": "0.9838803500574946",
      "de": "0.9929466351694511",
      "ha": "0.9822734302749224",
      "hi": "0.944883048718534",
      "hu": "0.9894084321920766"
    }
  },
  {
    "task_id": "Swift/17",
    "prompt": {
      "en": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/",
      "sq": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nKthen një varg elementesh që shfaqen në të gjitha vargjet brenda vargut dy-dimensional 'nums'.\nÇdo varg në 'nums' përbëhet nga numra të plotë pozitivë të dallueshëm.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Vetëm '3' shfaqet në të gjitha vargjet.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Vetëm '2' shfaqet në të gjitha vargjet.\n*/",
      "hy": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nՎերադարձնում է տարրերի զանգված, որոնք հանդիպում են երկու-չափանի 'nums' զանգվածի բոլոր զանգվածներում:\n'nums'-ի յուրաքանչյուր զանգված բաղկացած է տարբեր դրական ամբողջ թվերից:\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Միայն '3'-ը է հանդիպում բոլոր զանգվածներում:\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Միայն '2'-ը է հանդիպում բոլոր զանգվածներում:\n*/",
      "bn": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nদ্বি-মাত্রিক অ্যারে 'nums' এর মধ্যে প্রতিটি অ্যারেতে উপস্থিত উপাদানগুলির একটি অ্যারে প্রদান করে।\n'nums' এর প্রতিটি অ্যারে স্বতন্ত্র ধনাত্মক পূর্ণসংখ্যা নিয়ে গঠিত।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // শুধুমাত্র '3' সব অ্যারেতে উপস্থিত।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // শুধুমাত্র '2' সব অ্যারেতে উপস্থিত।\n*/",
      "bg": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nВръща масив от елементи, които се появяват във всички масиви в двумерния масив 'nums'.\nВсеки масив в 'nums' се състои от различни положителни цели числа.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Само '3' се появява във всички масиви.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Само '2' се появява във всички масиви.\n*/",
      "zh": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\n返回一个数组，其中包含出现在二维数组 'nums' 中所有数组中的元素。\n'nums' 中的每个数组由不同的正整数组成。\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // 只有 '3' 出现在所有数组中。\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // 只有 '2' 出现在所有数组中。\n*/",
      "fr": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nRenvoie un tableau d'éléments qui apparaissent dans tous les tableaux au sein du tableau bidimensionnel 'nums'.\nChaque tableau dans 'nums' se compose d'entiers positifs distincts.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Seul '3' apparaît dans tous les tableaux.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Seul '2' apparaît dans tous les tableaux.\n*/",
      "de": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nGibt ein Array von Elementen zurück, die in allen Arrays innerhalb des zweidimensionalen Arrays 'nums' erscheinen.\nJedes Array in 'nums' besteht aus unterschiedlichen positiven ganzen Zahlen.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Nur '3' erscheint in allen Arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Nur '2' erscheint in allen Arrays.\n*/",
      "ha": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nYana dawo da jerin abubuwan da suka bayyana a dukkan jerin abubuwa a cikin jerin abubuwa biyu 'nums'.\nKowane jeri a cikin 'nums' yana dauke da lambobi masu kyau daban-daban.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sai dai '3' ne kawai ya bayyana a dukkan jerin abubuwa.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sai dai '2' ne kawai ya bayyana a dukkan jerin abubuwa.\n*/",
      "hi": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nसभी उप-समुच्चयों में उपस्थित तत्वों की एक सूची लौटाता है जो द्वि-आयामी सूची 'nums' के भीतर हैं।\n'nums' में प्रत्येक उप-समुच्चय अद्वितीय सकारात्मक पूर्णांकों से बना होता है।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // केवल '3' सभी उप-समुच्चयों में उपस्थित है।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // केवल '2' सभी उप-समुच्चयों में उपस्थित है।\n*/",
      "hu": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nVisszaad egy tömböt azokról az elemekről, amelyek megjelennek az összes tömbben a 'nums' kétdimenziós tömbön belül.\nA 'nums' minden tömbje különálló pozitív egész számokból áll.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Csak a '3' jelenik meg minden tömbben.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Csak a '2' jelenik meg minden tömbben.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9732174739427798",
      "bn": "0.975666983801702",
      "bg": "0.999999801369619",
      "zh": "0.9945420343899234",
      "fr": "0.9901866660249713",
      "de": "0.999999801369619",
      "ha": "0.9865868876294761",
      "hi": "0.9385493217584746",
      "hu": "0.9808623600480506"
    },
    "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}",
    "instruction": {
      "en": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nBayar da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Swift cikin Hausa, ba fiye da haruffa 500 ba.",
      "hi": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9296333998449615",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8602410817088992",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9131170850315296",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)",
    "entry_point": "commonElementsInAllArrays",
    "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {",
    "docstring": {
      "en": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n",
      "sq": "Kthen një varg elementesh që shfaqen në të gjitha vargjet brenda vargut dy-dimensional 'nums'.\nÇdo varg në 'nums' përbëhet nga numra të plotë pozitivë të dallueshëm.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Vetëm '3' shfaqet në të gjitha vargjet.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Vetëm '2' shfaqet në të gjitha vargjet.",
      "hy": "Վերադարձնում է տարրերի զանգված, որոնք հայտնվում են երկչափ զանգվածի 'nums' բոլոր զանգվածներում:\n'nums'-ի յուրաքանչյուր զանգված բաղկացած է տարբեր դրական ամբողջ թվերից:\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Միայն '3'-ն է հայտնվում բոլոր զանգվածներում:\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Միայն '2'-ն է հայտնվում բոլոր զանգվածներում:",
      "bn": "Returns an array of elements that appear in all arrays within the two-dimensional array 'nums'.  \nপ্রত্যেকটি অ্যারে 'nums'-এ স্বতন্ত্র ধনাত্মক পূর্ণসংখ্যা নিয়ে গঠিত।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // শুধুমাত্র '3' সব অ্যারেতে উপস্থিত।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // শুধুমাত্র '2' সব অ্যারেতে উপস্থিত।",
      "bg": "Връща масив от елементи, които се появяват във всички масиви в двумерния масив 'nums'. Всеки масив в 'nums' се състои от различни положителни цели числа.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Само '3' се появява във всички масиви.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Само '2' се появява във всички масиви.",
      "zh": "返回一个数组，其中包含在二维数组 'nums' 中所有数组中出现的元素。\n'nums' 中的每个数组由不同的正整数组成。\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // 只有 '3' 出现在所有数组中。\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // 只有 '2' 出现在所有数组中。",
      "fr": "Renvoie un tableau d'éléments qui apparaissent dans tous les tableaux au sein du tableau bidimensionnel 'nums'.\nChaque tableau dans 'nums' est composé d'entiers positifs distincts.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Seul '3' apparaît dans tous les tableaux.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Seul '2' apparaît dans tous les tableaux.",
      "de": "Gibt ein Array von Elementen zurück, die in allen Arrays innerhalb des zweidimensionalen Arrays 'nums' erscheinen.\nJedes Array in 'nums' besteht aus unterschiedlichen positiven ganzen Zahlen.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Nur '3' erscheint in allen Arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Nur '2' erscheint in allen Arrays.",
      "ha": "Yana mayar da wani jerin abubuwa da suka bayyana a dukkan jerin abubuwa cikin jerin abubuwa mai girma biyu 'nums'.\nKowane jeri a cikin 'nums' yana dauke da lambobi masu kyau daban-daban.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sai dai '3' ne kawai ya bayyana a dukkan jerin abubuwa.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sai dai '2' ne kawai ya bayyana a dukkan jerin abubuwa.",
      "hi": "सभी उप-ऐरे में मौजूद तत्वों का एक ऐरे लौटाता है जो द्वि-आयामी ऐरे 'nums' के भीतर होते हैं।\n'nums' में प्रत्येक उप-ऐरे में भिन्न सकारात्मक पूर्णांक होते हैं।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // केवल '3' सभी उप-ऐरे में दिखाई देता है।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // केवल '2' सभी उप-ऐरे में दिखाई देता है।",
      "hu": "Visszaad egy tömböt azokról az elemekről, amelyek megjelennek az összes tömbben a 'nums' kétdimenziós tömbön belül.\nA 'nums' minden tömbje különálló pozitív egész számokból áll.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Csak a '3' jelenik meg az összes tömbben.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Csak a '2' jelenik meg az összes tömbben."
    },
    "docstring_bertscore": {
      "sq": "0.9911798179301458",
      "hy": "0.9922776480461256",
      "bn": "0.9900172343099486",
      "bg": "1",
      "zh": "0.9873831968270449",
      "fr": "0.9953876039219889",
      "de": "1",
      "ha": "0.9798090231374226",
      "hi": "0.9451966860901881",
      "hu": "0.9816457582708522"
    }
  },
  {
    "task_id": "Swift/18",
    "prompt": {
      "en": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/",
      "sq": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nZbaton algoritmin e specifikuar mbi vargun 'nums' derisa të mbetet vetëm një numër.\nGjatësia e 'nums' është një fuqi e 2. Për indekset çift, merr minimumin e çifteve; për indekset tek, merr maksimumin.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Numri përfundimtar pas zbatimit të përsëritur të algoritmit.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Numri përfundimtar pas zbatimit të algoritmit.\n*/",
      "hy": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nԿատարում է նշված ալգորիթմը 'nums' զանգվածի վրա, մինչև մնա միայն մեկ թիվ։ \n'nums'-ի երկարությունը 2-ի աստիճան է։ Զույգ ինդեքսների համար վերցնում ենք զույգերի նվազագույնը, իսկ կենտ ինդեքսների համար՝ առավելագույնը։\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Վերջնական թիվը ալգորիթմը բազմիցս կիրառելուց հետո։\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Վերջնական թիվը ալգորիթմը կիրառելուց հետո։\n*/",
      "bn": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nঅ্যারে 'nums' এর উপর নির্দিষ্ট অ্যালগরিদমটি প্রয়োগ করে যতক্ষণ না শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n'nums' এর দৈর্ঘ্য 2 এর ঘাত। জোড় সংখ্যক সূচকের জন্য, জোড়ার মধ্যে সর্বনিম্নটি নিন; বিজোড় সূচকের জন্য, সর্বাধিকটি নিন।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // বারবার অ্যালগরিদম প্রয়োগ করার পর চূড়ান্ত সংখ্যা।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // অ্যালগরিদম প্রয়োগ করার পর চূড়ান্ত সংখ্যা।\n*/",
      "bg": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nИзвършва специфичния алгоритъм върху масива 'nums', докато остане само едно число.\nДължината на 'nums' е степен на 2. За четни индекси вземете минималната стойност на двойките; за нечетни индекси вземете максималната стойност.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Крайно число след многократно прилагане на алгоритъма.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Крайно число след прилагане на алгоритъма.\n*/",
      "zh": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\n对数组 'nums' 执行指定的算法，直到只剩下一个数字。\n'nums' 的长度是 2 的幂。对于偶数索引，取对中较小的数；对于奇数索引，取对中较大的数。\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // 多次应用算法后得到的最终数字。\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // 应用算法后得到的最终数字。\n*/",
      "fr": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nExécute l'algorithme spécifié sur le tableau 'nums' jusqu'à ce qu'il ne reste qu'un seul nombre.\nLa longueur de 'nums' est une puissance de 2. Pour les indices pairs, prenez le minimum des paires ; pour les indices impairs, prenez le maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nombre final après avoir appliqué l'algorithme de manière répétée.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nombre final après avoir appliqué l'algorithme.\n*/",
      "de": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nFührt den angegebenen Algorithmus auf dem Array 'nums' aus, bis nur noch eine Zahl übrig ist.\nDie Länge von 'nums' ist eine Potenz von 2. Für gerade Indizes wird das Minimum der Paare genommen; für ungerade Indizes das Maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Endgültige Zahl nach wiederholter Anwendung des Algorithmus.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Endgültige Zahl nach Anwendung des Algorithmus.\n*/",
      "ha": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nAiwatar da tsarin da aka fayyace akan jerin 'nums' har sai an bar lamba daya kawai.\nTsawon 'nums' iko ne na 2. Don alamun ma'aurata, dauki mafi karancin ma'aurata; don alamun marasa ma'aurata, dauki mafi girma.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Lamba ta ƙarshe bayan an yi amfani da tsarin a kai a kai.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Lamba ta ƙarshe bayan an yi amfani da tsarin.\n*/",
      "hi": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\n'nums' सरणी पर निर्दिष्ट एल्गोरिदम तब तक लागू करता है जब तक केवल एक संख्या नहीं बचती।\n'nums' की लंबाई 2 की शक्ति है। सम सूचकांकों के लिए, जोड़ों का न्यूनतम लें; विषम सूचकांकों के लिए, अधिकतम लें।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // एल्गोरिदम को बार-बार लागू करने के बाद अंतिम संख्या।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // एल्गोरिदम लागू करने के बाद अंतिम संख्या।\n*/",
      "hu": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nVégrehajtja a megadott algoritmust a 'nums' tömbön, amíg csak egy szám marad.\nA 'nums' hossza 2 hatványa. Páros indexeknél a párok minimumát vesszük; páratlan indexeknél a maximumot.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // A végső szám az algoritmus ismételt alkalmazása után.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // A végső szám az algoritmus alkalmazása után.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9864357299095086",
      "hy": "0.9801369618965112",
      "bn": "0.9689516878796746",
      "bg": "0.9784646927185785",
      "zh": "0.9442019451419654",
      "fr": "0.9880084852665427",
      "de": "0.977072691008286",
      "ha": "0.9452632272678348",
      "hi": "0.9837711033479255",
      "hu": "0.9718588421365012"
    },
    "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}",
    "instruction": {
      "en": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Swift a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9229242614647462",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9165571646006728",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)",
    "entry_point": "performAlgorithmOnNums",
    "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n",
      "sq": "Kryen algoritmin e specifikuar mbi vargun 'nums' derisa të mbetet vetëm një numër.\nGjatësia e 'nums' është një fuqi e 2. Për indeksat çift, merret minimumi i çifteve; për indeksat tek, merret maksimumi.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Numri përfundimtar pas zbatimit të përsëritur të algoritmit.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Numri përfundimtar pas zbatimit të algoritmit.",
      "hy": "Կատարում է նշված ալգորիթմը 'nums' զանգվածի վրա մինչև մնա միայն մեկ թիվ:\n'nums'-ի երկարությունը 2-ի աստիճան է: Զույգ ինդեքսների համար վերցրեք զույգերի նվազագույնը; կենտ ինդեքսների համար վերցրեք առավելագույնը:\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Վերջնական թիվը ալգորիթմը բազմիցս կիրառելուց հետո:\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Վերջնական թիվը ալգորիթմը կիրառելուց հետո:",
      "bn": "নির্দিষ্ট অ্যালগরিদমটি 'nums' অ্যারেতে প্রয়োগ করে যতক্ষণ না শুধুমাত্র একটি সংখ্যা বাকি থাকে। 'nums'-এর দৈর্ঘ্য ২-এর ঘাত। জোড়া সূচকের জন্য, জোড়াগুলির মধ্যে সর্বনিম্নটি নিন; বিজোড় সূচকের জন্য, সর্বাধিকটি নিন।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // বারবার অ্যালগরিদম প্রয়োগ করার পরে চূড়ান্ত সংখ্যা।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // অ্যালগরিদম প্রয়োগ করার পরে চূড়ান্ত সংখ্যা।",
      "bg": "Изпълнява посочения алгоритъм върху масива 'nums', докато остане само едно число.\nДължината на 'nums' е степен на 2. За четни индекси вземете минималното от двойките; за нечетни индекси вземете максималното.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Крайно число след многократно прилагане на алгоритъма.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Крайно число след прилагане на алгоритъма.",
      "zh": "对数组 'nums' 执行指定的算法，直到只剩下一个数字。  \n'nums' 的长度是 2 的幂。对于偶数索引，取对中较小的；对于奇数索引，取对中较大的。  \n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])  \n1 // 多次应用算法后最终的数字。  \n>>> performAlgorithmOnNums([10, 100, 30, 20])  \n10 // 应用算法后的最终数字。  ",
      "fr": "Effectue l'algorithme spécifié sur le tableau 'nums' jusqu'à ce qu'il ne reste qu'un seul nombre.\nLa longueur de 'nums' est une puissance de 2. Pour les indices pairs, prenez le minimum des paires ; pour les indices impairs, prenez le maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nombre final après avoir appliqué l'algorithme de manière répétée.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nombre final après avoir appliqué l'algorithme.",
      "de": "Führt den angegebenen Algorithmus auf dem Array 'nums' aus, bis nur noch eine Zahl übrig ist. Die Länge von 'nums' ist eine Potenz von 2. Für gerade Indizes wird das Minimum der Paare genommen; für ungerade Indizes wird das Maximum genommen.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Letzte Zahl nach wiederholter Anwendung des Algorithmus.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Letzte Zahl nach Anwendung des Algorithmus.",
      "ha": "Yana aiwatar da tsarin da aka fayyace akan jerin 'nums' har sai an bar lamba daya kawai.\nTsawon 'nums' iko ne na 2. Don alamomin ma'aurata, ɗauki mafi ƙarancin ma'aurata; don alamomin marasa ma'aurata, ɗauki mafi girma.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Lamba ta ƙarshe bayan maimaita amfani da tsarin.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Lamba ta ƙarshe bayan amfani da tsarin.",
      "hi": "निर्दिष्ट एल्गोरिदम को 'nums' सरणी पर तब तक लागू करता है जब तक केवल एक संख्या नहीं बचती। 'nums' की लंबाई 2 की शक्ति है। सम सूचकांकों के लिए, जोड़े का न्यूनतम लें; विषम सूचकांकों के लिए, अधिकतम लें।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // एल्गोरिदम को बार-बार लागू करने के बाद अंतिम संख्या।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // एल्गोरिदम को लागू करने के बाद अंतिम संख्या।",
      "hu": "Végrehajtja a megadott algoritmust a 'nums' tömbön, amíg csak egy szám marad. A 'nums' hossza 2 hatványa. Páros indexek esetén vegye a párok minimumát; páratlan indexek esetén vegye a maximumot.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // A végső szám az algoritmus ismételt alkalmazása után.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // A végső szám az algoritmus alkalmazása után."
    },
    "docstring_bertscore": {
      "sq": "0.978980138557364",
      "hy": "0.9829223557297634",
      "bn": "0.9720391985224809",
      "bg": "0.9837782540416428",
      "zh": "0.9414904418104582",
      "fr": "0.9791144126949436",
      "de": "0.9588245179026108",
      "ha": "0.9403469267068403",
      "hi": "0.9810590041252751",
      "hu": "0.9663863765086089"
    }
  },
  {
    "task_id": "Swift/19",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n*/",
      "sq": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nNumëron numrin e vargjeve në 'words' që janë parashtesa të vargut 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", dhe \"abc\" janë parashtesa të \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" dhe \"hell\" janë parashtesa të \"hello\".\n*/",
      "hy": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nՀաշվում է 'words' ցուցակում գտնվող այն տողերի քանակը, որոնք 's' տողի նախածանցներն են:\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" և \"abc\" տողերը \"abc\" տողի նախածանցներն են:\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" և \"hell\" տողերը \"hello\" տողի նախածանցներն են:\n*/",
      "bn": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n'words' তালিকার কতগুলি স্ট্রিং 's' স্ট্রিংয়ের প্রিফিক্স তা গণনা করে।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", এবং \"abc\" হল \"abc\" এর প্রিফিক্স।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" এবং \"hell\" হল \"hello\" এর প্রিফিক্স।\n*/",
      "bg": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nБрои броя на стринговете в 'words', които са префикси на стринга 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" и \"abc\" са префикси на \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" и \"hell\" са префикси на \"hello\".\n*/",
      "zh": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n计算 'words' 中有多少字符串是字符串 's' 的前缀。\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", 和 \"abc\" 是 \"abc\" 的前缀。\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" 和 \"hell\" 是 \"hello\" 的前缀。\n*/",
      "fr": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCompte le nombre de chaînes dans 'words' qui sont des préfixes de la chaîne 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", et \"abc\" sont des préfixes de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" et \"hell\" sont des préfixes de \"hello\".\n*/",
      "de": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nZählt die Anzahl der Zeichenfolgen in 'words', die Präfixe der Zeichenfolge 's' sind.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" und \"abc\" sind Präfixe von \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" und \"hell\" sind Präfixe von \"hello\".\n*/",
      "ha": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nYana ƙididdige yawan igiyoyi a cikin 'words' waɗanda suke farkon igiyar 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", da \"abc\" su ne farkon \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" da \"hell\" su ne farkon \"hello\".\n*/",
      "hi": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n'words' में उन स्ट्रिंग्स की संख्या गिनता है जो स्ट्रिंग 's' की उपसर्ग हैं।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", और \"abc\" \"abc\" के उपसर्ग हैं।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" और \"hell\" \"hello\" के उपसर्ग हैं।\n*/",
      "hu": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nSzámolja meg, hogy hány 'words' listában található string előtagja az 's' stringnek.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", és \"abc\" előtagjai az \"abc\"-nek.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" és \"hell\" előtagjai a \"hello\"-nak.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9598955329171509",
      "bn": "0.9755708466972812",
      "bg": "0.999999801369619",
      "zh": "0.9798539136035365",
      "fr": "0.999999801369619",
      "de": "0.9970497429504888",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.9741681189464128"
    },
    "canonical_solution": "return words.filter { s.hasPrefix($0) }.count\n}",
    "instruction": {
      "en": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nনিচের Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\n请用最多500个字符的中文为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8897005494113266",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.851921646829634",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func checkCountPrefixes(_ countPrefixes: ([String], String) -> Int) {\nassert(countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\") == 2)\nassert(countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\") == 2)\nassert(countPrefixes([\"app\", \"apple\", \"apricot\", \"ap\"], \"apple\") == 3)\nassert(countPrefixes([\"blue\", \"blues\", \"blueberry\"], \"blue\") == 1)\nassert(countPrefixes([\"no\", \"match\"], \"yes\") == 0)\nassert(countPrefixes([], \"empty\") == 0)\nassert(countPrefixes([\"full\", \"fullest\", \"ful\"], \"fullest\") == 3)\n}\n\ncheckCountPrefixes(countPrefixes)",
    "entry_point": "countPrefixes",
    "signature": "func countPrefixes(_ words: [String], _ s: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n",
      "sq": "Numëron numrin e vargjeve në 'words' që janë parashtesa të vargut 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", dhe \"abc\" janë parashtesa të \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" dhe \"hell\" janë parashtesa të \"hello\".",
      "hy": "Հաշվում է 'words' ցուցակում գտնվող տողերի քանակը, որոնք 's' տողի նախածանցներն են:\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" և \"abc\" տողերը \"abc\" տողի նախածանցներն են։\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" և \"hell\" տողերը \"hello\" տողի նախածանցներն են։",
      "bn": "'words' এর মধ্যে কতগুলি স্ট্রিং 's' এর উপসর্গ তা গণনা করে।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", এবং \"abc\" হল \"abc\" এর উপসর্গ।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" এবং \"hell\" হল \"hello\" এর উপসর্গ।",
      "bg": "Брои броя на низовете в 'words', които са префикси на низа 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" и \"abc\" са префикси на \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" и \"hell\" са префикси на \"hello\".",
      "zh": "计算 'words' 中作为字符串 's' 前缀的字符串数量。\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"、\"ab\" 和 \"abc\" 是 \"abc\" 的前缀。\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" 和 \"hell\" 是 \"hello\" 的前缀。",
      "fr": "Compte le nombre de chaînes dans 'words' qui sont des préfixes de la chaîne 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", et \"abc\" sont des préfixes de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" et \"hell\" sont des préfixes de \"hello\".",
      "de": "Zählt die Anzahl der Zeichenfolgen in 'words', die Präfixe der Zeichenfolge 's' sind.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" und \"abc\" sind Präfixe von \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" und \"hell\" sind Präfixe von \"hello\".",
      "ha": "Yana ƙidaya yawan igiyoyin rubutu a cikin 'words' waɗanda suke farkon igiyar rubutu 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", da \"abc\" su ne farkon \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" da \"hell\" su ne farkon \"hello\".",
      "hi": "'words' में उन स्ट्रिंग्स की संख्या गिनता है जो स्ट्रिंग 's' के उपसर्ग हैं।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", और \"abc\" \"abc\" के उपसर्ग हैं।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" और \"hell\" \"hello\" के उपसर्ग हैं।",
      "hu": "Megszámolja a 'words' listában található azon karakterláncok számát, amelyek a 's' karakterlánc előtagjai.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" és \"abc\" az \"abc\" előtagjai.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" és \"hell\" az \"hello\" előtagjai."
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9537089910694383",
      "bn": "0.9615560829026025",
      "bg": "0.999999801369619",
      "zh": "0.9865964218877658",
      "fr": "0.9889261576269239",
      "de": "0.9963668517004909",
      "ha": "0.9940957119237379",
      "hi": "0.9758076141114748",
      "hu": "0.9701599564875097"
    }
  },
  {
    "task_id": "Swift/20",
    "prompt": {
      "en": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "sq": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nGjen dy numra në 'nums' shuma e të cilëve është e barabartë me 'target', dhe kthen indeksat e tyre.\nSupozon që çdo hyrje ka saktësisht një zgjidhje, dhe i njëjti element nuk mund të përdoret dy herë.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "hy": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nԳտնում է 'nums'-ում երկու թիվ, որոնց գումարը հավասար է 'target'-ին, և վերադարձնում է նրանց ինդեքսները։\nԵնթադրվում է, որ յուրաքանչյուր մուտք ունի միայն մեկ լուծում, և նույն տարրը չի կարող օգտագործվել երկու անգամ։\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "bn": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n'nums' এর মধ্যে দুটি সংখ্যা খুঁজে বের করে যাদের যোগফল 'target' এর সমান, এবং তাদের সূচকগুলি ফেরত দেয়।\nধরা হয়েছে যে প্রতিটি ইনপুটের ঠিক একটি সমাধান আছে, এবং একই উপাদান দুবার ব্যবহার করা যাবে না।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "bg": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nНамира две числа в 'nums', чиято сума е равна на 'target', и връща техните индекси.\nПредполага се, че всяко въведено има точно едно решение и един и същ елемент не може да се използва два пъти.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "zh": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n在'nums'中找到两个数，其和等于'target'，并返回它们的索引。\n假设每个输入有且只有一个解决方案，且同一个元素不能被重复使用。\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "fr": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nTrouve deux nombres dans 'nums' dont la somme est égale à 'target', et retourne leurs indices.\nSuppose que chaque entrée a exactement une solution, et qu'un même élément ne peut pas être utilisé deux fois.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "de": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFindet zwei Zahlen in 'nums', deren Summe 'target' entspricht, und gibt deren Indizes zurück.\nEs wird angenommen, dass jede Eingabe genau eine Lösung hat und dass dasselbe Element nicht zweimal verwendet werden kann.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "ha": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nNemo lambobi biyu a cikin 'nums' da jimlarsu ta yi daidai da 'target', kuma ya dawo da alamun su.\nYa ɗauka cewa kowace shigarwa tana da madaidaicin bayani guda ɗaya, kuma ba za a iya amfani da abu ɗaya sau biyu ba.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "hi": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n'nums' में दो संख्याएँ ढूँढता है जिनका योग 'target' के बराबर होता है, और उनके सूचकांक लौटाता है।\nमानता है कि प्रत्येक इनपुट का ठीक एक समाधान होता है, और एक ही तत्व का दो बार उपयोग नहीं किया जा सकता।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "hu": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nMegkeresi azokat a számokat a 'nums' listában, amelyek összege megegyezik a 'target' értékkel, és visszaadja azok indexeit.\nFeltételezi, hogy minden bemenetnek pontosan egy megoldása van, és ugyanazt az elemet nem lehet kétszer felhasználni.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9908925983991693",
      "hy": "0.9794032212689683",
      "bn": "0.9823481152981915",
      "bg": "0.9855254068732257",
      "zh": "0.9889345001029274",
      "fr": "0.9908925983991693",
      "de": "0.99168731855369",
      "ha": "0.9904540225178443",
      "hi": "0.9908925983991693",
      "hu": "0.9629901942536745"
    },
    "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}",
    "instruction": {
      "en": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nՏվեք Swift կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nনিচের Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nBa da taƙaitaccen bayani a cikin yaren ɗabi'a (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9324648759266139",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9140822300529781",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)",
    "entry_point": "twoSum",
    "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {",
    "docstring": {
      "en": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n",
      "sq": "Gjen dy numra në 'nums' shuma e të cilëve është e barabartë me 'target', dhe kthen indeksat e tyre. Supozohet që çdo hyrje ka saktësisht një zgjidhje, dhe i njëjti element nuk mund të përdoret dy herë.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hy": "Գտնում է 'nums'-ում երկու թվեր, որոնց գումարը հավասար է 'target'-ին, և վերադարձնում է դրանց ինդեքսները։ \nԵնթադրում է, որ յուրաքանչյուր մուտք ունի հենց մեկ լուծում, և նույն տարրը չի կարող օգտագործվել երկու անգամ։ \n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "bn": "'nums' তালিকায় দুটি সংখ্যা খুঁজে বের করে যাদের যোগফল 'target' এর সমান হয় এবং তাদের সূচকগুলি ফেরত দেয়। ধরে নেওয়া হয় যে প্রতিটি ইনপুটের ঠিক একটি সমাধান আছে এবং একই উপাদান দুবার ব্যবহার করা যাবে না।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "bg": "Намира две числа в 'nums', чиято сума е равна на 'target', и връща техните индекси. \nПредполага се, че всеки вход има точно едно решение и един и същ елемент не може да се използва два пъти.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "zh": "在“nums”中查找两个数字，其和等于“target”，并返回它们的索引。  \n假设每个输入恰好有一个解决方案，并且同一个元素不能使用两次。  \n>>> twoSum([2, 7, 11, 15], 9)  \n[0, 1] // nums[0] + nums[1] == 9  \n>>> twoSum([3, 2, 4], 6)  \n[1, 2] // nums[1] + nums[2] == 6  ",
      "fr": "Trouve deux nombres dans 'nums' dont la somme est égale à 'target', et renvoie leurs indices.\nSuppose que chaque entrée a exactement une solution, et que le même élément ne peut pas être utilisé deux fois.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "de": "Findet zwei Zahlen in 'nums', deren Summe 'target' entspricht, und gibt deren Indizes zurück.\nNimmt an, dass jede Eingabe genau eine Lösung hat und dass dasselbe Element nicht zweimal verwendet werden kann.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "ha": "Nemi lambobi biyu a cikin 'nums' da adadin su ya yi daidai da 'target', kuma ya dawo da alamun su. \nYa ɗauka cewa kowace shigarwa tana da madaidaicin mafita guda ɗaya, kuma ba za a iya amfani da abu ɗaya sau biyu ba.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hi": "'nums' में दो संख्याएँ खोजता है जिनका योग 'target' के बराबर होता है, और उनके सूचकांक लौटाता है। यह मानता है कि प्रत्येक इनपुट का ठीक एक समाधान होता है, और एक ही तत्व का दो बार उपयोग नहीं किया जा सकता।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hu": "Két számot keres a 'nums' listában, amelyek összege megegyezik a 'target' értékkel, és visszaadja azok indexeit. Feltételezi, hogy minden bemenetnek pontosan egy megoldása van, és ugyanazt az elemet nem lehet kétszer felhasználni.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6"
    },
    "docstring_bertscore": {
      "sq": "0.9695390379163947",
      "hy": "0.9885811366550663",
      "bn": "0.9591792717631391",
      "bg": "0.9818471694772216",
      "zh": "0.9776957945135925",
      "fr": "0.9829781708668343",
      "de": "0.9876443957781058",
      "ha": "0.9875450805875884",
      "hi": "0.9678860358854224",
      "hu": "0.9627832213966361"
    }
  },
  {
    "task_id": "Swift/21",
    "prompt": {
      "en": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "sq": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nPërcakton koordinatat e kulmit të katërt të një drejtkëndëshi kur jepen koordinatat e tre kulmeve.\nAnët e drejtkëndëshit supozohet të jenë paralele me boshtet e koordinatave.\n\n- Parametrat:\n- vertex1: Një dyshe që përfaqëson koordinatat e kulmit të parë.\n- vertex2: Një dyshe që përfaqëson koordinatat e kulmit të dytë.\n- vertex3: Një dyshe që përfaqëson koordinatat e kulmit të tretë.\n\n- Kthen: Një dyshe që përfaqëson koordinatat e kulmit të katërt.\n\nShembull përdorimi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "hy": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nՍահմանում է ուղղանկյան չորրորդ գագաթի կոորդինատները, երբ տրված են երեք գագաթների կոորդինատները։\nԵնթադրվում է, որ ուղղանկյան կողմերը զուգահեռ են կոորդինատային առանցքներին։\n\n- Պարամետրեր:\n- vertex1: Կոորդինատների առաջին գագաթը ներկայացնող զույգ։\n- vertex2: Կոորդինատների երկրորդ գագաթը ներկայացնող զույգ։\n- vertex3: Կոորդինատների երրորդ գագաթը ներկայացնող զույգ։\n\n- Վերադարձնում է: Կոորդինատների չորրորդ գագաթը ներկայացնող զույգ։\n\nՕրինակ օգտագործում:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "bn": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nযখন তিনটি শীর্ষবিন্দুর স্থানাঙ্ক দেওয়া থাকে তখন একটি আয়তক্ষেত্রের চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক নির্ধারণ করে।\nআয়তক্ষেত্রের বাহুগুলি স্থানাঙ্ক অক্ষের সমান্তরাল বলে ধরা হয়।\n\n- প্যারামিটার:\n- vertex1: প্রথম শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n- vertex2: দ্বিতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n- vertex3: তৃতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n\n- রিটার্নস: চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n\nউদাহরণ ব্যবহার:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "bg": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nОпределя координатите на четвъртата връхна точка на правоъгълник, когато са дадени координатите на три връхни точки.\nПредполага се, че страните на правоъгълника са успоредни на координатните оси.\n\n- Параметри:\n- vertex1: Кортеж, представляващ координатите на първата връхна точка.\n- vertex2: Кортеж, представляващ координатите на втората връхна точка.\n- vertex3: Кортеж, представляващ координатите на третата връхна точка.\n\n- Връща: Кортеж, представляващ координатите на четвъртата връхна точка.\n\nПример за използване:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "zh": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\n确定矩形第四个顶点的坐标，给定三个顶点的坐标。\n假设矩形的边与坐标轴平行。\n\n- 参数:\n- vertex1: 表示第一个顶点坐标的元组。\n- vertex2: 表示第二个顶点坐标的元组。\n- vertex3: 表示第三个顶点坐标的元组。\n\n- 返回: 表示第四个顶点坐标的元组。\n\n示例用法:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "fr": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDétermine les coordonnées du quatrième sommet d'un rectangle lorsque les coordonnées de trois sommets sont données.\nLes côtés du rectangle sont supposés être parallèles aux axes de coordonnées.\n\n- Paramètres:\n- vertex1: Un tuple représentant les coordonnées du premier sommet.\n- vertex2: Un tuple représentant les coordonnées du deuxième sommet.\n- vertex3: Un tuple représentant les coordonnées du troisième sommet.\n\n- Retourne: Un tuple représentant les coordonnées du quatrième sommet.\n\nExemple d'utilisation:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "de": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nBestimmt die Koordinaten des vierten Scheitelpunkts eines Rechtecks, wenn die Koordinaten von drei Scheitelpunkten gegeben sind.\nEs wird angenommen, dass die Seiten des Rechtecks parallel zu den Koordinatenachsen verlaufen.\n\n- Parameter:\n- vertex1: Ein Tupel, das die Koordinaten des ersten Scheitelpunkts darstellt.\n- vertex2: Ein Tupel, das die Koordinaten des zweiten Scheitelpunkts darstellt.\n- vertex3: Ein Tupel, das die Koordinaten des dritten Scheitelpunkts darstellt.\n\n- Rückgabe: Ein Tupel, das die Koordinaten des vierten Scheitelpunkts darstellt.\n\nBeispielverwendung:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "ha": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nYana tantance ko'odinatan kusurwar ta huɗu na murabba'i idan an ba da ko'odinatan kusurwoyi uku.\nAna ɗauka gefen murabba'in suna daidai da jujjuyawar ko'odinet.\n\n- Ma'auni:\n- vertex1: Tagwaye suna wakiltar ko'odinatan kusurwar farko.\n- vertex2: Tagwaye suna wakiltar ko'odinatan kusurwar ta biyu.\n- vertex3: Tagwaye suna wakiltar ko'odinatan kusurwar ta uku.\n\n- Komawa: Tagwaye suna wakiltar ko'odinatan kusurwar ta huɗu.\n\nMisalin amfani:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "hi": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nजब तीन शीर्षों के निर्देशांक दिए जाते हैं, तो आयत के चौथे शीर्ष के निर्देशांक निर्धारित करता है।\nआयत की भुजाएँ निर्देशांक अक्षों के समानांतर मानी जाती हैं।\n\n- पैरामीटर्स:\n- vertex1: पहले शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n- vertex2: दूसरे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n- vertex3: तीसरे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n\n- रिटर्न्स: चौथे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n\nउदाहरण उपयोग:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "hu": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nMeghatározza a negyedik csúcs koordinátáit egy téglalap esetén, ha három csúcs koordinátái adottak.\nFeltételezzük, hogy a téglalap oldalai párhuzamosak a koordináta-tengelyekkel.\n\n- Paraméterek:\n- vertex1: Egy tuple, amely az első csúcs koordinátáit jelöli.\n- vertex2: Egy tuple, amely a második csúcs koordinátáit jelöli.\n- vertex3: Egy tuple, amely a harmadik csúcs koordinátáit jelöli.\n\n- Visszatérési érték: Egy tuple, amely a negyedik csúcs koordinátáit jelöli.\n\nPélda használat:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9740900572066661",
      "hy": "0.9677763919150911",
      "bn": "0.9824202181265073",
      "bg": "0.9824202181265073",
      "zh": "0.9864984971099156",
      "fr": "0.9836481511420649",
      "de": "0.9824202181265073",
      "ha": "0.982390423569352",
      "hi": "0.9740900572066661",
      "hu": "0.9753348738046117"
    },
    "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}",
    "instruction": {
      "en": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nՏվեք Swift կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9390159045235256",
      "hy": "0.9324648759266139",
      "bn": "0.8370742244776571",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)",
    "entry_point": "findFourthVertex",
    "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {",
    "docstring": {
      "en": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n",
      "sq": "Përcakton koordinatat e kulmit të katërt të një drejtkëndëshi kur jepen koordinatat e tre kulmeve.\nAnët e drejtkëndëshit supozohet të jenë paralele me boshtet e koordinatave.\n\n- Parametrat:\n- vertex1: Një dyshe që përfaqëson koordinatat e kulmit të parë.\n- vertex2: Një dyshe që përfaqëson koordinatat e kulmit të dytë.\n- vertex3: Një dyshe që përfaqëson koordinatat e kulmit të tretë.\n\n- Kthen: Një dyshe që përfaqëson koordinatat e kulmit të katërt.\n\nShembull përdorimi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hy": "Որոշում է ուղղանկյան չորրորդ գագաթի կոորդինատները, երբ տրված են երեք գագաթների կոորդինատները։ \nԵնթադրվում է, որ ուղղանկյան կողմերը զուգահեռ են կոորդինատային առանցքներին։\n\n- Պարամետրեր:\n- vertex1: Կոորդինատների առաջին գագաթի ներկայացնող տյուպլ։\n- vertex2: Կոորդինատների երկրորդ գագաթի ներկայացնող տյուպլ։\n- vertex3: Կոորդինատների երրորդ գագաթի ներկայացնող տյուպլ։\n\n- Վերադարձնում է: Չորրորդ գագաթի կոորդինատների ներկայացնող տյուպլ։\n\nՕրինակ օգտագործում:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "bn": "চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক নির্ধারণ করে যখন তিনটি শীর্ষবিন্দুর স্থানাঙ্ক দেওয়া হয়। আয়তক্ষেত্রের বাহুগুলি স্থানাঙ্ক অক্ষের সাথে সমান্তরাল বলে অনুমান করা হয়।\n\n- প্যারামিটারসমূহ:\n- vertex1: প্রথম শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n- vertex2: দ্বিতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n- vertex3: তৃতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n\n- রিটার্নস: চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n\nউদাহরণ ব্যবহার:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "bg": "Определя координатите на четвъртата връхна точка на правоъгълник, когато са дадени координатите на три връхни точки. Страните на правоъгълника се предполага, че са успоредни на координатните оси.\n\n- Параметри:\n- vertex1: Кортеж, представляващ координатите на първата връхна точка.\n- vertex2: Кортеж, представляващ координатите на втората връхна точка.\n- vertex3: Кортеж, представляващ координатите на третата връхна точка.\n\n- Връща: Кортеж, представляващ координатите на четвъртата връхна точка.\n\nПример за използване:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "zh": "确定矩形第四个顶点的坐标，当给定三个顶点的坐标时。\n假设矩形的边与坐标轴平行。\n\n- 参数：\n- vertex1: 一个表示第一个顶点坐标的元组。\n- vertex2: 一个表示第二个顶点坐标的元组。\n- vertex3: 一个表示第三个顶点坐标的元组。\n\n- 返回值：一个表示第四个顶点坐标的元组。\n\n示例用法：\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "fr": "Détermine les coordonnées du quatrième sommet d'un rectangle lorsque les coordonnées de trois sommets sont données. Les côtés du rectangle sont supposés être parallèles aux axes de coordonnées.\n\n- Paramètres:\n- vertex1: Un tuple représentant les coordonnées du premier sommet.\n- vertex2: Un tuple représentant les coordonnées du deuxième sommet.\n- vertex3: Un tuple représentant les coordonnées du troisième sommet.\n\n- Retourne: Un tuple représentant les coordonnées du quatrième sommet.\n\nExemple d'utilisation :\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "de": "Bestimmt die Koordinaten des vierten Scheitelpunkts eines Rechtecks, wenn die Koordinaten von drei Scheitelpunkten gegeben sind. Es wird angenommen, dass die Seiten des Rechtecks parallel zu den Koordinatenachsen verlaufen.\n\n- Parameter:\n- vertex1: Ein Tupel, das die Koordinaten des ersten Scheitelpunkts darstellt.\n- vertex2: Ein Tupel, das die Koordinaten des zweiten Scheitelpunkts darstellt.\n- vertex3: Ein Tupel, das die Koordinaten des dritten Scheitelpunkts darstellt.\n\n- Rückgabe: Ein Tupel, das die Koordinaten des vierten Scheitelpunkts darstellt.\n\nBeispielverwendung:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "ha": "Yana ƙayyade daidaiton tsawo na kusurwar murabba'i lokacin da aka ba da daidaiton tsawo na kusurwoyi uku.\nAna ɗauka cewa gefen murabba'in suna daidai da jigon daidaitawa.\n\n- Sigogi:\n- vertex1: Wani tuple da ke wakiltar daidaiton tsawo na kusurwar farko.\n- vertex2: Wani tuple da ke wakiltar daidaiton tsawo na kusurwar biyu.\n- vertex3: Wani tuple da ke wakiltar daidaiton tsawo na kusurwar uku.\n\n- Komawa: Wani tuple da ke wakiltar daidaiton tsawo na kusurwar hudu.\n\nMisalin amfani:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hi": "चौथे शीर्ष बिंदु के निर्देशांक निर्धारित करता है जब तीन शीर्ष बिंदुओं के निर्देशांक दिए गए हों।\nआयत की भुजाएँ निर्देशांक अक्षों के समानांतर मानी जाती हैं।\n\n- पैरामीटर्स:\n- vertex1: पहले शीर्ष बिंदु के निर्देशांक को दर्शाने वाला एक युग्म।\n- vertex2: दूसरे शीर्ष बिंदु के निर्देशांक को दर्शाने वाला एक युग्म।\n- vertex3: तीसरे शीर्ष बिंदु के निर्देशांक को दर्शाने वाला एक युग्म।\n\n- रिटर्न: चौथे शीर्ष बिंदु के निर्देशांक को दर्शाने वाला एक युग्म।\n\nउदाहरण उपयोग:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hu": "Meghatározza egy téglalap negyedik csúcsának koordinátáit, ha megadjuk három csúcs koordinátáit.\nFeltételezzük, hogy a téglalap oldalai párhuzamosak a koordináta-tengelyekkel.\n\n- Paraméterek:\n- vertex1: Egy tuple, amely az első csúcs koordinátáit jelöli.\n- vertex2: Egy tuple, amely a második csúcs koordinátáit jelöli.\n- vertex3: Egy tuple, amely a harmadik csúcs koordinátáit jelöli.\n\n- Visszatérési érték: Egy tuple, amely a negyedik csúcs koordinátáit jelöli.\n\nPélda használat:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)"
    },
    "docstring_bertscore": {
      "sq": "0.9661754310439499",
      "hy": "0.9780914662326139",
      "bn": "0.9741502422121197",
      "bg": "0.9609387396783461",
      "zh": "0.9842770149284213",
      "fr": "0.9773984448331832",
      "de": "0.9780914662326139",
      "ha": "0.9763717243936139",
      "hi": "0.958837230246997",
      "hu": "0.9723512468510866"
    }
  },
  {
    "task_id": "Swift/22",
    "prompt": {
      "en": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/",
      "sq": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nKjo funksion llogarit numrin e figurave të shahut që duhet të shtohen ose të hiqen për të plotësuar një set standard shahu. Një set i plotë përbëhet nga 1 Mbret, 1 Mbretëreshë, 2 Kulla, 2 Oficerë, 2 Kalorës dhe 8 Ushtarë.\n\nHyrja është një varg me gjashtë numra të plotë që përfaqësojnë numrin e secilës figurë në rendin: Mbret, Mbretëreshë, Kullë, Oficer, Kalorës, Ushtar. Çdo numër është midis 0 dhe 10 përfshirë.\n\nFunksioni kthen një varg me gjashtë numra të plotë që tregojnë sa figura të secilit lloj duhet të shtohen (numër pozitiv) ose të hiqen (numër negativ) për të plotësuar setin.\n\nShembull:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti është tashmë i plotë\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Shto 1 Mbret, hiq 1 Mbretëreshë, shto 1 Kullë, shto 3 Ushtarë\n*/",
      "hy": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nԱյս ֆունկցիան հաշվարկում է, թե քանի շախմատի խաղաքար պետք է ավելացնել կամ հեռացնել, որպեսզի ստացվի ստանդարտ շախմատի հավաքածու: Լրիվ հավաքածուն բաղկացած է 1 Թագավորից, 1 Թագուհուց, 2 Նավակներից, 2 Փիղերից, 2 Ձիերից և 8 Զինվորներից:\n\nՄուտքը վեց ամբողջ թվերի զանգված է, որը ներկայացնում է յուրաքանչյուր խաղաքարի քանակը հետևյալ կարգով՝ Թագավոր, Թագուհի, Նավակ, Փիղ, Ձի, Զինվոր: Յուրաքանչյուր թիվ գտնվում է 0-ից մինչև 10 ներառյալ միջակայքում:\n\nՖունկցիան վերադարձնում է վեց ամբողջ թվերի զանգված, որը ցույց է տալիս, թե քանի խաղաքար պետք է ավելացնել (դրական թիվ) կամ հեռացնել (բացասական թիվ), որպեսզի հավաքածուն լրիվ լինի:\n\nՕրինակ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Հավաքածուն արդեն լրիվ է\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ավելացնել 1 Թագավոր, հեռացնել 1 Թագուհի, ավելացնել 1 Նավակ, ավելացնել 3 Զինվոր\n*/",
      "bn": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nএই ফাংশনটি একটি সম্পূর্ণ দাবার সেট সম্পন্ন করতে কতগুলি দাবার গুটি যোগ বা অপসারণ করতে হবে তা গণনা করে। একটি সম্পূর্ণ সেটে থাকে 1টি রাজা, 1টি রাণী, 2টি রুক, 2টি বিশপ, 2টি নাইট এবং 8টি পন।\n\nইনপুটটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে যা প্রতিটি গুটির সংখ্যা নির্দেশ করে নিম্নলিখিত ক্রমে: রাজা, রাণী, রুক, বিশপ, নাইট, পন। প্রতিটি সংখ্যা 0 থেকে 10 এর মধ্যে অন্তর্ভুক্ত।\n\nফাংশনটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে ফেরত দেয় যা নির্দেশ করে কতগুলি গুটি যোগ (ধনাত্মক সংখ্যা) বা অপসারণ (ঋণাত্মক সংখ্যা) করতে হবে সেট সম্পন্ন করতে।\n\nউদাহরণ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // সেটটি ইতিমধ্যেই সম্পূর্ণ\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1টি রাজা যোগ করুন, 1টি রাণী অপসারণ করুন, 1টি রুক যোগ করুন, 3টি পন যোগ করুন\n*/",
      "bg": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nТази функция изчислява броя на шахматните фигури, които трябва да бъдат добавени или премахнати, за да се завърши стандартен шахматен комплект. Пълен комплект се състои от 1 Цар, 1 Царица, 2 Топа, 2 Офицера, 2 Коня и 8 Пешки.\n\nВходът е масив от шест цели числа, представляващи броя на всяка фигура в следния ред: Цар, Царица, Топ, Офицер, Кон, Пешка. Всяко число е между 0 и 10 включително.\n\nФункцията връща масив от шест цели числа, показващи колко фигури от всеки тип трябва да бъдат добавени (положително число) или премахнати (отрицателно число), за да се завърши комплектът.\n\nПример:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Комплектът вече е завършен\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Добавете 1 Цар, премахнете 1 Царица, добавете 1 Топ, добавете 3 Пешки\n*/",
      "zh": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\n此函数计算需要添加或移除多少棋子才能完成一副标准的国际象棋棋子套装。一个完整的套装包括1个国王，1个皇后，2个车，2个象，2个马，和8个兵。\n\n输入是一个包含六个整数的数组，表示每种棋子的数量，顺序为：国王，皇后，车，象，马，兵。每个数字在0到10之间（包括0和10）。\n\n函数返回一个包含六个整数的数组，表示每种棋子需要添加（正数）或移除（负数）的数量以完成套装。\n\n例子:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // 套装已经完整\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 添加1个国王，移除1个皇后，添加1个车，添加3个兵\n*/",
      "fr": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nCette fonction calcule le nombre de pièces d'échecs qui doivent être ajoutées ou retirées pour compléter un jeu d'échecs standard. Un jeu complet se compose de 1 Roi, 1 Reine, 2 Tours, 2 Fous, 2 Cavaliers et 8 Pions.\n\nL'entrée est un tableau de six entiers représentant le nombre de chaque pièce dans l'ordre : Roi, Reine, Tour, Fou, Cavalier, Pion. Chaque nombre est compris entre 0 et 10 inclus.\n\nLa fonction renvoie un tableau de six entiers indiquant combien de pièces de chaque type doivent être ajoutées (nombre positif) ou retirées (nombre négatif) pour compléter le jeu.\n\nExemple:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Le jeu est déjà complet\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ajouter 1 Roi, retirer 1 Reine, ajouter 1 Tour, ajouter 3 Pions\n*/",
      "de": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nDiese Funktion berechnet die Anzahl der Schachfiguren, die hinzugefügt oder entfernt werden müssen, um ein vollständiges Standardschachset zu vervollständigen. Ein vollständiges Set besteht aus 1 König, 1 Dame, 2 Türmen, 2 Läufern, 2 Springern und 8 Bauern.\n\nDie Eingabe ist ein Array von sechs ganzen Zahlen, die die Anzahl jeder Figur in der Reihenfolge: König, Dame, Turm, Läufer, Springer, Bauer darstellen. Jede Zahl liegt zwischen 0 und 10 einschließlich.\n\nDie Funktion gibt ein Array von sechs ganzen Zahlen zurück, das angibt, wie viele Figuren jeder Art hinzugefügt (positive Zahl) oder entfernt (negative Zahl) werden müssen, um das Set zu vervollständigen.\n\nBeispiel:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Das Set ist bereits vollständig\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 König hinzufügen, 1 Dame entfernen, 1 Turm hinzufügen, 3 Bauern hinzufügen\n*/",
      "ha": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nWannan aikin yana ƙididdige adadin ƙananan wasannin catur da ake buƙata a ƙara ko cire don kammala saitin catur na al'ada. Saitin cikakke yana ƙunshe da Sarki 1, Sarauniya 1, Rook 2, Bishop 2, Knight 2, da Pawn 8.\n\nShigarwar shi ne jerin lambobi guda shida da ke wakiltar adadin kowanne nau'in a cikin tsari: Sarki, Sarauniya, Rook, Bishop, Knight, Pawn. Kowanne lamba yana tsakanin 0 da 10 ciki har da.\n\nAikin yana dawo da jerin lambobi guda shida da ke nuna yawan ƙananan wasannin kowanne nau'in da ake buƙatar a ƙara (lamba mai kyau) ko cire (lamba mara kyau) don kammala saitin.\n\nMisali:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Saitin ya riga ya cika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ƙara Sarki 1, cire Sarauniya 1, ƙara Rook 1, ƙara Pawn 3\n*/",
      "hi": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nयह फ़ंक्शन उन शतरंज के मोहरों की संख्या की गणना करता है जिन्हें एक मानक शतरंज सेट को पूरा करने के लिए जोड़ा या हटाया जाना चाहिए। एक पूर्ण सेट में 1 राजा, 1 रानी, 2 हाथी, 2 ऊंट, 2 घोड़े, और 8 प्यादे होते हैं।\n\nइनपुट छह पूर्णांकों की एक सूची है जो क्रम में प्रत्येक मोहरे की गिनती को दर्शाती है: राजा, रानी, हाथी, ऊंट, घोड़ा, प्यादा। प्रत्येक संख्या 0 से 10 के बीच (समावेशी) होती है।\n\nयह फ़ंक्शन छह पूर्णांकों की एक सूची लौटाता है जो यह दर्शाती है कि सेट को पूरा करने के लिए प्रत्येक प्रकार के कितने मोहरे जोड़े (सकारात्मक संख्या) या हटाए (ऋणात्मक संख्या) जाने चाहिए।\n\nउदाहरण:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // सेट पहले से ही पूरा है\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 राजा जोड़ें, 1 रानी हटाएं, 1 हाथी जोड़ें, 3 प्यादे जोड़ें\n*/",
      "hu": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nEz a függvény kiszámítja, hogy hány sakkfigurát kell hozzáadni vagy eltávolítani egy teljes szabványos sakk készlethez. Egy teljes készlet 1 királyból, 1 királynőből, 2 bástyából, 2 futóból, 2 huszárból és 8 gyalogból áll.\n\nA bemenet egy hat egész számot tartalmazó tömb, amely az egyes figurák számát jelzi a következő sorrendben: király, királynő, bástya, futó, huszár, gyalog. Minden szám 0 és 10 között van, beleértve.\n\nA függvény egy hat egész számot tartalmazó tömböt ad vissza, amely jelzi, hogy hány darabot kell hozzáadni (pozitív szám) vagy eltávolítani (negatív szám) az egyes típusú figurákból a készlet teljessé tételéhez.\n\nPélda:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // A készlet már teljes\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Adjunk hozzá 1 királyt, távolítsunk el 1 királynőt, adjunk hozzá 1 bástyát, adjunk hozzá 3 gyalogot\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9980560044608116",
      "hy": "0.981109058981296",
      "bn": "0.9491230128321048",
      "bg": "0.99338401926849",
      "zh": "0.9562155078477175",
      "fr": "0.9980560044608116",
      "de": "0.9664598697495919",
      "ha": "0.9821449164183929",
      "hi": "0.9539372173772473",
      "hu": "0.9559932404513395"
    },
    "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}",
    "instruction": {
      "en": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки най-много 500 символа.",
      "zh": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nBayar da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.8990590198137853",
      "bn": "0.8679241048473287",
      "bg": "0.8463854208494296",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9664368286253918",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()",
    "entry_point": "adjustChessPieces",
    "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n",
      "sq": "Kjo funksion llogarit numrin e figurave të shahut që duhet të shtohen ose të hiqen për të plotësuar një set standard shahu. Një set i plotë përbëhet nga 1 Mbret, 1 Mbretëreshë, 2 Topa, 2 Oficerë, 2 Kalorës dhe 8 Ushtarë.\n\nHyrja është një varg me gjashtë numra të plotë që përfaqësojnë numrin e secilës figurë në rendin: Mbret, Mbretëreshë, Top, Oficer, Kalorës, Ushtar. Secili numër është midis 0 dhe 10 përfshirë.\n\nFunksioni kthen një varg me gjashtë numra të plotë që tregojnë sa figura të secilit lloj duhet të shtohen (numër pozitiv) ose të hiqen (numër negativ) për të plotësuar setin.\n\nShembull:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti është tashmë i plotë\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Shto 1 Mbret, hiq 1 Mbretëreshë, shto 1 Top, shto 3 Ushtarë",
      "hy": "Այս ֆունկցիան հաշվարկում է շախմատի քարերի քանակը, որոնք անհրաժեշտ է ավելացնել կամ հեռացնել՝ ստանդարտ շախմատային հավաքածուն ամբողջացնելու համար։ Ամբողջական հավաքածուն բաղկացած է 1 Թագավորից, 1 Թագուհուց, 2 Նավակներից, 2 Փիղերից, 2 Ձիերից և 8 Զինվորներից։\n\nՄուտքը վեց ամբողջ թվերի զանգված է, որը ներկայացնում է յուրաքանչյուր քարի քանակը հետևյալ հերթականությամբ՝ Թագավոր, Թագուհի, Նավակ, Փիղ, Ձի, Զինվոր։ Յուրաքանչյուր թիվ գտնվում է 0-ից 10 միջակայքում ներառյալ։\n\nՖունկցիան վերադարձնում է վեց ամբողջ թվերի զանգված, որը ցույց է տալիս, թե քանի քար է անհրաժեշտ ավելացնել (դրական թիվ) կամ հեռացնել (բացասական թիվ) հավաքածուն ամբողջացնելու համար։\n\nՕրինակ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Հավաքածուն արդեն ամբողջական է\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ավելացնել 1 Թագավոր, հեռացնել 1 Թագուհի, ավելացնել 1 Նավակ, ավելացնել 3 Զինվոր",
      "bn": "এই ফাংশনটি কতগুলো দাবার গুটি যোগ বা বিয়োগ করতে হবে তা গণনা করে যাতে একটি সম্পূর্ণ দাবার সেট তৈরি হয়। একটি সম্পূর্ণ সেটে থাকে ১টি রাজা, ১টি রানী, ২টি রুক, ২টি বিশপ, ২টি নাইট, এবং ৮টি পন।\n\nইনপুটটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে যা প্রতিটি গুটির সংখ্যা নির্দেশ করে নিম্নলিখিত ক্রমে: রাজা, রানী, রুক, বিশপ, নাইট, পন। প্রতিটি সংখ্যা ০ থেকে ১০ এর মধ্যে অন্তর্ভুক্ত।\n\nফাংশনটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে রিটার্ন করে যা নির্দেশ করে কতগুলো গুটি প্রতিটি ধরনের যোগ (ধনাত্মক সংখ্যা) বা বিয়োগ (ঋণাত্মক সংখ্যা) করতে হবে সেট সম্পূর্ণ করতে।\n\nউদাহরণ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // সেটটি ইতিমধ্যে সম্পূর্ণ\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // ১টি রাজা যোগ করতে হবে, ১টি রানী বিয়োগ করতে হবে, ১টি রুক যোগ করতে হবে, ৩টি পন যোগ করতে হবে",
      "bg": "Тази функция изчислява броя на шахматните фигури, които трябва да бъдат добавени или премахнати, за да се завърши стандартен шахматен комплект. Един пълен комплект се състои от 1 Цар, 1 Царица, 2 Топа, 2 Офицера, 2 Коня и 8 Пешаци.\n\nВходът е масив от шест цели числа, представляващи броя на всяка фигура в реда: Цар, Царица, Топ, Офицер, Кон, Пешак. Всяко число е между 0 и 10 включително.\n\nФункцията връща масив от шест цели числа, показващи колко фигури от всеки тип трябва да бъдат добавени (положително число) или премахнати (отрицателно число), за да се завърши комплектът.\n\nПример:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Комплектът вече е пълен\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Добавете 1 Цар, премахнете 1 Царица, добавете 1 Топ, добавете 3 Пешака",
      "zh": "该函数计算需要添加或移除多少个棋子才能完成一副标准的国际象棋棋子套装。一个完整的套装包括1个国王，1个皇后，2个车，2个象，2个马和8个兵。\n\n输入是一个包含六个整数的数组，表示每种棋子的数量，顺序为：国王，皇后，车，象，马，兵。每个数字在0到10之间（包括0和10）。\n\n该函数返回一个包含六个整数的数组，指示每种类型的棋子需要添加（正数）或移除（负数）多少个以完成套装。\n\n示例：\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // 套装已经完整\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 添加1个国王，移除1个皇后，添加1个车，添加3个兵",
      "fr": "Cette fonction calcule le nombre de pièces d'échecs qu'il faut ajouter ou retirer pour compléter un jeu d'échecs standard. Un jeu complet se compose de 1 Roi, 1 Reine, 2 Tours, 2 Fous, 2 Cavaliers et 8 Pions.\n\nL'entrée est un tableau de six entiers représentant le nombre de chaque pièce dans l'ordre : Roi, Reine, Tour, Fou, Cavalier, Pion. Chaque nombre est compris entre 0 et 10 inclus.\n\nLa fonction renvoie un tableau de six entiers indiquant combien de pièces de chaque type doivent être ajoutées (nombre positif) ou retirées (nombre négatif) pour compléter le jeu.\n\nExemple :\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Le jeu est déjà complet\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ajouter 1 Roi, retirer 1 Reine, ajouter 1 Tour, ajouter 3 Pions",
      "de": "Diese Funktion berechnet die Anzahl der Schachfiguren, die hinzugefügt oder entfernt werden müssen, um ein vollständiges Standardschachset zu vervollständigen. Ein vollständiges Set besteht aus 1 König, 1 Dame, 2 Türmen, 2 Läufern, 2 Springern und 8 Bauern.\n\nDie Eingabe ist ein Array von sechs ganzen Zahlen, das die Anzahl jeder Figur in der Reihenfolge: König, Dame, Turm, Läufer, Springer, Bauer darstellt. Jede Zahl liegt zwischen 0 und 10 einschließlich.\n\nDie Funktion gibt ein Array von sechs ganzen Zahlen zurück, das angibt, wie viele Figuren von jedem Typ hinzugefügt (positive Zahl) oder entfernt (negative Zahl) werden müssen, um das Set zu vervollständigen.\n\nBeispiel:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Das Set ist bereits vollständig\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 König hinzufügen, 1 Dame entfernen, 1 Turm hinzufügen, 3 Bauern hinzufügen",
      "ha": "Wannan aikin yana ƙididdige yawan ƙananan wasannin catur da ake buƙatar ƙara ko cirewa don kammala saitin catur na al'ada. Cikakken saiti yana ƙunshe da Sarki 1, Sarauniya 1, Rook 2, Bishop 2, Knight 2, da Pawn 8.\n\nShigarwa shi ne jerin lambobi guda shida da ke wakiltar adadin kowanne yanki a tsari: Sarki, Sarauniya, Rook, Bishop, Knight, Pawn. Kowanne lamba yana tsakanin 0 da 10 ciki har da.\n\nAikin yana dawowa da jerin lambobi guda shida da ke nuna yawan ƙananan wasannin kowanne nau'i da ake buƙatar ƙara (lamba mai kyau) ko cirewa (lamba mara kyau) don kammala saitin.\n\nMisali:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Saitin ya riga ya cika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ƙara Sarki 1, cire Sarauniya 1, ƙara Rook 1, ƙara Pawn 3",
      "hi": "यह फ़ंक्शन यह गणना करता है कि एक मानक शतरंज सेट को पूरा करने के लिए कितने शतरंज के टुकड़े जोड़े या हटाए जाने की आवश्यकता है। एक पूर्ण सेट में 1 राजा, 1 रानी, 2 हाथी, 2 ऊँट, 2 घोड़े, और 8 प्यादे होते हैं।\n\nइनपुट छह पूर्णांकों की एक श्रृंखला है जो क्रम में प्रत्येक टुकड़े की गिनती को दर्शाती है: राजा, रानी, हाथी, ऊँट, घोड़ा, प्यादा। प्रत्येक संख्या 0 और 10 के बीच समावेशी होती है।\n\nफ़ंक्शन छह पूर्णांकों की एक श्रृंखला लौटाता है जो यह दर्शाती है कि सेट को पूरा करने के लिए प्रत्येक प्रकार के कितने टुकड़े जोड़े (सकारात्मक संख्या) या हटाए (ऋणात्मक संख्या) जाने की आवश्यकता है।\n\nउदाहरण:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // सेट पहले से ही पूरा है\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 राजा जोड़ें, 1 रानी हटाएं, 1 हाथी जोड़ें, 3 प्यादे जोड़ें",
      "hu": "Ez a függvény kiszámítja, hogy hány sakkfigurát kell hozzáadni vagy eltávolítani ahhoz, hogy egy teljes szabványos sakk készletet kapjunk. Egy teljes készlet 1 Királyból, 1 Királynőből, 2 Bástyából, 2 Futyúból, 2 Huszárból és 8 Gyalogból áll.\n\nA bemenet egy hat egész számot tartalmazó tömb, amely az egyes figurák számát jelöli a következő sorrendben: Király, Királynő, Bástya, Futyú, Huszár, Gyalog. Minden szám 0 és 10 között van, beleértve.\n\nA függvény egy hat egész számot tartalmazó tömböt ad vissza, amely azt jelzi, hogy hány darabot kell hozzáadni (pozitív szám) vagy eltávolítani (negatív szám) az egyes típusokból a készlet teljessé tételéhez.\n\nPélda:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // A készlet már teljes\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Adj hozzá 1 Királyt, távolíts el 1 Királynőt, adj hozzá 1 Bástyát, adj hozzá 3 Gyalogot"
    },
    "docstring_bertscore": {
      "sq": "0.9977505109347798",
      "hy": "0.9854747561260617",
      "bn": "0.9331026780801169",
      "bg": "0.9959034470215364",
      "zh": "0.9508880423979807",
      "fr": "0.9977505109347798",
      "de": "0.9638669487555624",
      "ha": "0.980124646812887",
      "hi": "0.9515804679062684",
      "hu": "0.9826826088598543"
    }
  },
  {
    "task_id": "Swift/23",
    "prompt": {
      "en": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "sq": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nLlogarit numrin maksimal të pjesëve që një tabelë shahu drejtkëndore mund të ndahet me 'n' prerje të drejta,\nku të gjitha prerjet janë paralele me anët e drejtkëndëshit.\n\nFormula për llogaritjen e numrit maksimal të pjesëve është (n^2 + n + 2)/2.\n\n- Parametrat:\n- n: Numri i prerjeve që do të bëhen në tabelën e shahut.\n- Kthen: Numri maksimal i pjesëve në të cilat mund të ndahet tabela e shahut.\n\nShembuj:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "hy": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nՀաշվում է առավելագույն կտորների քանակը, որին ուղղանկյուն շախմատային տախտակը կարող է բաժանվել 'n' ուղիղ կտրվածքներով,\nորտեղ բոլոր կտրվածքները զուգահեռ են ուղղանկյան կողմերին:\n\nԱռավելագույն կտորների քանակը հաշվելու բանաձևն է (n^2 + n + 2)/2:\n\n- Պարամետրեր:\n- n: Կտրվածքների քանակը, որը պետք է արվի շախմատային տախտակի վրա:\n- Վերադարձնում է: Առավելագույն կտորների քանակը, որին շախմատային տախտակը կարող է բաժանվել:\n\nՕրինակներ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "bn": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nএকটি আয়তাকার দাবার বোর্ডকে 'n'টি সরল কাটা দিয়ে সর্বাধিক কতগুলো টুকরোতে ভাগ করা যায় তা গণনা করে, \nযেখানে সব কাটাগুলি আয়তক্ষেত্রের পার্শ্বের সমান্তরাল।\n\nটুকরোগুলির সর্বাধিক সংখ্যার জন্য গণনার সূত্র হল (n^2 + n + 2)/2।\n\n- প্যারামিটার:\n- n: দাবার বোর্ডে তৈরি করার জন্য কাটাগুলির সংখ্যা।\n- রিটার্নস: দাবার বোর্ডকে সর্বাধিক কতগুলো টুকরোতে ভাগ করা যায়।\n\nউদাহরণ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "bg": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nИзчислява максималния брой парчета, на които правоъгълна шахматна дъска може да бъде разделена с 'n' прави разреза,\nкъдето всички разрези са успоредни на страните на правоъгълника.\n\nФормулата за изчисляване на максималния брой парчета е (n^2 + n + 2)/2.\n\n- Параметри:\n- n: Броят на разрезите, които ще бъдат направени на шахматната дъска.\n- Връща: Максималният брой парчета, на които шахматната дъска може да бъде разделена.\n\nПримери:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "zh": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\n计算可以用 'n' 条直线将一个矩形棋盘分成的最大块数，其中所有切割都平行于矩形的边。\n\n计算最大块数的公式是 (n^2 + n + 2)/2。\n\n- 参数:\n- n: 要在棋盘上进行的切割次数。\n- 返回值: 棋盘可以被分成的最大块数。\n\n示例:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "fr": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalcule le nombre maximum de morceaux qu'un échiquier rectangulaire peut être divisé en 'n' coupes droites,\noù toutes les coupes sont parallèles aux côtés du rectangle.\n\nLa formule pour calculer le nombre maximum de morceaux est (n^2 + n + 2)/2.\n\n- Paramètres:\n- n: Le nombre de coupes à effectuer sur l'échiquier.\n- Retourne: Le nombre maximum de morceaux dans lesquels l'échiquier peut être divisé.\n\nExemples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "de": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nBerechnet die maximale Anzahl von Stücken, in die ein rechteckiges Schachbrett mit 'n' geraden Schnitten geteilt werden kann,\nwobei alle Schnitte parallel zu den Seiten des Rechtecks verlaufen.\n\nDie Formel zur Berechnung der maximalen Anzahl von Stücken ist (n^2 + n + 2)/2.\n\n- Parameter:\n- n: Die Anzahl der Schnitte, die auf dem Schachbrett gemacht werden sollen.\n- Rückgabe: Die maximale Anzahl von Stücken, in die das Schachbrett geteilt werden kann.\n\nBeispiele:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "ha": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nYana ƙididdige yawan yankan da za a iya raba wani allo na catur a ciki tare da 'n' yankan madaidaici, \ninda duk yankan suna daidai da gefen rectangle.\n\nTsarin lissafin yawan yankan da za a iya samu shine (n^2 + n + 2)/2.\n\n- Ma'auni:\n- n: Yawan yankan da za a yi akan allon catur.\n- Komawa: Yawan yankan da za a iya raba allon catur a ciki.\n\nMisalai:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "hi": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nएक आयताकार शतरंज की बिसात को 'n' सीधे कट के साथ अधिकतम कितने टुकड़ों में विभाजित किया जा सकता है, \nजहां सभी कट आयत के किनारों के समानांतर होते हैं, की गणना करता है।\n\nअधिकतम टुकड़ों की संख्या की गणना का सूत्र (n^2 + n + 2)/2 है।\n\n- पैरामीटर्स:\n- n: शतरंज की बिसात पर किए जाने वाले कट की संख्या।\n- रिटर्न्स: अधिकतम टुकड़ों की संख्या जिसमें शतरंज की बिसात को विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "hu": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nKiszámítja, hogy egy téglalap alakú sakktábla maximálisan hány darabra osztható 'n' egyenes vágással, \nahol minden vágás párhuzamos a téglalap oldalával.\n\nA maximális darabszám kiszámításának képlete: (n^2 + n + 2)/2.\n\n- Paraméterek:\n- n: A sakktáblán végrehajtandó vágások száma.\n- Visszatér: A maximális darabszám, amire a sakktábla osztható.\n\nPéldák:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9898291313391085",
      "hy": "0.9857272153403571",
      "bn": "0.9919060106032094",
      "bg": "0.9883074239900003",
      "zh": "0.9868816551149319",
      "fr": "0.992592874460828",
      "de": "0.9768607523917218",
      "ha": "0.9580528388722902",
      "hi": "0.9963467900320063",
      "hu": "0.9919129626665456"
    },
    "canonical_solution": "if n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}",
    "instruction": {
      "en": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\n请用最多500个字符的中文为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8892538296843792",
      "bg": "0.8273796714704873",
      "zh": "0.8585559015561992",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9404853720824217",
      "hi": "0.9102601842611048",
      "hu": "0.9311469633484474"
    },
    "level": "",
    "test": "func testMaxChessboardSlices() {\nassert(maxChessboardSlices(0) == 1)\nassert(maxChessboardSlices(2) == 4)\nassert(maxChessboardSlices(4) == 9)\nassert(maxChessboardSlices(5) == 12)\nassert(maxChessboardSlices(6) == 16)\nassert(maxChessboardSlices(7) == 20)\n}\n\ntestMaxChessboardSlices()",
    "entry_point": "maxChessboardSlices",
    "signature": "func maxChessboardSlices(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n",
      "sq": "Llogarit numrin maksimal të pjesëve që një tabelë shahu drejtkëndore mund të ndahet me 'n' prerje të drejta, ku të gjitha prerjet janë paralele me anët e drejtkëndëshit.\n\nFormula për llogaritjen e numrit maksimal të pjesëve është (n^2 + n + 2)/2.\n\n- Parametrat:\n- n: Numri i prerjeve që do të bëhen në tabelën e shahut.\n- Kthen: Numri maksimal i pjesëve në të cilat tabela e shahut mund të ndahet.\n\nShembuj:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hy": "Հաշվում է առավելագույն կտորների քանակը, որոնց կարելի է բաժանել ուղղանկյուն շախմատային տախտակը 'n' ուղիղ կտրվածքներով, \nորտեղ բոլոր կտրվածքները զուգահեռ են ուղղանկյան կողմերին։\n\nԱռավելագույն կտորների քանակը հաշվելու բանաձևը (n^2 + n + 2)/2 է։\n\n- Պարամետրեր:\n- n: Կտրվածքների քանակը, որոնք պետք է արվեն շախմատային տախտակի վրա։\n- Վերադարձնում է: Առավելագույն կտորների քանակը, որոնց կարելի է բաժանել շախմատային տախտակը։\n\nՕրինակներ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "bn": "আয়তাকার দাবার বোর্ডকে 'n' টি সরল রেখা দিয়ে সর্বাধিক কতগুলি টুকরোতে ভাগ করা যায় তা গণনা করে, যেখানে সমস্ত কাটগুলি আয়তক্ষেত্রের পাশগুলির সমান্তরাল।\n\nসর্বাধিক টুকরোর সংখ্যা গণনা করার সূত্র হল (n^2 + n + 2)/2।\n\n- প্যারামিটারসমূহ:\n- n: দাবার বোর্ডে তৈরি করার জন্য কাটের সংখ্যা।\n- রিটার্ন করে: দাবার বোর্ডকে সর্বাধিক কতগুলি টুকরোতে ভাগ করা যেতে পারে।\n\nউদাহরণসমূহ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "bg": "Изчислява максималния брой парчета, на които правоъгълна шахматна дъска може да бъде разделена с 'n' прави разреза, където всички разрези са успоредни на страните на правоъгълника.\n\nФормулата за изчисляване на максималния брой парчета е (n^2 + n + 2)/2.\n\n- Параметри:\n- n: Броят на разрезите, които ще бъдат направени на шахматната дъска.\n- Връща: Максималният брой парчета, на които шахматната дъска може да бъде разделена.\n\nПримери:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "zh": "计算一个矩形棋盘可以用 'n' 条直线切割成的最大块数，其中所有切割都平行于矩形的边。\n\n计算最大块数的公式是 (n^2 + n + 2)/2。\n\n- 参数:\n- n: 棋盘上要进行的切割次数。\n- 返回值: 棋盘可以被分成的最大块数。\n\n示例:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "fr": "Calcule le nombre maximum de morceaux qu'un échiquier rectangulaire peut être divisé en utilisant 'n' coupes droites, où toutes les coupes sont parallèles aux côtés du rectangle.\n\nLa formule pour calculer le nombre maximum de morceaux est (n^2 + n + 2)/2.\n\n- Paramètres:\n- n: Le nombre de coupes à effectuer sur l'échiquier.\n- Renvoie: Le nombre maximum de morceaux dans lesquels l'échiquier peut être divisé.\n\nExemples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "de": "Berechnet die maximale Anzahl von Teilen, in die ein rechteckiges Schachbrett mit 'n' geraden Schnitten unterteilt werden kann, wobei alle Schnitte parallel zu den Seiten des Rechtecks verlaufen.\n\nDie Formel zur Berechnung der maximalen Anzahl von Teilen ist (n^2 + n + 2)/2.\n\n- Parameter:\n- n: Die Anzahl der Schnitte, die auf dem Schachbrett gemacht werden sollen.\n- Rückgabe: Die maximale Anzahl von Teilen, in die das Schachbrett unterteilt werden kann.\n\nBeispiele:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "ha": "Yana lissafin yawan yankan da za a iya raba wani allo na catur a ciki da yankan madaidaici guda 'n', inda duk yankan suna daidai da gefen rectangle.\n\nTsarin lissafi don lissafin yawan yankan shine (n^2 + n + 2)/2.\n\n- Sigogi:\n- n: Yawan yankan da za a yi a kan allon catur.\n- Komawa: Yawan yankan da allon catur zai iya rabuwa da shi.\n\nMisalai:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hi": "आयताकार शतरंज की बिसात को 'n' सीधे कटों के साथ अधिकतम कितने टुकड़ों में विभाजित किया जा सकता है, \nजहाँ सभी कट आयत के किनारों के समानांतर होते हैं।\n\nअधिकतम टुकड़ों की संख्या की गणना करने का सूत्र (n^2 + n + 2)/2 है।\n\n- पैरामीटर्स:\n- n: शतरंज की बिसात पर किए जाने वाले कटों की संख्या।\n- रिटर्न: अधिकतम टुकड़ों की संख्या जिसमें शतरंज की बिसात को विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hu": "Számítja ki, hogy egy téglalap alakú sakktábla maximálisan hány darabra osztható fel 'n' egyenes vágással, ahol minden vágás párhuzamos a téglalap oldalával.\n\nA maximális darabszám kiszámításának képlete: (n^2 + n + 2)/2.\n\n- Paraméterek:\n- n: A sakktáblán végrehajtandó vágások száma.\n- Visszatérési érték: A maximális darabszám, amire a sakktábla felosztható.\n\nPéldák:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9"
    },
    "docstring_bertscore": {
      "sq": "0.9884585817099678",
      "hy": "0.9873935256068588",
      "bn": "0.9867489700204005",
      "bg": "0.9806224145477604",
      "zh": "0.9875679230814074",
      "fr": "0.9866629630654125",
      "de": "0.9687935780963708",
      "ha": "0.9671131650728156",
      "hi": "0.9521529206644109",
      "hu": "0.9848015977647345"
    }
  },
  {
    "task_id": "Swift/24",
    "prompt": {
      "en": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "sq": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nGjen fjalën më të vogël leksikografikisht në një matricë të dhënë karakteresh. \nMatrica përbëhet nga shkronja të vogla dhe '#'. Një fjalë përkufizohet si një sekuencë \nshkronjash ose horizontalisht nga e majta në të djathtë ose vertikalisht nga lart poshtë, \npa kaluar '#'. Fjala duhet të jetë të paktën 2 karaktere e gjatë dhe të kufizohet nga '#' \nose skaji i matricës në të dy anët.\n\nShembull:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "hy": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nԳտնում է տրված նիշերի մատրիցայում բառարանային կարգով ամենափոքր բառը։ \nՄատրիցան բաղկացած է փոքրատառերից և '#'-ից։ Բառը սահմանվում է որպես նիշերի \nհաջորդականություն՝ կամ հորիզոնական ձախից աջ կամ ուղղահայաց վերևից ներքև, \nառանց '#'-ը հատելու։ Բառը պետք է լինի առնվազն 2 նիշ երկարությամբ և սահմանափակված լինի \n'#'-ով կամ մատրիցայի եզրով երկու կողմերից։\n\nՕրինակ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "bn": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nএকটি প্রদত্ত অক্ষরের ম্যাট্রিক্সে বর্ণানুক্রমিকভাবে ক্ষুদ্রতম শব্দ খুঁজে বের করে। \nম্যাট্রিক্সটি ছোট হাতের অক্ষর এবং '#' নিয়ে গঠিত। একটি শব্দকে সংজ্ঞায়িত করা হয় \nবাম থেকে ডানে অনুভূমিকভাবে বা উপরে থেকে নিচে উল্লম্বভাবে অক্ষরের ক্রম হিসাবে, \n'#' অতিক্রম না করে। শব্দটি অবশ্যই কমপক্ষে 2 অক্ষরের দীর্ঘ হতে হবে এবং উভয় প্রান্তে \n'#' বা ম্যাট্রিক্সের প্রান্ত দ্বারা সীমাবদ্ধ হতে হবে।\n\nউদাহরণ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "bg": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nНамира лексикографски най-малката дума в дадена матрица от символи.\nМатрицата се състои от малки букви и '#'. Думата се дефинира като последователност \nот букви или хоризонтално отляво надясно, или вертикално отгоре надолу, \nбез да пресича '#'. Думата трябва да бъде поне 2 символа дълга и да бъде ограничена от '#' \nили края на матрицата и от двете страни.\n\nПример:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "zh": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\n在给定的字符矩阵中查找字典序最小的单词。\n矩阵由小写字母和 '#' 组成。单词定义为从左到右水平或从上到下垂直的字母序列，\n不能跨越 '#'. 单词必须至少有 2 个字符长，并且在两端由 '#' 或矩阵的边界限定。\n\n示例:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "fr": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nTrouve le mot le plus petit lexicographiquement dans une matrice donnée de caractères. \nLa matrice se compose de lettres minuscules et de '#'. Un mot est défini comme une séquence \nde lettres soit horizontalement de gauche à droite, soit verticalement de haut en bas, \nsans traverser '#'. Le mot doit avoir au moins 2 caractères de long et être délimité par '#' \nou le bord de la matrice aux deux extrémités.\n\nExemple:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "de": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFindet das lexikographisch kleinste Wort in einer gegebenen Matrix von Zeichen. \nDie Matrix besteht aus Kleinbuchstaben und '#'. Ein Wort wird als eine Sequenz \nvon Buchstaben definiert, entweder horizontal von links nach rechts oder vertikal von oben nach unten, \nohne '#' zu überqueren. Das Wort muss mindestens 2 Zeichen lang sein und an beiden Enden \nvon '#' oder dem Rand der Matrix begrenzt sein.\n\nBeispiel:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "ha": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nNemi kalma mafi ƙanƙanta a cikin tsarin haruffa da aka bayar. \nTsarin yana ƙunshe da ƙananan haruffa da '#'. Ana ayyana kalma a matsayin jere \nna haruffa ko dai a kwance daga hagu zuwa dama ko a tsaye daga sama zuwa ƙasa, \nba tare da ketare '#' ba. Kalmar dole ne ta zama aƙalla haruffa 2 tsawo kuma ta kasance \nta kewayen '#' ko gefen tsarin a duka ƙarshen.\n\nMisali:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "hi": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nदिए गए वर्णों के मैट्रिक्स में शब्दकोशीय रूप से सबसे छोटा शब्द खोजें।\nमैट्रिक्स में छोटे अक्षर और '#' होते हैं। एक शब्द को वर्णों के अनुक्रम के रूप में परिभाषित किया जाता है \nजो या तो क्षैतिज रूप से बाएँ से दाएँ या ऊर्ध्वाधर रूप से ऊपर से नीचे तक होता है, \nबिना '#' को पार किए। शब्द कम से कम 2 अक्षरों का होना चाहिए और दोनों सिरों पर '#' \nया मैट्रिक्स के किनारे से सीमित होना चाहिए।\n\nउदाहरण:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "hu": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nMegkeresi a lexicoográfiailag legkisebb szót egy adott karaktermátrixban.\nA mátrix kisbetűkből és '#' karakterekből áll. Egy szó olyan betűsorozat, \namely vízszintesen balról jobbra vagy függőlegesen fentről lefelé halad, \nanélkül, hogy '#' karaktert keresztezne. A szónak legalább 2 karakter hosszúnak kell lennie, \nés mindkét végén '#' karakterrel vagy a mátrix szélével kell határoltnak lennie.\n\nPélda:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9908322147633347",
      "hy": "0.9928558610853182",
      "bn": "0.991369311313653",
      "bg": "0.9891065140129036",
      "zh": "0.9669767060010447",
      "fr": "0.996214104937475",
      "de": "0.9875393203065383",
      "ha": "0.9662193283581586",
      "hi": "0.9822889234446431",
      "hu": "0.957874866050883"
    },
    "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}",
    "instruction": {
      "en": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nՏվեք Swift կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nনিচের Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Swift cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9664368286253918",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()",
    "entry_point": "findSmallestWordInMatrix",
    "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {",
    "docstring": {
      "en": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n",
      "sq": "Gjen fjalën më të vogël leksikografikisht në një matricë të dhënë karakteresh. \nMatrica përbëhet nga shkronja të vogla dhe '#'. Një fjalë përcaktohet si një sekuencë \nshkronjash ose horizontalisht nga e majta në të djathtë ose vertikalisht nga lart poshtë, \npa kaluar '#'. Fjala duhet të jetë të paktën 2 karaktere e gjatë dhe të kufizohet nga '#' \nose skaji i matricës në të dyja anët.\n\nShembull:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hy": "Գտնում է լեքսիկոգրաֆիկորեն ամենափոքր բառը տրված նիշերի մատրիցայում։ \nՄատրիցան բաղկացած է փոքրատառերից և '#'-ից։ Բառը սահմանվում է որպես \nնիշերի հաջորդականություն՝ կամ հորիզոնական ձախից աջ կամ ուղղահայաց վերևից ներքև, \nառանց '#' հատելու։ Բառը պետք է լինի առնվազն 2 նիշ երկարությամբ և սահմանափակված լինի '#' \nկամ մատրիցայի եզրով երկու ծայրերից։\n\nՕրինակ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "bn": "প্রদত্ত অক্ষরের ম্যাট্রিক্সে বর্ণানুক্রমিকভাবে সবচেয়ে ছোট শব্দ খুঁজে বের করে। \nম্যাট্রিক্সটি ছোট হাতের অক্ষর এবং '#' নিয়ে গঠিত। একটি শব্দকে সংজ্ঞায়িত করা হয় \nবাম থেকে ডানে অনুভূমিকভাবে বা উপরে থেকে নিচে উল্লম্বভাবে অক্ষরের ক্রম হিসাবে, \n'#' অতিক্রম না করে। শব্দটি কমপক্ষে 2 অক্ষর দীর্ঘ হতে হবে এবং উভয় প্রান্তে '#' \nবা ম্যাট্রিক্সের প্রান্ত দ্বারা সীমাবদ্ধ হতে হবে।\n\nউদাহরণ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "bg": "Намира лексикографски най-малката дума в дадена матрица от символи. \nМатрицата се състои от малки букви и '#'. Думата се дефинира като последователност \nот букви или хоризонтално отляво надясно, или вертикално отгоре надолу, \nбез да пресича '#'. Думата трябва да бъде поне 2 символа дълга и да бъде ограничена от '#' \nили ръба на матрицата от двата края.\n\nПример:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "zh": "在给定的字符矩阵中查找按字典顺序排列的最小单词。矩阵由小写字母和 '#' 组成。单词定义为从左到右水平或从上到下垂直的字母序列，不跨越 '#'。单词必须至少有 2 个字符长，并且在两端由 '#' 或矩阵的边界限制。\n\n示例：\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "fr": "Trouve le mot le plus petit lexicographiquement dans une matrice donnée de caractères. La matrice se compose de lettres minuscules et de '#'. Un mot est défini comme une séquence de lettres soit horizontalement de gauche à droite, soit verticalement de haut en bas, sans traverser '#'. Le mot doit avoir au moins 2 caractères de long et être délimité par '#' ou le bord de la matrice aux deux extrémités.\n\nExemple :\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "de": "Findet das lexikographisch kleinste Wort in einer gegebenen Matrix von Zeichen. \nDie Matrix besteht aus Kleinbuchstaben und '#'. Ein Wort ist definiert als eine \nSequenz von Buchstaben entweder horizontal von links nach rechts oder vertikal von oben \nnach unten, ohne '#' zu überschreiten. Das Wort muss mindestens 2 Zeichen lang sein und \nan beiden Enden von '#' oder dem Rand der Matrix begrenzt sein.\n\nBeispiel:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "ha": "Yana nemo kalma mafi ƙarancin haruffa a cikin matrix da aka bayar na haruffa. \nMatrix ɗin ya ƙunshi ƙananan haruffa da '#'. An ayyana kalma a matsayin jerin \nharuffa ko dai a kwance daga hagu zuwa dama ko a tsaye daga sama zuwa ƙasa, \nba tare da ketare '#' ba. Kalmar dole ne ta zama aƙalla haruffa 2 tsawo kuma a \nƙayyade ta '#' ko gefen matrix a duka ƙarshen.\n\nMisali:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hi": "दिए गए वर्णों के मैट्रिक्स में शब्दकोशीय रूप से सबसे छोटा शब्द खोजता है। \nमैट्रिक्स में छोटे अक्षर और '#' होते हैं। एक शब्द को अक्षरों के अनुक्रम के रूप में परिभाषित किया गया है \nया तो क्षैतिज रूप से बाएँ से दाएँ या लंबवत रूप से ऊपर से नीचे तक, \n'#' को पार किए बिना। शब्द कम से कम 2 अक्षर लंबा होना चाहिए और दोनों सिरों पर '#' \nया मैट्रिक्स के किनारे से सीमित होना चाहिए।\n\nउदाहरण:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hu": "Megkeresi a lexicoográfiailag legkisebb szót egy adott karaktermátrixban. \nA mátrix kisbetűkből és '#' karakterekből áll. Egy szó olyan betűsorozat, amely \nvízszintesen balról jobbra vagy függőlegesen fentről lefelé halad, anélkül, hogy \nkeresztezné a '#'-t. A szónak legalább 2 karakter hosszúnak kell lennie, és mindkét \nvégén '#' vagy a mátrix szélével kell határoltnak lennie.\n\nPélda:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\""
    },
    "docstring_bertscore": {
      "sq": "0.985885921014804",
      "hy": "0.9884591776011109",
      "bn": "0.9639283255433022",
      "bg": "0.9975741271564209",
      "zh": "0.9491804170122239",
      "fr": "0.9848290087573173",
      "de": "0.9926055868052143",
      "ha": "0.9614984800921025",
      "hi": "0.9879314166787012",
      "hu": "0.9690384893561867"
    }
  },
  {
    "task_id": "Swift/25",
    "prompt": {
      "en": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/",
      "sq": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nGjen numrin që mungon në një sekuencë që fillimisht ishte një progresion aritmetik.\n\nHyrja është një varg me tre numra të plotë, që përfaqësojnë numrat e mbetur të sekuencës pasi një numër është humbur. Funksioni kthen numrin që mungon. Sekuenca origjinale prej katër numrash ishte në progresion aritmetik.\n\nShembuj:\n- Nëse hyrja është [3, 7, 5], funksioni kthen 1 ose 9, pasi sekuenca mund të ketë qenë [1, 3, 5, 7] ose [3, 5, 7, 9].\n- Nëse hyrja është [20, 14, 8], funksioni kthen 26 ose 2, pasi sekuenca mund të ketë qenë [2, 8, 14, 20] ose [8, 14, 20, 26].\n*/",
      "hy": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nԳտնում է բացակայող թիվը հաջորդականության մեջ, որը սկզբնապես թվաբանական պրոգրեսիա էր:\n\nՄուտքը երեք ամբողջ թվերի զանգված է, որը ներկայացնում է հաջորդականության մնացած թվերը մեկ թվի կորստից հետո: Ֆունկցիան վերադարձնում է բացակայող թիվը: Սկզբնական չորս թվերի հաջորդականությունը թվաբանական պրոգրեսիա էր:\n\nՕրինակներ:\n- Եթե մուտքը [3, 7, 5] է, ֆունկցիան վերադարձնում է 1 կամ 9, քանի որ հաջորդականությունը կարող էր լինել [1, 3, 5, 7] կամ [3, 5, 7, 9]:\n- Եթե մուտքը [20, 14, 8] է, ֆունկցիան վերադարձնում է 26 կամ 2, քանի որ հաջորդականությունը կարող էր լինել [2, 8, 14, 20] կամ [8, 14, 20, 26]:\n*/",
      "bn": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nএকটি ক্রমে অনুপস্থিত সংখ্যা খুঁজে বের করে যা মূলত একটি গাণিতিক ক্রমবৃদ্ধি ছিল।\n\nইনপুটটি তিনটি পূর্ণসংখ্যার একটি অ্যারে, যা একটি সংখ্যা হারিয়ে যাওয়ার পরে ক্রমের অবশিষ্ট সংখ্যা উপস্থাপন করে। ফাংশনটি অনুপস্থিত সংখ্যাটি ফেরত দেয়। চারটি সংখ্যার মূল ক্রমটি গাণিতিক ক্রমবৃদ্ধিতে ছিল।\n\nউদাহরণ:\n- যদি ইনপুট হয় [3, 7, 5], ফাংশনটি 1 বা 9 ফেরত দেয়, কারণ ক্রমটি হতে পারত [1, 3, 5, 7] বা [3, 5, 7, 9]।\n- যদি ইনপুট হয় [20, 14, 8], ফাংশনটি 26 বা 2 ফেরত দেয়, কারণ ক্রমটি হতে পারত [2, 8, 14, 20] বা [8, 14, 20, 26]।\n*/",
      "bg": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nНамира липсващото число в последователност, която първоначално е била аритметична прогресия.\n\nВходът е масив от три цели числа, представляващи останалите числа от последователността след загубата на едно число. Функцията връща липсващото число. Оригиналната последователност от четири числа е била в аритметична прогресия.\n\nПримери:\n- Ако входът е [3, 7, 5], функцията връща 1 или 9, тъй като последователността може да е била [1, 3, 5, 7] или [3, 5, 7, 9].\n- Ако входът е [20, 14, 8], функцията връща 26 или 2, тъй като последователността може да е била [2, 8, 14, 20] или [8, 14, 20, 26].\n*/",
      "zh": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\n在原本是等差数列的序列中查找缺失的数字。\n\n输入是一个包含三个整数的数组，表示序列中丢失一个数字后剩下的数字。函数返回缺失的数字。原始的四个数字序列是等差数列。\n\n示例：\n- 如果输入是 [3, 7, 5]，函数返回 1 或 9，因为序列可能是 [1, 3, 5, 7] 或 [3, 5, 7, 9]。\n- 如果输入是 [20, 14, 8]，函数返回 26 或 2，因为序列可能是 [2, 8, 14, 20] 或 [8, 14, 20, 26]。\n*/",
      "fr": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nTrouve le nombre manquant dans une séquence qui était à l'origine une progression arithmétique.\n\nL'entrée est un tableau de trois entiers, représentant les nombres restants de la séquence après la perte d'un nombre. La fonction renvoie le nombre manquant. La séquence originale de quatre nombres était en progression arithmétique.\n\nExemples :\n- Si l'entrée est [3, 7, 5], la fonction renvoie 1 ou 9, car la séquence aurait pu être [1, 3, 5, 7] ou [3, 5, 7, 9].\n- Si l'entrée est [20, 14, 8], la fonction renvoie 26 ou 2, car la séquence aurait pu être [2, 8, 14, 20] ou [8, 14, 20, 26].\n*/",
      "de": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFindet die fehlende Zahl in einer Sequenz, die ursprünglich eine arithmetische Folge war.\n\nDie Eingabe ist ein Array von drei ganzen Zahlen, die die verbleibenden Zahlen der Sequenz darstellen, nachdem eine Zahl verloren gegangen ist. Die Funktion gibt die fehlende Zahl zurück. Die ursprüngliche Sequenz von vier Zahlen war in arithmetischer Folge.\n\nBeispiele:\n- Wenn die Eingabe [3, 7, 5] ist, gibt die Funktion 1 oder 9 zurück, da die Sequenz [1, 3, 5, 7] oder [3, 5, 7, 9] gewesen sein könnte.\n- Wenn die Eingabe [20, 14, 8] ist, gibt die Funktion 26 oder 2 zurück, da die Sequenz [2, 8, 14, 20] oder [8, 14, 20, 26] gewesen sein könnte.\n*/",
      "ha": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nNemo lambar da ta ɓace a cikin jerin da a asali ya kasance ci gaba na lissafi.\n\nShigarwar ita ce jerin lambobi guda uku, suna wakiltar sauran lambobin jerin bayan an rasa lamba ɗaya. Aikin yana dawo da lambar da ta ɓace. Asalin jerin lambobi huɗu yana cikin ci gaba na lissafi.\n\nMisalai:\n- Idan shigarwar ita ce [3, 7, 5], aikin yana dawo da 1 ko 9, tunda jerin zai iya kasancewa [1, 3, 5, 7] ko [3, 5, 7, 9].\n- Idan shigarwar ita ce [20, 14, 8], aikin yana dawo da 26 ko 2, tunda jerin zai iya kasancewa [2, 8, 14, 20] ko [8, 14, 20, 26].\n*/",
      "hi": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nअनुक्रम में गायब संख्या का पता लगाता है जो मूल रूप से एक अंकगणितीय प्रगति थी।\n\nइनपुट तीन पूर्णांकों की एक सरणी है, जो अनुक्रम की शेष संख्याओं का प्रतिनिधित्व करती है जब एक संख्या खो जाती है। फ़ंक्शन गायब संख्या लौटाता है। चार संख्याओं का मूल अनुक्रम अंकगणितीय प्रगति में था।\n\nउदाहरण:\n- यदि इनपुट [3, 7, 5] है, तो फ़ंक्शन 1 या 9 लौटाता है, क्योंकि अनुक्रम [1, 3, 5, 7] या [3, 5, 7, 9] हो सकता था।\n- यदि इनपुट [20, 14, 8] है, तो फ़ंक्शन 26 या 2 लौटाता है, क्योंकि अनुक्रम [2, 8, 14, 20] या [8, 14, 20, 26] हो सकता था।\n*/",
      "hu": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nMegkeresi a hiányzó számot egy olyan sorozatban, amely eredetileg számtani sorozat volt.\n\nA bemenet egy három egész számot tartalmazó tömb, amely a sorozat megmaradt számait képviseli, miután egy szám elveszett. A függvény visszaadja a hiányzó számot. Az eredeti négy számot tartalmazó sorozat számtani sorozat volt.\n\nPéldák:\n- Ha a bemenet [3, 7, 5], a függvény 1 vagy 9-et ad vissza, mivel a sorozat lehetett [1, 3, 5, 7] vagy [3, 5, 7, 9].\n- Ha a bemenet [20, 14, 8], a függvény 26 vagy 2-t ad vissza, mivel a sorozat lehetett [2, 8, 14, 20] vagy [8, 14, 20, 26].\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9928393747636923",
      "hy": "0.9910475300963766",
      "bn": "0.9953677408838854",
      "bg": "0.9945166097011509",
      "zh": "0.9660159308479789",
      "fr": "0.998673149054687",
      "de": "0.9957787071422466",
      "ha": "0.9771543280948913",
      "hi": "0.9925654634682451",
      "hu": "0.9875075394455728"
    },
    "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}",
    "instruction": {
      "en": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nনিম্নলিখিত সুইফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9346315361229425",
      "hi": "0.9244314687960389",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()",
    "entry_point": "findMissingNumber",
    "signature": "func findMissingNumber(in numbers: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n",
      "sq": "Gjen numrin që mungon në një sekuencë që fillimisht ishte një progresion aritmetik.\n\nHyrja është një varg me tre numra të plotë, që përfaqësojnë numrat e mbetur të sekuencës pasi një numër është humbur. Funksioni kthen numrin që mungon. Sekuenca origjinale e katër numrave ishte në progresion aritmetik.\n\nShembuj:\n- Nëse hyrja është [3, 7, 5], funksioni kthen 1 ose 9, pasi sekuenca mund të ketë qenë [1, 3, 5, 7] ose [3, 5, 7, 9].\n- Nëse hyrja është [20, 14, 8], funksioni kthen 26 ose 2, pasi sekuenca mund të ketë qenë [2, 8, 14, 20] ose [8, 14, 20, 26].",
      "hy": "Գտնում է բացակայող թիվը հաջորդականության մեջ, որը սկզբնապես թվաբանական պրոգրեսիա էր:\n\nՄուտքը երեք ամբողջ թվերի զանգված է, որը ներկայացնում է հաջորդականության մնացած թվերը այն բանից հետո, երբ մեկ թիվ կորել է: Ֆունկցիան վերադարձնում է բացակայող թիվը: Սկզբնական չորս թվերի հաջորդականությունը թվաբանական պրոգրեսիա էր:\n\nՕրինակներ:\n- Եթե մուտքը [3, 7, 5] է, ֆունկցիան վերադարձնում է 1 կամ 9, քանի որ հաջորդականությունը կարող էր լինել [1, 3, 5, 7] կամ [3, 5, 7, 9]:\n- Եթե մուտքը [20, 14, 8] է, ֆունկցիան վերադարձնում է 26 կամ 2, քանի որ հաջորդականությունը կարող էր լինել [2, 8, 14, 20] կամ [8, 14, 20, 26]:",
      "bn": "একটি ক্রমে অনুপস্থিত সংখ্যা খুঁজে বের করে যা মূলত একটি গাণিতিক ক্রম ছিল।\n\nইনপুটটি তিনটি পূর্ণসংখ্যার একটি অ্যারে, যা একটি সংখ্যা হারানোর পরে ক্রমের অবশিষ্ট সংখ্যাগুলিকে উপস্থাপন করে। ফাংশনটি অনুপস্থিত সংখ্যাটি ফেরত দেয়। চারটি সংখ্যার মূল ক্রমটি গাণিতিক ক্রমে ছিল।\n\nউদাহরণ:\n- যদি ইনপুট হয় [3, 7, 5], ফাংশনটি 1 বা 9 ফেরত দেয়, কারণ ক্রমটি হতে পারত [1, 3, 5, 7] বা [3, 5, 7, 9]।\n- যদি ইনপুট হয় [20, 14, 8], ফাংশনটি 26 বা 2 ফেরত দেয়, কারণ ক্রমটি হতে পারত [2, 8, 14, 20] বা [8, 14, 20, 26]।",
      "bg": "Намира липсващото число в редица, която първоначално е била аритметична прогресия.\n\nВходът е масив от три цели числа, представляващи останалите числа от редицата след като едно число е изгубено. Функцията връща липсващото число. Оригиналната редица от четири числа е била в аритметична прогресия.\n\nПримери:\n- Ако входът е [3, 7, 5], функцията връща 1 или 9, тъй като редицата може да е била [1, 3, 5, 7] или [3, 5, 7, 9].\n- Ако входът е [20, 14, 8], функцията връща 26 или 2, тъй като редицата може да е била [2, 8, 14, 20] или [8, 14, 20, 26].",
      "zh": "找到原本是等差数列的序列中缺失的数字。\n\n输入是一个包含三个整数的数组，表示在丢失一个数字后序列中剩下的数字。该函数返回缺失的数字。原始的四个数字序列是等差数列。\n\n示例：\n- 如果输入是 [3, 7, 5]，函数返回 1 或 9，因为序列可能是 [1, 3, 5, 7] 或 [3, 5, 7, 9]。\n- 如果输入是 [20, 14, 8]，函数返回 26 或 2，因为序列可能是 [2, 8, 14, 20] 或 [8, 14, 20, 26]。",
      "fr": "Trouve le nombre manquant dans une séquence qui était à l'origine une progression arithmétique.\n\nL'entrée est un tableau de trois entiers, représentant les nombres restants de la séquence après la perte d'un nombre. La fonction renvoie le nombre manquant. La séquence originale de quatre nombres était en progression arithmétique.\n\nExemples :\n- Si l'entrée est [3, 7, 5], la fonction renvoie 1 ou 9, car la séquence aurait pu être [1, 3, 5, 7] ou [3, 5, 7, 9].\n- Si l'entrée est [20, 14, 8], la fonction renvoie 26 ou 2, car la séquence aurait pu être [2, 8, 14, 20] ou [8, 14, 20, 26].",
      "de": "Findet die fehlende Zahl in einer Sequenz, die ursprünglich eine arithmetische Folge war.\n\nDie Eingabe ist ein Array von drei ganzen Zahlen, das die verbleibenden Zahlen der Sequenz darstellt, nachdem eine Zahl verloren gegangen ist. Die Funktion gibt die fehlende Zahl zurück. Die ursprüngliche Sequenz von vier Zahlen war in arithmetischer Folge.\n\nBeispiele:\n- Wenn die Eingabe [3, 7, 5] ist, gibt die Funktion 1 oder 9 zurück, da die Sequenz [1, 3, 5, 7] oder [3, 5, 7, 9] gewesen sein könnte.\n- Wenn die Eingabe [20, 14, 8] ist, gibt die Funktion 26 oder 2 zurück, da die Sequenz [2, 8, 14, 20] oder [8, 14, 20, 26] gewesen sein könnte.",
      "ha": "Yana nemo lambar da ta ɓace a cikin jerin da a asali ya kasance ci gaba na lissafi.\n\nShigarwar shi ne jerin lambobi guda uku, wanda ke wakiltar sauran lambobin jerin bayan an rasa lamba ɗaya. Aikin yana dawowa da lambar da ta ɓace. Asalin jerin lambobi guda huɗu yana cikin ci gaba na lissafi.\n\nMisalai:\n- Idan shigarwar ita ce [3, 7, 5], aikin yana dawowa da 1 ko 9, tun da jerin zai iya kasancewa [1, 3, 5, 7] ko [3, 5, 7, 9].\n- Idan shigarwar ita ce [20, 14, 8], aikin yana dawowa da 26 ko 2, tun da jerin zai iya kasancewa [2, 8, 14, 20] ko [8, 14, 20, 26].",
      "hi": "गुम हुई संख्या को खोजता है जो मूल रूप से एक अंकगणितीय प्रगति में थी।\n\nइनपुट तीन पूर्णांकों की एक सरणी है, जो उस अनुक्रम की शेष संख्याओं का प्रतिनिधित्व करती है जिसमें से एक संख्या खो गई है। फ़ंक्शन गुम हुई संख्या को लौटाता है। चार संख्याओं का मूल अनुक्रम अंकगणितीय प्रगति में था।\n\nउदाहरण:\n- यदि इनपुट [3, 7, 5] है, तो फ़ंक्शन 1 या 9 लौटाता है, क्योंकि अनुक्रम [1, 3, 5, 7] या [3, 5, 7, 9] हो सकता था।\n- यदि इनपुट [20, 14, 8] है, तो फ़ंक्शन 26 या 2 लौटाता है, क्योंकि अनुक्रम [2, 8, 14, 20] या [8, 14, 20, 26] हो सकता था।",
      "hu": "Megkeresi a hiányzó számot egy olyan sorozatban, amely eredetileg számtani sorozat volt.\n\nA bemenet egy három egész számot tartalmazó tömb, amely a sorozat megmaradt számait képviseli, miután egy szám elveszett. A függvény visszaadja a hiányzó számot. Az eredeti négy számú sorozat számtani sorozat volt.\n\nPéldák:\n- Ha a bemenet [3, 7, 5], a függvény 1-et vagy 9-et ad vissza, mivel a sorozat lehetett [1, 3, 5, 7] vagy [3, 5, 7, 9].\n- Ha a bemenet [20, 14, 8], a függvény 26-ot vagy 2-t ad vissza, mivel a sorozat lehetett [2, 8, 14, 20] vagy [8, 14, 20, 26]."
    },
    "docstring_bertscore": {
      "sq": "0.9830073695328464",
      "hy": "0.9883205335951486",
      "bn": "0.9912733728396133",
      "bg": "0.9943489656595574",
      "zh": "0.9685862079785703",
      "fr": "0.9875001901214745",
      "de": "0.9854262903130893",
      "ha": "0.9692395033017941",
      "hi": "0.9778632399248048",
      "hu": "0.9670865486017569"
    }
  },
  {
    "task_id": "Swift/26",
    "prompt": {
      "en": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "sq": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nNumëron sa herë nënat kujtohen për sjelljen e një fëmije.\nNjë nënë kujtohet nëse numri i porcioneve të ushqimit që një fëmijë ka marrë\n(përjashtuar atë aktual) është më i madh se numri total i porcioneve të ushqimit\ntë marra nga fëmijët e tjerë.\n\nShembull:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "hy": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nՀաշվել, թե քանի անգամ մայրերը հիշեցվում են երեխայի վարքի մասին։\nՄայրը հիշեցվում է, եթե երեխայի վերցրած սննդի բաժինների քանակը\n(բացառությամբ ընթացիկի) ավելի մեծ է, քան մյուս երեխաների վերցրած\nսննդի բաժինների ընդհանուր քանակը։\n\nՕրինակ:\nՄուտք: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nԵլք: 1\n*/",
      "bn": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nমায়েদের একটি শিশুর আচরণের কথা কতবার মনে করিয়ে দেওয়া হয় তা গণনা করুন।\nযদি কোনো শিশু যে পরিমাণ খাবার গ্রহণ করেছে (বর্তমানটি বাদ দিয়ে) \nঅন্যান্য শিশুদের দ্বারা গৃহীত মোট খাবারের পরিমাণের চেয়ে বেশি হয় তবে মায়েদের মনে করিয়ে দেওয়া হয়।\n\nউদাহরণ:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "bg": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nБройте колко пъти майките са напомнени за поведението на дете.\nМайката е напомнена, ако броят на порциите храна, които детето е взело\n(без да се включва текущата), е по-голям от общия брой порции храна,\nвзети от другите деца.\n\nПример:\nВход: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nИзход: 1\n*/",
      "zh": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\n计算妈妈们被提醒孩子行为的次数。\n如果一个孩子已经拿过的食物份数（不包括当前的）大于其他孩子拿过的食物份数总和，妈妈就会被提醒。\n\n示例：\n输入: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\n输出: 1\n*/",
      "fr": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCompter le nombre de fois où les mamans sont rappelées du comportement d'un enfant.\nUne maman est rappelée si le nombre de portions de nourriture qu'un enfant a prises\n(en excluant la portion actuelle) est supérieur au nombre total de portions de nourriture\nprises par les autres enfants.\n\nExemple:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "de": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nZähle die Anzahl der Male, die die Mütter an das Verhalten eines Kindes erinnert werden.\nEine Mutter wird erinnert, wenn die Anzahl der Essensportionen, die ein Kind genommen hat\n(ohne die aktuelle) größer ist als die Gesamtanzahl der Essensportionen,\ndie von anderen Kindern genommen wurden.\n\nBeispiel:\nEingabe: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nAusgabe: 1\n*/",
      "ha": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nƘirga adadin lokutan da iyaye mata ke tunawa da halayen yaro.\nAna tunatar da uwa idan adadin rabo na abinci da yaro ya dauka\n(banda wanda yake yanzu) ya fi adadin rabo na abinci da sauran yara suka dauka.\n\nMisali:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "hi": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nमाताओं को एक बच्चे के व्यवहार की याद दिलाने की संख्या गिनें।\nएक माँ को याद दिलाया जाता है यदि किसी बच्चे द्वारा ली गई भोजन की मात्रा\n(वर्तमान को छोड़कर) अन्य बच्चों द्वारा ली गई कुल भोजन की मात्रा से अधिक है।\n\nउदाहरण:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "hu": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nSzámolja meg, hányszor emlékeztetik az anyukákat egy gyermek viselkedésére.\nEgy anyuka akkor van emlékeztetve, ha egy gyermek által elvett ételadagok száma\n(a jelenlegi nélkül) nagyobb, mint a többi gyermek által elvett ételadagok teljes száma.\n\nPélda:\nBemenet: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nKimenet: 1\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9790266180665261",
      "hy": "0.9752675381054409",
      "bn": "0.9487406493486126",
      "bg": "0.985065974801892",
      "zh": "0.9602226771547153",
      "fr": "0.9876499574287748",
      "de": "0.9892660142088746",
      "ha": "0.9666426097001439",
      "hi": "0.9573427352600905",
      "hu": "0.982077382088841"
    },
    "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}",
    "instruction": {
      "en": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nՏվեք Swift կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9182848516549142",
      "bn": "0.8766499374861914",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()",
    "entry_point": "countUnfairReminders",
    "signature": "func countUnfairReminders(_ children: [String]) -> Int {",
    "docstring": {
      "en": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n",
      "sq": "Numëroni sa herë nënat kujtohen për sjelljen e një fëmije. Një nënë kujtohet nëse numri i porcioneve të ushqimit që një fëmijë ka marrë (duke përjashtuar atë aktualin) është më i madh se numri total i porcioneve të ushqimit të marra nga fëmijët e tjerë.\n\nShembull:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "hy": "Հաշվել, թե քանի անգամ մայրերը հիշեցվում են երեխայի վարքագծի մասին։  \nՄայրերը հիշեցվում են, եթե երեխայի վերցրած սննդի բաժինների քանակը  \n(բացառելով ընթացիկը) ավելին է, քան մյուս երեխաների վերցրած սննդի  \nընդհանուր բաժինների քանակը։\n\nՕրինակ:  \nՄուտք: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nԵլք: 1  ",
      "bn": "Count the number of times the moms are reminded of a child's behavior.\nএকজন মা মনে করিয়ে দেওয়া হয় যদি একটি শিশুর নেওয়া খাদ্য অংশের সংখ্যা (বর্তমানটি বাদ দিয়ে) অন্য শিশুদের দ্বারা নেওয়া মোট খাদ্য অংশের চেয়ে বেশি হয়।\n\nউদাহরণ:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "bg": "Бройте колко пъти майките са напомнени за поведението на дете.\nМайката е напомнена, ако броят на порциите храна, които детето е взело\n(без да се включва текущата), е по-голям от общия брой на порциите храна,\nвзети от другите деца.\n\nПример:\nВход: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nИзход: 1",
      "zh": "计算提醒妈妈孩子行为的次数。\n如果一个孩子已经拿的食物份数（不包括当前这份）大于其他孩子拿的食物总数，则提醒妈妈。\n\n示例：\n输入: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\n输出: 1",
      "fr": "Comptez le nombre de fois où les mamans sont rappelées du comportement d'un enfant.  \nUne maman est rappelée si le nombre de portions de nourriture qu'un enfant a prises  \n(en excluant l'actuelle) est supérieur au nombre total de portions de nourriture  \nprises par les autres enfants.\n\nExemple :  \nEntrée : [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nSortie : 1  ",
      "de": "Zähle, wie oft die Mütter an das Verhalten eines Kindes erinnert werden.\nEine Mutter wird erinnert, wenn die Anzahl der Essensportionen, die ein Kind genommen hat\n(die aktuelle ausgenommen) größer ist als die Gesamtanzahl der Essensportionen,\ndie von anderen Kindern genommen wurden.\n\nBeispiel:\nEingabe: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nAusgabe: 1",
      "ha": "Ƙirga yawan lokutan da aka tunatar da iyaye game da halayen yaro. \nAna tunatar da uwa idan adadin rabon abinci da yaro ya ɗauka \n(banda wanda yake yanzu) ya fi yawan rabon abinci da sauran yara suka ɗauka.\n\nMisali:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "hi": "Count the number of times the moms are reminded of a child's behavior.  \nएक माँ को याद दिलाया जाता है यदि किसी बच्चे द्वारा ली गई भोजन की मात्रा (वर्तमान को छोड़कर) अन्य बच्चों द्वारा ली गई कुल भोजन की मात्रा से अधिक है।\n\nउदाहरण:  \nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nOutput: 1",
      "hu": "Számolja meg, hányszor emlékeztetik az anyákat egy gyermek viselkedésére.\nEgy anya emlékeztetve van, ha az egy gyermek által elfogyasztott ételadagok száma\n(a jelenlegi kivételével) nagyobb, mint a többi gyermek által elfogyasztott ételadagok teljes száma.\n\nPélda:\nBemenet: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nKimenet: 1"
    },
    "docstring_bertscore": {
      "sq": "0.9761858063569652",
      "hy": "0.9577276809385361",
      "bn": "0.9857002016085363",
      "bg": "0.9753032915740272",
      "zh": "0.9188565098915327",
      "fr": "0.9900243850036659",
      "de": "0.9775150408668507",
      "ha": "0.940447632310025",
      "hi": "0.9698719424350092",
      "hu": "0.9642659971910615"
    }
  },
  {
    "task_id": "Swift/27",
    "prompt": {
      "en": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "sq": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nLlogarit numrin e mollëve të plota të mbetura pas një periudhe të caktuar kohe.\nNgrënia e një molle kërkon një periudhë të caktuar kohe dhe mund të hash vetëm një mollë në një kohë.\nFunksioni merr tre parametra:\n- m: numri total i mollëve.\n- t: koha që duhet për të ngrënë një mollë.\n- s: koha totale e kaluar.\nFunksioni kthen numrin e mollëve të plota që mbeten.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "hy": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nՀաշվարկել մնացած ամբողջ խնձորների քանակը որոշակի ժամանակ անց:\nԽնձոր ուտելը տևում է որոշակի ժամանակ, և դուք կարող եք ուտել միայն մեկ խնձոր միաժամանակ:\nՖունկցիան ընդունում է երեք պարամետրեր.\n- m: խնձորների ընդհանուր քանակը:\n- t: ժամանակը, որը պահանջվում է մեկ խնձոր ուտելու համար:\n- s: անցած ընդհանուր ժամանակը:\nՖունկցիան վերադարձնում է մնացած ամբողջ խնձորների քանակը:\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "bn": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nএকটি নির্দিষ্ট সময় পর কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা গণনা করুন।\nএকটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে এবং আপনি একবারে শুধুমাত্র একটি আপেল খেতে পারেন।\nফাংশনটি তিনটি প্যারামিটার গ্রহণ করে:\n- m: আপেলের মোট সংখ্যা।\n- t: একটি আপেল খেতে যে সময় লাগে।\n- s: মোট সময় যা পেরিয়ে গেছে।\nফাংশনটি অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা প্রদান করে।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "bg": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nИзчислете броя на останалите цели ябълки след определено количество време.\nЯденето на една ябълка отнема определено време и можете да ядете само една ябълка наведнъж.\nФункцията приема три параметъра:\n- m: общият брой ябълки.\n- t: времето, необходимо за изяждане на една ябълка.\n- s: общото изминало време.\nФункцията връща броя на останалите цели ябълки.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "zh": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\n计算在一定时间后剩余的完整苹果数量。\n吃一个苹果需要一定的时间，并且一次只能吃一个苹果。\n该函数有三个参数：\n- m: 苹果的总数量。\n- t: 吃一个苹果所需的时间。\n- s: 已经过的总时间。\n该函数返回剩余的完整苹果数量。\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "fr": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalcule le nombre de pommes entières restantes après un certain temps.\nManger une pomme prend un certain temps et vous ne pouvez manger qu'une pomme à la fois.\nLa fonction prend trois paramètres :\n- m : le nombre total de pommes.\n- t : le temps nécessaire pour manger une pomme.\n- s : le temps total écoulé.\nLa fonction renvoie le nombre de pommes entières restantes.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "de": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nBerechne die Anzahl der verbleibenden ganzen Äpfel nach einer bestimmten Zeit.\nDas Essen eines Apfels dauert eine bestimmte Zeit und man kann nur einen Apfel auf einmal essen.\nDie Funktion nimmt drei Parameter:\n- m: die Gesamtanzahl der Äpfel.\n- t: die Zeit, die benötigt wird, um einen Apfel zu essen.\n- s: die insgesamt vergangene Zeit.\nDie Funktion gibt die Anzahl der verbleibenden ganzen Äpfel zurück.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "ha": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nƘididdige yawan cikakkun tuffa da suka rage bayan wani lokaci.\nCin tuffa guda yana ɗaukar wani lokaci kuma za ka iya cin tuffa guda ɗaya kawai a lokaci guda.\nAikin yana ɗaukar sigogi guda uku:\n- m: jimillar yawan tuffa.\n- t: lokacin da ake ɗauka don cin tuffa guda.\n- s: jimillar lokacin da ya wuce.\nAikin yana dawowa da yawan cikakkun tuffa da suka rage.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "hi": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nकुल समय के बाद बचे हुए पूरे सेबों की संख्या की गणना करें।\nएक सेब खाने में एक निश्चित समय लगता है और आप एक बार में केवल एक सेब खा सकते हैं।\nयह फ़ंक्शन तीन पैरामीटर लेता है:\n- m: सेबों की कुल संख्या।\n- t: एक सेब खाने में लगने वाला समय।\n- s: कुल बीता हुआ समय।\nफ़ंक्शन उन पूरे सेबों की संख्या लौटाता है जो बचे हैं।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "hu": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nSzámítsd ki a megmaradt egész almák számát egy bizonyos idő elteltével.\nEgy alma elfogyasztása bizonyos időt vesz igénybe, és egyszerre csak egy almát lehet megenni.\nA függvény három paramétert vesz fel:\n- m: az almák teljes száma.\n- t: az idő, ami egy alma elfogyasztásához szükséges.\n- s: az eltelt teljes idő.\nA függvény visszaadja a megmaradt egész almák számát.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9740197420517798",
      "hy": "0.9743192766663803",
      "bn": "0.9552374518515018",
      "bg": "0.9729538914271465",
      "zh": "0.953667874580564",
      "fr": "0.965646279708873",
      "de": "0.9738469336202794",
      "ha": "0.9600244440344425",
      "hi": "0.9422935044409823",
      "hu": "0.9705008062213657"
    },
    "canonical_solution": "let eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}",
    "instruction": {
      "en": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nBa da taƙaitaccen bayanin yanayi na al'ada (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9240495025733088",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.8437380751309965",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func check(_ remainingApples: (Int, Int, Int) -> Int) {\nassert(remainingApples(50, 10, 200) == 30)\nassert(remainingApples(100, 5, 1000) == 0)\nassert(remainingApples(75, 15, 300) == 55)\nassert(remainingApples(20, 20, 400) == 0)\nassert(remainingApples(30, 10, 300) == 0)\nassert(remainingApples(40, 15, 600) == 0)\nassert(remainingApples(60, 10, 600) == 0)\n}\n\ncheck(remainingApples)",
    "entry_point": "remainingApples",
    "signature": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {",
    "docstring": {
      "en": "\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "sq": "Llogarit numrin e mollëve të plota të mbetura pas një periudhe të caktuar kohe. \nTë hash një mollë kërkon një kohë të caktuar dhe mund të hash vetëm një mollë në një kohë. \nFunksioni merr tre parametra: \n- m: numri total i mollëve. \n- t: koha që duhet për të ngrënë një mollë. \n- s: koha totale e kaluar. \nFunksioni kthen numrin e mollëve të plota që mbeten.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "hy": "Հաշվարկել մնացած ամբողջ խնձորների քանակը որոշակի ժամանակ անց:\nԽնձոր ուտելը տևում է որոշակի ժամանակ, և դուք կարող եք ուտել միայն մեկ խնձոր միաժամանակ:\nՖունկցիան ընդունում է երեք պարամետրեր:\n- m: խնձորների ընդհանուր քանակը:\n- t: մեկ խնձոր ուտելու համար անհրաժեշտ ժամանակը:\n- s: անցած ընդհանուր ժամանակը:\nՖունկցիան վերադարձնում է մնացած ամբողջ խնձորների քանակը:\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "bn": "বাকি সম্পূর্ণ আপেলের সংখ্যা নির্ণয় করুন একটি নির্দিষ্ট সময় পর।  \nএকটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে এবং আপনি এক সময়ে শুধুমাত্র একটি আপেল খেতে পারেন।  \nফাংশনটি তিনটি প্যারামিটার নেয়:  \n- m: আপেলের মোট সংখ্যা।  \n- t: একটি আপেল খেতে সময় লাগে।  \n- s: মোট সময় পেরিয়ে গেছে।  \nফাংশনটি বাকি সম্পূর্ণ আপেলের সংখ্যা ফেরত দেয়।  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  ",
      "bg": "Изчислете броя на останалите цели ябълки след определено време. Яденето на една ябълка отнема определено време и можете да ядете само по една ябълка наведнъж. Функцията приема три параметъра:\n- m: общият брой ябълки.\n- t: времето, необходимо за изяждане на една ябълка.\n- s: общото изминало време.\nФункцията връща броя на целите ябълки, които остават.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "zh": "计算在经过一段时间后剩余的完整苹果数量。  \n吃一个苹果需要一定的时间，并且你一次只能吃一个苹果。  \n该函数有三个参数：  \n- m: 苹果的总数。  \n- t: 吃一个苹果所需的时间。  \n- s: 已经过的总时间。  \n该函数返回剩余的完整苹果数量。  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  ",
      "fr": "Calculer le nombre de pommes entières restantes après un certain temps.\nManger une pomme prend un certain temps et vous ne pouvez manger qu'une pomme à la fois.\nLa fonction prend trois paramètres :\n- m : le nombre total de pommes.\n- t : le temps nécessaire pour manger une pomme.\n- s : le temps total écoulé.\nLa fonction renvoie le nombre de pommes entières restantes.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "de": "Berechne die Anzahl der verbleibenden ganzen Äpfel nach einer bestimmten Zeit.\nDas Essen eines Apfels dauert eine bestimmte Zeit und man kann nur einen Apfel auf einmal essen.\nDie Funktion nimmt drei Parameter:\n- m: die Gesamtanzahl der Äpfel.\n- t: die Zeit, die benötigt wird, um einen Apfel zu essen.\n- s: die insgesamt vergangene Zeit.\nDie Funktion gibt die Anzahl der verbleibenden ganzen Äpfel zurück.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "ha": "Ƙididdige adadin cikakkun tuffa da suka rage bayan wani lokaci.\nCin tuffa ɗaya yana ɗaukar wani lokaci kuma za ka iya cin tuffa ɗaya kawai a lokaci guda.\nAikin yana ɗaukar sigogi guda uku:\n- m: jimillar adadin tuffa.\n- t: lokacin da ake ɗauka don cin tuffa ɗaya.\n- s: jimillar lokacin da ya wuce.\nAikin yana dawowa da adadin cikakkun tuffa da suka rage.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "hi": "Calculate the number of remaining full apples after a certain amount of time.  \nएक निश्चित समय के बाद बचे हुए पूरे सेबों की संख्या की गणना करें।  \nEating an apple takes a certain amount of time and you can only eat one apple at a time.  \nएक सेब खाने में एक निश्चित समय लगता है और आप एक समय में केवल एक सेब खा सकते हैं।  \nThe function takes three parameters:  \nयह फ़ंक्शन तीन पैरामीटर लेता है:  \n- m: the total number of apples.  \n  - m: सेबों की कुल संख्या।  \n- t: the time it takes to eat one apple.  \n  - t: एक सेब खाने में लगने वाला समय।  \n- s: the total time passed.  \n  - s: कुल बीता हुआ समय।  \nThe function returns the number of full apples that remain.  \nयह फ़ंक्शन बचे हुए पूरे सेबों की संख्या लौटाता है।  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  ",
      "hu": "Számítsd ki, hogy hány teljes alma marad egy bizonyos idő elteltével.\nEgy alma elfogyasztása egy bizonyos időt vesz igénybe, és egyszerre csak egy almát lehet megenni.\nA függvény három paramétert vesz fel:\n- m: az almák teljes száma.\n- t: az idő, ami egy alma elfogyasztásához szükséges.\n- s: az eltelt teljes idő.\nA függvény visszaadja a megmaradt teljes almák számát.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9772006089736724",
      "hy": "0.9634061262715615",
      "bn": "0.9411652838767041",
      "bg": "0.9672241994558142",
      "zh": "0.9545285400215883",
      "fr": "0.9635280853255169",
      "de": "0.9694359487486376",
      "ha": "0.9425227239006965",
      "hi": "0.999999801369619",
      "hu": "0.9598722931625698"
    }
  },
  {
    "task_id": "Swift/28",
    "prompt": {
      "en": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "sq": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nKontrollon nëse numri i dhënë pëlqehet nga katër individët:\n- Personi A pëlqen numrin nëse është çift dhe midis 4 dhe 12 (përfshirë).\n- Personi U pëlqen numrin nëse është ose çift ose midis 4 dhe 12 (përfshirë).\n- Personi H pëlqen numrin nëse ka saktësisht një nga dy vetitë (çift ose midis 4 dhe 12).\n- Personi G pëlqen numrin nëse nuk ka të dyja vetitë (çift dhe midis 4 dhe 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "hy": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nՍտուգում է, արդյոք տրված ամբողջ թիվը դուր է գալիս չորս անձանցից յուրաքանչյուրին.\n- Անձ A-ին դուր է գալիս թիվը, եթե այն զույգ է և գտնվում է 4-ից 12 միջակայքում (ներառյալ):\n- Անձ U-ին դուր է գալիս թիվը, եթե այն կամ զույգ է, կամ գտնվում է 4-ից 12 միջակայքում (ներառյալ):\n- Անձ H-ին դուր է գալիս թիվը, եթե այն ունի հենց երկու հատկություններից մեկը (զույգ կամ 4-ից 12 միջակայքում):\n- Անձ G-ին դուր է գալիս թիվը, եթե այն չունի երկու հատկությունները (զույգ և 4-ից 12 միջակայքում):\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "bn": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nনিচের চারজন ব্যক্তির দ্বারা প্রদত্ত পূর্ণসংখ্যাটি পছন্দ করা হয়েছে কিনা তা পরীক্ষা করে:\n- ব্যক্তি A পূর্ণসংখ্যাটি পছন্দ করে যদি এটি জোড় সংখ্যা হয় এবং 4 এবং 12 এর মধ্যে (অন্তর্ভুক্ত) হয়।\n- ব্যক্তি U পূর্ণসংখ্যাটি পছন্দ করে যদি এটি হয় জোড় সংখ্যা অথবা 4 এবং 12 এর মধ্যে (অন্তর্ভুক্ত) হয়।\n- ব্যক্তি H পূর্ণসংখ্যাটি পছন্দ করে যদি এটি ঠিক দুটি বৈশিষ্ট্যের মধ্যে একটি হয় (জোড় সংখ্যা বা 4 এবং 12 এর মধ্যে)।\n- ব্যক্তি G পূর্ণসংখ্যাটি পছন্দ করে যদি এটি উভয় বৈশিষ্ট্য না থাকে (জোড় সংখ্যা এবং 4 এবং 12 এর মধ্যে)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "bg": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nПроверява дали даденото цяло число се харесва от четиримата индивиди:\n- Лице A харесва числото, ако е четно и между 4 и 12 (включително).\n- Лице U харесва числото, ако е или четно, или между 4 и 12 (включително).\n- Лице H харесва числото, ако има точно едно от двете свойства (четно или между 4 и 12).\n- Лице G харесва числото, ако няма и двете свойства (четно и между 4 и 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "zh": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\n检查给定的整数是否被四个人喜欢：\n- 如果整数是偶数且在4到12之间（包括4和12），A喜欢这个整数。\n- 如果整数是偶数或在4到12之间（包括4和12），U喜欢这个整数。\n- 如果整数恰好具有两个属性之一（偶数或在4到12之间），H喜欢这个整数。\n- 如果整数不具有两个属性（偶数和在4到12之间），G喜欢这个整数。\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "fr": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nVérifie si l'entier donné est apprécié par les quatre individus :\n- La personne A aime l'entier s'il est à la fois pair et compris entre 4 et 12 (inclus).\n- La personne U aime l'entier s'il est soit pair, soit compris entre 4 et 12 (inclus).\n- La personne H aime l'entier s'il possède exactement l'une des deux propriétés (pair ou compris entre 4 et 12).\n- La personne G aime l'entier s'il ne possède pas les deux propriétés (pair et compris entre 4 et 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "de": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nÜberprüft, ob die gegebene Ganzzahl von den vier Personen gemocht wird:\n- Person A mag die Ganzzahl, wenn sie sowohl gerade ist als auch zwischen 4 und 12 (einschließlich) liegt.\n- Person U mag die Ganzzahl, wenn sie entweder gerade ist oder zwischen 4 und 12 (einschließlich) liegt.\n- Person H mag die Ganzzahl, wenn sie genau eine der beiden Eigenschaften hat (gerade oder zwischen 4 und 12).\n- Person G mag die Ganzzahl, wenn sie nicht beide Eigenschaften hat (gerade und zwischen 4 und 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "ha": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nDuba idan mutumin da aka bayar yana so ta mutane hudu:\n- Mutum A yana son lambar idan tana daidai kuma tsakanin 4 da 12 (ciki har da).\n- Mutum U yana son lambar idan tana daidai ko kuma tsakanin 4 da 12 (ciki har da).\n- Mutum H yana son lambar idan tana daidai daya daga cikin abubuwa biyu (daidai ko tsakanin 4 da 12).\n- Mutum G yana son lambar idan ba ta da duka abubuwan biyu (daidai da tsakanin 4 da 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "hi": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nजांच करता है कि दिए गए पूर्णांक को चार व्यक्तियों द्वारा पसंद किया गया है या नहीं:\n- व्यक्ति A को पूर्णांक पसंद है यदि यह सम है और 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति U को पूर्णांक पसंद है यदि यह या तो सम है या 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति H को पूर्णांक पसंद है यदि यह ठीक दो गुणों में से एक है (सम या 4 और 12 के बीच)।\n- व्यक्ति G को पूर्णांक पसंद है यदि इसमें दोनों गुण नहीं हैं (सम और 4 और 12 के बीच)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "hu": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nEllenőrzi, hogy a megadott egész számot kedvelik-e a négy egyén:\n- A személy kedveli az egész számot, ha az páros és 4 és 12 között van (beleértve).\n- U személy kedveli az egész számot, ha az páros vagy 4 és 12 között van (beleértve).\n- H személy kedveli az egész számot, ha pontosan az egyik tulajdonsággal rendelkezik (páros vagy 4 és 12 között).\n- G személy kedveli az egész számot, ha nem rendelkezik mindkét tulajdonsággal (páros és 4 és 12 között).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9555248700128592",
      "hy": "0.9222850688985759",
      "bn": "0.9689671810493953",
      "bg": "0.9597531149339489",
      "zh": "0.9123438169581607",
      "fr": "0.9910884479548697",
      "de": "0.9892515141910591",
      "ha": "0.9217155955961488",
      "hi": "0.9716631912111818",
      "hu": "0.9537765253989902"
    },
    "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}",
    "instruction": {
      "en": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nSwift կոդի համար տրամադրել հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.8990590198137853",
      "bn": "0.8892538296843792",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9346315361229425",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)",
    "entry_point": "checkLikes",
    "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {",
    "docstring": {
      "en": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n",
      "sq": "Kontrollon nëse numri i dhënë është i pëlqyer nga katër individët:\n- Personi A pëlqen numrin nëse është çift dhe midis 4 dhe 12 (përfshirë).\n- Personi U pëlqen numrin nëse është ose çift ose midis 4 dhe 12 (përfshirë).\n- Personi H pëlqen numrin nëse ka saktësisht një nga dy vetitë (çift ose midis 4 dhe 12).\n- Personi G pëlqen numrin nëse nuk ka të dyja vetitë (çift dhe midis 4 dhe 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hy": "Ստուգում է, արդյոք տրված ամբողջ թիվը հավանում են չորս անձինք.\n- Անձ A-ն հավանում է թիվը, եթե այն և՛ զույգ է, և՛ 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ U-ն հավանում է թիվը, եթե այն կամ զույգ է, կամ 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ H-ն հավանում է թիվը, եթե այն ունի հենց երկու հատկություններից մեկը (զույգ կամ 4-ից 12 միջակայքում):\n- Անձ G-ն հավանում է թիվը, եթե այն չունի երկու հատկություններն էլ (զույգ և 4-ից 12 միջակայքում):\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "bn": "Checks if the given integer is liked by the four individuals:\n- ব্যক্তি A পূর্ণসংখ্যাটি পছন্দ করে যদি এটি উভয়ই জোড় সংখ্যা হয় এবং 4 এবং 12 এর মধ্যে হয় (অন্তর্ভুক্ত)।\n- ব্যক্তি U পূর্ণসংখ্যাটি পছন্দ করে যদি এটি হয় জোড় সংখ্যা বা 4 এবং 12 এর মধ্যে হয় (অন্তর্ভুক্ত)।\n- ব্যক্তি H পূর্ণসংখ্যাটি পছন্দ করে যদি এটি ঠিক দুটি বৈশিষ্ট্যের একটিতে থাকে (জোড় সংখ্যা বা 4 এবং 12 এর মধ্যে)।\n- ব্যক্তি G পূর্ণসংখ্যাটি পছন্দ করে যদি এতে উভয় বৈশিষ্ট্য না থাকে (জোড় সংখ্যা এবং 4 এবং 12 এর মধ্যে)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "bg": "Проверява дали даденото цяло число се харесва от четирите лица:\n- Лице A харесва числото, ако е както четно, така и между 4 и 12 (включително).\n- Лице U харесва числото, ако е или четно, или между 4 и 12 (включително).\n- Лице H харесва числото, ако то има точно едно от двете свойства (четно или между 4 и 12).\n- Лице G харесва числото, ако то няма и двете свойства (четно и между 4 и 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "zh": "检查给定的整数是否被四个人喜欢：\n- 如果整数是偶数且在4到12之间（包括4和12），A喜欢这个整数。\n- 如果整数是偶数或在4到12之间（包括4和12），U喜欢这个整数。\n- 如果整数恰好具有两个属性之一（偶数或在4到12之间），H喜欢这个整数。\n- 如果整数不同时具有两个属性（偶数和在4到12之间），G喜欢这个整数。\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "fr": "Vérifie si l'entier donné est apprécié par les quatre individus :\n- La personne A aime l'entier s'il est à la fois pair et compris entre 4 et 12 (inclus).\n- La personne U aime l'entier s'il est soit pair, soit compris entre 4 et 12 (inclus).\n- La personne H aime l'entier s'il possède exactement l'une des deux propriétés (pair ou compris entre 4 et 12).\n- La personne G aime l'entier s'il ne possède pas les deux propriétés (pair et compris entre 4 et 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "de": "Prüft, ob die gegebene ganze Zahl von den vier Personen gemocht wird:\n- Person A mag die ganze Zahl, wenn sie sowohl gerade als auch zwischen 4 und 12 (einschließlich) ist.\n- Person U mag die ganze Zahl, wenn sie entweder gerade oder zwischen 4 und 12 (einschließlich) ist.\n- Person H mag die ganze Zahl, wenn sie genau eine der beiden Eigenschaften hat (gerade oder zwischen 4 und 12).\n- Person G mag die ganze Zahl, wenn sie nicht beide Eigenschaften hat (gerade und zwischen 4 und 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "ha": "Duba idan lambar cikakke da aka bayar tana da farin jini ga mutane hudu:\n- Mutum A yana son lambar idan tana da ma'ana biyu kuma tana tsakanin 4 da 12 (ciki har da su).\n- Mutum U yana son lambar idan tana da ma'ana biyu ko tana tsakanin 4 da 12 (ciki har da su).\n- Mutum H yana son lambar idan tana da ɗaya kawai daga cikin kaddarorin biyu (ma'ana biyu ko tsakanin 4 da 12).\n- Mutum G yana son lambar idan ba ta da duka kaddarorin biyu (ma'ana biyu da tsakanin 4 da 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hi": "दिए गए पूर्णांक की जाँच करता है कि क्या यह चार व्यक्तियों को पसंद है:\n- व्यक्ति A को पूर्णांक पसंद है यदि यह सम है और 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति U को पूर्णांक पसंद है यदि यह या तो सम है या 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति H को पूर्णांक पसंद है यदि यह ठीक दो गुणों में से एक है (सम या 4 और 12 के बीच)।\n- व्यक्ति G को पूर्णांक पसंद है यदि इसमें दोनों गुण नहीं हैं (सम और 4 और 12 के बीच)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hu": "Ellenőrzi, hogy a megadott egész szám tetszik-e a négy személynek:\n- A személynek tetszik az egész szám, ha páros és 4 és 12 között van (beleértve).\n- U személynek tetszik az egész szám, ha páros vagy 4 és 12 között van (beleértve).\n- H személynek tetszik az egész szám, ha pontosan egy a két tulajdonság közül (páros vagy 4 és 12 között van).\n- G személynek tetszik az egész szám, ha nem rendelkezik mindkét tulajdonsággal (páros és 4 és 12 között van).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9422831756611684",
      "hy": "0.9101495471388683",
      "bn": "0.9506397544216871",
      "bg": "0.9582937775244855",
      "zh": "0.8787286044237215",
      "fr": "0.9831899108530174",
      "de": "0.9883449651320159",
      "ha": "0.9252045382390266",
      "hi": "0.9557660072954356",
      "hu": "0.9623851661130421"
    }
  },
  {
    "task_id": "Swift/29",
    "prompt": {
      "en": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "sq": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nPërcaktoni nëse një vit i dhënë është vit i brishtë.\nNjë vit i brishtë është i ndashëm saktësisht me 4 përveç viteve në fund të shekullit të cilët duhet të jenë të ndashëm me 400.\nKjo do të thotë që viti 2000 ishte vit i brishtë, megjithëse 1900 nuk ishte.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "hy": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nՈրոշել՝ արդյոք տրված տարին նահանջ տարի է:\nՆահանջ տարին բաժանվում է 4-ի, բացառությամբ դարավերջի տարիների, որոնք պետք է բաժանվեն 400-ի:\nՍա նշանակում է, որ 2000 թվականը նահանջ տարի էր, չնայած 1900-ը չէր:\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "bn": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nএকটি প্রদত্ত বছর অধিবর্ষ কিনা তা নির্ধারণ করুন।\nএকটি অধিবর্ষ ঠিক ৪ দ্বারা বিভাজ্য হয়, তবে শতাব্দীর শেষের বছরগুলির জন্য ৪০০ দ্বারা বিভাজ্য হতে হবে।\nএর মানে হল যে ২০০০ সাল একটি অধিবর্ষ ছিল, যদিও ১৯০০ সাল ছিল না।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "bg": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nОпределете дали дадена година е високосна.\nВисокосна година е тази, която се дели точно на 4, с изключение на годините в края на вековете, които трябва да се делят на 400.\nТова означава, че годината 2000 беше високосна, въпреки че 1900 не беше.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "zh": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\n确定给定年份是否为闰年。\n闰年是可以被4整除的年份，除了世纪末的年份，它们必须能被400整除。\n这意味着2000年是闰年，尽管1900年不是。\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "fr": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDéterminer si une année donnée est une année bissextile.\nUne année bissextile est exactement divisible par 4, sauf pour les années de fin de siècle qui doivent être divisibles par 400.\nCela signifie que l'année 2000 était une année bissextile, bien que 1900 ne l'était pas.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "de": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nBestimmen, ob ein gegebenes Jahr ein Schaltjahr ist.\nEin Schaltjahr ist genau durch 4 teilbar, außer am Ende eines Jahrhunderts, wo es durch 400 teilbar sein muss.\nDas bedeutet, dass das Jahr 2000 ein Schaltjahr war, obwohl 1900 keines war.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "ha": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nGano ko shekara da aka bayar shekara ce mai tsallakewa.\nShekara mai tsallakewa ita ce wadda za a iya rabawa da 4 ba tare da saura ba sai dai shekarun karshen karni wanda dole ne a iya rabawa da 400.\nWannan yana nufin cewa shekarar 2000 shekara ce mai tsallakewa, ko da yake shekarar 1900 ba ta kasance ba.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "hi": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nयह निर्धारित करें कि दिया गया वर्ष लीप वर्ष है या नहीं।\nएक लीप वर्ष 4 से पूरी तरह विभाज्य होता है, सिवाय शताब्दी के अंत वाले वर्षों के, जिन्हें 400 से विभाज्य होना चाहिए।\nइसका मतलब है कि वर्ष 2000 एक लीप वर्ष था, हालांकि 1900 नहीं था।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "hu": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nHatározza meg, hogy egy adott év szökőév-e.\nEgy szökőév pontosan osztható 4-gyel, kivéve a századfordulós éveket, amelyeknek oszthatónak kell lenniük 400-zal.\nEz azt jelenti, hogy a 2000-es év szökőév volt, bár az 1900-as nem volt az.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9889972673033345",
      "bn": "0.9725155141762025",
      "bg": "0.9826373211329783",
      "zh": "0.9739454542892727",
      "fr": "0.9980683195444358",
      "de": "0.9755952782341485",
      "ha": "0.9650350940264286",
      "hi": "0.9779347468619773",
      "hu": "0.9860493938183956"
    },
    "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}",
    "instruction": {
      "en": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки не повече от 500 знака.",
      "zh": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nBayar da takaitaccen bayanin yanayi (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8897005494113266",
      "bn": "0.8779922816012251",
      "bg": "0.9346778170017236",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.8772476163027253",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)",
    "entry_point": "isLeapYear",
    "signature": "func isLeapYear(_ year: Int) -> Int {",
    "docstring": {
      "en": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "sq": "Përcaktoni nëse një vit i dhënë është një vit i brishtë.  \nNjë vit i brishtë është saktësisht i pjestueshëm me 4 përveç viteve në fund të shekullit të cilat duhet të jenë të pjestueshme me 400.  \nKjo do të thotë që viti 2000 ishte një vit i brishtë, megjithëse 1900 nuk ishte.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "hy": "Հաստատել, արդյոք տրված տարին նահանջ տարի է:\nՆահանջ տարին ճշգրիտ բաժանվում է 4-ի, բացառությամբ դարավերջի տարիների, որոնք պետք է բաժանվեն 400-ի:\nՍա նշանակում է, որ 2000 թվականը նահանջ տարի էր, թեև 1900-ը չէր:\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "bn": "একটি প্রদত্ত বছর অধিবর্ষ কিনা তা নির্ধারণ করুন। \nএকটি অধিবর্ষ ঠিক ৪ দ্বারা বিভাজ্য হয়, তবে শতাব্দীর শেষের বছরগুলির ক্ষেত্রে এটি ৪০০ দ্বারা বিভাজ্য হতে হবে। \nএর অর্থ হল ২০০০ সাল একটি অধিবর্ষ ছিল, যদিও ১৯০০ সাল ছিল না।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "bg": "Определете дали дадена година е високосна.\nВисокосна година е тази, която се дели точно на 4, с изключение на годините в края на века, които трябва да се делят на 400.\nТова означава, че годината 2000 беше високосна, въпреки че 1900 не беше.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "zh": "确定给定年份是否为闰年。\n闰年是可以被4整除的年份，但世纪末的年份必须能被400整除。\n这意味着2000年是闰年，而1900年不是。\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "fr": "Déterminer si une année donnée est une année bissextile.  \nUne année bissextile est exactement divisible par 4, sauf pour les années de fin de siècle qui doivent être divisibles par 400.  \nCela signifie que l'année 2000 était une année bissextile, bien que 1900 ne l'était pas.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "de": "Bestimmen Sie, ob ein gegebenes Jahr ein Schaltjahr ist.\nEin Schaltjahr ist genau durch 4 teilbar, außer bei Jahrhundertjahren, die durch 400 teilbar sein müssen.\nDas bedeutet, dass das Jahr 2000 ein Schaltjahr war, obwohl 1900 keines war.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "ha": "Kayyade ko wani shekara da aka bayar shekara ce mai tsallakewa.  \nShekara mai tsallakewa tana rabuwa daidai da 4 sai dai shekarun ƙarshen ƙarni waɗanda dole ne su rabu da 400.  \nWannan yana nufin cewa shekarar 2000 shekara ce mai tsallakewa, ko da yake shekarar 1900 ba ta kasance ba.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "hi": "निर्धारित करें कि दिया गया वर्ष लीप वर्ष है या नहीं।  \nएक लीप वर्ष 4 से पूरी तरह विभाज्य होता है, सिवाय शताब्दी के अंत वाले वर्षों के, जिन्हें 400 से विभाज्य होना चाहिए।  \nइसका मतलब है कि वर्ष 2000 एक लीप वर्ष था, हालांकि 1900 नहीं था।  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "hu": "Határozza meg, hogy egy adott év szökőév-e.\nEgy szökőév pontosan osztható 4-gyel, kivéve az évszázad végét jelentő éveket, amelyeknek oszthatónak kell lenniük 400-zal.\nEz azt jelenti, hogy a 2000-es év szökőév volt, bár az 1900-as nem volt az.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9924149016394207",
      "bn": "0.9697648806596314",
      "bg": "0.9819238408043011",
      "zh": "0.9501294729728086",
      "fr": "0.998291977353481",
      "de": "0.9844001657646629",
      "ha": "0.9854858794273997",
      "hi": "0.9718191160602943",
      "hu": "0.9767777248924492"
    }
  },
  {
    "task_id": "Swift/30",
    "prompt": {
      "en": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "sq": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nLlogarit numrin e ditëve në një muaj të caktuar të një viti të caktuar.\nMerr parasysh nëse viti është vit i brishtë apo jo.\n\n- Parametrat:\n- year: Viti për të cilin do të llogaritet numri i ditëve.\n- month: Muaji për të cilin do të llogaritet numri i ditëve.\n\n- Kthen: Numri i ditëve në muajin e dhënë të vitit të dhënë.\n\nShembuj:\ndaysInMonth(1926, 8) // Kthen 31\ndaysInMonth(2000, 2) // Kthen 29\n*/",
      "hy": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nՀաշվում է օրերի քանակը տրված տարվա տրված ամսում:\nՀաշվի է առնում, թե արդյոք տարին նահանջ տարի է, թե ոչ:\n\n- Պարամետրեր:\n- year: Տարին, որի համար պետք է հաշվել օրերի քանակը:\n- month: Ամիսը, որի համար պետք է հաշվել օրերի քանակը:\n\n- Վերադարձնում է: Օրերի քանակը տրված տարվա տրված ամսում:\n\nՕրինակներ:\ndaysInMonth(1926, 8) // Վերադարձնում է 31\ndaysInMonth(2000, 2) // Վերադարձնում է 29\n*/",
      "bn": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nএকটি প্রদত্ত বছরের একটি নির্দিষ্ট মাসে দিনের সংখ্যা গণনা করে।\nবছরটি অধিবর্ষ কিনা তা বিবেচনা করে।\n\n- Parameters:\n- year: যে বছরের জন্য দিনের সংখ্যা গণনা করতে হবে।\n- month: যে মাসের জন্য দিনের সংখ্যা গণনা করতে হবে।\n\n- Returns: প্রদত্ত বছরের প্রদত্ত মাসে দিনের সংখ্যা।\n\nউদাহরণ:\ndaysInMonth(1926, 8) // 31 প্রদান করে\ndaysInMonth(2000, 2) // 29 প্রদান করে\n*/",
      "bg": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nИзчислява броя на дните в даден месец на дадена година.\nВзема предвид дали годината е високосна или не.\n\n- Параметри:\n- year: Годината, за която да се изчисли броят на дните.\n- month: Месецът, за който да се изчисли броят на дните.\n\n- Връща: Броят на дните в дадения месец на дадената година.\n\nПримери:\ndaysInMonth(1926, 8) // Връща 31\ndaysInMonth(2000, 2) // Връща 29\n*/",
      "zh": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\n计算给定年份中给定月份的天数。\n考虑年份是否为闰年。\n\n- 参数:\n- year: 要计算天数的年份。\n- month: 要计算天数的月份。\n\n- 返回: 给定年份中给定月份的天数。\n\n示例:\ndaysInMonth(1926, 8) // 返回 31\ndaysInMonth(2000, 2) // 返回 29\n*/",
      "fr": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalcule le nombre de jours dans un mois donné d'une année donnée.\nPrend en compte si l'année est bissextile ou non.\n\n- Paramètres:\n- year: L'année pour laquelle calculer le nombre de jours.\n- month: Le mois pour lequel calculer le nombre de jours.\n\n- Retourne: Le nombre de jours dans le mois donné de l'année donnée.\n\nExemples:\ndaysInMonth(1926, 8) // Retourne 31\ndaysInMonth(2000, 2) // Retourne 29\n*/",
      "de": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nBerechnet die Anzahl der Tage in einem bestimmten Monat eines bestimmten Jahres.\nBerücksichtigt, ob das Jahr ein Schaltjahr ist oder nicht.\n\n- Parameter:\n- year: Das Jahr, für das die Anzahl der Tage berechnet werden soll.\n- month: Der Monat, für den die Anzahl der Tage berechnet werden soll.\n\n- Rückgabe: Die Anzahl der Tage im angegebenen Monat des angegebenen Jahres.\n\nBeispiele:\ndaysInMonth(1926, 8) // Gibt 31 zurück\ndaysInMonth(2000, 2) // Gibt 29 zurück\n*/",
      "ha": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nYana lissafin yawan kwanaki a wata da aka bayar na shekara da aka bayar.\nYana la'akari da ko shekarar shekara mai tsallakewa ce ko a'a.\n\n- Sigogi:\n- year: Shekarar da za a lissafa yawan kwanaki.\n- month: Watan da za a lissafa yawan kwanaki.\n\n- Komawa: Yawan kwanaki a watan da aka bayar na shekarar da aka bayar.\n\nMisalai:\ndaysInMonth(1926, 8) // Yana dawowa 31\ndaysInMonth(2000, 2) // Yana dawowa 29\n*/",
      "hi": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nकिसी दिए गए वर्ष के किसी दिए गए महीने में दिनों की संख्या की गणना करता है।\nयह ध्यान में रखता है कि वर्ष लीप वर्ष है या नहीं।\n\n- Parameters:\n- year: वह वर्ष जिसके लिए दिनों की संख्या की गणना करनी है।\n- month: वह महीना जिसके लिए दिनों की संख्या की गणना करनी है।\n\n- Returns: दिए गए वर्ष के दिए गए महीने में दिनों की संख्या।\n\nउदाहरण:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "hu": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nKiszámítja a napok számát egy adott év adott hónapjában.\nFigyelembe veszi, hogy az év szökőév-e vagy sem.\n\n- Paraméterek:\n- year: Az év, amelyre a napok számát ki kell számítani.\n- month: A hónap, amelyre a napok számát ki kell számítani.\n\n- Visszatér: A napok száma az adott év adott hónapjában.\n\nPéldák:\ndaysInMonth(1926, 8) // Visszatér 31\ndaysInMonth(2000, 2) // Visszatér 29\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9765697588835056",
      "hy": "0.9714977321037798",
      "bn": "0.9608874930400392",
      "bg": "1",
      "zh": "0.9768589647182924",
      "fr": "1",
      "de": "0.9571166938864728",
      "ha": "0.9906671529166947",
      "hi": "0.9717160268925371",
      "hu": "0.9765461218681625"
    },
    "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки не повече от 500 знака.",
      "zh": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简明的自然语言描述（文档字符串）。",
      "fr": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8754724565874165",
      "bg": "0.9346778170017236",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9404853720824217",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()",
    "entry_point": "daysInMonth",
    "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n",
      "sq": "Llogarit numrin e ditëve në një muaj të caktuar të një viti të caktuar. Merr parasysh nëse viti është vit i brishtë apo jo.\n\n- Parametrat:\n- year: Viti për të cilin do të llogaritet numri i ditëve.\n- month: Muaji për të cilin do të llogaritet numri i ditëve.\n\n- Kthen: Numri i ditëve në muajin e dhënë të vitit të dhënë.\n\nShembuj:\ndaysInMonth(1926, 8) // Kthen 31\ndaysInMonth(2000, 2) // Kthen 29",
      "hy": "Հաշվում է օրերի քանակը տրված տարվա տրված ամսում: Հաշվի է առնում, թե արդյոք տարին նահանջ տարի է, թե ոչ:\n\n- Պարամետրեր:\n- year: Տարին, որի համար պետք է հաշվել օրերի քանակը:\n- month: Ամիսը, որի համար պետք է հաշվել օրերի քանակը:\n\n- Վերադարձնում է: Օրերի քանակը տրված տարվա տրված ամսում:\n\nՕրինակներ:\ndaysInMonth(1926, 8) // Վերադարձնում է 31\ndaysInMonth(2000, 2) // Վերադարձնում է 29",
      "bn": "একটি প্রদত্ত বছরের একটি নির্দিষ্ট মাসে কত দিন আছে তা গণনা করে। বছরটি লিপ ইয়ার কিনা তা বিবেচনায় নেয়।\n\n- প্যারামিটারসমূহ:\n- year: যে বছরের জন্য দিনের সংখ্যা গণনা করতে হবে।\n- month: যে মাসের জন্য দিনের সংখ্যা গণনা করতে হবে।\n\n- রিটার্নস: প্রদত্ত বছরের প্রদত্ত মাসে দিনের সংখ্যা।\n\nউদাহরণসমূহ:\ndaysInMonth(1926, 8) // 31 রিটার্ন করে\ndaysInMonth(2000, 2) // 29 রিটার্ন করে",
      "bg": "Изчислява броя на дните в даден месец на дадена година. Взема предвид дали годината е високосна или не.\n\n- Параметри:\n- year: Годината, за която да се изчисли броят на дните.\n- month: Месецът, за който да се изчисли броят на дните.\n\n- Връща: Броят на дните в дадения месец на дадената година.\n\nПримери:\ndaysInMonth(1926, 8) // Връща 31\ndaysInMonth(2000, 2) // Връща 29",
      "zh": "计算给定年份的给定月份中的天数。\n考虑年份是否为闰年。\n\n- 参数:\n- year: 要计算天数的年份。\n- month: 要计算天数的月份。\n\n- 返回: 给定年份的给定月份中的天数。\n\n示例:\ndaysInMonth(1926, 8) // 返回 31\ndaysInMonth(2000, 2) // 返回 29",
      "fr": "Calcule le nombre de jours dans un mois donné d'une année donnée.  \nPrend en compte si l'année est bissextile ou non.\n\n- Paramètres:\n- year: L'année pour laquelle calculer le nombre de jours.\n- month: Le mois pour lequel calculer le nombre de jours.\n\n- Renvoie: Le nombre de jours dans le mois donné de l'année donnée.\n\nExemples:\ndaysInMonth(1926, 8) // Renvoie 31\ndaysInMonth(2000, 2) // Renvoie 29",
      "de": "Berechnet die Anzahl der Tage in einem gegebenen Monat eines gegebenen Jahres.\nBerücksichtigt, ob das Jahr ein Schaltjahr ist oder nicht.\n\n- Parameter:\n- year: Das Jahr, für das die Anzahl der Tage berechnet werden soll.\n- month: Der Monat, für den die Anzahl der Tage berechnet werden soll.\n\n- Rückgabe: Die Anzahl der Tage im angegebenen Monat des angegebenen Jahres.\n\nBeispiele:\ndaysInMonth(1926, 8) // Gibt 31 zurück\ndaysInMonth(2000, 2) // Gibt 29 zurück",
      "ha": "Calculates the number of days in a given month of a given year.  \nYana la'akari da ko shekarar shekara mai tsalle ce ko a'a.\n\n- Parameters:  \n- year: Shekarar da za a lissafa yawan kwanaki.  \n- month: Watan da za a lissafa yawan kwanaki.  \n\n- Returns: Yawan kwanaki a cikin watan da aka bayar na shekarar da aka bayar.  \n\nExamples:  \ndaysInMonth(1926, 8) // Returns 31  \ndaysInMonth(2000, 2) // Returns 29  ",
      "hi": "दिए गए वर्ष के दिए गए महीने में दिनों की संख्या की गणना करता है। यह ध्यान में रखता है कि वर्ष लीप वर्ष है या नहीं।\n\n- पैरामीटर्स:\n- year: वह वर्ष जिसके लिए दिनों की संख्या की गणना करनी है।\n- month: वह महीना जिसके लिए दिनों की संख्या की गणना करनी है।\n\n- रिटर्न्स: दिए गए वर्ष के दिए गए महीने में दिनों की संख्या।\n\nउदाहरण:\ndaysInMonth(1926, 8) // 31 लौटाता है\ndaysInMonth(2000, 2) // 29 लौटाता है",
      "hu": "Kiszámítja a napok számát egy adott év adott hónapjában.\nFigyelembe veszi, hogy az év szökőév-e vagy sem.\n\n- Paraméterek:\n- year: Az év, amelyre a napok számát ki kell számítani.\n- month: A hónap, amelyre a napok számát ki kell számítani.\n\n- Visszatérési érték: A napok száma az adott év adott hónapjában.\n\nPéldák:\ndaysInMonth(1926, 8) // Visszatér 31\ndaysInMonth(2000, 2) // Visszatér 29"
    },
    "docstring_bertscore": {
      "sq": "0.9663899518554676",
      "hy": "0.9722304795794174",
      "bn": "0.953986477711744",
      "bg": "1",
      "zh": "0.9626827144238325",
      "fr": "0.9970616607733509",
      "de": "0.9586391957571052",
      "ha": "0.9908705504268744",
      "hi": "0.9600476837890236",
      "hu": "0.9670525828066"
    }
  },
  {
    "task_id": "Swift/31",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "sq": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nGjen numrin minimal të rotacioneve 180-gradëshe të nevojshme për të riorganizuar vagonët e trenit në rend rritës.\n\nFunksioni merr një varg të numrave të plotë që përfaqësojnë rendin fillestar të vagonëve të trenit dhe kthen numrin minimal të rotacioneve të nevojshme për t'i renditur ato në rend rritës.\n\nShembuj të rasteve:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "hy": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nԳտնում է նվազագույն քանակությամբ 180 աստիճան պտույտներ, որոնք անհրաժեշտ են գնացքի վագոնները աճման կարգով դասավորելու համար:\n\nՖունկցիան ընդունում է ամբողջ թվերի զանգված, որը ներկայացնում է գնացքի վագոնների սկզբնական կարգը, և վերադարձնում է նվազագույն պտույտների քանակը, որոնք անհրաժեշտ են դրանք աճման կարգով դասավորելու համար:\n\nՕրինակներ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "bn": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nএকটি ট্রেনের গাড়িগুলিকে ক্রমবর্ধমান ক্রমে পুনর্বিন্যাস করতে প্রয়োজনীয় সর্বনিম্ন ১৮০-ডিগ্রি ঘূর্ণনের সংখ্যা খুঁজে বের করে।\n\nফাংশনটি ট্রেনের গাড়িগুলির প্রাথমিক ক্রমকে উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে নেয় এবং তাদের ক্রমবর্ধমান ক্রমে সাজাতে প্রয়োজনীয় সর্বনিম্ন ঘূর্ণনের সংখ্যা প্রদান করে।\n\nউদাহরণ কেস:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "bg": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nНамира минималния брой завъртания на 180 градуса, необходими за пренареждане на вагоните на влака във възходящ ред.\n\nФункцията приема масив от цели числа, представляващи началния ред на вагоните на влака, и връща минималния брой завъртания, необходими за подреждането им във възходящ ред.\n\nПримерни случаи:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "zh": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\n找到将火车车厢重新排列为升序所需的最小180度旋转次数。\n\n该函数接受一个整数数组，表示火车车厢的初始顺序，并返回将它们按升序排列所需的最小旋转次数。\n\n示例案例：\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "fr": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nTrouve le nombre minimum de rotations de 180 degrés nécessaires pour réorganiser les wagons d'un train dans l'ordre croissant.\n\nLa fonction prend un tableau d'entiers représentant l'ordre initial des wagons de train et renvoie le nombre minimum de rotations nécessaires pour les ordonner dans l'ordre croissant.\n\nExemples de cas :\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "de": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFindet die minimale Anzahl von 180-Grad-Drehungen, die benötigt werden, um die Waggons eines Zuges in aufsteigende Reihenfolge zu bringen.\n\nDie Funktion nimmt ein Array von ganzen Zahlen, das die anfängliche Reihenfolge der Waggons darstellt, und gibt die minimale Anzahl von Drehungen zurück, die erforderlich sind, um sie in aufsteigende Reihenfolge zu bringen.\n\nBeispielhafte Fälle:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "ha": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nNemo adadin juyawa 180-digiri mafi ƙaranci da ake buƙata don sake tsara motocin jirgin ƙasa cikin tsari mai ƙaruwa.\n\nAikin yana ɗaukar jerin lambobi masu wakiltar tsarin farko na motocin jirgin ƙasa, kuma yana dawo da adadin juyawa mafi ƙaranci da ake buƙata don tsara su cikin tsari mai ƙaruwa.\n\nMisalan lokuta:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "hi": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nएक ट्रेन की गाड़ियों को आरोही क्रम में पुनर्व्यवस्थित करने के लिए आवश्यक न्यूनतम 180-डिग्री घुमावों की संख्या खोजें।\n\nयह फ़ंक्शन ट्रेन की गाड़ियों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाले पूर्णांकों की एक सूची लेता है, और उन्हें आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम घुमावों की संख्या लौटाता है।\n\nउदाहरण मामले:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "hu": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nMegtalálja a minimális számú 180 fokos forgatást, amely szükséges ahhoz, hogy a vonat kocsijait növekvő sorrendbe rendezzük.\n\nA függvény egy egész számokból álló tömböt vesz át, amely a vonatkocsik kezdeti sorrendjét képviseli, és visszaadja a minimális forgatások számát, amely szükséges ahhoz, hogy azokat növekvő sorrendbe állítsuk.\n\nPélda esetek:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9857584003101796",
      "hy": "0.970838676499506",
      "bn": "0.9800577083744783",
      "bg": "0.9862865584933513",
      "zh": "0.9758527032079697",
      "fr": "0.985294399740082",
      "de": "0.9773811639900332",
      "ha": "0.9274379382433829",
      "hi": "0.9531005862123284",
      "hu": "0.9807066338293192"
    },
    "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}",
    "instruction": {
      "en": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nДайте кратко описание на Swift кода на български език, използвайки не повече от 500 знака.",
      "zh": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nBa da takaitaccen bayani cikin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.8990590198137853",
      "bn": "0.8754724565874165",
      "bg": "0.822453638020822",
      "zh": "0.8526498258065078",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9346315361229425",
      "hi": "0.9102601842611048",
      "hu": "0.9311469633484474"
    },
    "level": "",
    "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)",
    "entry_point": "minimumSwapsToOrder",
    "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n",
      "sq": "Gjen numrin minimal të rrotullimeve 180-gradëshe të nevojshme për të riorganizuar vagonët e trenit në rend rritës.\n\nFunksioni merr një varg të numrave të plotë që përfaqësojnë rendin fillestar të vagonëve të trenit dhe kthen numrin minimal të rrotullimeve të nevojshme për t'i renditur ato në rend rritës.\n\nRastet e shembullit:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hy": "Գտնում է 180 աստիճան պտույտների նվազագույն քանակը, որը անհրաժեշտ է գնացքի վագոնները աճման կարգով դասավորելու համար:\n\nՖունկցիան ընդունում է ամբողջ թվերի զանգված, որը ներկայացնում է գնացքի վագոնների սկզբնական կարգը, և վերադարձնում է պտույտների նվազագույն քանակը, որը պահանջվում է դրանք աճման կարգով դասավորելու համար:\n\nՕրինակներ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "bn": "ট্রেনের গাড়িগুলিকে ঊর্ধ্বমুখী ক্রমে পুনর্বিন্যাস করতে প্রয়োজনীয় সর্বনিম্ন ১৮০-ডিগ্রি ঘূর্ণনের সংখ্যা খুঁজে বের করে।\n\nফাংশনটি ট্রেনের গাড়ির প্রাথমিক ক্রমকে উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে গ্রহণ করে এবং তাদের ঊর্ধ্বমুখী ক্রমে সাজাতে প্রয়োজনীয় সর্বনিম্ন ঘূর্ণনের সংখ্যা ফেরত দেয়।\n\nউদাহরণ কেসসমূহ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "bg": "Намира минималния брой 180-градусови завъртания, необходими за пренареждане на вагоните на влак в нарастващ ред.\n\nФункцията приема масив от цели числа, представляващи началния ред на вагоните на влака, и връща минималния брой завъртания, необходими за подреждането им в нарастващ ред.\n\nПримерни случаи:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "zh": "找到将火车车厢重新排列为升序所需的最小180度旋转次数。\n\n该函数接受一个整数数组，表示火车车厢的初始顺序，并返回将它们按升序排列所需的最小旋转次数。\n\n示例案例：\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "fr": "Trouve le nombre minimum de rotations de 180 degrés nécessaires pour réorganiser les wagons d'un train dans l'ordre croissant.\n\nLa fonction prend un tableau d'entiers représentant l'ordre initial des wagons de train et renvoie le nombre minimum de rotations nécessaires pour les ordonner dans l'ordre croissant.\n\nCas d'exemple :\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "de": "Findet die minimale Anzahl von 180-Grad-Drehungen, die erforderlich sind, um die Waggons eines Zuges in aufsteigender Reihenfolge anzuordnen.\n\nDie Funktion nimmt ein Array von ganzen Zahlen, das die anfängliche Reihenfolge der Zugwaggons darstellt, und gibt die minimale Anzahl von Drehungen zurück, die erforderlich sind, um sie in aufsteigender Reihenfolge anzuordnen.\n\nBeispielhafte Fälle:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "ha": "Yana nemo mafi ƙarancin adadin juyawa digiri 180 da ake buƙata don sake tsara motocin jirgin a cikin tsari mai hawa.\n\nAikin yana ɗaukar jerin lambobi masu nuna tsari na farko na motocin jirgin, kuma yana dawo da mafi ƙarancin adadin juyawa da ake buƙata don tsara su a cikin tsari mai hawa.\n\nMisalan lokuta:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hi": "गाड़ियों के क्रम को आरोही क्रम में पुनर्व्यवस्थित करने के लिए आवश्यक 180-डिग्री घुमावों की न्यूनतम संख्या खोजता है।\n\nयह फ़ंक्शन गाड़ियों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाले पूर्णांकों की एक सूची लेता है, और उन्हें आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम घुमावों की संख्या लौटाता है।\n\nउदाहरण मामले:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hu": "Megtalálja a minimális számú 180 fokos forgatást, amely szükséges ahhoz, hogy egy vonat kocsijait növekvő sorrendbe rendezzük.\n\nA függvény egy egész számokat tartalmazó tömböt vesz át, amely a vonatkocsik kezdeti sorrendjét képviseli, és visszaadja a szükséges forgatások minimális számát, hogy azokat növekvő sorrendbe állítsa.\n\nPélda esetek:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10"
    },
    "docstring_bertscore": {
      "sq": "0.9744092562289891",
      "hy": "0.967382507869499",
      "bn": "0.9755551548971794",
      "bg": "0.9835112948095318",
      "zh": "0.968754845172069",
      "fr": "0.975159681808539",
      "de": "0.9748156539885865",
      "ha": "0.9510328439457553",
      "hi": "0.9465366466406495",
      "hu": "0.9760000869506975"
    }
  },
  {
    "task_id": "Swift/32",
    "prompt": {
      "en": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "sq": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nPërcakton nëse fjala e dhënë është një \"Fjalë me Fat.\" Një fjalë konsiderohet me fat nëse diferenca\nmidis frekuencave maksimale dhe minimale të karaktereve në fjalë është një numër i thjeshtë.\n\n- Parametrat:\n- word: Një varg që përfaqëson fjalën që do të kontrollohet. Supozohet të ketë vetëm shkronja të vogla dhe një gjatësi më pak se 100.\n\n- Kthen: Një tuple që përmban një boolean që tregon nëse fjala është me fat, dhe një numër i plotë që është diferenca\nmidis frekuencave maksimale dhe minimale nëse fjala është me fat, ose 0 përndryshe.\n\nShembuj:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "hy": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nՍահմանում է՝ արդյոք տրված բառը \"Հաջողակ Բառ\" է։ Բառը համարվում է հաջողակ, եթե բառում առավելագույն և նվազագույն\nսիմվոլների հաճախականությունների տարբերությունը պարզ թիվ է։\n\n- Պարամետրեր:\n- word: Տող, որը ներկայացնում է ստուգվող բառը։ Ենթադրվում է, որ պարունակում է միայն փոքրատառեր և ունի 100-ից փոքր երկարություն։\n\n- Վերադարձնում է: Զույգ, որը պարունակում է բուլյան արժեք, որը ցույց է տալիս՝ արդյոք բառը հաջողակ է, և ամբողջ թիվ, որը\nառավելագույն և նվազագույն հաճախականությունների տարբերությունն է, եթե բառը հաջողակ է, կամ 0՝ հակառակ դեպքում։\n\nՕրինակներ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "bn": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nনির্ধারণ করে যে প্রদত্ত শব্দটি একটি \"লাকি ওয়ার্ড\" কিনা। একটি শব্দকে লাকি বলা হয় যদি শব্দের মধ্যে সর্বাধিক এবং সর্বনিম্ন অক্ষরের ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\n\n- Parameters:\n- word: একটি স্ট্রিং যা যাচাই করার জন্য শব্দটি উপস্থাপন করে। শুধুমাত্র ছোট হাতের অক্ষর এবং দৈর্ঘ্য ১০০ এর কম ধরে নেয়।\n\n- Returns: একটি টিউপল প্রদান করে যা একটি বুলিয়ান নির্দেশ করে যে শব্দটি লাকি কিনা, এবং একটি পূর্ণসংখ্যা যা সর্বাধিক এবং সর্বনিম্ন ফ্রিকোয়েন্সির মধ্যে পার্থক্য যদি শব্দটি লাকি হয়, অন্যথায় ০।\n\nউদাহরণ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "bg": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nОпределя дали дадената дума е \"Късметлийска дума.\" Една дума се счита за късметлийска, ако разликата\nмежду максималната и минималната честота на символите в думата е просто число.\n\n- Параметри:\n- word: Низ, представляващ думата, която трябва да бъде проверена. Предполага се, че съдържа само малки букви и дължина по-малка от 100.\n\n- Връща: Кортеж, съдържащ булева стойност, показваща дали думата е късметлийска, и цяло число, което е разликата\nмежду максималната и минималната честота, ако думата е късметлийска, или 0 в противен случай.\n\nПримери:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "zh": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\n确定给定的单词是否为“幸运单词”。如果单词中字符出现频率的最大值和最小值之间的差是一个质数，则该单词被认为是幸运的。\n\n- 参数:\n- word: 一个字符串，表示要检查的单词。假设只有小写字母且长度小于100。\n\n- 返回: 一个包含布尔值的元组，指示单词是否幸运，以及如果单词是幸运的，则为最大和最小频率之间的差，否则为0。\n\n示例:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "fr": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDétermine si le mot donné est un \"mot chanceux.\" Un mot est considéré comme chanceux si la différence\nentre les fréquences des caractères maximum et minimum dans le mot est un nombre premier.\n\n- Paramètres:\n- word: Une chaîne de caractères représentant le mot à vérifier. Suppose uniquement des lettres minuscules et une longueur inférieure à 100.\n\n- Renvoie: Un tuple contenant un booléen indiquant si le mot est chanceux, et un entier qui est la différence\nentre les fréquences max et min si le mot est chanceux, ou 0 sinon.\n\nExemples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "de": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nBestimmt, ob das gegebene Wort ein \"Glückswort\" ist. Ein Wort wird als glücklich angesehen, wenn die Differenz\nzwischen den maximalen und minimalen Zeichenfrequenzen im Wort eine Primzahl ist.\n\n- Parameter:\n- word: Ein String, der das zu überprüfende Wort darstellt. Es wird angenommen, dass nur Kleinbuchstaben und eine Länge von weniger als 100 vorhanden sind.\n\n- Rückgabewerte: Ein Tupel, das einen booleschen Wert enthält, der angibt, ob das Wort glücklich ist, und eine ganze Zahl, die die Differenz\nzwischen den maximalen und minimalen Frequenzen ist, wenn das Wort glücklich ist, oder 0 andernfalls.\n\nBeispiele:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "ha": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nYana tantance idan kalmar da aka bayar kalma ce \"Mai Sa'a.\" Ana ɗaukar kalma mai sa'a idan bambanci\ntsakanin mafi girma da mafi ƙarancin yawan haruffa a cikin kalmar lamba ce mai lamba.\n\n- Ma'auni:\n- word: Wani kirtani da ke wakiltar kalmar da za a duba. Ana ɗauka kawai haruffan ƙananan baƙaƙe da tsawon ƙasa da 100.\n\n- Komawa: Wani tuple da ke ɗauke da boolean da ke nuna idan kalmar mai sa'a ce, da kuma cikakken lamba wanda shine bambanci\ntsakanin mafi girma da mafi ƙarancin yawan idan kalmar mai sa'a ce, ko 0 in ba haka ba.\n\nMisalai:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "hi": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nयह निर्धारित करता है कि दिया गया शब्द \"भाग्यशाली शब्द\" है या नहीं। एक शब्द को भाग्यशाली तब माना जाता है जब\nशब्द में अधिकतम और न्यूनतम वर्ण आवृत्तियों के बीच का अंतर एक अभाज्य संख्या हो।\n\n- पैरामीटर्स:\n- word: एक स्ट्रिंग जो जांचे जाने वाले शब्द का प्रतिनिधित्व करती है। केवल छोटे अक्षरों और 100 से कम लंबाई को मानती है।\n\n- रिटर्न्स: एक युग्म जिसमें एक बूलियन होता है जो यह दर्शाता है कि शब्द भाग्यशाली है या नहीं, और एक पूर्णांक जो\nअधिकतम और न्यूनतम आवृत्तियों के बीच का अंतर होता है यदि शब्द भाग्यशाली है, अन्यथा 0 होता है।\n\nउदाहरण:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "hu": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nMeghatározza, hogy a megadott szó \"Szerencsés Szó\"-e. Egy szó akkor tekinthető szerencsésnek, ha a szóban\na maximális és minimális karaktergyakoriság közötti különbség prímszám.\n\n- Paraméterek:\n- word: Egy string, amely a vizsgálandó szót képviseli. Feltételezi, hogy csak kisbetűket tartalmaz, és hossza kevesebb mint 100.\n\n- Visszatér: Egy tuple, amely tartalmaz egy logikai értéket, amely jelzi, hogy a szó szerencsés-e, és egy egész számot,\namely a maximális és minimális gyakoriság közötti különbség, ha a szó szerencsés, vagy 0 különben.\n\nPéldák:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9833406713122229",
      "hy": "0.9726525691391166",
      "bn": "0.9747693731098054",
      "bg": "0.9713660401611536",
      "zh": "0.9538281692980592",
      "fr": "0.9942081367194037",
      "de": "0.9637235376204553",
      "ha": "0.9586530998837777",
      "hi": "0.9699019356225455",
      "hu": "0.97111775218486"
    },
    "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}",
    "instruction": {
      "en": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nSwift կոդի համար տրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nনিম্নলিখিত Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nПредоставете кратко описание на Swift кода на български език, използвайки максимум 500 знака.",
      "zh": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8532159223924572",
      "bg": "0.8439380959246987",
      "zh": "0.8526498258065078",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9664368286253918",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()",
    "entry_point": "isLuckyWord",
    "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {",
    "docstring": {
      "en": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n",
      "sq": "Përcakton nëse fjala e dhënë është një \"Fjalë me Fat.\" Një fjalë konsiderohet me fat nëse diferenca\nmidis frekuencave maksimale dhe minimale të karaktereve në fjalë është një numër i thjeshtë.\n\n- Parametra:\n- word: Një varg që përfaqëson fjalën që do të kontrollohet. Supozohet vetëm shkronja të vogla dhe një gjatësi më pak se 100.\n\n- Kthen: Një dyshe që përmban një vlerë boolean që tregon nëse fjala është me fat, dhe një numër i plotë që është diferenca\nmidis frekuencave maksimale dhe minimale nëse fjala është me fat, ose 0 përndryshe.\n\nShembuj:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hy": "Սահմանում է՝ արդյոք տրված բառը «Բախտավոր Բառ» է։ Բառը համարվում է բախտավոր, եթե բառի առավելագույն և նվազագույն սիմվոլների հաճախականությունների տարբերությունը պարզ թիվ է։\n\n- Պարամետրեր:\n- word: Տող, որը ներկայացնում է ստուգվող բառը։ Ենթադրվում է, որ պարունակում է միայն փոքրատառեր և ունի 100-ից պակաս երկարություն։\n\n- Վերադարձնում է: Զույգ, որը պարունակում է բուլյան արժեք, որը ցույց է տալիս՝ արդյոք բառը բախտավոր է, և ամբողջ թիվ, որը առավելագույն և նվազագույն հաճախականությունների տարբերությունն է, եթե բառը բախտավոր է, կամ 0՝ հակառակ դեպքում։\n\nՕրինակներ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "bn": "প্রদত্ত শব্দটি \"লাকি ওয়ার্ড\" কিনা তা নির্ধারণ করে। একটি শব্দকে লাকি বলা হয় যদি শব্দের মধ্যে সর্বাধিক এবং সর্বনিম্ন অক্ষর ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\n\n- প্যারামিটারসমূহ:\n- word: একটি স্ট্রিং যা যাচাই করার জন্য শব্দটি উপস্থাপন করে। শুধুমাত্র ছোট হাতের অক্ষর এবং ১০০ এর চেয়ে কম দৈর্ঘ্য ধরে নেয়া হয়।\n\n- রিটার্নস: একটি টিউপল যা একটি বুলিয়ান ধারণ করে যা নির্দেশ করে শব্দটি লাকি কিনা, এবং একটি পূর্ণসংখ্যা যা সর্বাধিক এবং সর্বনিম্ন ফ্রিকোয়েন্সির মধ্যে পার্থক্য যদি শব্দটি লাকি হয়, অথবা অন্যথায় 0।\n\nউদাহরণসমূহ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "bg": "Определя дали дадената дума е \"Щастлива дума\". Една дума се счита за щастлива, ако разликата между максималната и минималната честота на символите в думата е просто число.\n\n- Параметри:\n- word: Низ, представляващ думата, която ще бъде проверена. Предполага се, че съдържа само малки букви и дължина по-малка от 100.\n\n- Връща: Кортеж, съдържащ булева стойност, указваща дали думата е щастлива, и цяло число, което е разликата между максималната и минималната честота, ако думата е щастлива, или 0 в противен случай.\n\nПримери:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "zh": "确定给定的单词是否是“幸运单词”。如果单词中字符出现频率的最大值和最小值之间的差是一个质数，则该单词被认为是幸运的。\n\n- 参数：\n- word: 一个字符串，表示要检查的单词。假设只有小写字母且长度小于100。\n\n- 返回：一个包含布尔值和整数的元组，布尔值表示单词是否幸运，整数是如果单词幸运则为最大和最小频率之间的差，否则为0。\n\n示例：\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "fr": "Détermine si le mot donné est un \"mot chanceux\". Un mot est considéré comme chanceux si la différence entre les fréquences maximales et minimales des caractères dans le mot est un nombre premier.\n\n- Paramètres:\n- word: Une chaîne de caractères représentant le mot à vérifier. Suppose uniquement des lettres minuscules et une longueur inférieure à 100.\n\n- Renvoie: Un tuple contenant un booléen indiquant si le mot est chanceux, et un entier qui est la différence entre les fréquences max et min si le mot est chanceux, ou 0 sinon.\n\nExemples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "de": "Bestimmt, ob das gegebene Wort ein \"Glückswort\" ist. Ein Wort wird als glücklich betrachtet, wenn die Differenz zwischen den maximalen und minimalen Zeichenhäufigkeiten im Wort eine Primzahl ist.\n\n- Parameter:\n- word: Ein String, der das zu überprüfende Wort darstellt. Geht davon aus, dass nur Kleinbuchstaben und eine Länge von weniger als 100 verwendet werden.\n\n- Rückgabewert: Ein Tupel, das einen booleschen Wert enthält, der angibt, ob das Wort glücklich ist, und eine ganze Zahl, die die Differenz zwischen den maximalen und minimalen Häufigkeiten ist, wenn das Wort glücklich ist, oder 0 andernfalls.\n\nBeispiele:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "ha": "Determines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference between the maximum and minimum character frequencies in the word is a prime number.\n\n- Sigogi:\n- word: Wani kirtani da ke wakiltar kalmar da za a duba. Ana tsammanin haruffa ƙanana kawai da tsawon kasa da 100.\n\n- Komawa: Wani tuple da ke dauke da boolean da ke nuna idan kalmar tana da sa'a, da kuma wani integer wanda shine bambanci tsakanin mafi girma da mafi karancin mitoci idan kalmar tana da sa'a, ko 0 in ba haka ba.\n\nMisalai:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hi": "दिया गया शब्द \"लकी वर्ड\" है या नहीं, यह निर्धारित करता है। एक शब्द को लकी माना जाता है यदि शब्द में अधिकतम और न्यूनतम वर्ण आवृत्तियों के बीच का अंतर एक अभाज्य संख्या है।\n\n- पैरामीटर्स:\n- word: एक स्ट्रिंग जो जांचे जाने वाले शब्द का प्रतिनिधित्व करती है। केवल छोटे अक्षरों और 100 से कम लंबाई को मानती है।\n\n- रिटर्न्स: एक ट्यूपल जिसमें एक बूलियन होता है जो यह इंगित करता है कि शब्द लकी है या नहीं, और एक पूर्णांक जो अधिकतम और न्यूनतम आवृत्तियों के बीच का अंतर होता है यदि शब्द लकी है, अन्यथा 0 होता है।\n\nउदाहरण:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hu": "Meghatározza, hogy a megadott szó \"Szerencsés Szó\"-e. Egy szót akkor tekintünk szerencsésnek, ha a szóban a maximális és minimális karaktergyakoriságok közötti különbség prímszám.\n\n- Paraméterek:\n- word: Egy string, amely a vizsgálandó szót képviseli. Feltételezi, hogy csak kisbetűket tartalmaz, és a hossza kevesebb, mint 100.\n\n- Visszatér: Egy tuple, amely tartalmaz egy logikai értéket, ami jelzi, hogy a szó szerencsés-e, és egy egész számot, amely a maximális és minimális gyakoriságok közötti különbség, ha a szó szerencsés, vagy 0-t egyébként.\n\nPéldák:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)"
    },
    "docstring_bertscore": {
      "sq": "0.9842051107304868",
      "hy": "0.961922754585993",
      "bn": "0.9691795169267216",
      "bg": "0.9644715796354326",
      "zh": "0.9398803439417893",
      "fr": "0.9800737974353421",
      "de": "0.9670035211024843",
      "ha": "0.9598095259621628",
      "hi": "0.9662391913962621",
      "hu": "0.9676921726335324"
    }
  },
  {
    "task_id": "Swift/33",
    "prompt": {
      "en": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/",
      "sq": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nGjen shumën maksimale të një nënvargu të pandërprerë në një varg të numrave të plotë.\n\n- Parametrat:\n- nums: Një varg i numrave të plotë.\n\n- Kthen: Shuma maksimale e çdo nënvargu të pandërprerë.\n\nShembuj:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ka shumën 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] është shuma më e madhe në varg\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ka shumën 7\n*/",
      "hy": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nԳտնում է ամբողջ թվերի զանգվածում հարակից ենթազանգվածի առավելագույն գումարը։\n\n- Պարամետրեր:\n- nums: Ամբողջ թվերի զանգված։\n\n- Վերադարձնում է: Ցանկացած հարակից ենթազանգվածի առավելագույն գումարը։\n\nՕրինակներ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] գումարվում է 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ամենամեծ գումարն է զանգվածում\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] գումարվում է 7\n*/",
      "bn": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nএকটি পূর্ণসংখ্যার অ্যারেতে একটি সন্নিহিত উপঅ্যারের সর্বাধিক যোগফল খুঁজে বের করে।\n\n- প্যারামিটার:\n- nums: পূর্ণসংখ্যার একটি অ্যারে।\n\n- রিটার্নস: যেকোনো সন্নিহিত উপঅ্যারের সর্বাধিক যোগফল।\n\nউদাহরণ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] এর যোগফল 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] অ্যারেতে সর্বাধিক যোগফল\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] এর যোগফল 7\n*/",
      "bg": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nНамира максималната сума на непрекъснат подмасив в масив от цели числа.\n\n- Параметри:\n- nums: Масив от цели числа.\n\n- Връща: Максималната сума на който и да е непрекъснат подмасив.\n\nПримери:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] сумира до 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] е най-голямата сума в масива\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] сумира до 7\n*/",
      "zh": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\n找到整数数组中连续子数组的最大和。\n\n- 参数：\n- nums: 一个整数数组。\n\n- 返回：任何连续子数组的最大和。\n\n示例：\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] 的和为 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] 是数组中最大的和\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] 的和为 7\n*/",
      "fr": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nTrouve la somme maximale d'un sous-tableau contigu dans un tableau d'entiers.\n\n- Paramètres :\n- nums : Un tableau d'entiers.\n\n- Renvoie : La somme maximale de tout sous-tableau contigu.\n\nExemples :\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] somme à 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] est la plus grande somme dans le tableau\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] somme à 7\n*/",
      "de": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFindet die maximale Summe eines zusammenhängenden Teilarrays in einem Array von ganzen Zahlen.\n\n- Parameter:\n- nums: Ein Array von ganzen Zahlen.\n\n- Rückgabewert: Die maximale Summe eines beliebigen zusammenhängenden Teilarrays.\n\nBeispiele:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] summiert sich zu 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ist die größte Summe im Array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] summiert sich zu 7\n*/",
      "ha": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nNemi mafi girman jimillar wani jere mai ci gaba a cikin jerin lambobi.\n\n- Sigogi:\n- nums: Jerin lambobi.\n\n- Komawa: Mafi girman jimillar kowanne jere mai ci gaba.\n\nMisalai:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] yana da jimillar 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] shine mafi girman jimilla a cikin jerin\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] yana da jimillar 7\n*/",
      "hi": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nकिसी पूर्णांक के सरणी में एक सन्निहित उपसरणी का अधिकतम योग खोजता है।\n\n- पैरामीटर्स:\n- nums: पूर्णांकों की एक सरणी।\n\n- रिटर्न्स: किसी भी सन्निहित उपसरणी का अधिकतम योग।\n\nउदाहरण:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] का योग 9 है\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] सरणी में सबसे बड़ा योग है\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] का योग 7 है\n*/",
      "hu": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nMegtalálja a maximális összeget egy összefüggő részhalmazban egy egész számokat tartalmazó tömbben.\n\n- Paraméterek:\n- nums: Egész számokat tartalmazó tömb.\n\n- Visszatér: Bármely összefüggő részhalmaz maximális összege.\n\nPéldák:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] összege 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] a legnagyobb összeg a tömbben\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] összege 7\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9854219204447064",
      "hy": "0.999999801369619",
      "bn": "0.9521910576975696",
      "bg": "0.9955908028017876",
      "zh": "0.9645109084508776",
      "fr": "0.999999801369619",
      "de": "0.985903003227573",
      "ha": "0.957362598298194",
      "hi": "0.9644977988457293",
      "hu": "0.9727181171648581"
    },
    "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}",
    "instruction": {
      "en": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nBada gajeriyar bayanin abinda lambar Swift take yi (docstring) cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9229242614647462",
      "bn": "0.8779922816012251",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.879556893112637",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)",
    "entry_point": "maxSubArraySum",
    "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n",
      "sq": "Gjen shumën maksimale të një nënvargu të pandërprerë në një varg të numrave të plotë.\n\n- Parametra:\n- nums: Një varg i numrave të plotë.\n\n- Kthen: Shuma maksimale e çdo nënvargu të pandërprerë.\n\nShembuj:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ka shumën 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] është shuma më e madhe në varg\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ka shumën 7",
      "hy": "Գտնում է ամբողջ թվերի զանգվածում հարակից ենթազանգվածի առավելագույն գումարը։\n\n- Պարամետրեր:\n- nums: Ամբողջ թվերի զանգված։\n\n- Վերադարձնում է: Ցանկացած հարակից ենթազանգվածի առավելագույն գումարը։\n\nՕրինակներ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] գումարվում է 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ամենամեծ գումարն է զանգվածում\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] գումարվում է 7",
      "bn": "একটি পূর্ণসংখ্যার অ্যারের মধ্যে একটি সংলগ্ন উপঅ্যারের সর্বাধিক যোগফল খুঁজে বের করে।\n\n- প্যারামিটারসমূহ:\n- nums: পূর্ণসংখ্যার একটি অ্যারে।\n\n- রিটার্নস: যেকোনো সংলগ্ন উপঅ্যারের সর্বাধিক যোগফল।\n\nউদাহরণসমূহ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] এর যোগফল 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] অ্যারের সর্বাধিক যোগফল\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] এর যোগফল 7",
      "bg": "Намира максималната сума на непрекъснат подмасив в масив от цели числа.\n\n- Параметри:\n- nums: Масив от цели числа.\n\n- Връща: Максималната сума на който и да е непрекъснат подмасив.\n\nПримери:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] сумата е 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] е най-голямата сума в масива\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] сумата е 7",
      "zh": "找到整数数组中连续子数组的最大和。\n\n- 参数：\n- nums: 整数数组。\n\n- 返回：任何连续子数组的最大和。\n\n示例：\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] 的和为 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] 是数组中最大的和\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] 的和为 7",
      "fr": "Trouve la somme maximale d'un sous-tableau contigu dans un tableau d'entiers.\n\n- Paramètres:\n- nums: Un tableau d'entiers.\n\n- Renvoie: La somme maximale de tout sous-tableau contigu.\n\nExemples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] somme à 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] est la plus grande somme dans le tableau\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] somme à 7",
      "de": "Findet die maximale Summe eines zusammenhängenden Teilarrays in einem Array von ganzen Zahlen.\n\n- Parameter:\n- nums: Ein Array von ganzen Zahlen.\n\n- Rückgabewert: Die maximale Summe eines beliebigen zusammenhängenden Teilarrays.\n\nBeispiele:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] summiert sich zu 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ist die größte Summe im Array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] summiert sich zu 7",
      "ha": "Nemi mafi girman jimlar wani jere mai ci gaba a cikin jerin lambobi masu tsari.\n\n- Sigogi:\n- nums: Wani jeri na lambobi masu tsari.\n\n- Komawa: Mafi girman jimlar duk wani jere mai ci gaba.\n\nMisalai:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] yana da jimlar 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] shine mafi girman jimla a cikin jerin\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] yana da jimlar 7",
      "hi": "किसी पूर्णांक के सरणी में एक निरंतर उप-सरणी का अधिकतम योग खोजता है।\n\n- पैरामीटर्स:\n- nums: पूर्णांकों की एक सरणी।\n\n- रिटर्न करता है: किसी भी निरंतर उप-सरणी का अधिकतम योग।\n\nउदाहरण:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] का योग 9 होता है\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] सरणी में सबसे बड़ा योग है\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] का योग 7 होता है",
      "hu": "Megkeresi a maximális összegű összefüggő rész tömböt egy egész számokat tartalmazó tömbben.\n\n- Paraméterek:\n- nums: Egész számokat tartalmazó tömb.\n\n- Visszatér: Bármely összefüggő rész tömb maximális összege.\n\nPéldák:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] összege 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] a legnagyobb összeg a tömbben\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] összege 7"
    },
    "docstring_bertscore": {
      "sq": "0.9784966722099251",
      "hy": "0.9947527812242014",
      "bn": "0.9457927758636738",
      "bg": "0.9758898470892232",
      "zh": "0.9568380154618809",
      "fr": "0.9923217439907154",
      "de": "0.991078516435818",
      "ha": "0.9657628757425405",
      "hi": "0.9611574317278655",
      "hu": "0.9543751973674293"
    }
  },
  {
    "task_id": "Swift/34",
    "prompt": {
      "en": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "sq": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nKonverton një numër nga një bazë në një tjetër. Bazat mund të variojnë nga 2 deri në 16.\n\n- Parametrat:\n- fromBase: Baza e numrit hyrës (midis 2 dhe 16 përfshirë).\n- number: Numri në formatin string që do të konvertohet. Për baza më të mëdha se 10, \npërdor shkronjat e mëdha A deri në F.\n- toBase: Baza në të cilën numri do të konvertohet (midis 2 dhe 16 përfshirë).\n\n- Kthen: Një string që përfaqëson numrin e konvertuar në bazën e re.\n\nShembuj:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "hy": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nԹվերի փոխարկում մեկ հիմքից մյուսը: Հիմքերը կարող են լինել 2-ից 16:\n\n- Պարամետրեր:\n- fromBase: Մուտքային թվի հիմքը (2-ից 16 ներառյալ):\n- number: Փոխարկվող թիվը տողի ձևաչափով: 10-ից մեծ հիմքերի համար \nօգտագործվում են մեծատառեր A-ից F:\n- toBase: Հիմքը, որին պետք է փոխարկվի թիվը (2-ից 16 ներառյալ):\n\n- Վերադարձնում է: Տող, որը ներկայացնում է փոխարկված թիվը նոր հիմքում:\n\nՕրինակներ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "bn": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nএকটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n\n- Parameters:\n- fromBase: ইনপুট সংখ্যার ভিত্তি (2 থেকে 16 এর মধ্যে অন্তর্ভুক্ত)।\n- number: স্ট্রিং ফরম্যাটে রূপান্তর করার জন্য সংখ্যা। 10 এর চেয়ে বড় ভিত্তির জন্য, \nএটি বড় হাতের অক্ষর A থেকে F ব্যবহার করে।\n- toBase: যে ভিত্তিতে সংখ্যাটি রূপান্তরিত হবে (2 থেকে 16 এর মধ্যে অন্তর্ভুক্ত)।\n\n- Returns: নতুন ভিত্তিতে রূপান্তরিত সংখ্যার একটি স্ট্রিং উপস্থাপনা।\n\nউদাহরণ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "bg": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nПреобразува число от една бройна система в друга. Бройните системи могат да бъдат в диапазона от 2 до 16.\n\n- Параметри:\n- fromBase: Бройната система на входното число (между 2 и 16 включително).\n- number: Числото във формат на низ, което трябва да бъде преобразувано. За бройни системи по-големи от 10, \nсе използват главни букви от A до F.\n- toBase: Бройната система, в която числото трябва да бъде преобразувано (между 2 и 16 включително).\n\n- Връща: Низ, представляващ преобразуваното число в новата бройна система.\n\nПримери:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "zh": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\n将一个数字从一个进制转换为另一个进制。进制范围可以从2到16。\n\n- 参数:\n- fromBase: 输入数字的进制（介于2到16之间，包括2和16）。\n- number: 要转换的数字，以字符串格式表示。对于大于10的进制，使用大写字母A到F。\n- toBase: 要转换到的进制（介于2到16之间，包括2和16）。\n\n- 返回: 一个字符串，表示在新进制中转换后的数字。\n\n示例:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "fr": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConvertit un nombre d'une base à une autre. Les bases peuvent varier de 2 à 16.\n\n- Paramètres:\n- fromBase: La base du nombre d'entrée (entre 2 et 16 inclus).\n- number: Le nombre au format chaîne à convertir. Pour les bases supérieures à 10,\nil utilise les lettres majuscules A à F.\n- toBase: La base vers laquelle le nombre doit être converti (entre 2 et 16 inclus).\n\n- Renvoie: Une chaîne représentant le nombre converti dans la nouvelle base.\n\nExemples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "de": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nKonvertiert eine Zahl von einer Basis in eine andere. Die Basen können von 2 bis 16 reichen.\n\n- Parameter:\n- fromBase: Die Basis der Eingabezahl (zwischen 2 und 16 inklusive).\n- number: Die Zahl im String-Format, die konvertiert werden soll. Für Basen größer als 10 \nwerden Großbuchstaben A bis F verwendet.\n- toBase: Die Basis, in die die Zahl konvertiert werden soll (zwischen 2 und 16 inklusive).\n\n- Rückgabewert: Ein String, der die konvertierte Zahl in der neuen Basis darstellt.\n\nBeispiele:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "ha": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nYana canza lamba daga wata tushe zuwa wata. Tushen na iya kasancewa daga 2 zuwa 16.\n\n- Parameters:\n- fromBase: Tushen lambar shigarwa (daga 2 zuwa 16 ciki har da).\n- number: Lambar a cikin tsarin rubutu da za a canza. Don tushen da suka fi 10, \nyana amfani da manyan haruffa A zuwa F.\n- toBase: Tushen zuwa wanda za a canza lambar (daga 2 zuwa 16 ciki har da).\n\n- Returns: Wani rubutu da ke wakiltar lambar da aka canza a cikin sabon tushe.\n\nMisalai:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "hi": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nएक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। आधार 2 से 16 तक हो सकते हैं।\n\n- पैरामीटर्स:\n- fromBase: इनपुट संख्या का आधार (2 से 16 तक शामिल)।\n- number: स्ट्रिंग प्रारूप में संख्या जिसे परिवर्तित किया जाना है। 10 से अधिक के आधारों के लिए, \nयह अपरकेस अक्षर A से F का उपयोग करता है।\n- toBase: वह आधार जिसमें संख्या को परिवर्तित किया जाना है (2 से 16 तक शामिल)।\n\n- रिटर्न्स: एक स्ट्रिंग जो नए आधार में परिवर्तित संख्या का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "hu": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nÁtalakít egy számot egyik számrendszerből a másikba. Az alapok 2-től 16-ig terjedhetnek.\n\n- Paraméterek:\n- fromBase: A bemeneti szám alapja (2 és 16 között, beleértve).\n- number: A szám sztring formátumban, amelyet át kell alakítani. 10-nél nagyobb alapok esetén \nnagybetűs A-tól F-ig terjedő betűket használ.\n- toBase: Az alap, amelyre a számot át kell alakítani (2 és 16 között, beleértve).\n\n- Visszatér: Egy sztring, amely az átalakított számot képviseli az új számrendszerben.\n\nPéldák:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9893436786878593",
      "hy": "0.9668046920910685",
      "bn": "0.9788087205385309",
      "bg": "0.9330166711251288",
      "zh": "0.9667129248550304",
      "fr": "0.9912306673076907",
      "de": "0.9879959715525376",
      "ha": "0.990030741175859",
      "hi": "0.976611272633142",
      "hu": "0.9630642833858005"
    },
    "canonical_solution": "let decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}",
    "instruction": {
      "en": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Swift cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8438361985392278",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9165571646006728",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func check(_ convertNumber: (Int, String, Int) -> String) {\nassert(convertNumber(10, \"255\", 2) == \"11111111\")\nassert(convertNumber(2, \"1010\", 10) == \"10\")\nassert(convertNumber(8, \"175\", 16) == \"7D\")\nassert(convertNumber(16, \"1A\", 10) == \"26\")\nassert(convertNumber(2, \"1111\", 16) == \"F\")\nassert(convertNumber(16, \"FF\", 8) == \"377\")\nassert(convertNumber(10, \"1000\", 16) == \"3E8\")\n}\n\ncheck(convertNumber)",
    "entry_point": "convertNumber",
    "signature": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {",
    "docstring": {
      "en": "\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n",
      "sq": "Konverton një numër nga një bazë në një tjetër. Bazat mund të variojnë nga 2 në 16.\n\n- Parametrat:\n- fromBase: Baza e numrit hyrës (midis 2 dhe 16 përfshirë).\n- number: Numri në formatin string që do të konvertohet. Për baza më të mëdha se 10, \npërdor shkronjat e mëdha A deri në F.\n- toBase: Baza në të cilën numri do të konvertohet (midis 2 dhe 16 përfshirë).\n\n- Kthen: Një string që përfaqëson numrin e konvertuar në bazën e re.\n\nShembuj:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hy": "Վերածում է թիվը մեկ հիմքից մյուսը: Հիմքերը կարող են տատանվել 2-ից մինչև 16:\n\n- Պարամետրեր:\n- fromBase: Մուտքային թվի հիմքը (2-ից մինչև 16 ներառյալ):\n- number: Տվյալը տողային ֆորմատով, որը պետք է վերածվի: 10-ից մեծ հիմքերի համար \nօգտագործում է մեծատառեր A-ից F:\n- toBase: Հիմքը, որին պետք է վերածել թիվը (2-ից մինչև 16 ներառյալ):\n\n- Վերադարձնում է: Տող, որը ներկայացնում է նոր հիմքով վերածված թիվը:\n\nՕրինակներ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "bn": "একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n\n- প্যারামিটারসমূহ:\n- fromBase: ইনপুট সংখ্যার ভিত্তি (2 এবং 16 অন্তর্ভুক্ত)।\n- number: স্ট্রিং ফর্ম্যাটে রূপান্তরিত হওয়ার জন্য সংখ্যা। 10 এর বেশি ভিত্তির জন্য, এটি বড় হাতের অক্ষর A থেকে F ব্যবহার করে।\n- toBase: যে ভিত্তিতে সংখ্যাটি রূপান্তরিত হবে (2 এবং 16 অন্তর্ভুক্ত)।\n\n- রিটার্ন করে: নতুন ভিত্তিতে রূপান্তরিত সংখ্যার একটি স্ট্রিং উপস্থাপনা।\n\nউদাহরণ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "bg": "Преобразува число от една база в друга. Базите могат да варират от 2 до 16.\n\n- Параметри:\n- fromBase: Базата на входното число (между 2 и 16 включително).\n- number: Числото във формат на низ, което трябва да бъде преобразувано. За бази по-големи от 10, се използват главни букви от A до F.\n- toBase: Базата, в която числото трябва да бъде преобразувано (между 2 и 16 включително).\n\n- Връща: Низ, представляващ преобразуваното число в новата база.\n\nПримери:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "zh": "将一个数字从一个进制转换为另一个进制。进制范围可以从2到16。\n\n- 参数：\n- fromBase: 输入数字的进制（介于2到16之间，包括2和16）。\n- number: 要转换的数字，字符串格式。对于大于10的进制，使用大写字母A到F。\n- toBase: 要转换到的进制（介于2到16之间，包括2和16）。\n\n- 返回：一个字符串，表示在新进制中转换后的数字。\n\n示例：\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "fr": "Convertit un nombre d'une base à une autre. Les bases peuvent aller de 2 à 16.\n\n- Paramètres:\n- fromBase: La base du nombre d'entrée (entre 2 et 16 inclus).\n- number: Le nombre au format chaîne à convertir. Pour les bases supérieures à 10, \nil utilise les lettres majuscules de A à F.\n- toBase: La base vers laquelle le nombre doit être converti (entre 2 et 16 inclus).\n\n- Retourne: Une chaîne représentant le nombre converti dans la nouvelle base.\n\nExemples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "de": "Konvertiert eine Zahl von einer Basis in eine andere. Die Basen können von 2 bis 16 reichen.\n\n- Parameter:\n- fromBase: Die Basis der Eingabezahl (zwischen 2 und 16 inklusive).\n- number: Die Zahl im String-Format, die konvertiert werden soll. Für Basen größer als 10 werden Großbuchstaben A bis F verwendet.\n- toBase: Die Basis, in die die Zahl konvertiert werden soll (zwischen 2 und 16 inklusive).\n\n- Rückgabewert: Ein String, der die konvertierte Zahl in der neuen Basis darstellt.\n\nBeispiele:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "ha": "Yana canza lamba daga wata tushe zuwa wata. Tushen na iya zama daga 2 zuwa 16.\n\n- Sigogi:\n- fromBase: Tushen lambar shigarwa (daga 2 zuwa 16 ciki har da).\n- number: Lambar a cikin tsarin kirtani da za a canza. Don tushe mafi girma fiye da 10,\nyana amfani da manyan haruffa A zuwa F.\n- toBase: Tushen da za a canza lambar zuwa (daga 2 zuwa 16 ciki har da).\n\n- Komawa: Kirtani da ke wakiltar lambar da aka canza a cikin sabon tushe.\n\nMisalai:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hi": "एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। आधार 2 से 16 तक हो सकते हैं।\n\n- पैरामीटर्स:\n- fromBase: इनपुट संख्या का आधार (2 और 16 के बीच समावेशी)।\n- number: स्ट्रिंग प्रारूप में संख्या जिसे परिवर्तित किया जाना है। 10 से अधिक के आधारों के लिए, यह अपरकेस अक्षर A से F का उपयोग करता है।\n- toBase: वह आधार जिसमें संख्या को परिवर्तित किया जाना है (2 और 16 के बीच समावेशी)।\n\n- रिटर्न: एक स्ट्रिंग जो नए आधार में परिवर्तित संख्या का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hu": "Átalakít egy számot egyik számrendszerből a másikba. A számrendszerek 2 és 16 között lehetnek.\n\n- Paraméterek:\n- fromBase: A bemeneti szám számrendszere (2 és 16 között, beleértve).\n- number: A szám string formátumban, amelyet át kell alakítani. 10-nél nagyobb számrendszerek esetén nagybetűs A-tól F-ig terjedő betűket használ.\n- toBase: Az a számrendszer, amelybe a számot át kell alakítani (2 és 16 között, beleértve).\n\n- Visszatér: Egy string, amely az átalakított számot képviseli az új számrendszerben.\n\nPéldák:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\""
    },
    "docstring_bertscore": {
      "sq": "0.9855365301745636",
      "hy": "0.9618836244009291",
      "bn": "0.9638697295808969",
      "bg": "0.9768978962729753",
      "zh": "0.9634530030414857",
      "fr": "0.9892040415299918",
      "de": "0.9866840178858022",
      "ha": "0.9748237978342089",
      "hi": "0.9680767210512159",
      "hu": "0.9493375336436225"
    }
  },
  {
    "task_id": "Swift/35",
    "prompt": {
      "en": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "sq": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nGjen numrin e k-të më të vogël unik nga një listë e dhënë me numra të plotë. Nëse dy numra janë të njëjtë,\nato konsiderohen si një numër unik. Nëse numri i k-të më i vogël unik nuk ekziston, kthen \"NO RESULT\".\n\n- Parametrat:\n- numbers: Një varg me numra të plotë.\n- k: Rendi i numrit më të vogël unik që do të gjendet.\n\n- Kthen: Një varg që përfaqëson numrin e k-të më të vogël unik ose \"NO RESULT\" nëse nuk ekziston.\n\nShembuj:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "hy": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nԳտնում է տրված ամբողջ թվերի ցուցակից k-րդ փոքրագույն եզակի թիվը։ Եթե երկու թիվ նույնն են,\nդրանք համարվում են մեկ եզակի թիվ։ Եթե k-րդ փոքրագույն եզակի թիվը գոյություն չունի, վերադարձնում է \"NO RESULT\"։\n\n- Պարամետրեր:\n- numbers: Ամբողջ թվերի զանգված։\n- k: Փոքրագույն եզակի թիվի կարգը, որը պետք է գտնել։\n\n- Վերադարձնում է: Տողի տիպի արժեք, որը ներկայացնում է k-րդ փոքրագույն եզակի թիվը կամ \"NO RESULT\", եթե այն գոյություն չունի։\n\nՕրինակներ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "bn": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nএকটি প্রদত্ত পূর্ণসংখ্যার তালিকা থেকে kth ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে। যদি দুটি সংখ্যা একই হয়,\nতাহলে তাদেরকে একটি অনন্য সংখ্যা হিসেবে গণ্য করা হয়। যদি kth ক্ষুদ্রতম অনন্য সংখ্যা বিদ্যমান না থাকে, তাহলে \"NO RESULT\" ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- numbers: পূর্ণসংখ্যার একটি অ্যারে।\n- k: খুঁজে বের করার জন্য ক্ষুদ্রতম অনন্য সংখ্যার ক্রম।\n\n- ফেরত দেয়: একটি স্ট্রিং যা kth ক্ষুদ্রতম অনন্য সংখ্যা বা যদি এটি বিদ্যমান না থাকে তবে \"NO RESULT\" উপস্থাপন করে।\n\nউদাহরণ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "bg": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nНамира k-тото най-малко уникално число от даден списък с цели числа. Ако две числа са еднакви,\nте се считат за едно уникално число. Ако k-тото най-малко уникално число не съществува, връща \"NO RESULT\".\n\n- Параметри:\n- numbers: Масив от цели числа.\n- k: Поредността на най-малкото уникално число, което да се намери.\n\n- Връща: Низ, представляващ k-тото най-малко уникално число или \"NO RESULT\", ако не съществува.\n\nПримери:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "zh": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\n找到给定整数列表中的第k个最小的唯一数字。如果两个数字相同，它们被视为一个唯一数字。如果第k个最小的唯一数字不存在，则返回\"NO RESULT\"。\n\n- 参数:\n- numbers: 整数数组。\n- k: 要查找的第k个最小的唯一数字的顺序。\n\n- 返回: 一个字符串，表示第k个最小的唯一数字，如果不存在则返回\"NO RESULT\"。\n\n示例:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "fr": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nTrouve le k-ième plus petit nombre unique dans une liste donnée d'entiers. Si deux nombres sont identiques,\nils sont considérés comme un seul nombre unique. Si le k-ième plus petit nombre unique n'existe pas, retourne \"NO RESULT\".\n\n- Paramètres :\n- numbers: Un tableau d'entiers.\n- k: L'ordre du plus petit nombre unique à trouver.\n\n- Retourne : Une chaîne représentant le k-ième plus petit nombre unique ou \"NO RESULT\" s'il n'existe pas.\n\nExemples :\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "de": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFindet die k-kleinste eindeutige Zahl aus einer gegebenen Liste von ganzen Zahlen. Wenn zwei Zahlen gleich sind,\nwerden sie als eine eindeutige Zahl betrachtet. Wenn die k-kleinste eindeutige Zahl nicht existiert, wird \"NO RESULT\" zurückgegeben.\n\n- Parameter:\n- numbers: Ein Array von ganzen Zahlen.\n- k: Die Reihenfolge der zu findenden kleinsten eindeutigen Zahl.\n\n- Rückgabewert: Ein String, der die k-kleinste eindeutige Zahl darstellt oder \"NO RESULT\", wenn sie nicht existiert.\n\nBeispiele:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "ha": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nNemo lamba ta k mafi ƙanƙanta daga jerin lambobi da aka bayar. Idan lambobi biyu iri ɗaya ne,\nana ɗaukar su a matsayin lamba guda. Idan lamba ta k mafi ƙanƙanta ba ta wanzu ba, yana mayar da \"NO RESULT\".\n\n- Parameters:\n- numbers: Jeri na lambobi.\n- k: Tsari na lamba mafi ƙanƙanta da za a nema.\n\n- Returns: Wani String da ke wakiltar lamba ta k mafi ƙanƙanta ko \"NO RESULT\" idan ba ta wanzu ba.\n\nMisalai:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "hi": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nदिए गए पूर्णांकों की सूची से kवां सबसे छोटा अद्वितीय संख्या ढूंढता है। यदि दो संख्याएँ समान हैं,\nतो उन्हें एक अद्वितीय संख्या के रूप में माना जाता है। यदि kवां सबसे छोटा अद्वितीय संख्या मौजूद नहीं है, तो \"NO RESULT\" लौटाता है।\n\n- Parameters:\n- numbers: पूर्णांकों की एक सूची।\n- k: सबसे छोटी अद्वितीय संख्या का क्रम जिसे ढूंढना है।\n\n- Returns: एक स्ट्रिंग जो kवां सबसे छोटा अद्वितीय संख्या या \"NO RESULT\" को दर्शाता है यदि यह मौजूद नहीं है।\n\nउदाहरण:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "hu": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nMegkeresi a megadott egész számok listájából a k-adik legkisebb egyedi számot. Ha két szám megegyezik,\nazokat egy egyedi számnak tekintjük. Ha a k-adik legkisebb egyedi szám nem létezik, \"NO RESULT\"-ot ad vissza.\n\n- Paraméterek:\n- numbers: Egész számok tömbje.\n- k: A legkisebb egyedi szám sorszáma, amelyet meg kell találni.\n\n- Visszatér: Egy String, amely a k-adik legkisebb egyedi számot vagy \"NO RESULT\"-ot képviseli, ha nem létezik.\n\nPéldák:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9760920528171168",
      "hy": "0.9759732718492579",
      "bn": "0.9942999039554418",
      "bg": "0.983767925261829",
      "zh": "0.9678484947434068",
      "fr": "0.9749884624200869",
      "de": "0.967427994226756",
      "ha": "0.9659624992754805",
      "hi": "0.9765298341769176",
      "hu": "0.9679323167642035"
    },
    "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}",
    "instruction": {
      "en": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nনিম্নলিখিত Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8754724565874165",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9105150270399726",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()",
    "entry_point": "kthUniqueSmallestNumber",
    "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {",
    "docstring": {
      "en": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n",
      "sq": "Gjen numrin e kth më të vogël unik nga një listë e dhënë me numra të plotë. Nëse dy numra janë të njëjtë, ata konsiderohen si një numër unik. Nëse numri i kth më i vogël unik nuk ekziston, kthen \"NO RESULT\".\n\n- Parametrat:\n- numbers: Një varg me numra të plotë.\n- k: Renditja e numrit më të vogël unik për të gjetur.\n\n- Kthen: Një varg që përfaqëson numrin e kth më të vogël unik ose \"NO RESULT\" nëse nuk ekziston.\n\nShembuj:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hy": "Գտնում է տրված ամբողջ թվերի ցուցակից k-րդ ամենափոքր եզակի թիվը: Եթե երկու թիվ նույնն են, դրանք համարվում են որպես մեկ եզակի թիվ: Եթե k-րդ ամենափոքր եզակի թիվը գոյություն չունի, վերադարձնում է \"NO RESULT\":\n\n- Պարամետրեր:\n- numbers: Ամբողջ թվերի զանգված:\n- k: Ամենափոքր եզակի թիվը գտնելու կարգը:\n\n- Վերադարձնում է: Տող, որը ներկայացնում է k-րդ ամենափոքր եզակի թիվը կամ \"NO RESULT\", եթե այն գոյություն չունի:\n\nՕրինակներ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "bn": "একটি প্রদত্ত পূর্ণসংখ্যার তালিকা থেকে kth ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে। যদি দুটি সংখ্যা একই হয়, তবে তারা একটি অনন্য সংখ্যা হিসেবে বিবেচিত হয়। যদি kth ক্ষুদ্রতম অনন্য সংখ্যা বিদ্যমান না থাকে, তবে \"NO RESULT\" ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- numbers: পূর্ণসংখ্যার একটি অ্যারে।\n- k: ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করার ক্রম।\n\n- রিটার্নস: একটি স্ট্রিং যা kth ক্ষুদ্রতম অনন্য সংখ্যা বা \"NO RESULT\" প্রতিনিধিত্ব করে যদি এটি বিদ্যমান না থাকে।\n\nউদাহরণসমূহ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "bg": "Намира k-тото най-малко уникално число от даден списък с цели числа. Ако две числа са еднакви, те се считат за едно уникално число. Ако k-тото най-малко уникално число не съществува, връща \"NO RESULT\".\n\n- Параметри:\n- numbers: Масив от цели числа.\n- k: Поредността на най-малкото уникално число, което да се намери.\n\n- Връща: Низ, представляващ k-тото най-малко уникално число или \"NO RESULT\", ако не съществува.\n\nПримери:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "zh": "找到给定整数列表中的第k个最小唯一数字。如果两个数字相同，它们被视为一个唯一数字。如果第k个最小唯一数字不存在，则返回“NO RESULT”。\n\n- 参数：\n- numbers: 整数数组。\n- k: 要查找的第k个最小唯一数字的顺序。\n\n- 返回：一个字符串，表示第k个最小唯一数字或如果不存在则为“NO RESULT”。\n\n示例：\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "fr": "Trouve le k-ième plus petit nombre unique à partir d'une liste donnée d'entiers. Si deux nombres sont identiques, ils sont considérés comme un seul nombre unique. Si le k-ième plus petit nombre unique n'existe pas, retourne \"AUCUN RÉSULTAT\".\n\n- Paramètres :\n- numbers: Un tableau d'entiers.\n- k: L'ordre du plus petit nombre unique à trouver.\n\n- Retourne : Une chaîne de caractères représentant le k-ième plus petit nombre unique ou \"AUCUN RÉSULTAT\" s'il n'existe pas.\n\nExemples :\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"AUCUN RÉSULTAT\"",
      "de": "Findet die k-kleinste eindeutige Zahl aus einer gegebenen Liste von ganzen Zahlen. Wenn zwei Zahlen gleich sind, werden sie als eine eindeutige Zahl betrachtet. Wenn die k-kleinste eindeutige Zahl nicht existiert, wird \"NO RESULT\" zurückgegeben.\n\n- Parameter:\n- numbers: Ein Array von ganzen Zahlen.\n- k: Die Ordnung der kleinsten eindeutigen Zahl, die gefunden werden soll.\n\n- Rückgabe: Ein String, der die k-kleinste eindeutige Zahl darstellt oder \"NO RESULT\", wenn sie nicht existiert.\n\nBeispiele:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "ha": "Nemo na k na ƙananan lamba ta musamman daga jerin lambobi na integers da aka bayar. Idan lambobi biyu suna daidai, ana ɗaukar su a matsayin lamba ɗaya ta musamman. Idan k na ƙananan lamba ta musamman ba ta wanzu ba, yana mayar da \"NO RESULT\".\n\n- Sigogi:\n- numbers: Wani tsararren lambobi na integers.\n- k: Umarni na ƙananan lamba ta musamman da za a nema.\n\n- Mayarwa: Wani Kirtani da ke wakiltar k na ƙananan lamba ta musamman ko \"NO RESULT\" idan ba ta wanzu ba.\n\nMisalai:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hi": "दिए गए पूर्णांकों की सूची से kth सबसे छोटा अद्वितीय संख्या खोजता है। यदि दो संख्याएँ समान हैं, तो उन्हें एक अद्वितीय संख्या के रूप में माना जाता है। यदि kth सबसे छोटी अद्वितीय संख्या मौजूद नहीं है, तो \"NO RESULT\" लौटाता है।\n\n- पैरामीटर्स:\n- numbers: पूर्णांकों की एक श्रृंखला।\n- k: खोजने के लिए सबसे छोटी अद्वितीय संख्या का क्रम।\n\n- रिटर्न्स: एक स्ट्रिंग जो kth सबसे छोटी अद्वितीय संख्या का प्रतिनिधित्व करती है या \"NO RESULT\" यदि यह मौजूद नहीं है।\n\nउदाहरण:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hu": "Megtalálja a k-adik legkisebb egyedi számot egy adott egész számok listájából. Ha két szám azonos, akkor egy egyedi számnak tekintendők. Ha a k-adik legkisebb egyedi szám nem létezik, \"NO RESULT\" értéket ad vissza.\n\n- Paraméterek:\n- numbers: Egész számok tömbje.\n- k: A megtalálandó legkisebb egyedi szám sorrendje.\n\n- Visszatér: Egy String, amely a k-adik legkisebb egyedi számot vagy \"NO RESULT\"-ot képviseli, ha nem létezik.\n\nPéldák:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\""
    },
    "docstring_bertscore": {
      "sq": "0.9927845527785266",
      "hy": "0.9754764972662896",
      "bn": "0.9851829680963214",
      "bg": "0.9829438078109152",
      "zh": "0.9646543195859848",
      "fr": "0.9783689528749197",
      "de": "0.9679541661061174",
      "ha": "0.9730957135192054",
      "hi": "0.9930276763649134",
      "hu": "0.9747820854541916"
    }
  },
  {
    "task_id": "Swift/36",
    "prompt": {
      "en": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "sq": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nGjen distancën më të shkurtër midis çdo dy pikave në një grup pikash të dhëna në një plan 2D.\n\n- Parametrat:\n- points: Një varg tuplesh, ku çdo tuple përfaqëson koordinatat x dhe y të një pike.\n\n- Kthen: Distanca më e shkurtër midis çdo dy pikave, e rrumbullakosur në katër vende dhjetore.\n\nShembull Përdorimi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "hy": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nԳտնում է ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև տրված կետերի հավաքածուում 2D հարթության վրա:\n\n- Պարամետրեր:\n- points: Թյուպլերի զանգված, որտեղ յուրաքանչյուր թյուպլ ներկայացնում է կետի x և y կոորդինատները:\n\n- Վերադարձնում է: Ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև, կլորացված մինչև չորս տասնորդական նիշ:\n\nՕրինակ օգտագործում:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "bn": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nদ্বিমাত্রিক সমতলে প্রদত্ত পয়েন্টগুলির মধ্যে যেকোন দুটি পয়েন্টের মধ্যে সবচেয়ে ছোট দূরত্ব খুঁজে বের করে।\n\n- প্যারামিটার:\n- points: একটি টাপল সমূহের অ্যারে, যেখানে প্রতিটি টাপল একটি পয়েন্টের x এবং y কোঅর্ডিনেট উপস্থাপন করে।\n\n- রিটার্নস: যেকোন দুটি পয়েন্টের মধ্যে সবচেয়ে ছোট দূরত্ব, চার দশমিক স্থানে রাউন্ড করা।\n\nউদাহরণ ব্যবহার:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "bg": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nНамира най-късото разстояние между две точки в даден набор от точки в 2D равнина.\n\n- Параметри:\n- points: Масив от кортежи, където всеки кортеж представлява x и y координатите на точка.\n\n- Връща: Най-късото разстояние между две точки, закръглено до четири десетични знака.\n\nПример за използване:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "zh": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\n在给定的二维平面点集中，找到任意两点之间的最短距离。\n\n- 参数:\n- points: 一个元组数组，其中每个元组表示一个点的 x 和 y 坐标。\n\n- 返回值: 任意两点之间的最短距离，四舍五入到小数点后四位。\n\n示例用法:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "fr": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nTrouve la distance la plus courte entre deux points quelconques dans un ensemble donné de points dans un plan 2D.\n\n- Paramètres :\n- points : Un tableau de tuples, où chaque tuple représente les coordonnées x et y d'un point.\n\n- Retourne : La distance la plus courte entre deux points, arrondie à quatre décimales.\n\nExemple d'utilisation :\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "de": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFindet die kürzeste Entfernung zwischen zwei beliebigen Punkten in einer gegebenen Menge von Punkten in einer 2D-Ebene.\n\n- Parameter:\n- points: Ein Array von Tupeln, wobei jedes Tupel die x- und y-Koordinaten eines Punktes darstellt.\n\n- Rückgabewert: Die kürzeste Entfernung zwischen zwei beliebigen Punkten, gerundet auf vier Dezimalstellen.\n\nBeispielverwendung:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "ha": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nNemi mafi kankantar nesa tsakanin kowanne maki biyu a cikin wani saitin maki a cikin faifan 2D.\n\n- Parameters:\n- points: Jerin tuples, inda kowanne tuple ke wakiltar x da y daidaitattun wani maki.\n\n- Returns: Mafi kankantar nesa tsakanin kowanne maki biyu, an zagaye zuwa wurare hudu na goma.\n\nMisalin Amfani:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "hi": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nदिए गए बिंदुओं के सेट में किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी खोजता है।\n\n- पैरामीटर्स:\n- points: ट्यूपल्स का एक ऐरे, जहाँ प्रत्येक ट्यूपल एक बिंदु के x और y निर्देशांक का प्रतिनिधित्व करता है।\n\n- रिटर्न्स: किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी, चार दशमलव स्थानों तक राउंड की गई।\n\nउदाहरण उपयोग:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "hu": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nMegtalálja a legrövidebb távolságot bármely két pont között egy adott pontkészletben egy 2D síkon.\n\n- Paraméterek:\n- points: Egy tömb, amelyben minden elem egy-egy tuple, amely a pont x és y koordinátáit reprezentálja.\n\n- Visszatér: A legrövidebb távolság bármely két pont között, négy tizedesjegyre kerekítve.\n\nPélda használat:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9939493213329152",
      "bn": "0.9828073487391442",
      "bg": "0.9880738346619032",
      "zh": "0.9919195174691197",
      "fr": "0.9939356158366238",
      "de": "0.9872229021095498",
      "ha": "0.9846128989027514",
      "hi": "0.973024802473176",
      "hu": "0.9833349110311729"
    },
    "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}",
    "instruction": {
      "en": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки не повече от 500 символа.",
      "zh": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nBayar da takaitaccen bayanin yare na halitta (docstring) na lambar Swift cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8733351936874811",
      "bg": "0.9346778170017236",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)",
    "entry_point": "findShortestDistanceAmongPoints",
    "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {",
    "docstring": {
      "en": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n",
      "sq": "Gjen distancën më të shkurtër midis çdo dy pikave në një grup të dhënë pikash në një plan 2D.\n\n- Parametra:\n- points: Një varg treshesh, ku çdo treshe përfaqëson koordinatat x dhe y të një pike.\n\n- Kthen: Distanca më e shkurtër midis çdo dy pikave, e rrumbullakosur në katër shifra dhjetore.\n\nShembull Përdorimi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hy": "Գտնում է ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև տրված կետերի հավաքածուում 2D հարթության վրա։\n\n- Պարամետրեր:\n- points: Թվերի զանգված, որտեղ յուրաքանչյուր տուփ ներկայացնում է կետի x և y կոորդինատները։\n\n- Վերադարձնում է: Ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև, կլորացված մինչև չորս տասնորդական կետ։\n\nՕրինակ օգտագործում:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "bn": "2D প্লেনে প্রদত্ত পয়েন্টগুলির সেটে যেকোনো দুটি পয়েন্টের মধ্যে সবচেয়ে ছোট দূরত্ব খুঁজে বের করে।\n\n- প্যারামিটার:\n- points: টুপলের একটি অ্যারে, যেখানে প্রতিটি টুপল একটি পয়েন্টের x এবং y কোঅর্ডিনেট উপস্থাপন করে।\n\n- রিটার্নস: যেকোনো দুটি পয়েন্টের মধ্যে সবচেয়ে ছোট দূরত্ব, চার দশমিক স্থান পর্যন্ত রাউন্ড করা।\n\nউদাহরণ ব্যবহার:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "bg": "Намира най-краткото разстояние между две точки в даден набор от точки в 2D равнина.\n\n- Параметри:\n- points: Масив от кортежи, където всеки кортеж представлява x и y координатите на точка.\n\n- Връща: Най-краткото разстояние между две точки, закръглено до четири знака след десетичната запетая.\n\nПример за използване:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "zh": "在给定的二维平面点集中，找到任意两点之间的最短距离。\n\n- 参数:\n- points: 一个元组数组，其中每个元组表示一个点的 x 和 y 坐标。\n\n- 返回值: 任意两点之间的最短距离，四舍五入到小数点后四位。\n\n示例用法:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "fr": "Trouve la distance la plus courte entre deux points quelconques dans un ensemble donné de points dans un plan 2D.\n\n- Paramètres :\n- points : Un tableau de tuples, où chaque tuple représente les coordonnées x et y d'un point.\n\n- Retourne : La distance la plus courte entre deux points quelconques, arrondie à quatre décimales.\n\nExemple d'utilisation :\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "de": "Findet die kürzeste Entfernung zwischen zwei beliebigen Punkten in einer gegebenen Menge von Punkten in einer 2D-Ebene.\n\n- Parameter:\n- points: Ein Array von Tupeln, wobei jedes Tupel die x- und y-Koordinaten eines Punktes darstellt.\n\n- Rückgabewert: Die kürzeste Entfernung zwischen zwei beliebigen Punkten, gerundet auf vier Dezimalstellen.\n\nBeispielverwendung:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "ha": "Nemo tazarar mafi guntu tsakanin kowanne maki biyu a cikin saitin maki a cikin faifan 2D.\n\n- Sigogi:\n- points: Jerin tuples, inda kowanne tuple ke wakiltar daidaitawar x da y na wata maki.\n\n- Komawa: Tazarar mafi guntu tsakanin kowanne maki biyu, an zagaye zuwa wurare hudu na goma.\n\nMisalin Amfani:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hi": "दिए गए बिंदुओं के सेट में किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी खोजता है।\n\n- पैरामीटर्स:\n- points: ट्यूपल्स की एक array, जहाँ प्रत्येक ट्यूपल एक बिंदु के x और y निर्देशांक का प्रतिनिधित्व करता है।\n\n- रिटर्न्स: किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी, चार दशमलव स्थानों तक गोल की गई।\n\nउदाहरण उपयोग:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hu": "Megtalálja a legrövidebb távolságot bármely két pont között egy adott pontkészletben egy 2D síkon.\n\n- Paraméterek:\n- points: Egy tömb, amely tuple-öket tartalmaz, ahol minden tuple egy pont x és y koordinátáit jelenti.\n\n- Visszatérési érték: A legrövidebb távolság bármely két pont között, négy tizedesjegyre kerekítve.\n\nPélda használat:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142"
    },
    "docstring_bertscore": {
      "sq": "0.9909905231770195",
      "hy": "0.9843999671342819",
      "bn": "0.9760509363282425",
      "bg": "0.988772417712003",
      "zh": "0.9753769834453911",
      "fr": "0.9873242036038776",
      "de": "0.9933860055723003",
      "ha": "0.9812709427418393",
      "hi": "0.9697140312820864",
      "hu": "0.9897333914954497"
    }
  },
  {
    "task_id": "Swift/37",
    "prompt": {
      "en": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "sq": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nNumëron numrin e mënyrave për të zgjedhur pjata nga një menu në mënyrë që kostoja totale\ntë përputhet saktësisht me një buxhet të dhënë. Çdo pjatë mund të zgjidhet vetëm një herë.\n\n- Parametrat:\n- dishes: Një varg i integerëve ku çdo integer përfaqëson koston e një pjate.\n- budget: Një integer që përfaqëson buxhetin total për vaktin.\n- Kthen: Numri total i kombinimeve unike të pjatave që saktësisht arrijnë shumën e buxhetit.\n\n## Shembull:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "hy": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nՀաշվում է այն եղանակների քանակը, որոնցով կարելի է ընտրել ուտեստներ մենյուից այնպես, որ ընդհանուր արժեքը\nհամընկնի տրված բյուջեի հետ։ Ամեն ուտեստ կարող է ընտրվել միայն մեկ անգամ։\n\n- Պարամետրեր:\n- dishes: Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է ուտեստի արժեքը։\n- budget: Ամբողջ թիվ, որը ներկայացնում է ճաշի ընդհանուր բյուջեն։\n- Վերադարձնում է: Ունիկալ ուտեստների կոմբինացիաների ընդհանուր քանակը, որոնք ճշգրիտ գումարվում են բյուջեին։\n\n## Օրինակ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "bn": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nখাবারের মেনু থেকে এমনভাবে খাবার বাছাই করার উপায়গুলির সংখ্যা গণনা করে যাতে মোট খরচ\nএকটি নির্দিষ্ট বাজেটের সাথে সঠিকভাবে মেলে। প্রতিটি খাবার শুধুমাত্র একবারই নির্বাচিত হতে পারে।\n\n- Parameters:\n- dishes: পূর্ণসংখ্যার একটি অ্যারে যেখানে প্রতিটি পূর্ণসংখ্যা একটি খাবারের খরচ নির্দেশ করে।\n- budget: একটি পূর্ণসংখ্যা যা খাবারের জন্য মোট বাজেট নির্দেশ করে।\n- Returns: খাবারের অনন্য সমন্বয়ের মোট সংখ্যা যা সঠিকভাবে বাজেটের সমান হয়।\n\n## উদাহরণ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "bg": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nБрои броя начини за избор на ястия от меню, така че общата цена\nда съвпада точно с даден бюджет. Всяко ястие може да бъде избрано само веднъж.\n\n- Параметри:\n- dishes: Масив от цели числа, където всяко число представлява цената на ястие.\n- budget: Цяло число, представляващо общия бюджет за храната.\n- Връща: Общият брой уникални комбинации от ястия, които точно съвпадат с бюджета.\n\n## Пример:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "zh": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\n计算从菜单中选择菜肴的方式数量，使得总成本正好与给定预算匹配。每道菜只能选择一次。\n\n- 参数:\n- dishes: 一个整数数组，其中每个整数表示一道菜的成本。\n- budget: 一个整数，表示餐点的总预算。\n- 返回: 正好总和为预算的菜肴的唯一组合总数。\n\n## 示例:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "fr": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCompte le nombre de façons de choisir des plats dans un menu de sorte que le coût total\ncorresponde exactement à un budget donné. Chaque plat ne peut être sélectionné qu'une seule fois.\n\n- Paramètres:\n- dishes: Un tableau d'entiers où chaque entier représente le coût d'un plat.\n- budget: Un entier représentant le budget total pour le repas.\n- Retourne: Le nombre total de combinaisons uniques de plats qui totalisent exactement le budget.\n\n## Exemple:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "de": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nZählt die Anzahl der Möglichkeiten, Gerichte aus einem Menü auszuwählen, sodass die Gesamtkosten\ngenau einem gegebenen Budget entsprechen. Jedes Gericht kann nur einmal ausgewählt werden.\n\n- Parameter:\n- dishes: Ein Array von ganzen Zahlen, wobei jede Zahl die Kosten eines Gerichts darstellt.\n- budget: Eine ganze Zahl, die das Gesamtbudget für das Essen darstellt.\n- Rückgabewert: Die Gesamtanzahl der einzigartigen Kombinationen von Gerichten, die genau dem Budget entsprechen.\n\n## Beispiel:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "ha": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nYana ƙididdige yawan hanyoyin zaɓar abinci daga menu ta yadda jimillar kuɗin\ndaidai yake da kasafin kuɗi da aka bayar. Ana iya zaɓar kowanne abinci sau ɗaya kawai.\n\n- Sigogi:\n- dishes: Jeren lambobi inda kowanne lamba ke wakiltar kuɗin abinci.\n- budget: Lamba mai wakiltar jimillar kasafin kuɗi don abincin.\n- Returns: Jimillar adadin zaɓuɓɓukan abinci na musamman waɗanda suka daidaita da kasafin kuɗi.\n\n## Misali:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "hi": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nयह गणना करता है कि मेनू से व्यंजन चुनने के कितने तरीके हैं ताकि कुल लागत\nएक दिए गए बजट से बिल्कुल मेल खाती हो। प्रत्येक व्यंजन को केवल एक बार ही चुना जा सकता है।\n\n- पैरामीटर्स:\n- dishes: पूर्णांकों की एक array जहां प्रत्येक पूर्णांक एक व्यंजन की लागत का प्रतिनिधित्व करता है।\n- budget: एक पूर्णांक जो भोजन के लिए कुल बजट का प्रतिनिधित्व करता है।\n- Returns: व्यंजनों के अद्वितीय संयोजनों की कुल संख्या जो बजट के बराबर होती है।\n\n## उदाहरण:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "hu": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nMegszámolja, hogy hányféleképpen lehet választani az étlapról úgy, hogy a teljes költség\npontosan megegyezzen egy adott költségvetéssel. Minden ételt csak egyszer lehet kiválasztani.\n\n- Paraméterek:\n- dishes: Egész számok tömbje, ahol minden egész szám egy étel költségét jelenti.\n- budget: Egy egész szám, amely az étkezés teljes költségvetését jelenti.\n- Visszatér: Az ételek azon egyedi kombinációinak teljes száma, amelyek pontosan a költségvetésre jönnek ki.\n\n## Példa:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9887175957268373",
      "hy": "0.9752772709941117",
      "bn": "0.9847012894223118",
      "bg": "0.9729272749560879",
      "zh": "0.9820960533446583",
      "fr": "0.9919193188387386",
      "de": "0.9796397900527809",
      "ha": "0.9375162451467122",
      "hi": "0.9772117322750103",
      "hu": "0.9841796860417142"
    },
    "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}",
    "instruction": {
      "en": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրումը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nПредоставете кратко описание на кода на Swift на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nBa da takaitaccen bayanin yare na zahiri (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9229242614647462",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.930809291700688"
    },
    "level": "",
    "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)",
    "entry_point": "countMealCombinations",
    "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n",
      "sq": "Numëron numrin e mënyrave për të zgjedhur pjata nga një menu në mënyrë që kostoja totale të përputhet saktësisht me një buxhet të dhënë. Çdo pjatë mund të zgjidhet vetëm një herë.\n\n- Parametra:\n- dishes: Një varg me numra të plotë ku secili numër përfaqëson koston e një pjate.\n- budget: Një numër i plotë që përfaqëson buxhetin total për vaktin.\n- Kthen: Numri total i kombinimeve unike të pjatave që saktësisht arrijnë buxhetin.\n\n## Shembull:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hy": "Հաշվում է ուտեստներ ընտրելու եղանակների քանակը մենյուից այնպես, որ ընդհանուր արժեքը\nճշգրիտ համապատասխանի տրված բյուջեին: Յուրաքանչյուր ուտեստ կարող է ընտրվել միայն մեկ անգամ:\n\n- Պարամետրեր:\n- dishes: Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է ուտեստի արժեքը:\n- budget: Ամբողջ թիվ, որը ներկայացնում է ճաշի ընդհանուր բյուջեն:\n- Վերադարձնում է: Ուտեստների եզակի համակցությունների ընդհանուր քանակը, որոնք ճշգրիտ գումարվում են բյուջեին:\n\n## Օրինակ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "bn": "খাবারের মেনু থেকে কতভাবে খাবার বাছাই করা যায় তা গণনা করে যাতে মোট খরচ একটি নির্দিষ্ট বাজেটের সাথে সঠিকভাবে মেলে। প্রতিটি খাবার শুধুমাত্র একবারই নির্বাচিত হতে পারে।\n\n- প্যারামিটারসমূহ:\n- dishes: পূর্ণসংখ্যার একটি অ্যারে যেখানে প্রতিটি পূর্ণসংখ্যা একটি খাবারের খরচ উপস্থাপন করে।\n- budget: একটি পূর্ণসংখ্যা যা খাবারের মোট বাজেট উপস্থাপন করে।\n- রিটার্নস: খাবারের মোট ইউনিক কম্বিনেশনের সংখ্যা যা ঠিক বাজেটের সমান হয়।\n\n## উদাহরণ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "bg": "Брои броя начини за избор на ястия от меню, така че общата стойност да съвпада точно с даден бюджет. Всяко ястие може да бъде избрано само веднъж.\n\n- Параметри:\n- dishes: Масив от цели числа, където всяко число представлява цената на ястие.\n- budget: Цяло число, представляващо общия бюджет за храненето.\n- Връща: Общият брой уникални комбинации от ястия, които точно съвпадат с бюджета.\n\n## Пример:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "zh": "计算从菜单中选择菜肴的方式数量，使得总成本正好与给定预算匹配。每道菜只能选择一次。\n\n- 参数：\n- dishes: 一个整数数组，其中每个整数表示一道菜的成本。\n- budget: 一个整数，表示这顿饭的总预算。\n- 返回：正好总和为预算的独特菜肴组合的总数。\n\n## 示例：\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "fr": "Compte le nombre de façons de choisir des plats dans un menu de sorte que le coût total corresponde exactement à un budget donné. Chaque plat ne peut être sélectionné qu'une seule fois.\n\n- Paramètres:\n- dishes: Un tableau d'entiers où chaque entier représente le coût d'un plat.\n- budget: Un entier représentant le budget total pour le repas.\n- Retourne: Le nombre total de combinaisons uniques de plats qui totalisent exactement le budget.\n\n## Exemple:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "de": "Zählt die Anzahl der Möglichkeiten, Gerichte aus einem Menü auszuwählen, sodass die Gesamtkosten genau einem gegebenen Budget entsprechen. Jedes Gericht kann nur einmal ausgewählt werden.\n\n- Parameter:\n- dishes: Ein Array von ganzen Zahlen, wobei jede Zahl die Kosten eines Gerichts darstellt.\n- budget: Eine ganze Zahl, die das Gesamtbudget für die Mahlzeit darstellt.\n- Rückgabewert: Die Gesamtanzahl der eindeutigen Kombinationen von Gerichten, die genau dem Budget entsprechen.\n\n## Beispiel:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "ha": "Yana ƙididdige adadin hanyoyin zaɓar abinci daga menu ta yadda jimlar kuɗin\ndaidai yake da kasafin kuɗi da aka bayar. Ana iya zaɓar kowanne abinci sau ɗaya kawai.\n\n- Sigogi:\n- dishes: Jeri na lambobi inda kowanne lamba ke wakiltar kuɗin abinci.\n- budget: Lamba mai wakiltar jimlar kasafin kuɗi don abincin.\n- Abin da ake dawowa da shi: Jimlar adadin haɗuwa na musamman na abinci waɗanda ke daidai da kasafin kuɗi.\n\n## Misali:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hi": "दिए गए बजट के साथ पूरी तरह मेल खाने वाली लागत के साथ मेनू से व्यंजन चुनने के तरीकों की संख्या गिनता है। प्रत्येक व्यंजन को केवल एक बार चुना जा सकता है।\n\n- पैरामीटर्स:\n- dishes: पूर्णांकों की एक श्रृंखला जहां प्रत्येक पूर्णांक एक व्यंजन की लागत का प्रतिनिधित्व करता है।\n- budget: भोजन के लिए कुल बजट का प्रतिनिधित्व करने वाला एक पूर्णांक।\n- रिटर्न्स: व्यंजनों के अद्वितीय संयोजनों की कुल संख्या जो पूरी तरह से बजट के बराबर होती है।\n\n## उदाहरण:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hu": "Számolja meg, hányféleképpen lehet ételeket választani egy étlapról úgy, hogy a teljes költség pontosan megegyezzen egy adott költségvetéssel. Minden ételt csak egyszer lehet kiválasztani.\n\n- Paraméterek:\n- dishes: Egész számokat tartalmazó tömb, ahol minden egész szám egy étel költségét jelenti.\n- budget: Egy egész szám, amely az étkezés teljes költségvetését jelöli.\n- Visszatérési érték: Az ételek azon egyedi kombinációinak teljes száma, amelyek pontosan a költségvetés összegét adják.\n\n## Példa:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.983044910674862",
      "hy": "0.96878960548875",
      "bn": "0.9646545182163658",
      "bg": "0.9747632155679933",
      "zh": "0.967337220142623",
      "fr": "0.9807622503360091",
      "de": "0.9777116849440752",
      "ha": "0.9287552549304063",
      "hi": "0.9532473740639132",
      "hu": "0.9864913464161983"
    }
  },
  {
    "task_id": "Swift/38",
    "prompt": {
      "en": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "sq": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nLlogarit kohën më të vonë kur yyy mund të niset për në shkollë pa u vonuar. \nShkolla është 'distance' metra larg, dhe yyy ecën me një shpejtësi prej 'speed' metra për minutë. \nPër më tepër, yyy kalon 10 minuta shtesë për ndarjen e mbeturinave gjatë rrugës.\n\nShkolla kërkon mbërritjen deri në orën 08:00 të mëngjesit. Kjo funksion kthen kohën më të vonë të nisjes në formatin HH:MM.\n\nShembuj:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "hy": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nՀաշվում է ամենավերջին ժամանակը, երբ yyy կարող է դուրս գալ դպրոց առանց ուշանալու։ \nԴպրոցը գտնվում է 'distance' մետր հեռավորության վրա, և yyy քայլում է 'speed' մետր րոպեում արագությամբ։ \nԲացի այդ, yyy ծախսում է լրացուցիչ 10 րոպե աղբի տեսակավորման համար ճանապարհին։\n\nԴպրոցը պահանջում է ժամանել մինչև 08:00։ Այս ֆունկցիան վերադարձնում է ամենավերջին դուրս գալու ժամը HH:MM ֆորմատով։\n\nՕրինակներ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "bn": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nস্কুলে দেরি না করে পৌঁছানোর জন্য yyy সর্বশেষ কখন রওনা হতে পারে তা গণনা করে। \nস্কুলটি 'distance' মিটার দূরে অবস্থিত, এবং yyy 'speed' মিটার প্রতি মিনিট গতিতে হাঁটে। \nঅতিরিক্তভাবে, yyy পথে আবর্জনা বাছাই করার জন্য অতিরিক্ত ১০ মিনিট ব্যয় করে।\n\nস্কুলে পৌঁছানোর সময় ০৮:০০ AM এর মধ্যে হতে হবে। এই ফাংশনটি সর্বশেষ রওনা হওয়ার সময় HH:MM ফরম্যাটে প্রদান করে।\n\nউদাহরণ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "bg": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nИзчислява най-късното време, в което yyy може да тръгне за училище, без да закъснее. \nУчилището е на 'distance' метра разстояние, а yyy ходи със скорост 'speed' метра в минута. \nОсвен това, yyy прекарва допълнителни 10 минути за сортиране на отпадъци по пътя.\n\nУчилището изисква пристигане до 08:00 ч. Тази функция връща най-късното време на тръгване във формат HH:MM.\n\nПримери:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "zh": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\n计算yyy可以不迟到去上学的最晚出发时间。\n学校距离为'distance'米，yyy以'speed'米每分钟的速度行走。\n另外，yyy在路上花费额外的10分钟进行垃圾分类。\n\n学校要求在上午08:00之前到达。此函数返回最晚出发时间，格式为HH:MM。\n\n例子:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "fr": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalcule l'heure la plus tardive à laquelle yyy peut partir pour l'école sans être en retard. \nL'école est à 'distance' mètres, et yyy marche à une vitesse de 'speed' mètres par minute. \nDe plus, yyy passe 10 minutes supplémentaires pour le tri des déchets en chemin.\n\nL'école exige une arrivée avant 08:00 AM. Cette fonction retourne l'heure de départ la plus tardive au format HH:MM.\n\nExemples :\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "de": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nBerechnet die späteste Zeit, zu der yyy zur Schule aufbrechen kann, ohne zu spät zu kommen.\nDie Schule ist 'distance' Meter entfernt, und yyy geht mit einer Geschwindigkeit von 'speed' Metern pro Minute.\nZusätzlich verbringt yyy 10 Minuten mit der Mülltrennung auf dem Weg.\n\nDie Schule erfordert eine Ankunft bis 08:00 Uhr. Diese Funktion gibt die späteste Abfahrtszeit im HH:MM-Format zurück.\n\nBeispiele:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "ha": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nYana lissafin mafi dadewar lokaci da yyy zai iya fita zuwa makaranta ba tare da ya makara ba.\nMakarantar tana nisan 'distance' mita, kuma yyy yana tafiya da saurin 'speed' mita a minti daya.\nBugu da kari, yyy yana daukar karin minti 10 don rarraba shara a hanya.\n\nMakarantar tana bukatar isowa kafin karfe 08:00 na safe. Wannan aikin yana dawo da mafi dadewar lokacin fita a cikin tsarin HH:MM.\n\nMisalai:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "hi": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nस्कूल के लिए yyy के बिना देर किए निकलने का सबसे अंतिम समय गणना करता है। \nस्कूल 'distance' मीटर दूर है, और yyy 'speed' मीटर प्रति मिनट की गति से चलता है। \nइसके अतिरिक्त, yyy रास्ते में कचरा छांटने के लिए 10 मिनट अतिरिक्त खर्च करता है।\n\nस्कूल में 08:00 AM तक पहुंचना आवश्यक है। यह फ़ंक्शन HH:MM प्रारूप में सबसे अंतिम प्रस्थान समय लौटाता है।\n\nउदाहरण:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "hu": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nKiszámítja a legkésőbbi időpontot, amikor yyy elindulhat az iskolába anélkül, hogy elkésne. \nAz iskola 'distance' méterre van, és yyy 'speed' méter/perc sebességgel gyalogol. \nEzenkívül yyy további 10 percet tölt a szemét szétválogatásával útközben.\n\nAz iskolába 08:00 óráig kell megérkezni. Ez a függvény a legkésőbbi indulási időt adja vissza HH:MM formátumban.\n\nPéldák:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9780561100247896",
      "hy": "0.9826935335308112",
      "bn": "0.9492811226154085",
      "bg": "0.9843018437260507",
      "zh": "0.9734018029363802",
      "fr": "0.9822102658137534",
      "de": "0.9850069815787246",
      "ha": "0.9833803973884299",
      "hi": "0.9612470140297122",
      "hu": "0.975388106746729"
    },
    "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}",
    "instruction": {
      "en": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nՏվեք Swift կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nনিচে দেওয়া Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\n请用不超过500个字符的中文为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8638186135017186",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)",
    "entry_point": "latestDepartureTime",
    "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {",
    "docstring": {
      "en": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n",
      "sq": "Llogarit kohën më të fundit kur yyy mund të niset për në shkollë pa u vonuar. \nShkolla është 'distance' metra larg, dhe yyy ecën me një shpejtësi prej 'speed' metrash për minutë. \nPër më tepër, yyy shpenzon 10 minuta shtesë për ndarjen e mbeturinave gjatë rrugës.\n\nShkolla kërkon mbërritjen deri në orën 08:00 të mëngjesit. Kjo funksion kthen kohën më të fundit të nisjes në formatin HH:MM.\n\nShembuj:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hy": "Հաշվում է վերջին ժամանակը, երբ yyy-ն կարող է դուրս գալ դպրոց առանց ուշանալու: \nԴպրոցը գտնվում է 'distance' մետր հեռավորության վրա, և yyy-ն քայլում է 'speed' մետր րոպեում արագությամբ: \nԲացի այդ, yyy-ն ծախսում է լրացուցիչ 10 րոպե աղբի տեսակավորման համար ճանապարհին:\n\nԴպրոցը պահանջում է ժամանում 08:00-ին: Այս ֆունկցիան վերադարձնում է վերջին դուրս գալու ժամանակը HH:MM ձևաչափով:\n\nՕրինակներ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "bn": "স্কুলে দেরি না করে পৌঁছানোর জন্য yyy সর্বশেষ কখন রওনা হতে পারে তা গণনা করে। \nস্কুলটি 'distance' মিটার দূরে, এবং yyy প্রতি মিনিটে 'speed' মিটার গতিতে হাঁটে। \nঅতিরিক্তভাবে, yyy পথে আবর্জনা বাছাই করার জন্য ১০ মিনিট অতিরিক্ত সময় ব্যয় করে।\n\nস্কুলে পৌঁছানোর সময় সকাল ০৮:০০ টার মধ্যে হতে হবে। এই ফাংশনটি সর্বশেষ রওনা দেওয়ার সময় HH:MM ফরম্যাটে প্রদান করে।\n\nউদাহরণ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "bg": "Изчислява най-късното време, в което yyy може да тръгне за училище, без да закъснее. \nУчилището е на 'distance' метра разстояние, а yyy ходи със скорост 'speed' метра в минута. \nОсвен това, yyy прекарва допълнителни 10 минути за сортиране на боклука по пътя.\n\nУчилището изисква пристигане до 08:00 ч. сутринта. Тази функция връща най-късното време за тръгване във формат HH:MM.\n\nПримери:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "zh": "计算yyy可以不迟到的情况下去上学的最晚出发时间。\n学校距离为'distance'米，yyy以'speed'米每分钟的速度行走。\n此外，yyy在路上花费额外的10分钟进行垃圾分类。\n\n学校要求在上午08:00之前到达。此函数返回最晚出发时间，格式为HH:MM。\n\n示例：\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "fr": "Calcule l'heure la plus tardive à laquelle yyy peut partir pour l'école sans être en retard. \nL'école est à 'distance' mètres, et yyy marche à une vitesse de 'speed' mètres par minute. \nDe plus, yyy passe 10 minutes supplémentaires pour le tri des déchets en chemin.\n\nL'école exige une arrivée avant 08:00. Cette fonction renvoie l'heure de départ la plus tardive au format HH:MM.\n\nExemples :\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "de": "Berechnet die späteste Zeit, zu der yyy zur Schule aufbrechen kann, ohne zu spät zu kommen. \nDie Schule ist 'distance' Meter entfernt, und yyy geht mit einer Geschwindigkeit von 'speed' Metern pro Minute. \nZusätzlich verbringt yyy 10 Minuten mit der Mülltrennung auf dem Weg.\n\nDie Schule erfordert eine Ankunft bis 08:00 Uhr. Diese Funktion gibt die späteste Abfahrtszeit im HH:MM-Format zurück.\n\nBeispiele:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "ha": "Yana ƙididdige mafi ƙarancin lokaci da yyy zai iya fita zuwa makaranta ba tare da yin jinkiri ba. \nMakarantar tana da nisan 'distance' mita, kuma yyy yana tafiya da saurin 'speed' mita a minti daya. \nBugu da ƙari, yyy yana ɗaukar karin minti 10 don rarraba shara a hanya.\n\nMakarantar tana buƙatar isa kafin karfe 08:00 na safe. Wannan aikin yana dawowa da mafi ƙarancin lokacin fita a cikin tsarin HH:MM.\n\nMisalai:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hi": "स्कूल के लिए yyy के देर न होने के लिए सबसे देर से निकलने का समय गणना करता है। \nस्कूल 'distance' मीटर दूर है, और yyy 'speed' मीटर प्रति मिनट की गति से चलता है। \nइसके अतिरिक्त, yyy रास्ते में कचरा छांटने के लिए 10 मिनट अतिरिक्त खर्च करता है।\n\nस्कूल में 08:00 AM तक पहुंचना आवश्यक है। यह फ़ंक्शन HH:MM प्रारूप में सबसे देर से प्रस्थान का समय लौटाता है।\n\nउदाहरण:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hu": "Kiszámítja, hogy yyy legkésőbb mikor indulhat el az iskolába anélkül, hogy elkésne. \nAz iskola 'distance' méterre van, és yyy 'speed' méter per perc sebességgel sétál. \nEzenkívül yyy további 10 percet tölt szemétválogatással útközben.\n\nAz iskola megköveteli, hogy 08:00-ra érkezzen meg. Ez a függvény a legkésőbbi indulási időt adja vissza HH:MM formátumban.\n\nPéldák:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\""
    },
    "docstring_bertscore": {
      "sq": "0.9710968959948514",
      "hy": "0.9825787251705731",
      "bn": "0.9398865014836014",
      "bg": "0.9813446346132033",
      "zh": "0.9659295266322288",
      "fr": "0.9681275704287609",
      "de": "0.9813809839729327",
      "ha": "0.9508213025899531",
      "hi": "0.9587740657858279",
      "hu": "0.980966839628475"
    }
  },
  {
    "task_id": "Swift/39",
    "prompt": {
      "en": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "sq": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nLlogarit rezultatin përfundimtar për një garues duke hequr rezultatet më të larta dhe më të ulëta nga\nvargu i dhënë i rezultateve dhe pastaj duke llogaritur mesataren e rezultateve të mbetura.\nRezultati rrumbullakohet në dy vende dhjetore.\n\n- Parametrat:\n- scores: Një varg i `Double` që përfaqëson rezultatet e dhëna nga secili gjyqtar.\n\n- Kthen: Një `Double` që përfaqëson rezultatin përfundimtar të garuesit, i rrumbullakosur në dy vende dhjetore.\n\nShembuj:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "hy": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nՀաշվում է մասնակիցի վերջնական միավորը՝ հեռացնելով ամենաբարձր և ամենացածր միավորները\nտրված միավորների զանգվածից, այնուհետև հաշվում է մնացած միավորների միջին արժեքը։\nԱրդյունքը կլորացվում է մինչև երկու տասնորդական թվանշան։\n\n- Պարամետրեր:\n- scores: `Double`-ի զանգված, որը ներկայացնում է յուրաքանչյուր դատավորի տրված միավորները։\n\n- Վերադարձնում է: `Double`, որը ներկայացնում է մասնակիցի վերջնական միավորը, կլորացված մինչև երկու տասնորդական թվանշան։\n\nՕրինակներ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "bn": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nপ্রতিযোগীর জন্য চূড়ান্ত স্কোর গণনা করে উচ্চতম এবং নিম্নতম স্কোরগুলি সরিয়ে দিয়ে\nপ্রদত্ত স্কোরের অ্যারে থেকে এবং তারপর অবশিষ্ট স্কোরগুলির গড় গণনা করে।\nফলাফলটি দুই দশমিক স্থান পর্যন্ত রাউন্ড করা হয়।\n\n- প্যারামিটার:\n- scores: প্রতিটি বিচারকের দ্বারা প্রদত্ত স্কোরের প্রতিনিধিত্বকারী `Double` এর একটি অ্যারে।\n\n- রিটার্নস: প্রতিযোগীর চূড়ান্ত স্কোরের প্রতিনিধিত্বকারী একটি `Double`, যা দুই দশমিক স্থান পর্যন্ত রাউন্ড করা হয়।\n\nউদাহরণ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "bg": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nИзчислява крайната оценка за състезател, като премахва най-високата и най-ниската оценка от\nдадения масив от оценки и след това изчислява средната стойност на останалите оценки.\nРезултатът се закръгля до два знака след десетичната запетая.\n\n- Параметри:\n- scores: Масив от `Double`, представляващ оценките, дадени от всеки съдия.\n\n- Връща: `Double`, представляващ крайната оценка на състезателя, закръглена до два знака след десетичната запетая.\n\nПримери:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "zh": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\n计算参赛者的最终得分，通过从给定的分数数组中去掉最高分和最低分，然后计算剩余分数的平均值。\n结果四舍五入到小数点后两位。\n\n- 参数:\n- scores: 一个 `Double` 数组，表示每位评委给出的分数。\n\n- 返回: 一个 `Double`，表示参赛者的最终得分，四舍五入到小数点后两位。\n\n示例:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "fr": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalcule le score final pour un concurrent en supprimant les scores les plus élevés et les plus bas du\ntableau de scores donné, puis en calculant la moyenne des scores restants.\nLe résultat est arrondi à deux décimales.\n\n- Paramètres:\n- scores: Un tableau de `Double` représentant les scores donnés par chaque juge.\n\n- Retourne: Un `Double` représentant le score final du concurrent, arrondi à deux décimales.\n\nExemples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "de": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nBerechnet die Endpunktzahl für einen Teilnehmer, indem die höchsten und niedrigsten Punktzahlen aus dem\ngegebenen Array von Punktzahlen entfernt werden und dann der Durchschnitt der verbleibenden Punktzahlen berechnet wird.\nDas Ergebnis wird auf zwei Dezimalstellen gerundet.\n\n- Parameter:\n- scores: Ein Array von `Double`, das die von jedem Richter vergebenen Punktzahlen darstellt.\n\n- Rückgabewert: Ein `Double`, das die Endpunktzahl des Teilnehmers darstellt, gerundet auf zwei Dezimalstellen.\n\nBeispiele:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "ha": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nYana lissafin maki na ƙarshe ga mai fafatawa ta hanyar cire mafi girma da mafi ƙanƙanta maki daga\njerin maki da aka bayar sannan kuma lissafin matsakaicin maki na sauran maki.\nSakamakon yana zagaye zuwa wurare biyu na goma.\n\n- Ma'auni:\n- scores: Jerin `Double` da ke wakiltar maki da kowanne alkalin ya bayar.\n\n- Yana Mayarwa: `Double` da ke wakiltar maki na ƙarshe na mai fafatawa, zagaye zuwa wurare biyu na goma.\n\nMisalai:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "hi": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nप्रतियोगी के लिए अंतिम स्कोर की गणना करता है, जिसमें दिए गए स्कोर के सरणी से सबसे उच्च और सबसे निम्न स्कोर को हटाकर शेष स्कोर का औसत निकालता है।\nपरिणाम को दो दशमलव स्थानों तक गोल किया जाता है।\n\n- पैरामीटर्स:\n- scores: `Double` की एक सरणी जो प्रत्येक जज द्वारा दिए गए स्कोर का प्रतिनिधित्व करती है।\n\n- रिटर्न्स: एक `Double` जो प्रतियोगी के अंतिम स्कोर का प्रतिनिधित्व करता है, दो दशमलव स्थानों तक गोल किया गया।\n\nउदाहरण:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "hu": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nKiszámítja a versenyző végső pontszámát úgy, hogy eltávolítja a legmagasabb és legalacsonyabb pontszámokat\na megadott pontszámok tömbjéből, majd kiszámítja a fennmaradó pontszámok átlagát.\nAz eredményt két tizedesjegyre kerekíti.\n\n- Paraméterek:\n- scores: Egy `Double` tömb, amely az egyes bírák által adott pontszámokat képviseli.\n\n- Visszatér: Egy `Double`, amely a versenyző végső pontszámát képviseli, két tizedesjegyre kerekítve.\n\nPéldák:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9882714718910329",
      "hy": "0.984092288674059",
      "bn": "0.9920085038798233",
      "bg": "0.9778225206966926",
      "zh": "0.9833456370717487",
      "fr": "0.9806067227476587",
      "de": "0.978103185425095",
      "ha": "0.9763129298008275",
      "hi": "0.9810458945201268",
      "hu": "0.9828226432784839"
    },
    "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}",
    "instruction": {
      "en": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nনিম্নলিখিত Swift কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9404853720824217",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()",
    "entry_point": "calculateFinalScore",
    "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {",
    "docstring": {
      "en": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n",
      "sq": "Llogarit rezultatin përfundimtar për një garues duke hequr pikët më të larta dhe më të ulëta nga\nvargu i dhënë i pikëve dhe pastaj duke llogaritur mesataren e pikëve të mbetura.\nRezultati rrumbullakohet në dy vende dhjetore.\n\n- Parametrat:\n- scores: Një varg i `Double` që përfaqëson pikët e dhëna nga secili gjyqtar.\n\n- Kthen: Një `Double` që përfaqëson rezultatin përfundimtar të garuesit, i rrumbullakosur në dy vende dhjetore.\n\nShembuj:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hy": "Հաշվում է մասնակիցի վերջնական միավորը՝ հեռացնելով ամենաբարձր և ամենացածր միավորները տրված միավորների զանգվածից, այնուհետև հաշվում է մնացած միավորների միջին արժեքը։ Արդյունքը կլորացվում է մինչև երկու տասնորդական թվանշան։\n\n- Պարամետրեր:\n- scores: `Double`-ի զանգված, որը ներկայացնում է յուրաքանչյուր դատավորի տված միավորները։\n\n- Վերադարձնում է: `Double`, որը ներկայացնում է մասնակիցի վերջնական միավորը, կլորացված մինչև երկու տասնորդական թվանշան։\n\nՕրինակներ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "bn": "প্রতিযোগীর চূড়ান্ত স্কোর গণনা করে সর্বোচ্চ এবং সর্বনিম্ন স্কোরগুলি প্রদত্ত স্কোরের অ্যারে থেকে সরিয়ে এবং তারপর বাকি স্কোরগুলির গড় গণনা করে। ফলাফলটি দুই দশমিক স্থান পর্যন্ত গোলাকার হয়।\n\n- প্যারামিটারসমূহ:\n- scores: প্রতিটি বিচারকের দেওয়া স্কোরগুলি উপস্থাপনকারী `Double` এর একটি অ্যারে।\n\n- রিটার্নস: প্রতিযোগীর চূড়ান্ত স্কোর উপস্থাপনকারী একটি `Double`, যা দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\nউদাহরণসমূহ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "bg": "Изчислява крайната оценка за състезател, като премахва най-високата и най-ниската оценка от дадения масив от оценки и след това изчислява средната стойност на останалите оценки. Резултатът се закръгля до два знака след десетичната запетая.\n\n- Параметри:\n- scores: Масив от `Double`, представляващ оценките, дадени от всеки съдия.\n\n- Връща: `Double`, представляващ крайната оценка на състезателя, закръглена до два знака след десетичната запетая.\n\nПримери:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "zh": "计算参赛者的最终得分，通过从给定的分数数组中去除最高分和最低分，然后计算剩余分数的平均值。结果四舍五入到小数点后两位。\n\n- 参数：\n- scores: 一个 `Double` 数组，表示每位评委给出的分数。\n\n- 返回：一个 `Double`，表示参赛者的最终得分，四舍五入到小数点后两位。\n\n示例：\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "fr": "Calcule le score final pour un concurrent en supprimant les scores les plus élevés et les plus bas du tableau de scores donné, puis en calculant la moyenne des scores restants. Le résultat est arrondi à deux décimales.\n\n- Paramètres:\n- scores: Un tableau de `Double` représentant les scores donnés par chaque juge.\n\n- Retourne: Un `Double` représentant le score final du concurrent, arrondi à deux décimales.\n\nExemples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "de": "Berechnet die Endpunktzahl für einen Teilnehmer, indem die höchsten und niedrigsten Punktzahlen aus dem angegebenen Array von Punktzahlen entfernt und dann der Durchschnitt der verbleibenden Punktzahlen berechnet wird. Das Ergebnis wird auf zwei Dezimalstellen gerundet.\n\n- Parameter:\n- scores: Ein Array von `Double`, das die von jedem Richter vergebenen Punktzahlen darstellt.\n\n- Rückgabewert: Ein `Double`, das die endgültige Punktzahl des Teilnehmers darstellt, gerundet auf zwei Dezimalstellen.\n\nBeispiele:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "ha": "Calculates the final score for a contestant by removing the highest and lowest scores from the given array of scores and then calculating the average of the remaining scores. The result is rounded to two decimal places.\n\n- Sigogi:\n- scores: Wani tsari na `Double` da ke wakiltar maki da kowane alƙali ya bayar.\n\n- Komawa: Wani `Double` da ke wakiltar maki na ƙarshe na mai gasa, an zagaye zuwa wurare biyu na goma.\n\nMisalai:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hi": "प्रतियोगी के लिए अंतिम स्कोर की गणना करता है, जिसमें दिए गए स्कोर के समूह से उच्चतम और निम्नतम स्कोर को हटा दिया जाता है और फिर शेष स्कोर का औसत निकाला जाता है। परिणाम को दो दशमलव स्थानों तक गोल किया जाता है।\n\n- पैरामीटर्स:\n- scores: `Double` का एक समूह जो प्रत्येक जज द्वारा दिए गए स्कोर का प्रतिनिधित्व करता है।\n\n- रिटर्न्स: एक `Double` जो प्रतियोगी का अंतिम स्कोर दर्शाता है, दो दशमलव स्थानों तक गोल किया जाता है।\n\nउदाहरण:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hu": "Kiszámítja a versenyző végső pontszámát azáltal, hogy eltávolítja a legmagasabb és legalacsonyabb pontszámokat a megadott pontszám tömbből, majd kiszámítja a megmaradt pontszámok átlagát. Az eredmény két tizedesjegyre van kerekítve.\n\n- Paraméterek:\n- scores: A bírók által adott pontszámokat tartalmazó `Double` tömb.\n\n- Visszatérési érték: Egy `Double`, amely a versenyző végső pontszámát jelenti, két tizedesjegyre kerekítve.\n\nPéldák:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00"
    },
    "docstring_bertscore": {
      "sq": "0.992666566332192",
      "hy": "0.9746406606228948",
      "bn": "0.9911597562616613",
      "bg": "0.9848617827701881",
      "zh": "0.9799301876698538",
      "fr": "0.977118177365543",
      "de": "0.9840418365572761",
      "ha": "0.9948413703741429",
      "hi": "0.9575215026030219",
      "hu": "0.9520037492482537"
    }
  },
  {
    "task_id": "Swift/40",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "sq": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nLlogarit ndryshimin minimal absolut midis thartësisë totale dhe hidhësisë totale të një kombinimi përbërësish. Thartësia totale është prodhimi i thartësisë së secilit përbërës të përdorur, dhe hidhësia totale është shuma e hidhësisë së secilit përbërës të përdorur. Të paktën një përbërës duhet të përdoret.\n\n- Parametrat:\n- ingredients: Një varg tuplesh, ku secili tuple përmban thartësinë dhe hidhësinë e një përbërësi.\n\n- Kthen: Ndryshimin minimal absolut midis thartësisë totale dhe hidhësisë totale.\n\nShembull:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "hy": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nՀաշվում է բաղադրիչների համադրության ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը: Ընդհանուր թթվությունը օգտագործված յուրաքանչյուր բաղադրիչի թթվության արտադրյալն է, իսկ ընդհանուր դառնությունը օգտագործված յուրաքանչյուր բաղադրիչի դառնության գումարն է: Պետք է օգտագործվի առնվազն մեկ բաղադրիչ:\n\n- Պարամետրեր:\n- ingredients: Կրկնակի արժեքների զանգված, որտեղ յուրաքանչյուր կրկնակի արժեք պարունակում է բաղադրիչի թթվությունը և դառնությունը:\n\n- Վերադարձնում է: Ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը:\n\nՕրինակ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "bn": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nউপাদানগুলির একটি সংমিশ্রণের মোট টকত্ব এবং মোট তিক্ততার মধ্যে ন্যূনতম পরম পার্থক্য গণনা করে। মোট টকত্ব হল ব্যবহৃত প্রতিটি উপাদানের টকত্বের গুণফল, এবং মোট তিক্ততা হল ব্যবহৃত প্রতিটি উপাদানের তিক্ততার যোগফল। অন্তত একটি উপাদান ব্যবহার করতে হবে।\n\n- প্যারামিটার:\n- ingredients: একটি টুপলের অ্যারে, যেখানে প্রতিটি টুপলে একটি উপাদানের টকত্ব এবং তিক্ততা থাকে।\n\n- রিটার্নস: মোট টকত্ব এবং মোট তিক্ততার মধ্যে ন্যূনতম পরম পার্থক্য।\n\nউদাহরণ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "bg": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nИзчислява минималната абсолютна разлика между общата киселинност и общата горчивина на комбинация от съставки. Общата киселинност е произведението от киселинността на всяка използвана съставка, а общата горчивина е сумата от горчивината на всяка използвана съставка. Трябва да се използва поне една съставка.\n\n- Параметри:\n- ingredients: Масив от кортежи, където всеки кортеж съдържа киселинността и горчивината на една съставка.\n\n- Връща: Минималната абсолютна разлика между общата киселинност и общата горчивина.\n\nПример:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "zh": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\n计算组合成分的总酸度和总苦味之间的最小绝对差。总酸度是所用每种成分的酸度的乘积，总苦味是所用每种成分的苦味之和。至少必须使用一种成分。\n\n- 参数:\n- ingredients: 一个元组数组，其中每个元组包含一种成分的酸度和苦味。\n\n- 返回值: 总酸度和总苦味之间的最小绝对差。\n\n示例:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "fr": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalcule la différence absolue minimale entre l'acidité totale et l'amertume totale d'une combinaison d'ingrédients. L'acidité totale est le produit de l'acidité de chaque ingrédient utilisé, et l'amertume totale est la somme de l'amertume de chaque ingrédient utilisé. Au moins un ingrédient doit être utilisé.\n\n- Paramètres:\n- ingredients: Un tableau de tuples, où chaque tuple contient l'acidité et l'amertume d'un ingrédient.\n\n- Retourne: La différence absolue minimale entre l'acidité totale et l'amertume totale.\n\nExemple:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "de": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nBerechnet den minimalen absoluten Unterschied zwischen der Gesamtsäure und der Gesamtbitterkeit einer Kombination von Zutaten. Die Gesamtsäure ist das Produkt der Säure jeder verwendeten Zutat, und die Gesamtbitterkeit ist die Summe der Bitterkeit jeder verwendeten Zutat. Es muss mindestens eine Zutat verwendet werden.\n\n- Parameter:\n- ingredients: Ein Array von Tupeln, wobei jedes Tupel die Säure und Bitterkeit einer Zutat enthält.\n\n- Rückgabe: Der minimale absolute Unterschied zwischen Gesamtsäure und Gesamtbitterkeit.\n\nBeispiel:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "ha": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nYana ƙididdige mafi ƙarancin bambanci tsakanin jimillar tsami da jimillar ɗaci na haɗin kayan abinci. Jimillar tsami ita ce samfurin tsamin kowanne kayan abinci da aka yi amfani da shi, kuma jimillar ɗaci ita ce jimillar ɗacin kowanne kayan abinci da aka yi amfani da shi. Aƙalla dole a yi amfani da kayan abinci guda ɗaya.\n\n- Sigogi:\n- ingredients: Jerin tuples, inda kowanne tuple ya ƙunshi tsami da ɗacin kayan abinci.\n\n- Returns: Mafi ƙarancin bambanci tsakanin jimillar tsami da jimillar ɗaci.\n\nMisali:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "hi": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nसामग्री के संयोजन की कुल खट्टापन और कुल कड़वाहट के बीच न्यूनतम पूर्ण अंतर की गणना करता है। कुल खट्टापन उपयोग की गई प्रत्येक सामग्री के खट्टापन का गुणनफल है, और कुल कड़वाहट उपयोग की गई प्रत्येक सामग्री की कड़वाहट का योग है। कम से कम एक सामग्री का उपयोग किया जाना चाहिए।\n\n- पैरामीटर्स:\n- ingredients: ट्यूपल की एक श्रृंखला, जहाँ प्रत्येक ट्यूपल में एक सामग्री की खट्टापन और कड़वाहट होती है।\n\n- रिटर्न्स: कुल खट्टापन और कुल कड़वाहट के बीच न्यूनतम पूर्ण अंतर।\n\nउदाहरण:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "hu": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nKiszámítja a minimális abszolút különbséget az összes savanyúság és az összes keserűség között egy összetevők kombinációjában. Az összes savanyúság az egyes felhasznált összetevők savanyúságának szorzata, és az összes keserűség az egyes felhasznált összetevők keserűségének összege. Legalább egy összetevőt fel kell használni.\n\n- Paraméterek:\n- ingredients: Egy tömb, amely párokat tartalmaz, ahol minden pár egy összetevő savanyúságát és keserűségét tartalmazza.\n\n- Visszatér: Az összes savanyúság és az összes keserűség közötti minimális abszolút különbség.\n\nPélda:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9964081668197461",
      "hy": "0.9954094532639027",
      "bn": "0.997324250137079",
      "bg": "0.9925493744073813",
      "zh": "0.9903821183199096",
      "fr": "0.997324250137079",
      "de": "0.9905104335460582",
      "ha": "0.9827392185184493",
      "hi": "0.997324250137079",
      "hu": "0.9796513106148809"
    },
    "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}",
    "instruction": {
      "en": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки най-много 500 знака.",
      "zh": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8733351936874811",
      "bg": "0.9448367678397529",
      "zh": "0.8526498258065078",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9312949429823184"
    },
    "level": "",
    "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()",
    "entry_point": "minimumTasteDifference",
    "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n",
      "sq": "Llogarit ndryshimin minimal absolut midis thartësisë totale dhe hidhësisë totale të një kombinimi përbërësish. Thartësia totale është produkti i thartësisë së secilit përbërës të përdorur, dhe hidhësia totale është shuma e hidhësisë së secilit përbërës të përdorur. Të paktën një përbërës duhet të përdoret.\n\n- Parametra:\n- ingredients: Një varg me tufa, ku çdo tufë përmban thartësinë dhe hidhësinë e një përbërësi.\n\n- Kthen: Ndryshimi minimal absolut midis thartësisë totale dhe hidhësisë totale.\n\nShembull:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hy": "Հաշվում է բաղադրիչների համակցման ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը։ Ընդհանուր թթվությունը օգտագործված յուրաքանչյուր բաղադրիչի թթվությունների արտադրյալն է, իսկ ընդհանուր դառնությունը օգտագործված յուրաքանչյուր բաղադրիչի դառնությունների գումարն է։ Պետք է օգտագործվի առնվազն մեկ բաղադրիչ։\n\n- Պարամետրեր:\n- ingredients: Թվերի զանգված, որտեղ յուրաքանչյուր տուփ պարունակում է բաղադրիչի թթվությունն ու դառնությունը։\n\n- Վերադարձնում է: Ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը։\n\nՕրինակ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "bn": "মোট টকত্ব এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পরম পার্থক্য গণনা করে একটি উপাদানের সংমিশ্রণের জন্য। মোট টকত্ব হল ব্যবহৃত প্রতিটি উপাদানের টকত্বের গুণফল, এবং মোট তিক্ততা হল ব্যবহৃত প্রতিটি উপাদানের তিক্ততার যোগফল। অন্তত একটি উপাদান ব্যবহার করতে হবে।\n\n- প্যারামিটারসমূহ:\n- ingredients: একটি টুপলের অ্যারে, যেখানে প্রতিটি টুপলে একটি উপাদানের টকত্ব এবং তিক্ততা থাকে।\n\n- রিটার্নস: মোট টকত্ব এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পরম পার্থক্য।\n\nউদাহরণ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "bg": "Изчислява минималната абсолютна разлика между общата киселинност и общата горчивина на комбинация от съставки. Общата киселинност е произведението на киселинността на всяка използвана съставка, а общата горчивина е сумата от горчивината на всяка използвана съставка. Трябва да се използва поне една съставка.\n\n- Параметри:\n- ingredients: Масив от кортежи, където всеки кортеж съдържа киселинността и горчивината на съставка.\n\n- Връща: Минималната абсолютна разлика между общата киселинност и общата горчивина.\n\nПример:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "zh": "计算组合成分的总酸度和总苦度之间的最小绝对差。总酸度是所用每种成分的酸度的乘积，总苦度是所用每种成分的苦度的总和。必须使用至少一种成分。\n\n- 参数：\n- ingredients: 一个元组数组，其中每个元组包含一种成分的酸度和苦度。\n\n- 返回值：总酸度和总苦度之间的最小绝对差。\n\n示例：\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "fr": "Calcule la différence absolue minimale entre l'acidité totale et l'amertume totale d'une combinaison d'ingrédients. L'acidité totale est le produit de l'acidité de chaque ingrédient utilisé, et l'amertume totale est la somme de l'amertume de chaque ingrédient utilisé. Au moins un ingrédient doit être utilisé.\n\n- Paramètres:\n- ingredients: Un tableau de tuples, où chaque tuple contient l'acidité et l'amertume d'un ingrédient.\n\n- Retourne: La différence absolue minimale entre l'acidité totale et l'amertume totale.\n\nExemple:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "de": "Berechnet den minimalen absoluten Unterschied zwischen der gesamten Säure und der gesamten Bitterkeit einer Kombination von Zutaten. Die gesamte Säure ist das Produkt der Säure jeder verwendeten Zutat, und die gesamte Bitterkeit ist die Summe der Bitterkeit jeder verwendeten Zutat. Es muss mindestens eine Zutat verwendet werden.\n\n- Parameter:\n- ingredients: Ein Array von Tupeln, wobei jedes Tupel die Säure und die Bitterkeit einer Zutat enthält.\n\n- Rückgabewert: Der minimale absolute Unterschied zwischen der gesamten Säure und der gesamten Bitterkeit.\n\nBeispiel:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "ha": "Calculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Sigogi:\n- ingredients: Wani tsari na tuples, inda kowane tuple ya ƙunshi sourness da bitterness na wani sinadari.\n\n- Returns: Mafi ƙarancin bambanci tsakanin total sourness da total bitterness.\n\nMisali:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hi": "कुल खट्टेपन और कुल कड़वाहट के बीच न्यूनतम निरपेक्ष अंतर की गणना करता है। कुल खट्टापन उपयोग किए गए प्रत्येक घटक के खट्टेपन का गुणनफल है, और कुल कड़वाहट उपयोग किए गए प्रत्येक घटक की कड़वाहट का योग है। कम से कम एक घटक का उपयोग किया जाना चाहिए।\n\n- पैरामीटर्स:\n- ingredients: ट्यूपल्स की एक array, जहां प्रत्येक ट्यूपल में एक घटक का खट्टापन और कड़वाहट होती है।\n\n- रिटर्न्स: कुल खट्टेपन और कुल कड़वाहट के बीच न्यूनतम निरपेक्ष अंतर।\n\nउदाहरण:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hu": "Kiszámítja az összes savanyúság és az összes keserűség közötti minimális abszolút különbséget az összetevők kombinációja esetén. Az összes savanyúság az összes felhasznált összetevő savanyúságának szorzata, és az összes keserűség az összes felhasznált összetevő keserűségének összege. Legalább egy összetevőt fel kell használni.\n\n- Paraméterek:\n- ingredients: Egy tömb, amely tuple-öket tartalmaz, ahol minden tuple egy összetevő savanyúságát és keserűségét tartalmazza.\n\n- Visszatér: Az összes savanyúság és az összes keserűség közötti minimális abszolút különbség.\n\nPélda:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9559622541118981",
      "hy": "0.9526602226575741",
      "bn": "0.9909049134827935",
      "bg": "0.9584423530494997",
      "zh": "0.9591723196998029",
      "fr": "0.959520320127376",
      "de": "0.9816928336711574",
      "ha": "0.9973284213750807",
      "hi": "0.9774135407421418",
      "hu": "0.9477669632207796"
    }
  },
  {
    "task_id": "Swift/41",
    "prompt": {
      "en": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calculates the product of the sum of the first two integers and the third integer.\n\n    This function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n    - Parameters:\n        - a: The first integer.\n        - b: The second integer.\n        - c: The third integer.\n\n    - Returns: An integer that is the product of (a+b) and c.\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */",
      "sq": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Llogarit produktin e shumës së dy numrave të parë dhe numrit të tretë.\n\n    Kjo funksion merr tre numra të plotë si hyrje dhe llogarit produktin e shumës së dy numrave të parë (a dhe b) dhe numrit të tretë (c), duke llogaritur në mënyrë efektive (a+b)*c.\n\n    - Parametrat:\n        - a: Numri i parë i plotë.\n        - b: Numri i dytë i plotë.\n        - c: Numri i tretë i plotë.\n\n    - Kthen: Një numër i plotë që është produkti i (a+b) dhe c.\n\n    ### Shembull:\n    calculateProductOfSumAndValue(1, 2, 3) // Kthen 9 sepse (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Kthen -9 sepse (-1-2)*-3 = 9\n    */",
      "hy": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Հաշվում է առաջին երկու ամբողջ թվերի գումարի և երրորդ թվի արտադրյալը։\n\n    Այս ֆունկցիան ընդունում է երեք ամբողջ թիվ որպես մուտք և հաշվում է առաջին երկու ամբողջ թվերի (a և b) գումարի և երրորդ թվի (c) արտադրյալը, փաստացի հաշվարկելով (a+b)*c։\n\n    - Պարամետրեր:\n        - a: Առաջին ամբողջ թիվը։\n        - b: Երկրորդ ամբողջ թիվը։\n        - c: Երրորդ ամբողջ թիվը։\n\n    - Վերադարձնում է: Ամբողջ թիվ, որը (a+b) և c արտադրյալն է։\n\n    ### Օրինակ:\n    calculateProductOfSumAndValue(1, 2, 3) // Վերադարձնում է 9, քանի որ (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Վերադարձնում է -9, քանի որ (-1-2)*-3 = 9\n    */",
      "bn": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    প্রথম দুটি পূর্ণসংখ্যার যোগফল এবং তৃতীয় পূর্ণসংখ্যার গুণফল হিসাব করে।\n\n    এই ফাংশনটি ইনপুট হিসেবে তিনটি পূর্ণসংখ্যা গ্রহণ করে এবং প্রথম দুটি পূর্ণসংখ্যার (a এবং b) যোগফল এবং তৃতীয় পূর্ণসংখ্যার (c) গুণফল হিসাব করে, কার্যকরভাবে (a+b)*c হিসাব করে।\n\n    - প্যারামিটারসমূহ:\n        - a: প্রথম পূর্ণসংখ্যা।\n        - b: দ্বিতীয় পূর্ণসংখ্যা।\n        - c: তৃতীয় পূর্ণসংখ্যা।\n\n    - রিটার্ন: একটি পূর্ণসংখ্যা যা (a+b) এবং c এর গুণফল।\n\n    ### উদাহরণ:\n    calculateProductOfSumAndValue(1, 2, 3) // 9 রিটার্ন করে কারণ (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // -9 রিটার্ন করে কারণ (-1-2)*-3 = 9\n    */",
      "bg": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Изчислява произведението на сумата от първите две цели числа и третото цяло число.\n\n    Тази функция приема три цели числа като вход и изчислява произведението на сумата от първите две цели числа (a и b) и третото цяло число (c), като ефективно изчислява (a+b)*c.\n\n    - Параметри:\n        - a: Първото цяло число.\n        - b: Второто цяло число.\n        - c: Третото цяло число.\n\n    - Връща: Цяло число, което е произведението на (a+b) и c.\n\n    ### Пример:\n    calculateProductOfSumAndValue(1, 2, 3) // Връща 9, защото (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Връща -9, защото (-1-2)*-3 = 9\n    */",
      "zh": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    计算前两个整数之和与第三个整数的乘积。\n\n    此函数接受三个整数作为输入，并计算前两个整数（a 和 b）之和与第三个整数（c）的乘积，实际上计算的是 (a+b)*c。\n\n    - 参数:\n        - a: 第一个整数。\n        - b: 第二个整数。\n        - c: 第三个整数。\n\n    - 返回: 一个整数，即 (a+b) 和 c 的乘积。\n\n    ### 示例:\n    calculateProductOfSumAndValue(1, 2, 3) // 返回 9 因为 (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // 返回 -9 因为 (-1-2)*-3 = 9\n    */",
      "fr": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calcule le produit de la somme des deux premiers entiers et du troisième entier.\n\n    Cette fonction prend trois entiers en entrée et calcule le produit de la somme des deux premiers entiers (a et b) et du troisième entier (c), calculant ainsi (a+b)*c.\n\n    - Paramètres:\n        - a: Le premier entier.\n        - b: Le deuxième entier.\n        - c: Le troisième entier.\n\n    - Retourne: Un entier qui est le produit de (a+b) et c.\n\n    ### Exemple:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */",
      "de": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Berechnet das Produkt der Summe der ersten beiden Ganzzahlen und der dritten Ganzzahl.\n\n    Diese Funktion nimmt drei Ganzzahlen als Eingabe und berechnet das Produkt der Summe der ersten beiden Ganzzahlen (a und b) und der dritten Ganzzahl (c), indem sie effektiv (a+b)*c berechnet.\n\n    - Parameter:\n        - a: Die erste Ganzzahl.\n        - b: Die zweite Ganzzahl.\n        - c: Die dritte Ganzzahl.\n\n    - Rückgabe: Eine Ganzzahl, die das Produkt von (a+b) und c ist.\n\n    ### Beispiel:\n    calculateProductOfSumAndValue(1, 2, 3) // Gibt 9 zurück, weil (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Gibt -9 zurück, weil (-1-2)*-3 = 9\n    */",
      "ha": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Lissafin samfurin jimillar lambobin farko biyu da lamba ta uku.\n\n    Wannan aikin yana karɓar lambobi guda uku a matsayin shigarwa kuma yana lissafin samfurin jimillar lambobin farko biyu (a da b) da lamba ta uku (c), yana lissafin (a+b)*c.\n\n    - Ma'auni:\n        - a: Lamba ta farko.\n        - b: Lamba ta biyu.\n        - c: Lamba ta uku.\n\n    - Komawa: Lamba ce wadda ita ce samfurin (a+b) da c.\n\n    ### Misali:\n    calculateProductOfSumAndValue(1, 2, 3) // Yana dawowa 9 saboda (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Yana dawowa -9 saboda (-1-2)*-3 = 9\n    */",
      "hi": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    पहले दो पूर्णांकों के योग और तीसरे पूर्णांक के गुणनफल की गणना करता है।\n\n    यह फ़ंक्शन तीन पूर्णांक इनपुट के रूप में लेता है और पहले दो पूर्णांकों (a और b) के योग और तीसरे पूर्णांक (c) के गुणनफल की गणना करता है, प्रभावी रूप से (a+b)*c की गणना करता है।\n\n    - पैरामीटर्स:\n        - a: पहला पूर्णांक।\n        - b: दूसरा पूर्णांक।\n        - c: तीसरा पूर्णांक।\n\n    - रिटर्न: एक पूर्णांक जो (a+b) और c का गुणनफल है।\n\n    ### उदाहरण:\n    calculateProductOfSumAndValue(1, 2, 3) // 9 लौटाता है क्योंकि (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // -9 लौटाता है क्योंकि (-1-2)*-3 = 9\n    */",
      "hu": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Kiszámítja az első két egész szám összegének és a harmadik egész számnak a szorzatát.\n\n    Ez a függvény három egész számot vesz be bemenetként, és kiszámítja az első két egész szám (a és b) összegének és a harmadik egész számnak (c) a szorzatát, lényegében kiszámítva (a+b)*c.\n\n    - Paraméterek:\n        - a: Az első egész szám.\n        - b: A második egész szám.\n        - c: A harmadik egész szám.\n\n    - Visszatér: Egy egész szám, amely (a+b) és c szorzata.\n\n    ### Példa:\n    calculateProductOfSumAndValue(1, 2, 3) // 9-et ad vissza, mert (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // -9-et ad vissza, mert (-1-2)*-3 = 9\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9845225220793805",
      "hy": "0.9937500950607372",
      "bn": "0.9918035173265953",
      "bg": "0.9902112961922197",
      "zh": "0.989729021627067",
      "fr": "0.9917032089841727",
      "de": "0.9911702836718561",
      "ha": "0.966910363453779",
      "hi": "0.9939433624214842",
      "hu": "0.9929531899720253"
    },
    "canonical_solution": "    return (a + b) * c\n}",
    "instruction": {
      "en": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nПредоставете кратко описание на кода на Swift на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Swift cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.8990590198137853",
      "bn": "0.8779922816012251",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9217926641839904",
      "hi": "0.9102601842611048",
      "hu": "0.9213906362927757"
    },
    "level": "",
    "test": "func testCalculateProductOfSumAndValue() {\n    assert(calculateProductOfSumAndValue(1, 2, 3) == 9, \"Test Case 1 Failed\")\n    assert(calculateProductOfSumAndValue(-1, 2, 3) == 3, \"Test Case 2 Failed\")\n    assert(calculateProductOfSumAndValue(-1, -2, -3) == 9, \"Test Case 3 Failed\")\n    assert(calculateProductOfSumAndValue(0, 0, 1) == 0, \"Test Case 4 Failed\")\n    assert(calculateProductOfSumAndValue(10, 20, 30) == 900, \"Test Case 5 Failed\")\n    assert(calculateProductOfSumAndValue(-5, 5, 0) == 0, \"Test Case 6 Failed\")\n    assert(calculateProductOfSumAndValue(100, 200, -1) == -300, \"Test Case 7 Failed\")\n}\n\ntestCalculateProductOfSumAndValue()",
    "entry_point": "calculateProductOfSumAndValue",
    "signature": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n",
      "sq": "Llogarit produktin e shumës së dy numrave të parë të plotë dhe numrit të tretë të plotë.\n\nKjo funksion merr tre numra të plotë si input dhe llogarit produktin e shumës së dy numrave të parë të plotë (a dhe b) dhe numrit të tretë të plotë (c), duke llogaritur në mënyrë efektive (a+b)*c.\n\n- Parametrat:\n- a: Numri i parë i plotë.\n- b: Numri i dytë i plotë.\n- c: Numri i tretë i plotë.\n\n- Kthen: Një numër i plotë që është produkti i (a+b) dhe c.\n\n### Shembull:\ncalculateProductOfSumAndValue(1, 2, 3) // Kthen 9 sepse (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Kthen -9 sepse (-1-2)*-3 = 9",
      "hy": "Հաշվում է առաջին երկու ամբողջ թվերի գումարի և երրորդ ամբողջ թվի արտադրյալը։\n\nԱյս ֆունկցիան ընդունում է երեք ամբողջ թիվ որպես մուտք և հաշվարկում է առաջին երկու ամբողջ թվերի (a և b) գումարի և երրորդ ամբողջ թվի (c) արտադրյալը, փաստորեն հաշվարկելով (a+b)*c։\n\n- Պարամետրեր:\n- a: Առաջին ամբողջ թիվը։\n- b: Երկրորդ ամբողջ թիվը։\n- c: Երրորդ ամբողջ թիվը։\n\n- Վերադարձնում է: Ամբողջ թիվ, որը (a+b) և c արտադրյալն է։\n\n### Օրինակ:\ncalculateProductOfSumAndValue(1, 2, 3) // Վերադարձնում է 9, որովհետև (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Վերադարձնում է -9, որովհետև (-1-2)*-3 = 9",
      "bn": "প্রথম দুটি পূর্ণসংখ্যার যোগফল এবং তৃতীয় পূর্ণসংখ্যার গুণফল গণনা করে।\n\nএই ফাংশনটি তিনটি পূর্ণসংখ্যা ইনপুট হিসেবে গ্রহণ করে এবং প্রথম দুটি পূর্ণসংখ্যার (a এবং b) যোগফল এবং তৃতীয় পূর্ণসংখ্যার (c) গুণফল গণনা করে, কার্যকরভাবে (a+b)*c হিসাব করে।\n\n- প্যারামিটারসমূহ:\n- a: প্রথম পূর্ণসংখ্যা।\n- b: দ্বিতীয় পূর্ণসংখ্যা।\n- c: তৃতীয় পূর্ণসংখ্যা।\n\n- রিটার্ন করে: একটি পূর্ণসংখ্যা যা (a+b) এবং c এর গুণফল।\n\n### উদাহরণ:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 রিটার্ন করে কারণ (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 রিটার্ন করে কারণ (-1-2)*-3 = 9",
      "bg": "Изчислява произведението на сумата на първите две цели числа и третото цяло число.\n\nТази функция приема три цели числа като вход и изчислява произведението на сумата на първите две цели числа (a и b) и третото цяло число (c), ефективно изчислявайки (a+b)*c.\n\n- Параметри:\n- a: Първото цяло число.\n- b: Второто цяло число.\n- c: Третото цяло число.\n\n- Връща: Цяло число, което е произведението на (a+b) и c.\n\n### Пример:\ncalculateProductOfSumAndValue(1, 2, 3) // Връща 9, защото (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Връща -9, защото (-1-2)*-3 = 9",
      "zh": "计算前两个整数之和与第三个整数的乘积。\n\n此函数接受三个整数作为输入，并计算前两个整数（a 和 b）之和与第三个整数（c）的乘积，有效地计算 (a+b)*c。\n\n- 参数:\n- a: 第一个整数。\n- b: 第二个整数。\n- c: 第三个整数。\n\n- 返回: 一个整数，即 (a+b) 和 c 的乘积。\n\n### 示例:\ncalculateProductOfSumAndValue(1, 2, 3) // 返回 9，因为 (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // 返回 -9，因为 (-1-2)*-3 = 9",
      "fr": "Calcule le produit de la somme des deux premiers entiers et du troisième entier.\n\nCette fonction prend trois entiers en entrée et calcule le produit de la somme des deux premiers entiers (a et b) et du troisième entier (c), calculant effectivement (a+b)*c.\n\n- Paramètres:\n- a: Le premier entier.\n- b: Le deuxième entier.\n- c: Le troisième entier.\n\n- Retourne: Un entier qui est le produit de (a+b) et c.\n\n### Exemple:\ncalculateProductOfSumAndValue(1, 2, 3) // Retourne 9 car (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Retourne -9 car (-1-2)*-3 = 9",
      "de": "Berechnet das Produkt der Summe der ersten beiden ganzen Zahlen und der dritten ganzen Zahl.\n\nDiese Funktion nimmt drei ganze Zahlen als Eingabe und berechnet das Produkt der Summe der ersten beiden ganzen Zahlen (a und b) und der dritten ganzen Zahl (c), indem sie effektiv (a+b)*c berechnet.\n\n- Parameter:\n- a: Die erste ganze Zahl.\n- b: Die zweite ganze Zahl.\n- c: Die dritte ganze Zahl.\n\n- Rückgabewert: Eine ganze Zahl, die das Produkt von (a+b) und c ist.\n\n### Beispiel:\ncalculateProductOfSumAndValue(1, 2, 3) // Gibt 9 zurück, weil (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Gibt -9 zurück, weil (-1-2)*-3 = 9",
      "ha": "Yana lissafin samfurin jumlar lambobin farko biyu da lamba ta uku.\n\nWannan aikin yana karɓar lambobi guda uku a matsayin shigarwa kuma yana lissafin samfurin jumlar lambobin farko biyu (a da b) da lamba ta uku (c), wanda ke lissafin (a+b)*c.\n\n- Sigogi:\n- a: Lamba ta farko.\n- b: Lamba ta biyu.\n- c: Lamba ta uku.\n\n- Yana dawowa: Lamba ce wadda ita ce samfurin (a+b) da c.\n\n### Misali:\ncalculateProductOfSumAndValue(1, 2, 3) // Yana dawowa 9 saboda (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Yana dawowa -9 saboda (-1-2)*-3 = 9",
      "hi": "पहले दो पूर्णांकों के योग और तीसरे पूर्णांक के गुणनफल की गणना करता है।\n\nयह फ़ंक्शन तीन पूर्णांकों को इनपुट के रूप में लेता है और पहले दो पूर्णांकों (a और b) के योग और तीसरे पूर्णांक (c) के गुणनफल की गणना करता है, प्रभावी रूप से (a+b)*c की गणना करता है।\n\n- पैरामीटर्स:\n- a: पहला पूर्णांक।\n- b: दूसरा पूर्णांक।\n- c: तीसरा पूर्णांक।\n\n- रिटर्न करता है: एक पूर्णांक जो (a+b) और c का गुणनफल है।\n\n### उदाहरण:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 रिटर्न करता है क्योंकि (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 रिटर्न करता है क्योंकि (-1-2)*-3 = 9",
      "hu": "Kiszámítja az első két egész szám összegének és a harmadik egész számnak a szorzatát.\n\nEz a függvény három egész számot vesz be bemenetként, és kiszámítja az első két egész szám (a és b) összegének és a harmadik egész számnak (c) a szorzatát, ténylegesen kiszámítva (a+b)*c.\n\n- Paraméterek:\n- a: Az első egész szám.\n- b: A második egész szám.\n- c: A harmadik egész szám.\n\n- Visszatér: Egy egész szám, amely az (a+b) és c szorzata.\n\n### Példa:\ncalculateProductOfSumAndValue(1, 2, 3) // 9-et ad vissza, mert (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9-et ad vissza, mert (-1-2)*-3 = 9"
    },
    "docstring_bertscore": {
      "sq": "0.9936809716881371",
      "hy": "0.9925620867517676",
      "bn": "0.9665830205858336",
      "bg": "0.9911430713096543",
      "zh": "0.9852326256915802",
      "fr": "0.9924981277690743",
      "de": "0.983022465441805",
      "ha": "0.959332813047679",
      "hi": "0.9842484121535523",
      "hu": "0.992627237516747"
    }
  },
  {
    "task_id": "Swift/42",
    "prompt": {
      "en": "func asciiCode(of character: Character) -> Int {\n    /**\n    Returns the ASCII code of the given character.\n\n    This function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n    - Parameter character: A `Character` value representing a visible character (excluding space).\n\n    - Returns: An `Int` representing the ASCII code of the given character.\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "sq": "func asciiCode(of character: Character) -> Int {\n    /**\n    Kthen kodin ASCII të karakterit të dhënë.\n\n    Kjo funksion merr një karakter të vetëm (përjashtuar hapësirën) si input dhe kthen kodin e tij ASCII si një numër i plotë. Vlera ASCII përcaktohet bazuar në përfaqësimin e karakterit në tabelën ASCII.\n\n    - Parametri karakter: Një vlerë `Character` që përfaqëson një karakter të dukshëm (përjashtuar hapësirën).\n\n    - Kthen: Një `Int` që përfaqëson kodin ASCII të karakterit të dhënë.\n\n    ### Shembull:\n    asciiCode(of: \"A\") // Kthen 65\n    asciiCode(of: \"a\") // Kthen 97\n    */",
      "hy": "func asciiCode(of character: Character) -> Int {\n    /**\n    Վերադարձնում է տրված սիմվոլի ASCII կոդը։\n\n    Այս ֆունկցիան ընդունում է մեկ սիմվոլ (բացառելով բացատը) որպես մուտք և վերադարձնում է նրա ASCII կոդը որպես ամբողջ թիվ։ ASCII արժեքը որոշվում է սիմվոլի ներկայացման հիման վրա ASCII աղյուսակում։\n\n    - Պարամետր character: `Character` արժեք, որը ներկայացնում է տեսանելի սիմվոլ (բացառելով բացատը)։\n\n    - Վերադարձնում է: `Int`, որը ներկայացնում է տրված սիմվոլի ASCII կոդը։\n\n    ### Օրինակ:\n    asciiCode(of: \"A\") // Վերադարձնում է 65\n    asciiCode(of: \"a\") // Վերադարձնում է 97\n    */",
      "bn": "func asciiCode(of character: Character) -> Int {\n    /**\n    প্রদত্ত অক্ষরের ASCII কোড প্রদান করে।\n\n    এই ফাংশনটি একটি একক অক্ষর (স্পেস বাদে) ইনপুট হিসেবে গ্রহণ করে এবং তার ASCII কোড একটি পূর্ণসংখ্যা হিসেবে প্রদান করে। ASCII মানটি ASCII টেবিলে অক্ষরের উপস্থাপনার উপর ভিত্তি করে নির্ধারিত হয়।\n\n    - Parameter character: একটি `Character` মান যা একটি দৃশ্যমান অক্ষরকে উপস্থাপন করে (স্পেস বাদে)।\n\n    - Returns: একটি `Int` যা প্রদত্ত অক্ষরের ASCII কোড উপস্থাপন করে।\n\n    ### উদাহরণ:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "bg": "func asciiCode(of character: Character) -> Int {\n    /**\n    Връща ASCII кода на дадения символ.\n\n    Тази функция приема един символ (без интервал) като вход и връща неговия ASCII код като цяло число. ASCII стойността се определя въз основа на представянето на символа в ASCII таблицата.\n\n    - Параметър character: Стойност от тип `Character`, представляваща видим символ (без интервал).\n\n    - Връща: `Int`, представляващ ASCII кода на дадения символ.\n\n    ### Пример:\n    asciiCode(of: \"A\") // Връща 65\n    asciiCode(of: \"a\") // Връща 97\n    */",
      "zh": "func asciiCode(of character: Character) -> Int {\n    /**\n    返回给定字符的ASCII码。\n\n    此函数接受一个单个字符（不包括空格）作为输入，并返回其ASCII码作为整数。ASCII值是根据字符在ASCII表中的表示确定的。\n\n    - 参数 character: 一个 `Character` 值，表示一个可见字符（不包括空格）。\n\n    - 返回: 一个 `Int`，表示给定字符的ASCII码。\n\n    ### 示例:\n    asciiCode(of: \"A\") // 返回 65\n    asciiCode(of: \"a\") // 返回 97\n    */",
      "fr": "func asciiCode(of character: Character) -> Int {\n    /**\n    Renvoie le code ASCII du caractère donné.\n\n    Cette fonction prend un seul caractère (à l'exclusion de l'espace) en entrée et renvoie son code ASCII sous forme d'entier. La valeur ASCII est déterminée en fonction de la représentation du caractère dans la table ASCII.\n\n    - Paramètre character: Une valeur `Character` représentant un caractère visible (à l'exclusion de l'espace).\n\n    - Renvoie: Un `Int` représentant le code ASCII du caractère donné.\n\n    ### Exemple:\n    asciiCode(of: \"A\") // Renvoie 65\n    asciiCode(of: \"a\") // Renvoie 97\n    */",
      "de": "func asciiCode(of character: Character) -> Int {\n    /**\n    Gibt den ASCII-Code des angegebenen Zeichens zurück.\n\n    Diese Funktion nimmt ein einzelnes Zeichen (ohne Leerzeichen) als Eingabe und gibt dessen ASCII-Code als Ganzzahl zurück. Der ASCII-Wert wird basierend auf der Darstellung des Zeichens in der ASCII-Tabelle bestimmt.\n\n    - Parameter character: Ein `Character`-Wert, der ein sichtbares Zeichen (ohne Leerzeichen) darstellt.\n\n    - Rückgabe: Ein `Int`, der den ASCII-Code des angegebenen Zeichens darstellt.\n\n    ### Beispiel:\n    asciiCode(of: \"A\") // Gibt 65 zurück\n    asciiCode(of: \"a\") // Gibt 97 zurück\n    */",
      "ha": "func asciiCode(of character: Character) -> Int {\n    /**\n    Yana mayar da lambar ASCII na harafin da aka bayar.\n\n    Wannan aikin yana karɓar harafi guda ɗaya (ban da sarari) azaman shigarwa kuma yana mayar da lambar ASCII ɗinsa azaman cikakken lamba. Ana ƙayyade ƙimar ASCII bisa wakilcin harafin a cikin teburin ASCII.\n\n    - Ma'aunin harafi: Ƙimar `Character` da ke wakiltar harafi mai gani (ban da sarari).\n\n    - Yana mayar da: `Int` da ke wakiltar lambar ASCII na harafin da aka bayar.\n\n    ### Misali:\n    asciiCode(of: \"A\") // Yana mayar da 65\n    asciiCode(of: \"a\") // Yana mayar da 97\n    */",
      "hi": "func asciiCode(of character: Character) -> Int {\n    /**\n    दिए गए वर्ण का ASCII कोड लौटाता है।\n\n    यह फ़ंक्शन एकल वर्ण (स्पेस को छोड़कर) को इनपुट के रूप में लेता है और उसके ASCII कोड को पूर्णांक के रूप में लौटाता है। ASCII मान ASCII तालिका में वर्ण के प्रतिनिधित्व के आधार पर निर्धारित किया जाता है।\n\n    - Parameter character: एक `Character` मान जो एक दृश्य वर्ण का प्रतिनिधित्व करता है (स्पेस को छोड़कर)।\n\n    - Returns: एक `Int` जो दिए गए वर्ण का ASCII कोड दर्शाता है।\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "hu": "func asciiCode(of character: Character) -> Int {\n    /**\n    Visszaadja a megadott karakter ASCII kódját.\n\n    Ez a függvény egyetlen karaktert (kivéve a szóközt) vesz be bemenetként, és visszaadja annak ASCII kódját egész számként. Az ASCII érték a karakter ASCII táblázatbeli ábrázolása alapján kerül meghatározásra.\n\n    - Parameter character: Egy `Character` érték, amely egy látható karaktert képvisel (kivéve a szóközt).\n\n    - Returns: Egy `Int`, amely a megadott karakter ASCII kódját képviseli.\n\n    ### Példa:\n    asciiCode(of: \"A\") // 65-öt ad vissza\n    asciiCode(of: \"a\") // 97-et ad vissza\n    */"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9876026833980885",
      "bn": "0.985065974801892",
      "bg": "0.9712949304847431",
      "zh": "0.9967772220677089",
      "fr": "1",
      "de": "0.9785578503672838",
      "ha": "0.9983990391288589",
      "hi": "0.9942174723473123",
      "hu": "1"
    },
    "canonical_solution": "    return Int(character.asciiValue!)\n}",
    "instruction": {
      "en": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nনিম্নলিখিত Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nПредоставете кратко описание на естествен език (docstring) на Swift кода на български, използвайки не повече от 500 символа.",
      "zh": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9229242614647462",
      "bn": "0.8733351936874811",
      "bg": "0.9346778170017236",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9217926641839904",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testAsciiCode() {\n    assert(asciiCode(of: \"A\") == 65, \"Test Case 1 Failed\")\n    assert(asciiCode(of: \"a\") == 97, \"Test Case 2 Failed\")\n    assert(asciiCode(of: \"0\") == 48, \"Test Case 3 Failed\")\n    assert(asciiCode(of: \"#\") == 35, \"Test Case 4 Failed\")\n    assert(asciiCode(of: \"Z\") == 90, \"Test Case 5 Failed\")\n    assert(asciiCode(of: \"z\") == 122, \"Test Case 6 Failed\")\n}\n\ntestAsciiCode()",
    "entry_point": "asciiCode",
    "signature": "func asciiCode(of character: Character) -> Int {",
    "docstring": {
      "en": "\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n",
      "sq": "Kthen kodin ASCII të karakterit të dhënë.\n\nKjo funksion merr një karakter të vetëm (përjashtuar hapësirën) si hyrje dhe kthen kodin e tij ASCII si një numër i plotë. Vlera ASCII përcaktohet bazuar në përfaqësimin e karakterit në tabelën ASCII.\n\n- Parametri karakter: Një vlerë `Character` që përfaqëson një karakter të dukshëm (përjashtuar hapësirën).\n\n- Kthen: Një `Int` që përfaqëson kodin ASCII të karakterit të dhënë.\n\n### Shembull:\nasciiCode(of: \"A\") // Kthen 65\nasciiCode(of: \"a\") // Kthen 97",
      "hy": "Վերադարձնում է տրված նիշի ASCII կոդը։\n\nԱյս ֆունկցիան ընդունում է մեկ նիշ (բացառությամբ բացատ) որպես մուտք և վերադարձնում է դրա ASCII կոդը որպես ամբողջ թիվ։ ASCII արժեքը որոշվում է նիշի ներկայացմամբ ASCII աղյուսակում։\n\n- Պարամետր character: `Character` արժեք, որը ներկայացնում է տեսանելի նիշ (բացառությամբ բացատ)։\n\n- Վերադարձնում է: `Int`, որը ներկայացնում է տրված նիշի ASCII կոդը։\n\n### Օրինակ:\nasciiCode(of: \"A\") // Վերադարձնում է 65\nasciiCode(of: \"a\") // Վերադարձնում է 97",
      "bn": "প্রদত্ত অক্ষরের ASCII কোড প্রদান করে।\n\nএই ফাংশনটি একটি একক অক্ষর (স্পেস বাদে) ইনপুট হিসেবে গ্রহণ করে এবং এর ASCII কোড একটি পূর্ণসংখ্যা হিসেবে প্রদান করে। ASCII মানটি ASCII টেবিলে অক্ষরের উপস্থাপনার উপর ভিত্তি করে নির্ধারিত হয়।\n\n- প্যারামিটার character: একটি `Character` মান যা একটি দৃশ্যমান অক্ষরকে উপস্থাপন করে (স্পেস বাদে)।\n\n- রিটার্নস: একটি `Int` যা প্রদত্ত অক্ষরের ASCII কোড উপস্থাপন করে।\n\n### উদাহরণ:\nasciiCode(of: \"A\") // 65 প্রদান করে\nasciiCode(of: \"a\") // 97 প্রদান করে",
      "bg": "Връща ASCII кода на дадения символ.\n\nТази функция приема един символ (без интервал) като вход и връща неговия ASCII код като цяло число. ASCII стойността се определя въз основа на представянето на символа в ASCII таблицата.\n\n- Параметър character: Стойност от тип `Character`, представляваща видим символ (без интервал).\n\n- Връща: `Int`, представляващ ASCII кода на дадения символ.\n\n### Пример:\nasciiCode(of: \"A\") // Връща 65\nasciiCode(of: \"a\") // Връща 97",
      "zh": "返回给定字符的ASCII码。\n\n此函数接受一个单字符（不包括空格）作为输入，并返回其ASCII码作为整数。ASCII值是根据字符在ASCII表中的表示来确定的。\n\n- 参数 character: 一个 `Character` 值，表示一个可见字符（不包括空格）。\n\n- 返回: 一个 `Int`，表示给定字符的ASCII码。\n\n### 示例:\nasciiCode(of: \"A\") // 返回 65\nasciiCode(of: \"a\") // 返回 97",
      "fr": "Retourne le code ASCII du caractère donné.\n\nCette fonction prend un seul caractère (à l'exclusion de l'espace) en entrée et retourne son code ASCII sous forme d'entier. La valeur ASCII est déterminée en fonction de la représentation du caractère dans la table ASCII.\n\n- Paramètre character: Une valeur `Character` représentant un caractère visible (à l'exclusion de l'espace).\n\n- Retourne: Un `Int` représentant le code ASCII du caractère donné.\n\n### Exemple:\nasciiCode(of: \"A\") // Retourne 65\nasciiCode(of: \"a\") // Retourne 97",
      "de": "Gibt den ASCII-Code des angegebenen Zeichens zurück.\n\nDiese Funktion nimmt ein einzelnes Zeichen (ohne Leerzeichen) als Eingabe und gibt dessen ASCII-Code als Ganzzahl zurück. Der ASCII-Wert wird basierend auf der Darstellung des Zeichens in der ASCII-Tabelle bestimmt.\n\n- Parameter character: Ein `Character`-Wert, der ein sichtbares Zeichen (ohne Leerzeichen) darstellt.\n\n- Rückgabe: Ein `Int`, der den ASCII-Code des angegebenen Zeichens darstellt.\n\n### Beispiel:\nasciiCode(of: \"A\") // Gibt 65 zurück\nasciiCode(of: \"a\") // Gibt 97 zurück",
      "ha": "Yana dawo da lambar ASCII na harafin da aka bayar.\n\nWannan aikin yana ɗaukar harafi guda ɗaya (ban da sarari) a matsayin shigarwa kuma yana dawo da lambar ASCII a matsayin cikakken lamba. Ana ƙayyade ƙimar ASCII bisa wakilcin harafin a cikin teburin ASCII.\n\n- Ma'aunin character: Ƙimar `Character` da ke wakiltar harafi mai gani (ban da sarari).\n\n- Yana dawowa: `Int` da ke wakiltar lambar ASCII na harafin da aka bayar.\n\n### Misali:\nasciiCode(of: \"A\") // Yana dawowa 65\nasciiCode(of: \"a\") // Yana dawowa 97",
      "hi": "दिए गए वर्ण का ASCII कोड लौटाता है।\n\nयह फ़ंक्शन एकल वर्ण (स्पेस को छोड़कर) को इनपुट के रूप में लेता है और उसके ASCII कोड को पूर्णांक के रूप में लौटाता है। ASCII मान वर्ण की ASCII तालिका में प्रस्तुति के आधार पर निर्धारित होता है।\n\n- पैरामीटर character: एक `Character` मान जो एक दृश्य वर्ण (स्पेस को छोड़कर) का प्रतिनिधित्व करता है।\n\n- रिटर्न करता है: एक `Int` जो दिए गए वर्ण का ASCII कोड दर्शाता है।\n\n### उदाहरण:\nasciiCode(of: \"A\") // 65 लौटाता है\nasciiCode(of: \"a\") // 97 लौटाता है",
      "hu": "Visszaadja a megadott karakter ASCII kódját.\n\nEz a függvény egyetlen karaktert (kivéve a szóközt) vesz be bemenetként, és visszaadja annak ASCII kódját egész számként. Az ASCII értéket a karakter ASCII táblázatbeli ábrázolása alapján határozzuk meg.\n\n- Paraméter karakter: Egy `Character` érték, amely egy látható karaktert képvisel (kivéve a szóközt).\n\n- Visszatér: Egy `Int`, amely a megadott karakter ASCII kódját képviseli.\n\n### Példa:\nasciiCode(of: \"A\") // Visszatér 65\nasciiCode(of: \"a\") // Visszatér 97"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9848685362031433",
      "bn": "0.9876892862442197",
      "bg": "0.979276296455487",
      "zh": "0.996088769167042",
      "fr": "1",
      "de": "0.9740864818598075",
      "ha": "0.9794495021477494",
      "hi": "0.7681886124436148",
      "hu": "1"
    }
  },
  {
    "task_id": "Swift/43",
    "prompt": {
      "en": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Returns the character corresponding to the given ASCII code.\n\n    This function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n    - Parameter code: An `Int` value representing the ASCII code.\n\n    - Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n    ### Example:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "sq": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Kthen karakterin që korrespondon me kodin e dhënë ASCII.\n\n    Kjo funksion merr një numër të plotë që përfaqëson një kod ASCII dhe kthen karakterin përkatës. Funksioni siguron që kodi i futur është brenda intervalit të karaktereve të printueshme ASCII (më i madh se 0 dhe më i vogël se 128).\n\n    - Parametri code: Një vlerë `Int` që përfaqëson kodin ASCII.\n\n    - Kthen: Një `Character?` që përfaqëson karakterin përkatës nëse kodi është brenda intervalit të printueshëm ASCII; përndryshe, `nil`.\n\n    ### Shembull:\n    characterForAsciiCode(65) // Kthen \"A\"\n    characterForAsciiCode(97) // Kthen \"a\"\n    */",
      "hy": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Վերադարձնում է տրված ASCII կոդին համապատասխանող սիմվոլը:\n\n    Այս ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ASCII կոդը և վերադարձնում է համապատասխան սիմվոլը: Ֆունկցիան ապահովում է, որ մուտքային կոդը գտնվում է տպվող ASCII սիմվոլների տիրույթում (ավելի մեծ է 0-ից և փոքր է 128-ից):\n\n    - Պարամետր code: `Int` արժեք, որը ներկայացնում է ASCII կոդը:\n\n    - Վերադարձնում է: `Character?`, որը ներկայացնում է համապատասխան սիմվոլը, եթե կոդը գտնվում է տպվող ASCII տիրույթում; հակառակ դեպքում՝ `nil`:\n\n    ### Օրինակ:\n    characterForAsciiCode(65) // Վերադարձնում է \"A\"\n    characterForAsciiCode(97) // Վերադարձնում է \"a\"\n    */",
      "bn": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    প্রদত্ত ASCII কোডের সাথে সম্পর্কিত অক্ষরটি ফেরত দেয়।\n\n    এই ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা একটি ASCII কোডকে উপস্থাপন করে এবং সম্পর্কিত অক্ষরটি ফেরত দেয়। ফাংশনটি নিশ্চিত করে যে ইনপুট কোডটি মুদ্রণযোগ্য ASCII অক্ষরের পরিসরের মধ্যে রয়েছে (0 এর চেয়ে বড় এবং 128 এর চেয়ে ছোট)।\n\n    - Parameter code: একটি `Int` মান যা ASCII কোডকে উপস্থাপন করে।\n\n    - Returns: একটি `Character?` যা মুদ্রণযোগ্য ASCII পরিসরের মধ্যে কোড থাকলে সম্পর্কিত অক্ষরটি উপস্থাপন করে; অন্যথায়, `nil`।\n\n    ### Example:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "bg": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Връща символа, съответстващ на дадения ASCII код.\n\n    Тази функция приема цяло число, представляващо ASCII код, и връща съответния символ. Функцията гарантира, че входният код е в рамките на диапазона на печатните ASCII символи (по-голям от 0 и по-малък от 128).\n\n    - Параметър code: Стойност от тип `Int`, представляваща ASCII код.\n\n    - Връща: `Character?`, представляващ съответния символ, ако кодът е в рамките на печатния ASCII диапазон; в противен случай `nil`.\n\n    ### Пример:\n    characterForAsciiCode(65) // Връща \"A\"\n    characterForAsciiCode(97) // Връща \"a\"\n    */",
      "zh": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    返回与给定ASCII码对应的字符。\n\n    此函数接受一个表示ASCII码的整数，并返回对应的字符。函数确保输入代码在可打印的ASCII字符范围内（大于0且小于128）。\n\n    - 参数 code: 一个表示ASCII码的 `Int` 值。\n\n    - 返回: 一个 `Character?`，如果代码在可打印的ASCII范围内，则返回对应的字符；否则返回 `nil`。\n\n    ### 示例:\n    characterForAsciiCode(65) // 返回 \"A\"\n    characterForAsciiCode(97) // 返回 \"a\"\n    */",
      "fr": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Renvoie le caractère correspondant au code ASCII donné.\n\n    Cette fonction prend un entier représentant un code ASCII et renvoie le caractère correspondant. La fonction s'assure que le code d'entrée est dans la plage des caractères ASCII imprimables (supérieur à 0 et inférieur à 128).\n\n    - Parameter code: Une valeur `Int` représentant le code ASCII.\n\n    - Returns: Un `Character?` représentant le caractère correspondant si le code est dans la plage ASCII imprimable ; sinon, `nil`.\n\n    ### Exemple:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "de": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Gibt das Zeichen zurück, das dem angegebenen ASCII-Code entspricht.\n\n    Diese Funktion nimmt eine Ganzzahl, die einen ASCII-Code darstellt, und gibt das entsprechende Zeichen zurück. Die Funktion stellt sicher, dass der Eingabecode innerhalb des Bereichs der druckbaren ASCII-Zeichen liegt (größer als 0 und kleiner als 128).\n\n    - Parameter code: Ein `Int`-Wert, der den ASCII-Code darstellt.\n\n    - Rückgabe: Ein `Character?`, der das entsprechende Zeichen darstellt, wenn der Code innerhalb des druckbaren ASCII-Bereichs liegt; andernfalls `nil`.\n\n    ### Beispiel:\n    characterForAsciiCode(65) // Gibt \"A\" zurück\n    characterForAsciiCode(97) // Gibt \"a\" zurück\n    */",
      "ha": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Yana mayar da harafin da ya dace da lambar ASCII da aka bayar.\n\n    Wannan aikin yana daukar lamba mai nuna lambar ASCII kuma yana mayar da harafin da ya dace. Aikin yana tabbatar da cewa lambar da aka shigar tana cikin kewayon haruffan ASCII masu bugawa (fiye da 0 kuma kasa da 128).\n\n    - Ma'auni code: Darajar `Int` mai nuna lambar ASCII.\n\n    - Yana Mayarwa: `Character?` mai nuna harafin da ya dace idan lambar tana cikin kewayon ASCII mai bugawa; in ba haka ba, `nil`.\n\n    ### Misali:\n    characterForAsciiCode(65) // Yana Mayar da \"A\"\n    characterForAsciiCode(97) // Yana Mayar da \"a\"\n    */",
      "hi": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    दिए गए ASCII कोड के अनुरूप वर्ण लौटाता है।\n\n    यह फ़ंक्शन एक पूर्णांक लेता है जो एक ASCII कोड का प्रतिनिधित्व करता है और संबंधित वर्ण लौटाता है। यह फ़ंक्शन सुनिश्चित करता है कि इनपुट कोड प्रिंट करने योग्य ASCII वर्णों की सीमा के भीतर है (0 से अधिक और 128 से कम)।\n\n    - Parameter code: एक `Int` मान जो ASCII कोड का प्रतिनिधित्व करता है।\n\n    - Returns: एक `Character?` जो प्रिंट करने योग्य ASCII सीमा के भीतर कोड होने पर संबंधित वर्ण का प्रतिनिधित्व करता है; अन्यथा, `nil`।\n\n    ### उदाहरण:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "hu": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Visszaadja a megadott ASCII kódnak megfelelő karaktert.\n\n    Ez a függvény egy egész számot vesz át, amely egy ASCII kódot képvisel, és visszaadja a megfelelő karaktert. A függvény biztosítja, hogy a bemeneti kód a nyomtatható ASCII karakterek tartományán belül legyen (nagyobb mint 0 és kisebb mint 128).\n\n    - Paraméter code: Egy `Int` érték, amely az ASCII kódot képviseli.\n\n    - Visszatérési érték: Egy `Character?`, amely a megfelelő karaktert képviseli, ha a kód a nyomtatható ASCII tartományon belül van; ellenkező esetben `nil`.\n\n    ### Példa:\n    characterForAsciiCode(65) // Visszaadja \"A\"\n    characterForAsciiCode(97) // Visszaadja \"a\"\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9939169445808066",
      "hy": "0.9856602769019484",
      "bn": "0.9873742584598983",
      "bg": "0.9815098950902243",
      "zh": "0.9725318018674474",
      "fr": "0.9979483467942907",
      "de": "0.9917624008377212",
      "ha": "0.9929905324836599",
      "hi": "0.9988725739572459",
      "hu": "0.9954956588492718"
    },
    "canonical_solution": "    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}",
    "instruction": {
      "en": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），最多使用500个字符。",
      "fr": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Swift a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8679241048473287",
      "bg": "0.840216358475248",
      "zh": "0.8683384478221675",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9165571646006728",
      "hi": "0.9102601842611048",
      "hu": "0.940857605416481"
    },
    "level": "",
    "test": "func testCharacterForAsciiCode() {\n    assert(characterForAsciiCode(65) == \"A\", \"Test Case 1 Failed\")\n    assert(characterForAsciiCode(97) == \"a\", \"Test Case 2 Failed\")\n    assert(characterForAsciiCode(48) == \"0\", \"Test Case 3 Failed\")\n    assert(characterForAsciiCode(35) == \"#\", \"Test Case 4 Failed\")\n    assert(characterForAsciiCode(90) == \"Z\", \"Test Case 5 Failed\")\n    assert(characterForAsciiCode(122) == \"z\", \"Test Case 6 Failed\")\n}\n\ntestCharacterForAsciiCode()",
    "entry_point": "characterForAsciiCode",
    "signature": "func characterForAsciiCode(_ code: Int) -> Character? {",
    "docstring": {
      "en": "\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n",
      "sq": "Kthen karakterin që korrespondon me kodin e dhënë ASCII.\n\nKjo funksion merr një numër të plotë që përfaqëson një kod ASCII dhe kthen karakterin përkatës. Funksioni siguron që kodi i hyrjes është brenda intervalit të karaktereve të printueshme ASCII (më i madh se 0 dhe më i vogël se 128).\n\n- Parametri code: Një vlerë `Int` që përfaqëson kodin ASCII.\n\n- Kthen: Një `Character?` që përfaqëson karakterin përkatës nëse kodi është brenda intervalit të karaktereve të printueshme ASCII; përndryshe, `nil`.\n\n### Shembull:\ncharacterForAsciiCode(65) // Kthen \"A\"\ncharacterForAsciiCode(97) // Kthen \"a\"",
      "hy": "Վերադարձնում է տրված ASCII կոդին համապատասխանող սիմվոլը։\n\nԱյս ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ASCII կոդը և վերադարձնում է համապատասխան սիմվոլը։ Ֆունկցիան ապահովում է, որ մուտքագրված կոդը լինի տպվող ASCII սիմվոլների տիրույթում (ավելի մեծ քան 0 և ավելի փոքր քան 128)։\n\n- Պարամետր code: `Int` արժեք, որը ներկայացնում է ASCII կոդը։\n\n- Վերադարձնում է: `Character?`, որը ներկայացնում է համապատասխան սիմվոլը, եթե կոդը գտնվում է տպվող ASCII տիրույթում; հակառակ դեպքում՝ `nil`։\n\n### Օրինակ:\ncharacterForAsciiCode(65) // Վերադարձնում է \"A\"\ncharacterForAsciiCode(97) // Վերադարձնում է \"a\"",
      "bn": "প্রদত্ত ASCII কোডের সাথে সম্পর্কিত চরিত্রটি ফেরত দেয়।\n\nএই ফাংশনটি একটি পূর্ণসংখ্যা গ্রহণ করে যা একটি ASCII কোডকে উপস্থাপন করে এবং সংশ্লিষ্ট চরিত্রটি ফেরত দেয়। ফাংশনটি নিশ্চিত করে যে ইনপুট কোডটি মুদ্রণযোগ্য ASCII চরিত্রগুলির পরিসরের মধ্যে রয়েছে (0 এর চেয়ে বড় এবং 128 এর চেয়ে ছোট)।\n\n- প্যারামিটার কোড: একটি `Int` মান যা ASCII কোডকে উপস্থাপন করে।\n\n- রিটার্নস: একটি `Character?` যা সংশ্লিষ্ট চরিত্রটি উপস্থাপন করে যদি কোডটি মুদ্রণযোগ্য ASCII পরিসরের মধ্যে থাকে; অন্যথায়, `nil`।\n\n### উদাহরণ:\ncharacterForAsciiCode(65) // \"A\" ফেরত দেয়\ncharacterForAsciiCode(97) // \"a\" ফেরত দেয়",
      "bg": "Връща символа, съответстващ на дадения ASCII код.\n\nТази функция приема цяло число, представляващо ASCII код, и връща съответния символ. Функцията гарантира, че входният код е в диапазона на печатаемите ASCII символи (по-голям от 0 и по-малък от 128).\n\n- Параметър code: Стойност от тип `Int`, представляваща ASCII кода.\n\n- Връща: `Character?`, представляващ съответния символ, ако кодът е в диапазона на печатаемите ASCII символи; в противен случай, `nil`.\n\n### Пример:\ncharacterForAsciiCode(65) // Връща \"A\"\ncharacterForAsciiCode(97) // Връща \"a\"",
      "zh": "返回与给定ASCII码对应的字符。\n\n此函数接受一个表示ASCII码的整数，并返回对应的字符。该函数确保输入的代码在可打印的ASCII字符范围内（大于0且小于128）。\n\n- 参数 code: 一个表示ASCII码的 `Int` 值。\n\n- 返回: 如果代码在可打印的ASCII范围内，返回对应的 `Character?`；否则返回 `nil`。\n\n### 示例:\ncharacterForAsciiCode(65) // 返回 \"A\"\ncharacterForAsciiCode(97) // 返回 \"a\"",
      "fr": "Retourne le caractère correspondant au code ASCII donné.\n\nCette fonction prend un entier représentant un code ASCII et retourne le caractère correspondant. La fonction s'assure que le code d'entrée est dans la plage des caractères ASCII imprimables (supérieur à 0 et inférieur à 128).\n\n- Paramètre code : Une valeur `Int` représentant le code ASCII.\n\n- Retourne : Un `Character?` représentant le caractère correspondant si le code est dans la plage des caractères ASCII imprimables ; sinon, `nil`.\n\n### Exemple :\ncharacterForAsciiCode(65) // Retourne \"A\"\ncharacterForAsciiCode(97) // Retourne \"a\"",
      "de": "Gibt das Zeichen zurück, das dem angegebenen ASCII-Code entspricht.\n\nDiese Funktion nimmt eine Ganzzahl, die einen ASCII-Code darstellt, und gibt das entsprechende Zeichen zurück. Die Funktion stellt sicher, dass der Eingabecode innerhalb des Bereichs der druckbaren ASCII-Zeichen liegt (größer als 0 und kleiner als 128).\n\n- Parameter code: Ein `Int`-Wert, der den ASCII-Code darstellt.\n\n- Rückgabe: Ein `Character?`, das das entsprechende Zeichen darstellt, wenn der Code innerhalb des druckbaren ASCII-Bereichs liegt; andernfalls `nil`.\n\n### Beispiel:\ncharacterForAsciiCode(65) // Gibt \"A\" zurück\ncharacterForAsciiCode(97) // Gibt \"a\" zurück",
      "ha": "Yana dawowa da harafin da ya dace da lambar ASCII da aka bayar.\n\nWannan aikin yana ɗaukar lamba mai wakiltar lambar ASCII kuma yana dawowa da harafin da ya dace. Aikin yana tabbatar da cewa lambar shigarwa tana cikin kewayon haruffan ASCII masu bugawa (fiye da 0 kuma ƙasa da 128).\n\n- Ma'aunin code: Darajar `Int` da ke wakiltar lambar ASCII.\n\n- Yana dawowa: `Character?` da ke wakiltar harafin da ya dace idan lambar tana cikin kewayon haruffan ASCII masu bugawa; in ba haka ba, `nil`.\n\n### Misali:\ncharacterForAsciiCode(65) // Yana dawowa \"A\"\ncharacterForAsciiCode(97) // Yana dawowa \"a\"",
      "hi": "दिए गए ASCII कोड के अनुरूप वर्ण लौटाता है।\n\nयह फ़ंक्शन एक पूर्णांक लेता है जो एक ASCII कोड का प्रतिनिधित्व करता है और इसके अनुरूप वर्ण लौटाता है। यह फ़ंक्शन सुनिश्चित करता है कि इनपुट कोड प्रिंट करने योग्य ASCII वर्णों की सीमा के भीतर है (0 से अधिक और 128 से कम)।\n\n- पैरामीटर कोड: एक `Int` मान जो ASCII कोड का प्रतिनिधित्व करता है।\n\n- रिटर्न करता है: एक `Character?` जो प्रिंट करने योग्य ASCII सीमा के भीतर कोड होने पर संबंधित वर्ण का प्रतिनिधित्व करता है; अन्यथा, `nil`।\n\n### उदाहरण:\ncharacterForAsciiCode(65) // \"A\" लौटाता है\ncharacterForAsciiCode(97) // \"a\" लौटाता है",
      "hu": "Visszaadja a megadott ASCII kódnak megfelelő karaktert.\n\nEz a függvény egy egész számot vesz át, amely egy ASCII kódot képvisel, és visszaadja a megfelelő karaktert. A függvény biztosítja, hogy a bemeneti kód a nyomtatható ASCII karakterek tartományán belül legyen (nagyobb, mint 0 és kisebb, mint 128).\n\n- Paraméter kód: Egy `Int` érték, amely az ASCII kódot képviseli.\n\n- Visszatérési érték: Egy `Character?`, amely a megfelelő karaktert képviseli, ha a kód a nyomtatható ASCII tartományon belül van; ellenkező esetben `nil`.\n\n### Példa:\ncharacterForAsciiCode(65) // Visszaadja \"A\"\ncharacterForAsciiCode(97) // Visszaadja \"a\""
    },
    "docstring_bertscore": {
      "sq": "0.9939322391201463",
      "hy": "0.9848369539725587",
      "bn": "0.988891993201386",
      "bg": "0.9802255510464527",
      "zh": "0.8571525779141878",
      "fr": "0.9908771052294486",
      "de": "0.9897476928828842",
      "ha": "0.9696067708763276",
      "hi": "0.9903910566870563",
      "hu": "0.9828730953952668"
    }
  },
  {
    "task_id": "Swift/44",
    "prompt": {
      "en": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n    - Parameters:\n        - value: An integer value to be converted to boolean and back to integer.\n\n    - Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n    */",
      "sq": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Konverton një numër të plotë në një vlerë boolean dhe pastaj përsëri në një numër të plotë, dhe kthen vlerën rezultuese të numrit të plotë.\n\n    - Parametrat:\n        - value: Një vlerë e plotë që do të konvertohet në boolean dhe pastaj përsëri në numër të plotë.\n\n    - Kthen: Një vlerë e plotë pas konvertimit. Vlera e kthyer është 1 nëse numri i plotë origjinal ishte jo-zero; përndryshe, është 0.\n\n    ### Shembull:\n    - `convertIntToBoolToInt(5)` kthen `1`, sepse çdo numër i plotë jo-zero konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n    - `convertIntToBoolToInt(0)` kthen `0`, sepse `0` konvertohet në `false`, i cili pastaj konvertohet përsëri në `0`.\n    - `convertIntToBoolToInt(-10)` kthen `1`, sepse çdo numër i plotë jo-zero, duke përfshirë numrat negativë, konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n    */",
      "hy": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Փոխակերպում է ամբողջ թիվը բուլյան արժեքի, ապա նորից ամբողջ թվի և վերադարձնում է ստացված ամբողջ թիվը:\n\n    - Պարամետրեր:\n        - value: Ամբողջ թիվ, որը պետք է փոխակերպվի բուլյան արժեքի և նորից ամբողջ թվի:\n\n    - Վերադարձնում է: Ամբողջ թիվ՝ փոխակերպումից հետո: Վերադարձվող արժեքը 1 է, եթե սկզբնական ամբողջ թիվը զրոյից տարբեր է; հակառակ դեպքում՝ 0:\n\n    ### Օրինակ:\n    - `convertIntToBoolToInt(5)` վերադարձնում է `1`, քանի որ ցանկացած զրոյից տարբեր ամբողջ թիվ փոխակերպվում է `true`, որը հետո նորից փոխակերպվում է `1`:\n    - `convertIntToBoolToInt(0)` վերադարձնում է `0`, քանի որ `0` փոխակերպվում է `false`, որը հետո նորից փոխակերպվում է `0`:\n    - `convertIntToBoolToInt(-10)` վերադարձնում է `1`, քանի որ ցանկացած զրոյից տարբեր ամբողջ թիվ, ներառյալ բացասական թվերը, փոխակերպվում է `true`, որը հետո նորից փոխակերպվում է `1`:\n    */",
      "bn": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে এবং তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে, এবং ফলস্বরূপ পূর্ণসংখ্যার মানটি ফেরত দেয়।\n\n    - প্যারামিটার:\n        - value: একটি পূর্ণসংখ্যার মান যা বুলিয়ানে এবং পরে পূর্ণসংখ্যায় রূপান্তরিত হবে।\n\n    - রিটার্নস: রূপান্তরের পরে একটি পূর্ণসংখ্যার মান। যদি মূল পূর্ণসংখ্যাটি শূন্য না হয় তবে রিটার্ন মানটি 1 হয়; অন্যথায়, এটি 0 হয়।\n\n    ### উদাহরণ:\n    - `convertIntToBoolToInt(5)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।\n    - `convertIntToBoolToInt(0)` `0` ফেরত দেয়, কারণ `0` `false` তে রূপান্তরিত হয়, যা পরে `0` তে রূপান্তরিত হয়।\n    - `convertIntToBoolToInt(-10)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা, নেতিবাচক সংখ্যাসহ, `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।\n    */",
      "bg": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Преобразува цяло число в булева стойност и след това обратно в цяло число, и връща получената стойност като цяло число.\n\n    - Параметри:\n        - value: Цяло число, което трябва да бъде преобразувано в булева стойност и обратно в цяло число.\n\n    - Връща: Цяло число след преобразуването. Върнатата стойност е 1, ако оригиналното цяло число е било различно от нула; в противен случай е 0.\n\n    ### Пример:\n    - `convertIntToBoolToInt(5)` връща `1`, защото всяко ненулево цяло число се преобразува в `true`, което след това се преобразува обратно в `1`.\n    - `convertIntToBoolToInt(0)` връща `0`, защото `0` се преобразува в `false`, което след това се преобразува обратно в `0`.\n    - `convertIntToBoolToInt(-10)` връща `1`, защото всяко ненулево цяло число, включително отрицателните числа, се преобразува в `true`, което след това се преобразува обратно в `1`.\n    */",
      "zh": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    将整数转换为布尔值，然后再转换回整数，并返回转换后的整数值。\n\n    - 参数:\n        - value: 要转换为布尔值并再转换回整数的整数值。\n\n    - 返回: 转换后的整数值。如果原始整数为非零，则返回值为1；否则为0。\n\n    ### 示例:\n    - `convertIntToBoolToInt(5)` 返回 `1`，因为任何非零整数转换为 `true`，然后再转换回 `1`。\n    - `convertIntToBoolToInt(0)` 返回 `0`，因为 `0` 转换为 `false`，然后再转换回 `0`。\n    - `convertIntToBoolToInt(-10)` 返回 `1`，因为任何非零整数，包括负数，转换为 `true`，然后再转换回 `1`。\n    */",
      "fr": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Convertit un entier en booléen puis de nouveau en entier, et renvoie la valeur entière résultante.\n\n    - Paramètres :\n        - value: Une valeur entière à convertir en booléen puis de nouveau en entier.\n\n    - Renvoie : Une valeur entière après conversion. La valeur de retour est 1 si l'entier original était non nul ; sinon, c'est 0.\n\n    ### Exemple :\n    - `convertIntToBoolToInt(5)` renvoie `1`, car tout entier non nul se convertit en `true`, qui se convertit ensuite en `1`.\n    - `convertIntToBoolToInt(0)` renvoie `0`, car `0` se convertit en `false`, qui se convertit ensuite en `0`.\n    - `convertIntToBoolToInt(-10)` renvoie `1`, car tout entier non nul, y compris les nombres négatifs, se convertit en `true`, qui se convertit ensuite en `1`.\n    */",
      "de": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Konvertiert eine ganze Zahl in einen Booleschen Wert und dann zurück in eine ganze Zahl und gibt den resultierenden ganzzahligen Wert zurück.\n\n    - Parameter:\n        - value: Ein ganzzahliger Wert, der in einen Booleschen Wert und zurück in eine ganze Zahl konvertiert werden soll.\n\n    - Rückgabe: Ein ganzzahliger Wert nach der Konvertierung. Der Rückgabewert ist 1, wenn die ursprüngliche ganze Zahl ungleich null war; andernfalls ist er 0.\n\n    ### Beispiel:\n    - `convertIntToBoolToInt(5)` gibt `1` zurück, weil jede von null verschiedene ganze Zahl in `true` konvertiert, was dann zurück in `1` konvertiert wird.\n    - `convertIntToBoolToInt(0)` gibt `0` zurück, weil `0` in `false` konvertiert, was dann zurück in `0` konvertiert wird.\n    - `convertIntToBoolToInt(-10)` gibt `1` zurück, weil jede von null verschiedene ganze Zahl, einschließlich negativer Zahlen, in `true` konvertiert, was dann zurück in `1` konvertiert wird.\n    */",
      "ha": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Yana canza lamba mai cikakken adadi zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai cikakken adadi, kuma yana dawo da darajar lamba mai cikakken adadi da aka samu.\n\n    - Parameters:\n        - value: Wata lamba mai cikakken adadi da za a canza zuwa boolean sannan kuma a mayar da ita zuwa lamba mai cikakken adadi.\n\n    - Returns: Wata lamba mai cikakken adadi bayan canzawa. Darajar dawowa ita ce 1 idan asalin lambar mai cikakken adadi ba ta kasance sifili ba; in ba haka ba, ita ce 0.\n\n    ### Misali:\n    - `convertIntToBoolToInt(5)` yana dawowa `1`, saboda kowace lamba mai cikakken adadi da ba sifili ba tana canzawa zuwa `true`, wanda sannan kuma ya canza zuwa `1`.\n    - `convertIntToBoolToInt(0)` yana dawowa `0`, saboda `0` yana canzawa zuwa `false`, wanda sannan kuma ya canza zuwa `0`.\n    - `convertIntToBoolToInt(-10)` yana dawowa `1`, saboda kowace lamba mai cikakken adadi da ba sifili ba, ciki har da lambobi marasa kyau, tana canzawa zuwa `true`, wanda sannan kuma ya canza zuwa `1`.\n    */",
      "hi": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    एक पूर्णांक को एक बूलियन में और फिर एक पूर्णांक में परिवर्तित करता है, और परिणामी पूर्णांक मान लौटाता है।\n\n    - पैरामीटर्स:\n        - value: एक पूर्णांक मान जिसे बूलियन में और फिर पूर्णांक में परिवर्तित किया जाना है।\n\n    - रिटर्न्स: परिवर्तन के बाद एक पूर्णांक मान। यदि मूल पूर्णांक शून्य नहीं था तो रिटर्न मान 1 है; अन्यथा, यह 0 है।\n\n    ### उदाहरण:\n    - `convertIntToBoolToInt(5)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक `true` में परिवर्तित होता है, जो फिर `1` में परिवर्तित होता है।\n    - `convertIntToBoolToInt(0)` `0` लौटाता है, क्योंकि `0` `false` में परिवर्तित होता है, जो फिर `0` में परिवर्तित होता है।\n    - `convertIntToBoolToInt(-10)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक, जिसमें ऋणात्मक संख्याएँ शामिल हैं, `true` में परिवर्तित होता है, जो फिर `1` में परिवर्तित होता है।\n    */",
      "hu": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Egy egész számot logikai értékké, majd vissza egész számmá alakít, és visszaadja az eredményül kapott egész számot.\n\n    - Paraméterek:\n        - value: Egy egész szám, amelyet logikai értékké, majd vissza egész számmá kell alakítani.\n\n    - Visszatérési érték: Egy egész szám az átalakítás után. A visszatérési érték 1, ha az eredeti egész szám nem nulla volt; különben 0.\n\n    ### Példa:\n    - `convertIntToBoolToInt(5)` visszaadja `1`, mert bármely nem nulla egész szám `true`-vá alakul, ami aztán vissza `1`-é alakul.\n    - `convertIntToBoolToInt(0)` visszaadja `0`, mert `0` `false`-vá alakul, ami aztán vissza `0`-vá alakul.\n    - `convertIntToBoolToInt(-10)` visszaadja `1`, mert bármely nem nulla egész szám, beleértve a negatív számokat is, `true`-vá alakul, ami aztán vissza `1`-é alakul.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9734540427265924",
      "hy": "0.9764398546143088",
      "bn": "0.9653354231625534",
      "bg": "0.9673209324513782",
      "zh": "0.9566342206909391",
      "fr": "0.9845231179705236",
      "de": "0.9785665901040493",
      "ha": "0.9812727304152686",
      "hi": "0.9771541294645103",
      "hu": "0.9722338562958951"
    },
    "canonical_solution": "    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}",
    "instruction": {
      "en": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9535341963341276",
      "hy": "0.9229242614647462",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8512246528225825",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testConvertIntToBoolToInt() {\n    assert(convertIntToBoolToInt(5) == 1, \"Conversion of 5 should return 1.\")\n    assert(convertIntToBoolToInt(0) == 0, \"Conversion of 0 should return 0.\")\n    assert(convertIntToBoolToInt(-10) == 1, \"Conversion of -10 should return 1.\")\n    assert(convertIntToBoolToInt(1) == 1, \"Conversion of 1 should return 1.\")\n    assert(convertIntToBoolToInt(-1) == 1, \"Conversion of -1 should return 1.\")\n    assert(convertIntToBoolToInt(100) == 1, \"Conversion of 100 should return 1.\")\n    assert(convertIntToBoolToInt(-100) == 1, \"Conversion of -100 should return 1.\")\n}\n\n// Call the test function to verify the functionality\ntestConvertIntToBoolToInt()",
    "entry_point": "convertIntToBoolToInt",
    "signature": "func convertIntToBoolToInt(_ value: Int) -> Int {",
    "docstring": {
      "en": "\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n",
      "sq": "Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë, dhe kthen vlerën rezultuese të numrit të plotë.\n\n- Parametrat:\n- value: Një vlerë e plotë që do të konvertohet në boolean dhe përsëri në numër të plotë.\n\n- Kthen: Një vlerë e plotë pas konvertimit. Vlera e kthyer është 1 nëse numri i plotë origjinal ishte jo-zero; përndryshe, është 0.\n\n### Shembull:\n- `convertIntToBoolToInt(5)` kthen `1`, sepse çdo numër i plotë jo-zero konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n- `convertIntToBoolToInt(0)` kthen `0`, sepse `0` konvertohet në `false`, i cili pastaj konvertohet përsëri në `0`.\n- `convertIntToBoolToInt(-10)` kthen `1`, sepse çdo numër i plotë jo-zero, përfshirë numrat negativë, konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.",
      "hy": "Վերածում է ամբողջ թիվը բուլյան արժեքի, ապա հետ վերածում ամբողջ թվի և վերադարձնում ստացված ամբողջ թվային արժեքը։\n\n- Պարամետրեր:\n- value: Ամբողջ թվային արժեք, որը պետք է վերածվի բուլյան արժեքի և հետ վերածվի ամբողջ թվի։\n\n- Վերադարձնում է: Ամբողջ թվային արժեք վերածումից հետո։ Վերադարձվող արժեքը 1 է, եթե սկզբնական ամբողջ թիվը զրոյից տարբեր էր, հակառակ դեպքում՝ 0։\n\n### Օրինակ:\n- `convertIntToBoolToInt(5)` վերադարձնում է `1`, որովհետև ցանկացած զրոյից տարբեր ամբողջ թիվ վերածվում է `true`, որը հետո վերածվում է `1`։\n- `convertIntToBoolToInt(0)` վերադարձնում է `0`, որովհետև `0` վերածվում է `false`, որը հետո վերածվում է `0`։\n- `convertIntToBoolToInt(-10)` վերադարձնում է `1`, որովհետև ցանկացած զրոյից տարբեր ամբողջ թիվ, ներառյալ բացասական թվերը, վերածվում է `true`, որը հետո վերածվում է `1`։",
      "bn": "একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে এবং তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে, এবং ফলস্বরূপ পূর্ণসংখ্যা মানটি ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- value: একটি পূর্ণসংখ্যা মান যা বুলিয়ানে এবং তারপর পূর্ণসংখ্যায় রূপান্তরিত হবে।\n\n- ফেরত দেয়: রূপান্তরের পরে একটি পূর্ণসংখ্যা মান। যদি মূল পূর্ণসংখ্যাটি শূন্য না হয় তবে ফেরত মানটি 1 হয়; অন্যথায়, এটি 0 হয়।\n\n### উদাহরণ:\n- `convertIntToBoolToInt(5)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।\n- `convertIntToBoolToInt(0)` `0` ফেরত দেয়, কারণ `0` `false` তে রূপান্তরিত হয়, যা পরে `0` তে রূপান্তরিত হয়।\n- `convertIntToBoolToInt(-10)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা, যার মধ্যে ঋণাত্মক সংখ্যাগুলিও অন্তর্ভুক্ত, `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।",
      "bg": "Преобразува цяло число в булево и след това обратно в цяло число, и връща получената стойност на цялото число.\n\n- Параметри:\n- value: Цяло число, което да бъде преобразувано в булево и обратно в цяло число.\n\n- Връща: Цяло число след преобразуването. Върнатата стойност е 1, ако оригиналното цяло число е било различно от нула; в противен случай е 0.\n\n### Пример:\n- `convertIntToBoolToInt(5)` връща `1`, защото всяко ненулево цяло число се преобразува в `true`, което след това се преобразува обратно в `1`.\n- `convertIntToBoolToInt(0)` връща `0`, защото `0` се преобразува в `false`, което след това се преобразува обратно в `0`.\n- `convertIntToBoolToInt(-10)` връща `1`, защото всяко ненулево цяло число, включително отрицателните числа, се преобразува в `true`, което след това се преобразува обратно в `1`.",
      "zh": "将整数转换为布尔值，然后再转换回整数，并返回转换后的整数值。\n\n- 参数：\n- value: 要转换为布尔值并再转换回整数的整数值。\n\n- 返回：转换后的整数值。如果原始整数为非零，则返回值为1；否则为0。\n\n### 示例：\n- `convertIntToBoolToInt(5)` 返回 `1`，因为任何非零整数转换为 `true`，然后再转换回 `1`。\n- `convertIntToBoolToInt(0)` 返回 `0`，因为 `0` 转换为 `false`，然后再转换回 `0`。\n- `convertIntToBoolToInt(-10)` 返回 `1`，因为任何非零整数，包括负数，转换为 `true`，然后再转换回 `1`。",
      "fr": "Convertit un entier en booléen puis de nouveau en entier, et renvoie la valeur entière résultante.\n\n- Paramètres:\n- value: Une valeur entière à convertir en booléen puis de nouveau en entier.\n\n- Renvoie: Une valeur entière après conversion. La valeur renvoyée est 1 si l'entier d'origine était non nul ; sinon, elle est 0.\n\n### Exemple:\n- `convertIntToBoolToInt(5)` renvoie `1`, car tout entier non nul se convertit en `true`, qui se reconvertit ensuite en `1`.\n- `convertIntToBoolToInt(0)` renvoie `0`, car `0` se convertit en `false`, qui se reconvertit ensuite en `0`.\n- `convertIntToBoolToInt(-10)` renvoie `1`, car tout entier non nul, y compris les nombres négatifs, se convertit en `true`, qui se reconvertit ensuite en `1`.",
      "de": "Konvertiert eine ganze Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl und gibt den resultierenden ganzzahligen Wert zurück.\n\n- Parameter:\n- value: Ein ganzzahliger Wert, der in einen booleschen Wert und zurück in eine ganze Zahl konvertiert werden soll.\n\n- Rückgabewert: Ein ganzzahliger Wert nach der Konvertierung. Der Rückgabewert ist 1, wenn die ursprüngliche ganze Zahl ungleich null war; andernfalls ist er 0.\n\n### Beispiel:\n- `convertIntToBoolToInt(5)` gibt `1` zurück, weil jede von null verschiedene ganze Zahl in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.\n- `convertIntToBoolToInt(0)` gibt `0` zurück, weil `0` in `false` konvertiert wird, was dann zurück in `0` konvertiert wird.\n- `convertIntToBoolToInt(-10)` gibt `1` zurück, weil jede von null verschiedene ganze Zahl, einschließlich negativer Zahlen, in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.",
      "ha": "Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Sigogi:\n- value: Wani ƙimar integer da za a canza zuwa boolean sannan a mayar da shi zuwa integer.\n\n- Komawa: Wani ƙimar integer bayan canzawa. Ƙimar dawowa ita ce 1 idan asalin integer ba sifili ba ne; in ba haka ba, yana da 0.\n\n### Misali:\n- `convertIntToBoolToInt(5)` yana dawowa `1`, saboda duk wani integer wanda ba sifili ba yana canzawa zuwa `true`, wanda sannan yana canzawa baya zuwa `1`.\n- `convertIntToBoolToInt(0)` yana dawowa `0`, saboda `0` yana canzawa zuwa `false`, wanda sannan yana canzawa baya zuwa `0`.\n- `convertIntToBoolToInt(-10)` yana dawowa `1`, saboda duk wani integer wanda ba sifili ba, ciki har da lambobi masu korau, yana canzawa zuwa `true`, wanda sannan yana canzawa baya zuwa `1`.",
      "hi": "एक पूर्णांक को बूलियन में और फिर से पूर्णांक में परिवर्तित करता है, और परिणामी पूर्णांक मान को लौटाता है।\n\n- पैरामीटर्स:\n- value: एक पूर्णांक मान जिसे बूलियन में और फिर से पूर्णांक में परिवर्तित किया जाना है।\n\n- रिटर्न्स: रूपांतरण के बाद एक पूर्णांक मान। यदि मूल पूर्णांक शून्य नहीं था तो रिटर्न मान 1 होता है; अन्यथा, यह 0 होता है।\n\n### उदाहरण:\n- `convertIntToBoolToInt(5)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक `true` में परिवर्तित होता है, जो फिर `1` में परिवर्तित होता है।\n- `convertIntToBoolToInt(0)` `0` लौटाता है, क्योंकि `0` `false` में परिवर्तित होता है, जो फिर `0` में परिवर्तित होता है।\n- `convertIntToBoolToInt(-10)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक, जिसमें ऋणात्मक संख्याएँ भी शामिल हैं, `true` में परिवर्तित होता है, जो फिर `1` में परिवर्तित होता है।",
      "hu": "Egész számot konvertál logikai értékké, majd vissza egész számmá, és visszaadja a kapott egész szám értékét.\n\n- Paraméterek:\n- value: Egy egész szám, amelyet logikai értékké, majd vissza egész számmá kell konvertálni.\n\n- Visszatérési érték: Egy egész szám érték a konverzió után. A visszatérési érték 1, ha az eredeti egész szám nem nulla volt; ellenkező esetben 0.\n\n### Példa:\n- `convertIntToBoolToInt(5)` visszaadja az `1`-et, mert bármely nem nulla egész szám `true`-vá konvertálódik, ami aztán vissza `1`-re.\n- `convertIntToBoolToInt(0)` visszaadja a `0`-t, mert a `0` `false`-vá konvertálódik, ami aztán vissza `0`-ra.\n- `convertIntToBoolToInt(-10)` visszaadja az `1`-et, mert bármely nem nulla egész szám, beleértve a negatív számokat is, `true`-vá konvertálódik, ami aztán vissza `1`-re."
    },
    "docstring_bertscore": {
      "sq": "0.9903239196182665",
      "hy": "0.9645683126309966",
      "bn": "0.9512151866355453",
      "bg": "0.9727199048382874",
      "zh": "0.7528887100836404",
      "fr": "0.9784752201287733",
      "de": "0.9642381889377166",
      "ha": "0.9878187932526544",
      "hi": "0.9671953980505641",
      "hu": "0.9654760534723261"
    }
  },
  {
    "task_id": "Swift/45",
    "prompt": {
      "en": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */",
      "sq": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Kthen një numër treshe dhe kthen rezultatin.\n\n    - Parametra:\n        - number: Një numër i plotë treshe që do të kthehet.\n\n    - Kthen: Numrin e kthyer. Nëse numri i futur nuk është një numër i plotë treshe, funksioni kthen -1 për të treguar një gabim.\n\n    ### Shembuj:\n    - `reverseThreeDigitNumber(123)` kthen `321`.\n    - `reverseThreeDigitNumber(456)` kthen `654`.\n    - `reverseThreeDigitNumber(789)` kthen `987`.\n    - `reverseThreeDigitNumber(100)` kthen `1`, pasi zerot para nuk përfaqësohen në numra të plotë.\n    - `reverseThreeDigitNumber(905)` kthen `509`.\n\n    Shënim: Funksioni supozon që inputi është gjithmonë një numër treshe.\n    */",
      "hy": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Հակադարձում է եռանիշ թիվը և վերադարձնում արդյունքը։\n\n    - Պարամետրեր:\n        - number: Եռանիշ ամբողջ թիվ, որը պետք է հակադարձել։\n\n    - Վերադարձնում է: Հակադարձված ամբողջ թիվը։ Եթե մուտքային թիվը եռանիշ ամբողջ թիվ չէ, ֆունկցիան վերադարձնում է -1՝ սխալը ցույց տալու համար։\n\n    ### Օրինակներ:\n    - `reverseThreeDigitNumber(123)` վերադարձնում է `321`։\n    - `reverseThreeDigitNumber(456)` վերադարձնում է `654`։\n    - `reverseThreeDigitNumber(789)` վերադարձնում է `987`։\n    - `reverseThreeDigitNumber(100)` վերադարձնում է `1`, քանի որ առաջատար զրոները չեն ներկայացվում ամբողջ թվերով։\n    - `reverseThreeDigitNumber(905)` վերադարձնում է `509`։\n\n    Նշում: Ֆունկցիան ենթադրում է, որ մուտքը միշտ եռանիշ թիվ է։\n    */",
      "bn": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    একটি তিন অঙ্কের সংখ্যা উল্টায় এবং ফলাফল প্রদান করে।\n\n    - প্যারামিটার:\n        - number: উল্টানোর জন্য একটি তিন অঙ্কের পূর্ণসংখ্যা।\n\n    - রিটার্নস: উল্টানো পূর্ণসংখ্যা। যদি ইনপুট সংখ্যা তিন অঙ্কের পূর্ণসংখ্যা না হয়, তাহলে ফাংশনটি একটি ত্রুটি নির্দেশ করতে -1 রিটার্ন করে।\n\n    ### উদাহরণ:\n    - `reverseThreeDigitNumber(123)` রিটার্ন করে `321`.\n    - `reverseThreeDigitNumber(456)` রিটার্ন করে `654`.\n    - `reverseThreeDigitNumber(789)` রিটার্ন করে `987`.\n    - `reverseThreeDigitNumber(100)` রিটার্ন করে `1`, কারণ পূর্ণসংখ্যায় শূন্য দিয়ে শুরু হয় না।\n    - `reverseThreeDigitNumber(905)` রিটার্ন করে `509`.\n\n    নোট: ফাংশনটি ধরে নেয় যে ইনপুট সর্বদা একটি তিন অঙ্কের সংখ্যা।\n    */",
      "bg": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Обръща трицифрено число и връща резултата.\n\n    - Параметри:\n        - number: Трицифрено цяло число, което да бъде обърнато.\n\n    - Връща: Обърнатото цяло число. Ако входното число не е трицифрено цяло число, функцията връща -1, за да посочи грешка.\n\n    ### Примери:\n    - `reverseThreeDigitNumber(123)` връща `321`.\n    - `reverseThreeDigitNumber(456)` връща `654`.\n    - `reverseThreeDigitNumber(789)` връща `987`.\n    - `reverseThreeDigitNumber(100)` връща `1`, тъй като водещите нули не се представят в цели числа.\n    - `reverseThreeDigitNumber(905)` връща `509`.\n\n    Забележка: Функцията приема, че входът винаги е трицифрено число.\n    */",
      "zh": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    反转一个三位数并返回结果。\n\n    - 参数:\n        - number: 要反转的三位整数。\n\n    - 返回: 反转后的整数。如果输入的数字不是三位整数，函数返回 -1 以表示错误。\n\n    ### 示例:\n    - `reverseThreeDigitNumber(123)` 返回 `321`。\n    - `reverseThreeDigitNumber(456)` 返回 `654`。\n    - `reverseThreeDigitNumber(789)` 返回 `987`。\n    - `reverseThreeDigitNumber(100)` 返回 `1`，因为整数中不表示前导零。\n    - `reverseThreeDigitNumber(905)` 返回 `509`。\n\n    注意: 函数假设输入始终是一个三位数。\n    */",
      "fr": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Renverse un nombre à trois chiffres et renvoie le résultat.\n\n    - Paramètres :\n        - number: Un entier à trois chiffres à renverser.\n\n    - Renvoie : L'entier renversé. Si le nombre d'entrée n'est pas un entier à trois chiffres, la fonction renvoie -1 pour indiquer une erreur.\n\n    ### Exemples :\n    - `reverseThreeDigitNumber(123)` renvoie `321`.\n    - `reverseThreeDigitNumber(456)` renvoie `654`.\n    - `reverseThreeDigitNumber(789)` renvoie `987`.\n    - `reverseThreeDigitNumber(100)` renvoie `1`, car les zéros en tête ne sont pas représentés dans les entiers.\n    - `reverseThreeDigitNumber(905)` renvoie `509`.\n\n    Remarque : La fonction suppose que l'entrée est toujours un nombre à trois chiffres.\n    */",
      "de": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Kehrt eine dreistellige Zahl um und gibt das Ergebnis zurück.\n\n    - Parameter:\n        - number: Eine dreistellige ganze Zahl, die umgekehrt werden soll.\n\n    - Rückgabewert: Die umgekehrte ganze Zahl. Wenn die Eingabezahl keine dreistellige ganze Zahl ist, gibt die Funktion -1 zurück, um einen Fehler anzuzeigen.\n\n    ### Beispiele:\n    - `reverseThreeDigitNumber(123)` gibt `321` zurück.\n    - `reverseThreeDigitNumber(456)` gibt `654` zurück.\n    - `reverseThreeDigitNumber(789)` gibt `987` zurück.\n    - `reverseThreeDigitNumber(100)` gibt `1` zurück, da führende Nullen in ganzen Zahlen nicht dargestellt werden.\n    - `reverseThreeDigitNumber(905)` gibt `509` zurück.\n\n    Hinweis: Die Funktion geht davon aus, dass die Eingabe immer eine dreistellige Zahl ist.\n    */",
      "ha": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Juya lamba mai tsawon uku kuma dawo da sakamakon.\n\n    - Sigogi:\n        - number: Lamba mai tsawon uku da za a juya.\n\n    - Dawo: Lambar da aka juyar. Idan lambar da aka shigar ba lamba mai tsawon uku ba ce, aikin zai dawo da -1 don nuna kuskure.\n\n    ### Misalai:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, kamar yadda ba a wakilta sifili a farkon lambobi.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Lura: Aikin yana ɗauka cewa shigarwar koyaushe lamba mai tsawon uku ce.\n    */",
      "hi": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    एक तीन-अंकीय संख्या को उलटता है और परिणाम लौटाता है।\n\n    - पैरामीटर्स:\n        - number: उलटने के लिए एक तीन-अंकीय पूर्णांक।\n\n    - रिटर्न्स: उलटा पूर्णांक। यदि इनपुट संख्या तीन-अंकीय पूर्णांक नहीं है, तो फ़ंक्शन त्रुटि को इंगित करने के लिए -1 लौटाता है।\n\n    ### उदाहरण:\n    - `reverseThreeDigitNumber(123)` `321` लौटाता है।\n    - `reverseThreeDigitNumber(456)` `654` लौटाता है।\n    - `reverseThreeDigitNumber(789)` `987` लौटाता है।\n    - `reverseThreeDigitNumber(100)` `1` लौटाता है, क्योंकि अग्रणी शून्य पूर्णांकों में प्रदर्शित नहीं होते।\n    - `reverseThreeDigitNumber(905)` `509` लौटाता है।\n\n    नोट: फ़ंक्शन मानता है कि इनपुट हमेशा एक तीन-अंकीय संख्या है।\n    */",
      "hu": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Megfordít egy háromjegyű számot, és visszaadja az eredményt.\n\n    - Paraméterek:\n        - number: Egy háromjegyű egész szám, amelyet meg kell fordítani.\n\n    - Visszatér: A megfordított egész szám. Ha a bemeneti szám nem háromjegyű egész szám, a függvény -1-et ad vissza, hogy hibát jelezzen.\n\n    ### Példák:\n    - `reverseThreeDigitNumber(123)` visszaadja `321`.\n    - `reverseThreeDigitNumber(456)` visszaadja `654`.\n    - `reverseThreeDigitNumber(789)` visszaadja `987`.\n    - `reverseThreeDigitNumber(100)` visszaadja `1`, mivel a vezető nullák nem jelennek meg az egész számokban.\n    - `reverseThreeDigitNumber(905)` visszaadja `509`.\n\n    Megjegyzés: A függvény feltételezi, hogy a bemenet mindig háromjegyű szám.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9977320383093436",
      "hy": "0.9910483246179007",
      "bn": "0.976252943425755",
      "bg": "0.9993989444669884",
      "zh": "0.9889448288827413",
      "fr": "0.9944133219030127",
      "de": "0.9874978065569021",
      "ha": "0.9802140304843527",
      "hi": "0.9917059898095072",
      "hu": "0.987446162657833"
    },
    "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}",
    "instruction": {
      "en": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8679241048473287",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9404756391937509"
    },
    "level": "",
    "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()",
    "entry_point": "reverseThreeDigitNumber",
    "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {",
    "docstring": {
      "en": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n",
      "sq": "Kthen një numër tre-shifror dhe kthen rezultatin.\n\n- Parametrat:\n- number: Një numër i plotë tre-shifror që do të kthehet.\n\n- Kthen: Numrin e plotë të kthyer. Nëse numri i futur nuk është një numër i plotë tre-shifror, funksioni kthen -1 për të treguar një gabim.\n\n### Shembuj:\n- `reverseThreeDigitNumber(123)` kthen `321`.\n- `reverseThreeDigitNumber(456)` kthen `654`.\n- `reverseThreeDigitNumber(789)` kthen `987`.\n- `reverseThreeDigitNumber(100)` kthen `1`, pasi zerot në fillim nuk përfaqësohen në numrat e plotë.\n- `reverseThreeDigitNumber(905)` kthen `509`.\n\nShënim: Funksioni supozon që hyrja është gjithmonë një numër tre-shifror.",
      "hy": "Հետադարձում է եռանիշ թիվը և վերադարձնում արդյունքը։\n\n- Պարամետրեր:\n- number: Եռանիշ ամբողջ թիվ, որը պետք է հետադարձվի։\n\n- Վերադարձնում է: Հետադարձված ամբողջ թիվը։ Եթե մուտքային թիվը եռանիշ ամբողջ թիվ չէ, ֆունկցիան վերադարձնում է -1՝ սխալը նշելու համար։\n\n### Օրինակներ:\n- `reverseThreeDigitNumber(123)` վերադարձնում է `321`։\n- `reverseThreeDigitNumber(456)` վերադարձնում է `654`։\n- `reverseThreeDigitNumber(789)` վերադարձնում է `987`։\n- `reverseThreeDigitNumber(100)` վերադարձնում է `1`, քանի որ առաջատար զրոները չեն ներկայացվում ամբողջ թվերում։\n- `reverseThreeDigitNumber(905)` վերադարձնում է `509`։\n\nՆշում: Ֆունկցիան ենթադրում է, որ մուտքը միշտ եռանիշ թիվ է։",
      "bn": "একটি তিন অঙ্কের সংখ্যা উল্টায় এবং ফলাফল প্রদান করে।\n\n- প্যারামিটারসমূহ:\n- number: একটি তিন অঙ্কের পূর্ণসংখ্যা যা উল্টানো হবে।\n\n- রিটার্নস: উল্টানো পূর্ণসংখ্যা। যদি ইনপুট সংখ্যা তিন অঙ্কের পূর্ণসংখ্যা না হয়, তাহলে ফাংশনটি একটি ত্রুটি নির্দেশ করতে -1 প্রদান করে।\n\n### উদাহরণসমূহ:\n- `reverseThreeDigitNumber(123)` `321` প্রদান করে।\n- `reverseThreeDigitNumber(456)` `654` প্রদান করে।\n- `reverseThreeDigitNumber(789)` `987` প্রদান করে।\n- `reverseThreeDigitNumber(100)` `1` প্রদান করে, কারণ পূর্ণসংখ্যায় শূন্যের পূর্ববর্তী সংখ্যা প্রদর্শিত হয় না।\n- `reverseThreeDigitNumber(905)` `509` প্রদান করে।\n\nনোট: ফাংশনটি ধরে নেয় যে ইনপুট সর্বদা একটি তিন অঙ্কের সংখ্যা।",
      "bg": "Обръща трицифрено число и връща резултата.\n\n- Параметри:\n- number: Трицифрено цяло число, което да бъде обърнато.\n\n- Връща: Обърнатото цяло число. Ако входното число не е трицифрено цяло число, функцията връща -1, за да посочи грешка.\n\n### Примери:\n- `reverseThreeDigitNumber(123)` връща `321`.\n- `reverseThreeDigitNumber(456)` връща `654`.\n- `reverseThreeDigitNumber(789)` връща `987`.\n- `reverseThreeDigitNumber(100)` връща `1`, тъй като водещите нули не се представят в цели числа.\n- `reverseThreeDigitNumber(905)` връща `509`.\n\nЗабележка: Функцията предполага, че входът винаги е трицифрено число.",
      "zh": "反转一个三位数并返回结果。\n\n- 参数：\n- number: 要反转的三位整数。\n\n- 返回：反转后的整数。如果输入的数字不是三位整数，函数返回 -1 以表示错误。\n\n### 示例：\n- `reverseThreeDigitNumber(123)` 返回 `321`。\n- `reverseThreeDigitNumber(456)` 返回 `654`。\n- `reverseThreeDigitNumber(789)` 返回 `987`。\n- `reverseThreeDigitNumber(100)` 返回 `1`，因为整数中不表示前导零。\n- `reverseThreeDigitNumber(905)` 返回 `509`。\n\n注意：该函数假设输入始终是一个三位数。",
      "fr": "Inverse un nombre à trois chiffres et renvoie le résultat.\n\n- Paramètres :\n- number : Un entier à trois chiffres à inverser.\n\n- Renvoie : L'entier inversé. Si le nombre d'entrée n'est pas un entier à trois chiffres, la fonction renvoie -1 pour indiquer une erreur.\n\n### Exemples :\n- `reverseThreeDigitNumber(123)` renvoie `321`.\n- `reverseThreeDigitNumber(456)` renvoie `654`.\n- `reverseThreeDigitNumber(789)` renvoie `987`.\n- `reverseThreeDigitNumber(100)` renvoie `1`, car les zéros initiaux ne sont pas représentés dans les entiers.\n- `reverseThreeDigitNumber(905)` renvoie `509`.\n\nRemarque : La fonction suppose que l'entrée est toujours un nombre à trois chiffres.",
      "de": "Kehrt eine dreistellige Zahl um und gibt das Ergebnis zurück.\n\n- Parameter:\n- number: Eine dreistellige ganze Zahl, die umgekehrt werden soll.\n\n- Rückgabe: Die umgekehrte ganze Zahl. Wenn die Eingabezahl keine dreistellige ganze Zahl ist, gibt die Funktion -1 zurück, um einen Fehler anzuzeigen.\n\n### Beispiele:\n- `reverseThreeDigitNumber(123)` gibt `321` zurück.\n- `reverseThreeDigitNumber(456)` gibt `654` zurück.\n- `reverseThreeDigitNumber(789)` gibt `987` zurück.\n- `reverseThreeDigitNumber(100)` gibt `1` zurück, da führende Nullen in ganzen Zahlen nicht dargestellt werden.\n- `reverseThreeDigitNumber(905)` gibt `509` zurück.\n\nHinweis: Die Funktion geht davon aus, dass die Eingabe immer eine dreistellige Zahl ist.",
      "ha": "Reverses a three-digit number and returns the result.\n\n- Sigogi:\n- number: Lamba mai tsawon uku da za a juya.\n\n- Komawa: Lambar da aka juya. Idan lambar da aka shigar ba lamba mai tsawon uku ba ce, aikin yana dawowa da -1 don nuna kuskure.\n\n### Misalai:\n- `reverseThreeDigitNumber(123)` yana dawowa da `321`.\n- `reverseThreeDigitNumber(456)` yana dawowa da `654`.\n- `reverseThreeDigitNumber(789)` yana dawowa da `987`.\n- `reverseThreeDigitNumber(100)` yana dawowa da `1`, saboda ba a wakilta sifili mai jagora a lambobi.\n- `reverseThreeDigitNumber(905)` yana dawowa da `509`.\n\nLura: Aikin yana tsammanin shigarwar koyaushe lamba mai tsawon uku ce.",
      "hi": "तीन अंकों की संख्या को उलटता है और परिणाम लौटाता है।\n\n- पैरामीटर्स:\n- number: उलटने के लिए एक तीन अंकों की पूर्णांक संख्या।\n\n- रिटर्न्स: उलटी की गई पूर्णांक संख्या। यदि इनपुट संख्या तीन अंकों की पूर्णांक संख्या नहीं है, तो यह फ़ंक्शन त्रुटि को सूचित करने के लिए -1 लौटाता है।\n\n### उदाहरण:\n- `reverseThreeDigitNumber(123)` `321` लौटाता है।\n- `reverseThreeDigitNumber(456)` `654` लौटाता है।\n- `reverseThreeDigitNumber(789)` `987` लौटाता है।\n- `reverseThreeDigitNumber(100)` `1` लौटाता है, क्योंकि अग्रणी शून्य पूर्णांकों में प्रदर्शित नहीं होते हैं।\n- `reverseThreeDigitNumber(905)` `509` लौटाता है।\n\nध्यान दें: फ़ंक्शन मानता है कि इनपुट हमेशा एक तीन अंकों की संख्या है।",
      "hu": "Megfordít egy háromjegyű számot, és visszaadja az eredményt.\n\n- Paraméterek:\n- number: Egy háromjegyű egész szám, amelyet meg kell fordítani.\n\n- Visszatérési érték: A megfordított egész szám. Ha a bemeneti szám nem háromjegyű egész szám, a függvény -1-et ad vissza, hogy hibát jelezzen.\n\n### Példák:\n- `reverseThreeDigitNumber(123)` visszaadja `321`.\n- `reverseThreeDigitNumber(456)` visszaadja `654`.\n- `reverseThreeDigitNumber(789)` visszaadja `987`.\n- `reverseThreeDigitNumber(100)` visszaadja `1`, mivel a vezető nullák nem jelennek meg az egész számokban.\n- `reverseThreeDigitNumber(905)` visszaadja `509`.\n\nMegjegyzés: A függvény feltételezi, hogy a bemenet mindig háromjegyű szám."
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9841195010362607",
      "bn": "0.9721607603156742",
      "bg": "0.998969505583191",
      "zh": "0.9841347955756004",
      "fr": "0.9872207171753584",
      "de": "0.9955409465761478",
      "ha": "0.9889325137991171",
      "hi": "0.9870206963816562",
      "hu": "0.9815847787438745"
    }
  },
  {
    "task_id": "Swift/46",
    "prompt": {
      "en": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calculates the nth term of an arithmetic sequence given its first two terms.\n\n    - Parameters:\n        - a1: The first term of the arithmetic sequence.\n        - a2: The second term of the arithmetic sequence.\n        - n: The position of the term in the sequence to be found (1-based index).\n\n    - Returns: The nth term of the arithmetic sequence.\n\n    ### Example:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\n    Note: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "sq": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Llogarit termin e n-të të një vargu aritmetik duke pasur parasysh dy termat e tij të parë.\n\n    - Parametra:\n        - a1: Termi i parë i vargut aritmetik.\n        - a2: Termi i dytë i vargut aritmetik.\n        - n: Pozicioni i termit në varg që do të gjendet (indeksi që fillon nga 1).\n\n    - Kthen: Termi i n-të i vargut aritmetik.\n\n    ### Shembull:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` llogarit termin e 100-të të një vargu aritmetik që fillon me 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` llogarit termin e 20-të të një vargu aritmetik që fillon me 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` llogarit termin e 10-të të një vargu aritmetik që fillon me -3, 1.\n\n    Shënim: Funksioni supozon që vlerat e hyrjes për `a1`, `a2`, dhe `n` ndjekin kufizimet -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "hy": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով դրա առաջին երկու անդամները։\n\n    - Պարամետրեր:\n        - a1: Թվաբանական հաջորդականության առաջին անդամը։\n        - a2: Թվաբանական հաջորդականության երկրորդ անդամը։\n        - n: Հաջորդականության այն անդամի դիրքը, որը պետք է գտնվի (1-ից սկսվող ինդեքս)։\n\n    - Վերադարձնում է: Թվաբանական հաջորդականության n-րդ անդամը։\n\n    ### Օրինակ:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` հաշվում է 100-րդ անդամը թվաբանական հաջորդականության, որը սկսվում է 1, 4-ով։\n    - `arithmeticSequenceLastTerm(5, 9, 20)` հաշվում է 20-րդ անդամը թվաբանական հաջորդականության, որը սկսվում է 5, 9-ով։\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` հաշվում է 10-րդ անդամը թվաբանական հաջորդականության, որը սկսվում է -3, 1-ով։\n\n    Նշում: Ֆունկցիան ենթադրում է, որ `a1`, `a2` և `n` մուտքային արժեքները համապատասխանում են սահմանափակումներին -100 <= a1,a2 <= 100, 0 < n <= 1000։\n    */",
      "bn": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    একটি গাণিতিক ক্রমের প্রথম দুটি পদ দেওয়া থাকলে এর n তম পদ গণনা করে।\n\n    - Parameters:\n        - a1: গাণিতিক ক্রমের প্রথম পদ।\n        - a2: গাণিতিক ক্রমের দ্বিতীয় পদ।\n        - n: ক্রমের যে পদের অবস্থান খুঁজে বের করতে হবে (১-ভিত্তিক সূচক)।\n\n    - Returns: গাণিতিক ক্রমের n তম পদ।\n\n    ### Example:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` গাণিতিক ক্রমের ১০০তম পদ গণনা করে যা ১, ৪ দিয়ে শুরু হয়।\n    - `arithmeticSequenceLastTerm(5, 9, 20)` গাণিতিক ক্রমের ২০তম পদ গণনা করে যা ৫, ৯ দিয়ে শুরু হয়।\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` গাণিতিক ক্রমের ১০তম পদ গণনা করে যা -৩, ১ দিয়ে শুরু হয়।\n\n    Note: ফাংশনটি ধরে নেয় যে `a1`, `a2`, এবং `n` এর ইনপুট মানগুলি নিম্নলিখিত সীমাবদ্ধতাগুলি অনুসরণ করে -100 <= a1,a2 <= 100, 0 < n <= 1000।\n    */",
      "bg": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Изчислява n-тия член на аритметична прогресия, като са дадени първите два члена.\n\n    - Параметри:\n        - a1: Първият член на аритметичната прогресия.\n        - a2: Вторият член на аритметичната прогресия.\n        - n: Позицията на члена в прогресията, който трябва да бъде намерен (индекс, започващ от 1).\n\n    - Връща: n-тия член на аритметичната прогресия.\n\n    ### Пример:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` изчислява 100-тия член на аритметична прогресия, започваща с 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` изчислява 20-тия член на аритметична прогресия, започваща с 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` изчислява 10-тия член на аритметична прогресия, започваща с -3, 1.\n\n    Забележка: Функцията предполага, че входните стойности за `a1`, `a2` и `n` следват ограниченията -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "zh": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    计算等差数列的第 n 项，给定其前两项。\n\n    - 参数:\n        - a1: 等差数列的第一项。\n        - a2: 等差数列的第二项。\n        - n: 要查找的项在序列中的位置（从1开始的索引）。\n\n    - 返回: 等差数列的第 n 项。\n\n    ### 示例:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` 计算以 1, 4 开始的等差数列的第 100 项。\n    - `arithmeticSequenceLastTerm(5, 9, 20)` 计算以 5, 9 开始的等差数列的第 20 项。\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` 计算以 -3, 1 开始的等差数列的第 10 项。\n\n    注意: 该函数假设输入值 `a1`、`a2` 和 `n` 遵循约束条件 -100 <= a1,a2 <= 100, 0 < n <= 1000。\n    */",
      "fr": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calcule le nième terme d'une suite arithmétique donnée ses deux premiers termes.\n\n    - Paramètres:\n        - a1: Le premier terme de la suite arithmétique.\n        - a2: Le deuxième terme de la suite arithmétique.\n        - n: La position du terme dans la suite à trouver (index basé sur 1).\n\n    - Retourne: Le nième terme de la suite arithmétique.\n\n    ### Exemple:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calcule le 100ème terme d'une suite arithmétique commençant par 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calcule le 20ème terme d'une suite arithmétique commençant par 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calcule le 10ème terme d'une suite arithmétique commençant par -3, 1.\n\n    Remarque: La fonction suppose que les valeurs d'entrée pour `a1`, `a2`, et `n` respectent les contraintes -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "de": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Berechnet das n-te Glied einer arithmetischen Folge, gegeben durch die ersten beiden Glieder.\n\n    - Parameter:\n        - a1: Das erste Glied der arithmetischen Folge.\n        - a2: Das zweite Glied der arithmetischen Folge.\n        - n: Die Position des zu findenden Gliedes in der Folge (1-basierter Index).\n\n    - Rückgabe: Das n-te Glied der arithmetischen Folge.\n\n    ### Beispiel:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` berechnet das 100. Glied einer arithmetischen Folge, beginnend mit 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` berechnet das 20. Glied einer arithmetischen Folge, beginnend mit 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` berechnet das 10. Glied einer arithmetischen Folge, beginnend mit -3, 1.\n\n    Hinweis: Die Funktion geht davon aus, dass die Eingabewerte für `a1`, `a2` und `n` die Einschränkungen -100 <= a1,a2 <= 100, 0 < n <= 1000 einhalten.\n    */",
      "ha": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Lissafa kalmar n ta jerin lissafi idan aka ba da kalmomi biyu na farko.\n\n    - Sigogi:\n        - a1: Kalmar farko ta jerin lissafi.\n        - a2: Kalma ta biyu ta jerin lissafi.\n        - n: Matsayin kalmar a cikin jerin da za a samu (1-based index).\n\n    - Komawa: Kalmar n ta jerin lissafi.\n\n    ### Misali:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` yana lissafin kalma ta 100 ta jerin lissafi da ya fara da 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` yana lissafin kalma ta 20 ta jerin lissafi da ya fara da 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` yana lissafin kalma ta 10 ta jerin lissafi da ya fara da -3, 1.\n\n    Lura: Aikin yana tsammanin ƙimar shigarwa don `a1`, `a2`, da `n` suna bin ƙuntatawa -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "hi": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    एक अंकगणित अनुक्रम के पहले दो पदों को दिया गया है, तो इसका nth पद गणना करता है।\n\n    - पैरामीटर्स:\n        - a1: अंकगणित अनुक्रम का पहला पद।\n        - a2: अंकगणित अनुक्रम का दूसरा पद।\n        - n: अनुक्रम में जिस पद को खोजना है उसकी स्थिति (1-आधारित सूचकांक)।\n\n    - रिटर्न करता है: अंकगणित अनुक्रम का nth पद।\n\n    ### उदाहरण:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` एक अंकगणित अनुक्रम का 100वां पद गणना करता है जो 1, 4 से शुरू होता है।\n    - `arithmeticSequenceLastTerm(5, 9, 20)` एक अंकगणित अनुक्रम का 20वां पद गणना करता है जो 5, 9 से शुरू होता है।\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` एक अंकगणित अनुक्रम का 10वां पद गणना करता है जो -3, 1 से शुरू होता है।\n\n    नोट: यह फ़ंक्शन मानता है कि `a1`, `a2`, और `n` के लिए इनपुट मान निम्नलिखित बाधाओं का पालन करते हैं -100 <= a1,a2 <= 100, 0 < n <= 1000।\n    */",
      "hu": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Kiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tagja.\n\n    - Paraméterek:\n        - a1: A számtani sorozat első tagja.\n        - a2: A számtani sorozat második tagja.\n        - n: A sorozatban keresett tag pozíciója (1-alapú index).\n\n    - Visszatérési érték: A számtani sorozat n-edik tagja.\n\n    ### Példa:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` kiszámítja a 100. tagját annak a számtani sorozatnak, amely 1, 4-gyel kezdődik.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` kiszámítja a 20. tagját annak a számtani sorozatnak, amely 5, 9-cel kezdődik.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` kiszámítja a 10. tagját annak a számtani sorozatnak, amely -3, 1-gyel kezdődik.\n\n    Megjegyzés: A függvény feltételezi, hogy az `a1`, `a2` és `n` bemeneti értékek megfelelnek a -100 <= a1,a2 <= 100, 0 < n <= 1000 korlátozásoknak.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9849340842288847",
      "hy": "0.9826393074367887",
      "bn": "0.9881302456901172",
      "bg": "0.9791606935737247",
      "zh": "0.9868226618917645",
      "fr": "0.9934114302610728",
      "de": "0.9692718800539027",
      "ha": "0.9907603105654001",
      "hi": "0.9878964577316391",
      "hu": "0.974368735631258"
    },
    "canonical_solution": "    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}",
    "instruction": {
      "en": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nՏվեք Swift կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nПредоставете кратко описание на Swift кода на български език, използвайки не повече от 500 знака.",
      "zh": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nAdj meg egy tömör, legfeljebb 500 karakteres természetes nyelvű leírást (docstring) a Swift kódról magyarul."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9229242614647462",
      "bn": "0.9230110629412583",
      "bg": "0.822453638020822",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9529424764290246",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testArithmeticSequenceLastTerm() {\n    assert(arithmeticSequenceLastTerm(1, 4, 100) == 298, \"The 100th term should be 298.\")\n    assert(arithmeticSequenceLastTerm(5, 9, 20) == 81, \"The 20th term should be 77.\")\n    assert(arithmeticSequenceLastTerm(-3, 1, 10) == 33, \"The 10th term should be 33.\")\n    assert(arithmeticSequenceLastTerm(0, 2, 50) == 98, \"The 50th term should be 98.\")\n    assert(arithmeticSequenceLastTerm(-100, -97, 1000) == 2897, \"The 1000th term should be 2897.\")\n    assert(arithmeticSequenceLastTerm(2, 5, 3) == 8, \"The 3rd term should be 8.\")\n}\n\n// Call the test function to verify the functionality\ntestArithmeticSequenceLastTerm()",
    "entry_point": "arithmeticSequenceLastTerm",
    "signature": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n",
      "sq": "Llogarit termin e n-të të një vargu aritmetik duke pasur parasysh dy termat e tij të parë.\n\n- Parametrat:\n- a1: Termi i parë i vargut aritmetik.\n- a2: Termi i dytë i vargut aritmetik.\n- n: Pozicioni i termit në varg që do të gjendet (indeksimi fillon nga 1).\n\n- Kthen: Termi i n-të i vargut aritmetik.\n\n### Shembull:\n- `arithmeticSequenceLastTerm(1, 4, 100)` llogarit termin e 100-të të një vargu aritmetik që fillon me 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` llogarit termin e 20-të të një vargu aritmetik që fillon me 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` llogarit termin e 10-të të një vargu aritmetik që fillon me -3, 1.\n\nShënim: Funksioni supozon që vlerat e hyrjes për `a1`, `a2`, dhe `n` ndjekin kufizimet -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "hy": "Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով դրա առաջին երկու անդամները։\n\n- Պարամետրեր:\n- a1: Թվաբանական հաջորդականության առաջին անդամը։\n- a2: Թվաբանական հաջորդականության երկրորդ անդամը։\n- n: Հաջորդականության այն անդամի դիրքը, որը պետք է գտնվի (1-ից սկսվող ինդեքս)։\n\n- Վերադարձնում է: Թվաբանական հաջորդականության n-րդ անդամը։\n\n### Օրինակ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` հաշվում է թվաբանական հաջորդականության 100-րդ անդամը, որը սկսվում է 1, 4։\n- `arithmeticSequenceLastTerm(5, 9, 20)` հաշվում է թվաբանական հաջորդականության 20-րդ անդամը, որը սկսվում է 5, 9։\n- `arithmeticSequenceLastTerm(-3, 1, 10)` հաշվում է թվաբանական հաջորդականության 10-րդ անդամը, որը սկսվում է -3, 1։\n\nՆշում: Ֆունկցիան ենթադրում է, որ մուտքային արժեքները `a1`, `a2` և `n` համապատասխանում են սահմանափակումներին -100 <= a1,a2 <= 100, 0 < n <= 1000։",
      "bn": "nth টার্ম গণনা করে একটি গাণিতিক ক্রমের, এর প্রথম দুটি টার্ম দেওয়া হলে।\n\n- প্যারামিটারসমূহ:\n- a1: গাণিতিক ক্রমের প্রথম টার্ম।\n- a2: গাণিতিক ক্রমের দ্বিতীয় টার্ম।\n- n: ক্রমের যে টার্মটি খুঁজে বের করতে হবে তার অবস্থান (১-ভিত্তিক সূচক)।\n\n- রিটার্ন করে: গাণিতিক ক্রমের nth টার্ম।\n\n### উদাহরণ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` গাণিতিক ক্রমের ১০০তম টার্ম গণনা করে যা ১, ৪ দিয়ে শুরু হয়।\n- `arithmeticSequenceLastTerm(5, 9, 20)` গাণিতিক ক্রমের ২০তম টার্ম গণনা করে যা ৫, ৯ দিয়ে শুরু হয়।\n- `arithmeticSequenceLastTerm(-3, 1, 10)` গাণিতিক ক্রমের ১০তম টার্ম গণনা করে যা -৩, ১ দিয়ে শুরু হয়।\n\nদ্রষ্টব্য: ফাংশনটি ধরে নেয় যে `a1`, `a2`, এবং `n` এর ইনপুট মানগুলি শর্ত পূরণ করে -100 <= a1,a2 <= 100, 0 < n <= 1000।",
      "bg": "Изчислява n-тия член на аритметична прогресия, като се дадат първите два члена.\n\n- Параметри:\n- a1: Първият член на аритметичната прогресия.\n- a2: Вторият член на аритметичната прогресия.\n- n: Позицията на члена в прогресията, който трябва да бъде намерен (индекс, започващ от 1).\n\n- Връща: n-тия член на аритметичната прогресия.\n\n### Пример:\n- `arithmeticSequenceLastTerm(1, 4, 100)` изчислява 100-тия член на аритметична прогресия, започваща с 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` изчислява 20-тия член на аритметична прогресия, започваща с 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` изчислява 10-тия член на аритметична прогресия, започваща с -3, 1.\n\nЗабележка: Функцията предполага, че входните стойности за `a1`, `a2` и `n` следват ограниченията -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "zh": "计算给定其前两个项的等差数列的第n项。\n\n- 参数：\n- a1: 等差数列的第一项。\n- a2: 等差数列的第二项。\n- n: 要查找的数列中项的位置（从1开始的索引）。\n\n- 返回：等差数列的第n项。\n\n### 示例：\n- `arithmeticSequenceLastTerm(1, 4, 100)` 计算以1, 4开始的等差数列的第100项。\n- `arithmeticSequenceLastTerm(5, 9, 20)` 计算以5, 9开始的等差数列的第20项。\n- `arithmeticSequenceLastTerm(-3, 1, 10)` 计算以-3, 1开始的等差数列的第10项。\n\n注意：该函数假设输入值 `a1`、`a2` 和 `n` 遵循约束条件 -100 <= a1,a2 <= 100, 0 < n <= 1000。",
      "fr": "Calcule le nième terme d'une suite arithmétique donnée ses deux premiers termes.\n\n- Paramètres:\n- a1: Le premier terme de la suite arithmétique.\n- a2: Le deuxième terme de la suite arithmétique.\n- n: La position du terme dans la suite à trouver (index basé sur 1).\n\n- Renvoie: Le nième terme de la suite arithmétique.\n\n### Exemple:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calcule le 100ème terme d'une suite arithmétique commençant par 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calcule le 20ème terme d'une suite arithmétique commençant par 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calcule le 10ème terme d'une suite arithmétique commençant par -3, 1.\n\nRemarque: La fonction suppose que les valeurs d'entrée pour `a1`, `a2`, et `n` respectent les contraintes -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "de": "Berechnet das n-te Glied einer arithmetischen Folge, gegeben durch ihre ersten beiden Glieder.\n\n- Parameter:\n- a1: Das erste Glied der arithmetischen Folge.\n- a2: Das zweite Glied der arithmetischen Folge.\n- n: Die Position des zu findenden Glieds in der Folge (1-basierter Index).\n\n- Rückgabewert: Das n-te Glied der arithmetischen Folge.\n\n### Beispiel:\n- `arithmeticSequenceLastTerm(1, 4, 100)` berechnet das 100. Glied einer arithmetischen Folge, die mit 1, 4 beginnt.\n- `arithmeticSequenceLastTerm(5, 9, 20)` berechnet das 20. Glied einer arithmetischen Folge, die mit 5, 9 beginnt.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` berechnet das 10. Glied einer arithmetischen Folge, die mit -3, 1 beginnt.\n\nHinweis: Die Funktion geht davon aus, dass die Eingabewerte für `a1`, `a2` und `n` den Einschränkungen -100 <= a1,a2 <= 100, 0 < n <= 1000 entsprechen.",
      "ha": "Yana ƙididdige sharadi na n na jerin lissafi idan aka ba shi sharuddan farko guda biyu.\n\n- Sigogi:\n- a1: Sharadi na farko na jerin lissafi.\n- a2: Sharadi na biyu na jerin lissafi.\n- n: Matsayin sharadi a cikin jerin da za a samu (1-tushe index).\n\n- Komawa: Sharadi na n na jerin lissafi.\n\n### Misali:\n- `arithmeticSequenceLastTerm(1, 4, 100)` yana ƙididdige sharadi na 100 na jerin lissafi da ya fara da 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` yana ƙididdige sharadi na 20 na jerin lissafi da ya fara da 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` yana ƙididdige sharadi na 10 na jerin lissafi da ya fara da -3, 1.\n\nLura: Aikin yana ɗauka cewa ƙimar shigarwa don `a1`, `a2`, da `n` suna bin ƙuntatawa -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "hi": "गणितीय अनुक्रम के पहले दो पद दिए जाने पर इसका nth पद गणना करता है।\n\n- पैरामीटर्स:\n- a1: गणितीय अनुक्रम का पहला पद।\n- a2: गणितीय अनुक्रम का दूसरा पद।\n- n: अनुक्रम में उस पद की स्थिति जिसे खोजा जाना है (1-आधारित सूचकांक)।\n\n- रिटर्न करता है: गणितीय अनुक्रम का nth पद।\n\n### उदाहरण:\n- `arithmeticSequenceLastTerm(1, 4, 100)` 1, 4 से शुरू होने वाले गणितीय अनुक्रम के 100वें पद की गणना करता है।\n- `arithmeticSequenceLastTerm(5, 9, 20)` 5, 9 से शुरू होने वाले गणितीय अनुक्रम के 20वें पद की गणना करता है।\n- `arithmeticSequenceLastTerm(-3, 1, 10)` -3, 1 से शुरू होने वाले गणितीय अनुक्रम के 10वें पद की गणना करता है।\n\nनोट: यह फ़ंक्शन मानता है कि `a1`, `a2`, और `n` के लिए इनपुट मान निम्नलिखित बाधाओं का पालन करते हैं -100 <= a1,a2 <= 100, 0 < n <= 1000।",
      "hu": "Kiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tagja.\n\n- Paraméterek:\n- a1: A számtani sorozat első tagja.\n- a2: A számtani sorozat második tagja.\n- n: A sorozatban keresett tag pozíciója (1-alapú index).\n\n- Visszatér: A számtani sorozat n-edik tagja.\n\n### Példa:\n- `arithmeticSequenceLastTerm(1, 4, 100)` kiszámítja a számtani sorozat 100. tagját, amely 1, 4-gyel kezdődik.\n- `arithmeticSequenceLastTerm(5, 9, 20)` kiszámítja a számtani sorozat 20. tagját, amely 5, 9-cel kezdődik.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` kiszámítja a számtani sorozat 10. tagját, amely -3, 1-gyel kezdődik.\n\nMegjegyzés: A függvény feltételezi, hogy az `a1`, `a2` és `n` bemeneti értékek megfelelnek a következő korlátoknak: -100 <= a1,a2 <= 100, 0 < n <= 1000."
    },
    "docstring_bertscore": {
      "sq": "0.9764342929636398",
      "hy": "0.981081250727951",
      "bn": "0.9803826676778513",
      "bg": "0.9546632114199298",
      "zh": "0.9823616221641019",
      "fr": "0.9919199147298818",
      "de": "0.9712704989478759",
      "ha": "0.9857270167099761",
      "hi": "0.97955517351046",
      "hu": "0.9627552145129102"
    }
  },
  {
    "task_id": "Swift/47",
    "prompt": {
      "en": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calculates the product of two positive integers.\n\n    - Parameters:\n        - a: The first positive integer.\n        - b: The second positive integer.\n        - Both `a` and `b` should be in the range of 1 to 50,000.\n\n    - Returns: The product of `a` and `b` as an integer.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    Note: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n    */",
      "sq": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Llogarit produktin e dy numrave të plotë pozitivë.\n\n    - Parametrat:\n        - a: Numri i parë i plotë pozitiv.\n        - b: Numri i dytë i plotë pozitiv.\n        - Të dy `a` dhe `b` duhet të jenë në intervalin nga 1 deri në 50,000.\n\n    - Kthen: Produktin e `a` dhe `b` si një numër i plotë.\n\n    ### Shembull:\n    - `multiply(3, 4)` kthen `12`.\n    - `multiply(10, 5)` kthen `50`.\n    - `multiply(36, 18)` kthen `648`.\n\n    Shënim: Funksioni trajton shumëzimin brenda intervalit të specifikuar, duke siguruar që nuk ka mbingarkesë për vlerat deri në 50,000.\n    */",
      "hy": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Հաշվարկում է երկու դրական ամբողջ թվերի արտադրյալը։\n\n    - Պարամետրեր:\n        - a: Առաջին դրական ամբողջ թիվը։\n        - b: Երկրորդ դրական ամբողջ թիվը։\n        - Ե՛վ `a`, և՛ `b` պետք է լինեն 1-ից մինչև 50,000 միջակայքում։\n\n    - Վերադարձնում է: `a` և `b` թվերի արտադրյալը որպես ամբողջ թիվ։\n\n    ### Օրինակ:\n    - `multiply(3, 4)` վերադարձնում է `12`։\n    - `multiply(10, 5)` վերադարձնում է `50`։\n    - `multiply(36, 18)` վերադարձնում է `648`։\n\n    Նշում: Ֆունկցիան կատարում է բազմապատկում նշված միջակայքում՝ ապահովելով, որ չլինի արտահոսք մինչև 50,000 արժեքների համար։\n    */",
      "bn": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    দুটি ধনাত্মক পূর্ণসংখ্যার গুণফল গণনা করে।\n\n    - প্যারামিটার:\n        - a: প্রথম ধনাত্মক পূর্ণসংখ্যা।\n        - b: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n        - উভয় `a` এবং `b` এর মান 1 থেকে 50,000 এর মধ্যে হওয়া উচিত।\n\n    - রিটার্নস: `a` এবং `b` এর গুণফল একটি পূর্ণসংখ্যা হিসাবে।\n\n    ### উদাহরণ:\n    - `multiply(3, 4)` রিটার্ন করে `12`।\n    - `multiply(10, 5)` রিটার্ন করে `50`।\n    - `multiply(36, 18)` রিটার্ন করে `648`।\n\n    নোট: এই ফাংশন নির্দিষ্ট সীমার মধ্যে গুণফল পরিচালনা করে, 50,000 পর্যন্ত মানের জন্য কোনো ওভারফ্লো না হওয়া নিশ্চিত করে।\n    */",
      "bg": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Изчислява произведението на две положителни цели числа.\n\n    - Параметри:\n        - a: Първото положително цяло число.\n        - b: Второто положително цяло число.\n        - И двете `a` и `b` трябва да бъдат в диапазона от 1 до 50,000.\n\n    - Връща: Произведението на `a` и `b` като цяло число.\n\n    ### Пример:\n    - `multiply(3, 4)` връща `12`.\n    - `multiply(10, 5)` връща `50`.\n    - `multiply(36, 18)` връща `648`.\n\n    Забележка: Функцията обработва умножение в рамките на посочения диапазон, като осигурява липса на преливане за стойности до 50,000.\n    */",
      "zh": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    计算两个正整数的乘积。\n\n    - 参数:\n        - a: 第一个正整数。\n        - b: 第二个正整数。\n        - `a` 和 `b` 都应该在 1 到 50,000 的范围内。\n\n    - 返回: `a` 和 `b` 的乘积，作为整数。\n\n    ### 示例:\n    - `multiply(3, 4)` 返回 `12`。\n    - `multiply(10, 5)` 返回 `50`。\n    - `multiply(36, 18)` 返回 `648`。\n\n    注意: 该函数在指定范围内处理乘法，确保对于值高达 50,000 不会溢出。\n    */",
      "fr": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calcule le produit de deux entiers positifs.\n\n    - Paramètres :\n        - a : Le premier entier positif.\n        - b : Le deuxième entier positif.\n        - Les deux `a` et `b` doivent être dans la plage de 1 à 50 000.\n\n    - Renvoie : Le produit de `a` et `b` en tant qu'entier.\n\n    ### Exemple :\n    - `multiply(3, 4)` renvoie `12`.\n    - `multiply(10, 5)` renvoie `50`.\n    - `multiply(36, 18)` renvoie `648`.\n\n    Remarque : La fonction gère la multiplication dans la plage spécifiée, garantissant aucune surcharge pour des valeurs allant jusqu'à 50 000.\n    */",
      "de": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Berechnet das Produkt von zwei positiven ganzen Zahlen.\n\n    - Parameter:\n        - a: Die erste positive ganze Zahl.\n        - b: Die zweite positive ganze Zahl.\n        - Sowohl `a` als auch `b` sollten im Bereich von 1 bis 50.000 liegen.\n\n    - Rückgabe: Das Produkt von `a` und `b` als Ganzzahl.\n\n    ### Beispiel:\n    - `multiply(3, 4)` gibt `12` zurück.\n    - `multiply(10, 5)` gibt `50` zurück.\n    - `multiply(36, 18)` gibt `648` zurück.\n\n    Hinweis: Die Funktion behandelt die Multiplikation innerhalb des angegebenen Bereichs und stellt sicher, dass es bei Werten bis zu 50.000 nicht zu einem Überlauf kommt.\n    */",
      "ha": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Yana ƙididdige samfurin lambobi masu kyau guda biyu.\n\n    - Sigogi:\n        - a: Lamba ta farko mai kyau.\n        - b: Lamba ta biyu mai kyau.\n        - Duk `a` da `b` ya kamata su kasance a cikin zangon 1 zuwa 50,000.\n\n    - Yana Mayarwa: Samfurin `a` da `b` a matsayin lamba.\n\n    ### Misali:\n    - `multiply(3, 4)` yana mayar da `12`.\n    - `multiply(10, 5)` yana mayar da `50`.\n    - `multiply(36, 18)` yana mayar da `648`.\n\n    Lura: Aikin yana sarrafa ninkawa a cikin zangon da aka fayyace, yana tabbatar da babu cika iyaka don ƙimar har zuwa 50,000.\n    */",
      "hi": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    दो धनात्मक पूर्णांकों का गुणनफल गणना करता है।\n\n    - पैरामीटर्स:\n        - a: पहला धनात्मक पूर्णांक।\n        - b: दूसरा धनात्मक पूर्णांक।\n        - दोनों `a` और `b` 1 से 50,000 की सीमा में होने चाहिए।\n\n    - रिटर्न करता है: `a` और `b` का गुणनफल एक पूर्णांक के रूप में।\n\n    ### उदाहरण:\n    - `multiply(3, 4)` रिटर्न करता है `12`।\n    - `multiply(10, 5)` रिटर्न करता है `50`।\n    - `multiply(36, 18)` रिटर्न करता है `648`।\n\n    नोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर गुणा करता है, यह सुनिश्चित करते हुए कि 50,000 तक के मानों के लिए कोई ओवरफ्लो नहीं होता।\n    */",
      "hu": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Kiszámítja két pozitív egész szám szorzatát.\n\n    - Paraméterek:\n        - a: Az első pozitív egész szám.\n        - b: A második pozitív egész szám.\n        - Mind `a`, mind `b` az 1 és 50,000 közötti tartományban kell legyenek.\n\n    - Visszatér: `a` és `b` szorzata egész számként.\n\n    ### Példa:\n    - `multiply(3, 4)` visszaadja `12`.\n    - `multiply(10, 5)` visszaadja `50`.\n    - `multiply(36, 18)` visszaadja `648`.\n\n    Megjegyzés: A függvény kezeli a szorzást a megadott tartományon belül, biztosítva, hogy ne legyen túlcsordulás 50,000-ig terjedő értékek esetén.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.991591181449269",
      "hy": "0.992433374264857",
      "bn": "0.9843348163693025",
      "bg": "0.9942544175981848",
      "zh": "0.9894487541594268",
      "fr": "0.9973079624458342",
      "de": "0.9952964325770939",
      "ha": "0.9819923682857581",
      "hi": "0.9929595461442184",
      "hu": "0.9939584583304428"
    },
    "canonical_solution": "    return a * b\n}",
    "instruction": {
      "en": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar Swift cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8990590198137853",
      "bn": "0.8766499374861914",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.8871878750912352",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testMultiply() {\n    assert(multiply(3, 4) == 12, \"Product of 3 and 4 should be 12.\")\n    assert(multiply(10, 5) == 50, \"Product of 10 and 5 should be 50.\")\n    assert(multiply(36, 18) == 648, \"Product of 36 and 18 should be 648.\")\n    assert(multiply(1, 50000) == 50000, \"Product of 1 and 50000 should be 50000.\")\n    assert(multiply(123, 456) == 56088, \"Product of 123 and 456 should be 56088.\")\n    assert(multiply(500, 100) == 50000, \"Product of 500 and 100 should be 50000.\")\n}\n\n// Call the test function to verify the functionality\ntestMultiply()",
    "entry_point": "multiply",
    "signature": "func multiply(_ a: Int, _ b: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n",
      "sq": "Llogarit produktin e dy numrave të plotë pozitivë.\n\n- Parametrat:\n- a: Numri i parë i plotë pozitiv.\n- b: Numri i dytë i plotë pozitiv.\n- Të dy `a` dhe `b` duhet të jenë në intervalin nga 1 deri në 50,000.\n\n- Kthen: Produktin e `a` dhe `b` si një numër i plotë.\n\n### Shembull:\n- `multiply(3, 4)` kthen `12`.\n- `multiply(10, 5)` kthen `50`.\n- `multiply(36, 18)` kthen `648`.\n\nShënim: Funksioni trajton shumëzimin brenda intervalit të specifikuar, duke siguruar që nuk ka mbingarkesë për vlerat deri në 50,000.",
      "hy": "Հաշվում է երկու դրական ամբողջ թվերի արտադրյալը։\n\n- Պարամետրեր:\n- a: Առաջին դրական ամբողջ թիվը։\n- b: Երկրորդ դրական ամբողջ թիվը։\n- Թվերը `a` և `b` պետք է լինեն 1-ից մինչև 50,000 միջակայքում։\n\n- Վերադարձնում է: `a` և `b` թվերի արտադրյալը որպես ամբողջ թիվ։\n\n### Օրինակ:\n- `multiply(3, 4)` վերադարձնում է `12`։\n- `multiply(10, 5)` վերադարձնում է `50`։\n- `multiply(36, 18)` վերադարձնում է `648`։\n\nՆշում: Ֆունկցիան կատարում է բազմապատկում նշված միջակայքում, ապահովելով, որ 50,000-ի չափով արժեքների համար չլինի արտահոսք։",
      "bn": "Calculates the product of two positive integers.\n\n- প্যারামিটারসমূহ:\n- a: প্রথম ধনাত্মক পূর্ণসংখ্যা।\n- b: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n- উভয় `a` এবং `b` 1 থেকে 50,000 এর মধ্যে হওয়া উচিত।\n\n- রিটার্নস: `a` এবং `b` এর গুণফল একটি পূর্ণসংখ্যা হিসেবে।\n\n### উদাহরণ:\n- `multiply(3, 4)` রিটার্ন করে `12`।\n- `multiply(10, 5)` রিটার্ন করে `50`।\n- `multiply(36, 18)` রিটার্ন করে `648`।\n\nনোট: ফাংশনটি নির্দিষ্ট সীমার মধ্যে গুণফল পরিচালনা করে, নিশ্চিত করে যে 50,000 পর্যন্ত মানের জন্য কোন ওভারফ্লো হবে না।",
      "bg": "Изчислява произведението на две положителни цели числа.\n\n- Параметри:\n- a: Първото положително цяло число.\n- b: Второто положително цяло число.\n- И двете `a` и `b` трябва да са в диапазона от 1 до 50,000.\n\n- Връща: Произведението на `a` и `b` като цяло число.\n\n### Пример:\n- `multiply(3, 4)` връща `12`.\n- `multiply(10, 5)` връща `50`.\n- `multiply(36, 18)` връща `648`.\n\nЗабележка: Функцията обработва умножение в рамките на посочения диапазон, като гарантира, че няма преливане за стойности до 50,000.",
      "zh": "计算两个正整数的乘积。\n\n- 参数：\n- a: 第一个正整数。\n- b: 第二个正整数。\n- `a` 和 `b` 都应该在 1 到 50,000 的范围内。\n\n- 返回：`a` 和 `b` 的乘积，作为一个整数。\n\n### 示例：\n- `multiply(3, 4)` 返回 `12`。\n- `multiply(10, 5)` 返回 `50`。\n- `multiply(36, 18)` 返回 `648`。\n\n注意：该函数在指定范围内处理乘法，确保对于高达 50,000 的值不会溢出。",
      "fr": "Calcule le produit de deux entiers positifs.\n\n- Paramètres:\n- a: Le premier entier positif.\n- b: Le deuxième entier positif.\n- Les deux `a` et `b` doivent être dans la plage de 1 à 50 000.\n\n- Renvoie: Le produit de `a` et `b` en tant qu'entier.\n\n### Exemple:\n- `multiply(3, 4)` renvoie `12`.\n- `multiply(10, 5)` renvoie `50`.\n- `multiply(36, 18)` renvoie `648`.\n\nRemarque: La fonction gère la multiplication dans la plage spécifiée, en s'assurant qu'il n'y a pas de dépassement pour des valeurs allant jusqu'à 50 000.",
      "de": "Berechnet das Produkt von zwei positiven ganzen Zahlen.\n\n- Parameter:\n- a: Die erste positive ganze Zahl.\n- b: Die zweite positive ganze Zahl.\n- Sowohl `a` als auch `b` sollten im Bereich von 1 bis 50.000 liegen.\n\n- Rückgabewert: Das Produkt von `a` und `b` als ganze Zahl.\n\n### Beispiel:\n- `multiply(3, 4)` gibt `12` zurück.\n- `multiply(10, 5)` gibt `50` zurück.\n- `multiply(36, 18)` gibt `648` zurück.\n\nHinweis: Die Funktion behandelt die Multiplikation innerhalb des angegebenen Bereichs und stellt sicher, dass es bei Werten bis zu 50.000 zu keinem Überlauf kommt.",
      "ha": "Calculates the product of two positive integers.\n\n- Sigogi:\n- a: Na farko lamba mai kyau.\n- b: Na biyu lamba mai kyau.\n- Duk `a` da `b` ya kamata su kasance a cikin kewayon 1 zuwa 50,000.\n\n- Mayar da: Samfurin `a` da `b` a matsayin lamba.\n\n### Misali:\n- `multiply(3, 4)` yana mayar da `12`.\n- `multiply(10, 5)` yana mayar da `50`.\n- `multiply(36, 18)` yana mayar da `648`.\n\nLura: Aikin yana sarrafa ninkawa a cikin kewayon da aka fayyace, yana tabbatar da babu cika iyaka don ƙimar har zuwa 50,000.",
      "hi": "दो सकारात्मक पूर्णांकों का गुणनफल गणना करता है।\n\n- पैरामीटर्स:\n- a: पहला सकारात्मक पूर्णांक।\n- b: दूसरा सकारात्मक पूर्णांक।\n- दोनों `a` और `b` 1 से 50,000 की सीमा में होने चाहिए।\n\n- रिटर्न करता है: `a` और `b` का गुणनफल एक पूर्णांक के रूप में।\n\n### उदाहरण:\n- `multiply(3, 4)` `12` लौटाता है।\n- `multiply(10, 5)` `50` लौटाता है।\n- `multiply(36, 18)` `648` लौटाता है।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर गुणा को संभालता है, यह सुनिश्चित करते हुए कि 50,000 तक के मानों के लिए कोई ओवरफ्लो नहीं होता।",
      "hu": "Kiszámítja két pozitív egész szám szorzatát.\n\n- Paraméterek:\n- a: Az első pozitív egész szám.\n- b: A második pozitív egész szám.\n- Mindkettő, `a` és `b`, az 1 és 50,000 közötti tartományban kell legyen.\n\n- Visszatér: `a` és `b` szorzata egész számként.\n\n### Példa:\n- `multiply(3, 4)` visszatér `12`.\n- `multiply(10, 5)` visszatér `50`.\n- `multiply(36, 18)` visszatér `648`.\n\nMegjegyzés: A függvény kezeli a szorzást a megadott tartományon belül, biztosítva, hogy ne legyen túlcsordulás 50,000-ig terjedő értékek esetén."
    },
    "docstring_bertscore": {
      "sq": "0.9896477818012237",
      "hy": "0.9845388097706254",
      "bn": "0.9844420767750613",
      "bg": "0.9939320404897652",
      "zh": "0.883480041768457",
      "fr": "0.9920108874443958",
      "de": "0.9903261045524578",
      "ha": "0.9808699080025299",
      "hi": "0.9896384461733151",
      "hu": "0.9880921086569584"
    }
  },
  {
    "task_id": "Swift/48",
    "prompt": {
      "en": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calculates the power of 2 for a given non-negative integer.\n\n    - Parameters:\n        - n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n    - Returns: The result of 2 raised to the power of `n`.\n\n    ### Example:\n    - `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n    - `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n    - `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\n    Note: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n    */",
      "sq": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Llogarit fuqinë e 2 për një numër të dhënë jo-negativ.\n\n    - Parametrat:\n        - n: Një numër jo-negativ për të cilin llogaritet fuqia e 2. Vlera e `n` duhet të jetë në intervalin 0 deri 30, përfshirë.\n\n    - Kthen: Rezultatin e 2 ngritur në fuqinë e `n`.\n\n    ### Shembull:\n    - `powerOfTwo(3)` kthen `8`, pasi 2^3 = 8.\n    - `powerOfTwo(5)` kthen `32`, pasi 2^5 = 32.\n    - `powerOfTwo(10)` kthen `1024`, pasi 2^10 = 1024.\n\n    Shënim: Funksioni është projektuar për të trajtuar hyrjet brenda intervalit të specifikuar pa rezultuar në mbivendosje të numrave të plotë.\n    */",
      "hy": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Հաշվարկում է 2-ի աստիճանը տրված ոչ բացասական ամբողջ թվի համար։\n\n    - Պարամետրեր:\n        - n: Ոչ բացասական ամբողջ թիվ, որի համար հաշվարկվում է 2-ի աստիճանը։ `n`-ի արժեքը պետք է լինի 0-ից 30 միջակայքում, ներառյալ։\n\n    - Վերադարձնում է: 2-ի `n` աստիճանի արդյունքը։\n\n    ### Օրինակ:\n    - `powerOfTwo(3)` վերադարձնում է `8`, քանի որ 2^3 = 8։\n    - `powerOfTwo(5)` վերադարձնում է `32`, քանի որ 2^5 = 32։\n    - `powerOfTwo(10)` վերադարձնում է `1024`, քանի որ 2^10 = 1024։\n\n    Նշում: Ֆունկցիան նախատեսված է մշակելու նշված միջակայքում գտնվող մուտքերը՝ առանց ամբողջ թվի վերածման։\n    */",
      "bn": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    প্রদত্ত একটি অ-ঋণাত্মক পূর্ণসংখ্যার জন্য 2 এর ঘাত নির্ণয় করে।\n\n    - প্যারামিটার:\n        - n: একটি অ-ঋণাত্মক পূর্ণসংখ্যা যার জন্য 2 এর ঘাত নির্ণয় করা হয়। `n` এর মান 0 থেকে 30 এর মধ্যে হতে হবে, অন্তর্ভুক্ত।\n\n    - রিটার্নস: `n` এর ঘাত হিসাবে 2 এর ফলাফল প্রদান করে।\n\n    ### উদাহরণ:\n    - `powerOfTwo(3)` `8` প্রদান করে, কারণ 2^3 = 8।\n    - `powerOfTwo(5)` `32` প্রদান করে, কারণ 2^5 = 32।\n    - `powerOfTwo(10)` `1024` প্রদান করে, কারণ 2^10 = 1024।\n\n    দ্রষ্টব্য: ফাংশনটি নির্দিষ্ট সীমার মধ্যে ইনপুটগুলি পরিচালনা করার জন্য ডিজাইন করা হয়েছে যাতে পূর্ণসংখ্যার ওভারফ্লো না হয়।\n    */",
      "bg": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Изчислява степента на 2 за дадено неотрицателно цяло число.\n\n    - Параметри:\n        - n: Неотрицателно цяло число, за което се изчислява степента на 2. Стойността на `n` трябва да бъде в диапазона от 0 до 30, включително.\n\n    - Връща: Резултатът от 2, повдигнато на степен `n`.\n\n    ### Пример:\n    - `powerOfTwo(3)` връща `8`, тъй като 2^3 = 8.\n    - `powerOfTwo(5)` връща `32`, тъй като 2^5 = 32.\n    - `powerOfTwo(10)` връща `1024`, тъй като 2^10 = 1024.\n\n    Забележка: Функцията е проектирана да обработва входни данни в рамките на посочения диапазон без да води до препълване на цяло число.\n    */",
      "zh": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    计算给定非负整数的2的幂。\n\n    - 参数:\n        - n: 计算2的幂的非负整数。`n`的值必须在0到30之间（包括0和30）。\n\n    - 返回: 2的`n`次幂的结果。\n\n    ### 示例:\n    - `powerOfTwo(3)` 返回 `8`，因为 2^3 = 8。\n    - `powerOfTwo(5)` 返回 `32`，因为 2^5 = 32。\n    - `powerOfTwo(10)` 返回 `1024`，因为 2^10 = 1024。\n\n    注意: 该函数设计用于处理指定范围内的输入，不会导致整数溢出。\n    */",
      "fr": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calcule la puissance de 2 pour un entier non négatif donné.\n\n    - Paramètres:\n        - n: Un entier non négatif pour lequel la puissance de 2 est calculée. La valeur de `n` doit être dans la plage de 0 à 30, inclus.\n\n    - Retourne: Le résultat de 2 élevé à la puissance de `n`.\n\n    ### Exemple:\n    - `powerOfTwo(3)` retourne `8`, car 2^3 = 8.\n    - `powerOfTwo(5)` retourne `32`, car 2^5 = 32.\n    - `powerOfTwo(10)` retourne `1024`, car 2^10 = 1024.\n\n    Remarque: La fonction est conçue pour gérer les entrées dans la plage spécifiée sans entraîner de dépassement d'entier.\n    */",
      "de": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Berechnet die Potenz von 2 für eine gegebene nicht-negative ganze Zahl.\n\n    - Parameter:\n        - n: Eine nicht-negative ganze Zahl, für die die Potenz von 2 berechnet wird. Der Wert von `n` muss im Bereich von 0 bis 30 liegen, einschließlich.\n\n    - Rückgabe: Das Ergebnis von 2 hoch `n`.\n\n    ### Beispiel:\n    - `powerOfTwo(3)` gibt `8` zurück, da 2^3 = 8.\n    - `powerOfTwo(5)` gibt `32` zurück, da 2^5 = 32.\n    - `powerOfTwo(10)` gibt `1024` zurück, da 2^10 = 1024.\n\n    Hinweis: Die Funktion ist so konzipiert, dass sie Eingaben innerhalb des angegebenen Bereichs ohne Ganzzahlüberlauf verarbeitet.\n    */",
      "ha": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Lissafin ƙarfin 2 don wata lamba mai kyau mara kyau.\n\n    - Sigogi:\n        - n: Lamba mai kyau mara kyau wanda za a lissafa ƙarfin 2. Dole ne ƙimar `n` ta kasance a cikin kewayon 0 zuwa 30, ciki har da.\n\n    - Mayarwa: Sakamakon 2 da aka ɗaga zuwa ƙarfin `n`.\n\n    ### Misali:\n    - `powerOfTwo(3)` yana mayar da `8`, kamar yadda 2^3 = 8.\n    - `powerOfTwo(5)` yana mayar da `32`, kamar yadda 2^5 = 32.\n    - `powerOfTwo(10)` yana mayar da `1024`, kamar yadda 2^10 = 1024.\n\n    Lura: An tsara aikin don sarrafa shigarwa a cikin kewayon da aka fayyace ba tare da haifar da cikar lamba ba.\n    */",
      "hi": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    दिए गए गैर-ऋणात्मक पूर्णांक के लिए 2 की घात की गणना करता है।\n\n    - पैरामीटर्स:\n        - n: एक गैर-ऋणात्मक पूर्णांक जिसके लिए 2 की घात की गणना की जाती है। `n` का मान 0 से 30 की सीमा में होना चाहिए, समावेशी।\n\n    - रिटर्न्स: `n` की घात के रूप में 2 का परिणाम।\n\n    ### उदाहरण:\n    - `powerOfTwo(3)` `8` लौटाता है, क्योंकि 2^3 = 8।\n    - `powerOfTwo(5)` `32` लौटाता है, क्योंकि 2^5 = 32।\n    - `powerOfTwo(10)` `1024` लौटाता है, क्योंकि 2^10 = 1024।\n\n    नोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर इनपुट को संभालने के लिए डिज़ाइन किया गया है ताकि पूर्णांक ओवरफ्लो न हो।\n    */",
      "hu": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Kiszámítja a 2 hatványát egy adott nem negatív egész számra.\n\n    - Paraméterek:\n        - n: Egy nem negatív egész szám, amelyre a 2 hatványát kiszámítjuk. Az `n` értékének a 0 és 30 közötti tartományban kell lennie, beleértve.\n\n    - Visszatér: A 2 `n` hatványra emelésének eredménye.\n\n    ### Példa:\n    - `powerOfTwo(3)` visszaadja `8`, mivel 2^3 = 8.\n    - `powerOfTwo(5)` visszaadja `32`, mivel 2^5 = 32.\n    - `powerOfTwo(10)` visszaadja `1024`, mivel 2^10 = 1024.\n\n    Megjegyzés: A függvény úgy van tervezve, hogy a megadott tartományon belüli bemeneteket kezelje anélkül, hogy egész szám túlcsordulást eredményezne.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9832916096081072",
      "hy": "0.9696063736155656",
      "bn": "0.9574472148405149",
      "bg": "0.9869956689536459",
      "zh": "0.968703399903381",
      "fr": "0.9858813525160401",
      "de": "0.9791777757864937",
      "ha": "0.9875023750556658",
      "hi": "0.9770639512715205",
      "hu": "0.9835482400604043"
    },
    "canonical_solution": "    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}",
    "instruction": {
      "en": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nՏվեք Swift կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nস্বিফট কোডের একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nBayar da takaitaccen bayanin yaren halitta (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9229242614647462",
      "bn": "0.8766499374861914",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.9217926641839904",
      "hi": "0.9102601842611048",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testPowerOfTwo() {\n    assert(powerOfTwo(3) == 8, \"2^3 should be 8.\")\n    assert(powerOfTwo(5) == 32, \"2^5 should be 32.\")\n    assert(powerOfTwo(10) == 1024, \"2^10 should be 1024.\")\n    assert(powerOfTwo(0) == 1, \"2^0 should be 1.\")\n    assert(powerOfTwo(15) == 32768, \"2^15 should be 32768.\")\n    assert(powerOfTwo(30) == 1073741824, \"2^30 should be 1073741824.\")\n}\n\n// Call the test function to verify the functionality\ntestPowerOfTwo()",
    "entry_point": "powerOfTwo",
    "signature": "func powerOfTwo(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n",
      "sq": "Llogarit fuqinë e 2 për një numër të dhënë të plotë jo-negativ.\n\n- Parametrat:\n- n: Një numër i plotë jo-negativ për të cilin llogaritet fuqia e 2. Vlera e `n` duhet të jetë në intervalin nga 0 deri në 30, përfshirë.\n\n- Kthen: Rezultatin e 2 ngritur në fuqinë e `n`.\n\n### Shembull:\n- `powerOfTwo(3)` kthen `8`, pasi 2^3 = 8.\n- `powerOfTwo(5)` kthen `32`, pasi 2^5 = 32.\n- `powerOfTwo(10)` kthen `1024`, pasi 2^10 = 1024.\n\nShënim: Funksioni është projektuar për të trajtuar hyrjet brenda intervalit të specifikuar pa rezultuar në mbingarkesë të numrit të plotë.",
      "hy": "Հաշվում է 2-ի աստիճանը տրված ոչ բացասական ամբողջ թվի համար։\n\n- Պարամետրեր:\n- n: Ոչ բացասական ամբողջ թիվ, որի համար հաշվարկվում է 2-ի աստիճանը։ `n`-ի արժեքը պետք է լինի 0-ից 30 միջակայքում, ներառյալ։\n\n- Վերադարձնում է: 2-ի `n` աստիճանի արդյունքը։\n\n### Օրինակ:\n- `powerOfTwo(3)` վերադարձնում է `8`, քանի որ 2^3 = 8։\n- `powerOfTwo(5)` վերադարձնում է `32`, քանի որ 2^5 = 32։\n- `powerOfTwo(10)` վերադարձնում է `1024`, քանի որ 2^10 = 1024։\n\nՆշում: Ֆունկցիան նախատեսված է մշակելու մուտքերը նշված միջակայքում՝ առանց ամբողջ թվի գերազանցման։",
      "bn": "2 এর ঘাত একটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যার জন্য গণনা করে।\n\n- প্যারামিটারসমূহ:\n- n: একটি অ-ঋণাত্মক পূর্ণসংখ্যা যার জন্য 2 এর ঘাত গণনা করা হয়। `n` এর মান অবশ্যই 0 থেকে 30 এর মধ্যে থাকতে হবে, অন্তর্ভুক্ত।\n\n- রিটার্নস: `n` এর ঘাত হিসাবে 2 এর ফলাফল।\n\n### উদাহরণ:\n- `powerOfTwo(3)` `8` রিটার্ন করে, কারণ 2^3 = 8।\n- `powerOfTwo(5)` `32` রিটার্ন করে, কারণ 2^5 = 32।\n- `powerOfTwo(10)` `1024` রিটার্ন করে, কারণ 2^10 = 1024।\n\nদ্রষ্টব্য: ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে ইনপুটগুলি পরিচালনা করার জন্য ডিজাইন করা হয়েছে যাতে পূর্ণসংখ্যার ওভারফ্লো না ঘটে।",
      "bg": "Изчислява степента на 2 за дадено неотрицателно цяло число.\n\n- Параметри:\n- n: Неотрицателно цяло число, за което се изчислява степента на 2. Стойността на `n` трябва да бъде в диапазона от 0 до 30, включително.\n\n- Връща: Резултатът от 2, повдигнато на степен `n`.\n\n### Пример:\n- `powerOfTwo(3)` връща `8`, тъй като 2^3 = 8.\n- `powerOfTwo(5)` връща `32`, тъй като 2^5 = 32.\n- `powerOfTwo(10)` връща `1024`, тъй като 2^10 = 1024.\n\nЗабележка: Функцията е проектирана да обработва входни данни в рамките на посочения диапазон без да води до препълване на цяло число.",
      "zh": "计算给定非负整数的2的幂。\n\n- 参数：\n- n: 计算2的幂的非负整数。`n` 的值必须在0到30之间（包括0和30）。\n\n- 返回：2的`n`次幂的结果。\n\n### 示例：\n- `powerOfTwo(3)` 返回 `8`，因为 2^3 = 8。\n- `powerOfTwo(5)` 返回 `32`，因为 2^5 = 32。\n- `powerOfTwo(10)` 返回 `1024`，因为 2^10 = 1024。\n\n注意：该函数设计用于处理指定范围内的输入，不会导致整数溢出。",
      "fr": "Calcule la puissance de 2 pour un entier non négatif donné.\n\n- Paramètres:\n- n: Un entier non négatif pour lequel la puissance de 2 est calculée. La valeur de `n` doit être dans la plage de 0 à 30, inclus.\n\n- Renvoie: Le résultat de 2 élevé à la puissance de `n`.\n\n### Exemple:\n- `powerOfTwo(3)` renvoie `8`, car 2^3 = 8.\n- `powerOfTwo(5)` renvoie `32`, car 2^5 = 32.\n- `powerOfTwo(10)` renvoie `1024`, car 2^10 = 1024.\n\nRemarque: La fonction est conçue pour gérer les entrées dans la plage spécifiée sans entraîner de dépassement d'entier.",
      "de": "Berechnet die Potenz von 2 für eine gegebene nicht-negative ganze Zahl.\n\n- Parameter:\n- n: Eine nicht-negative ganze Zahl, für die die Potenz von 2 berechnet wird. Der Wert von `n` muss im Bereich von 0 bis 30 liegen, einschließlich.\n\n- Rückgabewert: Das Ergebnis von 2 hoch `n`.\n\n### Beispiel:\n- `powerOfTwo(3)` gibt `8` zurück, da 2^3 = 8.\n- `powerOfTwo(5)` gibt `32` zurück, da 2^5 = 32.\n- `powerOfTwo(10)` gibt `1024` zurück, da 2^10 = 1024.\n\nHinweis: Die Funktion ist so konzipiert, dass sie Eingaben innerhalb des angegebenen Bereichs ohne Ganzzahlüberlauf verarbeitet.",
      "ha": "Calculates the power of 2 for a given non-negative integer.\n\n- Sigogi:\n- n: Wani lamba mara kyau wanda ake lissafin ikon 2. Darajar `n` dole ne ta kasance a cikin kewayon 0 zuwa 30, ciki har da.\n\n- Komawa: Sakamakon 2 da aka ɗaga zuwa ikon `n`.\n\n### Misali:\n- `powerOfTwo(3)` yana dawo da `8`, kamar yadda 2^3 = 8.\n- `powerOfTwo(5)` yana dawo da `32`, kamar yadda 2^5 = 32.\n- `powerOfTwo(10)` yana dawo da `1024`, kamar yadda 2^10 = 1024.\n\nLura: An tsara aikin don sarrafa shigarwa a cikin kewayon da aka ƙayyade ba tare da haifar da kumburin lamba ba.",
      "hi": "2 की शक्ति की गणना एक दिए गए गैर-ऋणात्मक पूर्णांक के लिए करता है।\n\n- पैरामीटर्स:\n- n: एक गैर-ऋणात्मक पूर्णांक जिसके लिए 2 की शक्ति की गणना की जाती है। `n` का मान 0 से 30 की सीमा में होना चाहिए, दोनों शामिल हैं।\n\n- रिटर्न्स: `n` की शक्ति के रूप में 2 का परिणाम।\n\n### उदाहरण:\n- `powerOfTwo(3)` `8` लौटाता है, क्योंकि 2^3 = 8।\n- `powerOfTwo(5)` `32` लौटाता है, क्योंकि 2^5 = 32।\n- `powerOfTwo(10)` `1024` लौटाता है, क्योंकि 2^10 = 1024।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर इनपुट को संभालने के लिए डिज़ाइन किया गया है बिना पूर्णांक ओवरफ्लो के।",
      "hu": "Kiszámítja a 2 hatványát egy adott nem negatív egész számra.\n\n- Paraméterek:\n- n: Egy nem negatív egész szám, amelyre a 2 hatványát kiszámítjuk. Az `n` értékének 0 és 30 között kell lennie, beleértve ezeket is.\n\n- Visszatér: A 2 `n` hatványra emelésének eredménye.\n\n### Példa:\n- `powerOfTwo(3)` visszatér `8`, mivel 2^3 = 8.\n- `powerOfTwo(5)` visszatér `32`, mivel 2^5 = 32.\n- `powerOfTwo(10)` visszatér `1024`, mivel 2^10 = 1024.\n\nMegjegyzés: A függvény úgy van tervezve, hogy a megadott tartományon belüli bemeneteket kezelje anélkül, hogy egész szám túlcsordulást eredményezne."
    },
    "docstring_bertscore": {
      "sq": "0.9823657934021036",
      "hy": "0.9790959400695073",
      "bn": "0.9560488569580292",
      "bg": "0.9831710409668191",
      "zh": "0.8501149048837406",
      "fr": "0.9823201084144656",
      "de": "0.9643226068496565",
      "ha": "0.994084389992019",
      "hi": "0.9764696491714641",
      "hu": "0.9775279518416179"
    }
  },
  {
    "task_id": "Swift/49",
    "prompt": {
      "en": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */",
      "sq": "func determineSign(_ n: Int) -> String {\n    /**\n    Përcakton nëse një numër i dhënë është pozitiv, zero, apo negativ.\n\n    - Parametrat:\n        - n: Një vlerë e plotë që mund të variojë nga -10^9 deri në 10^9.\n\n    - Kthen: Një varg që tregon nëse numri i plotë është `pozitiv`, `zero`, apo `negativ`.\n\n    ### Shembull:\n    - `determineSign(3)` kthen `\"pozitiv\"`.\n    - `determineSign(0)` kthen `\"zero\"`.\n    - `determineSign(-5)` kthen `\"negativ\"`.\n\n    Shënim: Kjo funksion klasifikon saktësisht çdo numër të plotë brenda intervalit të specifikuar në njërën nga tre kategoritë.\n    */",
      "hy": "func determineSign(_ n: Int) -> String {\n    /**\n    Սահմանում է, արդյոք տրված ամբողջ թիվը դրական է, զրո, թե բացասական:\n\n    - Պարամետրեր:\n        - n: Ամբողջ թիվ, որը կարող է լինել -10^9-ից մինչև 10^9:\n\n    - Վերադարձնում է: Տող, որը ցույց է տալիս, արդյոք ամբողջ թիվը `դրական`, `զրո`, թե `բացասական` է:\n\n    ### Օրինակ:\n    - `determineSign(3)` վերադարձնում է `\"positive\"`.\n    - `determineSign(0)` վերադարձնում է `\"zero\"`.\n    - `determineSign(-5)` վերադարձնում է `\"negative\"`.\n\n    Նշում: Այս ֆունկցիան ճշգրիտ կերպով դասակարգում է նշված տիրույթում գտնվող ցանկացած ամբողջ թիվ երեք կատեգորիաներից մեկում:\n    */",
      "bn": "func determineSign(_ n: Int) -> String {\n    /**\n    একটি প্রদত্ত পূর্ণসংখ্যা ধনাত্মক, শূন্য, বা ঋণাত্মক কিনা তা নির্ধারণ করে।\n\n    - প্যারামিটার:\n        - n: একটি পূর্ণসংখ্যা যা -10^9 থেকে 10^9 পর্যন্ত হতে পারে।\n\n    - রিটার্নস: একটি স্ট্রিং যা নির্দেশ করে যে পূর্ণসংখ্যাটি `positive`, `zero`, বা `negative`।\n\n    ### উদাহরণ:\n    - `determineSign(3)` রিটার্ন করে `\"positive\"`।\n    - `determineSign(0)` রিটার্ন করে `\"zero\"`।\n    - `determineSign(-5)` রিটার্ন করে `\"negative\"`।\n\n    নোট: এই ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে যেকোনো পূর্ণসংখ্যাকে সঠিকভাবে তিনটি শ্রেণীর একটিতে শ্রেণীবদ্ধ করে।\n    */",
      "bg": "func determineSign(_ n: Int) -> String {\n    /**\n    Определя дали дадено цяло число е положително, нула или отрицателно.\n\n    - Параметри:\n        - n: Цяло число, което може да варира от -10^9 до 10^9.\n\n    - Връща: Низ, който указва дали цялото число е `положително`, `нула` или `отрицателно`.\n\n    ### Пример:\n    - `determineSign(3)` връща `\"positive\"`.\n    - `determineSign(0)` връща `\"zero\"`.\n    - `determineSign(-5)` връща `\"negative\"`.\n\n    Забележка: Тази функция точно класифицира всяко цяло число в рамките на посочения диапазон в една от трите категории.\n    */",
      "zh": "func determineSign(_ n: Int) -> String {\n    /**\n    确定给定的整数是正数、零还是负数。\n\n    - 参数:\n        - n: 一个整数值，范围可以从 -10^9 到 10^9。\n\n    - 返回: 一个字符串，指示整数是 `positive`、`zero` 还是 `negative`。\n\n    ### 示例:\n    - `determineSign(3)` 返回 `\"positive\"`。\n    - `determineSign(0)` 返回 `\"zero\"`。\n    - `determineSign(-5)` 返回 `\"negative\"`。\n\n    注意: 此函数可以准确地将指定范围内的任何整数分类为三种类别之一。\n    */",
      "fr": "func determineSign(_ n: Int) -> String {\n    /**\n    Détermine si un entier donné est positif, nul ou négatif.\n\n    - Paramètres :\n        - n : Une valeur entière qui peut varier de -10^9 à 10^9.\n\n    - Renvoie : Une chaîne de caractères qui indique si l'entier est `positif`, `nul` ou `négatif`.\n\n    ### Exemple :\n    - `determineSign(3)` renvoie `\"positive\"`.\n    - `determineSign(0)` renvoie `\"zero\"`.\n    - `determineSign(-5)` renvoie `\"negative\"`.\n\n    Remarque : Cette fonction classe avec précision tout entier dans la plage spécifiée dans l'une des trois catégories.\n    */",
      "de": "func determineSign(_ n: Int) -> String {\n    /**\n    Bestimmt, ob eine gegebene Ganzzahl positiv, null oder negativ ist.\n\n    - Parameter:\n        - n: Ein Ganzzahlwert, der von -10^9 bis 10^9 reichen kann.\n\n    - Rückgabe: Ein String, der angibt, ob die Ganzzahl `positiv`, `null` oder `negativ` ist.\n\n    ### Beispiel:\n    - `determineSign(3)` gibt `\"positive\"` zurück.\n    - `determineSign(0)` gibt `\"zero\"` zurück.\n    - `determineSign(-5)` gibt `\"negative\"` zurück.\n\n    Hinweis: Diese Funktion klassifiziert jede Ganzzahl innerhalb des angegebenen Bereichs genau in eine der drei Kategorien.\n    */",
      "ha": "func determineSign(_ n: Int) -> String {\n    /**\n    Yana tantance ko wani cikakken lamba yana da kyau, sifili, ko mara kyau.\n\n    - Sigogi:\n        - n: Wani cikakken lamba wanda zai iya kasancewa daga -10^9 zuwa 10^9.\n\n    - Komawa: Wani kirtani wanda yake nuna ko cikakken lambar `mai kyau`, `sifili`, ko `mara kyau`.\n\n    ### Misali:\n    - `determineSign(3)` yana dawowa `\"positive\"`.\n    - `determineSign(0)` yana dawowa `\"zero\"`.\n    - `determineSign(-5)` yana dawowa `\"negative\"`.\n\n    Lura: Wannan aikin yana daidai rarraba duk wani cikakken lamba a cikin kewayon da aka ayyana zuwa ɗaya daga cikin rukuni uku.\n    */",
      "hi": "func determineSign(_ n: Int) -> String {\n    /**\n    यह निर्धारित करता है कि दिया गया पूर्णांक धनात्मक, शून्य, या ऋणात्मक है।\n\n    - पैरामीटर्स:\n        - n: एक पूर्णांक मान जो -10^9 से 10^9 तक हो सकता है।\n\n    - रिटर्न्स: एक स्ट्रिंग जो यह इंगित करती है कि पूर्णांक `positive`, `zero`, या `negative` है।\n\n    ### उदाहरण:\n    - `determineSign(3)` `\"positive\"` लौटाता है।\n    - `determineSign(0)` `\"zero\"` लौटाता है।\n    - `determineSign(-5)` `\"negative\"` लौटाता है।\n\n    नोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक को तीन श्रेणियों में से एक में सही ढंग से वर्गीकृत करता है।\n    */",
      "hu": "func determineSign(_ n: Int) -> String {\n    /**\n    Meghatározza, hogy egy adott egész szám pozitív, nulla vagy negatív.\n\n    - Paraméterek:\n        - n: Egy egész szám, amely -10^9 és 10^9 között lehet.\n\n    - Visszatér: Egy string, amely jelzi, hogy az egész szám `pozitív`, `nulla` vagy `negatív`.\n\n    ### Példa:\n    - `determineSign(3)` visszatér `\"positive\"`.\n    - `determineSign(0)` visszatér `\"zero\"`.\n    - `determineSign(-5)` visszatér `\"negative\"`.\n\n    Megjegyzés: Ez a függvény pontosan osztályoz bármely egész számot a megadott tartományon belül a három kategória egyikébe.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9930646216157858",
      "hy": "0.9893047471331764",
      "bn": "0.9872920254821499",
      "bg": "0.992467538690395",
      "zh": "0.9777349246986563",
      "fr": "0.9968975920786161",
      "de": "0.9873881625865708",
      "ha": "0.9785324256785114",
      "hi": "0.9932604711714862",
      "hu": "0.9883922391627021"
    },
    "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}",
    "instruction": {
      "en": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nSwift կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\n请用不超过500个字符的中文，为以下Swift代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Swift a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.9324648759266139",
      "bn": "0.8733351936874811",
      "bg": "0.8273796714704873",
      "zh": "0.8458660024030233",
      "fr": "0.9680399744307244",
      "de": "0.9224157676892968",
      "ha": "0.8890841993389753",
      "hi": "0.9244314687960389",
      "hu": "0.9522244276015835"
    },
    "level": "",
    "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()",
    "entry_point": "determineSign",
    "signature": "func determineSign(_ n: Int) -> String {",
    "docstring": {
      "en": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n",
      "sq": "Përcakton nëse një numër i dhënë është pozitiv, zero, apo negativ.\n\n- Parametrat:\n- n: Një vlerë e plotë që mund të variojë nga -10^9 deri në 10^9.\n\n- Kthen: Një varg që tregon nëse numri i plotë është `pozitiv`, `zero`, ose `negativ`.\n\n### Shembull:\n- `determineSign(3)` kthen `\"pozitiv\"`.\n- `determineSign(0)` kthen `\"zero\"`.\n- `determineSign(-5)` kthen `\"negativ\"`.\n\nShënim: Kjo funksion klasifikon saktësisht çdo numër të plotë brenda intervalit të specifikuar në njërën nga tre kategoritë.",
      "hy": "Սահմանում է, արդյոք տրված ամբողջ թիվը դրական է, զրո, թե բացասական:\n\n- Պարամետրեր:\n- n: Ամբողջ թիվ, որը կարող է տատանվել -10^9-ից մինչև 10^9:\n\n- Վերադարձնում է: Տող, որը ցույց է տալիս, արդյոք ամբողջ թիվը `դրական`, `զրո`, թե `բացասական` է:\n\n### Օրինակ:\n- `determineSign(3)` վերադարձնում է `\"positive\"`:\n- `determineSign(0)` վերադարձնում է `\"zero\"`:\n- `determineSign(-5)` վերադարձնում է `\"negative\"`:\n\nՆշում: Այս ֆունկցիան ճշգրիտ դասակարգում է նշված տիրույթում գտնվող ցանկացած ամբողջ թիվ երեք կատեգորիաներից մեկում:",
      "bn": "একটি প্রদত্ত পূর্ণসংখ্যা ধনাত্মক, শূন্য, বা ঋণাত্মক কিনা তা নির্ধারণ করে।\n\n- প্যারামিটারসমূহ:\n- n: একটি পূর্ণসংখ্যার মান যা -10^9 থেকে 10^9 এর মধ্যে হতে পারে।\n\n- রিটার্নস: একটি স্ট্রিং যা নির্দেশ করে যে পূর্ণসংখ্যাটি `positive`, `zero`, বা `negative`।\n\n### উদাহরণ:\n- `determineSign(3)` রিটার্ন করে `\"positive\"`।\n- `determineSign(0)` রিটার্ন করে `\"zero\"`।\n- `determineSign(-5)` রিটার্ন করে `\"negative\"`।\n\nনোট: এই ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে যে কোনো পূর্ণসংখ্যাকে সঠিকভাবে তিনটি শ্রেণীর একটিতে শ্রেণীবদ্ধ করে।",
      "bg": "Определя дали дадено цяло число е положително, нула или отрицателно.\n\n- Параметри:\n- n: Цяло число, което може да варира от -10^9 до 10^9.\n\n- Връща: Низ, който указва дали цялото число е `положително`, `нула` или `отрицателно`.\n\n### Пример:\n- `determineSign(3)` връща `\"positive\"`.\n- `determineSign(0)` връща `\"zero\"`.\n- `determineSign(-5)` връща `\"negative\"`.\n\nЗабележка: Тази функция точно класифицира всяко цяло число в посочения диапазон в една от трите категории.",
      "zh": "确定给定的整数是正数、零还是负数。\n\n- 参数:\n- n: 一个整数值，范围可以从 -10^9 到 10^9。\n\n- 返回: 一个字符串，指示整数是 `positive`、`zero` 还是 `negative`。\n\n### 示例:\n- `determineSign(3)` 返回 `\"positive\"`。\n- `determineSign(0)` 返回 `\"zero\"`。\n- `determineSign(-5)` 返回 `\"negative\"`。\n\n注意: 此函数可以准确地将指定范围内的任何整数分类为三种类别之一。",
      "fr": "Détermine si un entier donné est positif, nul ou négatif.\n\n- Paramètres:\n- n: Une valeur entière qui peut aller de -10^9 à 10^9.\n\n- Renvoie: Une chaîne de caractères qui indique si l'entier est `positif`, `nul` ou `négatif`.\n\n### Exemple:\n- `determineSign(3)` renvoie `\"positive\"`.\n- `determineSign(0)` renvoie `\"zero\"`.\n- `determineSign(-5)` renvoie `\"negative\"`.\n\nRemarque: Cette fonction classe avec précision tout entier dans la plage spécifiée dans l'une des trois catégories.",
      "de": "Bestimmt, ob eine gegebene ganze Zahl positiv, null oder negativ ist.\n\n- Parameter:\n- n: Ein ganzzahliger Wert, der von -10^9 bis 10^9 reichen kann.\n\n- Rückgabe: Ein String, der angibt, ob die ganze Zahl `positiv`, `null` oder `negativ` ist.\n\n### Beispiel:\n- `determineSign(3)` gibt `\"positive\"` zurück.\n- `determineSign(0)` gibt `\"zero\"` zurück.\n- `determineSign(-5)` gibt `\"negative\"` zurück.\n\nHinweis: Diese Funktion klassifiziert jede ganze Zahl innerhalb des angegebenen Bereichs genau in eine der drei Kategorien.",
      "ha": "Yana tantance ko wani lamba cikakke yana da kyau, sifili, ko mara kyau.\n\n- Sigogi:\n- n: Wani lamba cikakke wanda zai iya kasancewa daga -10^9 zuwa 10^9.\n\n- Komawa: Wani rubutu wanda ke nuna ko lamba cikakke yana da `kyau`, `sifili`, ko `mara kyau`.\n\n### Misali:\n- `determineSign(3)` yana dawowa `\"positive\"`.\n- `determineSign(0)` yana dawowa `\"zero\"`.\n- `determineSign(-5)` yana dawowa `\"negative\"`.\n\nLura: Wannan aikin yana daidai da rarraba duk wani lamba cikakke a cikin kewayon da aka kayyade zuwa ɗaya daga cikin rukuni uku.",
      "hi": "निर्धारित करता है कि दिया गया पूर्णांक सकारात्मक, शून्य, या नकारात्मक है।\n\n- पैरामीटर्स:\n- n: एक पूर्णांक मान जो -10^9 से 10^9 तक हो सकता है।\n\n- रिटर्न्स: एक स्ट्रिंग जो यह इंगित करती है कि पूर्णांक `positive`, `zero`, या `negative` है।\n\n### उदाहरण:\n- `determineSign(3)` रिटर्न करता है `\"positive\"`।\n- `determineSign(0)` रिटर्न करता है `\"zero\"`।\n- `determineSign(-5)` रिटर्न करता है `\"negative\"`।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक को तीन श्रेणियों में से एक में सही ढंग से वर्गीकृत करता है।",
      "hu": "Meghatározza, hogy egy adott egész szám pozitív, nulla vagy negatív.\n\n- Paraméterek:\n- n: Egy egész szám, amely -10^9 és 10^9 között lehet.\n\n- Visszatér: Egy sztring, amely jelzi, hogy az egész szám `pozitív`, `nulla` vagy `negatív`.\n\n### Példa:\n- `determineSign(3)` visszatér `\"positive\"`.\n- `determineSign(0)` visszatér `\"zero\"`.\n- `determineSign(-5)` visszatér `\"negative\"`.\n\nMegjegyzés: Ez a függvény pontosan osztályozza a megadott tartományon belüli bármely egész számot a három kategória egyikébe."
    },
    "docstring_bertscore": {
      "sq": "0.9903292826385544",
      "hy": "0.987588580641035",
      "bn": "0.9802203866565459",
      "bg": "0.9914547223774981",
      "zh": "0.9739347282486968",
      "fr": "0.986079982897075",
      "de": "0.9889277466699722",
      "ha": "0.96827713910568",
      "hi": "0.9900279603505244",
      "hu": "0.9816924364103954"
    }
  },
  {
    "task_id": "Swift/50",
    "prompt": {
      "en": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calculates and returns the absolute value of a given integer.\n\n    - Parameters:\n        - n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n    - Returns: The absolute value of `n`.\n\n    ### Example:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    Note: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n    */",
      "sq": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Llogarit dhe kthen vlerën absolute të një numri të dhënë të plotë.\n\n    - Parametra:\n        - n: Një numër i plotë për të cilin do të llogaritet vlera absolute. Vlera e `n` nuk duhet të kalojë vlerën absolute të 10000.\n\n    - Kthen: Vlera absolute e `n`.\n\n    ### Shembull:\n    - `absoluteValue(-3)` kthen `3`.\n    - `absoluteValue(5)` kthen `5`.\n    - `absoluteValue(0)` kthen `0`.\n    - `absoluteValue(-10000)` kthen `10000`.\n\n    Shënim: Kjo funksion siguron që vlera absolute të llogaritet saktë për çdo numër të plotë brenda kufirit të specifikuar.\n    */",
      "hy": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Հաշվում և վերադարձնում է տրված ամբողջ թվի բացարձակ արժեքը։\n\n    - Պարամետրեր:\n        - n: Ամբողջ թիվ, որի բացարձակ արժեքը պետք է հաշվարկվի։ `n`-ի արժեքը չպետք է գերազանցի 10000-ի բացարձակ արժեքը։\n\n    - Վերադարձնում է: `n`-ի բացարձակ արժեքը։\n\n    ### Օրինակ:\n    - `absoluteValue(-3)` վերադարձնում է `3`։\n    - `absoluteValue(5)` վերադարձնում է `5`։\n    - `absoluteValue(0)` վերադարձնում է `0`։\n    - `absoluteValue(-10000)` վերադարձնում է `10000`։\n\n    Նշում: Այս ֆունկցիան ապահովում է, որ բացարձակ արժեքը ճիշտ հաշվարկվի ցանկացած ամբողջ թվի համար սահմանված սահմաններում։\n    */",
      "bn": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    একটি প্রদত্ত পূর্ণসংখ্যার মান নির্ণয় করে এবং ফেরত দেয়।\n\n    - প্যারামিটার:\n        - n: একটি পূর্ণসংখ্যা যার মান নির্ণয় করতে হবে। `n` এর মান অবশ্যই 10000 এর মান অতিক্রম করা উচিত নয়।\n\n    - ফেরত দেয়: `n` এর মান।\n\n    ### উদাহরণ:\n    - `absoluteValue(-3)` ফেরত দেয় `3`।\n    - `absoluteValue(5)` ফেরত দেয় `5`।\n    - `absoluteValue(0)` ফেরত দেয় `0`।\n    - `absoluteValue(-10000)` ফেরত দেয় `10000`।\n\n    নোট: এই ফাংশন নিশ্চিত করে যে নির্দিষ্ট সীমার মধ্যে যেকোনো পূর্ণসংখ্যার জন্য মান সঠিকভাবে নির্ণয় করা হয়।\n    */",
      "bg": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Изчислява и връща абсолютната стойност на дадено цяло число.\n\n    - Параметри:\n        - n: Цяло число, чиято абсолютна стойност трябва да бъде изчислена. Стойността на `n` не трябва да надвишава абсолютната стойност на 10000.\n\n    - Връща: Абсолютната стойност на `n`.\n\n    ### Пример:\n    - `absoluteValue(-3)` връща `3`.\n    - `absoluteValue(5)` връща `5`.\n    - `absoluteValue(0)` връща `0`.\n    - `absoluteValue(-10000)` връща `10000`.\n\n    Забележка: Тази функция гарантира, че абсолютната стойност е правилно изчислена за всяко цяло число в рамките на посочения лимит.\n    */",
      "zh": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    计算并返回给定整数的绝对值。\n\n    - 参数:\n        - n: 要计算绝对值的整数。`n` 的值不得超过绝对值 10000。\n\n    - 返回: `n` 的绝对值。\n\n    ### 示例:\n    - `absoluteValue(-3)` 返回 `3`。\n    - `absoluteValue(5)` 返回 `5`。\n    - `absoluteValue(0)` 返回 `0`。\n    - `absoluteValue(-10000)` 返回 `10000`。\n\n    注意: 此函数确保在指定限制内正确计算任何整数的绝对值。\n    */",
      "fr": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calcule et retourne la valeur absolue d'un entier donné.\n\n    - Paramètres:\n        - n: Un entier dont la valeur absolue doit être calculée. La valeur de `n` ne doit pas dépasser la valeur absolue de 10000.\n\n    - Retourne: La valeur absolue de `n`.\n\n    ### Exemple:\n    - `absoluteValue(-3)` retourne `3`.\n    - `absoluteValue(5)` retourne `5`.\n    - `absoluteValue(0)` retourne `0`.\n    - `absoluteValue(-10000)` retourne `10000`.\n\n    Remarque: Cette fonction garantit que la valeur absolue est correctement calculée pour tout entier dans la limite spécifiée.\n    */",
      "de": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Berechnet und gibt den absoluten Wert einer gegebenen ganzen Zahl zurück.\n\n    - Parameter:\n        - n: Eine ganze Zahl, deren absoluter Wert berechnet werden soll. Der Wert von `n` darf den absoluten Wert von 10000 nicht überschreiten.\n\n    - Rückgabe: Der absolute Wert von `n`.\n\n    ### Beispiel:\n    - `absoluteValue(-3)` gibt `3` zurück.\n    - `absoluteValue(5)` gibt `5` zurück.\n    - `absoluteValue(0)` gibt `0` zurück.\n    - `absoluteValue(-10000)` gibt `10000` zurück.\n\n    Hinweis: Diese Funktion stellt sicher, dass der absolute Wert für jede ganze Zahl innerhalb des angegebenen Limits korrekt berechnet wird.\n    */",
      "ha": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Lissafa kuma ya dawo da ƙimar cikakken adadi na wani cikakken lamba.\n\n    - Ma'auni:\n        - n: Wani cikakken lamba wanda za a lissafa ƙimar cikakken adadinsa. Ƙimar `n` bai kamata ya wuce ƙimar cikakken adadi na 10000 ba.\n\n    - Dawowa: Ƙimar cikakken adadi na `n`.\n\n    ### Misali:\n    - `absoluteValue(-3)` ya dawo da `3`.\n    - `absoluteValue(5)` ya dawo da `5`.\n    - `absoluteValue(0)` ya dawo da `0`.\n    - `absoluteValue(-10000)` ya dawo da `10000`.\n\n    Lura: Wannan aikin yana tabbatar da cewa an lissafa ƙimar cikakken adadi daidai ga kowane cikakken lamba a cikin iyaka da aka kayyade.\n    */",
      "hi": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    दिए गए पूर्णांक का परिमाण गणना करता है और लौटाता है।\n\n    - पैरामीटर्स:\n        - n: एक पूर्णांक जिसका परिमाण गणना किया जाना है। `n` का मान 10000 के परिमाण से अधिक नहीं होना चाहिए।\n\n    - रिटर्न्स: `n` का परिमाण।\n\n    ### उदाहरण:\n    - `absoluteValue(-3)` `3` लौटाता है।\n    - `absoluteValue(5)` `5` लौटाता है।\n    - `absoluteValue(0)` `0` लौटाता है।\n    - `absoluteValue(-10000)` `10000` लौटाता है।\n\n    नोट: यह फ़ंक्शन सुनिश्चित करता है कि निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक के लिए परिमाण सही ढंग से गणना किया गया है।\n    */",
      "hu": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Kiszámítja és visszaadja egy adott egész szám abszolút értékét.\n\n    - Paraméterek:\n        - n: Egy egész szám, amelynek az abszolút értékét ki kell számítani. Az `n` értéke nem haladhatja meg a 10000 abszolút értékét.\n\n    - Visszatér: Az `n` abszolút értéke.\n\n    ### Példa:\n    - `absoluteValue(-3)` visszaadja `3`.\n    - `absoluteValue(5)` visszaadja `5`.\n    - `absoluteValue(0)` visszaadja `0`.\n    - `absoluteValue(-10000)` visszaadja `10000`.\n\n    Megjegyzés: Ez a függvény biztosítja, hogy az abszolút érték helyesen legyen kiszámítva bármely egész számra a megadott határon belül.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9899548643703037",
      "hy": "0.9867356617848712",
      "bn": "0.97518292156312",
      "bg": "0.9953445011293043",
      "zh": "0.9704428061501035",
      "fr": "0.9953445011293043",
      "de": "0.9879488961522322",
      "ha": "0.9911245986842181",
      "hi": "0.960750438077125",
      "hu": "0.9953445011293043"
    },
    "canonical_solution": "    return abs(n)\n}",
    "instruction": {
      "en": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "sq": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Swift në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nSwift կոդի համար տրամադրեք կարճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nনিচের Swift কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।",
      "bg": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nПредоставете кратко описание на Swift кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\n请用中文为以下 Swift 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Swift en français en utilisant au maximum 500 caractères.",
      "de": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Swift-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Swift a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nस्विफ्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Swift kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9534891072376327",
      "hy": "0.8828916985798316",
      "bn": "0.8968238321359997",
      "bg": "0.8273796714704873",
      "zh": "0.8602410817088992",
      "fr": "0.9680399744307244",
      "de": "0.9361661544468179",
      "ha": "0.9086230726606153",
      "hi": "0.9102601842611048",
      "hu": "0.9430238683520475"
    },
    "level": "",
    "test": "func testAbsoluteValue() {\n    assert(absoluteValue(-3) == 3, \"-3's absolute value should be 3.\")\n    assert(absoluteValue(5) == 5, \"5's absolute value should be 5.\")\n    assert(absoluteValue(0) == 0, \"0's absolute value should be 0.\")\n    assert(absoluteValue(-10000) == 10000, \"-10000's absolute value should be 10000.\")\n    assert(absoluteValue(10000) == 10000, \"10000's absolute value should be 10000.\")\n    assert(absoluteValue(-1) == 1, \"-1's absolute value should be 1.\")\n}\n\n// Call the test function to verify the functionality\ntestAbsoluteValue()",
    "entry_point": "absoluteValue",
    "signature": "func absoluteValue(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n",
      "sq": "Llogarit dhe kthen vlerën absolute të një numri të plotë të dhënë.\n\n- Parametrat:\n- n: Një numër i plotë për të cilin do të llogaritet vlera absolute. Vlera e `n` nuk duhet të kalojë vlerën absolute të 10000.\n\n- Kthen: Vlera absolute e `n`.\n\n### Shembull:\n- `absoluteValue(-3)` kthen `3`.\n- `absoluteValue(5)` kthen `5`.\n- `absoluteValue(0)` kthen `0`.\n- `absoluteValue(-10000)` kthen `10000`.\n\nShënim: Kjo funksion siguron që vlera absolute të llogaritet saktë për çdo numër të plotë brenda kufirit të specifikuar.",
      "hy": "Հաշվարկում և վերադարձնում է տրված ամբողջ թվի բացարձակ արժեքը։\n\n- Պարամետրեր:\n- n: Ամբողջ թիվ, որի բացարձակ արժեքը պետք է հաշվարկվի։ `n`-ի արժեքը չպետք է գերազանցի 10000-ի բացարձակ արժեքը։\n\n- Վերադարձնում է: `n`-ի բացարձակ արժեքը։\n\n### Օրինակ:\n- `absoluteValue(-3)` վերադարձնում է `3`։\n- `absoluteValue(5)` վերադարձնում է `5`։\n- `absoluteValue(0)` վերադարձնում է `0`։\n- `absoluteValue(-10000)` վերադարձնում է `10000`։\n\nՆշում: Այս ֆունկցիան ապահովում է, որ բացարձակ արժեքը ճիշտ հաշվարկվի ցանկացած ամբողջ թվի համար նշված սահմանափակման շրջանակներում։",
      "bn": "নির্দিষ্ট পূর্ণসংখ্যার জন্য গাণিতিক পরম মান গণনা করে এবং ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- n: একটি পূর্ণসংখ্যা যার পরম মান গণনা করা হবে। `n` এর মান অবশ্যই 10000 এর পরম মান অতিক্রম করতে পারবে না।\n\n- রিটার্নস: `n` এর পরম মান।\n\n### উদাহরণ:\n- `absoluteValue(-3)` রিটার্ন করে `3`।\n- `absoluteValue(5)` রিটার্ন করে `5`।\n- `absoluteValue(0)` রিটার্ন করে `0`।\n- `absoluteValue(-10000)` রিটার্ন করে `10000`।\n\nনোট: এই ফাংশন নিশ্চিত করে যে নির্দিষ্ট সীমার মধ্যে যেকোনো পূর্ণসংখ্যার জন্য পরম মান সঠিকভাবে গণনা করা হয়।",
      "bg": "Изчислява и връща абсолютната стойност на дадено цяло число.\n\n- Параметри:\n- n: Цяло число, чиято абсолютна стойност трябва да бъде изчислена. Стойността на `n` не трябва да надвишава абсолютната стойност на 10000.\n\n- Връща: Абсолютната стойност на `n`.\n\n### Пример:\n- `absoluteValue(-3)` връща `3`.\n- `absoluteValue(5)` връща `5`.\n- `absoluteValue(0)` връща `0`.\n- `absoluteValue(-10000)` връща `10000`.\n\nЗабележка: Тази функция гарантира, че абсолютната стойност е правилно изчислена за всяко цяло число в рамките на посочения лимит.",
      "zh": "计算并返回给定整数的绝对值。\n\n- 参数：\n- n: 要计算其绝对值的整数。`n` 的值不得超过绝对值 10000。\n\n- 返回：`n` 的绝对值。\n\n### 示例：\n- `absoluteValue(-3)` 返回 `3`。\n- `absoluteValue(5)` 返回 `5`。\n- `absoluteValue(0)` 返回 `0`。\n- `absoluteValue(-10000)` 返回 `10000`。\n\n注意：此函数确保在指定限制内正确计算任何整数的绝对值。",
      "fr": "Calcule et renvoie la valeur absolue d'un entier donné.\n\n- Paramètres:\n- n: Un entier dont la valeur absolue doit être calculée. La valeur de `n` ne doit pas dépasser la valeur absolue de 10000.\n\n- Renvoie: La valeur absolue de `n`.\n\n### Exemple:\n- `absoluteValue(-3)` renvoie `3`.\n- `absoluteValue(5)` renvoie `5`.\n- `absoluteValue(0)` renvoie `0`.\n- `absoluteValue(-10000)` renvoie `10000`.\n\nRemarque: Cette fonction garantit que la valeur absolue est correctement calculée pour tout entier dans la limite spécifiée.",
      "de": "Berechnet und gibt den Absolutwert einer gegebenen ganzen Zahl zurück.\n\n- Parameter:\n- n: Eine ganze Zahl, deren Absolutwert berechnet werden soll. Der Wert von `n` darf den Absolutwert von 10000 nicht überschreiten.\n\n- Rückgabe: Der Absolutwert von `n`.\n\n### Beispiel:\n- `absoluteValue(-3)` gibt `3` zurück.\n- `absoluteValue(5)` gibt `5` zurück.\n- `absoluteValue(0)` gibt `0` zurück.\n- `absoluteValue(-10000)` gibt `10000` zurück.\n\nHinweis: Diese Funktion stellt sicher, dass der Absolutwert für jede ganze Zahl innerhalb des angegebenen Limits korrekt berechnet wird.",
      "ha": "Yana lissafi da dawowa da darajar cikakken adadi na wani cikakken lamba da aka bayar.\n\n- Sigogi:\n- n: Wani cikakken lamba wanda za a lissafa darajar cikakken adadinsa. Darajar `n` ba za ta wuce darajar cikakken adadi na 10000 ba.\n\n- Dawowa: Darajar cikakken adadi na `n`.\n\n### Misali:\n- `absoluteValue(-3)` yana dawowa `3`.\n- `absoluteValue(5)` yana dawowa `5`.\n- `absoluteValue(0)` yana dawowa `0`.\n- `absoluteValue(-10000)` yana dawowa `10000`.\n\nLura: Wannan aikin yana tabbatar da cewa an lissafa darajar cikakken adadi daidai ga duk wani cikakken lamba a cikin iyakar da aka kayyade.",
      "hi": "गणना करता है और दिए गए पूर्णांक का परिमाण मान लौटाता है।\n\n- पैरामीटर्स:\n- n: एक पूर्णांक जिसका परिमाण मान गणना किया जाना है। `n` का मान 10000 के परिमाण मान से अधिक नहीं होना चाहिए।\n\n- रिटर्न्स: `n` का परिमाण मान।\n\n### उदाहरण:\n- `absoluteValue(-3)` `3` लौटाता है।\n- `absoluteValue(5)` `5` लौटाता है।\n- `absoluteValue(0)` `0` लौटाता है।\n- `absoluteValue(-10000)` `10000` लौटाता है।\n\nनोट: यह फ़ंक्शन सुनिश्चित करता है कि निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक के लिए परिमाण मान सही ढंग से गणना किया गया है।",
      "hu": "Kiszámítja és visszaadja egy adott egész szám abszolút értékét.\n\n- Paraméterek:\n- n: Egy egész szám, amelynek abszolút értékét ki kell számítani. Az `n` értéke nem haladhatja meg a 10000 abszolút értékét.\n\n- Visszatérési érték: `n` abszolút értéke.\n\n### Példa:\n- `absoluteValue(-3)` visszaadja `3`.\n- `absoluteValue(5)` visszaadja `5`.\n- `absoluteValue(0)` visszaadja `0`.\n- `absoluteValue(-10000)` visszaadja `10000`.\n\nMegjegyzés: Ez a függvény biztosítja, hogy az abszolút érték helyesen legyen kiszámítva bármely egész számra a megadott határon belül."
    },
    "docstring_bertscore": {
      "sq": "0.9876807451378352",
      "hy": "0.9926915937602023",
      "bn": "0.9886349654883269",
      "bg": "0.9952733914528938",
      "zh": "0.9797694956915967",
      "fr": "0.9949394937823741",
      "de": "0.9988086149745528",
      "ha": "0.9894700076101974",
      "hi": "0.9944943630984749",
      "hu": "0.988152293662412"
    }
  }
]