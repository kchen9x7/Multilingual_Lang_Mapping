[
  {
    "task_id": "Go/1",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\nParametrat:\n- a (float64): Gjatësia e anës 'a'.\n- b (float64): Gjatësia e anës 'b'.\n- c (float64): Gjatësia e anës 'c'.\n\nKthen:\n- float64: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthen -1.\n\nShembuj:\n\tcalculateTriangleArea(3, 5, 4)  // Kthen 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\nՊարամետրեր:\n- a (float64): 'a' կողմի երկարությունը:\n- b (float64): 'b' կողմի երկարությունը:\n- c (float64): 'c' կողմի երկարությունը:\n\nՎերադարձնում է:\n- float64: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնել -1:\n\nՕրինակներ:\n\tcalculateTriangleArea(3, 5, 4)  // Վերադարձնում է 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি ত্রিভুজের তিন বাহুর দৈর্ঘ্য প্রদান করলে তার ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- a (float64): বাহু 'a' এর দৈর্ঘ্য।\n- b (float64): বাহু 'b' এর দৈর্ঘ্য।\n- c (float64): বাহু 'c' এর দৈর্ঘ্য।\n\nফেরত দেয়:\n- float64: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে গণনা করা ক্ষেত্রফল ২ দশমিক স্থান পর্যন্ত ফেরত দিন।\nঅন্যথায়, -1 ফেরত দিন।\n\nউদাহরণ:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 ফেরত দেয়\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете площта на триъгълник, дадени неговите три страни.\nПараметри:\n- a (float64): Дължина на страна 'a'.\n- b (float64): Дължина на страна 'b'.\n- c (float64): Дължина на страна 'c'.\n\nВръща:\n- float64: Ако предоставените страни образуват триъгълник, върнете изчислената площ с 2 десетични знака.\nВ противен случай върнете -1.\n\nПримери:\n\tcalculateTriangleArea(3, 5, 4)  // Връща 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定三边的三角形面积。\n参数：\n- a (float64): 边 'a' 的长度。\n- b (float64): 边 'b' 的长度。\n- c (float64): 边 'c' 的长度。\n\n返回：\n- float64: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 -1。\n\n示例：\n\tcalculateTriangleArea(3, 5, 4)  // 返回 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculez l'aire d'un triangle donné ses trois côtés.\nParamètres :\n- a (float64) : Longueur du côté 'a'.\n- b (float64) : Longueur du côté 'b'.\n- c (float64) : Longueur du côté 'c'.\n\nRenvoie :\n- float64 : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie -1.\n\nExemples :\n\tcalculateTriangleArea(3, 5, 4)  // Renvoie 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\nParameter:\n- a (float64): Länge der Seite 'a'.\n- b (float64): Länge der Seite 'b'.\n- c (float64): Länge der Seite 'c'.\n\nRückgabewerte:\n- float64: Wenn die angegebenen Seiten ein Dreieck bilden, gib die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls gib -1 zurück.\n\nBeispiele:\n\tcalculateTriangleArea(3, 5, 4)  // Gibt 6.00 zurück\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige yanki na alwatika idan aka ba da gefensa guda uku.\nSigogi:\n- a (float64): Tsawon gefen 'a'.\n- b (float64): Tsawon gefen 'b'.\n- c (float64): Tsawon gefen 'c'.\n\nDawowa:\n- float64: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare biyu na goma.\nIn ba haka ba, dawo da -1.\n\nMisalai:\n\tcalculateTriangleArea(3, 5, 4)  // Yana dawowa 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nकिसी त्रिभुज के तीन भुजाओं के दिए गए माप के आधार पर उसका क्षेत्रफल गणना करें।\nपैरामीटर्स:\n- a (float64): भुजा 'a' की लंबाई।\n- b (float64): भुजा 'b' की लंबाई।\n- c (float64): भुजा 'c' की लंबाई।\n\nवापसी मान:\n- float64: यदि दिए गए भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\nअन्यथा, -1 लौटाएं।\n\nउदाहरण:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 लौटाता है\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki egy háromszög területét a három oldalának ismeretében.\nParaméterek:\n- a (float64): Az 'a' oldal hossza.\n- b (float64): A 'b' oldal hossza.\n- c (float64): A 'c' oldal hossza.\n\nVisszatér:\n- float64: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegyre kerekítve.\nEgyébként térjen vissza -1 értékkel.\n\nPéldák:\n\tcalculateTriangleArea(3, 5, 4)  // Visszatér 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9955560424851064",
      "hy": "0.9972867089950634",
      "bn": "0.9780926580149001",
      "bg": "1",
      "zh": "0.9848129196964535",
      "fr": "0.9844051315241888",
      "de": "0.9867481754988764",
      "ha": "0.9957439468255654",
      "hi": "0.9710214164500581",
      "hu": "0.9788319602931119"
    },
    "canonical_solution": "if a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}",
    "instruction": {
      "en": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar Go cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func calculateTriangleArea(a, b, c float64) float64\nif a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9243263933244714",
      "bn": "0.8784854808373347",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.91027269797511",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCalculateTriangleArea(t *testing.T) {\n\t// Using a small delta for floating point comparison\n\tconst delta = 1e-6\n\n\tassert := assert.New(t)\n\n\t// Triangle with sides 3, 5, 4 should return area 6.00\n\tassert.InDelta(6.00, calculateTriangleArea(3, 5, 4), delta)\n\n\t// Not a triangle with sides 1, 1, 4 should return -1\n\tassert.Equal(-1.0, calculateTriangleArea(1, 1, 4))\n\n\t// Triangle with sides 7, 24, 25 should return area 84.00\n\tassert.InDelta(84.00, calculateTriangleArea(7, 24, 25), delta)\n\n\t// Triangle with sides 10.5, 6.2, 7.3 should return close to calculated area\n\tassert.InDelta(22.15, calculateTriangleArea(10.5, 6.2, 7.3), 1e-2) // Looser delta for specific precision\n}",
    "entry_point": "calculateTriangleArea",
    "signature": "func calculateTriangleArea(a, b, c float64) float64",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\nParametrat:\n- a (float64): Gjatësia e anës 'a'.\n- b (float64): Gjatësia e anës 'b'.\n- c (float64): Gjatësia e anës 'c'.\n\nKthen:\n- float64: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra pas presjes dhjetore.\nPërndryshe, kthen -1.\n\nShembuj:\n\tcalculateTriangleArea(3, 5, 4)  // Kthen 6.00",
      "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\nՊարամետրեր:\n- a (float64): 'a' կողմի երկարությունը:\n- b (float64): 'b' կողմի երկարությունը:\n- c (float64): 'c' կողմի երկարությունը:\n\nՎերադարձնում է:\n- float64: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով:\nՀակառակ դեպքում, վերադարձնում է -1:\n\nՕրինակներ:\n\tcalculateTriangleArea(3, 5, 4)  // Վերադարձնում է 6.00",
      "bn": "ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- a (float64): বাহু 'a' এর দৈর্ঘ্য।\n- b (float64): বাহু 'b' এর দৈর্ঘ্য।\n- c (float64): বাহু 'c' এর দৈর্ঘ্য।\n\nরিটার্নস:\n- float64: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন। অন্যথায়, -1 রিটার্ন করুন।\n\nউদাহরণসমূহ:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 রিটার্ন করে",
      "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\nПараметри:\n- a (float64): Дължина на страна 'a'.\n- b (float64): Дължина на страна 'b'.\n- c (float64): Дължина на страна 'c'.\n\nВръща:\n- float64: Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\nВ противен случай връща -1.\n\nПримери:\n\tcalculateTriangleArea(3, 5, 4)  // Връща 6.00",
      "zh": "计算给定三边的三角形面积。\n参数：\n- a (float64): 边 'a' 的长度。\n- b (float64): 边 'b' 的长度。\n- c (float64): 边 'c' 的长度。\n\n返回：\n- float64: 如果提供的边构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 -1。\n\n示例：\n\tcalculateTriangleArea(3, 5, 4)  // 返回 6.00",
      "fr": "Calculer l'aire d'un triangle donné par ses trois côtés.\nParamètres :\n- a (float64) : Longueur du côté 'a'.\n- b (float64) : Longueur du côté 'b'.\n- c (float64) : Longueur du côté 'c'.\n\nRenvoie :\n- float64 : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie -1.\n\nExemples :\n\tcalculateTriangleArea(3, 5, 4)  // Renvoie 6.00",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\nParameter:\n- a (float64): Länge der Seite 'a'.\n- b (float64): Länge der Seite 'b'.\n- c (float64): Länge der Seite 'c'.\n\nRückgabewert:\n- float64: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls -1 zurückgeben.\n\nBeispiele:\n\tcalculateTriangleArea(3, 5, 4)  // Gibt 6.00 zurück",
      "ha": "Ƙididdige yanki na alwatika idan aka ba da gefensa uku.\nSigogi:  \n- a (float64): Tsawon gefen 'a'.  \n- b (float64): Tsawon gefen 'b'.  \n- c (float64): Tsawon gefen 'c'.  \n\nDawowa:  \n- float64: Idan gefen da aka bayar sun samar da kusurwa, dawo da yankin da aka lissafa tare da wurare guda 2 na adadi.  \nIn ba haka ba, dawo da -1.  \n\nMisalai:  \n\tcalculateTriangleArea(3, 5, 4)  // Dawo da 6.00  ",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\nParameters:\n- a (float64): भुजा 'a' की लंबाई।\n- b (float64): भुजा 'b' की लंबाई।\n- c (float64): भुजा 'c' की लंबाई।\n\nReturns:\n- float64: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 लौटाता है।",
      "hu": "Számítsa ki egy háromszög területét a három oldalának megadása alapján.\nParaméterek:\n- a (float64): Az 'a' oldal hossza.\n- b (float64): A 'b' oldal hossza.\n- c (float64): A 'c' oldal hossza.\n\nVisszatérési érték:\n- float64: Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal. Ellenkező esetben adja vissza a -1 értéket.\n\nPéldák:\n\tcalculateTriangleArea(3, 5, 4)  // Visszaadja: 6.00"
    },
    "docstring_bertscore": {
      "sq": "0.9921197368932029",
      "hy": "0.9921197368932029",
      "bn": "0.9806253940034759",
      "bg": "0.999999801369619",
      "zh": "0.9653137724510206",
      "fr": "0.9774661777931161",
      "de": "0.975051626881256",
      "ha": "0.9949633294280983",
      "hi": "0.9686618861537447",
      "hu": "0.9513341662337852"
    }
  },
  {
    "task_id": "Go/2",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "sq": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit vlerën e funksionit për një hyrje të dhënë.\nParametrat:\n- x (int): Vlera e hyrjes për funksionin.\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "hy": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\nՊարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը, կլորացված մինչև 5 տասնորդական թվանշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "bn": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\nপ্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\nরিটার্নস:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\nফাংশন সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "bg": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете стойността на функцията за даден вход.\nПараметри:\n- x (int): Входна стойност за функцията.\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "zh": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定输入的函数值。\n参数：\n- x (int): 函数的输入值。\n返回：\n- string: 如果 x 不在定义域中，返回 \"Not define\"。\n否则，返回计算的函数值，保留到小数点后5位。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "fr": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalcule la valeur de la fonction pour une entrée donnée.\nParamètres:\n- x (int): Valeur d'entrée pour la fonction.\nRenvoie:\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "de": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne den Wert der Funktion für eine gegebene Eingabe.\nParameter:\n- x (int): Eingabewert für die Funktion.\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "ha": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige ƙimar aikin don wani shigarwa da aka bayar.\nSigogi:\n- x (int): Ƙimar shigarwa don aikin.\nDawowa:\n- string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na goma.\n\nMa'anar Ayyuka:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "hi": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nकिसी दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\nपैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक गोल कर लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "hu": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a függvény értékét egy adott bemenetre.\nParaméterek:\n- x (int): A függvény bemeneti értéke.\nVisszatér:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n\nFüggvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9870326142045184",
      "hy": "0.9568733716697051",
      "bn": "0.9850026117103418",
      "bg": "0.9871847650763911",
      "zh": "0.9813297373346257",
      "fr": "0.9791610908344868",
      "de": "0.9743891945605047",
      "ha": "0.9851968722229939",
      "hi": "0.9910209136253179",
      "hu": "0.979589337935998"
    },
    "canonical_solution": "if 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}",
    "instruction": {
      "en": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nՏվեք Go կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nGeben Sie eine prägnante Beschreibung des Go-Codes in natürlicher Sprache auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func calculateFunctionValue(x int) string\nif 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9449734255419049",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.8704461147953286",
      "ha": "0.94069234493946",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestCalculateFunctionValue(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Not define\", calculateFunctionValue(40)) // the provided test case\n\n\t// Additional test cases based on provided function definitions\n\tassert.Equal(\"Not define\", calculateFunctionValue(40))\n\tassert.Equal(\"-0.14550\", calculateFunctionValue(5))\n\tassert.Equal(\"0.76266\", calculateFunctionValue(15))\n\tassert.Equal(\"0.31314\", calculateFunctionValue(25))\n\tassert.Equal(\"Not define\", calculateFunctionValue(-1))\n}",
    "entry_point": "calculateFunctionValue",
    "signature": "func calculateFunctionValue(x int) string",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\nParametrat:\n- x (int): Vlera e hyrjes për funksionin.\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërcaktimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hy": "Հաշվել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։ \nՊարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ \nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "bn": "ফাংশনের মান নির্ধারিত ইনপুটের জন্য গণনা করুন।\nপ্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\nফেরত দেয়:\n- string: যদি x নির্ধারিত ডোমেইনে না থাকে, তাহলে \"Not define\" ফেরত দেয়।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে ফেরত দেয়।\n\nফাংশনের সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "bg": "Изчислява стойността на функцията за даден вход.\nПараметри:\n- x (int): Входна стойност за функцията.\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "zh": "计算给定输入的函数值。\n参数：\n- x (int): 函数的输入值。\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留 5 位小数。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée.\nParamètres:\n- x (int): Valeur d'entrée pour la fonction.\nRenvoie:\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\nParameter:\n- x (int): Eingabewert für die Funktion.\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Nicht definiert\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Nicht definiert\"",
      "ha": "Ƙididdige ƙimar aikin don wani shigarwar da aka bayar.\nSigogi:\n- x (int): Darajar shigarwa don aikin.\nDawowa:\n- string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa da darajar aikin da aka lissafa an zagaye zuwa wurare 5 na ƙidaya.\n\nMa'anar Ayyuka:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\nपैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\nReturns:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना की गई फ़ंक्शन मान को 5 दशमलव स्थानों तक गोल करके लौटाता है।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\nParaméterek:\n- x (int): A függvény bemeneti értéke.\nVisszatér:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve.\n\nFüggvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\""
    },
    "docstring_bertscore": {
      "sq": "0.9854519136322427",
      "hy": "0.9353217766970386",
      "bn": "0.9899483095677295",
      "bg": "0.9847725977291034",
      "zh": "0.9750714899193594",
      "fr": "0.9757990730050903",
      "de": "0.9676472821674185",
      "ha": "0.9760578883915787",
      "hi": "0.9899483095677295",
      "hu": "0.9746239756708879"
    }
  },
  {
    "task_id": "Go/3",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nFunksioni kthen dy vlera: numrin maksimal dhe minimal.\n\nShembull përdorimi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\n\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nՖունկցիան վերադարձնում է երկու արժեք՝ առավելագույն և նվազագույն ամբողջ թիվը։\n\nՕրինակ օգտագործում:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nফাংশনটি দুটি মান ফেরত দেয়: সর্বাধিক এবং সর্বনিম্ন পূর্ণসংখ্যা।\n\nউদাহরণ ব্যবহার:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nНамерете максимума и минимума на три различни цели числа.\n\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nФункцията връща две стойности: максималното и минималното цяло число.\n\nПример за използване:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n找到三个不同整数的最大值和最小值。\n\n参数:\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回值:\n该函数返回两个值：最大整数和最小整数。\n\n示例用法:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\n\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nLa fonction renvoie deux valeurs : l'entier max et min.\n\nExemple d'utilisation :\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nDie Funktion gibt zwei Werte zurück: die maximale und minimale ganze Zahl.\n\nBeispielverwendung:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\n\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nAiki yana dawowa da ƙimar biyu: mafi girma da mafi ƙanƙanta lamba.\n\nMisalin amfani:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम खोजें।\n\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nयह फ़ंक्शन दो मान लौटाता है: अधिकतम और न्यूनतम पूर्णांक।\n\nउदाहरण उपयोग:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\n\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérés:\nA függvény két értéket ad vissza: a max és min egész számot.\n\nPélda használat:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {"
    },
    "prompt_bertscore": {
      "sq": "0.9902824058686301",
      "hy": "0.9933715055544847",
      "bn": "0.9790689263376866",
      "bg": "0.9933715055544847",
      "zh": "0.9805773254512655",
      "fr": "0.9977872575552713",
      "de": "0.989484507628013",
      "ha": "0.9590515524281337",
      "hi": "0.9811215726953011",
      "hu": "0.9974702434671396"
    },
    "canonical_solution": "var max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}",
    "instruction": {
      "en": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nПредоставете кратко описание на Go кода на естествен език на български, като използвате не повече от 500 символа.",
      "zh": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\n请用中文为以下 Go 代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func FindMaxMin(a, b, c int) (int, int)\nvar max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8946285691648022",
      "bn": "0.8773334246273324",
      "bg": "0.8396865647158265",
      "zh": "0.8680091186504116",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9219535547926286",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestFindMaxMin(t *testing.T) {\n\tassert := assert.New(t)\n\tvar max, min int\n\n\tmax, min = FindMaxMin(1, 2, 3)\n\tassert.Equal(3, max)\n\tassert.Equal(1, min)\n\n\t// Additional tests\n\tmax, min = FindMaxMin(5, 3, 4)\n\tassert.Equal(5, max)\n\tassert.Equal(3, min)\n\n\tmax, min = FindMaxMin(10, -2, 7)\n\tassert.Equal(10, max)\n\tassert.Equal(-2, min)\n\n\tmax, min = FindMaxMin(-1, -3, -2)\n\tassert.Equal(-1, max)\n\tassert.Equal(-3, min)\n}",
    "entry_point": "FindMaxMin",
    "signature": "func FindMaxMin(a, b, c int) (int, int)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nFunksioni kthen dy vlera: numrin maksimal dhe minimal.\n\nShembull përdorimi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\n\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nՖունկցիան վերադարձնում է երկու արժեք՝ առավելագույն և նվազագույն ամբողջ թիվը:\n\nՕրինակ օգտագործում:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত দেয়:\nফাংশনটি দুটি মান ফেরত দেয়: সর্বাধিক এবং সর্বনিম্ন পূর্ণসংখ্যা।\n\nব্যবহারের উদাহরণ:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "bg": "Намерете максимума и минимума на три различни цели числа.\n\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nФункцията връща две стойности: максималното и минималното цяло число.\n\nПример за използване:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "zh": "找出三个不同整数的最大值和最小值。\n\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\n该函数返回两个值：最大整数和最小整数。\n\n示例用法：\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.\n\nParamètres:\na (int): Le premier entier.\nb (int): Le deuxième entier.\nc (int): Le troisième entier.\n\nRenvoie:\nLa fonction renvoie deux valeurs : l'entier max et min.\n\nExemple d'utilisation:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nDie Funktion gibt zwei Werte zurück: die maximale und minimale ganze Zahl.\n\nBeispielverwendung:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\n\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nAiki yana dawowa da ƙimar biyu: mafi girma da mafi ƙanƙanta lamba.\n\nMisalin amfani:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम खोजें।\n\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nयह फ़ंक्शन दो मान लौटाता है: अधिकतम और न्यूनतम पूर्णांक।\n\nउदाहरण उपयोग:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\n\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési értékek:\nA függvény két értéket ad vissza: a max és min egész számot.\n\nPélda használat:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)"
    },
    "docstring_bertscore": {
      "sq": "0.9901467413183833",
      "hy": "0.9901467413183833",
      "bn": "0.9711447659166808",
      "bg": "0.9901467413183833",
      "zh": "0.9671165417892932",
      "fr": "0.9937073895288148",
      "de": "0.980255544233989",
      "ha": "0.9405574749107373",
      "hi": "0.9722044589995019",
      "hu": "0.9741985093947111"
    }
  },
  {
    "task_id": "Go/4",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (float64): koordinata x e pikës A.\n- ya (float64): koordinata y e pikës A.\n- xb (float64): koordinata x e pikës B.\n- yb (float64): koordinata y e pikës B.\n\nKthen:\nfloat64: Distanca midis pikave A dhe B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել հեռավորությունը A (xa, ya) և B (xb, yb) կետերի միջև։\n\nՊարամետրեր:\n- xa (float64): A կետի x-կոորդինատը։\n- ya (float64): A կետի y-կոորդինատը։\n- xb (float64): B կետի x-կոորդինատը։\n- yb (float64): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nfloat64: A և B կետերի միջև հեռավորությունը։\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (float64): বিন্দু A এর x-সমন্বয়।\n- ya (float64): বিন্দু A এর y-সমন্বয়।\n- xb (float64): বিন্দু B এর x-সমন্বয়।\n- yb (float64): বিন্দু B এর y-সমন্বয়।\n\nফেরত দেয়:\nfloat64: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (float64): x-координата на точка A.\n- ya (float64): y-координата на точка A.\n- xb (float64): x-координата на точка B.\n- yb (float64): y-координата на точка B.\n\nВръща:\nfloat64: Разстоянието между точките A и B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数:\n- xa (float64): 点 A 的 x 坐标。\n- ya (float64): 点 A 的 y 坐标。\n- xb (float64): 点 B 的 x 坐标。\n- yb (float64): 点 B 的 y 坐标。\n\n返回:\nfloat64: 点 A 和 B 之间的距离。\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres:\n- xa (float64): coordonnée x du point A.\n- ya (float64): coordonnée y du point A.\n- xb (float64): coordonnée x du point B.\n- yb (float64): coordonnée y du point B.\n\nRenvoie:\nfloat64: La distance entre les points A et B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (float64): x-Koordinate von Punkt A.\n- ya (float64): y-Koordinate von Punkt A.\n- xb (float64): x-Koordinate von Punkt B.\n- yb (float64): y-Koordinate von Punkt B.\n\nRückgabewert:\nfloat64: Die Entfernung zwischen den Punkten A und B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (float64): x-daftarin maki A.\n- ya (float64): y-daftarin maki A.\n- xb (float64): x-daftarin maki B.\n- yb (float64): y-daftarin maki B.\n\nDawo:\nfloat64: Nisan tsakanin maki A da B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (float64): बिंदु A का x-निर्देशांक।\n- ya (float64): बिंदु A का y-निर्देशांक।\n- xb (float64): बिंदु B का x-निर्देशांक।\n- yb (float64): बिंदु B का y-निर्देशांक।\n\nवापसी:\nfloat64: बिंदुओं A और B के बीच की दूरी।\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (float64): A pont x-koordinátája.\n- ya (float64): A pont y-koordinátája.\n- xb (float64): B pont x-koordinátája.\n- yb (float64): B pont y-koordinátája.\n\nVisszatérési érték:\nfloat64: A távolság A és B pontok között.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9957779126207225",
      "bn": "0.9973365652207031",
      "bg": "1",
      "zh": "0.9973365652207031",
      "fr": "0.9777188356377925",
      "de": "0.9957461317597568",
      "ha": "1",
      "hi": "0.9973365652207031",
      "hu": "0.9709093889151544"
    },
    "canonical_solution": "return math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}",
    "instruction": {
      "en": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nՏվեք Go կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func calculateDistance(xa, ya, xb, yb float64) float64\nreturn math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9229258505077944",
      "bn": "0.8679813103970667",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestCalculateDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.InDelta(5, calculateDistance(0, 0, 3, 4), 1e-6)\n\tassert.InDelta(0, calculateDistance(0, 0, 0, 0), 1e-6)\n\tassert.InDelta(4.242640687, calculateDistance(-1, -1, 2, 2), 1e-6)\n\tassert.InDelta(5.68243, calculateDistance(1.5, 3.9, 4.2, -1.1), 1e-6)\n}",
    "entry_point": "calculateDistance",
    "signature": "func calculateDistance(xa, ya, xb, yb float64) float64",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (float64): koordinata x e pikës A.\n- ya (float64): koordinata y e pikës A.\n- xb (float64): koordinata x e pikës B.\n- yb (float64): koordinata y e pikës B.\n\nKthen:\nfloat64: Distanca midis pikave A dhe B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hy": "Հաշվարկել երկու կետերի A (xa, ya) և B (xb, yb) միջև հեռավորությունը:\n\nՊարամետրեր:\n- xa (float64): A կետի x-համակարգային կոորդինատը:\n- ya (float64): A կետի y-համակարգային կոորդինատը:\n- xb (float64): B կետի x-համակարգային կոորդինատը:\n- yb (float64): B կետի y-համակարգային կոորդինատը:\n\nՎերադարձնում է:\nfloat64: A և B կետերի միջև հեռավորությունը:\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (float64): বিন্দু A এর x-সমন্বয়।\n- ya (float64): বিন্দু A এর y-সমন্বয়।\n- xb (float64): বিন্দু B এর x-সমন্বয়।\n- yb (float64): বিন্দু B এর y-সমন্বয়।\n\nফেরত দেয়:\nfloat64: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "bg": "Изчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (float64): x-координата на точка A.\n- ya (float64): y-координата на точка A.\n- xb (float64): x-координата на точка B.\n- yb (float64): y-координата на точка B.\n\nВръща:\nfloat64: Разстоянието между точките A и B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "zh": "计算两点A (xa, ya)和B (xb, yb)之间的距离。\n\n参数：\n- xa (float64): 点A的x坐标。\n- ya (float64): 点A的y坐标。\n- xb (float64): 点B的x坐标。\n- yb (float64): 点B的y坐标。\n\n返回：\nfloat64: 点A和B之间的距离。\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres:\n- xa (float64): coordonnée x du point A.\n- ya (float64): coordonnée y du point A.\n- xb (float64): coordonnée x du point B.\n- yb (float64): coordonnée y du point B.\n\nRenvoie:\nfloat64: La distance entre les points A et B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "de": "Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (float64): x-Koordinate des Punktes A.\n- ya (float64): y-Koordinate des Punktes A.\n- xb (float64): x-Koordinate des Punktes B.\n- yb (float64): y-Koordinate des Punktes B.\n\nRückgabewert:\nfloat64: Die Entfernung zwischen den Punkten A und B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "ha": "Ƙididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (float64): x-kordine na aya A.\n- ya (float64): y-kordine na aya A.\n- xb (float64): x-kordine na aya B.\n- yb (float64): y-kordine na aya B.\n\nAbin da ya dawo:\nfloat64: Nisan tsakanin maki A da B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (float64): बिंदु A का x-निर्देशांक।\n- ya (float64): बिंदु A का y-निर्देशांक।\n- xb (float64): बिंदु B का x-निर्देशांक।\n- yb (float64): बिंदु B का y-निर्देशांक।\n\nरिटर्न्स:\nfloat64: बिंदुओं A और B के बीच की दूरी।\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (float64): A pont x-koordinátája.\n- ya (float64): A pont y-koordinátája.\n- xb (float64): B pont x-koordinátája.\n- yb (float64): B pont y-koordinátája.\n\nVisszatérési érték:\nfloat64: Az A és B pontok közötti távolság.\n   >>> calculateDistance(0, 0, 3, 4)\n   5"
    },
    "docstring_bertscore": {
      "sq": "0.9688774001171675",
      "hy": "0.9739128789067829",
      "bn": "0.99712482523452",
      "bg": "1",
      "zh": "0.9741883792452783",
      "fr": "1",
      "de": "0.9947061030846581",
      "ha": "1",
      "hi": "0.99712482523452",
      "hu": "0.9704352581956242"
    }
  },
  {
    "task_id": "Go/5",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n*/\nfunc processRequest(n int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\nint: Rezultati pas marrjes së modulo 10007 të daljes.\n\nShembuj:\n    ExtraNumber(1)    // kthen 1\n*/\nfunc processRequest(n int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳտնել N-ի ֆակտորիալը և արդյունքի վրա կիրառել 10007 մոդուլը։\n\nՊարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):\n\nՎերադարձնում է:\nint: Արդյունքը 10007 մոդուլը կիրառելուց հետո։\n\nՕրինակներ:\n    ExtraNumber(1)    // վերադարձնում է 1\n*/\nfunc processRequest(n int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nN এর ফ্যাক্টোরিয়াল খুঁজুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: আউটপুটের 10007 এর মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\n    ExtraNumber(1)    // returns 1\n*/\nfunc processRequest(n int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nНамерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след вземане на модуло 10007 от изхода.\n\nПримери:\n    ExtraNumber(1)    // връща 1\n*/\nfunc processRequest(n int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n找到N的阶乘并对结果取模10007。\n\n参数:\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回:\nint: 对输出取模10007后的结果。\n\n示例:\n    ExtraNumber(1)    // 返回 1\n*/\nfunc processRequest(n int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie :\nint : Le résultat après avoir pris le modulo 10007 de la sortie.\n\nExemples :\n    ExtraNumber(1)    // renvoie 1\n*/\nfunc processRequest(n int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFinde die Fakultät von N und nehme das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach der Modulo-Operation 10007 des Outputs.\n\nBeispiele:\n    ExtraNumber(1)    // gibt 1 zurück\n*/\nfunc processRequest(n int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNemo factorial na N kuma a ɗauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n\nMisalai:\n    ExtraNumber(1)    // yana dawowa 1\n*/\nfunc processRequest(n int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nN का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n\nपैरामीटर्स:\n- N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी मान:\nint: आउटपुट का 10007 से माड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n    ExtraNumber(1)    // returns 1\n*/\nfunc processRequest(n int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTaláld meg N faktoriálisát és vedd a 10007-es maradékát az eredménynek.\n\nParaméterek:\n- N (int): Egy egész szám, amely a bemeneti értéket jelenti (N <= 10000).\n\nVisszatér:\nint: Az eredmény, miután a 10007-es maradékát vettük az eredménynek.\n\nPéldák:\n    ExtraNumber(1)    // visszaadja 1\n*/\nfunc processRequest(n int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9895367474182252",
      "hy": "0.9649437240511526",
      "bn": "0.9758648196612129",
      "bg": "0.9895367474182252",
      "zh": "0.979321981443125",
      "fr": "1",
      "de": "0.9784857475389681",
      "ha": "0.9895367474182252",
      "hi": "0.9711628412813549",
      "hu": "0.9551856093220517"
    },
    "canonical_solution": "if n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}",
    "instruction": {
      "en": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简明的自然语言描述（文档字符串）。",
      "fr": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nBa da bayanin takaitaccen harshe na halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func processRequest(n int) int\nif n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386492328401351",
      "hy": "0.9036519501144551",
      "bn": "0.8784854808373347",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9528896407476694",
      "hi": "0.904317560521303",
      "hu": "0.9429034983411404"
    },
    "level": "",
    "test": "func TestProcessRequest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, processRequest(0), \"Factorial of 0 should be 1\")\n\tassert.Equal(1, processRequest(1), \"Factorial of 1 should be 1\")\n\tassert.Equal(2, processRequest(2), \"Factorial of 2 should be 2\")\n\tassert.Equal(6, processRequest(3), \"Factorial of 3 should be 6\")\n\tassert.Equal(24, processRequest(4), \"Factorial of 4 should be 24\")\n\tassert.Equal(6266, processRequest(10), \"Factorial of 10 modulus 10007 should be 6266\")\n\tassert.Equal(6991, processRequest(10000), \"Boundary condition for Factorial of 10000 modulus 10007 should be 6991\")\n}",
    "entry_point": "processRequest",
    "signature": "func processRequest(n int) int",
    "docstring": {
      "en": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n",
      "sq": "Gjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n\nKthen:\nint: Rezultati pas marrjes së modulo 10007 të daljes.\n\nShembuj:\n    ExtraNumber(1)    // kthen 1",
      "hy": "Գտնել N-ի ֆակտորիալը և արդյունքը վերցնել մոդուլո 10007։\n\nՊարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\nint: Արդյունքը մոդուլո 10007 վերցնելուց հետո։\n\nՕրինակներ:\n    ExtraNumber(1)    // վերադարձնում է 1",
      "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: আউটপুটের 10007 মডুলোর পরে ফলাফল।\n\nউদাহরণসমূহ:\n    ExtraNumber(1)    // returns 1",
      "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след вземане на модуло 10007 от изхода.\n\nПримери:\n    ExtraNumber(1)    // връща 1",
      "zh": "找到N的阶乘并对结果取模10007。\n\n参数:\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回:\nint: 对输出取模10007后的结果。\n\n示例:\n    ExtraNumber(1)    // 返回 1",
      "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir pris le modulo 10007 de la sortie.\n\nExemples:\n    ExtraNumber(1)    // renvoie 1",
      "de": "Finde die Fakultät von N und nehme das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach dem Nehmen des Modulo 10007 des Outputs.\n\nBeispiele:\n    ExtraNumber(1)    // gibt 1 zurück",
      "ha": "Nemo factorial na N kuma a dauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (int): Lamba mai nuna ƙimar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n\nMisalai:\n    ExtraNumber(1)    // yana dawowa 1",
      "hi": "N का फैक्टोरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n\nपैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n\nवापसी:\nint: आउटपुट का 10007 से मापांक लेने के बाद का परिणाम।\n\nउदाहरण:\n    ExtraNumber(1)    // returns 1",
      "hu": "Keresse meg N faktoriálisát, és vegye az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (int): Egy egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n\nVisszatér:\nint: Az eredmény, miután az 10007-es modulót alkalmaztuk az eredményre.\n\nPéldák:\n    ExtraNumber(1)    // visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9847378374124223",
      "hy": "0.9559485486156066",
      "bn": "0.9958184332184535",
      "bg": "0.9847378374124223",
      "zh": "0.9682993857083559",
      "fr": "1",
      "de": "0.9810079561173491",
      "ha": "0.9830709312547775",
      "hi": "0.9606773420969043",
      "hu": "0.9588890727764471"
    }
  },
  {
    "task_id": "Go/6",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calculates the area of a triangle given its base and height.\n​\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​\nReturns:\n​float64: The calculated area of the triangle, rounded to a float64 precision.\n​\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 llogarit sipërfaqen e një trekëndëshi duke dhënë bazën dhe lartësinë e tij.\n​\nParametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​\nKthen:\n​float64: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një precizion float64.\n​\nShembuj:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 հաշվարկում է եռանկյունու մակերեսը, տրված նրա հիմքը և բարձրությունը։\n​\nՊարամետրեր:\n- base (int): Եռանկյունու հիմքի երկարությունը։\n- height (int): Եռանկյունու բարձրությունը։\n​\nՎերադարձնում է:\n​float64: Եռանկյունու հաշվարկված մակերեսը, կլորացված float64 ճշգրտությամբ։\n​\nՕրինակներ:\n\tcalculateTriangleArea2(1, 2) // վերադարձնում է 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 একটি ত্রিভুজের ক্ষেত্রফল গণনা করে যখন এর ভিত্তি এবং উচ্চতা দেওয়া হয়।\n\nপ্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n\nফেরত দেয়:\n​float64: ত্রিভুজের গণনা করা ক্ষেত্রফল, float64 প্রিসিশনে রাউন্ড করা।\n\nউদাহরণ:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 изчислява площта на триъгълник, дадени неговата основа и височина.\n​\nПараметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​\nВръща:\n​float64: Изчислената площ на триъгълника, закръглена до точност float64.\n​\nПримери:\n\tcalculateTriangleArea2(1, 2) // връща 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 计算给定底和高的三角形面积。\n\n参数：\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n\n返回：\n​float64: 计算出的三角形面积，四舍五入到 float64 精度。\n\n示例：\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calcule l'aire d'un triangle donné sa base et sa hauteur.\n​\nParamètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n​\nRenvoie :\n​float64 : L'aire calculée du triangle, arrondie à une précision float64.\n​\nExemples :\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 berechnet die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n\nParameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n\nRückgabewert:\n​float64: Die berechnete Fläche des Dreiecks, gerundet auf eine float64-Präzision.\n\nBeispiele:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 yana ƙididdige yanki na alwatika idan aka ba shi tushe da tsawo.\n\nSigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon alwatika.\n\nAbin da ya dawo:\n​float64: Yankin da aka ƙididdige na alwatika, an zagaye shi zuwa daidaiton float64.\n\nMisalai:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 त्रिभुज का क्षेत्रफल गणना करता है जब इसका आधार और ऊँचाई दी जाती है।\n\nपैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n\nवापसी:\nfloat64: त्रिभुज का गणना किया गया क्षेत्रफल, float64 सटीकता के लिए राउंड किया गया।\n\nउदाहरण:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 kiszámítja egy háromszög területét az alapja és magassága alapján.\n\nParaméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n\nVisszatérési érték:\n​float64: A kiszámított háromszög területe, float64 pontosságra kerekítve.\n\nPéldák:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {"
    },
    "prompt_bertscore": {
      "sq": "0.991420160691198",
      "hy": "0.9906760912838413",
      "bn": "0.9662874585788536",
      "bg": "0.9817132926004041",
      "zh": "0.9776324314220423",
      "fr": "0.9717811776575166",
      "de": "0.9862023392117926",
      "ha": "0.9798012765525622",
      "hi": "0.9631856465486128",
      "hu": "0.9738538856836156"
    },
    "canonical_solution": "// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}",
    "instruction": {
      "en": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বোচ্চ ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func calculateTriangleArea2(base, height int) float64\n// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.9243263933244714",
      "bn": "0.8888925210212767",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.91027269797511",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestCalculateTriangleArea2(t *testing.T) {\n\t// Using testify for assert comparison with delta for approximation\n\tassert := assert.New(t)\n\n\t// Adding more comprehensive test cases and correcting the expected values\n\tassert.InDelta(1.0, calculateTriangleArea2(1, 2), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(6.0, calculateTriangleArea2(3, 4), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(20.0, calculateTriangleArea2(5, 8), 1e-6)   // Additional test case\n\tassert.InDelta(10.5, calculateTriangleArea2(7, 3), 1e-6)   // Additional test case\n\tassert.InDelta(50.0, calculateTriangleArea2(10, 10), 1e-6) // Additional test case\n}",
    "entry_point": "calculateTriangleArea2",
    "signature": "func calculateTriangleArea2(base, height int) float64",
    "docstring": {
      "en": "CalculateTriangleArea2 calculates the area of a triangle given its base and height.\n\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\nReturns:\nfloat64: The calculated area of the triangle, rounded to a float64 precision.\n\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n",
      "sq": "CalculateTriangleArea2 llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n\nParametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n\nKthen:\nfloat64: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një saktësi float64.\n\nShembuj:\n\tcalculateTriangleArea2(1, 2) // kthen 1.0",
      "hy": "CalculateTriangleArea2-ը հաշվարկում է եռանկյան մակերեսը՝ տրված նրա հիմքը և բարձրությունը:\n\nՊարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n\nՎերադարձնում է:\nfloat64: Եռանկյան հաշվարկված մակերեսը, կլորացված float64 ճշգրտությամբ:\n\nՕրինակներ:\n\tcalculateTriangleArea2(1, 2) // վերադարձնում է 1.0",
      "bn": "CalculateTriangleArea2 একটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে তার ক্ষেত্রফল গণনা করে।\n\nপ্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n\nফেরত দেয়:\nfloat64: ত্রিভুজের গণনা করা ক্ষেত্রফল, যা float64 প্রিসিশনে গোল করা হয়েছে।\n\nউদাহরণ:\n\tcalculateTriangleArea2(1, 2) // 1.0 ফেরত দেয়",
      "bg": "CalculateTriangleArea2 изчислява площта на триъгълник, като се дадат неговата основа и височина.\n\nПараметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n\nВръща:\nfloat64: Изчислената площ на триъгълника, закръглена до точност float64.\n\nПримери:\n\tcalculateTriangleArea2(1, 2) // връща 1.0",
      "zh": "CalculateTriangleArea2 计算给定底边和高的三角形面积。\n\n参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高。\n\n返回:\nfloat64: 计算出的三角形面积，四舍五入到 float64 精度。\n\n示例:\n\tcalculateTriangleArea2(1, 2) // 返回 1.0",
      "fr": "CalculateTriangleArea2 calcule l'aire d'un triangle donné sa base et sa hauteur.\n\nParamètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n\nRenvoie:\nfloat64: L'aire calculée du triangle, arrondie à une précision float64.\n\nExemples:\n\tcalculateTriangleArea2(1, 2) // renvoie 1.0",
      "de": "CalculateTriangleArea2 berechnet die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n\nParameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n\nRückgabewert:\nfloat64: Die berechnete Fläche des Dreiecks, gerundet auf eine float64-Präzision.\n\nBeispiele:\n\tcalculateTriangleArea2(1, 2) // gibt 1.0 zurück",
      "ha": "CalculateTriangleArea2 yana lissafin yanki na wani alwatika idan aka ba da tushe da tsawo.\n\nSigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon alwatika.\n\nDawowa:\nfloat64: Yankin da aka lissafa na alwatika, an zagaye shi zuwa madaidaicin float64.\n\nMisalai:\n\tcalculateTriangleArea2(1, 2) // yana dawowa 1.0",
      "hi": "CalculateTriangleArea2 त्रिभुज का क्षेत्रफल गणना करता है जब इसका आधार और ऊँचाई दी जाती है।\n\nपैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n\nवापसी:\nfloat64: त्रिभुज का गणना किया गया क्षेत्रफल, float64 परिशुद्धता में राउंड किया हुआ।\n\nउदाहरण:\n\tcalculateTriangleArea2(1, 2) // 1.0 लौटाता है",
      "hu": "CalculateTriangleArea2 kiszámítja a háromszög területét az alapja és a magassága alapján.\n\nParaméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n\nVisszatérési érték:\nfloat64: A háromszög kiszámított területe, float64 pontosságra kerekítve.\n\nPéldák:\n\tcalculateTriangleArea2(1, 2) // visszaadja 1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9902599606355732",
      "hy": "0.9794554610591805",
      "bn": "0.9827853007668493",
      "bg": "0.985897640207285",
      "zh": "0.9701961072168581",
      "fr": "0.985897640207285",
      "de": "0.9822374781759551",
      "ha": "0.9793591253243785",
      "hi": "0.9810268260035475",
      "hu": "0.9718371914249684"
    }
  },
  {
    "task_id": "Go/7",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit distancën Hamming midis dy numrave të plotë.\n\nDistanca Hamming mat numrin e bitëve që ndryshojnë midis\ndy vlerave të plotë kur përfaqësohen në formë binare.\n\nParametrat:\n- x (int): Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- int: Numri i bitëve që duhet të ndryshohen për të kthyer x në y.\n\nShembuj:\n    hammingDistance(1, 2) // kthen 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվարկել Համինգի հեռավորությունը երկու ամբողջ թվերի միջև։\n\nՀամինգի հեռավորությունը չափում է տարբեր բիթերի քանակը\nերկու ամբողջ թվերի միջև, երբ դրանք ներկայացված են երկբանական ձևով։\n\nՊարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n\nՎերադարձնում է:\n- int: Բիթերի քանակը, որոնք պետք է փոխել x-ը y-ի վերածելու համար։\n\nՕրինակներ:\n    hammingDistance(1, 2) // վերադարձնում է 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি পূর্ণসংখ্যার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nহ্যামিং দূরত্ব মাপ করে কতগুলি ভিন্ন বিট রয়েছে\nদুটি পূর্ণসংখ্যার মানের মধ্যে যখন সেগুলি বাইনারি রূপে উপস্থাপিত হয়।\n\nপ্যারামিটার:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nফেরত দেয়:\n- int: কতগুলি বিট উল্টাতে হবে x কে y তে রূপান্তর করতে।\n\nউদাহরণ:\n    hammingDistance(1, 2) // 2 ফেরত দেয়\n*/\nfunc hammingDistance(x int, y int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете разстоянието на Хаминг между две цели числа.\n\nРазстоянието на Хаминг измерва броя на различаващите се битове между\nдве целочислени стойности, когато са представени в двоична форма.\n\nПараметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- int: Броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y.\n\nПримери:\n    hammingDistance(1, 2) // връща 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算两个整数之间的汉明距离。\n\n汉明距离衡量两个整数在二进制形式下有多少位不同。\n\n参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n\n返回:\n- int: 需要翻转多少位才能将 x 转换为 y。\n\n示例:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la distance de Hamming entre deux entiers.\n\nLa distance de Hamming mesure le nombre de bits différents entre\ndeux valeurs entières lorsqu'elles sont représentées sous forme binaire.\n\nParamètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie :\n- int : Le nombre de bits qui doivent être inversés pour convertir x en y.\n\nExemples :\n    hammingDistance(1, 2) // renvoie 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen.\n\nDie Hamming-Distanz misst die Anzahl der unterschiedlichen Bits zwischen\nzwei ganzzahligen Werten, wenn sie in binärer Form dargestellt werden.\n\nParameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nRückgabewert:\n- int: Die Anzahl der Bits, die umgekehrt werden müssen, um x in y zu konvertieren.\n\nBeispiele:\n    hammingDistance(1, 2) // gibt 2 zurück\n*/\nfunc hammingDistance(x int, y int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu.\n\nNisan Hamming yana auna adadin bits da suka bambanta tsakanin\nlambobi biyu lokacin da aka wakilta su a cikin tsarin binary.\n\nSigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nDawowa:\n- int: Adadin bits da ake buƙatar juyawa don canza x zuwa y.\n\nMisalai:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदो पूर्णांकों के बीच हैमिंग दूरी की गणना करें।\n\nहैमिंग दूरी मापती है कि दो पूर्णांक मानों के बीच कितने भिन्न बिट्स होते हैं\nजब उन्हें बाइनरी रूप में प्रदर्शित किया जाता है।\n\nपैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी मान:\n- int: बिट्स की संख्या जिन्हें x को y में बदलने के लिए उलटना पड़ता है।\n\nउदाहरण:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a Hamming-távolságot két egész szám között.\n\nA Hamming-távolság azt méri, hogy hány különböző bit van\nkét egész szám bináris formában való ábrázolásakor.\n\nParaméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatér:\n- int: Azoknak a biteknek a száma, amelyeket meg kell változtatni ahhoz, hogy x-ből y legyen.\n\nPéldák:\n    hammingDistance(1, 2) // visszaadja: 2\n*/\nfunc hammingDistance(x int, y int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9892310552618125",
      "hy": "0.9859349827189196",
      "bn": "0.9698637985893868",
      "bg": "1",
      "zh": "0.9674250147710404",
      "fr": "0.9931800258671671",
      "de": "0.9882120814071035",
      "ha": "0.9771310883403103",
      "hi": "0.9754816616561965",
      "hu": "0.9731312683574107"
    },
    "canonical_solution": "distance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}",
    "instruction": {
      "en": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nՏրամադրել Go կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nBa da takaitaccen bayanin harshen dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों में हो।",
      "hu": "func hammingDistance(x int, y int) int\ndistance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.9449734255419049",
      "bn": "0.8857873322745583",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.94069234493946",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestHammingDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, hammingDistance(1, 2), \"1 and 2 should have a Hamming distance of 2\")\n\tassert.Equal(2, hammingDistance(4, 7), \"4 and 7 should have a Hamming distance of 2\")\n\tassert.Equal(3, hammingDistance(25, 30), \"25 and 30 should have a Hamming distance of 3\")\n\tassert.Equal(0, hammingDistance(0, 0), \"0 and 0 should have a Hamming distance of 0\")\n\tassert.Equal(28, hammingDistance(0xFFFFFFF, 0), \"0xFFFFFFF and 0 should have a Hamming distance of 28\")\n}",
    "entry_point": "hammingDistance",
    "signature": "func hammingDistance(x int, y int) int",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë.\n\nDistanca Hamming mat numrin e bitëve që ndryshojnë midis\ndy vlerave të plota kur përfaqësohen në formë binare.\n\nParametrat:\n- x (int): Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- int: Numri i bitëve që duhet të ndryshohen për të kthyer x në y.\n\nShembuj:\n    hammingDistance(1, 2) // kthen 2",
      "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև։\n\nՀեմինգի հեռավորությունը չափում է տարբեր բիթերի քանակը\nերկու ամբողջ թվային արժեքների միջև, երբ ներկայացված են երկուական ձևով։\n\nՊարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n\nՎերադարձնում է:\n- int: Բիթերի քանակը, որոնք պետք է փոխել x-ը y-ի վերածելու համար։\n\nՕրինակներ:\n    hammingDistance(1, 2) // վերադարձնում է 2",
      "bn": "দুটি পূর্ণসংখ্যার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nHamming distance দুটি পূর্ণসংখ্যার মধ্যে ভিন্ন বিটের সংখ্যা পরিমাপ করে যখন সেগুলি বাইনারি রূপে উপস্থাপিত হয়।\n\nParameters:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nReturns:\n- int: x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nExamples:\n    hammingDistance(1, 2) // 2 প্রদান করে",
      "bg": "Изчисляване на разстоянието на Хаминг между две цели числа.\n\nРазстоянието на Хаминг измерва броя на различаващите се битове между\nдве цели стойности, когато са представени в двоична форма.\n\nПараметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- int: Броят на битовете, които трябва да бъдат променени, за да се преобразува x в y.\n\nПримери:\n    hammingDistance(1, 2) // връща 2",
      "zh": "计算两个整数之间的汉明距离。\n\n汉明距离用于衡量两个整数在二进制表示时有多少位不同。\n\n参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n\n返回:\n- int: 将 x 转换为 y 需要翻转的位数。\n\n示例:\n    hammingDistance(1, 2) // 返回 2",
      "fr": "Calculer la distance de Hamming entre deux entiers.\n\nLa distance de Hamming mesure le nombre de bits différents entre\ndeux valeurs entières lorsqu'elles sont représentées sous forme binaire.\n\nParamètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie:\n- int: Le nombre de bits qui doivent être inversés pour convertir x en y.\n\nExemples:\n    hammingDistance(1, 2) // renvoie 2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen.\n\nDie Hamming-Distanz misst die Anzahl der unterschiedlichen Bits zwischen\nzwei ganzzahligen Werten, wenn sie in binärer Form dargestellt werden.\n\nParameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nGibt zurück:\n- int: Die Anzahl der Bits, die umgedreht werden müssen, um x in y zu konvertieren.\n\nBeispiele:\n    hammingDistance(1, 2) // gibt 2 zurück",
      "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu.\n\nHamming distance yana auna yawan bambancin bits tsakanin\nlambobi guda biyu lokacin da aka wakilta su a cikin tsarin binary.\n\nSigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nAbin da ake dawowa da shi:\n- int: Yawan bits da ake bukata a jujjuya don canza x zuwa y.\n\nMisalai:\n    hammingDistance(1, 2) // yana dawowa da 2",
      "hi": "दो पूर्णांकों के बीच हैमिंग दूरी की गणना करें।\n\nहैमिंग दूरी मापता है कि जब दो पूर्णांक मानों को बाइनरी रूप में दर्शाया जाता है तो उनके बीच कितने भिन्न बिट्स होते हैं।\n\nपैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी:\n- int: बिट्स की संख्या जिन्हें x को y में बदलने के लिए उलटना आवश्यक है।\n\nउदाहरण:\n    hammingDistance(1, 2) // 2 लौटाता है",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám között.\n\nA Hamming-távolság azt méri, hogy hány különböző bit van két egész szám között, amikor bináris formában vannak ábrázolva.\n\nParaméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- int: Azoknak a biteknek a száma, amelyeket meg kell fordítani, hogy x-et y-ra alakítsuk.\n\nPéldák:\n    hammingDistance(1, 2) // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9907849407326484",
      "hy": "0.981092969920432",
      "bn": "0.9719740477575014",
      "bg": "0.9884057460286125",
      "zh": "0.9696983394819847",
      "fr": "0.9883934309449883",
      "de": "0.995149446095128",
      "ha": "0.9598345533901732",
      "hi": "0.9730893573470123",
      "hu": "0.9737573513184327"
    }
  },
  {
    "task_id": "Go/8",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n- count (int): Numri i numrave për të vlerësuar.\n- nums ([]int): Një segment i numrave të plotë.\n\nKthen:\nint: Numri i numrave tek në listën e dhënë.\n\nShembuj:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր:\n- count (int): Գնահատման ենթակա թվերի քանակը։\n- nums ([]int): Ամբողջ թվերի շերտ։\n\nՎերադարձնում է:\nint: Մուտքային ցանկում գտնվող կենտ թվերի քանակը։\n\nՕրինակներ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // վերադարձնում է 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n\nপ্যারামিটার:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- nums ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 ফেরত দেয়\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n- count (int): Броят на числата за оценка.\n- nums ([]int): Срез от цели числа.\n\nВръща:\nint: Броят на нечетните числа в входния списък.\n\nПримери:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // връща 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定数字列表中奇数的数量。\n\n参数:\n- count (int): 要评估的数字数量。\n- nums ([]int): 整数切片。\n\n返回:\nint: 输入列表中奇数的数量。\n\n示例:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres:\n- count (int): Le nombre de nombres à évaluer.\n- nums ([]int): Une tranche d'entiers.\n\nRenvoie:\nint: Le nombre de nombres impairs dans la liste d'entrée.\n\nExemples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // renvoie 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- nums ([]int): Ein Slice von Ganzzahlen.\n\nRückgabewerte:\nint: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiele:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // gibt 3 zurück\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- count (int): Adadin lambobin da za a tantance.\n- nums ([]int): Wani yanki na lambobi.\n\nDawowa:\nint: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n\nMisalai:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदी गई संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- nums ([]int): पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 लौटाता है\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n- count (int): Az értékelendő számok száma.\n- nums ([]int): Egész számok szelete.\n\nVisszatér:\nint: A páratlan számok száma a bemeneti listában.\n\nPéldák:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9805590514562104",
      "hy": "0.9709419642976441",
      "bn": "0.99135719486041",
      "bg": "0.9932678204955845",
      "zh": "0.9750130925873352",
      "fr": "0.9932678204955845",
      "de": "0.9843447478883542",
      "ha": "0.9842498025662195",
      "hi": "0.9962270159122423",
      "hu": "0.9879606153447134"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countOddNumbers(count int, nums []int) int\nans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9226590899060646",
      "bn": "0.8773334246273324",
      "bg": "0.8396865647158265",
      "zh": "0.8896873717349259",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.935334886302187",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestCountOddNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, countOddNumbers(5, []int{1, 4, 3, 2, 5}))\n\tassert.Equal(0, countOddNumbers(4, []int{2, 2, 0, 0}))\n\tassert.Equal(4, countOddNumbers(6, []int{7, 7, 8, 1, 9, 10})) // Additional Test Sample\n}",
    "entry_point": "countOddNumbers",
    "signature": "func countOddNumbers(count int, nums []int) int",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- nums ([]int): Një segment i numrave të plotë.\n\nKthen:\nint: Numri i numrave tek në listën e dhënë të hyrjes.\n\nShembuj:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // kthen 3",
      "hy": "Կատարել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակի հաշվարկ:\n\nՊարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- nums ([]int): Ամբողջ թվերի կտոր:\n\nՎերադարձնում է:\nint: Մուտքագրված ցանկում գտնվող կենտ թվերի քանակը:\n\nՕրինակներ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // վերադարձնում է 3",
      "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- nums ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণসমূহ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 ফেরত দেয়",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n- count (int): Броят на числата за оценка.\n- nums ([]int): Срез от цели числа.\n\nВръща:\nint: Броят на нечетните числа в входния списък.\n\nПримери:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // връща 3",
      "zh": "计算给定数字列表中奇数的数量。\n\n参数:\n- count (int): 要评估的数字数量。\n- nums ([]int): 整数切片。\n\n返回:\nint: 输入列表中奇数的数量。\n\n示例:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 返回 3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres:\n- count (int): Le nombre de nombres à évaluer.\n- nums ([]int): Une tranche d'entiers.\n\nRenvoie:\nint: Le nombre de nombres impairs dans la liste d'entrée.\n\nExemples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // renvoie 3",
      "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- nums ([]int): Ein Slice von Ganzzahlen.\n\nRückgabewerte:\nint: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiele:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // gibt 3 zurück",
      "ha": "Kirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- count (int): Adadin lambobin da za a tantance.\n- nums ([]int): Wani yanki na lambobi masu cikakken lamba.\n\nDawowa:\nint: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n\nMisalai:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // yana dawowa 3",
      "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- nums ([]int): पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 लौटाता है",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n- count (int): Az értékelendő számok száma.\n- nums ([]int): Egész számok szelete.\n\nVisszatérési érték:\nint: A bemeneti listában található páratlan számok száma.\n\nPéldák:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // visszaadja: 3"
    },
    "docstring_bertscore": {
      "sq": "0.9513669402466559",
      "hy": "0.9644306617769395",
      "bn": "0.9849499746593675",
      "bg": "0.9895297953548889",
      "zh": "0.9630112490740641",
      "fr": "0.9895297953548889",
      "de": "0.9759035525855146",
      "ha": "0.9670567540446017",
      "hi": "0.9704666417958276",
      "hu": "0.9584205037075858"
    }
  },
  {
    "task_id": "Go/9",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\n- size (int): The length of the slice.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers ([]int): Një segment i numrave të plotë.\n- size (int): Gjatësia e segmentit.\nKthen:\nint: Shuma e numrave çift në segmentin hyrës.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվարկել տրված ցուցակի զույգ թվերի գումարը։\nՊարամետրեր:\n- numbers ([]int): Թվերի շերտ։\n- size (int): Շերտի երկարությունը։\nՎերադարձնում է:\nint: Մուտքային շերտի զույգ թվերի գումարը։\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- numbers ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n- size (int): স্লাইসের দৈর্ঘ্য।\nরিটার্নস:\nint: ইনপুট স্লাইসের জোড় সংখ্যাগুলির যোগফল।\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете сумата на четните числа в даден списък.\nПараметри:\n- numbers ([]int): Срез от цели числа.\n- size (int): Дължината на среза.\nВръща:\nint: Сумата на четните числа в входния срез.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定列表中偶数的和。\n参数：\n- numbers ([]int): 整数切片。\n- size (int): 切片的长度。\n返回：\nint: 输入切片中偶数的和。\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la somme des nombres pairs dans une liste donnée.\nParamètres :\n- numbers ([]int) : Une tranche d'entiers.\n- size (int) : La longueur de la tranche.\nRenvoie :\nint : La somme des nombres pairs dans la tranche d'entrée.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers ([]int): Ein Slice von ganzen Zahlen.\n- size (int): Die Länge des Slices.\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabeslice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLissafin jimillar lambobin da suka kasance ma'aurata a cikin jerin da aka bayar.\nSigogi:\n- numbers ([]int): Wani yanki na lambobi.\n- size (int): Tsawon yanki.\nDawo:\nint: Jimillar lambobin ma'aurata a cikin yanki na shigarwa.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए सूची में सम संख्याओं का योग गणना करें।\nपैरामीटर्स:\n- numbers ([]int): पूर्णांकों की एक स्लाइस।\n- size (int): स्लाइस की लंबाई।\nवापसी:\nint: इनपुट स्लाइस में सम संख्याओं का योग।\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a páros számok összegét egy adott listában.\nParaméterek:\n- numbers ([]int): Egy egész számokat tartalmazó szelet.\n- size (int): A szelet hossza.\nVisszatér:\nint: A bemeneti szelet páros számainak összege.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9579370373601469",
      "bn": "1",
      "bg": "0.985026447356066",
      "zh": "0.98108105209757",
      "fr": "0.9971653458322511",
      "de": "0.9860203937827645",
      "ha": "0.9476827439392208",
      "hi": "0.997056893644206",
      "hu": "0.9939153555377582"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nՏվեք տվյալ Go կոդի կարճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nBa da taƙaitaccen bayani a cikin yare na dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func calculateEvenSum(numbers []int) int\nans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8865520592415426",
      "bn": "0.8837468023701869",
      "bg": "0.8329297550441628",
      "zh": "0.8793532969720762",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9303623733433596",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestCalculateEvenSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, calculateEvenSum([]int{1, 4, 3, 2, 5}))\n\tassert.Equal(4, calculateEvenSum([]int{2, 2, 0, 0}))\n\tassert.Equal(0, calculateEvenSum([]int{7, 11, 19})) // Should return 0 because there are no even numbers\n\tassert.Equal(12+14+16+18+20, calculateEvenSum([]int{12, 14, 16, 18, 20}))\n}",
    "entry_point": "calculateEvenSum",
    "signature": "func calculateEvenSum(numbers []int) int",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n",
      "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers ([]int): Një segment i numrave të plotë.\nKthen:\nint: Shuma e numrave çift në segmentin e dhënë.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hy": "Հաշվել տրված ցուցակի զույգ թվերի գումարը։  \nՊարամետրեր:  \n- numbers ([]int): Թվերի շերտ։  \nՎերադարձնում է:  \nint: Մուտքային շերտի զույգ թվերի գումարը։  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "bn": "দেওয়া তালিকায় জোড় সংখ্যাগুলোর যোগফল গণনা করুন।  \nপ্যারামিটারসমূহ:  \n- numbers ([]int): পূর্ণসংখ্যার একটি স্লাইস।  \nরিটার্নস:  \nint: ইনপুট স্লাইসে জোড় সংখ্যাগুলোর যোগফল।  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "bg": "Изчислява сумата на четните числа в даден списък.  \nПараметри:  \n- numbers ([]int): Срез на цели числа.  \nВръща:  \nint: Сумата на четните числа в входния срез.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "zh": "计算给定列表中偶数的和。  \n参数：  \n- numbers ([]int): 一个整数切片。  \n返回：  \nint: 输入切片中偶数的和。\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "fr": "Calculer la somme des nombres pairs dans une liste donnée.  \nParamètres :  \n- numbers ([]int) : Une tranche d'entiers.  \nRenvoie :  \nint : La somme des nombres pairs dans la tranche d'entrée.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "de": "Berechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers ([]int): Ein Slice von ganzen Zahlen.\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabeslice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "ha": "Ƙididdige jimillar lambobin da suka zama biyu a cikin jerin da aka bayar.  \nSigogi:  \n- numbers ([]int): Wani yanki na lambobi.  \nDawowa:  \nint: Jimillar lambobin da suka zama biyu a cikin yankin shigarwa.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hi": "दिए गए सूची में सम संख्या का योग गणना करें।  \nपैरामीटर्स:  \n- numbers ([]int): पूर्णांकों की एक स्लाइस।  \nवापसी:  \nint: इनपुट स्लाइस में सम संख्याओं का योग।  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hu": "Számítsa ki a páros számok összegét egy adott listában.  \nParaméterek:  \n- numbers ([]int): Egész számok szelete.  \nVisszatérési érték:  \nint: A bemeneti szelet páros számainak összege.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9867563193444988",
      "hy": "0.9499568631716893",
      "bn": "0.9941062393339328",
      "bg": "0.9818900736395251",
      "zh": "0.9941062393339328",
      "fr": "1",
      "de": "0.9805082020786654",
      "ha": "0.9458344882436912",
      "hi": "0.9941062393339328",
      "hu": "0.9756945934246659"
    }
  },
  {
    "task_id": "Go/10",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDetermine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n\nArgumentet:\na, b: Përfaqësimi i intervalit të parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\nc, d: Përfaqësimi i intervalit të dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n\nKthen:\nint: 1 nëse intervalet ndërpriten, 0 përndryshe.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՊարզել՝ արդյոք երկու փակ միջակայքեր հատվում են:\n\nԱրգումենտներ:\na, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\nc, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n\nՎերադարձնում է:\nint: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি বন্ধ ইন্টারভাল ছেদ করে কিনা তা নির্ধারণ করুন।\n\nআর্গুমেন্ট:\na, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\nc, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n\nরিটার্ন:\nint: ইন্টারভালগুলি ছেদ করলে 1, অন্যথায় 0।\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОпределете дали два затворени интервала се пресичат.\n\nАргументи:\na, b: Представляват първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\nc, d: Представляват втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n\nВръща:\nint: 1 ако интервалите се пресичат, 0 в противен случай.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n确定两个闭区间是否相交。\n\n参数：\na, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\nc, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n\n返回：\nint: 如果区间相交返回 1，否则返回 0。\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDéterminer si deux intervalles fermés s'intersectent.\n\nArguments :\na, b : Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\nc, d : Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n\nRenvoie :\nint : 1 si les intervalles s'intersectent, 0 sinon.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBestimmen, ob sich zwei geschlossene Intervalle schneiden.\n\nArgumente:\na, b: Repräsentieren das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\nc, d: Repräsentieren das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n\nRückgabewert:\nint: 1, wenn sich die Intervalle schneiden, 0 andernfalls.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKayyade ko wasu tazara biyu masu rufewa suna haɗuwa.\n\nHujjoji:\na, b: Wakiltar tazara na farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\nc, d: Wakiltar tazara na biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n\nDawowa:\nint: 1 idan tazarorin suna haɗuwa, 0 in ba haka ba.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nनिर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n\nतर्क:\na, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\nc, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n\nवापसी मान:\nint: 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\n\nArgumentumok:\na, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\nc, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n\nVisszatér:\nint: 1, ha az intervallumok metszik egymást, 0 különben.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9856896741983415",
      "hy": "0.9644388056225619",
      "bn": "0.9831017189638379",
      "bg": "0.9846335564623789",
      "zh": "0.9661345131854567",
      "fr": "0.999999801369619",
      "de": "0.9810019972059181",
      "ha": "0.9893337471688075",
      "hi": "0.9695012981439981",
      "hu": "0.9846335564623789"
    },
    "canonical_solution": "if (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}",
    "instruction": {
      "en": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nՏվեք կարճ բնութագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\n将以下 Go 代码的自然语言描述（文档字符串）简洁地翻译成中文，字数不超过500个字符。",
      "fr": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar Go cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func AreIntervalsIntersecting(a, b, c, d int) int\nif (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.8946285691648022",
      "bn": "0.8840058163870563",
      "bg": "0.8329297550441628",
      "zh": "0.8441657263413647",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9029146341400536",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestAreIntervalsIntersecting(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, AreIntervalsIntersecting(1, 1, 1, 2))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 2, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 4, 7))\n\tassert.Equal(0, AreIntervalsIntersecting(3, 5, 6, 7))\n\t// Additional test cases\n\tassert.Equal(1, AreIntervalsIntersecting(0, 0, 0, 0))\n\tassert.Equal(1, AreIntervalsIntersecting(1, 3, 2, 4))\n\tassert.Equal(0, AreIntervalsIntersecting(1, 3, 4, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(10, 20, 20, 30))\n\tassert.Equal(0, AreIntervalsIntersecting(10, 20, 21, 30))\n}",
    "entry_point": "AreIntervalsIntersecting",
    "signature": "func AreIntervalsIntersecting(a, b, c, d int) int",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n\nArgumentet:\na, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\nc, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n\nKthen:\nint: 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Երկու փակ միջակայքերի հատման որոշում։\n\nԱրգումենտներ՝\na, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\nc, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n\nՎերադարձնում է՝\nint: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։",
      "bn": "দুইটি বন্ধ ইন্টারভাল পরস্পরকে ছেদ করে কিনা তা নির্ধারণ করুন।\n\nআর্গুমেন্টস:\na, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\nc, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n\nরিটার্নস:\nint: ইন্টারভালগুলি যদি ছেদ করে তবে 1, অন্যথায় 0।",
      "bg": "Определете дали два затворени интервала се пресичат.\n\nАргументи:\na, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\nc, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n\nВръща:\nint: 1, ако интервалите се пресичат, 0 в противен случай.",
      "zh": "确定两个闭区间是否相交。\n\n参数：\na, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\nc, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n\n返回：\nint: 如果区间相交返回 1，否则返回 0。",
      "fr": "Déterminer si deux intervalles fermés s'intersectent.\n\nArguments:\na, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\nc, d: Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n\nRenvoie:\nint: 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Bestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n\nArgumente:\na, b: Repräsentiert das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\nc, d: Repräsentiert das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n\nRückgabewerte:\nint: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Gano ko rukunin tazara biyu masu rufe suna haduwa.\n\nHujojji:\na, b: Wakiltar rukunin tazara na farko mai rufe [a, b] inda 0 <= a <= b <= 1000.\nc, d: Wakiltar rukunin tazara na biyu mai rufe [c, d] inda 0 <= c <= d <= 1000.\n\nDawowa:\nint: 1 idan rukunin tazaran suna haduwa, 0 in ba haka ba.",
      "hi": "दो बंद अंतरालों के प्रतिच्छेदन का निर्धारण करें।\n\nतर्क:\na, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\nc, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n\nवापसी:\nint: 1 यदि अंतराल प्रतिच्छेद करते हैं, अन्यथा 0।",
      "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\n\nArgumentumok:\na, b: Az első zárt intervallumot [a, b] képviseli, ahol 0 <= a <= b <= 1000.\nc, d: A második zárt intervallumot [c, d] képviseli, ahol 0 <= c <= d <= 1000.\n\nVisszatérési érték:\nint: 1, ha az intervallumok metszik egymást, 0 különben."
    },
    "docstring_bertscore": {
      "sq": "0.9844081109799043",
      "hy": "0.9753843327694894",
      "bn": "0.9788963165365673",
      "bg": "0.9782994322415575",
      "zh": "0.9452370080575382",
      "fr": "1",
      "de": "0.9626010773372271",
      "ha": "0.9844081109799043",
      "hi": "0.9747145511246398",
      "hu": "0.9769791360988185"
    }
  },
  {
    "task_id": "Go/11",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nfunc HelloMMCODEEVAL() string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nfunc HelloMMCODEEVAL() string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget\nfunc HelloMMCODEEVAL() string {"
    },
    "prompt_bertscore": {
      "sq": "0.9982075594415412",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.9982075594415412",
      "zh": "0.999999801369619",
      "fr": "0.9982075594415412",
      "de": "0.999999801369619",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.9839496720604759"
    },
    "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}",
    "instruction": {
      "en": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nՏվեք Go կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\n请用不超过500个字符的中文为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func HelloMMCODEEVAL() string\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9291421869126623",
      "bn": "0.8784854808373347",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9364712507120876",
      "ha": "0.935334886302187",
      "hi": "0.91027269797511",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestHelloMMCODEEVAL(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\", HelloMMCODEEVAL())\n}",
    "entry_point": "HelloMMCODEEVAL",
    "signature": "func HelloMMCODEEVAL() string",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնում է \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bg": "Върни \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Zurückgeben \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएँ",
      "hu": "Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget."
    },
    "docstring_bertscore": {
      "sq": "0.9081203391662159",
      "hy": "0.9560623638239396",
      "bn": "0.8965616400330337",
      "bg": "0.9420164150594386",
      "zh": "0.956679111157053",
      "fr": "0.956679111157053",
      "de": "0.956679111157053",
      "ha": "0.8340985427393734",
      "hi": "0.9027009078500601",
      "hu": "0.9107190204412954"
    }
  },
  {
    "task_id": "Go/12",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore llogarit totalin e pikëve për një student bazuar në pikët individuale në lëndë të ndryshme.\n\nParametrat:\n- scores (variadic ints): Lista e pikëve për secilën lëndë.\n\nKthen:\n- int: Totali i pikëve të marra duke mbledhur pikët individuale.\n\nShembuj:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // kthen 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore ֆունկցիան հաշվարկում է ուսանողի ընդհանուր միավորը՝ հիմնված տարբեր առարկաներում ստացված առանձին միավորների վրա:\n\nՊարամետրեր:\n- scores (փոփոխական ints): Առարկաների համար ստացված միավորների ցուցակ:\n\nՎերադարձնում է:\n- int: Ընդհանուր միավորը, որը ստացվում է առանձին միավորների գումարով:\n\nՕրինակներ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore একটি ছাত্রের জন্য বিভিন্ন বিষয়ের পৃথক স্কোরের ভিত্তিতে মোট স্কোর গণনা করে।\n\nপ্যারামিটার:\n- scores (variadic ints): প্রতিটি বিষয়ের জন্য স্কোরের তালিকা।\n\nরিটার্নস:\n- int: পৃথক স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore изчислява общия резултат за студент въз основа на индивидуалните резултати в различни предмети.\n\nПараметри:\n- scores (вариативни int): Списък с резултати за всеки предмет.\n\nВръща:\n- int: Общият резултат, получен чрез сумиране на индивидуалните резултати.\n\nПримери:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // връща 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore 计算学生在不同科目中的总分。\n\n参数:\n- scores (可变参数 int): 每个科目的分数列表。\n\n返回:\n- int: 通过将各个分数相加获得的总分。\n\n示例:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore calcule le score total pour un étudiant basé sur les scores individuels dans différentes matières.\n\nParamètres :\n- scores (entiers variadiques) : Liste des scores pour chaque matière.\n\nRenvoie :\n- int : Le score total obtenu en additionnant les scores individuels.\n\nExemples :\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore berechnet die Gesamtpunktzahl für einen Studenten basierend auf den einzelnen Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- scores (variadic ints): Liste der Punktzahlen für jedes Fach.\n\nRückgabewerte:\n- int: Die Gesamtpunktzahl, die durch Summieren der einzelnen Punktzahlen erhalten wird.\n\nBeispiele:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore yana lissafin jimillar maki ga dalibi bisa ga maki na kowane darasi daban-daban.\n\nSigogi:\n- scores (variadic ints): Jerin maki don kowane darasi.\n\nDawowa:\n- int: Jimillar maki da aka samu ta hanyar tara maki na kowane darasi.\n\nMisalai:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore एक छात्र के लिए विभिन्न विषयों में व्यक्तिगत अंकों के आधार पर कुल स्कोर की गणना करता है।\n\nपैरामीटर्स:\n- scores (variadic ints): प्रत्येक विषय के लिए अंकों की सूची।\n\nवापसी:\n- int: व्यक्तिगत अंकों को जोड़कर प्राप्त कुल स्कोर।\n\nउदाहरण:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore kiszámítja a diák összpontszámát az egyes tantárgyakban elért egyéni pontszámok alapján.\n\nParaméterek:\n- scores (variadic ints): Az egyes tantárgyak pontszámainak listája.\n\nVisszatér:\n- int: Az összpontszám, amelyet az egyéni pontszámok összegzésével kapunk.\n\nPéldák:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9790303920437659",
      "hy": "0.9706970530378282",
      "bn": "0.971237526304624",
      "bg": "0.9807123941103693",
      "zh": "0.9615938226749992",
      "fr": "0.9699933055978215",
      "de": "0.987930224896415",
      "ha": "0.9746207975847913",
      "hi": "0.9715922801651523",
      "hu": "0.9867920728130851"
    },
    "canonical_solution": "total := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}",
    "instruction": {
      "en": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nՏվեք Go կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nПредоставете кратко описание на Go кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\n请用最多500个字符的中文为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func CalculateTotalScore(scores ...int) int\ntotal := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.9229258505077944",
      "bn": "0.8980968542480523",
      "bg": "0.8396865647158265",
      "zh": "0.8793532969720762",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.91027269797511",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestCalculateTotalScore(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(500, CalculateTotalScore(100, 100, 100, 100, 100), \"should return the correct total score\")\n\tassert.Equal(0, CalculateTotalScore(0, 0, 0, 0, 0), \"should handle zero scores correctly\")\n\tassert.Equal(150, CalculateTotalScore(20, 30, 40, 10, 50), \"should return the correct total score for varied inputs\")\n\tassert.Equal(236, CalculateTotalScore(23, 45, 67, 89, 12), \"should return the correct total score for varied inputs\")\n\tassert.Equal(25, CalculateTotalScore(5, 5, 5, 5, 5), \"should return the correct total score for uniform inputs\")\n}",
    "entry_point": "CalculateTotalScore",
    "signature": "func CalculateTotalScore(scores ...int) int",
    "docstring": {
      "en": "CalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n",
      "sq": "CalculateTotalScore llogarit totalin e pikëve për një student bazuar në pikët individuale në lëndë të ndryshme.\n\nParametrat:\n- scores (variadic ints): Lista e pikëve për secilën lëndë.\n\nKthen:\n- int: Totali i pikëve të marra duke mbledhur pikët individuale.\n\nShembuj:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // kthen 500",
      "hy": "CalculateTotalScore-ը հաշվարկում է ուսանողի ընդհանուր միավորը՝ հիմնվելով տարբեր առարկաներում ստացած առանձին միավորների վրա։\n\nՊարամետրեր:\n- scores (variadic ints): Յուրաքանչյուր առարկայի միավորների ցանկ։\n\nՎերադարձնում է:\n- int: Ընդհանուր միավորը, որը ստացվում է առանձին միավորների գումարով։\n\nՕրինակներ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // վերադարձնում է 500",
      "bn": "CalculateTotalScore একটি ছাত্রের মোট স্কোর গণনা করে বিভিন্ন বিষয়ের পৃথক স্কোরের উপর ভিত্তি করে।\n\nপ্যারামিটারসমূহ:\n- scores (variadic ints): প্রতিটি বিষয়ের জন্য স্কোরের তালিকা।\n\nফেরত দেয়:\n- int: পৃথক স্কোরগুলোর যোগফল দ্বারা প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 ফেরত দেয়",
      "bg": "CalculateTotalScore изчислява общия резултат за студент въз основа на индивидуалните резултати в различни предмети.\n\nПараметри:\n- scores (вариадични int): Списък с резултати за всеки предмет.\n\nВръща:\n- int: Общият резултат, получен чрез сумиране на индивидуалните резултати.\n\nПримери:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // връща 500",
      "zh": "CalculateTotalScore 计算学生在不同科目中的单科成绩总和。\n\n参数:\n- scores (variadic ints): 每个科目的成绩列表。\n\n返回:\n- int: 通过将各个成绩相加得到的总成绩。\n\n示例:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 返回 500",
      "fr": "CalculateTotalScore calcule le score total pour un étudiant basé sur les scores individuels dans différentes matières.\n\nParamètres:\n- scores (variadic ints): Liste des scores pour chaque matière.\n\nRetourne:\n- int: Le score total obtenu en additionnant les scores individuels.\n\nExemples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // retourne 500",
      "de": "CalculateTotalScore berechnet die Gesamtpunktzahl für einen Schüler basierend auf den einzelnen Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- scores (variadic ints): Liste der Punktzahlen für jedes Fach.\n\nRückgabewerte:\n- int: Die Gesamtpunktzahl, die durch Summieren der einzelnen Punktzahlen erhalten wird.\n\nBeispiele:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // gibt 500 zurück",
      "ha": "CalculateTotalScore yana ƙididdige jimillar maki ga ɗalibi bisa ga maki na kowane fanni daban-daban.\n\nSigogi:\n- scores (variadic ints): Jerin maki don kowane fanni.\n\nDawo:\n- int: Jimillar maki da aka samu ta hanyar tara maki na kowane fanni.\n\nMisalai:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // yana dawo da 500",
      "hi": "CalculateTotalScore एक छात्र के लिए विभिन्न विषयों में व्यक्तिगत अंकों के आधार पर कुल अंक की गणना करता है।\n\nParameters:\n- scores (variadic ints): प्रत्येक विषय के लिए अंकों की सूची।\n\nReturns:\n- int: व्यक्तिगत अंकों को जोड़कर प्राप्त कुल अंक।\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500",
      "hu": "CalculateTotalScore kiszámítja a hallgató összpontszámát a különböző tantárgyakban elért egyéni pontszámok alapján.\n\nParaméterek:\n- scores (variadic ints): Az egyes tantárgyak pontszámainak listája.\n\nVisszatérési érték:\n- int: Az összpontszám, amelyet az egyéni pontszámok összegzésével kapunk.\n\nPéldák:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // visszaadja az 500-at"
    },
    "docstring_bertscore": {
      "sq": "0.9812409495543031",
      "hy": "0.9826814170775681",
      "bn": "0.9658157114238958",
      "bg": "0.9738167418023621",
      "zh": "0.9567827962159532",
      "fr": "0.974026495484735",
      "de": "0.98241306743279",
      "ha": "0.96554398506264",
      "hi": "0.9594386830407706",
      "hu": "0.970576285766159"
    }
  },
  {
    "task_id": "Go/13",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers dekodon një seri numrash për të zbuluar modelin e fshehur që tregon\nvlerat aktuale që përfaqëson secila shifër. Modeli përcaktohet si më poshtë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk tejkalon 100.\n\nKthen:\nint: Rezultati që korrespondon me secilin varg të dhënash sipas modelit të paracaktuar.\n\nShembull përdorimi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers-ը վերծանում է թվերի շարք՝ բացահայտելու թաքնված օրինաչափությունը, որը ցույց է տալիս\nյուրաքանչյուր թվանշանի ներկայացրած իրական արժեքները: Օրինաչափությունը սահմանված է հետևյալ կերպ.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- dataStr: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի՝ նախապես սահմանված օրինաչափության համաձայն:\n\nՕրինակ օգտագործում:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers সংখ্যার একটি সিরিজ ডিকোড করে লুকানো প্যাটার্ন প্রকাশ করে যা প্রতিটি সংখ্যার প্রকৃত মান নির্দেশ করে। প্যাটার্নটি নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের জন্য পূর্বনির্ধারিত প্যাটার্ন অনুযায়ী ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers декодира поредица от числа, за да разкрие скрития модел, който показва\nдействителните стойности, които всяка цифра представлява. Моделът е дефиниран по следния начин:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- dataStr: Низ, представляващ поредица от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът, съответстващ на всеки низ от данни според предварително дефинирания модел.\n\nПример за използване:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers 解码一系列数字以揭示隐藏的模式，该模式指示每个数字代表的实际值。模式定义如下：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- dataStr: 表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 根据预定义模式对应于每个数据字符串的结果。\n\n示例用法：\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers décode une série de chiffres pour révéler le motif caché qui indique\nles valeurs réelles que chaque chiffre représente. Le motif est défini comme suit :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- dataStr : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRetourne :\nint : Le résultat correspondant à chaque chaîne de données selon le motif prédéfini.\n\nExemple d'utilisation :\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers dekodiert eine Serie von Zahlen, um das verborgene Muster zu enthüllen, welches die tatsächlichen Werte angibt, die jede Ziffer darstellt. Das Muster ist wie folgt definiert:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- dataStr: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabe:\nint: Das Ergebnis, das jedem Datenstring gemäß dem vordefinierten Muster entspricht.\n\nBeispielverwendung:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers yana fassara jerin lambobi don bayyana tsarin ɓoyayyen abin da ke nuna\nainihin ƙimar da kowace lamba ke wakilta. An ayyana tsarin kamar haka:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- dataStr: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nAbin da ake dawowa da shi:\nint: Sakamakon da ya dace da kowane kirtanin bayanai bisa tsarin da aka rigaya aka ayyana.\n\nMisalin amfani:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers संख्याओं की एक श्रृंखला को डिकोड करता है ताकि छिपे हुए पैटर्न को प्रकट किया जा सके जो दर्शाता है\nवास्तविक मान प्रत्येक अंक का प्रतिनिधित्व करता है। पैटर्न निम्नलिखित के रूप में परिभाषित है:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- dataStr: संख्याओं की एक श्रृंखला का प्रतिनिधित्व करने वाली एक स्ट्रिंग। लंबाई 100 से अधिक नहीं होती है।\n\nवापसी:\nint: पूर्वनिर्धारित पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के लिए परिणाम।\n\nउदाहरण उपयोग:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers dekódolja a számok sorozatát, hogy felfedje a rejtett mintát, amely jelzi,\nhogy az egyes számjegyek valójában milyen értékeket képviselnek. A minta a következőképpen van meghatározva:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- dataStr: Egy karakterlánc, amely számok sorozatát képviseli. A hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az eredmény, amely az egyes adatkarakterláncokhoz tartozik az előre meghatározott minta szerint.\n\nPélda használat:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9915802567783121",
      "hy": "0.9839758912707725",
      "bn": "0.9765687657316005",
      "bg": "0.9911188384031681",
      "zh": "0.9890556646353587",
      "fr": "0.9857349619252175",
      "de": "0.9965422423269447",
      "ha": "0.9738826870888656",
      "hi": "0.9894249185137025",
      "hu": "0.988909472674917"
    },
    "canonical_solution": "a := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func DecodeNumbers(dataStr string) int\na := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9243263933244714",
      "bn": "0.8888925210212767",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.91027269797511",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestDecodeNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, DecodeNumbers(\"0000\"))\n\tassert.Equal(8, DecodeNumbers(\"8888\"))\n\tassert.Equal(1, DecodeNumbers(\"1234\"))\n\tassert.Equal(3, DecodeNumbers(\"5678\"))\n\tassert.Equal(2, DecodeNumbers(\"9012\"))\n\tassert.Equal(0, DecodeNumbers(\"1357\"))\n\tassert.Equal(4, DecodeNumbers(\"2468\"))\n\n\t// Additional test samples\n\tassert.Equal(4, DecodeNumbers(\"9999\"))\n\tassert.Equal(0, DecodeNumbers(\"1111\"))\n\tassert.Equal(0, DecodeNumbers(\"2222\"))\n\tassert.Equal(0, DecodeNumbers(\"3333\"))\n\tassert.Equal(4, DecodeNumbers(\"4444\"))\n\tassert.Equal(0, DecodeNumbers(\"5555\"))\n\tassert.Equal(4, DecodeNumbers(\"6666\"))\n\tassert.Equal(0, DecodeNumbers(\"7777\"))\n\tassert.Equal(3, DecodeNumbers(\"0001\"))\n\tassert.Equal(1, DecodeNumbers(\"2301\"))\n}",
    "entry_point": "DecodeNumbers",
    "signature": "func DecodeNumbers(dataStr string) int",
    "docstring": {
      "en": "DecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "sq": "DecodeNumbers dekodon një seri numrash për të zbuluar modelin e fshehur që tregon vlerat aktuale që përfaqëson secila shifër. Modeli është i përcaktuar si më poshtë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati që korrespondon me secilin varg të dhënash sipas modelit të paracaktuar.\n\nShembull përdorimi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hy": "DecodeNumbers-ը վերծանում է թվերի շարք՝ բացահայտելու թաքնված օրինաչափությունը, որը ցույց է տալիս, թե ինչ արժեքներ է ներկայացնում յուրաքանչյուր թվանշան: Օրինաչափությունը սահմանված է հետևյալ կերպ.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- dataStr: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալների տողին՝ նախապես սահմանված օրինաչափության համաձայն:\n\nՕրինակ օգտագործում:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "bn": "DecodeNumbers একটি সংখ্যার সিরিজ ডিকোড করে লুকানো প্যাটার্ন প্রকাশ করে যা প্রতিটি অঙ্কের প্রকৃত মান নির্দেশ করে। প্যাটার্নটি নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- dataStr: একটি স্ট্রিং যা একটি সংখ্যার সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: পূর্বনির্ধারিত প্যাটার্ন অনুযায়ী প্রতিটি ডেটা স্ট্রিং এর সাথে সংশ্লিষ্ট ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "bg": "DecodeNumbers декодира серия от числа, за да разкрие скрития модел, който показва действителните стойности, които всяка цифра представлява. Моделът е дефиниран, както следва: 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- dataStr: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът, съответстващ на всеки низ от данни според предварително определения модел.\n\nПример за използване:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "zh": "DecodeNumbers 解码一系列数字以揭示隐藏的模式，该模式指示每个数字代表的实际值。模式定义如下：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数:\n- dataStr: 一个表示一系列数字的字符串。长度不超过100。\n\n返回:\nint: 根据预定义模式对应于每个数据字符串的结果。\n\n示例用法:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "fr": "DecodeNumbers décode une série de chiffres pour révéler le motif caché qui indique les valeurs réelles que chaque chiffre représente. Le motif est défini comme suit : 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- dataStr : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat correspondant à chaque chaîne de données selon le motif prédéfini.\n\nExemple d'utilisation :\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "de": "DecodeNumbers dekodiert eine Serie von Zahlen, um das verborgene Muster zu enthüllen, das die tatsächlichen Werte darstellt, die jede Ziffer repräsentiert. Das Muster ist wie folgt definiert:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- dataStr: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis, das jedem Datenstring gemäß dem vordefinierten Muster entspricht.\n\nBeispielverwendung:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "ha": "DecodeNumbers yana fassara jerin lambobi don bayyana tsarin ɓoye wanda ke nuna\nainihin ƙimar da kowace lamba ke wakilta. An ayyana tsarin kamar haka:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- dataStr: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nDawowa:\nint: Sakamakon da ya dace da kowanne kirtani na bayanai bisa ga tsarin da aka riga aka ayyana.\n\nMisalin amfani:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hi": "DecodeNumbers संख्याओं की एक श्रृंखला को डिकोड करता है ताकि छिपे हुए पैटर्न का पता चल सके जो संकेत देता है कि प्रत्येक अंक का वास्तविक मूल्य क्या है। पैटर्न निम्नलिखित रूप से परिभाषित है:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- dataStr: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nरिटर्न्स:\nint: पूर्वनिर्धारित पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n\nउदाहरण उपयोग:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hu": "DecodeNumbers dekódol egy számsorozatot, hogy feltárja a rejtett mintát, amely jelzi, hogy az egyes számjegyek valójában mit képviselnek. A minta a következőképpen van meghatározva:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- dataStr: Egy számsorozatot reprezentáló karakterlánc. A hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az eredmény, amely az egyes adatkarakterláncokhoz tartozik az előre meghatározott minta szerint.\n\nPélda használat:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))"
    },
    "docstring_bertscore": {
      "sq": "0.9909343107791867",
      "hy": "0.9883453623927779",
      "bn": "0.9804446403567342",
      "bg": "0.9964961600785446",
      "zh": "0.9870347991387097",
      "fr": "0.9911023520815422",
      "de": "0.9842933026196662",
      "ha": "0.9758479360788248",
      "hi": "0.9802956675709581",
      "hu": "0.9754858328941982"
    }
  },
  {
    "task_id": "Go/14",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë\nme m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe\nkatrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nArgumentet:\n    n int: Numri i katrorëve.\n    m int: Numri i ngjyrave.\n\nKthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n\nShembuj:\n    CountColoringMethods(1,1) kthen 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods հաշվում է քառակուսիների n քանակի համար տարբեր գունավորման մեթոդների քանակը\nm գույներով, հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և\nառաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։\n\nԱրգումենտներ:\n    n int: Քառակուսիների քանակը։\n    m int: Գույների քանակը։\n\nՎերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։\n\nՕրինակներ:\n    CountColoringMethods(1,1) վերադարձնում է 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods ফাংশনটি n টি বর্গক্ষেত্রের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে\nm টি রঙের সাথে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\nআর্গুমেন্টসমূহ:\n    n int: বর্গক্ষেত্রের সংখ্যা।\n    m int: রঙের সংখ্যা।\n\nফেরত দেয়:\n    int: নির্দিষ্ট শর্তাবলী পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n\nউদাহরণ:\n    CountColoringMethods(1,1) 1 ফেরত দেয়\n*/\nfunc CountColoringMethods(n, m int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods брои броя на различните методи за оцветяване за n квадрата\nс m цвята, като се взема предвид изискването съседните квадрати и\nпървият/последният квадрат да са с различни цветове.\n\nАргументи:\n    n int: Броят на квадратите.\n    m int: Броят на цветовете.\n\nВръща:\n    int: Броят на различните методи за оцветяване, които отговарят на посочените условия.\n\nПримери:\n    CountColoringMethods(1,1) връща 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods 计算对于 n 个方块和 m 种颜色的不同着色方法数量，\n考虑到相邻方块和第一个/最后一个方块必须具有不同颜色的要求。\n\n参数:\n    n int: 方块的数量。\n    m int: 颜色的数量。\n\n返回:\n    int: 满足指定条件的不同着色方法的数量。\n\n示例:\n    CountColoringMethods(1,1) 返回 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods compte le nombre de méthodes de coloration différentes pour n carrés\navec m couleurs, en considérant l'exigence que les carrés adjacents et les\npremier/dernier carrés doivent avoir des couleurs différentes.\n\nArgs:\n    n int: Le nombre de carrés.\n    m int: Le nombre de couleurs.\n\nReturns:\n    int: Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate\nmit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die\nersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\nArgumente:\n    n int: Die Anzahl der Quadrate.\n    m int: Die Anzahl der Farben.\n\nRückgabewert:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n\nBeispiele:\n    CountColoringMethods(1,1) gibt 1 zurück\n*/\nfunc CountColoringMethods(n, m int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods yana ƙididdige adadin hanyoyin launi daban-daban don murabba'i n\ntare da launuka m, la'akari da buƙatar cewa murabba'ai masu makwabtaka da kuma\nmurabba'ai na farko/na ƙarshe dole ne su sami launuka daban-daban.\n\nArgs:\n    n int: Yawan murabba'ai.\n    m int: Yawan launuka.\n\nReturns:\n    int: Adadin hanyoyin launi daban-daban da suka cika ka'idodin da aka ƙayyade.\n\nMisalai:\n    CountColoringMethods(1,1) yana dawowa 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods n वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की संख्या गिनता है\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nआर्ग्स:\n    n int: वर्गों की संख्या।\n    m int: रंगों की संख्या।\n\nरिटर्न्स:\n    int: निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगने के तरीकों की गिनती।\n\nउदाहरण:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods megszámolja a különböző színezési módszerek számát n négyzetre\nm színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az\nelső/utolsó négyzetek különböző színűek legyenek.\n\nArgok:\n    n int: A négyzetek száma.\n    m int: A színek száma.\n\nVisszatér:\n    int: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n\nPéldák:\n    CountColoringMethods(1,1) visszatér 1\n*/\nfunc CountColoringMethods(n, m int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9709032313733423",
      "hy": "0.9720701848619223",
      "bn": "0.9422402714988649",
      "bg": "0.9757629222757419",
      "zh": "0.948013860784406",
      "fr": "0.996350365378865",
      "de": "0.9765574437998814",
      "ha": "0.9781359594379657",
      "hi": "0.9755684631327087",
      "hu": "0.9879761085144341"
    },
    "canonical_solution": "const mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}",
    "instruction": {
      "en": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nՏվեք Go կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\n将以下 Go 代码的说明内容翻译成中文，并用不超过 500 个字符提供简洁的自然语言描述（文档字符串）。",
      "fr": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func CountColoringMethods(n, m int) int\nconst mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9049180201631715",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8309516416126377",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9528896407476694",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCountColoringMethods(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountColoringMethods(1, 1))\n\tassert.Equal(2, CountColoringMethods(2, 2))\n\tassert.Equal(6, CountColoringMethods(3, 3))\n\tassert.Equal(2, CountColoringMethods(4, 2))\n\t// Add your tests here\n\tassert.Equal(6, CountColoringMethods(2, 3))\n\tassert.Equal(67911, CountColoringMethods(1000, 1000))\n\tassert.Equal(501817, CountColoringMethods(999, 66))\n\tassert.Equal(30, CountColoringMethods(5, 3))\n\n\t// Test with unknown expected result, assuming a placeholder value is \"expectedResult\".\n\t// Replace \"expectedResult\" with the actual expected value if known.\n\texpectedResult := 566585 // Placeholder for the expected result of CountColoringMethods(1000, 10)\n\tassert.Equal(expectedResult, CountColoringMethods(1000, 10))\n}",
    "entry_point": "CountColoringMethods",
    "signature": "func CountColoringMethods(n, m int) int",
    "docstring": {
      "en": "CountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n",
      "sq": "CountColoringMethods numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nArgs:\n    n int: Numri i katrorëve.\n    m int: Numri i ngjyrave.\n\nReturns:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n\nExamples:\n    CountColoringMethods(1,1) kthen 1",
      "hy": "CountColoringMethods-ը հաշվում է n քառակուսիների համար տարբեր գունավորման մեթոդների քանակը՝ m գույներով, հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։\n\nԱրգումենտներ:\n    n int: Քառակուսիների քանակը։\n    m int: Գույների քանակը։\n\nՎերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։\n\nՕրինակներ:\n    CountColoringMethods(1,1) վերադարձնում է 1",
      "bn": "CountColoringMethods n টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\nArgs:\n    n int: বর্গক্ষেত্রের সংখ্যা।\n    m int: রঙের সংখ্যা।\n\nReturns:\n    int: নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n\nExamples:\n    CountColoringMethods(1,1) 1 ফেরত দেয়",
      "bg": "CountColoringMethods брои броя на различните методи за оцветяване за n квадрата\nс m цвята, като се взема предвид изискването съседните квадрати и\nпървият/последният квадрат да имат различни цветове.\n\nArgs:\n    n int: Броят на квадратите.\n    m int: Броят на цветовете.\n\nReturns:\n    int: Броят на различните методи за оцветяване, които отговарят на посочените условия.\n\nExamples:\n    CountColoringMethods(1,1) връща 1",
      "zh": "CountColoringMethods 计算使用 m 种颜色为 n 个方块上色的不同方法数量，考虑到相邻方块和首/尾方块必须具有不同颜色的要求。\n\n参数:\n    n int: 方块的数量。\n    m int: 颜色的数量。\n\n返回:\n    int: 满足指定条件的不同上色方法的数量。\n\n示例:\n    CountColoringMethods(1,1) 返回 1",
      "fr": "CountColoringMethods compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\nArgs:\n    n int: Le nombre de carrés.\n    m int: Le nombre de couleurs.\n\nReturns:\n    int: Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées.\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "de": "CountColoringMethods zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\nArgs:\n    n int: Die Anzahl der Quadrate.\n    m int: Die Anzahl der Farben.\n\nReturns:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n\nExamples:\n    CountColoringMethods(1,1) gibt 1 zurück",
      "ha": "CountColoringMethods yana ƙirga yawan hanyoyin launuka daban-daban don murabba'i n\ntare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da kuma\nmurabba'i na farko/na ƙarshe dole ne su kasance da launuka daban-daban.\n\nArgs:\n    n int: Yawan murabba'ai.\n    m int: Yawan launuka.\n\nReturns:\n    int: Yawan hanyoyin launuka daban-daban da suka cika sharuɗɗan da aka fayyace.\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "hi": "CountColoringMethods n वर्गों के लिए m रंगों के विभिन्न रंगाई तरीकों की संख्या की गणना करता है, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nArgs:\n    n int: वर्गों की संख्या।\n    m int: रंगों की संख्या।\n\nReturns:\n    int: निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगाई तरीकों की संख्या।\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "hu": "CountColoringMethods megszámolja a különböző színezési módszerek számát n négyzetre\nm színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az\nelső/utolsó négyzetek különböző színűek legyenek.\n\nArgs:\n    n int: A négyzetek száma.\n    m int: A színek száma.\n\nReturns:\n    int: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n\nExamples:\n    CountColoringMethods(1,1) visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9747427566387468",
      "hy": "0.9688531672106813",
      "bn": "0.957333796892944",
      "bg": "0.983181767007395",
      "zh": "0.9250041201845625",
      "fr": "0.9950060349600208",
      "de": "0.9797808176233156",
      "ha": "0.9669602196794188",
      "hi": "0.9772923762097105",
      "hu": "0.976862142804389"
    }
  },
  {
    "task_id": "Go/15",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\nKthen:\n- uint64: Numri i sekuencave të vlefshme.\nShembull:\n    countValidCoinTossSequences(1)\n    // Kthen: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվեք վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների դեպքում չկան հաջորդական գլուխներ:\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը:\nՎերադարձնում է:\n- uint64: Վավեր հաջորդականությունների քանակը:\nՕրինակ:\n    countValidCoinTossSequences(1)\n    // Վերադարձնում է: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nকোনো পরপর হেড না থাকা n টসের বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\nপ্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\nফেরত দেয়:\n- uint64: বৈধ সিকোয়েন্সের সংখ্যা।\nউদাহরণ:\n    countValidCoinTossSequences(1)\n    // ফেরত দেয়: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\nПараметри:\n- n (int): Броят на хвърлянията на монета.\nВръща:\n- uint64: Броят на валидните последователности.\nПример:\n    countValidCoinTossSequences(1)\n    // Връща: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n参数:\n- n (int): 投掷硬币的次数。\n返回:\n- uint64: 有效序列的数量。\n示例:\n    countValidCoinTossSequences(1)\n    // 返回: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCompter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\nParamètres :\n- n (int) : Le nombre de lancers de pièce.\nRenvoie :\n- uint64 : Le nombre de séquences valides.\nExemple :\n    countValidCoinTossSequences(1)\n    // Renvoie : 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\nRückgabe:\n- uint64: Die Anzahl der gültigen Sequenzen.\nBeispiel:\n    countValidCoinTossSequences(1)\n    // Gibt zurück: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa tsabar kudi n.\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\nMayar da:\n- uint64: Adadin sahihan jerin.\nMisali:\n    countValidCoinTossSequences(1)\n    // Mayar da: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nसत्यापित सिक्का उछाल अनुक्रमों की संख्या गिनें जिनमें n उछालों में कोई लगातार हेड्स नहीं हैं।\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\nरिटर्न्स:\n- uint64: सत्यापित अनुक्रमों की गिनती।\nउदाहरण:\n    countValidCoinTossSequences(1)\n    // रिटर्न करता है: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincs egymást követő fej n dobásban.\nParaméterek:\n- n (int): A pénzfeldobások száma.\nVisszatér:\n- uint64: Az érvényes sorozatok száma.\nPélda:\n    countValidCoinTossSequences(1)\n    // Visszatér: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9846909606424981",
      "hy": "0.9777426712835167",
      "bn": "0.9803214895204926",
      "bg": "0.9926347854712263",
      "zh": "0.985903003227573",
      "fr": "0.9926347854712263",
      "de": "0.9926347854712263",
      "ha": "0.9578399071038208",
      "hi": "0.9915540375680155",
      "hu": "0.9879179098127908"
    },
    "canonical_solution": "var a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}",
    "instruction": {
      "en": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nՏվեք կարճ բնութագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nনিচের Go কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বোচ্চ ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nДайте кратко описание на Go кода на български език, използвайки най-много 500 символа.",
      "zh": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\n将以下 Go 代码的功能使用不超过500个字符的中文进行简洁的自然语言描述（文档字符串）。",
      "fr": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func CountValidCoinTossSequences(n int) uint64\nvar a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8916920176115823",
      "bn": "0.873551104911666",
      "bg": "0.834864660119025",
      "zh": "0.8587797579956256",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestCountValidCoinTossSequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(uint64(2), CountValidCoinTossSequences(1))\n\tassert.Equal(uint64(3), CountValidCoinTossSequences(2))\n\tassert.Equal(uint64(5), CountValidCoinTossSequences(3))\n\tassert.Equal(uint64(8), CountValidCoinTossSequences(4))  // Additional test\n\tassert.Equal(uint64(13), CountValidCoinTossSequences(5)) // Additional test\n\t// Feel free to add more tests here\n\tassert.Equal(uint64(267914296), CountValidCoinTossSequences(40)) // Additional test\n\tassert.Equal(uint64(165580141), CountValidCoinTossSequences(39))\n\tassert.Equal(uint64(102334155), CountValidCoinTossSequences(38))\n\t// Use t.Log instead of fmt.Print or fmt.Println in tests\n\tt.Log(\"All tests passed!\")\n}",
    "entry_point": "CountValidCoinTossSequences",
    "signature": "func CountValidCoinTossSequences(n int) uint64",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhave pa koka radhazi në n hedhje.\nParametrat:\n- n (int): Numri i hedhjeve të monedhave.\nKthen:\n- uint64: Numri i sekuencave të vlefshme.\nShembull:\n    countValidCoinTossSequences(1)\n    // Kthen: 2",
      "hy": "Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետումների ժամանակ։ \nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\nՎերադարձնում է:\n- uint64: Վավեր հաջորդականությունների քանակը։\nՕրինակ:\n    countValidCoinTossSequences(1)\n    // Վերադարձնում է: 2",
      "bn": "n টি টসে পরপর কোনো মাথা না থাকার বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\nপ্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\nফেরত দেয়:\n- uint64: বৈধ সিকোয়েন্সের সংখ্যা।\nউদাহরণ:\n    countValidCoinTossSequences(1)\n    // ফেরত দেয়: 2",
      "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\nПараметри:\n- n (int): Броят на хвърлянията на монета.\nВръща:\n- uint64: Броят на валидните последователности.\nПример:\n    countValidCoinTossSequences(1)\n    // Връща: 2",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n参数：\n- n (int): 硬币投掷的次数。\n返回：\n- uint64: 有效序列的数量。\n示例：\n    countValidCoinTossSequences(1)\n    // 返回: 2",
      "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\nParamètres :\n- n (int) : Le nombre de lancers de pièce.\nRenvoie :\n- uint64 : Le compte des séquences valides.\nExemple :\n    countValidCoinTossSequences(1)\n    // Renvoie : 2",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\nRückgabewert:\n- uint64: Die Anzahl der gültigen Sequenzen.\nBeispiel:\n    countValidCoinTossSequences(1)\n    // Gibt zurück: 2",
      "ha": "Kirga adadin jerin jefa tsabar kudi masu inganci ba tare da kai biyu a jere ba a cikin jefa tsabar kudi n.\nSigogi:\n- n (int): Adadin jefa tsabar kudi.\nDawowa:\n- uint64: Adadin jerin masu inganci.\nMisali:\n    countValidCoinTossSequences(1)\n    // Dawowa: 2",
      "hi": "सत्यापित सिक्का उछाल अनुक्रमों की संख्या गिनें जिनमें n उछालों में कोई लगातार हेड्स नहीं हैं। \nपैरामीटर्स:\n- n (int): सिक्का उछाल की संख्या।\nरिटर्न्स:\n- uint64: सत्यापित अनुक्रमों की गिनती।\nउदाहरण:\n    countValidCoinTossSequences(1)\n    // रिटर्न करता है: 2",
      "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs két egymást követő fej az n dobás során.\nParaméterek:\n- n (int): A pénzfeldobások száma.\nVisszatér:\n- uint64: Az érvényes sorozatok száma.\nPélda:\n    countValidCoinTossSequences(1)\n    // Visszatér: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9785445421317545",
      "hy": "0.9693841062191875",
      "bn": "0.9577624412552173",
      "bg": "0.980824421645273",
      "zh": "0.9667113358119821",
      "fr": "0.9944159040979662",
      "de": "0.981575840376728",
      "ha": "0.9739573721121347",
      "hi": "0.9599831289151873",
      "hu": "0.969074044194392"
    }
  },
  {
    "task_id": "Go/16",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri jo-negativ.\n\nParametrat:\n- n (uint64): Një numër jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\nint: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- n (uint64): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\nint: Ամենաերկար հաջորդական 1-երի երկարությունը տրված ամբողջ թվի բինար ներկայացման մեջ:\n\nՕրինակներ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজুন।\n\nপ্যারামিটার:\n- n (uint64): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nরিটার্নস:\nint: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য।\n\nউদাহরণ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nНамерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (uint64): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\nint: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数：\n- n (uint64): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\nint: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例：\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (uint64) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\nint : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFinde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (uint64): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\nint: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNemo tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (uint64): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\nint: Tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nकिसी गैर-ऋणात्मक पूर्णांक के द्विआधारी निरूपण में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (uint64): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\nint: दिए गए पूर्णांक के द्विआधारी निरूपण में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKeresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (uint64): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatér:\nint: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9663136777891502",
      "hy": "0.9864929354592465",
      "bn": "0.9971738869386356",
      "bg": "0.9805675925625948",
      "zh": "0.9941372256733743",
      "fr": "1",
      "de": "0.9909716532908213",
      "ha": "0.9683546049542837",
      "hi": "0.9941372256733743",
      "hu": "0.9969399003497765"
    },
    "canonical_solution": "max := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}",
    "instruction": {
      "en": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func findLongestConsecutiveOnesLength(n uint64) int\nmax := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9243263933244714",
      "bn": "0.8665176031192207",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestFindLongestConsecutiveOnesLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, findLongestConsecutiveOnesLength(7))\n\tassert.Equal(2, findLongestConsecutiveOnesLength(13))\n\tassert.Equal(3, findLongestConsecutiveOnesLength(12345))         // New test sample\n\tassert.Equal(4, findLongestConsecutiveOnesLength(0b11011101111)) // New test sample using binary literal for clarity\n\tassert.Equal(32, findLongestConsecutiveOnesLength(0xFFFFFFFF))   // New test sample: all ones for a 32-bit number\n\tassert.Equal(0, findLongestConsecutiveOnesLength(0))             // New test sample: no ones in a zero\n}",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "func findLongestConsecutiveOnesLength(n uint64) int",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave të njëpasnjëshme në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (uint64): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\nint: Gjatësia e sekuencës më të gjatë të njëshave të njëpasnjëshme në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hy": "Բացահայտեք ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ։\n\nՊարամետրեր:\n- n (uint64): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n\nՎերադարձնում է:\nint: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n\nՕրինակներ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজুন।\n\nপ্যারামিটারসমূহ:\n- n (uint64): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\nint: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে সবচেয়ে দীর্ঘ ক্রমাগত 1-এর ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "bg": "Намерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (uint64): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\nint: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "zh": "找到一个非负整数的二进制表示中最长连续1的序列的长度。\n\n参数：\n- n (uint64): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\nint: 给定整数的二进制表示中最长连续1的序列的长度。\n\n示例：\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres:\n- n (uint64): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie:\nint: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "de": "Finden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (uint64): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\nint: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba maras kyau.\n\nSigogi:\n- n (uint64): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\nint: Tsawon jerin tsararrun 1s mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (uint64): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\nint: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hu": "A nemnegatív egész szám bináris ábrázolásában találja meg a leghosszabb egymást követő 1-esek sorozatának hosszát.\n\nParaméterek:\n- n (uint64): Egy nemnegatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatér:\nint: A megadott egész szám bináris ábrázolásában a leghosszabb egymást követő 1-esek sorozatának hossza.\n\nPéldák:\n    >>> findLongestConsecutiveOnesLength(7)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9624888511719424",
      "hy": "0.9896885010293358",
      "bn": "1",
      "bg": "0.9863894490307273",
      "zh": "0.9975707504399434",
      "fr": "1",
      "de": "0.9926530594662816",
      "ha": "0.9798566944288709",
      "hi": "0.9975707504399434",
      "hu": "1"
    }
  },
  {
    "task_id": "Go/17",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (string): Fjalë e parë që do të përdoret në ID.\n- word2 (string): Fjalë e dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të\n        fjalës së dytë dhe duke e kombinuar me fjalën e parë.\np.sh.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով:\nՊարամետրեր:\n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում:\n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում:\nՎերադարձնում է:\nstring: Աստվածային ID, որը կազմված է երկրորդ բառի յուրաքանչյուր երկրորդ սիմվոլի շրջմամբ\n        և առաջին բառի հետ համադրությամբ:\nօր.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটার:\n- word1 (string): প্রথম শব্দ যা আইডিতে ব্যবহার করা হবে।\n- word2 (string): দ্বিতীয় শব্দ যা আইডিতে ব্যবহার করা হবে।\nফেরত দেয়:\nstring: একটি ঐশ্বরিক আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে একত্রিত করে গঠিত হয়।\nউদাহরণ:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nСъздава ID чрез комбиниране на две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще се използва в ID.\n- word2 (string): Втората дума, която ще се използва в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ на\n        втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n通过以特定方式组合两个单词来创建一个ID。\n参数:\n- word1 (string): 用于ID的第一个单词。\n- word2 (string): 用于ID的第二个单词。\n返回:\nstring: 一个神圣的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (string) : Le premier mot à utiliser dans l'ID.\n- word2 (string) : Le second mot à utiliser dans l'ID.\nRetourne :\nstring : Un ID divin formé en inversant chaque autre caractère du second\n         mot et en le combinant avec le premier mot.\nex. :\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (string): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nstring: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des\n        zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu ta wata hanya ta musamman.\nSigogi:\n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nYana dawowa:\nstring: Wani ID mai ban mamaki wanda aka ƙirƙira ta hanyar juyar da kowane harafi na biyu na kalma ta biyu\n        kuma a haɗa shi da kalma ta farko.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदो शब्दों को एक विशेष तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (string): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (string): आईडी में उपयोग के लिए दूसरा शब्द।\nवापसी:\nstring: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और पहले शब्द के साथ मिलाकर बनती है।\nउदा.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLétrehoz egy azonosítót két szó meghatározott módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első szó, amelyet az azonosítóban használunk.\n- word2 (string): A második szó, amelyet az azonosítóban használunk.\nVisszatér:\nstring: Egy isteni azonosító, amelyet a második szó minden második karakterének\n        megfordításával és az első szóval való kombinálásával hozunk létre.\npélda:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {"
    },
    "prompt_bertscore": {
      "sq": "0.986529880710119",
      "hy": "0.9874670188478417",
      "bn": "0.9768142728825596",
      "bg": "0.9854832972324462",
      "zh": "0.955114102384879",
      "fr": "0.9814995663104105",
      "de": "0.9799401191889056",
      "ha": "0.9774238695219556",
      "hi": "0.961091287810981",
      "hu": "0.9509331314944757"
    },
    "canonical_solution": "length1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}",
    "instruction": {
      "en": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nПредоставете кратко описание на Go кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\n请用中文为以下 Go 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func CreateID(word1, word2 string) string\nlength1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9307552642370466",
      "bn": "0.8905304271432903",
      "bg": "0.8415138121241679",
      "zh": "0.8733431389027225",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9219535547926286",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCreateID(t *testing.T) {\n\tassert.Equal(t, \"ftiasch\", CreateID(\"fish\", \"cat\"))\n\tassert.Equal(t, \"imccpac\", CreateID(\"icpc\", \"acm\"))\n\tassert.Equal(t, \"owo\", CreateID(\"oo\", \"w\"))\n\tassert.Equal(t, \"hdellrloow\", CreateID(\"hello\", \"world\"))\n\tassert.Equal(t, \"afbecd\", CreateID(\"abc\", \"def\"))\n\tassert.Equal(t, \"bauaauabnbbn\", CreateID(\"buaanb\", \"nbbuaa\"))\n\tassert.Equal(t, \"xuttuxiesvgooloid\", CreateID(\"xtuisgood\", \"ilovextu\"))\n}",
    "entry_point": "CreateID",
    "signature": "func CreateID(word1, word2 string) string",
    "docstring": {
      "en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"\n",
      "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (string): Fjala e parë që do të përdoret në ID.\n- word2 (string): Fjala e dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով։  \nՊարամետրեր:  \n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nstring: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ սիմվոլը շրջելով և այն առաջին բառի հետ համադրելով։  \nօրինակ:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "bn": "একটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (string): ID তৈরির জন্য ব্যবহৃত প্রথম শব্দ।\n- word2 (string): ID তৈরির জন্য ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন:\nstring: একটি অনন্য ID যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে প্রথম শব্দের সাথে মিলিয়ে গঠিত হয়।\nউদাহরণ:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще се използва в ID.\n- word2 (string): Втората дума, която ще се използва в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ от втората\n        дума и комбинирането му с първата дума.\nнапр.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "zh": "创建一个ID，通过特定方式组合两个单词。\n参数:\n- word1 (string): 用于ID的第一个单词。  \n- word2 (string): 用于ID的第二个单词。  \n返回:  \nstring: 一个神奇的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。  \n例如:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "fr": "Crée un ID en combinant deux mots d'une manière spécifique.  \nParamètres :  \n- word1 (string) : Le premier mot à utiliser dans l'ID.  \n- word2 (string) : Le deuxième mot à utiliser dans l'ID.  \nRenvoie :  \nstring : Un ID divin formé en inversant chaque autre caractère du deuxième  \n         mot et en le combinant avec le premier mot.  \ne.g. :  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (string): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nstring: Eine göttliche ID, die gebildet wird, indem jedes zweite Zeichen des zweiten\n        Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "ha": "Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\nParameters:\n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nReturns:\nstring: Wani ID mai ban mamaki da aka samar ta hanyar juyar da kowace harafi na biyu na kalma ta biyu\n        kuma a haɗa shi da kalma ta farko.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hi": "दो शब्दों को एक विशेष तरीके से संयोजित करके एक आईडी बनाता है।\nमापदंड:  \n- word1 (string): ID में उपयोग के लिए पहला शब्द।  \n- word2 (string): ID में उपयोग के लिए दूसरा शब्द।  \nवापसी:  \nstring: एक दिव्य ID जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और पहले शब्द के साथ जोड़कर बनाई जाती है।  \nउदाहरण:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "hu": "Létrehoz egy azonosítót két szó meghatározott módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első szó, amelyet az azonosítóban használunk.\n- word2 (string): A második szó, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amelyet a második szó minden második karakterének megfordításával és az első szóval való kombinálásával hozunk létre.\npélda:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\""
    },
    "docstring_bertscore": {
      "sq": "0.9981487648487548",
      "hy": "0.9711145740987635",
      "bn": "0.9400338852263294",
      "bg": "0.992450655108007",
      "zh": "0.9401411456320882",
      "fr": "0.9686074614293411",
      "de": "0.9710490260730219",
      "ha": "0.9716830542492854",
      "hi": "0.9544921906618589",
      "hu": "0.9300062290701641"
    }
  },
  {
    "task_id": "Go/18",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\nint: Numri total i skemave të ndryshme të permutimit.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել տարբեր փոխադրումների սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայնային տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայնային տողում։\n\nՎերադարձնում է:\nint: Տարբեր փոխադրումների սխեմաների ընդհանուր քանակը։\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফিরতি:\nint: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБрой на различните схеми за пермутация на двоична верига с дължина n,\nкъдето броят на '1'-ците е m и броят на '0'-лите е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната верига.\n- m (int): Брой на '1'-ците в двоичната верига.\n\nВръща:\nint: Общият брой на различните схеми за пермутация.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算长度为 n 的二进制字符串的不同排列方案的数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\nint: 不同排列方案的总数。\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nComptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nint : Le nombre total de différents schémas de permutation.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\nint: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige adadin tsarin permutation daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawowa:\nint: Jimillar adadin tsarin permutation daban-daban.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nएक बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें,\nजहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\nint: A különböző permutációs sémák összes száma.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9951681173509453",
      "hy": "0.9817677173248076",
      "bn": "0.9951681173509453",
      "bg": "0.9846536181308635",
      "zh": "0.9681839814569747",
      "fr": "0.9880416565401756",
      "de": "0.991061434223049",
      "ha": "0.9749942227011369",
      "hi": "0.9865642437660381",
      "hu": "0.9865910588674778"
    },
    "canonical_solution": "factorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}",
    "instruction": {
      "en": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nПредоставете кратко описание на Go кода на български език, като използвате най-много 500 знака.",
      "zh": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Go a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countPermutationsOfBinaryString(n, m int) int\nfactorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9243263933244714",
      "bn": "0.8773334246273324",
      "bg": "0.8412363254818621",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestCountPermutationsOfBinaryString(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, countPermutationsOfBinaryString(2, 0))\n\tassert.Equal(0, countPermutationsOfBinaryString(2, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 0))\n\tassert.Equal(3, countPermutationsOfBinaryString(3, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 2))\n\tassert.Equal(145422675, countPermutationsOfBinaryString(30, 2))\n\tassert.Equal(4, countPermutationsOfBinaryString(4, 2))\n\tassert.Equal(1, countPermutationsOfBinaryString(5, 5))\n\tassert.Equal(13884156, countPermutationsOfBinaryString(33, 17))\n\tassert.Equal(1, countPermutationsOfBinaryString(1000000, 1000000))\n\t// Add more test cases if necessary\n}",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "func countPermutationsOfBinaryString(n, m int) int",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\nint: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր փոխատեղման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): Երկբայական տողի '1'-երի քանակը։\n\nՎերադարձնում է:\nint: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\nint: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоичен низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n\nВръща:\nint: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\nint: 不同排列方案的总数。",
      "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nint : Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\nint: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙididdige adadin tsarin permutation daban-daban don igiyar binary mai tsawon n, inda adadin '1's shine m kuma adadin '0's shine n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawowa:\nint: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nरिटर्न्स:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\nint: A különböző permutációs sémák teljes száma."
    },
    "docstring_bertscore": {
      "sq": "0.9963775777410667",
      "hy": "0.9757369016958264",
      "bn": "0.9646994086824797",
      "bg": "1",
      "zh": "0.9608616710905046",
      "fr": "0.9850904063387592",
      "de": "0.9936114510547749",
      "ha": "0.9860321129752456",
      "hi": "0.9963775777410667",
      "hu": "0.9916450102825295"
    }
  },
  {
    "task_id": "Go/19",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nfunc answerQuestions() string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPërgjigjuni një serie pyetjesh duke ofruar zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke dhënë 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të pointerëve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten nga brenda trupit të tij.\nPyetja 5:\nCila deklaratë rreth pointerëve është e pasaktë?\n    A. Zbritja e dy pointerëve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i pointerit përfshin zgjidhjen bazuar në tipin e pointerit.\n    C. int *p[4], p është një varg i pointerëve int.\n    D. Emrat e funksioneve mund të caktohen te pointerët e funksioneve.\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n*/\nfunc answerQuestions() string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՊատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքներից մեկը:\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՏրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈր հայտարարությունը սխալ է արտահայտությունների ձախ արժեքների մասին?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահավաքման արտահայտությունները ձախ արժեքներ են:\n    D. Նախաբանի ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈր հայտարարությունը սխալ է ֆունկցիաների մասին?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\nՀարց 5:\nՈր հայտարարությունը սխալ է ցուցիչների մասին?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահավաքումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:\n*/\nfunc answerQuestions() string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nপ্রতিটি প্রশ্নের জন্য বিকল্প A, B, C, বা D প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন 2:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\nপ্রশ্ন 3:\nএক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশন টাইপটি রিটার্ন ভ্যালু টাইপের মতোই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করা তাদের ঠিকানা মানের পার্থক্যের সমান।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান জড়িত।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\nআপনার শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।\n*/\nfunc answerQuestions() string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\nВъпрос 3:\nКое твърдение за леви стойности в изрази е неправилно?\n    A. Изрази с имена на променливи са леви стойности.\n    B. Операцията на инкрементиране изисква операндът да е лява стойност.\n    C. Изрази с разименуване на указатели са леви стойности.\n    D. Изрази с префиксно инкрементиране са леви стойности.\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функция са локални променливи.\n    B. Локалните променливи се разпределят в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от своето тяло.\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n*/\nfunc answerQuestions() string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n通过为每个问题提供选择A、B、C或D来回答一系列问题。\n问题1：\n像1e6这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n问题2：\n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n问题3：\n关于表达式中的左值，哪种说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n问题4：\n关于函数，哪种说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n问题5：\n关于指针，哪种说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4]，p是一个int指针的数组。\n    D. 函数名可以赋给函数指针。\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。\n*/\nfunc answerQuestions() string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nRépondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même à l'intérieur de son corps.\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n*/\nfunc answerQuestions() string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keiner der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperator-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern ergibt die Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n*/\nfunc answerQuestions() string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\nTambaya ta 1:\nConstant kamar 1e6 yana cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanin sunan canji ƙimar hagu ne.\n    B. Aikin ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Bayanin cirewa mai nuna alama ƙimar hagu ne.\n    D. Bayanin aikin ƙara na farko ƙimar hagu ne.\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki canje-canje na gida ne.\n    B. Canje-canje na gida ana ware musu sarari a cikin faifai.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Cire masu nuna alama biyu ya yi daidai da bambancin a cikin ƙimar adireshinsu.\n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsari ne na masu nuna alama na int.\n    D. Ana iya ba da sunayen ayyuka ga masu nuna alama na aiki.\nAna tsammanin ka dawo da kirtani kamar \"AAAAA\", wanda ke tsaye ga zaɓuɓɓukan tambayar.\n*/\nfunc answerQuestions() string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\nप्रश्न 1:\n1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nप्रश्न 2:\nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेण्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\nप्रश्न 4:\nफंक्शन्स के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर मिलता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स का ऐरे है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n*/\nfunc answerQuestions() string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVálaszolj egy sor kérdésre úgy, hogy minden kérdéshez választási lehetőségeket adsz meg: A, B, C vagy D.\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n2. kérdés:\nAdott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának alapján történik.\n    C. int *p[4], p egy tömb int pointerekből.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választásait jelölik.\n*/\nfunc answerQuestions() string {"
    },
    "prompt_bertscore": {
      "sq": "0.919302832357718",
      "hy": "0.8914250583794715",
      "bn": "0.956104076203957",
      "bg": "0.9283419051074727",
      "zh": "0.9551550202433723",
      "fr": "0.9722302809490364",
      "de": "0.948486402460888",
      "ha": "0.9262471491090788",
      "hi": "0.9587768466111624",
      "hu": "0.9329066298940355"
    },
    "canonical_solution": "return \"DDDBA\"\n}",
    "instruction": {
      "en": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nՏվեք Go կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\n将以下 Go 代码的自然语言描述（文档字符串）翻译成中文，字数不超过500个字符。",
      "fr": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nBa da wata takaitacciyar bayanin yare na halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func answerQuestions() string\nreturn \"DDDBA\"\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9449734255419049",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8318029248925518",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9528896407476694",
      "hi": "0.91027269797511",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestAnswerQuestions(t *testing.T) {\n\texpectedAnswers := \"DDDBA\"\n\tactualAnswers := answerQuestions()\n\n\tassert.Equal(t, expectedAnswers, actualAnswers, \"they should be equal\")\n}",
    "entry_point": "answerQuestions",
    "signature": "func answerQuestions() string",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i rritjes kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të rritjes prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish të int.\n    D. Emrat e funksioneve mund të caktohen në tregues të funksioneve.\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.",
      "hy": "Պատասխանել մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր հայտարարությունն է սխալ ձախ արժեքների մասին արտահայտություններում:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր հայտարարությունն է սխալ ֆունկցիաների մասին:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են stack-ում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\nՀարց 5:\nՈ՞ր հայտարարությունն է սխալ ցուցիչների մասին:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\"-ն, որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "একটি সিরিজ প্রশ্নের উত্তর দিন প্রতিটি প্রশ্নের জন্য A, B, C, বা D পছন্দ প্রদান করে।\nপ্রশ্ন ১:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\nপ্রশ্ন ৩:\nএক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়ার কথা, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разреференция на указатели са леви стойности.\n    D. Изразите с префикс инкрементна операция са леви стойности.\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от тялото си.\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разреференцията на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.",
      "zh": "回答一系列问题，为每个问题提供选择 A、B、C 或 D。\n\n问题 1： 常量如 1e6 属于哪种数据类型？ \n    A. unsigned int \n    B. int \n    C. float \n    D. double \n\n问题 2： 给定 21! = 51,090,942,171,709,440,000，可以使用哪种数据类型存储此值？ \n    A. int \n    B. long long \n    C. double \n    D. 以上都不是 \n\n问题 3： 关于表达式中的左值，哪个说法不正确？ \n    A. 变量名表达式是左值。 \n    B. 自增操作要求操作数是左值。 \n    C. 指针解引用表达式是左值。 \n    D. 前缀自增操作表达式是左值。 \n\n问题 4： 关于函数，哪个说法不正确？ \n    A. 函数的形式参数是局部变量。 \n    B. 局部变量在栈中分配空间。 \n    C. 函数类型与返回值类型相同。 \n    D. 函数可以在其主体内调用自身。 \n\n问题 5： 关于指针，哪个说法不正确？ \n    A. 两个指针相减等于它们地址值的差。 \n    B. 指针解引用涉及基于指针类型的解析。 \n    C. int *p[4]，p 是一个 int 指针数组。 \n    D. 函数名可以赋值给函数指针。 \n\n你应该只返回类似 \"AAAAA\" 的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs de gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs de gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur de gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs de gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs de gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de fonction est le même que le type de valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keiner der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperator-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren zweier Zeiger entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\nDu sollst nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanin sunan canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Bayanin cirewa mai nuna alama ƙimar hagu ne.\n    D. Bayanin aiki na ƙaruwa na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Ƙayyadaddun sigogi na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin tari.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Rage masu nuna alama biyu yana daidai da bambanci a ƙimar adireshinsu.\n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsararraki ne na masu nuna alama int.\n    D. Ana iya sanya sunayen ayyuka ga masu nuna alama na aiki.\n\nAna tsammanin ku dawo da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।  \nप्रश्न 1:  \n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nप्रश्न 2:  \nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?  \n    A. int  \n    B. long long  \n    C. double  \n    D. उपरोक्त में से कोई नहीं  \nप्रश्न 3:  \nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?  \n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।  \n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।  \n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।  \n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।  \nप्रश्न 4:  \nकार्य के बारे में कौन सा कथन गलत है?  \n    A. किसी कार्य के औपचारिक पैरामीटर स्थानीय चर होते हैं।  \n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।  \n    C. कार्य प्रकार वही होता है जो वापसी मूल्य प्रकार होता है।  \n    D. एक कार्य अपने शरीर के भीतर से स्वयं को बुला सकता है।  \nप्रश्न 5:  \nपॉइंटर्स के बारे में कौन सा कथन गलत है?  \n    A. दो पॉइंटर्स को घटाने का अर्थ उनके पते के मूल्यों में अंतर होता है।  \n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।  \n    C. int *p[4], p एक int पॉइंटर्स का सरणी है।  \n    D. कार्य नामों को कार्य पॉइंटर्स को सौंपा जा सकता है।  \nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszoljon egy sor kérdésre azáltal, hogy választ ad A, B, C vagy D formájában minden kérdésre.\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nKérdés 2:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\nKérdés 3:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\nKérdés 4:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\nKérdés 5:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának alapján történő feloldást jelenti.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\nCsak olyan karakterláncokat kell visszaadnia, mint például \"AAAAA\", amelyek a kérdések válaszait jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.953013387475054",
      "hy": "0.9455019809858387",
      "bn": "0.9394234940654091",
      "bg": "0.9493168760839948",
      "zh": "0.9396074257982474",
      "fr": "0.9767807043481647",
      "de": "0.9441892327975792",
      "ha": "0.9058076856398267",
      "hi": "0.9401210839636036",
      "hu": "0.9317180256939227"
    }
  },
  {
    "task_id": "Go/20",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square përcakton nëse është e mundur të montohet katrorët prej druri nga n kovë,\nku secila kova përmban një numër specifik të katrorëve me gjatësi anësore 1, në një katror më të madh.\nFunksioni merr gjatësinë e listës dhe një varg numrash si hyrje.\n\nShembuj përdorimi:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square որոշում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\nորտեղ յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ քառակուսիներ՝ կողքի երկարությունը 1, մեկ մեծ քառակուսի մեջ:\nՖունկցիան ընդունում է ցուցակի երկարությունը և թվերի զանգվածը որպես մուտքագրումներ:\n\nՕգտագործման օրինակներ:\n    IsSquare(1, []int{9})             // Արդյունք: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square নির্ধারণ করে যে এটি n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা,\nযেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের নির্দিষ্ট সংখ্যক বর্গক্ষেত্র রয়েছে, একটি একক বড় বর্গক্ষেত্রে।\nফাংশনটি তালিকার দৈর্ঘ্য এবং সংখ্যার একটি অ্যারে ইনপুট হিসাবে নেয়।\n\nব্যবহারের উদাহরণ:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square определя дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа определен брой квадрати със страна 1, в един по-голям квадрат.\nФункцията приема дължината на списъка и масив от числа като входни данни.\n\nПримери за употреба:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square 确定是否可以从 n 个桶中组装木制正方形，\n其中每个桶包含一定数量的边长为 1 的正方形，组合成一个更大的正方形。\n该函数接受列表的长度和一个数字数组作为输入。\n\n使用示例:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square détermine s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient un nombre spécifique de carrés avec une longueur de côté de 1, en un seul carré plus grand.\nLa fonction prend la longueur de la liste et un tableau de nombres comme entrées.\n\nExemples d'utilisation :\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern,\nwobei jeder Eimer eine bestimmte Anzahl von Quadraten mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nDie Funktion nimmt die Länge der Liste und ein Array von Zahlen als Eingaben.\n\nVerwendungsbeispiele:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square yana tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowanne guga yana dauke da adadin murabba'ai tare da tsawon gefe na 1, zuwa wani babba murabba'i guda daya.\nAikin yana daukar tsawon jerin da kuma jerin lambobi a matsayin shigarwa.\n\nMisalan amfani:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में 1 की साइड लंबाई वाले वर्गों की एक विशिष्ट संख्या होती है, एक बड़े वर्ग में।\nयह फ़ंक्शन सूची की लंबाई और संख्याओं की एक श्रृंखला को इनपुट के रूप में लेता है।\n\nउपयोग के उदाहरण:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square meghatározza, hogy lehetséges-e az n vödörből származó fa négyzeteket,\nahol minden vödör egy adott számú, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté összeállítani.\nA függvény a lista hosszát és egy számokból álló tömböt vesz bemenetként.\n\nHasználati példák:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {"
    },
    "prompt_bertscore": {
      "sq": "0.9821562383501119",
      "hy": "0.9747421607476037",
      "bn": "0.9771350609479309",
      "bg": "0.9716246569172611",
      "zh": "0.9672907406334609",
      "fr": "0.9956720426276309",
      "de": "0.9955995425385531",
      "ha": "0.9613598360861401",
      "hi": "0.9734701317874562",
      "hu": "0.9790170838082365"
    },
    "canonical_solution": "sum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}",
    "instruction": {
      "en": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nՏվեք Go կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки максимум 500 символа.",
      "zh": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\n将以下 Go 代码的功能使用中文进行简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Go cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func IsSquare(length int, squares []int) bool\nsum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9112044730925446",
      "bn": "0.8784854808373347",
      "bg": "0.8412363254818621",
      "zh": "0.8394051054659001",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.8980082650981108",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestIsSquare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(IsSquare(1, []int{9}))\n\tassert.True(IsSquare(2, []int{14, 2}))\n\tassert.False(IsSquare(2, []int{7, 7}))\n\tassert.False(IsSquare(7, []int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.True(IsSquare(6, []int{1, 3, 5, 7, 9, 11}))\n\tassert.False(IsSquare(4, []int{2, 2, 2, 2}))\n\n\t// Additional test cases\n\tassert.False(IsSquare(3, []int{4, 5, 6}))\n\tassert.False(IsSquare(4, []int{16, 9, 4, 1}))\n\tassert.False(IsSquare(5, []int{1, 1, 1, 1, 1}))\n\tassert.False(IsSquare(2, []int{25, 25}))\n\tassert.True(IsSquare(3, []int{10, 10, 5}))\n}",
    "entry_point": "IsSquare",
    "signature": "func IsSquare(length int, squares []int) bool",
    "docstring": {
      "en": "Is_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n",
      "sq": "Is_Square përcakton nëse është e mundur të montohet katrorë druri nga n kovë,\nku secila kovë përmban një numër specifik katrorësh me një gjatësi anësore prej 1, në një katror më të madh.\nFunksioni merr gjatësinë e listës dhe një varg numrash si hyrje.\n\nShembuj përdorimi:\n    IsSquare(1, []int{9})             // Dalje: true",
      "hy": "Is_Square-ը որոշում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիներ n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ 1 կողմի երկարությամբ քառակուսիներ, մեկ մեծ քառակուսի մեջ: Ֆունկցիան ընդունում է ցուցակի երկարությունը և թվերի զանգվածը որպես մուտքեր:\n\nՕգտագործման օրինակներ:\n    IsSquare(1, []int{9})             // Արդյունք: true",
      "bn": "Is_Square নির্ধারণ করে যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের নির্দিষ্ট সংখ্যক বর্গক্ষেত্র রয়েছে, একটি একক বৃহত্তর বর্গক্ষেত্রে। ফাংশনটি তালিকার দৈর্ঘ্য এবং সংখ্যার একটি অ্যারে ইনপুট হিসাবে গ্রহণ করে।\n\nব্যবহারের উদাহরণ:\n    IsSquare(1, []int{9})             // আউটপুট: true",
      "bg": "Is_Square определя дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа определен брой квадрати с дължина на страната 1, в един по-голям квадрат. Функцията приема дължината на списъка и масив от числа като входни данни.\n\nПримери за използване:\n    IsSquare(1, []int{9})             // Изход: true",
      "zh": "Is_Square 确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含特定数量的边长为 1 的正方形，组装成一个更大的正方形。该函数接受列表的长度和一个数字数组作为输入。\n\n用法示例：\n    IsSquare(1, []int{9})             // 输出: true",
      "fr": "Is_Square détermine s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient un nombre spécifique de carrés avec une longueur de côté de 1, en un seul carré plus grand.\nLa fonction prend la longueur de la liste et un tableau de nombres comme entrées.\n\nExemples d'utilisation :\n    IsSquare(1, []int{9})             // Sortie : true",
      "de": "Is_Square bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer eine bestimmte Anzahl von Quadraten mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen. Die Funktion nimmt die Länge der Liste und ein Array von Zahlen als Eingaben.\n\nVerwendungsbeispiele:\n    IsSquare(1, []int{9})             // Ausgabe: true",
      "ha": "Is_Square yana tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowanne guga yana dauke da adadin murabba'ai tare da tsawon gefe 1, zuwa babban murabba'i guda.\nAikin yana daukar tsawon jerin da kuma jerin lambobi a matsayin shigarwa.\n\nMisalan amfani:\n    IsSquare(1, []int{9})             // Fitarwa: true",
      "hi": "Is_Square यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है, \nजहां प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्गों की एक विशिष्ट संख्या होती है, एक बड़े वर्ग में इकट्ठा करना संभव है। \nयह फ़ंक्शन सूची की लंबाई और संख्याओं की एक सरणी को इनपुट के रूप में लेता है।\n\nउदाहरण उपयोग:\n    IsSquare(1, []int{9})             // आउटपुट: true",
      "hu": "Is_Square meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani, ahol minden vödör egy adott számú, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté. A függvény a lista hosszát és egy szám tömböt vesz bemenetként.\n\nHasználati példák:\n    IsSquare(1, []int{9})             // Kimenet: true"
    },
    "docstring_bertscore": {
      "sq": "0.9826609581483216",
      "hy": "0.9618933572895998",
      "bn": "0.9785300421139389",
      "bg": "0.973838988405038",
      "zh": "0.9563370696409109",
      "fr": "0.9933355534555174",
      "de": "0.9921356273236857",
      "ha": "0.9359307774452916",
      "hi": "0.9645442783548914",
      "hu": "0.9497769040464716"
    }
  },
  {
    "task_id": "Go/21",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven integers c and d, where a + b = c and a * b = d, find\nand return the possible value of a where a <= b. If there are\nmultiple groups, output the group with the smallest a. If no\nvalid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur parasysh numrat c dhe d, ku a + b = c dhe a * b = d, gjej\ndhe kthe vlerën e mundshme të a ku a <= b. Nëse ka\ngrupe të shumta, jepni grupin me a më të vogël. Nëse nuk\nekziston një çift i vlefshëm, kthe -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a, ose -1 nëse nuk ekzistojnë çifte të vlefshme.\n\nShembuj:\n    findIntegers(7,11) // kthen -1\n*/\nfunc findIntegers(c int, d int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել\nև վերադարձնել a-ի հնարավոր արժեքը, որտեղ a <= b: Եթե կան\nմի քանի խումբ, արտածել խումբը ամենափոքր a-ով: Եթե ոչ մի\nվավեր զույգ չկա, վերադարձնել -1:\n\nՊարամետրեր:\n- c (int): a-ի և b-ի գումարը:\n- d (int): a-ի և b-ի արտադրյալը:\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը, կամ -1, եթե վավեր զույգեր չկան:\n\nՕրինակներ:\n    findIntegers(7,11) // վերադարձնում է -1\n*/\nfunc findIntegers(c int, d int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, খুঁজে বের করুন\nএবং a এর সম্ভাব্য মান ফেরত দিন যেখানে a <= b। যদি একাধিক গোষ্ঠী থাকে,\nতাহলে সবচেয়ে ছোট a সহ গোষ্ঠীটি আউটপুট করুন। যদি কোন বৈধ জোড়া না থাকে,\nতাহলে -1 ফেরত দিন।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত:\n- int: a এর একটি সম্ভাব্য মান, অথবা যদি কোন বৈধ জোড়া না থাকে তাহলে -1।\n\nউদাহরণ:\n    findIntegers(7,11) // -1 ফেরত দেয়\n*/\nfunc findIntegers(c int, d int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете\nи върнете възможната стойност на a, където a <= b. Ако има\nняколко групи, изведете групата с най-малката a. Ако не съществува\nвалидна двойка, върнете -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a, или -1 ако не съществуват валидни двойки.\n\nПримери:\n    findIntegers(7,11) // връща -1\n*/\nfunc findIntegers(c int, d int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值，其中 a <= b。\n如果有多个组合，输出 a 最小的组合。如果不存在有效组合，返回 -1。\n\n参数：\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回：\n- int: a 的可能值，或者如果不存在有效组合则返回 -1。\n\n示例:\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver\net retourner la valeur possible de a où a <= b. S'il y a\nplusieurs groupes, afficher le groupe avec le plus petit a. Si aucun\ncouple valide n'existe, retourner -1.\n\nParamètres :\n- c (int) : La somme de a et b.\n- d (int) : Le produit de a et b.\n\nRenvoie :\n- int : Une valeur possible de a, ou -1 si aucun couple valide n'existe.\n\nExemples :\n    findIntegers(7,11) // retourne -1\n*/\nfunc findIntegers(c int, d int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d ist. Finde\nund gib den möglichen Wert von a zurück, wobei a <= b. Wenn es\nmehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus. Wenn kein\ngültiges Paar existiert, gib -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewerte:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Paare existieren.\n\nBeispiele:\n    findIntegers(7,11) // gibt -1 zurück\n*/\nfunc findIntegers(c int, d int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo\nkuma dawo da yiwuwar ƙimar a inda a <= b. Idan akwai\nkungiyoyi da yawa, fitar da ƙungiyar da ke da ƙaramin a. Idan babu\nwata madaidaiciyar ma'aurata, dawo da -1.\n\nSigogi:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nDawowa:\n- int: Yiwuwar ƙimar a, ko -1 idan babu ma'aurata masu inganci.\n\nMisalai:\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, का पता लगाएँ\nऔर a का संभावित मान लौटाएँ जहाँ a <= b। यदि कई समूह हैं,\nतो सबसे छोटे a वाले समूह को आउटपुट करें। यदि कोई मान्य जोड़ी मौजूद नहीं है,\nतो -1 लौटाएँ।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का संभावित मान, या -1 यदि कोई मान्य जोड़ी मौजूद नहीं है।\n\nउदाहरण:\n    findIntegers(7,11) // -1 लौटाता है\n*/\nfunc findIntegers(c int, d int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott két egész szám, c és d, ahol a + b = c és a * b = d, találd meg\nés add vissza a lehetséges a értékét, ahol a <= b. Ha több csoport is van,\nadd vissza azt a csoportot, amelyikben a legkisebb a. Ha nem létezik\nérvényes pár, térj vissza -1 értékkel.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatér:\n- int: a lehetséges a értéke, vagy -1, ha nem létezik érvényes pár.\n\nPéldák:\n    findIntegers(7,11) // visszaadja -1\n*/\nfunc findIntegers(c int, d int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9762567174029947",
      "hy": "0.9867890933573696",
      "bn": "0.9896193776567357",
      "bg": "0.9881451429686948",
      "zh": "0.9723772674310023",
      "fr": "0.9917655789238177",
      "de": "0.9739716734995693",
      "ha": "0.9837818293885013",
      "hi": "0.973901556975064",
      "hu": "0.9714474786173779"
    },
    "canonical_solution": "for i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\n请提供一段中文的简洁自然语言描述（文档字符串），用于描述该 Go 代码，字数不超过500个字符。",
      "fr": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func findIntegers(c int, d int) int\nfor i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8837444188056144",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8904362763426799",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.8390148433003679",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestFindIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, findIntegers(5, 6))\n\tassert.Equal(3, findIntegers(6, 9))\n\tassert.Equal(3, findIntegers(7, 12))\n\tassert.Equal(-1, findIntegers(7, 11))\n\tassert.Equal(1, findIntegers(9, 8))\n\tassert.Equal(5, findIntegers(10, 25))\n\tassert.Equal(-1, findIntegers(10000, 8765))\n}",
    "entry_point": "findIntegers",
    "signature": "func findIntegers(c int, d int) int",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a where a <= b. If there are multiple groups, output the group with the smallest a. If no valid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a ku a <= b. Nëse ka disa grupe, jepni grupin me a më të vogël. Nëse nuk ekziston asnjë çift i vlefshëm, kthe -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a, ose -1 nëse nuk ekzistojnë çifte të vlefshme.\n\nShembuj:\n    findIntegers(7,11) // kthen -1",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը, որտեղ a <= b: Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է: Եթե վավեր զույգ չի գոյություն ունենում, վերադարձնել -1:\n\nՊարամետրեր:\n- c (int): a-ի և b-ի գումարը:\n- d (int): a-ի և b-ի արտադրյալը:\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը, կամ -1, եթե վավեր զույգեր չկան:\n\nՕրինակներ:\n    findIntegers(7,11) // վերադարձնում է -1",
      "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন যেখানে a <= b। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন। যদি কোনো বৈধ জোড়া না থাকে, তাহলে -1 ফেরত দিন।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n- int: a এর একটি সম্ভাব্য মান, অথবা যদি কোনো বৈধ জোড়া না থাকে তবে -1।\n\nউদাহরণ:\n    findIntegers(7,11) // -1 ফেরত দেয়",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a, където a <= b. Ако има множество групи, изведете групата с най-малката a. Ако не съществува валидна двойка, върнете -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a, или -1 ако не съществуват валидни двойки.\n\nПримери:\n    findIntegers(7,11) // връща -1",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值，其中 a <= b。如果有多个组合，输出 a 最小的组合。如果不存在有效的组合，返回 -1。\n\n参数:\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回:\n- int: a 的可能值，如果不存在有效组合则返回 -1。\n\n示例:\n    findIntegers(7,11) // 返回 -1",
      "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, trouvez et renvoyez la valeur possible de a où a <= b. S'il y a plusieurs groupes, affichez le groupe avec le plus petit a. Si aucun couple valide n'existe, renvoyez -1.\n\nParamètres:\n- c (int): La somme de a et b.\n- d (int): Le produit de a et b.\n\nRenvoie:\n- int: Une valeur possible de a, ou -1 si aucun couple valide n'existe.\n\nExemples:\n    findIntegers(7,11) // renvoie -1",
      "de": "Gegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den möglichen Wert von a zurück, wobei a <= b. Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus. Wenn kein gültiges Paar existiert, gib -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Paare existieren.\n\nBeispiele:\n    findIntegers(7,11) // gibt -1 zurück",
      "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a inda a <= b. Idan akwai rukuni da yawa, fitar da rukunin da ke da ƙaramin a. Idan babu ma'aurata masu inganci, dawo da -1.\n\nParameters:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nReturns:\n- int: Yiwuwar ƙimar a, ko -1 idan babu ma'aurata masu inganci.\n\nExamples:\n    findIntegers(7,11) // returns -1",
      "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ जहाँ a <= b। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें। यदि कोई वैध जोड़ी मौजूद नहीं है, तो -1 लौटाएँ।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान, या -1 यदि कोई वैध जोड़ी मौजूद नहीं है।\n\nउदाहरण:\n    findIntegers(7,11) // -1 लौटाता है",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értékét, ahol a <= b. Ha több csoport létezik, adja meg a legkisebb a értékű csoportot. Ha nem létezik érvényes pár, adjon vissza -1-et.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\n- int: a lehetséges a értéke, vagy -1, ha nem létezik érvényes pár.\n\nPéldák:\n    findIntegers(7,11) // visszaadja -1"
    },
    "docstring_bertscore": {
      "sq": "0.9673253023197609",
      "hy": "0.9714655539820521",
      "bn": "0.9902843921724405",
      "bg": "0.9933766699443917",
      "zh": "0.9634573729098685",
      "fr": "0.9846931455766894",
      "de": "0.9888633904265169",
      "ha": "0.9791676456370609",
      "hi": "0.9789219398557207",
      "hu": "0.9730867751520589"
    }
  },
  {
    "task_id": "Go/22",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur tre shifra a, b, c ku dy janë identike dhe i treti është i ndryshëm,\ngjeni vlerën unike.\n\nShembuj:\n    extraNumber(0, 0, 1) duhet të kthejë 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԵրեք թվանշան a, b, c ունենալով, որտեղ երկուսը նույնական են և երրորդը տարբեր է,\nգտնել եզակի արժեքը։\n\nՕրինակներ:\n    extraNumber(0, 0, 1) պետք է վերադարձնի 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতিনটি সংখ্যা a, b, c দেওয়া আছে যেখানে দুটি সংখ্যা অভিন্ন এবং তৃতীয়টি ভিন্ন,\nঅনন্য মানটি খুঁজে বের করুন।\n\nউদাহরণ:\n    extraNumber(0, 0, 1) 1 রিটার্ন করা উচিত\n*/\nfunc extraNumber(a, b, c int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са три цифри a, b, c, където две са идентични и третата е различна,\nнамерете уникалната стойност.\n\nПримери:\n    extraNumber(0, 0, 1) трябва да върне 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定三个数字 a, b, c，其中两个是相同的，第三个是不同的，\n找出唯一的值。\n\n例子:\n    extraNumber(0, 0, 1) 应该返回 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné trois chiffres a, b, c où deux sont identiques et le troisième est différent,\ntrouvez la valeur unique.\n\nExemples :\n    extraNumber(0, 0, 1) devrait retourner 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind drei Ziffern a, b, c, wobei zwei identisch sind und die dritte unterschiedlich ist,\nfinde den einzigartigen Wert.\n\nBeispiele:\n    extraNumber(0, 0, 1) sollte 1 zurückgeben\n*/\nfunc extraNumber(a, b, c int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da lambobi uku a, b, c inda biyu suna daidai kuma na uku ya bambanta,\nnemo ƙimar da ta bambanta.\n\nMisalai:\n    extraNumber(0, 0, 1) ya kamata ya dawo da 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nतीन अंक a, b, c दिए गए हैं जहाँ दो समान हैं और तीसरा अलग है,\nअद्वितीय मान खोजें।\n\nउदाहरण:\n    extraNumber(0, 0, 1) को 1 लौटाना चाहिए\n*/\nfunc extraNumber(a, b, c int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott három számjegy a, b, c, ahol kettő azonos és a harmadik különbözik,\ntaláld meg az egyedi értéket.\n\nPéldák:\n    extraNumber(0, 0, 1) esetén az eredmény 1\n*/\nfunc extraNumber(a, b, c int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9910091944328369",
      "hy": "0.9877510602927215",
      "bn": "0.9707463133723248",
      "bg": "0.997779908231173",
      "zh": "0.9837158841019978",
      "fr": "0.9925058743539347",
      "de": "0.997779908231173",
      "ha": "0.9679261592223914",
      "hi": "0.9698731342172954",
      "hu": "0.9654136835326811"
    },
    "canonical_solution": "if a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}",
    "instruction": {
      "en": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nՏվյալ Go կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func extraNumber(a, b, c int) int\nif a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.891040509961788",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9364712507120876",
      "ha": "0.935334886302187",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestExtraNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7, extraNumber(2, 7, 2), \"Extra number should be 7\")\n\tassert.Equal(3, extraNumber(3, 2, 2), \"Extra number should be 3\")\n\tassert.Equal(1, extraNumber(5, 5, 1), \"Extra number should be 1\")\n\tassert.Equal(3, extraNumber(500000000, 3, 500000000), \"Extra number should be 3\")\n\tassert.Equal(3, extraNumber(500000000, 500000000, 3), \"Extra number should be 3\")\n}",
    "entry_point": "extraNumber",
    "signature": "func extraNumber(a, b, c int) int",
    "docstring": {
      "en": "Given three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n",
      "sq": "Duke pasur tre shifra a, b, c ku dy janë identike dhe e treta është e ndryshme, gjeni vlerën unike.\n\nShembuj:\n    extraNumber(0, 0, 1) duhet të kthejë 1",
      "hy": "Երեք թվանշանների՝ a, b, c դեպքում, որտեղ երկուսը նույնական են և երրորդը տարբեր է, գտնել եզակի արժեքը։\n\nՕրինակներ:\n    extraNumber(0, 0, 1) պետք է վերադարձնի 1",
      "bn": "তিনটি সংখ্যা a, b, c দেওয়া আছে যেখানে দুটি সংখ্যা অভিন্ন এবং তৃতীয়টি ভিন্ন,  \nঅনন্য মানটি খুঁজে বের করুন।\n\nউদাহরণ:\n    extraNumber(0, 0, 1) 1 ফেরত দেওয়া উচিত",
      "bg": "Дадени са три цифри a, b, c, където две са идентични и третата е различна, намерете уникалната стойност.\n\nПримери:\n    extraNumber(0, 0, 1) трябва да върне 1",
      "zh": "给定三个数字 a, b, c，其中两个是相同的，第三个是不同的，找出唯一的值。\n\n示例：\n    extraNumber(0, 0, 1) 应返回 1",
      "fr": "Étant donné trois chiffres a, b, c où deux sont identiques et le troisième est différent, trouvez la valeur unique.\n\nExemples :\n    extraNumber(0, 0, 1) devrait retourner 1",
      "de": "Gegeben drei Ziffern a, b, c, wobei zwei identisch sind und die dritte unterschiedlich ist, finde den einzigartigen Wert.\n\nBeispiele:\n    extraNumber(0, 0, 1) sollte 1 zurückgeben",
      "ha": "An ba da lambobi uku a, b, c inda biyu suna daidai kuma na uku ya bambanta, gano ƙimar da ta bambanta.\n\nMisalai:\n    extraNumber(0, 0, 1) ya kamata ya dawo da 1",
      "hi": "तीन अंकों a, b, c को दिया गया है जहाँ दो समान हैं और तीसरा भिन्न है, अद्वितीय मान खोजें।\n\nउदाहरण:\n    extraNumber(0, 0, 1) को 1 लौटाना चाहिए",
      "hu": "Három számjegy, a, b, c adott, ahol kettő azonos, és a harmadik különbözik, találja meg az egyedi értéket.\n\nPéldák:\n    extraNumber(0, 0, 1) vissza kell adnia 1"
    },
    "docstring_bertscore": {
      "sq": "0.9996440543571855",
      "hy": "0.9434433757167932",
      "bn": "0.9329392052765252",
      "bg": "0.9953303983722508",
      "zh": "0.9677491795528893",
      "fr": "0.9845272892085253",
      "de": "0.9953303983722508",
      "ha": "0.9493923556287881",
      "hi": "0.9886810477367269",
      "hu": "0.9517238790413756"
    }
  },
  {
    "task_id": "Go/23",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "sq": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges: Një listë e plotë me numra që përfaqëson gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "hy": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողեր տրված կողերի հավաքածուից:\n\nՓաստարկներ:\n- edges: Թվերի շերտ, որը ներկայացնում է կողերի երկարությունները:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "bn": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে গঠিত তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges: প্রান্তগুলির দৈর্ঘ্যগুলি উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "bg": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges: Срез от цели числа, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "zh": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数:\n- edges: 一个整数切片，表示边的长度。\n\n返回:\nint: 可以形成的不同锐角三角形的数量。\n\n示例:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "fr": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArguments:\n- edges: Une tranche d'entiers représentant les longueurs des côtés.\n\nRenvoie:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "de": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nArgumente:\n- edges: Ein Slice von ganzen Zahlen, das die Längen der Kanten darstellt.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "ha": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘirga adadin kusurwoyin tsirara waɗanda za a iya ƙirƙira ta hanyar zaɓar kowane gefuna 3 daga cikin saitin gefuna da aka bayar.\n\nHujojji:\n- edges: Wani yanki na lambobi masu wakiltar tsawon gefuna.\n\nDawowa:\nint: Adadin kusurwoyin tsirara daban-daban waɗanda za a iya ƙirƙira.\n\nMisalai:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "hi": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nतीव्र कोण वाले त्रिभुजों की संख्या गिनें जो किनारों के दिए गए सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nतर्क:\n- edges: किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: विशिष्ट तीव्र कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "hu": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n\nArgumentumok:\n- edges: Egész számokat tartalmazó szelet, amely az élek hosszát jelöli.\n\nVisszatér:\nint: A különböző hegyesszögű háromszögek száma, amelyek képezhetők.\n\nPéldák:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9654907521205227",
      "hy": "0.9496865272231008",
      "bn": "0.9921171546982495",
      "bg": "0.9723021851469711",
      "zh": "0.9593850528378912",
      "fr": "0.9634976948772186",
      "de": "0.9871474225647565",
      "ha": "0.955221561421019",
      "hi": "0.9891559729777814",
      "hu": "0.9823064029181743"
    },
    "canonical_solution": "sort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}",
    "instruction": {
      "en": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nՏրամադրեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\n请用中文为以下 Go 代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func countAcuteTriangles(edges []int) int\nsort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9099479373021179",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8733431389027225",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9219535547926286",
      "hi": "0.91027269797511",
      "hu": "0.9317637106815607"
    },
    "level": "",
    "test": "func TestCountAcuteTriangles(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, countAcuteTriangles([]int{1, 1, 1, 1}))\n\tassert.Equal(0, countAcuteTriangles([]int{1, 2, 3}))\n\t// Additional tests to ensure correctness\n\tassert.Equal(0, countAcuteTriangles([]int{3, 4, 5, 7, 10}))\n\tassert.Equal(4, countAcuteTriangles([]int{6, 8, 10, 5, 5, 5}))\n}",
    "entry_point": "countAcuteTriangles",
    "signature": "func countAcuteTriangles(edges []int) int",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n",
      "sq": "Numëroni numrin e trekëndëshave këndakut që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges: Një segment i numrave të plotë që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm këndakut që mund të formohen.\n\nShembuj:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hy": "Սուր անկյուն ունեցող եռանկյունիների քանակը հաշվել, որոնք կարելի է կազմել՝ ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n\nԱրձանագրություններ:\n- edges: Թվերի զանգված, որը ներկայացնում է կողերի երկարությունները:\n\nՎերադարձնում է:\nint: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարելի է կազմել:\n\nՕրինակներ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "bn": "তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে গঠন করা যেতে পারে।\n\nআর্গুমেন্টসমূহ:\n- edges: প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: ভিন্ন তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা যা গঠন করা যেতে পারে।\n\nউদাহরণ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges: Списък от цели числа, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges: 一个整数切片，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quelles 3 arêtes parmi un ensemble donné d'arêtes.\n\nArguments:\n- edges: Une tranche d'entiers représentant les longueurs des arêtes.\n\nRenvoie:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nArgumente:\n- edges: Ein Slice von Ganzzahlen, das die Längen der Kanten darstellt.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "ha": "Ƙirga yawan kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane gefuna 3 daga cikin wani saitin gefuna da aka bayar.\n\nHuɗa:\n- edges: Wani yanki na lambobi masu wakiltar tsawon gefuna.\n\nDawowa:\nint: Yawan kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो किनारों के दिए गए सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nतर्क:\n- edges: किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\nवापसी:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n\nArgumentumok:\n- edges: Egész számok szelete, amely az élek hosszát reprezentálja.\n\nVisszatér:\nint: Azoknak a különböző hegyesszögű háromszögeknek a száma, amelyek kialakíthatók.\n\nPéldák:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9464780506782442",
      "hy": "0.9358842979361295",
      "bn": "0.9889801850905654",
      "bg": "0.9648573198354025",
      "zh": "0.9405872694678925",
      "fr": "0.9648573198354025",
      "de": "0.9608759724779391",
      "ha": "0.9594259706963845",
      "hi": "0.9839196788729396",
      "hu": "0.9596307586192314"
    }
  },
  {
    "task_id": "Go/24",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "sq": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar lexon një numër të plotë dhe një karakter, pastaj i kthen ato\nsi një varg i formatuar i ndarë me presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (rune): Karakteri i dhënë si hyrje.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin të ndarë me presje.\n\nShembuj:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "hy": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք\nորպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (rune): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակներ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "bn": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি ফরম্যাট করা স্ট্রিং হিসেবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (rune): ইনপুট অক্ষর।\nফেরত দেয়:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "bg": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar чете цяло число и символ, след което ги връща\nкато форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (rune): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПримери:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "zh": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar 读取一个整数和一个字符，然后将它们作为格式化字符串返回，中间用逗号分隔。\n参数:\n- integer_value (int): 输入的整数。\n- char_value (rune): 输入的字符。\n返回:\n- string: 包含整数和字符的字符串，中间用逗号分隔。\n\n例子:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "fr": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar lit un entier et un caractère, puis les renvoie\nsous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (rune) : Le caractère d'entrée.\nRenvoie :\n- string : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemples :\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "de": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar liest eine Ganzzahl und ein Zeichen und gibt sie dann\nals formatierter String, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (rune): Das Eingabe-Zeichen.\nRückgabewerte:\n- string: Ein String, der die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n\nBeispiele:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "ha": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar yana karanta lamba da harafi, sannan yana mayar da su\na matsayin jeren rubutu da aka raba da alamar kwalliya.\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (rune): Harafin shigarwa.\nAbubuwan da ake mayarwa:\n- string: Jeren rubutu da ke dauke da lambar da harafin da aka raba da alamar kwalliya.\n\nMisalai:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "hi": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (rune): इनपुट वर्ण।\nवापसी:\n- string: एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम से अलग करके रखती है।\n\nउदाहरण:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "hu": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar beolvas egy egész számot és egy karaktert, majd visszaadja őket\negy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (rune): A bemeneti karakter.\nVisszatér:\n- string: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza vesszővel elválasztva.\n\nPéldák:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Kimenet: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {"
    },
    "prompt_bertscore": {
      "sq": "0.979885893094883",
      "hy": "0.9940257940296137",
      "bn": "0.9882551841997881",
      "bg": "0.98712120335446",
      "zh": "0.992962724230315",
      "fr": "0.9958512072313243",
      "de": "0.9840120420001208",
      "ha": "0.9837345553578151",
      "hi": "0.9808720929367213",
      "hu": "0.9911913384922458"
    },
    "canonical_solution": "return fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}",
    "instruction": {
      "en": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 символа.",
      "zh": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func processIntegerAndChar(integerValue int, charValue rune) string\nreturn fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9243263933244714",
      "bn": "0.8840058163870563",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.904317560521303",
      "hu": "0.9308857643973865"
    },
    "level": "",
    "test": "func TestProcessIntegerAndChar(t *testing.T) {\n\tassert := assert.New(t)\n\n\t// Test 1\n\toutput1 := processIntegerAndChar(234, 'H')\n\tassert.Equal(\"234,H\", output1)\n\n\t// Additional tests can be added here with different input values\n\t// Test 2\n\toutput2 := processIntegerAndChar(123, 'A')\n\tassert.Equal(\"123,A\", output2)\n\n\t// Test 3\n\toutput3 := processIntegerAndChar(0, 'Z')\n\tassert.Equal(\"0,Z\", output3)\n}",
    "entry_point": "processIntegerAndChar",
    "signature": "func processIntegerAndChar(integerValue int, charValue rune) string",
    "docstring": {
      "en": "processIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n",
      "sq": "processIntegerAndChar lexon një numër të plotë dhe një karakter, pastaj i kthen ato\nsi një varg i formatuar i ndarë me presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (rune): Karakteri i dhënë si hyrje.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembuj:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hy": "processIntegerAndChar-ը կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, բաժանված ստորակետով։  \nՊարամետրեր:  \n- integer_value (int): Մուտքային ամբողջ թիվը։  \n- char_value (rune): Մուտքային սիմվոլը։  \nՎերադարձնում է:  \n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։  \n\nՕրինակներ:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // Արդյունք: \"234,H\"",
      "bn": "processIntegerAndChar একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি ফরম্যাট করা স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়। \nParameters:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (rune): ইনপুট অক্ষর।\nReturns:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "bg": "processIntegerAndChar чете цяло число и символ, след което ги връща\nкато форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (rune): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПримери:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "zh": "processIntegerAndChar 读取一个整数和一个字符，然后将它们作为以逗号分隔的格式化字符串返回。\n参数:\n- integer_value (int): 输入的整数。\n- char_value (rune): 输入的字符。\n返回:\n- string: 包含整数和字符并以逗号分隔的字符串。\n\n示例:\n    fmt.Println(processIntegerAndChar(234, 'H')) // 输出: \"234,H\"",
      "fr": "processIntegerAndChar lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres:\n- integer_value (int): L'entier d'entrée.\n- char_value (rune): Le caractère d'entrée.\nRenvoie:\n- string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "de": "processIntegerAndChar liest eine Ganzzahl und ein Zeichen und gibt sie dann als formatierten String, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (rune): Das Eingabezeichen.\nRückgabewerte:\n- string: Ein String, der die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\n\nBeispiele:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ausgabe: \"234,H\"",
      "ha": "processIntegerAndChar yana karanta lamba da kuma harafi, sannan yana mayar da su\na matsayin kirtani mai tsari da aka raba ta alamar kwalliya.\nParameters:\n- integer_value (int): Lambar shigarwa.\n- char_value (rune): Harafin shigarwa.\nReturns:\n- string: Kirtani mai dauke da lamba da harafi da aka raba ta alamar kwalliya.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hi": "processIntegerAndChar एक पूर्णांक और एक अक्षर पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।  \nपैरामीटर्स:  \n- integer_value (int): इनपुट पूर्णांक।  \n- char_value (rune): इनपुट अक्षर।  \nवापसी:  \n- string: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम से अलग होते हैं।  \n\nउदाहरण:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hu": "processIntegerAndChar beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (rune): A bemeneti karakter.\nVisszatér:\n- string: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n\nPéldák:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Kimenet: \"234,H\""
    },
    "docstring_bertscore": {
      "sq": "0.9774554517525402",
      "hy": "0.9917725309871539",
      "bn": "0.987549053195209",
      "bg": "0.9919771202796198",
      "zh": "0.9983934774781899",
      "fr": "0.9960565910453144",
      "de": "0.9765010327716676",
      "ha": "0.9857860099331434",
      "hi": "0.970667655741435",
      "hu": "0.9913929483289963"
    }
  },
  {
    "task_id": "Go/25",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik.\nVetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (str): Teksti hyrës që do të përpunohet.\n\nKthen:\nstr: Teksti i transformuar me karakteret e zhvendosura me 5 pozicione.\n\nShembull:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tkthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով։\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n\nՊարամետրեր:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի։\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով։\n\nՕրինակ:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tվերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nসমস্ত অক্ষরকে বর্ণানুক্রমিক ক্রমে ৫ অবস্থানে সরিয়ে দেয়।\nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nফেরত দেয়:\nstr: রূপান্তরিত টেক্সট যা অক্ষরগুলি ৫ অবস্থানে সরানো হয়েছে।\n\nউদাহরণ:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tফেরত দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nПремества всички символи с 5 позиции в азбучен ред.\nСамо букви се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (str): Входният текст, който ще бъде обработен.\n\nВръща:\nstr: Трансформираният текст със символи, преместени с 5 позиции.\n\nПример:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n将所有字符在字母顺序中移动5个位置。\n只有字母会被替换，并且所有字母都是大写。\n\n参数：\ntext (str): 要处理的输入文本。\n\n返回：\nstr: 字符被移动5个位置后的转换文本。\n\n示例：\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique.\nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres:\ntext (str): Le texte d'entrée à traiter.\n\nRenvoie:\nstr: Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\trenvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (str): Der zu verarbeitende Eingabetext.\n\nRückgabe:\nstr: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tgibt \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" zurück\n*/\nfunc shiftCharacters(text string) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYana matsar da duk haruffa da matsayi 5 a cikin tsarin haruffa.\nHaruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (str): Rubutun shigarwa da za a sarrafa.\n\nDawowa:\nstr: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\nMisali:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tyana dawowa \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।\nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (str): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\nवापसी:\nstr: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\nउदाहरण:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tवापसी करता है \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAz összes karaktert 5 pozícióval eltolja ábécé sorrendben.\nCsak a betűk kerülnek helyettesítésre, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tvisszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9807757572019193",
      "hy": "0.9819794573109908",
      "bn": "0.9677378576211704",
      "bg": "0.9985013337750918",
      "zh": "0.9522337632294922",
      "fr": "0.9955318095786202",
      "de": "1",
      "ha": "0.9860865376996492",
      "hi": "0.976696882327368",
      "hu": "0.9797190435748138"
    },
    "canonical_solution": "runes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}",
    "instruction": {
      "en": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nՏվեք Go կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\n请用中文为以下 Go 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func shiftCharacters(text string) string\nrunes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.9112044730925446",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8882789517742599",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.935334886302187",
      "hi": "0.91027269797511",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestShiftCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\n\ttest1 := \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n\texpected1 := \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\tassert.Equal(expected1, shiftCharacters(test1), \"Test case 1 failed\")\n\n\ttest2 := \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n\texpected2 := \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\"\n\tassert.Equal(expected2, shiftCharacters(test2), \"Test case 2 failed\")\n\n\ttest3 := \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n\texpected3 := \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\"\n\tassert.Equal(expected3, shiftCharacters(test3), \"Test case 3 failed\")\n}",
    "entry_point": "shiftCharacters",
    "signature": "func shiftCharacters(text string) string",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (str): Teksti hyrës që do të përpunohet.\n\nKthen:\nstr: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tkthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Բոլոր նիշերը տեղափոխում է այբբենական կարգով 5 դիրքով:\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը, որտեղ նիշերը տեղափոխված են 5 դիրքով:\n\nՕրինակ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tվերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে সরিয়ে দেয়। \nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nরিটার্নস:\nstr: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫টি অবস্থানে সরানো হয়েছে।\n\nউদাহরণ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tফিরিয়ে দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Изместява всички символи с 5 позиции в азбучен ред.  \nСамо букви се заменят, и всички букви са с главни букви.\n\nПараметри:  \ntext (str): Входният текст, който ще бъде обработен.\n\nВръща:  \nstr: Преобразуваният текст със символи, изместени с 5 позиции.\n\nПример:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "将所有字符在字母表中向后移动5个位置。  \n仅替换字母，且所有字母均为大写。\n\n参数：  \ntext (str): 要处理的输入文本。\n\n返回：  \nstr: 转换后的文本，其中字符向后移动5个位置。\n\n示例：  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\t返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique.  \nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :  \ntext (str) : Le texte d'entrée à traiter.\n\nRenvoie :  \nstr : Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\trenvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.  \nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:  \ntext (str): Der zu verarbeitende Eingabetext.\n\nRückgabewert:  \nstr: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tgibt zurück \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa.\nHaruffa kawai ake maye gurbinsu, kuma dukkan haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (str): Rubutun da za a sarrafa.\n\nAbubuwan da ake mayarwa:\nstr: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\nMisali:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।  \nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:  \ntext (str): वह इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\nरिटर्न्स:  \nstr: परिवर्तित टेक्स्ट जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n\nउदाहरण:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tरिटर्न करता है \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Az összes karaktert 5 pozícióval eltolja ábécé sorrendben. \nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tvisszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.990685824172512",
      "hy": "0.970303764883379",
      "bn": "0.9507545627819254",
      "bg": "0.9954400423425821",
      "zh": "0.9516303241319082",
      "fr": "0.9839973433519242",
      "de": "0.9888683561860429",
      "ha": "0.9874795325618468",
      "hi": "0.9692353320637924",
      "hu": "0.9791988306068834"
    }
  },
  {
    "task_id": "Go/26",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "sq": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa të përcaktohet klasa.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\n    classifyInteger(\"24\") // kthen 6\n*/\nfunc classifyInteger(x string) int {",
      "hy": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԴասակարգեք ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (string): Ամբողջ թիվը, որը պետք է դասակարգվի որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\n    classifyInteger(\"24\") // վերադարձնում է 6\n*/\nfunc classifyInteger(x string) int {",
      "bn": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তবে x তার নিজস্ব শ্রেণীর অন্তর্গত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (string): পূর্ণসংখ্যাটি একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করতে হবে।\n\nরিটার্নস:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্গত।\n\nউদাহরণ:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "bg": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\n\nПараметри:\n- x (string): Цялото число, което трябва да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nПримери:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "zh": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类别。\n\n示例：\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "fr": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRetourne :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "de": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKlassifiziere die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die ganze Zahl, die als Zeichenkette klassifiziert werden soll.\n\nRückgabewert:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "ha": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin kirtani.\n\nDawowa:\nint: Aji wanda lambar x take ciki.\n\nMisalai:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "hi": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और वर्ग निर्धारित होने तक पुनरावृत्ति करें।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे एक स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nवापसी:\nint: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\nउदाहरण:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "hu": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nOsztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összegezze x számjegyeit, kapjon egy új x-et, és iteráljon, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám sztringként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9878658686529597",
      "hy": "0.8532284361064625",
      "bn": "0.9776439519841423",
      "bg": "0.9987694847894889",
      "zh": "0.964513490645831",
      "fr": "0.9841683641099953",
      "de": "0.9943549245709885",
      "ha": "0.9588809289308247",
      "hi": "0.9863264831999393",
      "hu": "0.9968125782755332"
    },
    "canonical_solution": "var n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}",
    "instruction": {
      "en": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nՏվեք Go կոդի հակիրճ նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func classifyInteger(x string) int\nvar n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9291421869126623",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestClassifyInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, classifyInteger(\"24\"))\n\tassert.Equal(3, classifyInteger(\"39\"))\n\tassert.Equal(9, classifyInteger(\"123456789\"))\n\tassert.Equal(9, classifyInteger(\"123456789012345678901234567890\"))\n\tassert.Equal(6, classifyInteger(\"12345\"))\n\tassert.Equal(9, classifyInteger(\"999999999\"))\n}",
    "entry_point": "classifyInteger",
    "signature": "func classifyInteger(x string) int",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa në të cilën i përket numri i plotë x.\n\nShembuj:\n    classifyInteger(\"24\") // kthen 6",
      "hy": "Դասակարգեք ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։  \nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի։  \n\nՊարամետրեր:  \n- x (string): Թիվը, որը պետք է դասակարգվի որպես տող։  \n\nՎերադարձնում է:  \nint: Դասը, որին պատկանում է թիվ x-ը։  \n\nՕրինակներ:  \n    classifyInteger(\"24\") // վերադարձնում է 6  ",
      "bn": "নিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজের শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nParameters:\n- x (string): যেটি একটি স্ট্রিং হিসেবে শ্রেণীবদ্ধ করা হবে এমন পূর্ণসংখ্যা।\n\nReturns:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\nExamples:\n    classifyInteger(\"24\") // 6 রিটার্ন করে",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:  \nАко x е едноцифрено число, x принадлежи на своя собствен клас.  \nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:  \n- x (string): Цялото число, което трябва да бъде класифицирано като низ.\n\nВръща:  \nint: Класът, към който принадлежи цялото число x.\n\nПримери:  \n    classifyInteger(\"24\") // връща 6",
      "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类别。\n\n示例：\n    classifyInteger(\"24\") // 返回 6",
      "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string): L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint: La classe à laquelle appartient l'entier x.\n\nExemples :\n    classifyInteger(\"24\") // renvoie 6",
      "de": "Classifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen den Vorgang, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als Zeichenfolge zu klassifizierende ganze Zahl.\n\nRückgabewerte:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\n    classifyInteger(\"24\") // gibt 6 zurück",
      "ha": "Rarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai ɗigo ɗaya, x na cikin ajin sa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba da maimaitawa har sai an tantance ajin.\n\nParameters:\n- x (string): Lambar da za a tantance a matsayin kirtani.\n\nReturns:\nint: Aji wanda lambar x take ciki.\n\nExamples:\n    classifyInteger(\"24\") // returns 6",
      "hi": "पूरे x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एक एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nParameters:\n- x (string): उस पूर्णांक को एक स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nReturns:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nExamples:\n    classifyInteger(\"24\") // returns 6",
      "hu": "Az egész szám x osztályozása a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadjuk x számjegyeit, kapunk egy új x-et, és iterálunk, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám, mint string.\n\nVisszatér:\nint: Az osztály, amelyhez az egész szám x tartozik.\n\nPéldák:\n    classifyInteger(\"24\") // visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9882448554199743",
      "hy": "0.9820251422986288",
      "bn": "0.9402172210680245",
      "bg": "0.9867700248407902",
      "zh": "0.9628171871917931",
      "fr": "0.9711741632130739",
      "de": "0.992683847175342",
      "ha": "0.9643341274117565",
      "hi": "0.9561348639130174",
      "hu": "0.9897794737438498"
    }
  },
  {
    "task_id": "Go/27",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transformon shkronjën e dhënë në shkronjë të madhe ose të vogël.\n\nParametrat:\n- letter (rune): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- rune: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronjë të vogël, kthen versionin me shkronjë të madhe,\n  dhe nëse hyrja është me shkronjë të madhe, kthen versionin me shkronjë të vogël.\n\nShembuj:\n\t- TransformLetterCase('b') kthen 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase ֆունկցիան փոխակերպում է տրված տառի տառատեսակը։\n\nՊարամետրեր:\n- letter (rune): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- rune: Տառը՝ իր տառատեսակը հակադարձված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n  իսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\n\t- TransformLetterCase('b') վերադարձնում է 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nপ্যারামিটার:\n- letter (rune): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nরিটার্ন:\n- rune: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n  এবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nউদাহরণ:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase преобразува регистъра на дадена буква.\n\nПараметри:\n- letter (rune): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- rune: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\n  а ако входът е с главни букви, връща версията с малки букви.\n\nПримери:\n\t- TransformLetterCase('b') връща 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase 转换给定字母的大小写。\n\n参数：\n- letter (rune): 要转换的输入字母。\n\n返回：\n- rune: 大小写反转的字母。如果输入是小写字母，则返回大写版本，\n  如果输入是大写字母，则返回小写版本。\n\n示例：\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforme la casse d'une lettre donnée.\n\nParamètres :\n- letter (rune) : La lettre d'entrée à transformer.\n\nRenvoie :\n- rune : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\n  et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples :\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase wandelt den Fall eines gegebenen Buchstabens um.\n\nParameter:\n- letter (rune): Der Eingabebuchstabe, der umgewandelt werden soll.\n\nRückgabewerte:\n- rune: Der Buchstabe mit umgekehrtem Fall. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben,\n  und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase yana sauya yanayin harafin da aka bayar.\n\nSigogi:\n- letter (rune): Harafin shigarwa da za a sauya.\n\nDawowa:\n- rune: Harafin tare da yanayinsa da aka juya. Idan shigarwar harafi ne ƙarami, zai dawo da babba,\n  kuma idan shigarwar babba ce, zai dawo da ƙarami.\n\nMisalai:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase एक दिए गए अक्षर के मामले को बदलता है।\n\nपैरामीटर्स:\n- letter (rune): इनपुट अक्षर जिसे बदला जाना है।\n\nवापसी:\n- rune: अक्षर जिसका मामला उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\n  और यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n\nउदाहरण:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase átalakítja egy adott betű esetét.\n\nParaméterek:\n- letter (rune): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- rune: A betű megfordított esettel. Ha a bemenet kisbetű, akkor a nagybetűs változatot adja vissza,\n  és ha a bemenet nagybetű, akkor a kisbetűs változatot adja vissza.\n\nPéldák:\n\t- TransformLetterCase('b') visszaadja 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {"
    },
    "prompt_bertscore": {
      "sq": "0.9638594008010831",
      "hy": "0.97147091700234",
      "bn": "0.9683651323644785",
      "bg": "0.9920939149436684",
      "zh": "0.9692039484635888",
      "fr": "0.9889917056526655",
      "de": "0.9733527412322646",
      "ha": "0.962435618229825",
      "hi": "0.9720993835279345",
      "hu": "0.9920939149436684"
    },
    "canonical_solution": "if letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}",
    "instruction": {
      "en": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nՏվեք Go կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) अधिकतम 500 वर्णों में हिंदी में प्रदान करें।",
      "hu": "func TransformLetterCase(letter rune) rune\nif letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9291421869126623",
      "bn": "0.8888925210212767",
      "bg": "0.8329297550441628",
      "zh": "0.8896873717349259",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.935334886302187",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestTransformLetterCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(rune('B'), TransformLetterCase('b'), \"Lowercase 'b' should transform to uppercase 'B'\")\n\tassert.Equal(rune('b'), TransformLetterCase('B'), \"Uppercase 'B' should transform to lowercase 'b'\")\n\n\t// Additional test cases\n\tassert.Equal(rune('Z'), TransformLetterCase('z'), \"Lowercase 'z' should transform to uppercase 'Z'\")\n\tassert.Equal(rune('z'), TransformLetterCase('Z'), \"Uppercase 'Z' should transform to lowercase 'z'\")\n\tassert.Equal(rune('M'), TransformLetterCase('m'), \"Lowercase 'm' should transform to uppercase 'M'\")\n\tassert.Equal(rune('m'), TransformLetterCase('M'), \"Uppercase 'M' should transform to lowercase 'm'\")\n\tassert.Equal(rune('1'), TransformLetterCase('1'), \"Non-alphabetic '1' should remain unchanged\")\n\tassert.Equal(rune('!'), TransformLetterCase('!'), \"Non-alphabetic '!' should remain unchanged\")\n}",
    "entry_point": "TransformLetterCase",
    "signature": "func TransformLetterCase(letter rune) rune",
    "docstring": {
      "en": "TransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "sq": "TransformLetterCase transformon shkronjën e dhënë në një rast tjetër.\n\nParametrat:\n- letter (rune): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- rune: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\n  dhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n\nShembuj:\n\t- TransformLetterCase('b') kthen 'B'",
      "hy": "TransformLetterCase-ը փոխակերպում է տրված տառի ռեգիստրը։\n\nՊարամետրեր:\n- letter (rune): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- rune: Տառը՝ իր ռեգիստրը հակադարձված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը, \n  և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\n\t- TransformLetterCase('b') վերադարձնում է 'B'",
      "bn": "TransformLetterCase একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nParameters:\n- letter (rune): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nReturns:\n- rune: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n  এবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "bg": "TransformLetterCase преобразува регистъра на дадена буква.\n\nПараметри:\n- letter (rune): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- rune: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\n  а ако входът е с главни букви, връща версията с малки букви.\n\nПримери:\n\t- TransformLetterCase('b') връща 'B'",
      "zh": "TransformLetterCase 转换给定字母的大小写。\n\n参数:\n- letter (rune): 要转换的输入字母。\n\n返回:\n- rune: 大小写已反转的字母。如果输入是小写，则返回大写版本；如果输入是大写，则返回小写版本。\n\n示例:\n\t- TransformLetterCase('b') 返回 'B'",
      "fr": "TransformLetterCase transforme la casse d'une lettre donnée.\n\nParamètres:\n- letter (rune): La lettre d'entrée à transformer.\n\nRenvoie:\n- rune: La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\n  et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples:\n\t- TransformLetterCase('b') renvoie 'B'",
      "de": "TransformLetterCase transformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nParameter:\n- letter (rune): Der Eingabebuchstabe, der transformiert werden soll.\n\nRückgabewert:\n- rune: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe in Kleinbuchstaben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe in Großbuchstaben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\n\t- TransformLetterCase('b') gibt 'B' zurück",
      "ha": "TransformLetterCase yana canza harafin da aka bayar zuwa babba ko ƙanana.\n\nParameters:\n- letter (rune): Harafin shigarwa da za a canza.\n\nReturns:\n- rune: Harafin tare da canjin babba ko ƙanana. Idan shigarwar ƙanana ne, zai dawo da babbar sigar,\n  kuma idan shigarwar babba ce, zai dawo da ƙananan sigar.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "hi": "TransformLetterCase एक दिए गए अक्षर के मामले को बदलता है।\n\nपैरामीटर्स:\n- letter (rune): इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n\nवापसी:\n- rune: अक्षर जिसके मामले को उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\n  और यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n\nउदाहरण:\n\t- TransformLetterCase('b') 'B' लौटाता है।",
      "hu": "TransformLetterCase átalakítja egy adott betű esetét.\n\nParaméterek:\n- letter (rune): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- rune: A betű az esetének megfordításával. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza, és ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n\nPéldák:\n\t- TransformLetterCase('b') visszaadja 'B'"
    },
    "docstring_bertscore": {
      "sq": "0.978838117834924",
      "hy": "0.9898190011896758",
      "bn": "0.9483245187003445",
      "bg": "0.9773503762809728",
      "zh": "0.968458885904327",
      "fr": "0.9850445227207402",
      "de": "0.9696065722459466",
      "ha": "0.9442962945729569",
      "hi": "0.9864869765478155",
      "hu": "1"
    }
  },
  {
    "task_id": "Go/28",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo kthen kodin ASCII për një karakter të dhënë.\n\nParametrat:\n- character: Karakteri i dhënë për të cilin informacioni ASCII do të shfaqet.\n\nKthen:\n- Kodi përkatës ASCII.\n\nShembuj:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo վերադարձնում է ASCII կոդը տրված սիմվոլի համար:\n\nՊարամետրեր:\n- character: Մուտքային սիմվոլ, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\nՎերադարձնում է:\n- Համապատասխանող ASCII կոդը:\n\nՕրինակներ:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo একটি প্রদত্ত অক্ষরের জন্য ASCII কোড প্রদান করে।\n\nপ্যারামিটার:\n- character: ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nরিটার্ন:\n- সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo връща ASCII кода за даден символ.\n\nПараметри:\n- character: Входният символ, за който трябва да се покаже ASCII информация.\n\nВръща:\n- Съответния ASCII код.\n\nПримери:\n\tDisplayASCIIInfo('A') // връща 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo 返回给定字符的 ASCII 码。\n\n参数:\n- character: 要显示 ASCII 信息的输入字符。\n\n返回:\n- 对应的 ASCII 码。\n\n示例:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo retourne le code ASCII pour un caractère donné.\n\nParamètres:\n- character: Le caractère d'entrée pour lequel l'information ASCII doit être affichée.\n\nRetourne:\n- Le code ASCII correspondant.\n\nExemples:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo gibt den ASCII-Code für ein gegebenes Zeichen zurück.\n\nParameter:\n- character: Das Eingabezeichen, für das ASCII-Informationen angezeigt werden sollen.\n\nRückgabewerte:\n- Der entsprechende ASCII-Code.\n\nBeispiele:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo yana dawo da lambar ASCII don wata alama da aka bayar.\n\nSigogi:\n- character: Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n\nAbubuwan da ake dawowa da su:\n- Lambar ASCII da ta dace.\n\nMisalai:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo दिए गए वर्ण के लिए ASCII कोड लौटाता है।\n\nपैरामीटर:\n- character: वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n- संबंधित ASCII कोड।\n\nउदाहरण:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo visszaadja a megadott karakter ASCII kódját.\n\nParaméterek:\n- character: Az a bemeneti karakter, amelynek ASCII információját meg kell jeleníteni.\n\nVisszatér:\n- A megfelelő ASCII kód.\n\nPéldák:\n\tDisplayASCIIInfo('A') // visszaadja a 65-öt\n*/\nfunc DisplayASCIIInfo(character rune) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9804458321390205",
      "hy": "0.9701236071277805",
      "bn": "0.9680580497953986",
      "bg": "0.9921552917314082",
      "zh": "0.9777063219237873",
      "fr": "0.9879461153268978",
      "de": "0.9853867628672632",
      "ha": "0.9877744986776836",
      "hi": "0.9833231918386918",
      "hu": "0.9769898621393944"
    },
    "canonical_solution": "return int(character)\n}",
    "instruction": {
      "en": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nՏվյալ Go կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func DisplayASCIIInfo(character rune) int\nreturn int(character)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8666584320593744",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9528896407476694",
      "hi": "0.904317560521303",
      "hu": "0.9310951208189973"
    },
    "level": "",
    "test": "func TestDisplayASCIIInfo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(65, DisplayASCIIInfo('A'), \"ASCII value for 'A' should be 65\")\n\tassert.Equal(66, DisplayASCIIInfo('B'), \"ASCII value for 'B' should be 66\") // Additional test case\n\tassert.Equal(48, DisplayASCIIInfo('0'), \"ASCII value for '0' should be 48\") // Additional test case\n\tassert.Equal(32, DisplayASCIIInfo(' '), \"ASCII value for ' ' should be 32\") // Additional test case\n}",
    "entry_point": "DisplayASCIIInfo",
    "signature": "func DisplayASCIIInfo(character rune) int",
    "docstring": {
      "en": "DisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n",
      "sq": "DisplayASCIIInfo kthen kodin ASCII për një karakter të dhënë.\n\nParametrat:\n- character: Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n\nKthen:\n- Kodi përkatës ASCII.\n\nShembuj:\n\tDisplayASCIIInfo('A') // kthen 65",
      "hy": "DisplayASCIIInfo-ը վերադարձնում է տրված սիմվոլի ASCII կոդը։\n\nՊարամետրեր:\n- character: Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\nՎերադարձնում է:\n- Համապատասխան ASCII կոդը։\n\nՕրինակներ:\n\tDisplayASCIIInfo('A') // վերադարձնում է 65",
      "bn": "DisplayASCIIInfo একটি প্রদত্ত অক্ষরের জন্য ASCII কোড প্রদান করে।\n\nParameters:\n- character: ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nReturns:\n- সংশ্লিষ্ট ASCII কোড।\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65",
      "bg": "DisplayASCIIInfo връща ASCII код за даден символ.\n\nПараметри:\n- character: Входният символ, за който трябва да се покаже ASCII информация.\n\nВръща:\n- Съответният ASCII код.\n\nПримери:\n\tDisplayASCIIInfo('A') // връща 65",
      "zh": "DisplayASCIIInfo 返回给定字符的 ASCII 码。\n\n参数：\n- character: 要显示 ASCII 信息的输入字符。\n\n返回：\n- 对应的 ASCII 码。\n\n示例：\n\tDisplayASCIIInfo('A') // 返回 65",
      "fr": "DisplayASCIIInfo renvoie le code ASCII pour un caractère donné.\n\nParamètres:\n- character: Le caractère d'entrée pour lequel l'information ASCII doit être affichée.\n\nRenvoie:\n- Le code ASCII correspondant.\n\nExemples:\n\tDisplayASCIIInfo('A') // renvoie 65",
      "de": "DisplayASCIIInfo gibt den ASCII-Code für ein gegebenes Zeichen zurück.\n\nParameter:\n- character: Das Eingabezeichen, für das die ASCII-Information angezeigt werden soll.\n\nRückgabewert:\n- Der entsprechende ASCII-Code.\n\nBeispiele:\n\tDisplayASCIIInfo('A') // gibt 65 zurück",
      "ha": "DisplayASCIIInfo yana dawo da lambar ASCII don wata alama da aka bayar.\n\nSigogi:\n- character: Alamar shigarwa wadda za a nuna bayanin ASCII ɗinta.\n\nDawowa:\n- Lambar ASCII mai dacewa.\n\nMisalai:\n\tDisplayASCIIInfo('A') // yana dawowa 65",
      "hi": "DisplayASCIIInfo एक दिए गए वर्ण के लिए ASCII कोड लौटाता है।\n\nParameters:\n- character: वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nReturns:\n- संबंधित ASCII कोड।\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65",
      "hu": "DisplayASCIIInfo visszaadja egy adott karakter ASCII kódját.\n\nParaméterek:\n- character: Az a bemeneti karakter, amelyhez az ASCII információt meg kell jeleníteni.\n\nVisszatér:\n- A megfelelő ASCII kód.\n\nPéldák:\n\tDisplayASCIIInfo('A') // visszaadja 65"
    },
    "docstring_bertscore": {
      "sq": "0.9725689457487009",
      "hy": "0.9667880071390615",
      "bn": "0.9506941791460908",
      "bg": "0.9799619685308194",
      "zh": "0.9583934899757651",
      "fr": "0.9709455396445028",
      "de": "0.9619801587661121",
      "ha": "0.9684187625673579",
      "hi": "0.9753312984577531",
      "hu": "0.9694796474324653"
    }
  },
  {
    "task_id": "Go/29",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\t Example:\n\t\tevaluateIntegerGrade(90) // Returns 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVlerësoni notën për një numër të plotë hyrës.\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n\t Shembull:\n\t\tevaluateIntegerGrade(90) // Kthen 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳնահատել մուտքային ամբողջ թվի գնահատականը։\nՊարամետրեր:\n- score (int): Գնահատվող ամբողջ թվային միավորը։\nՎերադարձնում է:\n    char: Մուտքային միավորին համապատասխան գնահատականը։\n         Եթե միավորը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n         Հակառակ դեպքում, վերադարձնում է 'B'։\n\t Օրինակ:\n\t\tevaluateIntegerGrade(90) // Վերադարձնում է 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\nপ্যারামিটার:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n         যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' ফেরত দেয়।\n         অন্যথায়, 'B' ফেরত দেয়।\n\t উদাহরণ:\n\t\tevaluateIntegerGrade(90) // 'A' ফেরত দেয়\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОценете оценката за входящо цяло число.\nПараметри:\n- score (int): Цялото число, което трябва да бъде оценено.\nВръща:\n    char: Оценката, съответстваща на входящото число.\n         Ако числото е между 90 и 100 (включително), връща 'A'.\n         В противен случай връща 'B'.\n\t Пример:\n\t\tevaluateIntegerGrade(90) // Връща 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n评估输入整数的等级。\n参数：\n- score (int): 要评估的整数分数。\n返回：\n    char: 与输入分数对应的等级。\n         如果分数在90到100之间（包括90和100），返回 'A'。\n         否则，返回 'B'。\n\t 示例：\n\t\tevaluateIntegerGrade(90) // 返回 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉvaluer la note pour un entier en entrée.\nParamètres :\n- score (int) : Le score entier à évaluer.\nRenvoie :\n    char : La note correspondant au score d'entrée.\n         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n         Sinon, renvoie 'B'.\n\t Exemple :\n\t\tevaluateIntegerGrade(90) // Renvoie 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBewerte die Note für eine Eingabe als Ganzzahl.\nParameter:\n- score (int): Die zu bewertende Ganzzahl.\nRückgabe:\n    char: Die Note, die der Eingabepunktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n\t Beispiel:\n\t\tevaluateIntegerGrade(90) // Gibt 'A' zurück\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKimanta maki don wani lamba shigarwa.\nSigogi:\n- score (int): Lambar maki da za a kimanta.\nAbubuwan da ake dawowa da su:\n    char: Makin da ya dace da maki na shigarwa.\n         Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawo da 'A'.\n         In ba haka ba, yana dawo da 'B'.\n\t Misali:\n\t\tevaluateIntegerGrade(90) // Yana dawo da 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nइनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\nवापसी:\n    char: इनपुट स्कोर के अनुसार ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n\t उदाहरण:\n\t\tevaluateIntegerGrade(90) // 'A' लौटाता है\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉrtékeld ki a jegyet egy egész szám bemenet alapján.\nParaméterek:\n- score (int): Az értékelendő egész szám pontszám.\nVisszatér:\n    char: A bemeneti pontszámhoz tartozó jegy.\n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n         Egyébként 'B'-t ad vissza.\n\t Példa:\n\t\tevaluateIntegerGrade(90) // Visszaadja: 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {"
    },
    "prompt_bertscore": {
      "sq": "0.9851619132759318",
      "hy": "0.9847489607137603",
      "bn": "0.9885171776723731",
      "bg": "0.9761560117998099",
      "zh": "0.9736290360922841",
      "fr": "0.9937179169390096",
      "de": "0.9638663528644194",
      "ha": "0.9728480214340549",
      "hi": "0.9602862388766465",
      "hu": "0.9864849902440052"
    },
    "canonical_solution": "if 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}",
    "instruction": {
      "en": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Go cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func evaluateIntegerGrade(score int) rune\nif 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9307552642370466",
      "bn": "0.875873689957107",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.8980082650981108",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestEvaluateIntegerGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal('A', evaluateIntegerGrade(90))\n\tassert.Equal('B', evaluateIntegerGrade(89))\n\tassert.Equal('A', evaluateIntegerGrade(95))\n\tassert.Equal('A', evaluateIntegerGrade(100))\n\tassert.Equal('B', evaluateIntegerGrade(101))\n}",
    "entry_point": "evaluateIntegerGrade",
    "signature": "func evaluateIntegerGrade(score int) rune",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n     Example:\n        evaluateIntegerGrade(90) // Returns 'A'",
      "sq": "Vlerësoni notën për një numër të plotë hyrës.\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n     Shembull:\n        evaluateIntegerGrade(90) // Kthen 'A'",
      "hy": "Գնահատել մուտքային ամբողջ թվի գնահատականը։  \nՊարամետրեր:  \n- score (int): Գնահատվող ամբողջ թվային միավորը։  \nՎերադարձնում է:  \n    char: Մուտքային միավորին համապատասխան գնահատականը։  \n         Եթե միավորը 90-ից 100 է (ներառյալ), վերադարձնում է 'A':  \n         Հակառակ դեպքում, վերադարձնում է 'B':  \n     Օրինակ:  \n        evaluateIntegerGrade(90) // Վերադարձնում է 'A'  ",
      "bn": "ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n         যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তবে 'A' ফেরত দেয়।\n         অন্যথায়, 'B' ফেরত দেয়।\n     উদাহরণ:\n        evaluateIntegerGrade(90) // 'A' ফেরত দেয়।",
      "bg": "Оценете оценката за входящо цяло число.  \nПараметри:  \n- score (int): Цялочислената оценка, която трябва да бъде оценена.  \nВръща:  \n    char: Оценката, съответстваща на входящата оценка.  \n         Ако оценката е между 90 и 100 (включително), връща 'A'.  \n         В противен случай връща 'B'.  \n     Пример:  \n        evaluateIntegerGrade(90) // Връща 'A'  ",
      "zh": "评估输入整数的等级。\n参数：\n- score (int): 要评估的整数分数。\n返回：\n    char: 与输入分数对应的等级。\n         如果分数在90到100之间（包括90和100），返回 'A'。\n         否则，返回 'B'。\n     示例：\n        evaluateIntegerGrade(90) // 返回 'A'",
      "fr": "Évaluer la note pour un entier en entrée.\nParamètres :\n- score (int): Le score entier à évaluer.\nRenvoie :\n    char: La note correspondant au score d'entrée.\n         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n         Sinon, renvoie 'B'.\n     Exemple :\n        evaluateIntegerGrade(90) // Renvoie 'A'",
      "de": "Bewerten Sie die Note für eine Eingabe als Ganzzahl.\nParameter:\n- score (int): Die zu bewertende Ganzzahl.\nRückgabewert:\n    char: Die Note, die der Eingabepunktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n     Beispiel:\n        evaluateIntegerGrade(90) // Gibt 'A' zurück",
      "ha": "Kimanta darajar don wani cikakken lamba.\nSigogi:\n- score (int): Makircin cikakken lamba da za a tantance.\nDawowa:\n    char: Matsayin da ya dace da makircin da aka shigar.\n         Idan makircin yana tsakanin 90 da 100 (ciki har da), ya dawo da 'A'.\n         In ba haka ba, ya dawo da 'B'.\n     Misali:\n        evaluateIntegerGrade(90) // Ya dawo da 'A'",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n     उदाहरण:\n        evaluateIntegerGrade(90) // 'A' लौटाता है।",
      "hu": "Értékeli a bemeneti egész szám osztályzatát.\nParaméterek:\n- score (int): Az értékelendő egész szám pontszám.\nVisszatér:\n    char: Az osztályzat, amely megfelel a bemeneti pontszámnak.\n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n         Egyébként 'B'-t ad vissza.\n     Példa:\n        evaluateIntegerGrade(90) // Visszaadja: 'A'"
    },
    "docstring_bertscore": {
      "sq": "0.9651673818601979",
      "hy": "0.9886341709668026",
      "bn": "0.9782728157704987",
      "bg": "0.9740113995757763",
      "zh": "0.9650746214722545",
      "fr": "0.9941282873062277",
      "de": "0.9415222226714237",
      "ha": "0.9506200900139647",
      "hi": "0.9697984491940262",
      "hu": "0.9826945266827164"
    }
  },
  {
    "task_id": "Go/30",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n//\n// Args:\n//\n//\ts (string): The three-character string to be checked.\n//\n// Returns:\n//\n//\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n//\tExamples:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n//\n// Argumentet:\n//\n//\ts (string): Vargu me tre karaktere që do të kontrollohet.\n//\n// Kthen:\n//\n//\tstr: Kthen \"Yes\" nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe \"No\".\n//\tShembuj:\n//\t    checkTwoEqualDigits(\"112\") // kthen \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n//\n// Արգումենտներ:\n//\n//\ts (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n//\n// Վերադարձնում է:\n//\n//\tstr: Վերադարձնում է \"Yes\", եթե մուտքագրումը ունի հենց երկու նույն նիշ, հակառակ դեպքում՝ \"No\".\n//\tՕրինակներ:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কি না।\n//\n// আর্গুমেন্টসমূহ:\n//\n//\ts (string): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n//\n// রিটার্নস:\n//\n//\tstr: \"Yes\" রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n//\tউদাহরণ:\n//\t    checkTwoEqualDigits(\"112\") // \"Yes\" রিটার্ন করে\nfunc CheckTwoEqualDigits(s string) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits проверява дали низ с три знака има точно два еднакви знака.\n//\n// Аргументи:\n//\n//\ts (string): Низът с три знака, който ще бъде проверен.\n//\n// Връща:\n//\n//\tstr: Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n//\tПримери:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits 检查一个三字符字符串是否有且仅有两个字符相同。\n//\n// 参数:\n//\n//\ts (string): 要检查的三字符字符串。\n//\n// 返回:\n//\n//\tstr: 如果输入有且仅有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n//\t示例:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n//\n// Args:\n//\n//\ts (string): La chaîne de trois caractères à vérifier.\n//\n// Returns:\n//\n//\tstr: Retourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n//\tExemples:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n//\n// Argumente:\n//\n//\ts (string): Der zu überprüfende dreistellige String.\n//\n// Rückgabewerte:\n//\n//\tstr: Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n//\tBeispiele:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits yana duba idan wani igiyar haruffa guda uku yana da daidai haruffa biyu da suke daidai.\n//\n// Args:\n//\n//\ts (string): Igiyar haruffa guda uku da za a duba.\n//\n// Returns:\n//\n//\tstr: Yana dawowa da \"Yes\" idan shigar yana da daidai haruffa biyu da suke daidai, in ba haka ba \"No\".\n//\tMisalai:\n//\t    checkTwoEqualDigits(\"112\") // yana dawowa da \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits यह जांचता है कि क्या तीन-अक्षर वाली स्ट्रिंग में ठीक दो अक्षर समान हैं।\n//\n// तर्क:\n//\n//\ts (string): तीन-अक्षर वाली स्ट्रिंग जिसे जांचा जाना है।\n//\n// वापसी:\n//\n//\tstr: \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n//\tउदाहरण:\n//\t    checkTwoEqualDigits(\"112\") // \"Yes\" लौटाता है\nfunc CheckTwoEqualDigits(s string) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits ellenőrzi, hogy egy három karakteres string pontosan két azonos karakterrel rendelkezik-e.\n//\n// Args:\n//\n//\ts (string): A három karakteres string, amelyet ellenőrizni kell.\n//\n// Visszatér:\n//\n//\tstr: \"Yes\"-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben \"No\"-t.\n//\tPéldák:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9645571893296587",
      "hy": "0.9632748315896974",
      "bn": "0.9724459935428403",
      "bg": "0.9633803043220269",
      "zh": "0.9598212451546438",
      "fr": "0.9715992322284885",
      "de": "0.9598075396583524",
      "ha": "0.9772558282196001",
      "hi": "0.9750482501647784",
      "hu": "0.9847914676153017"
    },
    "canonical_solution": "if (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}",
    "instruction": {
      "en": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nՏրամադրել Go կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\n请用中文为以下 Go 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func CheckTwoEqualDigits(s string) string\nif (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9211790949369736",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8882789517742599",
      "fr": "0.967547569716139",
      "de": "0.9364712507120876",
      "ha": "0.9528896407476694",
      "hi": "0.91027269797511",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCheckTwoEqualDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"112\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"123\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"232\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"444\")) // All three characters are equal, not two.\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"121\"))\n\n\t// Additional test cases to cover more scenarios\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"787\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"999\")) // All three characters are equal\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"890\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"556\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"353\")) // No two characters are equal\n}",
    "entry_point": "CheckTwoEqualDigits",
    "signature": "func CheckTwoEqualDigits(s string) string",
    "docstring": {
      "en": "CheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n\n\ts (string): The three-character string to be checked.\n\nReturns:\n\n\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "sq": "CheckTwoEqualDigits kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgs:\n\n\ts (string): Vargu me tre karaktere që do të kontrollohet.\n\nReturns:\n\n\tstr: Kthen \"Yes\" nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // kthen \"Yes\"",
      "hy": "CheckTwoEqualDigits-ը ստուգում է, արդյոք երեք նիշից բաղկացած տողում կա՞ն երկու նույնական նիշ:\n\nԱրգումենտներ:\n\n\ts (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n\nՎերադարձնում է:\n\n\tstr: Վերադարձնում է \"Yes\", եթե մուտքագրումը ունի հենց երկու նույնական նիշ, հակառակ դեպքում՝ \"No\":\n\tՕրինակներ:\n\t    checkTwoEqualDigits(\"112\") // վերադարձնում է \"Yes\"",
      "bn": "CheckTwoEqualDigits একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা তা পরীক্ষা করে।\n\nArgs:\n\n\ts (string): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nReturns:\n\n\tstr: \"Yes\" ফেরত দেয় যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" ফেরত দেয়",
      "bg": "CheckTwoEqualDigits проверява дали низ от три знака има точно два еднакви знака.\n\nArgs:\n\n\ts (string): Низът от три знака, който ще бъде проверен.\n\nReturns:\n\n\tstr: Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // връща \"Yes\"",
      "zh": "CheckTwoEqualDigits 检查一个三字符字符串是否有且仅有两个字符相同。\n\nArgs:\n\n\ts (string): 要检查的三字符字符串。\n\nReturns:\n\n\tstr: 如果输入有且仅有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "fr": "CheckTwoEqualDigits vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n\n\ts (string): La chaîne de trois caractères à vérifier.\n\nReturns:\n\n\tstr: Renvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "de": "CheckTwoEqualDigits überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgs:\n\n\ts (string): Der dreistellige String, der überprüft werden soll.\n\nReturns:\n\n\tstr: Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // gibt \"Yes\" zurück",
      "ha": "CheckTwoEqualDigits yana duba idan wata igiyar haruffa guda uku tana da ainihin haruffa biyu da suke daidai.\n\nArgs:\n\n\ts (string): Igiyar haruffa guda uku da za a duba.\n\nReturns:\n\n\tstr: Yana dawowa da \"Yes\" idan shigarwar tana da ainihin haruffa biyu da suke daidai, in ba haka ba \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // yana dawowa da \"Yes\"",
      "hi": "CheckTwoEqualDigits यह जांचता है कि क्या एक तीन-अक्षर वाली स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nArgs:\n\n\ts (string): तीन-अक्षर वाली स्ट्रिंग जिसे जांचना है।\n\nReturns:\n\n\tstr: \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" लौटाता है",
      "hu": "CheckTwoEqualDigits ellenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgs:\n\n\ts (string): A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nReturns:\n\n\tstr: \"Yes\" értéket ad vissza, ha a bemenetben pontosan két azonos karakter van, különben \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // visszaadja \"Yes\""
    },
    "docstring_bertscore": {
      "sq": "0.9835031509639094",
      "hy": "0.9217632668875972",
      "bn": "0.9628485707919966",
      "bg": "0.9575451396183651",
      "zh": "0.9630080709879676",
      "fr": "0.9594392789319137",
      "de": "0.9595471352288157",
      "ha": "0.9560782542544224",
      "hi": "0.9625204334025269",
      "hu": "0.9556996647481699"
    }
  },
  {
    "task_id": "Go/31",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a string consisting of lowercase English letters,\nin each round, you can change one of the characters to another character.\nThe question is: what is the minimum number of rounds needed to make\nthe string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes,\nnë çdo raund, ju mund të ndryshoni një nga karakteret në një karakter tjetër.\nPyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë\nvargun të përbërë nga i njëjti karakter?\n\nPër shembull:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով փոքրատառ անգլերեն տառերից կազմված տող,\nյուրաքանչյուր փուլում, դուք կարող եք փոխել նիշերից մեկը մեկ այլ նիշի:\nՀարցն այն է՝ որքան է նվազագույն փուլերի քանակը, որպեսզի\nտողը կազմված լինի նույն նիշից:\n\nՕրինակ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত,\nপ্রতিটি রাউন্ডে, আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন।\nপ্রশ্ন হল: স্ট্রিংটি একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е низ, състоящ се от малки английски букви,\nвъв всеки рунд можете да промените един от символите на друг символ.\nВъпросът е: какъв е минималният брой рундове, необходими, за да се направи\nнизът съставен от един и същ символ?\n\nНапример:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由小写英文字母组成的字符串，\n在每一轮中，你可以将其中一个字符更改为另一个字符。\n问题是：需要多少轮才能使字符串由相同的字符组成？\n\n例如:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une chaîne composée de lettres minuscules anglaises,\nà chaque tour, vous pouvez changer l'un des caractères pour un autre caractère.\nLa question est : quel est le nombre minimum de tours nécessaires pour rendre\nla chaîne composée du même caractère ?\n\nPar exemple :\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht,\nin jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern.\nDie Frage ist: Was ist die minimale Anzahl an Runden, die benötigt werden,\num den String aus demselben Zeichen zusammengesetzt zu machen?\n\nZum Beispiel:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi,\na kowace zagaye, za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi.\nTambayar ita ce: menene mafi ƙarancin adadin zagaye da ake bukata don yin\nkirtanin ya ƙunshi harafi guda?\n\nMisali:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए स्ट्रिंग में छोटे अक्षरों के अंग्रेजी अक्षर होते हैं,\nप्रत्येक राउंड में, आप वर्णों में से एक को दूसरे वर्ण में बदल सकते हैं।\nप्रश्न यह है: स्ट्रिंग को एक ही वर्ण से मिलकर बनाने के लिए\nन्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy kisbetűs angol betűkből álló string,\nminden körben megváltoztathatsz egy karaktert egy másik karakterre.\nA kérdés: mi a minimális körök száma, amely szükséges ahhoz, hogy\na string ugyanabból a karakterből álljon?\n\nPéldául:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {"
    },
    "prompt_bertscore": {
      "sq": "0.996663804120138",
      "hy": "0.9713433962977156",
      "bn": "0.9813271551396723",
      "bg": "0.9980309770328012",
      "zh": "0.9795186255203496",
      "fr": "0.9981874977730566",
      "de": "0.9749582706021696",
      "ha": "0.981838231110075",
      "hi": "0.9755205932108794",
      "hu": "0.9858469894601211"
    },
    "canonical_solution": "var charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}",
    "instruction": {
      "en": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nՏվեք Go կոդի հակիրճ նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\n将以下 Go 代码的自然语言描述（文档字符串）翻译成中文，字数不超过500个字符。",
      "fr": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func minRoundsToSameChar(s string) int\nvar charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9117481244454371",
      "bn": "0.8665176031192207",
      "bg": "0.8329297550441628",
      "zh": "0.8318029248925518",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.935334886302187",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestMinRoundsToSameChar(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, minRoundsToSameChar(\"aab\"), \"They should be equal\")\n\tassert.Equal(2, minRoundsToSameChar(\"abc\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"aaa\"), \"They should be equal\")\n\tassert.Equal(1, minRoundsToSameChar(\"abab\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"zzzzz\"), \"They should be equal\")\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "func minRoundsToSameChar(s string) int",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round, you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në secilën raund, ju mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: sa është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nPër shembull:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից բաղկացած տող, յուրաքանչյուր փուլում կարող եք փոխել տառերից մեկը այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից:\n\nՕրինակ՝\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "bn": "নিচে প্রদত্ত স্ট্রিংটি ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে, আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্নটি হল: স্ট্রিংটি একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "bg": "Като се даде низ, състоящ се от малки английски букви, във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nНапример:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：需要最少多少轮才能使字符串由相同的字符组成？\n\n例如：\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nPar exemple :\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "de": "Angenommen, eine Zeichenkette besteht aus Kleinbuchstaben des englischen Alphabets. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um die Zeichenkette aus demselben Zeichen zusammengesetzt zu machen?\n\nZum Beispiel:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "ha": "An ba da wata igiyar rubutu da ta ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye, za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar rubutu ta ƙunshi harafin guda?\n\nMisali:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hi": "एक स्ट्रिंग दी गई है जिसमें छोटे अक्षरों वाले अंग्रेजी अक्षर हैं, प्रत्येक राउंड में, आप एक वर्ण को दूसरे वर्ण में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही वर्ण से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldául:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0"
    },
    "docstring_bertscore": {
      "sq": "0.9945905002028959",
      "hy": "0.9452654122020262",
      "bn": "0.9716476980414611",
      "bg": "0.9973212706813634",
      "zh": "0.9863356201974669",
      "fr": "0.9888226711984047",
      "de": "0.9435736772467521",
      "ha": "0.9624254880803923",
      "hi": "0.962851351617331",
      "hu": "0.980705044786271"
    }
  },
  {
    "task_id": "Go/32",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Y_n when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh,\nproblemi është të gjesh vitin Y_n kur ndodh ngjarja e n-të, nën\nkushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin\nmenjëherë pas ndodhjes së ngjarjes i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ,\nխնդիրը գտնելն է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության համար հետհաշվարկը կարող է սկսվել միայն\ni իրադարձության տեղի ունենալուց անմիջապես հետո:\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে,\nসমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন nতম ঘটনা ঘটে,\nএই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছরেই শুরু হতে পারে।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години,\nпроблемът е да се намери годината Y_n, когато се случва n-тото събитие, при\nусловие, че отброяването за събитие i+1 може да започне само в годината\nведнага след настъпването на събитие i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个长度为 n 的事件序列，每个事件以 a_i 年为周期发生，\n问题是在以下条件下找到第 n 个事件发生的年份 Y_n：\n事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années,\nle problème est de trouver l'année Y_n lorsque le nième événement se produit, sous la\ncondition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année\nsuivant immédiatement la survenue de l'événement i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten,\nbesteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der\nBedingung, dass der Countdown für Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten von Ereignis i beginnen kann.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da jerin abubuwan da suka faru n, kowanne yana faruwa tare da maimaitawar a_i shekaru,\nmatsalar ita ce nemo shekarar Y_n lokacin da abin da ya faru na nth ya faru, a ƙarƙashin\nsharadi cewa ƙidayar lokaci don abin da ya faru i+1 na iya farawa kawai a cikin shekara\nnan take bayan faruwar abin da ya faru i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nकिसी अनुक्रम में n घटनाएं दी गई हैं, प्रत्येक a_i वर्षों की आवृत्ति के साथ घटित होती हैं,\nसमस्या यह है कि वर्ष Y_n का पता लगाना है जब nth घटना घटित होती है, इस शर्त के तहत कि\nघटना i+1 के लिए उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद के वर्ष में ही शुरू हो सकती है।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott n esemény sorozata, amelyek mindegyike a_i évenkénti periodicitással fordul elő,\na feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a\nfeltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény\nbekövetkezését követő évben kezdődhet meg.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9918511886180437",
      "hy": "0.9599219507578285",
      "bn": "0.9577685987970294",
      "bg": "0.9918511886180437",
      "zh": "0.9531341547467234",
      "fr": "0.9984473063114503",
      "de": "0.9849096526920175",
      "ha": "0.9689508933581504",
      "hi": "0.9704396280640069",
      "hu": "0.9564602204771525"
    },
    "canonical_solution": "year := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}",
    "instruction": {
      "en": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nՏվեք Go կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nগো কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Go cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func apocalypseYear(n int, signs []int) int\nyear := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9229258505077944",
      "bn": "0.9223740553092795",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestApocalypseYear(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(36, apocalypseYear(6, []int{3, 2, 4, 5, 9, 18}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 1, 1, 1, 1}))\n\tassert.Equal(2012, apocalypseYear(6, []int{50, 30, 711, 200, 503, 1006}))\n\tassert.Equal(2, apocalypseYear(2, []int{1, 2}))\n\tassert.Equal(6, apocalypseYear(3, []int{3, 1, 2}))\n\tassert.Equal(4, apocalypseYear(3, []int{2, 3, 4}))\n\tassert.Equal(4, apocalypseYear(4, []int{1, 2, 3, 4}))\n\tassert.Equal(13, apocalypseYear(4, []int{5, 7, 11, 13}))\n\tassert.Equal(10, apocalypseYear(5, []int{2, 2, 2, 2, 2}))\n\tassert.Equal(15, apocalypseYear(3, []int{6, 10, 15}))\n\tassert.Equal(14, apocalypseYear(3, []int{4, 6, 14}))\n\tassert.Equal(800, apocalypseYear(4, []int{50, 30, 711, 200}))\n\tassert.Equal(6, apocalypseYear(6, []int{1, 1, 1, 1, 1, 1}))\n\tassert.Equal(1999998, apocalypseYear(2, []int{1000000, 999999}))\n}",
    "entry_point": "apocalypseYear",
    "signature": "func apocalypseYear(n int, signs []int) int",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the nth event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n",
      "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնելն է Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "bn": "প্রদত্ত n ঘটনাবলীর একটি ক্রমে, প্রতিটি a_i বছরের একটি পর্যায়ক্রমিকতার সাথে ঘটে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন nth ঘটনা ঘটে, এই শর্তের অধীনে যে ইভেন্ট i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ইভেন্ট i এর ঘটনার পরবর্তী বছরেই শুরু হতে পারে।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че обратното броене за събитие i+1 може да започне само в годината непосредствено след настъпването на събитие i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "zh": "给定一个由 n 个事件组成的序列，每个事件以 a_i 年的周期性发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生的下一年开始。",
      "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le nième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement l'occurrence de l'événement i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "de": "Angenommen, es gibt eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten des Ereignisses i beginnen kann.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaituwa na shekaru a_i, matsalar ita ce gano shekarar Y_n lokacin da abin n na n ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya fara ne kawai a cikin shekarar da ke biye da faruwar abin i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "hi": "दिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ घटित होती है, समस्या यह है कि nth घटना के घटित होने वाले वर्ष Y_n को खोजना है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है।",
      "hu": "Adott n esemény sorozata, amelyek mindegyike a_i évek periodicitással következik be, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36"
    },
    "docstring_bertscore": {
      "sq": "0.9837117128639961",
      "hy": "0.943686697933561",
      "bn": "0.9933017862907415",
      "bg": "0.9798547081250606",
      "zh": "0.87645964958116",
      "fr": "0.9912294755254045",
      "de": "0.9570620705316882",
      "ha": "0.9359315719668158",
      "hi": "0.8479667173128483",
      "hu": "0.958421894120253"
    }
  },
  {
    "task_id": "Go/33",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: New Modulo Operation \"⊕\".\nIn this operation, for x ⊕ y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! ⊕ p,\nwhere n! is the factorial of n (product of all positive integers ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblemi: Operacioni i Ri Modulo \"⊕\".\nNë këtë operacion, për x ⊕ y:\n- Nëse x nuk është shumëfish i y, rezultati është x % y.\n- Nëse x është shumëfish i y, vazhdo të pjestosh x me y (x = x / y) derisa x të mos jetë më shumëfish.\n  Le të jetë vlera përfundimtare x'. Rezultati është x' % y.\n\nShembuj:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDuke pasur një numër të thjeshtë p dhe një numër të plotë n, llogarit vlerën e n! ⊕ p,\nku n! është faktorieli i n (prodhimi i të gjithë numrave të plotë pozitivë ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԽնդիր: Նոր Մոդուլո Գործողություն \"⊕\".\nԱյս գործողության համար, x ⊕ y:\n- Եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n- Եթե x-ը y-ի բազմապատիկ է, շարունակեք բաժանել x-ը y-ի վրա (x = x / y), մինչև x-ը այլևս բազմապատիկ չլինի:\n  Թող վերջնական արժեքը լինի x': Արդյունքը x' % y է:\n\nՕրինակներ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nՏրված է պարզ թիվ p և ամբողջ թիվ n, հաշվեք n! ⊕ p-ի արժեքը,\nորտեղ n! n-ի ֆակտորիալն է (բոլոր դրական ամբողջ թվերի արտադրյալը ≤ n):\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nসমস্যা: নতুন মডুলো অপারেশন \"⊕\"।\nএই অপারেশনে, x ⊕ y এর জন্য:\n- যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হবে x % y।\n- যদি x, y এর গুণিতক হয়, তাহলে x কে y দ্বারা ভাগ করতে থাকুন (x = x / y) যতক্ষণ না x আর গুণিতক থাকে।\n  চূড়ান্ত মানটিকে x' বলা যাক। ফলাফল হবে x' % y।\n\nউদাহরণ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nএকটি মৌলিক সংখ্যা p এবং একটি পূর্ণসংখ্যা n দেওয়া আছে, n! ⊕ p এর মান গণনা করুন,\nযেখানে n! হল n এর ফ্যাক্টোরিয়াল (সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল ≤ n)।\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nПроблем: Нова операция за модуло \"⊕\".\nПри тази операция, за x ⊕ y:\n- Ако x не е кратно на y, резултатът е x % y.\n- Ако x е кратно на y, продължавайте да делите x на y (x = x / y), докато x вече не е кратно.\n  Нека крайната стойност бъде x'. Резултатът е x' % y.\n\nПримери:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nДадено е просто число p и цяло число n, изчислете стойността на n! ⊕ p,\nкъдето n! е факториелът на n (произведение на всички положителни цели числа ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n问题: 新的取模运算 \"⊕\"。\n在此运算中，对于 x ⊕ y:\n- 如果 x 不是 y 的倍数，结果是 x % y。\n- 如果 x 是 y 的倍数，持续将 x 除以 y (x = x / y)，直到 x 不再是倍数。\n  设最终值为 x'。结果是 x' % y。\n\n例子:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\n给定一个素数 p 和一个整数 n，计算 n! ⊕ p 的值，\n其中 n! 是 n 的阶乘（小于等于 n 的所有正整数的乘积）。\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblème : Nouvelle opération de modulo \"⊕\".\nDans cette opération, pour x ⊕ y :\n- Si x n'est pas un multiple de y, le résultat est x % y.\n- Si x est un multiple de y, continuez à diviser x par y (x = x / y) jusqu'à ce que x ne soit plus un multiple.\n  Que la valeur finale soit x'. Le résultat est x' % y.\n\nExemples :\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nÉtant donné un nombre premier p et un entier n, calculez la valeur de n! ⊕ p,\noù n! est la factorielle de n (produit de tous les entiers positifs ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: Neue Modulo-Operation \"⊕\".\nIn dieser Operation, für x ⊕ y:\n- Wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n- Wenn x ein Vielfaches von y ist, teile x durch y (x = x / y), bis x kein Vielfaches mehr ist.\n  Der Endwert sei x'. Das Ergebnis ist x' % y.\n\nBeispiele:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGegeben eine Primzahl p und eine ganze Zahl n, berechne den Wert von n! ⊕ p,\nwobei n! die Fakultät von n ist (Produkt aller positiven ganzen Zahlen ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nMatsala: Sabon Aiki na Modulo \"⊕\".\nA cikin wannan aikin, don x ⊕ y:\n- Idan x ba shi ne ninki na y ba, sakamakon shi ne x % y.\n- Idan x ninki ne na y, ci gaba da raba x da y (x = x / y) har sai x ba shi ne ninki ba.\n  Bari ƙimar ƙarshe ta zama x'. Sakamakon shi ne x' % y.\n\nMisalai:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nAn ba da lamba mai firamare p da kuma cikakken lamba n, ƙididdige ƙimar n! ⊕ p,\ninda n! shine factorial na n (samfurin duk lambobin kirki ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nसमस्या: नया माड्यूलो ऑपरेशन \"⊕\"।\nइस ऑपरेशन में, x ⊕ y के लिए:\n- यदि x, y का गुणज नहीं है, तो परिणाम x % y है।\n- यदि x, y का गुणज है, तो x को y से विभाजित करते रहें (x = x / y) जब तक कि x अब गुणज न हो।\n  अंतिम मान को x' मानें। परिणाम x' % y है।\n\nउदाहरण:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nएक अभाज्य संख्या p और एक पूर्णांक n दिया गया है, n! ⊕ p का मान गणना करें,\nजहाँ n! n का फैक्टोरियल है (सभी धनात्मक पूर्णांकों का गुणनफल ≤ n)।\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFeladat: Új Modulo Művelet \"⊕\".\nEbben a műveletben, x ⊕ y esetén:\n- Ha x nem többszöröse y-nak, az eredmény x % y.\n- Ha x többszöröse y-nak, oszd el x-et y-nal (x = x / y), amíg x már nem többszöröse.\n  Legyen a végső érték x'. Az eredmény x' % y.\n\nPéldák:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nAdott egy prímszám p és egy egész szám n, számítsd ki az n! ⊕ p értékét,\nahol n! az n faktoriálisa (az összes pozitív egész szám szorzata ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9945124384631492",
      "hy": "0.9731487478309417",
      "bn": "0.9789318713747726",
      "bg": "0.975598456320245",
      "zh": "0.9826818143383301",
      "fr": "0.997084900527932",
      "de": "0.9890467262682121",
      "ha": "0.9870401621589977",
      "hi": "0.9887237532686494",
      "hu": "0.9920937163132874"
    },
    "canonical_solution": "pj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nগো কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\n将以下 Go 代码的功能用中文进行简洁的自然语言描述（文档字符串），字数不超过 500 个字符。",
      "fr": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func newModuloFactorial(n, p uint64) uint64\npj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8888706716793628",
      "bn": "0.9071744612917277",
      "bg": "0.8329297550441628",
      "zh": "0.8394051054659001",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.94069234493946",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestNewModuloFactorial(t *testing.T) {\n\t// Test cases\n\tassert.Equal(t, uint64(6), newModuloFactorial(3, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(10, 3))\n\tassert.Equal(t, uint64(4), newModuloFactorial(11, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(45, 7))\n\tassert.Equal(t, uint64(2), newModuloFactorial(14, 7))\n\tassert.Equal(t, uint64(3152), newModuloFactorial(1919, 10007))\n\tassert.Equal(t, uint64(3679), newModuloFactorial(810, 10007))\n\tassert.Equal(t, uint64(1), newModuloFactorial(1, 2))\n\tassert.Equal(t, uint64(10), newModuloFactorial(5, 11))\n\tassert.Equal(t, uint64(5), newModuloFactorial(6, 13))\n\tassert.Equal(t, uint64(13), newModuloFactorial(8, 17))\n\tassert.Equal(t, uint64(16), newModuloFactorial(15, 19))\n\tassert.Equal(t, uint64(1), newModuloFactorial(21, 23))\n\tassert.Equal(t, uint64(28), newModuloFactorial(30, 29))\n\tassert.Equal(t, uint64(100), newModuloFactorial(100, 101))\n}",
    "entry_point": "newModuloFactorial",
    "signature": "func newModuloFactorial(n, p uint64) uint64",
    "docstring": {
      "en": "Problem: New Modulo Operation \"⊕\".\nIn this operation, for x ⊕ y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! ⊕ p,\nwhere n! is the factorial of n (product of all positive integers ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "sq": "Problemë: Operacioni i Ri Modulo \"⊕\".\nNë këtë operacion, për x ⊕ y:\n- Nëse x nuk është shumëfish i y, rezultati është x % y.\n- Nëse x është shumëfish i y, vazhdoni të ndani x me y (x = x / y) derisa x të mos jetë më shumëfish.\n  Le të jetë vlera përfundimtare x'. Rezultati është x' % y.\n\nShembuj:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDuke pasur një numër të thjeshtë p dhe një numër të plotë n, llogaritni vlerën e n! ⊕ p,\nku n! është faktoriali i n (prodhimi i të gjithë numrave të plotë pozitivë ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hy": "Խնդիր: Նոր Մոդուլո Գործողություն \"⊕\".\nԱյս գործողության մեջ, x ⊕ y-ի համար՝\n- Եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է։\n- Եթե x-ը y-ի բազմապատիկ է, շարունակեք բաժանել x-ը y-ի վրա (x = x / y), մինչև x-ը այլևս բազմապատիկ չլինի։\n  Թող վերջնական արժեքը լինի x': Արդյունքը x' % y է։\n\nՕրինակներ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nՏրված է պարզ թիվ p և ամբողջ թիվ n, հաշվեք n! ⊕ p-ի արժեքը,\nորտեղ n! n-ի ֆակտորիալն է (բոլոր դրական ամբողջ թվերի արտադրյալը ≤ n):\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bn": "সমস্যা: নতুন মডুলো অপারেশন \"⊕\"।\nএই অপারেশনে, x ⊕ y এর জন্য:\n- যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হবে x % y।\n- যদি x, y এর গুণিতক হয়, তাহলে x কে y দিয়ে ভাগ করতে থাকুন (x = x / y) যতক্ষণ না x আর গুণিতক থাকে।\n  চূড়ান্ত মানটিকে x' বলুন। ফলাফল হবে x' % y।\n\nউদাহরণসমূহ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nএকটি মৌলিক সংখ্যা p এবং একটি পূর্ণসংখ্যা n দেওয়া আছে, n! ⊕ p এর মান গণনা করুন,\nযেখানে n! হল n এর ফ্যাক্টোরিয়াল (n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল)।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bg": "Проблем: Нова операция за модул \"⊕\".\nВ тази операция, за x ⊕ y:\n- Ако x не е кратно на y, резултатът е x % y.\n- Ако x е кратно на y, продължавайте да делите x на y (x = x / y), докато x вече не е кратно.\n  Нека крайната стойност бъде x'. Резултатът е x' % y.\n\nПримери:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nДадено е просто число p и цяло число n, изчислете стойността на n! ⊕ p,\nкъдето n! е факториелът на n (произведение на всички положителни цели числа ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "zh": "问题：新的模运算 \"⊕\"。\n在此运算中，对于 x ⊕ y：\n- 如果 x 不是 y 的倍数，结果是 x % y。\n- 如果 x 是 y 的倍数，继续将 x 除以 y（x = x / y），直到 x 不再是倍数。\n  设最终值为 x'。结果是 x' % y。\n\n示例：\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\n给定一个素数 p 和一个整数 n，计算 n! ⊕ p 的值，\n其中 n! 是 n 的阶乘（所有小于等于 n 的正整数的乘积）。\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "fr": "Problème : Nouvelle opération de modulo \"⊕\".\nDans cette opération, pour x ⊕ y :\n- Si x n'est pas un multiple de y, le résultat est x % y.\n- Si x est un multiple de y, continuez à diviser x par y (x = x / y) jusqu'à ce que x ne soit plus un multiple.\n  Laissez la valeur finale être x'. Le résultat est x' % y.\n\nExemples :\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nÉtant donné un nombre premier p et un entier n, calculez la valeur de n! ⊕ p,\noù n! est la factorielle de n (produit de tous les entiers positifs ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "de": "Problem: Neue Modulo-Operation \"⊕\".\nIn dieser Operation, für x ⊕ y:\n- Wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n- Wenn x ein Vielfaches von y ist, teile x durch y (x = x / y), bis x kein Vielfaches mehr ist.\n  Der Endwert sei x'. Das Ergebnis ist x' % y.\n\nBeispiele:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGegeben eine Primzahl p und eine ganze Zahl n, berechne den Wert von n! ⊕ p,\nwobei n! die Fakultät von n ist (Produkt aller positiven ganzen Zahlen ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "ha": "Matsala: Sabon Aiki na Modulo \"⊕\".  \nA cikin wannan aikin, don x ⊕ y:  \n- Idan x ba ya raba y, sakamakon shi ne x % y.  \n- Idan x yana raba y, ci gaba da raba x da y (x = x / y) har sai x ba ya raba y.  \n  Bari ƙimar ƙarshe ta zama x'. Sakamakon shi ne x' % y.  \n\nMisalai:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nAn ba da lamba mai firamare p da kuma cikakken lamba n, a lissafta ƙimar n! ⊕ p,  \ninda n! shine factorial na n (samfurin duk lambobin da suka fi ko daidai da n).  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hi": "समस्या: नया मॉड्यूलो ऑपरेशन \"⊕\"।\nइस ऑपरेशन में, x ⊕ y के लिए:\n- यदि x, y का गुणज नहीं है, तो परिणाम x % y है।\n- यदि x, y का गुणज है, तो x को y से विभाजित करते रहें (x = x / y) जब तक कि x अब गुणज न रहे।\n  अंतिम मान को x' मान लें। परिणाम x' % y है।\n\nउदाहरण:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nएक अभाज्य संख्या p और एक पूर्णांक n दिए गए हैं, n! ⊕ p का मान गणना करें,\nजहाँ n! n का फैक्टोरियल है (सभी धनात्मक पूर्णांकों का गुणनफल जो n से कम या उसके बराबर हैं)।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hu": "Probléma: Új Modulo Művelet \"⊕\".  \nEbben a műveletben, x ⊕ y esetén:  \n- Ha x nem osztható maradék nélkül y-nal, az eredmény x % y.  \n- Ha x osztható maradék nélkül y-nal, folyamatosan oszd el x-et y-nal (x = x / y), amíg x már nem osztható maradék nélkül.  \n  Legyen a végső érték x'. Az eredmény x' % y.  \n\nPéldák:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nAdott egy prímszám p és egy egész szám n, számítsd ki az n! ⊕ p értékét,  \nahol n! az n faktoriálisa (az összes pozitív egész szám szorzata, amely ≤ n).  \n\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.993611848315537",
      "hy": "0.9741546120805025",
      "bn": "0.9631894205258524",
      "bg": "0.9636285922983205",
      "zh": "0.978627569631027",
      "fr": "0.9957133577468861",
      "de": "0.9930395941877754",
      "ha": "0.9534609017235257",
      "hi": "0.9733064603534834",
      "hu": "0.9957111728126947"
    }
  },
  {
    "task_id": "Go/34",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni më së shumti një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար:\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দ্বারা প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由n个整数组成的数组a。你最多可以执行一次操作，在其中选择三个整数i, j, x (1 <= i <= j <= n)，并将从a[i]到a[j]的所有元素替换为x，代价为(j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSie haben ein Array a von n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] mit x ersetzen, zu einem Kostenaufwand von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba ku wani jerin a na lambobi n. Kuna iya yin aiki ɗaya kawai inda kuke zaɓar lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwa a cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nआपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-szel helyettesíted, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9971337636016666",
      "hy": "0.9643603466220532",
      "bn": "0.9962768721378821",
      "bg": "0.9902945223218733",
      "zh": "0.9870050045815545",
      "fr": "0.9986211078948558",
      "de": "0.9906135227138153",
      "ha": "0.9758523059472076",
      "hi": "0.9970827155937406",
      "hu": "0.9791561250749609"
    },
    "canonical_solution": "p, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}",
    "instruction": {
      "en": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nՏրամադրել Go կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nДайте кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "func makeEqualAgain(n int, a []int) int\np, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9028075723646758",
      "bn": "0.8784854808373347",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9528896407476694",
      "hi": "0.9188825304714482",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestMakeEqualAgain(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, makeEqualAgain(3, []int{1, 2, 1}))\n\tassert.Equal(1, makeEqualAgain(5, []int{5, 5, 1, 5, 5}))\n\tassert.Equal(0, makeEqualAgain(4, []int{1, 1, 1, 1}))\n\tassert.Equal(1, makeEqualAgain(6, []int{2, 2, 2, 3, 2, 2}))\n\tassert.Equal(0, makeEqualAgain(1, []int{1}))\n\tassert.Equal(1, makeEqualAgain(2, []int{1, 2}))\n\tassert.Equal(2, makeEqualAgain(4, []int{1, 2, 2, 1}))\n\tassert.Equal(2, makeEqualAgain(7, []int{4, 4, 4, 3, 3, 4, 4}))\n\tassert.Equal(3, makeEqualAgain(6, []int{5, 4, 4, 4, 5, 5}))\n\tassert.Equal(5, makeEqualAgain(7, []int{1, 2, 1, 2, 1, 2, 1}))\n\tassert.Equal(4, makeEqualAgain(6, []int{1, 2, 3, 4, 5, 1}))\n\tassert.Equal(0, makeEqualAgain(7, []int{1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(2, makeEqualAgain(8, []int{8, 8, 8, 1, 2, 8, 8, 8}))\n\tassert.Equal(2, makeEqualAgain(3, []int{1, 2, 3}))\n\tassert.Equal(6, makeEqualAgain(7, []int{4, 3, 2, 7, 1, 1, 3}))\n\tassert.Equal(7, makeEqualAgain(9, []int{9, 9, 2, 9, 2, 5, 5, 5, 3}))\n}",
    "entry_point": "makeEqualAgain",
    "signature": "func makeEqualAgain(n int, a []int) int",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hy": "Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը x-ով՝ (j - i + 1) արժեքով։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "bg": "Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "zh": "您有一个包含 n 个整数的数组 a。您最多可以执行一次操作，其中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "fr": "Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "de": "Sie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "ha": "An ba ku wani tsari a na lambobi n. Kuna iya aiwatar da aiki ɗaya kawai inda za ku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin duk abubuwan daga a[i] zuwa a[j] da x, a farashin (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hi": "आपको n पूर्णांकों की एक सरणी a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को सरणी में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hu": "Adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, amely során kiválasztasz három egész számot: i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9938730472665979",
      "hy": "0.9542635670932876",
      "bn": "0.9974678599025673",
      "bg": "0.9876114231348541",
      "zh": "0.9886035818881233",
      "fr": "0.9927418472466042",
      "de": "0.9895728981475735",
      "ha": "0.9717640954447475",
      "hi": "0.9887263354636029",
      "hu": "0.9721474520801449"
    }
  },
  {
    "task_id": "Go/35",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh,\npërcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, duke marrë radhën me Dan për të lëvizur\nnjë numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin ngjitur në të djathtë. Lojtari i detyruar të\nlëvizë gurët vetëm në grumbullin e fundit humbet. Duke supozuar lojë optimale, gjeni fituesin.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով քարերի N կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրում կա քարերի դրական քանակ,\nորոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է խաղում, հերթափոխով Դենի հետ տեղափոխելով\nդրական քանակի քարեր ձախից աջ հարակից կույտ։ Վերջին կույտում միայն քարեր տեղափոխելու հարկադրանքով խաղացողը պարտվում է։ Ենթադրելով օպտիմալ խաղ, պարզեք հաղթողին։\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nধরা যাক N সংখ্যক পাথরের স্তূপের একটি ক্রম রয়েছে যেগুলি 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে,\nচার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, ড্যানের সাথে পালা করে পালা করে\nবামদিকের প্রথম খালি না থাকা স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরাতে। যে খেলোয়াড়কে শুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয় সে হেরে যায়। সর্বোত্তম খেলার অনুমান করে, বিজয়ী কে তা খুঁজে বের করুন।\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни,\nопределете победителя в игра, играна от Чарли и Дан. Чарли започва пръв, като се редува с Дан да премества\nположителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, който е принуден\nда премества камъни само в последната купчина, губи. Приемайки оптимална игра, намерете победителя.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，\n确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，与Dan轮流\n从最左边的非空堆中移动一个正数的石头到相邻的右边堆。被迫\n只能在最后一堆移动石头的玩家输掉游戏。假设双方都采取最佳策略，找出获胜者。\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres,\ndéterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer\nun nombre positif de pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Le joueur forcé de\ndéplacer des pierres uniquement dans le dernier tas perd. En supposant un jeu optimal, trouvez le gagnant.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält,\nbestimme den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab,\num eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen zu bewegen. Der Spieler,\nder gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert. Angenommen, es wird optimal gespielt, finde den Gewinner heraus.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadi mai kyau na duwatsu,\nkayyade wanda ya lashe wasan da Charlie da Dan suka buga. Charlie ne ke farawa, yana yin juyi tare da Dan don motsawa\nadadi mai kyau na duwatsu daga mafi hagu tarin da ba komai a ciki zuwa tarin dama kusa. Dan wasan da aka tilasta\nmotsi duwatsu a cikin tarin karshe ya yi rashin nasara. Ana tsammanin wasa mafi kyau, gano wanda ya yi nasara.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n1 से N तक क्रमांकित पत्थरों के N ढेरों की एक श्रृंखला दी गई है, जिनमें से प्रत्येक में पत्थरों की एक सकारात्मक संख्या है,\nचार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, डैन के साथ बारी-बारी से\nबाएँ से दाएँ सबसे निकटतम खाली न होने वाले ढेर से दाएँ के आसन्न ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करता है। \nजिस खिलाड़ी को केवल अंतिम ढेर में पत्थरों को स्थानांतरित करने के लिए मजबूर किया जाता है, वह हार जाता है। \nसर्वोत्तम खेल मानते हुए, विजेता का पता लगाएं।\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy N kövekből álló sorozat, amelyeket 1-től N-ig számoztak, mindegyik egy pozitív számú követ tartalmaz,\nhatározd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, majd Dan következik, hogy felváltva\npozitív számú követ mozgassanak a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos,\naki kénytelen csak az utolsó halomban köveket mozgatni, veszít. Feltételezve az optimális játékot, találd meg a győztest.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9876616766212558",
      "hy": "0.9600141152546288",
      "bn": "0.9586052299619483",
      "bg": "0.9818412105657905",
      "zh": "0.9515677555618822",
      "fr": "0.9850292281814005",
      "de": "0.9620592136577639",
      "ha": "0.9649993405578423",
      "hi": "0.9796717695441275",
      "hu": "0.9701861756978064"
    },
    "canonical_solution": "if n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}",
    "instruction": {
      "en": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 символа.",
      "zh": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\n将以下 Go 代码的自然语言描述（文档字符串）翻译成中文，字数不超过500个字符。",
      "fr": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func GameWinner(n int, piles []int) string\nif n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386492328401351",
      "hy": "0.9411337016461195",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8318029248925518",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.91027269797511",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestGameWinner(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Dan\", GameWinner(3, []int{1, 2, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(5, []int{5, 5, 5, 5, 5}))\n\tassert.Equal(\"Charlie\", GameWinner(3, []int{2, 1, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(4, []int{3, 3, 3, 3}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{2, 1}))\n\tassert.Equal(\"Dan\", GameWinner(11, []int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{2, 2, 2, 2, 2, 2, 2, 2, 2, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{10, 10, 10, 10, 10, 10, 10, 10, 10, 10}))\n\tassert.Equal(\"Dan\", GameWinner(10, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}",
    "entry_point": "GameWinner",
    "signature": "func GameWinner(n int, piles []int) string",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, duke marrë radhë me Dan për të lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin ngjitur në të djathtë. Lojtari që detyrohet të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë optimale, gjeni fituesin.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hy": "Տրված է N քանակությամբ քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրում կա քարերի դրական քանակ, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է սկսում, հերթափոխով Դենի հետ տեղափոխելով քարերի դրական քանակը ձախից աջ ամենամոտ դատարկ կույտից դեպի հարևան աջ կույտ: Խաղացողը, ով ստիպված է տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով օպտիմալ խաղ, պարզեք, թե ով է հաղթողը:\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া আছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, ড্যানের সাথে পালা করে পালা করে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। যে খেলোয়াড়কে শুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয় সে হেরে যায়। সর্বোত্তম খেলা ধরে নিয়ে, বিজয়ী কে তা খুঁজে বের করুন।\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв, като се редува с Дан да премества положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, принуден да премества камъни само в последната купчина, губи. Приемайки оптимална игра, определете победителя.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的赢家。Charlie先开始，与Dan轮流从最左边的非空堆移动正数的石头到相邻的右边堆。被迫只能在最后一堆移动石头的玩家输掉比赛。在假设最佳玩法的情况下，找出赢家。\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "fr": "Étant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer un nombre positif de pierres de la pile la plus à gauche non vide vers la pile adjacente à droite. Le joueur forcé de ne déplacer des pierres que dans la dernière pile perd. En supposant un jeu optimal, trouvez le gagnant.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "de": "Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt zuerst und wechselt sich mit Dan ab, um eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen zu bewegen. Der Spieler, der gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert. Bei optimalem Spiel finden Sie heraus, wer der Gewinner ist.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, a tantance wanda ya lashe wasan da Charlie da Dan suka buga. Charlie yana farawa, yana juyawa tare da Dan don motsa adadin duwatsu masu kyau daga tarin da ba komai na hagu zuwa tarin da ke kusa da shi na dama. Dan wasan da aka tilasta shi motsa duwatsu a cikin tarin karshe ya yi rashin nasara. Idan ana tsammanin wasa mai kyau, gano wanda ya yi nasara.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hi": "N पत्थरों के ढेरों की एक अनुक्रमणिका दी गई है, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, \nचार्ली और डैन द्वारा खेले जाने वाले खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, डैन के साथ बारी-बारी से \nबाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सन्निकट ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करता है। \nवह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित करने के लिए मजबूर होता है, हार जाता है। इष्टतम खेल को मानते हुए, विजेता का पता लगाएं।\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozd meg a győztest egy játékban, amelyet Charlie és Dan játszanak. Charlie kezd, és felváltva mozgatnak pozitív számú követ a balról a legközelebbi nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, akit arra kényszerítenek, hogy csak az utolsó halomban mozgasson köveket. Feltételezve az optimális játékot, derítsd ki, ki a győztes.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.974904044508147",
      "hy": "0.9679849538151778",
      "bn": "0.9420658740243162",
      "bg": "0.9851899201596577",
      "zh": "0.9541817313763014",
      "fr": "0.9819522449487891",
      "de": "0.9512515359952747",
      "ha": "0.9097232863411675",
      "hi": "0.9451223983276811",
      "hu": "0.9468874278935571"
    }
  },
  {
    "task_id": "Go/36",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից։ Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել մի թիվ i և վճարել արժեք C_i՝ i քայլ աջ գնալու և այն դիրքում դուռը բացելու համար։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար։\nԽնդիրը կայանում է որոշել բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը։\n\nՕրինակ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nnটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে হয়। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定 n 个门按圆形排列，玩家从门 1 前开始。每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind n Türen, die in einem Kreis angeordnet sind. Der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba n kofofi da aka tsara a cikin da'ira, mai kunnawa yana farawa a gaban kofa ta 1. Kowace juyawa, mai kunnawa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shine a tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk kofofin.\n\nMisali:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n दरवाजे एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू होता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और उस स्थिति पर दरवाजा खोलने के लिए i कदम दाईं ओर जाने की लागत C_i का भुगतान कर सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizethet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az adott pozícióban lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9977493191524937",
      "hy": "0.9789638508661191",
      "bn": "0.9705282172139484",
      "bg": "0.9947358976418134",
      "zh": "0.9902279811442266",
      "fr": "0.9970386196491509",
      "de": "0.9818733886875182",
      "ha": "0.9869477990318165",
      "hi": "0.9614247882207385",
      "hu": "0.9836531169015907"
    },
    "canonical_solution": "return int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}",
    "instruction": {
      "en": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrale (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nনিচে দেওয়া Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Go a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func MinTotalCost(n int, C []int) int64\nreturn int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386492328401351",
      "hy": "0.9168924526838597",
      "bn": "0.8641886619015866",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestMinTotalCost(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(15), MinTotalCost(5, []int{4, 3, 3, 3, 3})) // Note the 0-indexed array for slice in Golang\n\tassert.Equal(int64(3), MinTotalCost(3, []int{1, 1, 1}))\n\tassert.Equal(int64(11), MinTotalCost(4, []int{5, 4, 3, 2}))\n\tassert.Equal(int64(391), MinTotalCost(4, []int{100, 99, 98, 97}))\n\tassert.Equal(int64(35), MinTotalCost(6, []int{10, 9, 8, 7, 6, 5}))\n\tassert.Equal(int64(14), MinTotalCost(7, []int{2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(56), MinTotalCost(8, []int{9, 7, 7, 7, 7, 7, 7, 7}))\n\tassert.Equal(int64(18), MinTotalCost(9, []int{3, 2, 2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(50), MinTotalCost(10, []int{6, 5, 5, 5, 5, 5, 5, 5, 5, 5}))\n\tassert.Equal(int64(11), MinTotalCost(11, []int{8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n}",
    "entry_point": "MinTotalCost",
    "signature": "func MinTotalCost(n int, C []int) int64",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n",
      "sq": "Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1. Çdo herë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n. Detyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hy": "Տրված են n դռներ, որոնք դասավորված են շրջանաձև: Խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այդ դիրքում դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը որոշելու մեջ:\n\nՕրինակ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডান দিকে যেতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n। \nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "zh": "给定 n 个门按圆形排列，玩家从门 1 前面开始。每一回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kostenbetrag C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "ha": "An ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don motsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne ƙayyade mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofin.\n\nMisali:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} के लिए 1 <= i < n।\n\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén. A feladat az, hogy meghatározzuk az összes ajtó kinyitásához szükséges minimális összköltséget.\n\nPélda:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9807004762875071",
      "hy": "0.9670905212093777",
      "bn": "0.9571955501477437",
      "bg": "0.9975091750218225",
      "zh": "0.9904945431155754",
      "fr": "0.9975091750218225",
      "de": "0.9879163207697426",
      "ha": "0.9837146923197115",
      "hi": "0.9655394165638762",
      "hu": "0.9739593584159452"
    }
  },
  {
    "task_id": "Go/37",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që është tashmë në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ձեռքսեղմումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի արդեն դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, ում ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մտնելու կարգը։\n\nՕրինակներ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nশ্রেণীকক্ষে প্রবেশ করা ছাত্রদের একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি করমর্দন হয় তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে করমর্দন করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е последователност от студентски идентификатори, които влизат в класна стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък идентификатор. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中所有ID号较小的学生握手。序列表示学生进入教室的顺序。\n\n例子:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Student wird jedem Studenten, der bereits im Klassenraum ist und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da jerin lambobin dalibai suna shiga aji, inda lambobin ke daga 0 zuwa N-1, ƙididdige jimillar yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai gaisa da duk daliban da suka riga sun shiga aji da ƙaramin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nछात्र आईडी के अनुक्रम को कक्षा में प्रवेश करते हुए दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल कितनी हाथ मिलाने की घटनाएँ होती हैं, यह गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी नंबर के साथ हैं। अनुक्रम यह दर्शाता है कि छात्र किस क्रम में कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy osztályterembe belépő diákok azonosítóinak sorozata alapján, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások összes számát, amelyek megtörténnek. Minden diák kezet fog minden már az osztályteremben lévő diákkal, akinek kisebb az azonosítója. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.987884738539158",
      "hy": "0.9828321775367735",
      "bn": "0.9653376080967447",
      "bg": "0.9879681632991927",
      "zh": "0.9848168923040742",
      "fr": "0.9974640859253275",
      "de": "0.9833102808639246",
      "ha": "0.939342850130709",
      "hi": "0.955375897227083",
      "hu": "0.9801468934155629"
    },
    "canonical_solution": "var ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nՏվյալ Go կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 символа.",
      "zh": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func CountHandshakes(n int, order []int) int64\nvar ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8829604246916697",
      "bn": "0.873551104911666",
      "bg": "0.8329297550441628",
      "zh": "0.8358629298809049",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.91027269797511",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCountHandshakes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), CountHandshakes(4, []int{2, 1, 3, 0}))\n\tassert.Equal(int64(15), CountHandshakes(6, []int{0, 1, 2, 3, 4, 5}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{1, 2, 0}))\n\tassert.Equal(int64(0), CountHandshakes(4, []int{3, 2, 1, 0}))\n\tassert.Equal(int64(6), CountHandshakes(4, []int{0, 1, 2, 3}))\n\tassert.Equal(int64(0), CountHandshakes(6, []int{5, 4, 3, 2, 1, 0}))\n\tassert.Equal(int64(5), CountHandshakes(4, []int{0, 2, 1, 3}))\n\tassert.Equal(int64(3), CountHandshakes(5, []int{3, 1, 4, 2, 0}))\n\tassert.Equal(int64(4), CountHandshakes(4, []int{1, 0, 3, 2}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{2, 0, 1}))\n\tassert.Equal(int64(7), CountHandshakes(5, []int{1, 3, 0, 2, 4}))\n\tassert.Equal(int64(0), CountHandshakes(5, []int{4, 3, 2, 1, 0}))\n}\n\n// To run tests in Go, you can use the following command:\n// go test -v",
    "entry_point": "CountHandshakes",
    "signature": "func CountHandshakes(n int, order []int) int64",
    "docstring": {
      "en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n",
      "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hy": "Ունենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջունումների ընդհանուր թիվը։ Յուրաքանչյուր ուսանող ողջունում է բոլոր այն ուսանողներին, որոնք արդեն դասարանում են և ունեն ավելի փոքր ID։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "bn": "প্রদত্ত একটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির ক্রম, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি করমর্দন ঘটে তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে উপস্থিত প্রতিটি ছাত্রের সাথে করমর্দন করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রম নির্দেশ করে।\n\nউদাহরণ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "bg": "Дадена е последователност от студентски идентификационни номера, влизащи в класната стая, където идентификационните номера варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък идентификационен номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。该序列表示学生进入教室的顺序。\n\n示例：\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "de": "Gegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Student wird jedem Studenten die Hand schütteln, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "ha": "An ba da jerin lambobin ID na ɗalibai da ke shiga aji, inda lambobin ID ɗin ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da kowane ɗalibi da ke riga shi a cikin aji da ke da ƙaramin lamba na ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hi": "छात्र आईडी के अनुक्रम को एक कक्षा में प्रवेश करते हुए दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हाथ मिलाने की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी नंबर के साथ हैं। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hu": "Adott egy tanulói azonosítók sorozata, akik belépnek egy osztályterembe, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden olyan diákkal, aki már az osztályteremben van, és kisebb azonosítóval rendelkezik. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9879645879523341",
      "hy": "0.9456183783891252",
      "bn": "0.9247439143854067",
      "bg": "0.9760326623331873",
      "zh": "0.9628241392551293",
      "fr": "0.996538269719324",
      "de": "1",
      "ha": "1",
      "hi": "0.9484903750685086",
      "hu": "0.9595820941758778"
    }
  },
  {
    "task_id": "Go/38",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh midis\nelementeve më të shpeshta në një sekuencë.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n դրական ամբողջ թիվ, որոնք ներկայացնում են 1-ից n թվերի քանակը,\nգտեք մոդայի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը այդ թվերից\nկառուցված հաջորդականության բոլոր նախածանցների համար։ Մոդան հաջորդականության\nամենահաճախ հանդիպող տարրերի մեջ ամենամեծ թիվն է։\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tՀաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল ক্রমে সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, съставена от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователността.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tПоследователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是序列中最频繁元素中的最大数字。\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\t达到最大值的序列是 (3,2,3,1,2,2)。\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\ntrouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une\nséquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi\nles éléments les plus fréquents dans une séquence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\nSequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter\nden häufigsten Elementen in einer Sequenz.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba n lambobin da suke masu kyau wadanda ke wakiltar yawan kowanne lamba daga 1 zuwa n,\nnemo mafi girman jimillar yanayin (abin da aka fi samu) don dukkanin farkon\njerin da aka gina daga wadannan lambobin. Yanayin shine mafi girman lamba tsakanin\nabin da aka fi samu a cikin jerin.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tJerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nइन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें।\nमोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\nkeresse meg az összes prefix móduszának (leggyakrabban előforduló elem) maximális összegét\negy ezen számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat\nleggyakrabban előforduló elemei között.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9986302448923834",
      "hy": "0.9617745763217409",
      "bn": "0.9934688344411918",
      "bg": "0.982344539951333",
      "zh": "0.9834072124898696",
      "fr": "1",
      "de": "1",
      "ha": "0.9577626398855983",
      "hi": "0.9757444496503057",
      "hu": "0.9504433089748436"
    },
    "canonical_solution": "ans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nՏվեք Go կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হওয়া উচিত।",
      "bg": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func MaxModeSum(n int, counts []int) int64\nans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9229258505077944",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8881799067424754",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.935334886302187",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestMaxModeSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(17), MaxModeSum(3, []int{1, 3, 2}))\n\tassert.Equal(int64(37), MaxModeSum(4, []int{4, 1, 2, 3}))\n\tassert.Equal(int64(4), MaxModeSum(2, []int{1, 1}))\n\tassert.Equal(int64(75), MaxModeSum(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(int64(100000), MaxModeSum(1, []int{100000}))\n\tassert.Equal(int64(62), MaxModeSum(5, []int{5, 3, 2, 4, 1}))\n\tassert.Equal(int64(900000), MaxModeSum(3, []int{100000, 100000, 100000}))\n\tassert.Equal(int64(27), MaxModeSum(3, []int{2, 2, 5}))\n\tassert.Equal(int64(64), MaxModeSum(4, []int{4, 4, 4, 4}))\n\tassert.Equal(int64(126), MaxModeSum(6, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(int64(16), MaxModeSum(3, []int{3, 1, 2}))\n}",
    "entry_point": "MaxModeSum",
    "signature": "func MaxModeSum(n int, counts []int) int64",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).",
      "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n յուրաքանչյուր թվի քանակը, \nգտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների համար \nհերթականության, որը կազմված է այս թվերից։ Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի մեջ \nհերթականության մեջ։\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tՀերթականությունը, որը հասնում է իր մաքսիմալ արժեքին, (3,2,3,1,2,2) է։",
      "bn": "প্রদান করা n ধনাত্মক পূর্ণসংখ্যা যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n    >>> MaxModeSum(3, []int{1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\t达到其最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\ntrouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\nSequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter\nden häufigsten Elementen in einer Sequenz.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).",
      "ha": "An ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowane lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (abu mafi yawan faruwa) don duk farkon jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin abubuwan da suka fi yawan faruwa a cikin jerin.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tWani jeri da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, \nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें \nजो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> MaxModeSum(3, []int{1, 2, 3})\n    17\n    एक अनुक्रम जो अपनी अधिकतम मान तक पहुंचता है वह है (3,2,3,1,2,2)।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számát képviselik, \nkeresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az \nezekből a számokból felépített sorozat összes prefixére. A módusz a legnagyobb szám a \nsorozat leggyakrabban előforduló elemei között.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "sq": "0.9929815941165132",
      "hy": "0.9715297115951264",
      "bn": "0.9700773262489992",
      "bg": "0.9888705411202342",
      "zh": "0.9790276112184313",
      "fr": "1",
      "de": "1",
      "ha": "0.9484536284480172",
      "hi": "0.9762495667092774",
      "hu": "0.9460867488276055"
    }
  },
  {
    "task_id": "Go/39",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementëve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) kthen 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով ամբողջ թվերի A զանգված, խնդիրն է հաշվել բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) վերադարձնում է 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে (L, R) জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 প্রদান করে\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) връща 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n子数组的异或和是从L到R的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 返回 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemples de cas :\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) gibt 39 zurück\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani tsari A na lambobi masu cikakken lamba, aikin shi ne a lissafa jimillar XOR na dukkan ƙananan tsaruka.\nAna ayyana ƙaramar tsari ta hanyar ma'aurata na alamomi (L, R) ta yadda 1 <= L <= R <= n, inda n shine girman tsari.\nJimillar XOR na ƙaramar tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan tsaruka.\n\nMisalan lokuta:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए पूर्णांकों की एक array A के लिए, कार्य सभी उप-श्रृंखलाओं के XOR का योग गणना करना है।\nएक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है जैसे कि 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के XOR योगों का योग है।\n\nउदाहरण मामले:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 लौटाता है\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) visszaadja 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9935689441532334",
      "hy": "0.9918442365547074",
      "bn": "0.9725337881712577",
      "bg": "0.9935689441532334",
      "zh": "0.9692255991751216",
      "fr": "0.9935689441532334",
      "de": "0.9935689441532334",
      "ha": "0.9716490884541283",
      "hi": "0.9846703030828704",
      "hu": "0.9752303942241873"
    },
    "canonical_solution": "n := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "en": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nՏվեք Go կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func sumOfXorSubarrays(A []int) int64\nn := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9604707665006279",
      "bn": "0.8784854808373347",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9030844631158383",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestSumOfXorSubarrays(t *testing.T) {\n\tassert.Equal(t, int64(39), sumOfXorSubarrays([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(t, int64(4), sumOfXorSubarrays([]int{1, 1, 1}))\n\tassert.Equal(t, int64(9), sumOfXorSubarrays([]int{2, 3, 1}))\n\tassert.Equal(t, int64(74), sumOfXorSubarrays([]int{4, 5, 7, 9}))\n\tassert.Equal(t, int64(0), sumOfXorSubarrays([]int{0, 0, 0, 0}))\n\tassert.Equal(t, int64(72), sumOfXorSubarrays([]int{8, 8, 8, 8, 8}))\n\tassert.Equal(t, int64(125), sumOfXorSubarrays([]int{3, 6, 9, 12, 15}))\n\tassert.Equal(t, int64(390), sumOfXorSubarrays([]int{10, 20, 30, 40, 50}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{16, 16, 16, 16, 16, 16}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{1, 3, 5, 7, 9, 11, 13}))\n\tassert.Equal(t, int64(218), sumOfXorSubarrays([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "func sumOfXorSubarrays(A []int) int64",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) kthen 39",
      "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR-ի գումարների գումարն է:\n\nՕրինակային դեպքեր:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) վերադարձնում է 39",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা। একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার। একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল। চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 প্রদান করে",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) връща 39",
      "zh": "给定一个整数数组 A，任务是计算所有子数组的异或和之和。  \n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。  \n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和的总和。\n\n示例案例：  \n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 返回 39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) retourne 39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, sodass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel Fälle:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) gibt 39 zurück",
      "ha": "An ba da wani tsari A na lambobin cikakke, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan tsaruka.\nAna ayyana wani ƙaramin tsari ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\nJimillar XOR na wani ƙaramin tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n\nMisalan lokuta:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39",
      "hi": "Provided an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nएक उप-ऐरे को (L, R) सूचकांक की जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n ऐरे का आकार है।\nएक उप-ऐरे का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-ऐरे के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 लौटाता है।",
      "hu": "Egy A egész számokat tartalmazó tömb esetén a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) visszaadja 39"
    },
    "docstring_bertscore": {
      "sq": "0.9926256484736987",
      "hy": "0.9760292856167097",
      "bn": "0.9711866769270792",
      "bg": "0.9815458471891917",
      "zh": "0.953325634434041",
      "fr": "0.9910975849523973",
      "de": "0.9926182991496004",
      "ha": "0.9520367218915056",
      "hi": "0.9648867171317955",
      "hu": "0.9646439908061709"
    }
  },
  {
    "task_id": "Go/40",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n,\nqë mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme ligjore të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n,\nորոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলো ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন,\nযা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n,\nкоито могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.\nРазличните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，\n这些 x 可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n同一个数的不同合法表示只计算一次。\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n,\nqui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nDifférentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n,\ndie als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n,\nwanda za a iya bayyana su a matsayin x = a^b tare da a da b kasancewa lambobi masu kyau kuma b >= k.\nDaban-daban halattattun wakilcin lamba ɗaya ana kirgawa sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n,\nजो x = a^b के रूप में व्यक्त किए जा सकते हैं जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKét pozitív egész szám, n és k adott. Találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n,\namelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző legális ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9711894577524136",
      "bn": "0.9569262073510604",
      "bg": "0.999999801369619",
      "zh": "0.9712095194208982",
      "fr": "0.999999801369619",
      "de": "0.9884041569855643",
      "ha": "0.9940142734675137",
      "hi": "0.9905803514401825",
      "hu": "0.9623253783683506"
    },
    "canonical_solution": "count := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}",
    "instruction": {
      "en": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func countPowerNumbers(n int, k int) int\ncount := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9243263933244714",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9364712507120876",
      "ha": "0.9528896407476694",
      "hi": "0.904317560521303",
      "hu": "0.9407235299092824"
    },
    "level": "",
    "test": "func TestCountPowerNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(99, countPowerNumbers(99, 1))\n\tassert.Equal(7, countPowerNumbers(99, 3))\n\tassert.Equal(12, countPowerNumbers(99, 2))\n\tassert.Equal(10, countPowerNumbers(10, 1))\n\tassert.Equal(4, countPowerNumbers(10, 2))\n\tassert.Equal(500, countPowerNumbers(500, 1))\n\tassert.Equal(30, countPowerNumbers(500, 2))\n\tassert.Equal(13, countPowerNumbers(500, 3))\n\tassert.Equal(1000, countPowerNumbers(1000, 1))\n\tassert.Equal(41, countPowerNumbers(1000, 2))\n\tassert.Equal(17, countPowerNumbers(1000, 3))\n\tassert.Equal(1, countPowerNumbers(1000, 93))\n\tassert.Equal(10, countPowerNumbers(50, 2))\n\tassert.Equal(5, countPowerNumbers(50, 3))\n\tassert.Equal(1, countPowerNumbers(2, 3))\n}",
    "entry_point": "countPowerNumbers",
    "signature": "func countPowerNumbers(n int, k int) int",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n,\nqë mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hy": "Երկու դրական ամբողջ թիվ n և k ունենալով, գտեք դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, \nորոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "给定两个正整数 n 和 k，找到多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示仅计数一次。\n    >>> countPowerNumbers(99, 1)\n    99",
      "fr": "Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n,\ndie als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "An ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya daban-daban wakilcin doka na wannan lambar sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।  \n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Két pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Ugyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "sq": "0.9364188122914944",
      "hy": "0.9772860200375174",
      "bn": "0.960448917158714",
      "bg": "0.9902889606712043",
      "zh": "0.9583978598441478",
      "fr": "1",
      "de": "0.9806667091227312",
      "ha": "0.9749850857036093",
      "hi": "0.960448917158714",
      "hu": "0.9458632896489412"
    }
  },
  {
    "task_id": "Go/41",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\nmodulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԵրեք ամբողջ թիվ n, m և k տրված են, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')',\nայնպիսին, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի\nմոդուլո 1,000,000,007 (10^9 + 7)։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত কতগুলো ক্রম আছে,\nযাতে দীর্ঘতম ভারসাম্যপূর্ণ উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা\nমডুলো করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подпоследователност е с дължина 2 * k. Резултатът трябва да бъде изчислен\nмодуло 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模计算。\n\n例如:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné trois entiers n, m, et k, trouvez le nombre de séquences composées de n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être\ncalculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen bestehend aus n '(' und m ')',\nso dass die längste ausbalancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte berechnet werden\nmodulo 1.000.000.007 (10^9 + 7).\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba lambobi guda uku n, m, da k, nemo adadin jerin abubuwa da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jerin abubuwa masu daidaituwa zai kasance mai tsawon 2 * k. A sakamakon ya kamata a ƙididdige\nmodulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nतीन पूर्णांक n, m, और k दिए गए हैं, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम की गणना\n1,000,000,007 (10^9 + 7) के मापांक में की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott három egész szám: n, m és k. Találd meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt a 1,000,000,007 (10^9 + 7) modulusával\nkell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9895935557072012",
      "bn": "0.9658721224521096",
      "bg": "1",
      "zh": "0.9841532682010367",
      "fr": "0.9960683102377954",
      "de": "0.9963819476094495",
      "ha": "0.9843646109264578",
      "hi": "0.9864512230792293",
      "hu": "0.9511724811036227"
    },
    "canonical_solution": "const P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}",
    "instruction": {
      "en": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 символа.",
      "zh": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func countBalancedSubsequences(n, m, k int64) int64\nconst P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.9243263933244714",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9528896407476694",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCountBalancedSubsequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), countBalancedSubsequences(2, 2, 2))\n\tassert.Equal(int64(0), countBalancedSubsequences(3, 2, 3))\n\tassert.Equal(int64(4), countBalancedSubsequences(3, 2, 1))\n\tassert.Equal(int64(14), countBalancedSubsequences(4, 3, 2))\n\tassert.Equal(int64(35), countBalancedSubsequences(5, 5, 2))\n\tassert.Equal(int64(6), countBalancedSubsequences(6, 1, 1))\n\tassert.Equal(int64(6), countBalancedSubsequences(1, 6, 1))\n\tassert.Equal(int64(27), countBalancedSubsequences(7, 2, 2))\n\tassert.Equal(int64(110), countBalancedSubsequences(8, 3, 3))\n\tassert.Equal(int64(10659), countBalancedSubsequences(10, 10, 5))\n\tassert.Equal(int64(574221648), countBalancedSubsequences(20, 20, 10))\n\tassert.Equal(int64(854104531), countBalancedSubsequences(2000, 2000, 1000))\n\tassert.Equal(int64(334874485), countBalancedSubsequences(2000, 1999, 1000))\n\tassert.Equal(int64(259428024), countBalancedSubsequences(2000, 2000, 1999))\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "func countBalancedSubsequences(n, m, k int64) int64",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\nmodulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')'-ից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n টি '(' এবং m টি ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен\nмодул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Étant donné trois entiers n, m et k, trouvez le nombre de séquences composées de n '(' et m ')', \ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé \nmodulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen bestehend aus n '(' und m ')',\nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte berechnet werden\nmodulo 1,000,000,007 (10^9 + 7).\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jeri mai daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi\nmodulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या ज्ञात करें जो n '(' और m ')' से बने होते हैं, \nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg az n '(' és m ')' karakterekből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9996007529341199",
      "hy": "0.9691904415976785",
      "bn": "0.9591834430011408",
      "bg": "0.9932205464648982",
      "zh": "0.9732657411253713",
      "fr": "0.9942174723473123",
      "de": "0.9910693794382904",
      "ha": "0.9491847868806066",
      "hi": "0.9580266196619937",
      "hu": "0.9605236021819832"
    }
  },
  {
    "task_id": "Go/42",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me\nkëndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur\ntë operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet\nrastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota dhe pret (jo vetëm prek\nskajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë.\nPërgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝\nիր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, անհրաժեշտ է հաշվարկել գործողությունների\nսպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր։ Յուրաքանչյուր գործողության ժամանակ\nպատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և\nկտրում է թուղթը (ոչ միայն հպվում է եզրին)։ Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա անտեսվում է։\nՊատասխանը պետք է լինի 10^9+7 մոդուլով։\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি আয়তাকার কাগজ যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম\nকোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, তোমাকে হিসাব করতে হবে কতগুলি অপারেশন প্রয়োজন\nযাতে কাগজের অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বাছাই করা হয় যা\nঅক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্কযুক্ত বিন্দুগুলোর মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র\nধারের স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাদ দেওয়া হয়।\nউত্তরটি 10^9+7 মডুলোতে হতে হবে।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с\nдолния ляв ъгъл на (0,0) и горния десен ъгъл на (n,m), трябва да изчислите очаквания брой операции за\nрязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира произволна\nлиния, която е успоредна на осите, преминава през точки с цели координати и пресича (не само докосва\nръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，\n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，\n该线通过整数坐标的点，并切割（不仅仅是触碰边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应对 10^9+7 取模。\n\n例如:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche\nà (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour\ncouper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard qui\nest parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem mit seiner\nlinken unteren Ecke bei (0,0) und der rechten oberen Ecke bei (n,m) platziert ist. Sie müssen die erwartete\nAnzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist.\nBei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit\nganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder\nrechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba takardar murabba'i mai girman n x m a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0)\nda kusurwar sama-dama a (n,m), kuna buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar \nta yadda yankin da ya rage ya kasance ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da \nmakamai, ya wuce ta wuraren da suke da daidaitattun lambobi, kuma ya yanke (ba kawai taɓa gefen ba) takardar. \nSannan ana yar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिया गया एक आयताकार कागज जिसका आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \nजिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, आपको उन ऑपरेशनों की अपेक्षित संख्या \nकी गणना करनी है जिनसे कागज का शेष क्षेत्रफल k से कम हो जाए। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप \nसे चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को \nकाटती है (सिर्फ किनारे को छूती नहीं है)। इस रेखा के साथ कागज का निचला या दायां हिस्सा फिर त्याग दिया जाता है।\nउत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy n x m méretű téglalap alakú papír, amely egy derékszögű koordináta-rendszerben van elhelyezve, \naz alsó-bal sarka a (0,0) pontban és a jobb-felső sarka a (n,m) pontban található. Ki kell számítani a \nvárható műveletek számát, hogy a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész \nkoordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén \nlévő alsó vagy jobb részét eldobja. \nA válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9680850635272193",
      "hy": "0.8531203811791795",
      "bn": "0.9532569083222029",
      "bg": "0.9585666956680275",
      "zh": "0.9581783732731043",
      "fr": "0.9781856170332245",
      "de": "0.9667911852251581",
      "ha": "0.9575354067296944",
      "hi": "0.9664461642533004",
      "hu": "0.9458239608334963"
    },
    "canonical_solution": "const MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "en": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nՏվեք տվյալ Go կոդի համառոտ բնութագրությունը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nBa da takaitaccen bayani na harshen halitta (docstring) na lambar Go cikin Hausa ba tare da wuce haruffa 500 ba.",
      "hi": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "func expectedCuts(n int, m int, k int64) int64\nconst MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8865520592415426",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9065289125533644",
      "hi": "0.9324170060047845",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestExpectedCuts(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(int64(0), expectedCuts(2, 4, 10))\n\tassert.Equal(int64(1), expectedCuts(2, 4, 8))\n\tassert.Equal(int64(833333342), expectedCuts(2, 4, 2))\n\tassert.Equal(int64(250000003), expectedCuts(2, 4, 6))\n\tassert.Equal(int64(666666673), expectedCuts(3, 3, 4))\n\tassert.Equal(int64(666666673), expectedCuts(5, 5, 12))\n\tassert.Equal(int64(722222229), expectedCuts(6, 7, 20))\n\tassert.Equal(int64(72727275), expectedCuts(8, 8, 30))\n\tassert.Equal(int64(714285721), expectedCuts(10, 10, 50))\n\tassert.Equal(int64(945634929), expectedCuts(1, 10, 5))\n\tassert.Equal(int64(945634929), expectedCuts(10, 1, 5))\n}",
    "entry_point": "expectedCuts",
    "signature": "func expectedCuts(n int, m int, k int64) int64",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që zona e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվարկել սպասվող գործողությունների քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը): Այս գծի երկայնքով թղթի ներքևի կամ աջ մասը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bn": "একটি আয়তাকার কাগজের টুকরা আকার n x m একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, আপনাকে কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট ক্ষেত্রফল k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের সাথে কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 দ্বারা মডুলো হতে হবে।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за изрязване на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модуло 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 位置，右上角在 (n,m) 位置。你需要计算期望的操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标点，并切割（不仅仅是接触边缘）纸张。然后丢弃沿此线的纸张底部或右侧部分。答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "de": "Angenommen, ein rechteckiges Papier der Größe n x m liegt in einem kartesischen Koordinatensystem mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "ha": "An ba takarda mai murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ƙasa ko ɓangaren dama na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hi": "दिया गया एक आयताकार कागज जिसका आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर (0,0) और ऊपरी-दाईं कोने पर (n,m) है, आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करने की आवश्यकता है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। इस रेखा के साथ कागज का निचला या दायां भाग फिर त्याग दिया जाता है। उत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hu": "Adott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el, bal alsó sarka a (0,0) pontban, jobb felső sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát ahhoz, hogy a papír megmaradt területe kisebb legyen, mint k. Minden művelet során véletlenszerűen választanak egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A vonal mentén a papír alsó vagy jobb oldali részét elvetik. A válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9563746107829265",
      "hy": "0.9541708067053444",
      "bn": "0.9466240440083048",
      "bg": "0.9437750884531214",
      "zh": "0.9226894803543629",
      "fr": "0.9635940306120205",
      "de": "0.9577987906149467",
      "ha": "0.9475796547714637",
      "hi": "0.9559016718456824",
      "hu": "0.9185466464971183"
    }
  },
  {
    "task_id": "Go/43",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 ≤ x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografikisht që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment. Kjo përfshin zgjedhjen e k-1 pikave të ndarjes me 1 ≤ x1 < x2 < ... < x(k-1) < n, dhe ndarjen e p në segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Rezultati duhet të jetë modulo 998244353.\nShembull:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n տարրերի q փոխատեղում և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով։ Սա ներառում է ընտրել k-1 կոտրման կետեր 1 ≤ x1 < x2 < ... < x(k-1) < n պայմանով, և p-ն բաժանել հատվածների [1, x1], (x1, x2], ..., (x(k-1), n]։ Արդյունքը պետք է լինի 998244353 մոդուլով։\nՕրինակ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যেন f(p) = q, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি নয় এমন সংলগ্ন segment এ ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যেতে পারে। এটি 1 ≤ x1 < x2 < ... < x(k-1) < n সহ k-1 টি breakpoints নির্বাচন করার সাথে জড়িত, এবং p কে segment গুলিতে ভাগ করা [1, x1], (x1, x2], ..., (x(k-1), n]। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\nউদাহরণ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент. Това включва избиране на k-1 точки на прекъсване с 1 ≤ x1 < x2 < ... < x(k-1) < n, и разделяне на p на сегменти [1, x1], (x1, x2], ..., (x(k-1), n]. Резултатът трябва да бъде модуло 998244353.\nПример:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由n个元素组成的排列q和一个整数k，找出n个元素的排列p的数量，使得f(p) = q，其中f(p)是通过将p分成恰好k个非空连续段并对每个段进行排序后可以得到的字典序最小的排列。这涉及选择k-1个断点，满足1 ≤ x1 < x2 < ... < x(k-1) < n，并将p分成段[1, x1], (x1, x2], ..., (x(k-1), n]。结果应取模998244353。\n例子:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment. Cela implique de choisir k-1 points de rupture avec 1 ≤ x1 < x2 < ... < x(k-1) < n, et de diviser p en segments [1, x1], (x1, x2], ..., (x(k-1), n]. Le résultat doit être modulo 998244353.\nExemple:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird. Dies beinhaltet die Auswahl von k-1 Trennpunkten mit 1 ≤ x1 < x2 < ... < x(k-1) < n, und das Teilen von p in Segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Das Ergebnis sollte modulo 998244353 sein.\nBeispiel:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo yawan permutations p na abubuwa n da suke cika f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically da za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da babu komai kuma a tsara kowanne sashe. Wannan yana nufin zaɓar k-1 wuraren tsayawa tare da 1 ≤ x1 < x2 < ... < x(k-1) < n, da kuma raba p zuwa sassa [1, x1], (x1, x2], ..., (x(k-1), n]. Sakamakon ya zama modulo 998244353.\nMisali:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है। इसमें k-1 ब्रेकपॉइंट्स चुनना शामिल है जहाँ 1 ≤ x1 < x2 < ... < x(k-1) < n, और p को खंडों में विभाजित करना [1, x1], (x1, x2], ..., (x(k-1), n]। परिणाम को 998244353 से मॉड्यूलो किया जाना चाहिए।\nउदाहरण:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) az a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk. Ez magában foglalja k-1 töréspont kiválasztását 1 ≤ x1 < x2 < ... < x(k-1) < n, és p felosztását szegmensekre [1, x1], (x1, x2], ..., (x(k-1), n]. Az eredménynek modulo 998244353 kell lennie.\nPélda:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.8817009094455275",
      "hy": "0.9865974150396709",
      "bn": "0.9943799519989989",
      "bg": "0.9950286788234588",
      "zh": "0.9888117465274479",
      "fr": "0.9958259811729329",
      "de": "0.994141992802519",
      "ha": "0.9631292355203989",
      "hi": "0.9898682615241724",
      "hu": "0.9877296082115697"
    },
    "canonical_solution": "const N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nՏվեք Go կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\n将以下 Go 代码的自然语言描述（文档字符串）简洁地翻译成中文，字数不超过500个字符。",
      "fr": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func CountPermutations(n int, k int, qq []int) int\nconst N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.9229258505077944",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8456234747077798",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9113071649995397",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCountPermutations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, CountPermutations(2, 1, []int{1, 2}))\n\tassert.Equal(1, CountPermutations(3, 3, []int{3, 1, 2}))\n\tassert.Equal(13, CountPermutations(6, 3, []int{1, 2, 3, 6, 5, 4}))\n\tassert.Equal(720, CountPermutations(6, 1, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(0, CountPermutations(6, 3, []int{1, 2, 5, 3, 4, 5}))\n\tassert.Equal(1, CountPermutations(9, 9, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(29093, CountPermutations(9, 2, []int{1, 2, 3, 4, 5, 6, 7, 9, 8}))\n}",
    "entry_point": "CountPermutations",
    "signature": "func CountPermutations(n int, k int, qq []int) int",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 ≤ x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n",
      "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment. Kjo përfshin zgjedhjen e k-1 pikave të ndarjes me 1 ≤ x1 < x2 < ... < x(k-1) < n, dhe ndarjen e p në segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Rezultati duhet të jetë modulo 998244353.\nShembull:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hy": "Տրված է n տարրերի փոխատեղում q և ամբողջ թիվ k, գտնել n տարրերի այն փոխատեղումների p քանակը, որոնց համար f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով։ Սա ներառում է k-1 կոտրման կետերի ընտրություն 1 ≤ x1 < x2 < ... < x(k-1) < n, և p-ն բաժանելով հատվածների [1, x1], (x1, x2], ..., (x(k-1), n]։ Արդյունքը պետք է լինի 998244353 մոդուլով։\nՕրինակ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশনের সংখ্যা খুঁজে বের করুন যেখানে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা ঠিক k টি খালি নয় এমন সংলগ্ন সেগমেন্টে p কে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে প্রাপ্ত করা যায়। এটি 1 ≤ x1 < x2 < ... < x(k-1) < n সহ k-1 টি ব্রেকপয়েন্ট নির্বাচন করা জড়িত, এবং p কে সেগমেন্টে ভাগ করা [1, x1], (x1, x2], ..., (x(k-1), n]। ফলাফলটি 998244353 দ্বারা মডুলো হবে।\nউদাহরণ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент. Това включва избиране на k-1 точки на прекъсване с 1 ≤ x1 < x2 < ... < x(k-1) < n, и разделяне на p на сегменти [1, x1], (x1, x2], ..., (x(k-1), n]. Резултатът трябва да бъде по модул 998244353.\nПример:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是可以通过将 p 分成恰好 k 个非空连续段并对每个段进行排序得到的字典序最小的排列。这涉及选择 k-1 个断点，满足 1 ≤ x1 < x2 < ... < x(k-1) < n，并将 p 分成段 [1, x1], (x1, x2], ..., (x(k-1), n]。结果应对 998244353 取模。\n示例：\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment. Cela implique de choisir k-1 points de coupure avec 1 ≤ x1 < x2 < ... < x(k-1) < n, et de diviser p en segments [1, x1], (x1, x2], ..., (x(k-1), n]. Le résultat doit être modulo 998244353.\nExemple :\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch das Teilen von p in genau k nicht-leere zusammenhängende Segmente und das Sortieren jedes Segments erhalten werden kann. Dies beinhaltet die Wahl von k-1 Trennpunkten mit 1 ≤ x1 < x2 < ... < x(k-1) < n, und das Teilen von p in Segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Das Ergebnis sollte modulo 998244353 sein.\nBeispiel:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "ha": "An ba da permutation q na abubuwa n da kuma integer k, nemo yawan permutations p na abubuwa n inda f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassan da ba su da komai kuma a tsara kowane sashe. Wannan yana nufin zaɓar k-1 wuraren tsayawa tare da 1 ≤ x1 < x2 < ... < x(k-1) < n, da kuma raba p zuwa sassa [1, x1], (x1, x2], ..., (x(k-1), n]. Sakamakon ya zama modulo 998244353.\nMisali:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या ज्ञात करें जिनके लिए f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है। इसमें k-1 ब्रेकपॉइंट्स चुनना शामिल है जहाँ 1 ≤ x1 < x2 < ... < x(k-1) < n, और p को खंडों में विभाजित करना [1, x1], (x1, x2], ..., (x(k-1), n]। परिणाम को 998244353 से मापांकित करना चाहिए।\nउदाहरण:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hu": "Adott egy q permutáció n elemre és egy egész szám k, keressük meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kaphatunk meg, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk. Ez magában foglalja k-1 töréspont kiválasztását 1 ≤ x1 < x2 < ... < x(k-1) < n, és p felosztását szegmensekre [1, x1], (x1, x2], ..., (x(k-1), n]. Az eredményt 998244353-mal kell modulozni.\nPélda:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2"
    },
    "docstring_bertscore": {
      "sq": "0.9747278593601691",
      "hy": "0.984707844224886",
      "bn": "0.9758713744637869",
      "bg": "0.9979918468477372",
      "zh": "0.9884063419197556",
      "fr": "0.9898525697240707",
      "de": "1",
      "ha": "0.9630495847376039",
      "hi": "0.9860446266892509",
      "hu": "0.9850429336776919"
    }
  },
  {
    "task_id": "Go/44",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës,\ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD)\ni vlerave maksimale dhe minimale të treshes të jetë 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները,\nգտնել եղանակների քանակը, որով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների\nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nকিরার বন্ধুদের উচ্চতা উপস্থাপনকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\n(ক, খ, গ) ত্রয়ী বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের\nমহানতম সাধারণ বিভাজক (GCD) 1 হয়।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\nнамерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД)\nна максималната и минималната стойност на тройката да е 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\ntrouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\ndes valeurs maximum et minimum du triplet soit 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ein Array von n verschiedenen ganzen Zahlen, das die Höhen von Kiras Freunden darstellt,\nfinde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\nnemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kashi (GCD)\nna mafi girma da mafi ƙarancin ƙimomin triplet ɗin shine 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n भिन्न पूर्णांकों की एक array जो कि किरा के दोस्तों की ऊँचाईयों का प्रतिनिधित्व करती है,\nउन तरीकों की संख्या खोजें जिनसे एक तिकड़ी (a, b, c) चुनी जा सकती है ताकि तिकड़ी के अधिकतम और न्यूनतम\nमूल्यों का महत्तम समापवर्तक (GCD) 1 हो।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\ntaláljuk meg, hányféleképpen választhatunk ki egy hármast (a, b, c) úgy, hogy a hármas\nmaximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.99175068164524",
      "bn": "1",
      "bg": "0.9983902993920932",
      "zh": "0.9969281811572954",
      "fr": "1",
      "de": "0.9969281811572954",
      "ha": "0.9608676300019356",
      "hi": "0.9900295493935728",
      "hu": "0.980301626482389"
    },
    "canonical_solution": "count := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "en": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n将以下 Go 代码的自然语言描述（文档字符串）翻译成中文，字数不超过500个字符。",
      "fr": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "func countTriplets(heights []int, n int) int\ncount := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8837444188056144",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8318029248925518",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9303623733433596",
      "hi": "0.9188825304714482",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCountTriplets(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, countTriplets([]int{1, 5, 7}, 3))\n\tassert.Equal(3, countTriplets([]int{1, 6, 2, 3}, 4))\n\tassert.Equal(0, countTriplets([]int{16, 4, 8, 2}, 4))\n\tassert.Equal(77, countTriplets([]int{10, 1, 6, 7, 9, 8, 4, 3, 5, 2}, 10))\n\tassert.Equal(7, countTriplets([]int{4, 5, 9, 11, 14}, 5))\n\tassert.Equal(104, countTriplets([]int{15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}, 11))\n\tassert.Equal(4, countTriplets([]int{3, 7, 11, 13}, 4))\n\tassert.Equal(10, countTriplets([]int{5, 12, 13, 17, 19}, 5))\n\tassert.Equal(87, countTriplets([]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 11))\n\tassert.Equal(122, countTriplets([]int{1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}, 11))\n}",
    "entry_point": "countTriplets",
    "signature": "func countTriplets(heights []int, n int) int",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n",
      "sq": "Duke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hy": "Տրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, \nգտեք եռյակ (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "bn": "Kira এর বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে, এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রীটেস্ট কমন ডিভাইজর (GCD) হয় 1।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "de": "Angenommen, ein Array von n verschiedenen ganzen Zahlen stellt die Größen von Kiras Freunden dar,\nfinden Sie die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GGT)\nder maximalen und minimalen Werte des Tripels 1 ist.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "ha": "An ba da wani tsararraki na lambobi daban-daban n da ke wakiltar tsayin abokan Kira, nemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ke raba su baki ɗaya (GCD) na mafi girma da mafi ƙarancin ƙimomin triplet ɗin ya zama 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hi": "Kira के दोस्तों की ऊँचाईयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है, \nऐसे triplet (a, b, c) को चुनने के तरीकों की संख्या खोजें कि triplet के अधिकतम और न्यूनतम मानों का \nमहानतम समापवर्तक (GCD) 1 हो।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hu": "Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik, \ntalálja meg, hányféleképpen lehet választani egy hármast (a, b, c) úgy, hogy a hármas \nmaximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9934267248004125",
      "hy": "0.9759822102164044",
      "bn": "0.9439592188163408",
      "bg": "0.996191461074037",
      "zh": "1",
      "fr": "1",
      "de": "0.989399096564168",
      "ha": "0.9496408422354627",
      "hi": "0.9290110908611793",
      "hu": "0.9589073467715024"
    }
  },
  {
    "task_id": "Go/45",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJu jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë.\nJu mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës\nngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë.\nGjeni numrin minimal të operacioneve të kërkuara për t'i bërë të gjithë piksela të së njëjtës ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով:\nԴուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները\nընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը:\nԳտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում. Յուրաքանչյուր գույնի համար այդ գույնի առավելագույնը 20 պիքսել կա:\n\nՕրինակներ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nআপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়।\nআপনি এমন একটি অপারেশন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলিকে নির্বাচিত রঙে পরিবর্তন করেন।\nদুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় এবং একই রঙ থাকে।\nসমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nদ্রষ্টব্য: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен от цяло число.\nМожете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия\nцвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят.\nНамерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。\n你可以执行一个操作，选择一种颜色并将所有相同颜色的相连像素更改为所选颜色。\n如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。\n找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n例子:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nOn vous donne une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier.\nVous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même\ncouleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur.\nTrouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSie haben ein 1xN-Pixel-Bild, bei dem jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird.\nSie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben\nFarbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben.\nFinden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba.\nKuna iya aiwatar da aiki inda kuke ɗaukar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya\nzuwa launin da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa kuma suna da launi ɗaya.\nNemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai pixels mafi yawa 20 na wannan launi.\n\nMisalai:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nआपको 1 बाई n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है।\nआप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने हुए रंग में बदल देते हैं।\nदो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है।\nसभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशन की संख्या खोजें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy 1 x n pixeles képet kap, ahol minden pixel színe egy egész számmal van reprezentálva.\nVégezhet egy olyan műveletet, ahol kiválaszt egy színt, és az összes összekapcsolt azonos színű\npixelt megváltoztatja a választott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek.\nKeresse meg a minimális műveletszámot, amely szükséges ahhoz, hogy minden pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.8774557809420499",
      "hy": "0.9921868739619927",
      "bn": "0.9864573806210413",
      "bg": "0.9850755090601816",
      "zh": "0.9656258207796264",
      "fr": "0.9914811402181757",
      "de": "0.983204212240452",
      "ha": "0.9903203442714078",
      "hi": "0.9791150085860867",
      "hu": "0.9633036329949475"
    },
    "canonical_solution": "n := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "en": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nՏվեք կարճ բնութագիր (docstring) Go ծրագրի կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nগো কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n请用最多500个字符的中文为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func minOperations(pixels []int) int\nn := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.887608176977505",
      "bn": "0.9223740553092795",
      "bg": "0.8329297550441628",
      "zh": "0.8793532969720762",
      "fr": "0.9611900071103553",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestMinOperations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, minOperations([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(1, minOperations([]int{1, 1, 2, 2}))\n\tassert.Equal(3, minOperations([]int{1, 2, 1, 4, 2}))\n\tassert.Equal(0, minOperations([]int{5, 5, 5, 5, 5}))\n\tassert.Equal(1, minOperations([]int{1, 1, 1, 2, 2, 2}))\n\tassert.Equal(2, minOperations([]int{1, 3, 3, 3, 2, 2, 2}))\n\tassert.Equal(1, minOperations([]int{4, 4, 4, 4, 3, 3, 3, 3}))\n\tassert.Equal(8, minOperations([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(5, minOperations([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}))\n\tassert.Equal(0, minOperations([]int{3, 3, 3}))\n\tassert.Equal(1, minOperations([]int{2, 1, 1, 2}))\n}",
    "entry_point": "minOperations",
    "signature": "func minOperations(pixels []int) int",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n",
      "sq": "Ju jepet një imazh me përmasa 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë.\nJu mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur me të njëjtën\nngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë.\nGjeni numrin minimal të operacioneve të kërkuara për t'i bërë të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hy": "Ձեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։  \nԴուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր կապված պիքսելները ընտրված գույնով։ Երկու պիքսել կապված են, եթե նրանք հարակից են և ունեն նույն գույնը։  \nԳտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնի։\n\nՕրինակներ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "bn": "আপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "bg": "Дадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "zh": "你有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有相同颜色的相连像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是相连的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "de": "Du hast ein 1 mal n Pixel Bild, wobei jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "ha": "An ba ku hoton pixel 1 ta n, inda kowanne pixel ke da launi da aka wakilta ta hanyar lamba. Kuna iya aiwatar da aiki inda kuke ɗaukar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna makwabta kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai mafi yawan pixels 20 na wannan launi.\n\nMisalai:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hi": "आपको 1 बाई n पिक्सेल की छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hu": "Meg van adva egy 1 x n pixeles kép, ahol minden pixel színe egy egész számmal van reprezentálva. \nVégrehajthatsz egy műveletet, amely során kiválasztasz egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatod a választott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. \nTaláld meg a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n\nPéldák:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2"
    },
    "docstring_bertscore": {
      "sq": "0.9716459103680318",
      "hy": "0.9942111161751193",
      "bn": "0.9761937515722066",
      "bg": "0.9753354696957548",
      "zh": "0.9615836925255664",
      "fr": "0.9787018573935341",
      "de": "0.983404034403773",
      "ha": "0.986228161161327",
      "hi": "0.9787312546899273",
      "hu": "0.9615004663959128"
    }
  },
  {
    "task_id": "Go/46",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n\nqë janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,\nduhet të numërohet vetëm një herë.\n\nPër shembull:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր թվերի գումարը,\nորոնք բազմապատիկ են կամ 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի,\nայն պետք է հաշվել միայն մեկ անգամ։\n\nՕրինակ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি পূর্ণসংখ্যা n দেওয়া আছে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন\nযেগুলি ৩ বা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়,\nতাহলে এটি কেবল একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\nкоито са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5,\nтрябва да се брои само веднъж.\n\nНапример:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。\n如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n\n例如:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n\nqui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et 5,\nil ne doit être compté qu'une seule fois.\n\nPar exemple :\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine ganze Zahl n, schreibe eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen,\ndie Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist,\nsollte sie nur einmal gezählt werden.\n\nZum Beispiel:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba ku lamba n, rubuta wata aiki don ƙididdige jumlar duk lambobi daga 1 zuwa n\nwadanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5,\nya kamata a ƙirga ta sau ɗaya kawai.\n\nMisali:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए पूर्णांक n के लिए, 1 से n तक के उन सभी संख्याओं का योग गणना करने के लिए एक फ़ंक्शन लिखें\nजो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों के गुणज है,\nतो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az 1-től n-ig terjedő összes szám összegét,\namelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse,\nakkor csak egyszer kell számolni.\n\nPéldául:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9939995748193171",
      "hy": "0.9946663770084512",
      "bn": "0.9939995748193171",
      "bg": "0.9896136173756857",
      "zh": "0.9913865921568031",
      "fr": "0.9945597124938355",
      "de": "0.9984079774960054",
      "ha": "0.9905545294906479",
      "hi": "0.9900527891481539",
      "hu": "0.9886220545135596"
    },
    "canonical_solution": "sum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}",
    "instruction": {
      "en": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nনিচের Go কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки максимум 500 знака.",
      "zh": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Go cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func sumOfMultiples(n int) int\nsum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8837444188056144",
      "bn": "0.873551104911666",
      "bg": "0.8412363254818621",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestSumOfMultiples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(33, sumOfMultiples(10))\n\tassert.Equal(60, sumOfMultiples(15))\n\tassert.Equal(98, sumOfMultiples(20))\n\tassert.Equal(8, sumOfMultiples(5))\n\tassert.Equal(3, sumOfMultiples(3))\n\tassert.Equal(14, sumOfMultiples(6))\n\tassert.Equal(23, sumOfMultiples(9))\n\tassert.Equal(45, sumOfMultiples(12))\n\tassert.Equal(60, sumOfMultiples(17))\n\tassert.Equal(119, sumOfMultiples(21))\n\tassert.Equal(168, sumOfMultiples(25))\n}",
    "entry_point": "sumOfMultiples",
    "signature": "func sumOfMultiples(n int) int",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n",
      "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n\nqë janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,\nduhet të numërohet vetëm një herë.\n\nPër shembull:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hy": "Տրված ամբողջ թիվ n-ի դեպքում, գրեք ֆունկցիա, որը կհաշվարկի 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\n\nՕրինակ՝\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা হয় ৩ অথবা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়ের গুণিতক হয়, তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\nкоито са кратни на 3 или 5. Ако едно число е кратно както на 3, така и на 5,\nто трябва да бъде преброено само веднъж.\n\nНапример:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 的所有数字中是 3 或 5 的倍数的总和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n\n例如：\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\n\nPar exemple :\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "de": "Gegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\n\nZum Beispiel:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "ha": "An ba da wani lamba n, rubuta wata aiki don lissafa jimillar dukkan lambobi daga 1 zuwa n\nwanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5,\nya kamata a kirga ta sau daya kawai.\n\nMisali:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hi": "एक पूर्णांक n दिया गया है, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az 1-től n-ig terjedő összes szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám 3-nak és 5-nek is többszöröse, akkor csak egyszer kell számolni.\n\nPéldául:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "sq": "0.9895691241703339",
      "hy": "0.9763419298364586",
      "bn": "0.9900519946266297",
      "bg": "0.9900519946266297",
      "zh": "0.9851692626000301",
      "fr": "0.9908419476520054",
      "de": "1",
      "ha": "0.9635260990217066",
      "hi": "0.9677390494034566",
      "hu": "0.9877226561482335"
    }
  },
  {
    "task_id": "Go/47",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the\nsame forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "sq": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet\nnjësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "hy": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՊարզել, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է\nնույն ձևով առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը)։\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "bn": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nনির্ধারণ করুন যে একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "bg": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете\nпо един и същ начин напред и назад (като се игнорират интервали, пунктуация и главни букви).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "zh": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n确定给定的字符串是否是回文。回文是指一个单词、短语、数字或其他字符序列，正着读和反着读都是一样的（忽略空格、标点和大小写）。\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "fr": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit\nde la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et les majuscules).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "de": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBestimmen Sie, ob eine gegebene Zeichenkette ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "ha": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGano idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya a gaba da baya (ana watsi da sarari, rubutu, da manyan baki).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "hi": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nनिर्धारित करें कि क्या दिया गया स्ट्रिंग एक पालिंड्रोम है। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम होता है जो आगे और पीछे से पढ़ने पर समान होता है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "hu": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHatározza meg, hogy egy adott sztring palindróm-e. Egy palindróm olyan szó, kifejezés, szám vagy más karakterek sorozata, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9971488595106253",
      "bn": "0.9991516496426",
      "bg": "0.9991516496426",
      "zh": "0.9885261160395197",
      "fr": "1",
      "de": "0.9944931713161888",
      "ha": "1",
      "hi": "0.9745633934046722",
      "hu": "0.9991516496426"
    },
    "canonical_solution": "str = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}",
    "instruction": {
      "en": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nՏվեք Go կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\n请用中文为以下 Go 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nBa da taƙaitaccen bayani a cikin harshen ɗan adam (docstring) na lambar Go cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "func IsPalindrome(str string) bool\nstr = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.9229258505077944",
      "bn": "0.8773334246273324",
      "bg": "0.8329297550441628",
      "zh": "0.8882789517742599",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.8858842639005032",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.True(IsPalindrome(\"A man a plan a canal Panama\"))\n\tassert.True(IsPalindrome(\"No lemon, no melon\"))\n\tassert.True(IsPalindrome(\"Was it a car or a cat I saw\"))\n\tassert.True(IsPalindrome(\"Madam, in Eden, I'm Adam\"))\n\tassert.True(IsPalindrome(\"Never odd or even\"))\n\tassert.True(IsPalindrome(\"Eva, can I see bees in a cave\"))\n\tassert.False(IsPalindrome(\"hello\"))\n\tassert.False(IsPalindrome(\"GitHub\"))\n\tassert.False(IsPalindrome(\"programming\"))\n}",
    "entry_point": "IsPalindrome",
    "signature": "func IsPalindrome(str string) bool",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "hy": "Հաստատեք, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়া যায় (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "zh": "确定给定的字符串是否是回文。回文是指无论从前往后还是从后往前读，字符序列都是相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et les majuscules).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "ha": "Gano idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jere na haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutun alama, da manyan ba).\n\n    >>> IsPalindrome(\"racecar\")\n    true",
      "hi": "दिया गया स्ट्रिंग पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों की अनुक्रम होता है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षर को नजरअंदाज करते हुए)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm egy olyan szó, kifejezés, szám vagy más karakterek sorozata, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9925545387972883",
      "bn": "0.9980681209140547",
      "bg": "1",
      "zh": "0.9980681209140547",
      "fr": "1",
      "de": "0.9907223721626225",
      "ha": "1",
      "hi": "0.9572289200517575",
      "hu": "1"
    }
  },
  {
    "task_id": "Go/48",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nfunc addDigits(num int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një numër të plotë jo-negativ num, shtoni vazhdimisht të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    addDigits(38) // kthen 2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n*/\nfunc addDigits(num int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, կրկնակիորեն գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    addDigits(38) // վերադարձնում է 2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը:\n*/\nfunc addDigits(num int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে কেবল একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    addDigits(38) // 2 ফেরত দেয়\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর কেবল একটি অঙ্ক রয়েছে, 2 হল ফলাফল।\n*/\nfunc addDigits(num int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    addDigits(38) // връща 2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n*/\nfunc addDigits(num int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个非负整数 num，反复将所有位上的数字相加，直到结果只有一位数字。\n例如：\n    addDigits(38) // 返回 2\n    因为 3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，2 是结果。\n*/\nfunc addDigits(num int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple:\n    addDigits(38) // retourne 2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n*/\nfunc addDigits(num int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    addDigits(38) // gibt 2 zurück\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n*/\nfunc addDigits(num int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    addDigits(38) // returns 2\n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n*/\nfunc addDigits(num int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिया गया एक गैर-ऋणात्मक पूर्णांक num, इसके सभी अंकों को तब तक बार-बार जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    addDigits(38) // 2 लौटाता है\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n*/\nfunc addDigits(num int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    addDigits(38) // visszaadja a 2-t\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n*/\nfunc addDigits(num int) int {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9966048108969706",
      "bn": "1",
      "bg": "0.9638476816086021",
      "zh": "0.969335640406215",
      "fr": "1",
      "de": "1",
      "ha": "0.9856479618183241",
      "hi": "0.9962814406366458",
      "hu": "0.9719321367471031"
    },
    "canonical_solution": "for num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}",
    "instruction": {
      "en": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nՏվեք կարճ բնութագրություն (docstring) Go կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nДайте кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func addDigits(num int) int\nfor num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.8935635130616931",
      "bn": "0.8784854808373347",
      "bg": "0.8329297550441628",
      "zh": "0.8845166256558257",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9303623733433596",
      "hi": "0.91027269797511",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestAddDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, addDigits(38))\n\tassert.Equal(0, addDigits(0))\n\tassert.Equal(9, addDigits(9))\n\tassert.Equal(6, addDigits(123))\n\tassert.Equal(6, addDigits(456))\n\tassert.Equal(9, addDigits(9999))\n\tassert.Equal(1, addDigits(100))\n\tassert.Equal(2, addDigits(1010))\n\tassert.Equal(1, addDigits(1234))\n\tassert.Equal(3, addDigits(9876))\n\tassert.Equal(1, addDigits(199))\n}",
    "entry_point": "addDigits",
    "signature": "func addDigits(num int) int",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    addDigits(38) // kthen 2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան։ Օրինակ՝\n    addDigits(38) // վերադարձնում է 2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է։",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, এর সমস্ত অঙ্কগুলি বারবার যোগ করুন যতক্ষণ না ফলাফলটি কেবল একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    addDigits(38) // 2 ফেরত দেয়\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর কেবল একটি অঙ্ক রয়েছে, তাই 2 হল ফলাফল।",
      "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    addDigits(38) // връща 2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.",
      "zh": "给定一个非负整数 num，重复相加其所有位数，直到结果只有一位数字。\n\n例如：\n    addDigits(38) // 返回 2\n    因为 3 + 8 = 11，而 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。",
      "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    addDigits(38) // renvoie 2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Comme 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Angenommen, eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    addDigits(38) // gibt 2 zurück\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nAn ba da wani lamba mara tabbatacce num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.  \n\nFor example:  \nMisali:  \n    addDigits(38) // returns 2  \n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.  \n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.  ",
      "hi": "दिया गया एक गैर-ऋणात्मक पूर्णांक num, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण के लिए:\n    addDigits(38) // 2 लौटाता है\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Adott egy nemnegatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    addDigits(38) // visszaadja a 2-t\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény."
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9907563379577794",
      "bn": "0.999999801369619",
      "bg": "0.9430105601165182",
      "zh": "0.964012942085623",
      "fr": "0.999999801369619",
      "de": "0.9258814705775935",
      "ha": "0.994677103049027",
      "hi": "0.9728106789224203",
      "hu": "0.9846158783584669"
    }
  },
  {
    "task_id": "Go/49",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh,\ndhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli.\nAi që heq gurin e fundit fiton lojën.\nDuke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju\nashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից,\nև դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։\nԱյն, ով հեռացնում է վերջին քարը, հաղթում է խաղը։\nՏրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք\nև ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n সংখ্যক পাথর দিয়ে শুরু করো,\nএবং তুমি এবং তোমার প্রতিদ্বন্দ্বী পালাক্রমে ১ থেকে ৩টি পাথর পাইল থেকে সরিয়ে নাও।\nযে শেষ পাথরটি সরায় সে গেমটি জিতে।\nপাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করো তুমি গেমটি জিততে পারবে কিনা যদি তুমি এবং\nতোমার প্রতিদ্বন্দ্বী উভয়েই সর্বোত্তমভাবে খেলে। নোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка,\nи вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината.\nТози, който премахне последния камък, печели играта.\nДаден е броят на камъните n, определете дали можете да спечелите играта, ако и вие,\nи вашият противник играете оптимално. Забележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，\n你和你的对手轮流从堆中移除 1 到 3 个石头。\n移除最后一个石头的人赢得游戏。\n给定石头的数量 n，如果你和你的对手都以最佳方式进行游戏，确定你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres,\net vous et votre adversaire prenez à tour de rôle 1 à 3 pierres du tas.\nCelui qui enlève la dernière pierre gagne la partie.\nÉtant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et\nvotre adversaire jouez de manière optimale. Remarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDu spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen,\nund du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen.\nDerjenige, der den letzten Stein entfernt, gewinnt das Spiel.\nAngesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du\nals auch dein Gegner optimal spielen. Hinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKana wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin duwatsu n,\nkai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin.\nWanda ya cire dutse na ƙarshe shi ne ya ci wasan.\nAn ba da adadin duwatsu n, tantance ko zaka iya cin nasara a wasan idan kai da\nabokin hamayyarka kuna wasa da hikima. Lura: Kai ne koyaushe kake fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं,\nऔर आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं।\nजो अंतिम पत्थर हटाता है वह खेल जीतता है।\nदिए गए पत्थरों की संख्या n के आधार पर निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों अनुकूल रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहां कुछ मामले दिए गए हैं:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz,\nés te és az ellenfeled felváltva távolítotok el 1-3 követ a halomból.\nAz nyer, aki az utolsó követ eltávolítja.\nAdott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha mindketten\noptimálisan játszotok. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {"
    },
    "prompt_bertscore": {
      "sq": "0.9973097501192635",
      "hy": "0.9773124378781951",
      "bn": "0.9789269056152466",
      "bg": "0.9900595425811091",
      "zh": "0.9830790751003999",
      "fr": "0.9935594098949437",
      "de": "0.9889414521662636",
      "ha": "0.9829332804007204",
      "hi": "0.9798439820844848",
      "hu": "0.9768686976069632"
    },
    "canonical_solution": "return n%4 != 0\n}",
    "instruction": {
      "en": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nՏվեք Go կոդի կարճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nПредоставете кратко описание на Go кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nBa da takaitaccen bayani na harshen halitta (docstring) na lambar Go a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func canWinNim(n int) bool\nreturn n%4 != 0\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9531867917976975",
      "hy": "0.8967263046189117",
      "bn": "0.8784854808373347",
      "bg": "0.8396865647158265",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.922712521478563",
      "hi": "0.904317560521303",
      "hu": "0.9402164265465004"
    },
    "level": "",
    "test": "func TestCanWinNim(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, canWinNim(1))\n\tassert.Equal(true, canWinNim(2))\n\tassert.Equal(true, canWinNim(3))\n\tassert.Equal(false, canWinNim(4))\n\tassert.Equal(true, canWinNim(5))\n\tassert.Equal(true, canWinNim(6))\n\tassert.Equal(true, canWinNim(7))\n\tassert.Equal(false, canWinNim(8))\n\tassert.Equal(true, canWinNim(9))\n\tassert.Equal(true, canWinNim(10))\n\tassert.Equal(true, canWinNim(11))\n\tassert.Equal(false, canWinNim(12))\n\tassert.Equal(true, canWinNim(13))\n\tassert.Equal(true, canWinNim(14))\n\tassert.Equal(true, canWinNim(15))\n\tassert.Equal(false, canWinNim(16))\n\tassert.Equal(true, canWinNim(17))\n\tassert.Equal(true, canWinNim(18))\n\tassert.Equal(true, canWinNim(19))\n\tassert.Equal(false, canWinNim(20))\n}",
    "entry_point": "canWinNim",
    "signature": "func canWinNim(n int) bool",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հանում եք 1-ից 3 քար կույտից։ Նա, ով հանում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը՝ n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե և դուք, և ձեր մրցակիցը խաղում եք օպտիմալ։ Նշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true",
      "bn": "আপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি n সংখ্যক পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩টি পাথর স্তূপ থেকে সরান। যে শেষ পাথরটি সরায় সে খেলা জিতে। পাথরের সংখ্যা n দেওয়া আছে, নির্ধারণ করুন আপনি খেলা জিততে পারেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন। দ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> canWinNim(1)\n    true",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. Забележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否可以赢得游戏。注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen. Hinweis: Du bist immer am Zug.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe shi ne zai ci wasa. An ba da adadin duwatsu n, tantance idan za ka iya cin wasa idan kai da abokin hamayyarka kuna wasa da kyau. Lura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम तरीके से खेलते हैं। ध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha te és az ellenfeled is optimálisan játszotok. Megjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9731253094459796",
      "bn": "0.9795857625891393",
      "bg": "0.9831736231617726",
      "zh": "0.9624505155084027",
      "fr": "0.9780644525007932",
      "de": "0.9948342196804256",
      "ha": "0.9822664782115862",
      "hi": "0.9819377449309735",
      "hu": "0.9781856170332245"
    }
  },
  {
    "task_id": "Go/50",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct llogarit shumën e dy numrave të plotë nëse shuma është çift,\nose prodhimin e dy numrave të plotë nëse shuma është tek.\n\nShembuj:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct հաշվում է երկու ամբողջ թվերի գումարը, եթե գումարը զույգ է,\nկամ երկու ամբողջ թվերի արտադրյալը, եթե գումարը կենտ է։\n\nՕրինակներ:\n\tEvenSumOrOddProduct(2, 3) // վերադարձնում է 6\n\tEvenSumOrOddProduct(5, 5) // վերադարձնում է 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct দুটি পূর্ণসংখ্যার যোগফল গণনা করে যদি যোগফলটি জোড় হয়,\nঅথবা দুটি পূর্ণসংখ্যার গুণফল যদি যোগফলটি বিজোড় হয়।\n\nউদাহরণ:\n\tEvenSumOrOddProduct(2, 3) // 6 প্রদান করে\n\tEvenSumOrOddProduct(5, 5) // 10 প্রদান করে\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct изчислява сумата на две цели числа, ако сумата е четна,\nили произведението на двете цели числа, ако сумата е нечетна.\n\nПримери:\n\tEvenSumOrOddProduct(2, 3) // връща 6\n\tEvenSumOrOddProduct(5, 5) // връща 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct 计算两个整数的和，如果和是偶数，\n则返回和；如果和是奇数，则返回两个整数的乘积。\n\n例子:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct calcule la somme de deux entiers si la somme est paire,\nou le produit des deux entiers si la somme est impaire.\n\nExemples :\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct berechnet die Summe von zwei ganzen Zahlen, wenn die Summe gerade ist,\noder das Produkt der beiden ganzen Zahlen, wenn die Summe ungerade ist.\n\nBeispiele:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct yana ƙididdige jumlar lambobi guda biyu idan jumlar ta zama lamba mai mafarin biyu,\nko kuma samfurin lambobi guda biyu idan jumlar ta zama lamba mai mafarin ɗaya.\n\nMisalai:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct दो पूर्णांकों का योग गणना करता है यदि योग सम है,\nया दो पूर्णांकों का गुणनफल यदि योग विषम है।\n\nउदाहरण:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct kiszámítja két egész szám összegét, ha az összeg páros,\nvagy a két egész szám szorzatát, ha az összeg páratlan.\n\nPéldák:\n\tEvenSumOrOddProduct(2, 3) // visszaadja: 6\n\tEvenSumOrOddProduct(5, 5) // visszaadja: 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9887519587827563",
      "hy": "0.9887519587827563",
      "bn": "0.9930956079552273",
      "bg": "0.9946137399574769",
      "zh": "0.9513679333985611",
      "fr": "0.9946137399574769",
      "de": "0.9946137399574769",
      "ha": "0.9673564872895833",
      "hi": "0.9873857790219984",
      "hu": "0.9882849787569433"
    },
    "canonical_solution": "sum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}",
    "instruction": {
      "en": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nProvide a concise natural language description (docstring) of the Go code in English using at most 500 characters.",
      "sq": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Go në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nՏվեք կարճ բնութագիր (docstring) Go կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nগো কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nПредоставете кратко описание на Go кода на български език, използвайки не повече от 500 знака.",
      "zh": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\n请用不超过500个字符的中文，为以下Go代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nFournissez une description concise en langage naturel (docstring) du code Go en français en utilisant au maximum 500 caractères.",
      "de": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Go-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Go cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nगो कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "func EvenSumOrOddProduct(a, b int) int\nsum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Go kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.953177853430551",
      "hy": "0.8946285691648022",
      "bn": "0.875873689957107",
      "bg": "0.8329297550441628",
      "zh": "0.8735256802228936",
      "fr": "0.967547569716139",
      "de": "0.9223377059495501",
      "ha": "0.9173586381881486",
      "hi": "0.904317560521303",
      "hu": "0.9515518651313993"
    },
    "level": "",
    "test": "func TestEvenSumOrOddProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, EvenSumOrOddProduct(2, 3))\n\tassert.Equal(10, EvenSumOrOddProduct(5, 5))\n\tassert.Equal(2, EvenSumOrOddProduct(1, 1))\n\tassert.Equal(0, EvenSumOrOddProduct(0, 0))\n\tassert.Equal(-2, EvenSumOrOddProduct(-1, -1))\n\tassert.Equal(300, EvenSumOrOddProduct(100, 200))\n\tassert.Equal(12, EvenSumOrOddProduct(3, 4))\n\tassert.Equal(0, EvenSumOrOddProduct(-5, 5))\n\tassert.Equal(56, EvenSumOrOddProduct(7, 8))\n\tassert.Equal(90, EvenSumOrOddProduct(9, 10))\n\tassert.Equal(154, EvenSumOrOddProduct(11, 14))\n}",
    "entry_point": "EvenSumOrOddProduct",
    "signature": "func EvenSumOrOddProduct(a, b int) int",
    "docstring": {
      "en": "EvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10",
      "sq": "EvenSumOrOddProduct llogarit shumën e dy numrave të plotë nëse shuma është çift,\nose prodhimin e dy numrave të plotë nëse shuma është tek.\n\nShembuj:\n\tEvenSumOrOddProduct(2, 3) // kthen 6\n\tEvenSumOrOddProduct(5, 5) // kthen 10",
      "hy": "EvenSumOrOddProduct-ը հաշվում է երկու ամբողջ թվերի գումարը, եթե գումարը զույգ է, կամ երկու ամբողջ թվերի արտադրյալը, եթե գումարը կենտ է։\n\nՕրինակներ:\n\tEvenSumOrOddProduct(2, 3) // վերադարձնում է 6\n\tEvenSumOrOddProduct(5, 5) // վերադարձնում է 10",
      "bn": "EvenSumOrOddProduct দুটি পূর্ণসংখ্যার যোগফল গণনা করে যদি যোগফলটি জোড় হয়,\nঅথবা দুটি পূর্ণসংখ্যার গুণফল যদি যোগফলটি বিজোড় হয়।\n\nউদাহরণসমূহ:\n\tEvenSumOrOddProduct(2, 3) // 6 রিটার্ন করে\n\tEvenSumOrOddProduct(5, 5) // 10 রিটার্ন করে",
      "bg": "EvenSumOrOddProduct изчислява сумата на две цели числа, ако сумата е четна, или произведението на двете цели числа, ако сумата е нечетна.\n\nПримери:\n\tEvenSumOrOddProduct(2, 3) // връща 6\n\tEvenSumOrOddProduct(5, 5) // връща 10",
      "zh": "EvenSumOrOddProduct 计算两个整数的和，如果和是偶数，则返回和；如果和是奇数，则返回两个整数的乘积。\n\n示例：\n\tEvenSumOrOddProduct(2, 3) // 返回 6\n\tEvenSumOrOddProduct(5, 5) // 返回 10",
      "fr": "EvenSumOrOddProduct calcule la somme de deux entiers si la somme est paire, ou le produit des deux entiers si la somme est impaire.\n\nExemples :\n\tEvenSumOrOddProduct(2, 3) // renvoie 6\n\tEvenSumOrOddProduct(5, 5) // renvoie 10",
      "de": "EvenSumOrOddProduct berechnet die Summe von zwei ganzen Zahlen, wenn die Summe gerade ist, oder das Produkt der beiden ganzen Zahlen, wenn die Summe ungerade ist.\n\nBeispiele:\n\tEvenSumOrOddProduct(2, 3) // gibt 6 zurück\n\tEvenSumOrOddProduct(5, 5) // gibt 10 zurück",
      "ha": "EvenSumOrOddProduct yana ƙididdige jumlar lambobi guda biyu idan jumlar ta zama maɗaukaki,\nko samfurin lambobi biyu idan jumlar ta zama marasa maɗaukaki.\n\nMisalai:\n\tEvenSumOrOddProduct(2, 3) // yana dawowa 6\n\tEvenSumOrOddProduct(5, 5) // yana dawowa 10",
      "hi": "EvenSumOrOddProduct दो पूर्णांकों का योग गणना करता है यदि योग सम है, या दो पूर्णांकों का गुणनफल यदि योग विषम है।\n\nउदाहरण:\n\tEvenSumOrOddProduct(2, 3) // 6 लौटाता है\n\tEvenSumOrOddProduct(5, 5) // 10 लौटाता है",
      "hu": "EvenSumOrOddProduct kiszámítja két egész szám összegét, ha az összeg páros,\nvagy a két egész szám szorzatát, ha az összeg páratlan.\n\nPéldák:\n\tEvenSumOrOddProduct(2, 3) // visszaadja: 6\n\tEvenSumOrOddProduct(5, 5) // visszaadja: 10"
    },
    "docstring_bertscore": {
      "sq": "0.9835625414478388",
      "hy": "0.9835625414478388",
      "bn": "0.9835625414478388",
      "bg": "0.9921121889387235",
      "zh": "0.9272919449133222",
      "fr": "0.9921121889387235",
      "de": "0.9921121889387235",
      "ha": "0.9756159357937761",
      "hi": "0.981479504641926",
      "hu": "0.9814548744746777"
    }
  }
]